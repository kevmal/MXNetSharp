namespace rec MXNetSharp
open System
open System.Collections.Generic
open System.Runtime.InteropServices
open MXNetSharp.Interop

type SymbolInitilizationException(symbol : Symbol, inner : Exception) =
    inherit Exception(
        match inner  with 
        | null -> sprintf "Init failed on symbol %O" symbol
        | ex -> sprintf "Init failed on symbol %O: %s %A" symbol ex.Message ex.StackTrace)


type ISymbolArguments = 
    abstract member Arguments : Symbol seq

type ISymbolComposable = 
    abstract member ComposedWith : Symbol -> Symbol

[<AbstractClass>]
type Symbol() =
    static let mutable count = 0L
    static let nameId() = Threading.Interlocked.Increment &count
    let sid = lazy(nameId())
    member x.Id = sid.Value
    member x.GeneratedName = sprintf "%s!%d" (x.GetType().Name) x.Id
    //let mutable disposed = false
    member val internal InternalName : string option = None with get,set
    member val internal InternalHandle : SafeSymbolHandle option = None with get,set
    member x.IsInitialized = x.InternalHandle.IsSome
    //member internal x.CreateId() = 
    //    assert(x.IsInitialized)
    //    match x.Id with 
    //    | None ->
    //        let sid = Guid.NewGuid()
    //        MXSymbol.setAttr x.UnsafeHandle "mxnetsharp_symbolid" (string sid)
    //    | _ -> ()
    //member x.Id = 
    //    if x.IsInitialized then 
    //        MXSymbol.getAttr x.UnsafeHandle "mxnetsharp_symbolid"
    //    else    
    //        None
    abstract member Copy : unit -> Symbol
    member x.Name 
        with get() = 
            if x.IsInitialized then 
                match MXSymbol.getName x.UnsafeHandle with 
                | Some name -> name
                | None ->
                    match x.InternalName with Some n -> n | _ -> x.GeneratedName
            else
                match x.InternalName with Some n -> n | _ -> x.GeneratedName
        and set v = 
            if x.IsInitialized then
                failwith "Cannot set name. Symbol has already been created." //TODO: make exception
            x.InternalName <- Some v 
    member x.SetName(name) = x.Name <- name; x
    member x.SetName(symbol : Symbol) =
        match symbol.InternalName with 
        | Some(n) -> x.SetName(n)
        | None -> x
    member x.SymbolHandle : SafeSymbolHandle = 
        match x.InternalHandle with 
        | Some h -> h
        | None -> 
            x.Initialize()
            match x.InternalHandle with
            | Some h -> h
            | None -> 
                // We should never really get to this point. Handle should be set or another excepion already thrown.
                raise (SymbolInitilizationException(x, null))
    member x.UnsafeHandle = x.SymbolHandle.UnsafeHandle //REVIEW: mark as internal?
    member x.Outputs = 
        let n = MXSymbol.getNumOutputs x.UnsafeHandle |> int
        Array.init n 
            (fun i ->
                let h = MXSymbol.getOutput x.UnsafeHandle i
                new SymbolOutput(x,new SafeSymbolHandle(h, true))
            )
    member x.ArgumentNames = MXSymbol.listArguments x.UnsafeHandle
    member x.OutputNames = MXSymbol.listOutputs x.UnsafeHandle
    member x.AuxiliaryStateNames = MXSymbol.listAuxiliaryStates x.UnsafeHandle
    abstract member InputSymbols : Symbol []
    default x.InputSymbols = MXSymbol.getInputSymbols x.UnsafeHandle |> Array.map (fun h -> new SymbolInput(x, new SafeSymbolHandle(h,true)) :> Symbol)
    abstract member Initialize : unit -> unit
   
    member x.Slice(startIndices, endIndices, stepIndices) = Slice(x, startIndices, endIndices, stepIndices)
    member x.GetSlice([<ParamArray>] a : obj []) = 
        let b = ResizeArray()
        let e = ResizeArray()
        let s = ResizeArray<int option>()
        let mutable i = 0
        while i < a.Length do 
            match a.[i] with 
            | :? int as idx -> 
                b.Add(Some idx)
                e.Add(Some(idx + 1))
                s.Add None
            | :? (int option) as o -> 
                let o2 = a.[i+1] :?> int option |> Option.map (fun x -> x + 1)
                b.Add(o)
                e.Add(o2)
                s.Add None
                i <- i + 1
            | _ -> failwithf "invalid argument to get slice %A" a.[i]
            i <- i + 1
        x.Slice(b,e,s) 
             
    static member (+)(x : Symbol, y : float) = new PlusScalar(x,y)
    static member (+)(y : float, x : Symbol) = new PlusScalar(x,y)
    static member (+)(x : Symbol, y : Symbol) = new ElemwiseAdd(x,y)
    static member (.+)(x : Symbol, y : Symbol) = new BroadcastAdd(x,y)
    
    static member (-)(x : Symbol, y : float) = new MinusScalar(x,y)
    static member (-)(y : float, x : Symbol) = new RminusScalar(x,y)
    static member (-)(x : Symbol, y : Symbol) = new ElemwiseSub(x,y)
    static member (.-)(x : Symbol, y : Symbol) = new BroadcastSub(x,y)
    
    static member (/)(x : Symbol, y : float) = new DivScalar(x,y)
    static member (/)(y : float, x : Symbol) = new RdivScalar(x,y)
    static member (/)(x : Symbol, y : Symbol) = new ElemwiseDiv(x,y)
    static member (./)(x : Symbol, y : Symbol) = new BroadcastDiv(x,y)
    
    static member ( * )(x : Symbol, y : float) = new MulScalar(x,y)
    static member ( * )(y : float, x : Symbol) = new MulScalar(x,y)
    static member ( * )(x : Symbol, y : Symbol) = new ElemwiseMul(x,y)
    static member ( .* )(x : Symbol, y : Symbol) = new BroadcastMul(x,y)
    
    static member ( ** )(x : Symbol, y : float) = new PowerScalar(x,y)
    static member ( ** )(y : float, x : Symbol) = new RpowerScalar(x,y)
    static member ( ** )(x : Symbol, y : Symbol) = new Power(x,y)
    static member ( .** )(x : Symbol, y : Symbol) = new BroadcastPower(x,y)

    member x.Negate() = -1.0*x
    member x.ApplyNegate() = x.Negate()
    static member (~-)(x : Symbol) = x.Negate()

    static member (%)(x : Symbol, y : float) = new ModScalar(x,y)
    static member (%)(y : float, x : Symbol) = new RmodScalar(x,y)
    static member (%)(x : Symbol, y : Symbol) = new BroadcastMod(x,y)
    
    static member (.=)(x : Symbol, y : float) = new EqualScalar(x,y)
    static member (.=)(y : float, x : Symbol) = new EqualScalar(x,y)
    static member (.=)(x : Symbol, y : Symbol) = new BroadcastEqual(x,y)
    
    static member (.<>)(x : Symbol, y : float) = new NotEqualScalar(x,y)
    static member (.<>)(y : float, x : Symbol) = new NotEqualScalar(x,y)
    static member (.<>)(x : Symbol, y : Symbol) = new BroadcastNotEqual(x,y)

    static member (.>)(x : Symbol, y : float) = new GreaterScalar(x,y)
    static member (.>)(y : float, x : Symbol) = new LesserScalar(x,y)
    static member (.>)(x : Symbol, y : Symbol) = new BroadcastGreater(x,y)
    
    static member (.<)(x : Symbol, y : float) = new LesserScalar(x,y)
    static member (.<)(y : float, x : Symbol) = new GreaterScalar(x,y)
    static member (.<)(x : Symbol, y : Symbol) = new BroadcastLesser(x,y)
    
    static member (.>=)(x : Symbol, y : float) = new GreaterEqualScalar(x,y)
    static member (.>=)(y : float, x : Symbol) = new LesserEqualScalar(x,y)
    static member (.>=)(x : Symbol, y : Symbol) = new BroadcastGreaterEqual(x,y)
    
    static member (.<=)(x : Symbol, y : float) = new LesserEqualScalar(x,y)
    static member (.<=)(y : float, x : Symbol) = new GreaterEqualScalar(x,y)
    static member (.<=)(x : Symbol, y : Symbol) = new BroadcastLesserEqual(x,y)

    static member (.&&)(x : Symbol, y : bool) = new LogicalAndScalar(x,if y then 1.0 else 0.0)
    static member (.&&)(y : bool, x : Symbol) = new LogicalAndScalar(x,if y then 1.0 else 0.0)
    static member (.&&)(x : Symbol, y : float) = new LogicalAndScalar(x,y)
    static member (.&&)(y : float, x : Symbol) = new LogicalAndScalar(x,y)
    static member (.&&)(x : Symbol, y : Symbol) = new LogicalAnd(x,y)
    static member (..&&)(x : Symbol, y : Symbol) = new BroadcastLogicalAnd(x,y)
    
    static member (.||)(x : Symbol, y : bool) = new LogicalOrScalar(x,if y then 1.0 else 0.0)
    static member (.||)(y : bool, x : Symbol) = new LogicalOrScalar(x,if y then 1.0 else 0.0)
    static member (.||)(x : Symbol, y : float) = new LogicalOrScalar(x,y)
    static member (.||)(y : float, x : Symbol) = new LogicalOrScalar(x,y)
    static member (.||)(x : Symbol, y : Symbol) = new LogicalOr(x,y)
    static member (..||)(x : Symbol, y : Symbol) = new BroadcastLogicalOr(x,y)
    
    static member (.^^)(x : Symbol, y : bool) = new LogicalXorScalar(x,if y then 1.0 else 0.0)
    static member (.^^)(y : bool, x : Symbol) = new LogicalXorScalar(x,if y then 1.0 else 0.0)
    static member (.^^)(x : Symbol, y : float) = new LogicalXorScalar(x,y)
    static member (.^^)(y : float, x : Symbol) = new LogicalXorScalar(x,y)
    static member (.^^)(x : Symbol, y : Symbol) = new LogicalXor(x,y)
    static member (..^^)(x : Symbol, y : Symbol) = new BroadcastLogicalXor(x,y)

    member x.Exp() = new Exp(x)
    member x.ApplyExp() = new Exp(x)
    static member Exp(x : Symbol) = new Exp(x) :> Symbol
    member x.Log() = new Log(x)
    member x.ApplyLog() = new Log(x)
    static member Log(x : Symbol) = new Log(x) :> Symbol
    member x.Abs() = new Abs(x)
    member x.ApplyAbs() = new Abs(x)
    static member Abs(x : Symbol) = new Abs(x) :> Symbol
    member x.Acos() = new Arccos(x)
    member x.ApplyAcos() = new Arccos(x)
    static member Acos(x : Symbol) = new Arccos(x) :> Symbol
    member x.Asin() = new Arcsin(x)
    member x.ApplyAsin() = new Arcsin(x)
    static member Asin(x : Symbol) = new Arcsin(x) :> Symbol
    member x.Atan() = new Arctan(x)
    member x.ApplyAtan() = new Arctan(x)
    static member Atan(x : Symbol) = new Arctan(x) :> Symbol
    static member Atan2(x : #Symbol, y : #Symbol) = new NpiArctan2(x, y) 
    static member Atan2(x : #Symbol, y : double) = new NpiArctan2Scalar(x, y) 
    static member Atan2(y : double, x : #Symbol) = new NpiRarctan2Scalar(x, y) 
    static member ArcTan2(x : #Symbol, y : #Symbol) = new NpiArctan2(x, y) 
    static member ArcTan2(x : #Symbol, y : double) = new NpiArctan2Scalar(x, y) 
    static member AtcTan2(y : double, x : #Symbol) = new NpiRarctan2Scalar(x, y) 
    member x.Ceiling() = new Ceil(x)
    member x.ApplyCeiling() = new Ceil(x)
    static member Ceiling(x : Symbol) = new Ceil(x) :> Symbol
    member x.Floor() = new Floor(x)
    member x.ApplyFloor() = new Floor(x)
    static member Floor(x : Symbol) = new Floor(x) :> Symbol
    member x.Truncate() = new Trunc(x)
    member x.ApplyTruncate() = new Trunc(x)
    static member Truncate(x : Symbol) = new Trunc(x) :> Symbol
    member x.Round() = new Round(x)
    member x.ApplyRound() = new Round(x)
    static member Round(x : Symbol) = new Round(x) :> Symbol
    member x.Log10() = new Log10(x)
    member x.ApplyLog10() = new Log10(x)
    static member Log10(x : Symbol) = new Log10(x) :> Symbol
    member x.Sqrt() = new Sqrt(x)
    member x.ApplySqrt() = new Sqrt(x)
    static member Sqrt(x : Symbol) = new Sqrt(x) :> Symbol
    member x.Cos() = new Cos(x)
    member x.ApplyCos() = new Cos(x)
    static member Cos(x : Symbol) = new Cos(x) :> Symbol
    member x.Cosh() = new Cosh(x)
    member x.ApplyCosh() = new Cosh(x)
    static member Cosh(x : Symbol) = new Cosh(x) :> Symbol
    member x.Sin() = new Sin(x)
    member x.ApplySin() = new Sin(x)
    static member Sin(x : Symbol) = new Sin(x) :> Symbol
    member x.Sinh() = new Sinh(x)
    member x.ApplySinh() = new Sinh(x)
    static member Sinh(x : Symbol) = new Sinh(x) :> Symbol
    member x.Tan() = new Tan(x)
    member x.ApplyTan() = new Tan(x)
    static member Tan(x : Symbol) = new Tan(x) :> Symbol
    member x.Tanh() = new Tanh(x)
    member x.ApplyTanh() = new Tanh(x)
    static member Tanh(x : Symbol) = new Tanh(x) :> Symbol

(*
    member x.Dispose(disposing) = 
        if not disposed then 
            if disposing then 
                match x.InternalHandle with 
                | Some h -> h.Dispose()
                | None -> ()
        disposed <- true
    member x.Dispose() = 
        x.Dispose(true)
        GC.SuppressFinalize(x)
    interface IDisposable with  
        member x.Dispose() = x.Dispose()
*)

type SymbolOutput internal (parent : Symbol) = 
    inherit Symbol()
    new(parent, handle) as this = 
        new SymbolOutput(parent) then 
            this.InternalHandle <- Some handle
    member x.Parent = parent
    override x.Initialize() = ()
    default x.Copy() = 
        let h = MXSymbol.copy x.SymbolHandle.UnsafeHandle
        SymbolOutput(parent, new SafeSymbolHandle(h, true)) :> Symbol //REVIEW: not sure this makes sense. Copy the output and keep the same parent?


type SymbolInput internal (parent : Symbol) = 
    inherit Symbol()
    new(parent, handle) as this = 
        new SymbolInput(parent) then 
            this.InternalHandle <- Some handle
    member x.Parent = parent
    override x.Initialize() = ()
    default x.Copy() = 
        let h = MXSymbol.copy x.SymbolHandle.UnsafeHandle
        SymbolInput(parent, new SafeSymbolHandle(h, true)) :> Symbol //REVIEW: not sure this makes sense. Copy the input and keep the same parent?

type Variable() =
    inherit Symbol()
    new (name : string) as this = 
        new Variable() then 
            this.InternalName <- Some name
    //member internal x.CreateId() = 
    //    assert(x.IsInitialized)
    //    match x.Id with 
    //    | None ->
    //        let sid = Guid.NewGuid()
    //        MXSymbol.setAttr x.UnsafeHandle "mxnetsharp_symbolid" (string sid)
    //    | _ -> ()
    override x.Initialize() =   
        match x.InternalHandle with 
        | Some _ -> ()
        | None -> 
            let n = 
                match x.InternalName with 
                | Some n -> n
                | None -> x.GeneratedName
            x.InternalHandle <- Some(new SafeSymbolHandle(MXSymbol.createVariable n,true))
    default x.Copy() = 
        x.Initialize() 
        let v = Variable(x.Name) 
        v :> Symbol

type ImplicitVariable() = 
    inherit Variable() 
    default x.Copy() = ImplicitVariable() :> Symbol

//TODO: Manually add CustomOp type and skip in codegen
//TODO: fix histogram
//TODO: override tostring
//TODO: ctx = '' for NDArray ops is invalid even though it's often the default
//TODO: We should add valiation to the specific symbol types
type SymbolOperator(creator : AtomicSymbolCreator, operatorArguments : Arguments<Symbol>) = 
    inherit Symbol()
    //let parametersStr = parameters |> Array.map (fun (k,v) -> k, Util.valueString v)
    new(name, args) = new SymbolOperator(AtomicSymbolCreator.FromName name, args)
    //new(creator,pnames,ps,inames,ins) = new SymbolOperator(creator, Array.zip pnames ps, Array.zip inames ins)
    member internal x.AtomicSymbolCreator = creator
    member x.OperatorArguments = operatorArguments
    default x.Copy() = 
        x.OperatorArguments
        |> Seq.map 
            (fun a -> 
                match a with 
                | name, VarArg(num, args) -> 
                    let args = args |> Array.map (fun a -> a.Copy().SetName(a.Name))
                    name, VarArg(num, args)
                | name, Input(s) -> name, Input(s.Copy().SetName(s.Name))
                | otherwise -> otherwise
            )
        |> (fun args -> x.WithArguments(Arguments<Symbol>(args)).SetName(x.Name))
    override x.InputSymbols = 
        let args : string [] = x.ArgumentNames
        let inputs : Symbol [] = base.InputSymbols
        let d = Dictionary<string, Symbol>()
        x.OperatorArguments
        |> Seq.iter 
            (fun a -> 
                match a with 
                | _, VarArg(num, args) -> 
                    args 
                    |> Array.iter 
                        (fun a ->
                            a.InputSymbols |> Seq.iter (fun x -> d.[x.Name] <- x)
                            d.[a.Name] <- a
                        )
                | _, Input(s) -> 
                    s.InputSymbols |> Seq.iter (fun x -> d.[x.Name] <- x)
                    d.[s.Name] <- s
                | _ -> ()
            )
        args 
        |> Array.mapi
            (fun i a ->
                let scc,v = d.TryGetValue(a)
                if scc then 
                    v
                else
                    inputs.[i]
            )
        
    abstract member WithArguments : operatorArguments : Arguments<Symbol> -> Symbol
    default x.WithArguments(args) = new SymbolOperator(creator, args) :> Symbol
    abstract member ComposedWith : Symbol -> Symbol
    default x.ComposedWith(symbol : Symbol) = 
        let mutable inserted = false
        let args = 
            operatorArguments
            |> Seq.map 
                (fun a -> 
                    match a with 
                    | name, Input(:? ImplicitVariable) when not inserted -> 
                       inserted <- true
                       printfn "Composing %s in %s with %s" name (x.GetType().Name) (symbol.GetType().Name)
                       name, Input(symbol)
                    | name, VarArg(countName,a) -> 
                       inserted <- true
                       printfn "Composing %s in %s with %s" name (x.GetType().Name) (symbol.GetType().Name)
                       name, VarArg(countName, [|yield! a; yield symbol|])
                        
                    | x -> x
                )
            |> Seq.toArray
        if inserted then 
            x.WithArguments(Arguments<Symbol>(args)).SetName(x)
        else
            failwithf "Could not compose %O with %O" x  symbol
    override x.Initialize() =   
        match x.InternalHandle with 
        | Some _ -> ()
        | None ->
            try
                //TODO: We should maybe check the varArg count parameter is not specified. Generally this should never happen
                let inputKeys = ResizeArray()
                let inputValues = ResizeArray()
                let pKeys = ResizeArray()
                let pValues = ResizeArray()
                let name = defaultArg x.InternalName x.GeneratedName
                for a in creator.Info.Arguments do  
                    let scc,v = operatorArguments.Args.TryGetValue a.Name
                    if scc then 
                        match v with 
                        | Input i -> 
                            inputKeys.Add a.Name
                            match i with 
                            | :? ImplicitVariable as v when not v.IsInitialized -> v.Name <- sprintf "%s_%s" name a.Name
                            | _ -> ()
                            inputValues.Add i
                        | VarArg (count,i) -> 
                            inputValues.AddRange i
                            pKeys.Add count
                            pValues.Add(i.Length.ValueString())
                        | Parameter (Some o) -> 
                            pKeys.Add a.Name
                            pValues.Add(o.ValueString())
                        | Parameter None -> ()
                    else 
                        match a.TypeInfo with
                        | "NDArray-or-Symbol" //TODO: I dont like this
                        | "Symbol" -> 
                            inputKeys.Add(a.Name)
                            let i = new ImplicitVariable()
                            i.Name <- sprintf "%s_%s" name a.Name
                            inputValues.Add(i)
                        | _ -> ()
                let symbol = 
                    let keys = pKeys.ToArray()
                    let vals = pValues.ToArray()
                    assert (keys.Length = vals.Length)
                    MXSymbol.createAtomicSymbol creator.AtomicSymbolCreatorHandle keys vals
                let ivals = inputValues |> Seq.map (fun i -> i.UnsafeHandle) |> Seq.toArray
                if inputKeys.Count <> inputValues.Count then 
                    MXSymbol.compose symbol name null ivals
                else //REVIEW: we could just never use keys
                    let keys = inputKeys.ToArray()
                    Seq.zip keys inputValues 
                    |> Seq.filter 
                        (fun (name,v) ->
                            match v with 
                            | :? ImplicitVariable -> false
                            | _ -> true
                        )
                    |> Seq.map (fun (name,v) -> name, v.UnsafeHandle)
                    |> Seq.toArray
                    |> Array.unzip
                    ||> MXSymbol.compose symbol name
                x.InternalHandle <- Some(new SafeSymbolHandle(symbol, true))
                //x.CreateId()
            with
            | e -> raise(SymbolInitilizationException(x, e))
    interface ISymbolComposable with 
        member x.ComposedWith(y) = x.ComposedWith(y)

type SymbolComposable<'a when 'a :> SymbolOperator>(argSymbol : Symbol, rootSymbol: 'a) = 
    inherit SymbolOperator(rootSymbol.AtomicSymbolCreator, rootSymbol.OperatorArguments) 
    override x.ComposedWith(symbol : Symbol) = 
        let rec loop (x : SymbolOperator) = 
            x.OperatorArguments
            |> Seq.map 
                (fun a -> 
                    match a with 
                    | name, VarArg(num, args) -> 
                        let args = 
                            args 
                            |> Array.map 
                                (fun a ->
                                    match a with 
                                    | s when Object.ReferenceEquals(argSymbol,s) -> symbol
                                    | :? SymbolOperator as s -> loop s
                                    | s -> s
                                )
                        name, VarArg(num, args)
                    | name, Input(s) when Object.ReferenceEquals(argSymbol,s) -> name, Input(symbol)
                    | name, Input(:? SymbolOperator as s) -> name, Input(loop s)
                    | otherwise -> otherwise
                )
            |> (fun args -> x.WithArguments(Arguments<Symbol>(args)).SetName(x))
        SymbolComposable(argSymbol, loop (rootSymbol :> SymbolOperator) :?> 'a) :> Symbol
    override x.WithArguments(args : Arguments<Symbol>) = new SymbolComposable<'a>(argSymbol, rootSymbol.WithArguments(args) :?> 'a) :> Symbol
    default x.Copy() = 
        let rec loop (x : SymbolOperator) = 
            x.OperatorArguments
            |> Seq.map 
                (fun a -> 
                    match a with 
                    | name, VarArg(num, args) -> 
                        let args = 
                            args 
                            |> Array.map 
                                (fun a ->
                                    match a with 
                                    | s when Object.ReferenceEquals(argSymbol,s) -> argSymbol
                                    | :? SymbolOperator as s -> loop s
                                    | s -> s.Copy().SetName(s.Name)
                                )
                        name, VarArg(num, args)
                    | name, Input(s) when Object.ReferenceEquals(argSymbol,s) -> name, Input(argSymbol)
                    | name, Input(:? SymbolOperator as s) -> name, Input(loop s)
                    | name, Input(s) -> name, Input(s.Copy().SetName(s.Name))
                    | otherwise -> otherwise
                )
            |> (fun args -> x.WithArguments(Arguments<Symbol>(args)).SetName(x.Name))
        SymbolComposable(argSymbol, loop (rootSymbol :> SymbolOperator) :?> 'a) :> Symbol
    override x.InputSymbols = rootSymbol.InputSymbols
    


type SymbolGroup(symbols : Symbol []) = 
    inherit Symbol()
    new (symbols : Symbol seq) = SymbolGroup(symbols |> Seq.toArray)
    member x.Item with get(i : int) = symbols.[i]
    member x.Count = symbols.Length
    override x.Initialize() =   
        match x.InternalHandle with 
        | Some _ -> ()
        | None -> 
            let symbol = symbols |> Array.map (fun x -> x.UnsafeHandle) |> MXSymbol.createGroup 
            x.InternalHandle <- Some(new SafeSymbolHandle(symbol, true))
            //x.CreateId()
    default x.Copy() = SymbolGroup(symbols |> Array.map (fun x -> x.Copy())) :> Symbol
    override x.InputSymbols = 
        let a = symbols |> Array.collect (fun x -> x.InputSymbols)
        assert ((a |> Array.map (fun x -> x.Name)) = x.ArgumentNames)
        a


// **************************************************************************************************************************************
// ** GENERATED SYMBOL TYPES SECTION
// ** The below Section is generated and should not be edited
// **************************************************************************************************************************************

(* GERNATED SYMBOL TYPES BEGIN *)//
type CustomFunction private (operatorArguments) = 
    inherit SymbolOperator("_CustomFunction", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new CustomFunction(args)
    override this.WithArguments(args : Arguments<Symbol>) = new CustomFunction(this.OperatorArguments.AddReplace(args)) :> Symbol
    new() =
        let operatorArguments = 
            [
            ]
        new CustomFunction(Arguments<Symbol>(operatorArguments))

type CachedOp private (operatorArguments) = 
    inherit SymbolOperator("_CachedOp", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new CachedOp(args)
    override this.WithArguments(args : Arguments<Symbol>) = new CachedOp(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <param name="data">input data list</param>
    new([<ParamArray>] data : Symbol[]) =
        let operatorArguments = 
            [
                "data", VarArg("", data)
            ]
        new CachedOp(Arguments<Symbol>(operatorArguments))
    /// input data list
    member __.Data = operatorArguments.GetVarArg "data"
    /// <summary>Copy CachedOp instance with updated inputs/parameters.</summary>
    /// <param name="data">input data list</param>
    member this.With([<Optional>] ?data : Symbol seq) =
        let operatorArguments = 
            [
                data |> Option.map (fun x -> "data", VarArg("", Seq.toArray x))
            ] |> List.choose id
        new CachedOp(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type Cvimread private (operatorArguments) = 
    inherit SymbolOperator("_cvimread", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new Cvimread(args)
    override this.WithArguments(args : Arguments<Symbol>) = new Cvimread(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <summary>Read and decode image with OpenCV. 
    /// Note: return image in RGB by default, instead of OpenCV&#39;s default BGR.</summary>
    /// <param name="filename">Name of the image file to be loaded.</param>
    /// <param name="flag">Convert decoded image to grayscale (0) or color (1).</param>
    /// <param name="toRgb">Whether to convert decoded image to mxnet&#39;s default RGB format (instead of opencv&#39;s default BGR).</param>
    new(filename : string,
        [<Optional>] ?flag : int,
        [<Optional>] ?toRgb : bool) = 
        let operatorArguments = 
            [
                "filename", Parameter(Some(box filename))
                "flag", flag |> Option.map box |> Parameter
                "to_rgb", toRgb |> Option.map box |> Parameter
            ]
        new Cvimread(Arguments<Symbol>(operatorArguments))
    /// Default value for Flag
    /// Convert decoded image to grayscale (0) or color (1).
    static member FlagDefault : int = 1
    /// Default value for ToRgb
    /// Whether to convert decoded image to mxnet&#39;s default RGB format (instead of opencv&#39;s default BGR).
    static member ToRgbDefault : bool = true
    /// Name of the image file to be loaded.
    member __.Filename : string = match operatorArguments.GetParameter "filename" with Some(v) -> unbox v | None -> failwithf "Required parameter filename is missing"
    /// Convert decoded image to grayscale (0) or color (1).
    member __.Flag = operatorArguments.GetParameter("flag", Cvimread.FlagDefault)
    /// Whether to convert decoded image to mxnet&#39;s default RGB format (instead of opencv&#39;s default BGR).
    member __.ToRgb = operatorArguments.GetParameter("to_rgb", Cvimread.ToRgbDefault)
    /// <summary>Copy Cvimread instance with updated inputs/parameters.</summary>
    /// <param name="filename">Name of the image file to be loaded.</param>
    /// <param name="flag">Convert decoded image to grayscale (0) or color (1).</param>
    /// <param name="toRgb">Whether to convert decoded image to mxnet&#39;s default RGB format (instead of opencv&#39;s default BGR).</param>
    member this.With([<Optional>] ?filename : string,
        [<Optional>] ?flag : int,
        [<Optional>] ?toRgb : bool) = 
        let operatorArguments = 
            [
                filename |> Option.map (fun x -> "filename", Parameter(Some (box x)))
                flag |> Option.map (fun x -> "flag", Parameter(Some (box x)))
                toRgb |> Option.map (fun x -> "to_rgb", Parameter(Some (box x)))
            ] |> List.choose id
        new Cvimread(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type NoGradient private (operatorArguments) = 
    inherit SymbolOperator("_NoGradient", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new NoGradient(args)
    override this.WithArguments(args : Arguments<Symbol>) = new NoGradient(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <summary>Place holder for variable who cannot perform gradient</summary>
    new() =
        let operatorArguments = 
            [
            ]
        new NoGradient(Arguments<Symbol>(operatorArguments))

type BatchNormV1 private (operatorArguments) = 
    inherit SymbolOperator("BatchNorm_v1", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new BatchNormV1(args)
    override this.WithArguments(args : Arguments<Symbol>) = new BatchNormV1(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <summary>Batch normalization.
    /// 
    /// This operator is DEPRECATED. Perform BatchNorm on the input.
    /// 
    /// Normalizes a data batch by mean and variance, and applies a scale ``gamma`` as
    /// well as offset ``beta``.
    /// 
    /// Assume the input has more than one dimension and we normalize along axis 1.
    /// We first compute the mean and variance along this axis:
    /// 
    /// .. math::
    /// 
    ///   data\_mean[i] = mean(data[:,i,:,...]) \\
    ///   data\_var[i] = var(data[:,i,:,...])
    /// 
    /// Then compute the normalized output, which has the same shape as input, as following:
    /// 
    /// .. math::
    /// 
    ///   out[:,i,:,...] = \frac{data[:,i,:,...] - data\_mean[i]}{\sqrt{data\_var[i]+\epsilon}} * gamma[i] + beta[i]
    /// 
    /// Both *mean* and *var* returns a scalar by treating the input as a vector.
    /// 
    /// Assume the input has size *k* on axis 1, then both ``gamma`` and ``beta``
    /// have shape *(k,)*. If ``output_mean_var`` is set to be true, then outputs both ``data_mean`` and
    /// ``data_var`` as well, which are needed for the backward pass.
    /// 
    /// Besides the inputs and the outputs, this operator accepts two auxiliary
    /// states, ``moving_mean`` and ``moving_var``, which are *k*-length
    /// vectors. They are global statistics for the whole dataset, which are updated
    /// by::
    /// 
    ///   moving_mean = moving_mean * momentum + data_mean * (1 - momentum)
    ///   moving_var = moving_var * momentum + data_var * (1 - momentum)
    /// 
    /// If ``use_global_stats`` is set to be true, then ``moving_mean`` and
    /// ``moving_var`` are used instead of ``data_mean`` and ``data_var`` to compute
    /// the output. It is often used during inference.
    /// 
    /// Both ``gamma`` and ``beta`` are learnable parameters. But if ``fix_gamma`` is true,
    /// then set ``gamma`` to 1 and its gradient to 0.
    /// 
    /// There&#39;s no sparse support for this operator, and it will exhibit problematic behavior if used with
    /// sparse tensors.
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\batch_norm_v1.cc:L95</summary>
    /// <param name="data">Input data to batch normalization</param>
    /// <param name="gamma">gamma array</param>
    /// <param name="beta">beta array</param>
    /// <param name="eps">Epsilon to prevent div 0</param>
    /// <param name="momentum">Momentum for moving average</param>
    /// <param name="fixGamma">Fix gamma while training</param>
    /// <param name="useGlobalStats">Whether use global moving statistics instead of local batch-norm. This will force change batch-norm into a scale shift operator.</param>
    /// <param name="outputMeanVar">Output All,normal mean and var</param>
    new([<Optional>] ?data : Symbol,
        [<Optional>] ?gamma : Symbol,
        [<Optional>] ?beta : Symbol,
        [<Optional>] ?eps : float,
        [<Optional>] ?momentum : float,
        [<Optional>] ?fixGamma : bool,
        [<Optional>] ?useGlobalStats : bool,
        [<Optional>] ?outputMeanVar : bool) = 
        let data = defaultArg data (new ImplicitVariable() :> Symbol)
        let gamma = defaultArg gamma (new ImplicitVariable() :> Symbol)
        let beta = defaultArg beta (new ImplicitVariable() :> Symbol)
        let operatorArguments = 
            [
                "data", Input data
                "gamma", Input gamma
                "beta", Input beta
                "eps", eps |> Option.map box |> Parameter
                "momentum", momentum |> Option.map box |> Parameter
                "fix_gamma", fixGamma |> Option.map box |> Parameter
                "use_global_stats", useGlobalStats |> Option.map box |> Parameter
                "output_mean_var", outputMeanVar |> Option.map box |> Parameter
            ]
        new BatchNormV1(Arguments<Symbol>(operatorArguments))
    /// Default value for Eps
    /// Epsilon to prevent div 0
    static member EpsDefault : double = 0.00100000005
    /// Default value for Momentum
    /// Momentum for moving average
    static member MomentumDefault : double = 0.899999976
    /// Default value for FixGamma
    /// Fix gamma while training
    static member FixGammaDefault : bool = true
    /// Default value for UseGlobalStats
    /// Whether use global moving statistics instead of local batch-norm. This will force change batch-norm into a scale shift operator.
    static member UseGlobalStatsDefault : bool = false
    /// Default value for OutputMeanVar
    /// Output All,normal mean and var
    static member OutputMeanVarDefault : bool = false
    /// Input data to batch normalization
    member __.Data = operatorArguments.GetInput "data"
    /// gamma array
    member __.Gamma = operatorArguments.GetInput "gamma"
    /// beta array
    member __.Beta = operatorArguments.GetInput "beta"
    /// Epsilon to prevent div 0
    member __.Eps = operatorArguments.GetParameter("eps", BatchNormV1.EpsDefault)
    /// Momentum for moving average
    member __.Momentum = operatorArguments.GetParameter("momentum", BatchNormV1.MomentumDefault)
    /// Fix gamma while training
    member __.FixGamma = operatorArguments.GetParameter("fix_gamma", BatchNormV1.FixGammaDefault)
    /// Whether use global moving statistics instead of local batch-norm. This will force change batch-norm into a scale shift operator.
    member __.UseGlobalStats = operatorArguments.GetParameter("use_global_stats", BatchNormV1.UseGlobalStatsDefault)
    /// Output All,normal mean and var
    member __.OutputMeanVar = operatorArguments.GetParameter("output_mean_var", BatchNormV1.OutputMeanVarDefault)
    /// <summary>Copy BatchNormV1 instance with updated inputs/parameters.</summary>
    /// <param name="data">Input data to batch normalization</param>
    /// <param name="gamma">gamma array</param>
    /// <param name="beta">beta array</param>
    /// <param name="eps">Epsilon to prevent div 0</param>
    /// <param name="momentum">Momentum for moving average</param>
    /// <param name="fixGamma">Fix gamma while training</param>
    /// <param name="useGlobalStats">Whether use global moving statistics instead of local batch-norm. This will force change batch-norm into a scale shift operator.</param>
    /// <param name="outputMeanVar">Output All,normal mean and var</param>
    member this.With([<Optional>] ?data : Symbol,
        [<Optional>] ?gamma : Symbol,
        [<Optional>] ?beta : Symbol,
        [<Optional>] ?eps : float,
        [<Optional>] ?momentum : float,
        [<Optional>] ?fixGamma : bool,
        [<Optional>] ?useGlobalStats : bool,
        [<Optional>] ?outputMeanVar : bool) = 
        let operatorArguments = 
            [
                data |> Option.map (fun x -> "data", Input x)
                gamma |> Option.map (fun x -> "gamma", Input x)
                beta |> Option.map (fun x -> "beta", Input x)
                eps |> Option.map (fun x -> "eps", Parameter(Some (box x)))
                momentum |> Option.map (fun x -> "momentum", Parameter(Some (box x)))
                fixGamma |> Option.map (fun x -> "fix_gamma", Parameter(Some (box x)))
                useGlobalStats |> Option.map (fun x -> "use_global_stats", Parameter(Some (box x)))
                outputMeanVar |> Option.map (fun x -> "output_mean_var", Parameter(Some (box x)))
            ] |> List.choose id
        new BatchNormV1(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type MpAdamwUpdate private (operatorArguments) = 
    inherit SymbolOperator("_mp_adamw_update", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new MpAdamwUpdate(args)
    override this.WithArguments(args : Arguments<Symbol>) = new MpAdamwUpdate(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <summary>Update function for multi-precision AdamW optimizer.
    /// 
    /// AdamW is seen as a modification of Adam by decoupling the weight decay from the
    /// optimization steps taken w.r.t. the loss function.
    /// 
    /// Adam update consists of the following steps, where g represents gradient and m, v
    /// are 1st and 2nd order moment estimates (mean and variance).
    /// 
    /// .. math::
    /// 
    ///  g_t = \nabla J(W_{t-1})\\
    ///  m_t = \beta_1 m_{t-1} + (1 - \beta_1) g_t\\
    ///  v_t = \beta_2 v_{t-1} + (1 - \beta_2) g_t^2\\
    ///  W_t = W_{t-1} - \eta_t (\alpha \frac{ m_t }{ \sqrt{ v_t } + \epsilon } + wd W_{t-1})
    /// 
    /// It updates the weights using::
    /// 
    ///  m = beta1*m + (1-beta1)*grad
    ///  v = beta2*v + (1-beta2)*(grad**2)
    ///  w -= eta * (learning_rate * m / (sqrt(v) + epsilon) + w * wd)
    /// 
    /// Note that gradient is rescaled to grad = rescale_grad * grad. If rescale_grad is NaN, Inf, or 0,
    /// the update is skipped.
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\contrib\adamw.cc:L77</summary>
    /// <param name="weight">Weight</param>
    /// <param name="grad">Gradient</param>
    /// <param name="mean">Moving mean</param>
    /// <param name="var">Moving variance</param>
    /// <param name="weight32">Weight32</param>
    /// <param name="rescaleGrad">Rescale gradient to rescale_grad * grad. If NaN, Inf, or 0, the update is skipped.</param>
    /// <param name="lr">Learning rate</param>
    /// <param name="eta">Learning rate schedule multiplier</param>
    /// <param name="beta1">The decay rate for the 1st moment estimates.</param>
    /// <param name="beta2">The decay rate for the 2nd moment estimates.</param>
    /// <param name="epsilon">A small constant for numerical stability.</param>
    /// <param name="wd">Weight decay augments the objective function with a regularization term that penalizes large weights. The penalty scales with the square of the magnitude of each weight.</param>
    /// <param name="clipGradient">Clip gradient to the range of [-clip_gradient, clip_gradient] If clip_gradient &lt;= 0, gradient clipping is turned off. grad = max(min(grad, clip_gradient), -clip_gradient).</param>
    new(weight : Symbol,
        grad : Symbol,
        mean : Symbol,
        var : Symbol,
        weight32 : Symbol,
        rescaleGrad : Symbol,
        lr : float,
        eta : float,
        [<Optional>] ?beta1 : float,
        [<Optional>] ?beta2 : float,
        [<Optional>] ?epsilon : float,
        [<Optional>] ?wd : float,
        [<Optional>] ?clipGradient : float) = 
        let operatorArguments = 
            [
                "weight", Input weight
                "grad", Input grad
                "mean", Input mean
                "var", Input var
                "weight32", Input weight32
                "rescale_grad", Input rescaleGrad
                "lr", Parameter(Some(box lr))
                "eta", Parameter(Some(box eta))
                "beta1", beta1 |> Option.map box |> Parameter
                "beta2", beta2 |> Option.map box |> Parameter
                "epsilon", epsilon |> Option.map box |> Parameter
                "wd", wd |> Option.map box |> Parameter
                "clip_gradient", clipGradient |> Option.map box |> Parameter
            ]
        new MpAdamwUpdate(Arguments<Symbol>(operatorArguments))
    /// <summary>Update function for multi-precision AdamW optimizer.
    /// 
    /// AdamW is seen as a modification of Adam by decoupling the weight decay from the
    /// optimization steps taken w.r.t. the loss function.
    /// 
    /// Adam update consists of the following steps, where g represents gradient and m, v
    /// are 1st and 2nd order moment estimates (mean and variance).
    /// 
    /// .. math::
    /// 
    ///  g_t = \nabla J(W_{t-1})\\
    ///  m_t = \beta_1 m_{t-1} + (1 - \beta_1) g_t\\
    ///  v_t = \beta_2 v_{t-1} + (1 - \beta_2) g_t^2\\
    ///  W_t = W_{t-1} - \eta_t (\alpha \frac{ m_t }{ \sqrt{ v_t } + \epsilon } + wd W_{t-1})
    /// 
    /// It updates the weights using::
    /// 
    ///  m = beta1*m + (1-beta1)*grad
    ///  v = beta2*v + (1-beta2)*(grad**2)
    ///  w -= eta * (learning_rate * m / (sqrt(v) + epsilon) + w * wd)
    /// 
    /// Note that gradient is rescaled to grad = rescale_grad * grad. If rescale_grad is NaN, Inf, or 0,
    /// the update is skipped.
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\contrib\adamw.cc:L77</summary>
    /// <param name="lr">Learning rate</param>
    /// <param name="eta">Learning rate schedule multiplier</param>
    /// <param name="weight">Weight</param>
    /// <param name="grad">Gradient</param>
    /// <param name="mean">Moving mean</param>
    /// <param name="var">Moving variance</param>
    /// <param name="weight32">Weight32</param>
    /// <param name="rescaleGrad">Rescale gradient to rescale_grad * grad. If NaN, Inf, or 0, the update is skipped.</param>
    /// <param name="beta1">The decay rate for the 1st moment estimates.</param>
    /// <param name="beta2">The decay rate for the 2nd moment estimates.</param>
    /// <param name="epsilon">A small constant for numerical stability.</param>
    /// <param name="wd">Weight decay augments the objective function with a regularization term that penalizes large weights. The penalty scales with the square of the magnitude of each weight.</param>
    /// <param name="clipGradient">Clip gradient to the range of [-clip_gradient, clip_gradient] If clip_gradient &lt;= 0, gradient clipping is turned off. grad = max(min(grad, clip_gradient), -clip_gradient).</param>
    new(lr : float,
        eta : float,
        [<Optional>] ?weight : Symbol,
        [<Optional>] ?grad : Symbol,
        [<Optional>] ?mean : Symbol,
        [<Optional>] ?var : Symbol,
        [<Optional>] ?weight32 : Symbol,
        [<Optional>] ?rescaleGrad : Symbol,
        [<Optional>] ?beta1 : float,
        [<Optional>] ?beta2 : float,
        [<Optional>] ?epsilon : float,
        [<Optional>] ?wd : float,
        [<Optional>] ?clipGradient : float) = 
        let weight = defaultArg weight (new ImplicitVariable() :> Symbol)
        let grad = defaultArg grad (new ImplicitVariable() :> Symbol)
        let mean = defaultArg mean (new ImplicitVariable() :> Symbol)
        let var = defaultArg var (new ImplicitVariable() :> Symbol)
        let weight32 = defaultArg weight32 (new ImplicitVariable() :> Symbol)
        let rescaleGrad = defaultArg rescaleGrad (new ImplicitVariable() :> Symbol)
        let operatorArguments = 
            [
                "weight", Input weight
                "grad", Input grad
                "mean", Input mean
                "var", Input var
                "weight32", Input weight32
                "rescale_grad", Input rescaleGrad
                "lr", Parameter(Some(box lr))
                "eta", Parameter(Some(box eta))
                "beta1", beta1 |> Option.map box |> Parameter
                "beta2", beta2 |> Option.map box |> Parameter
                "epsilon", epsilon |> Option.map box |> Parameter
                "wd", wd |> Option.map box |> Parameter
                "clip_gradient", clipGradient |> Option.map box |> Parameter
            ]
        new MpAdamwUpdate(Arguments<Symbol>(operatorArguments))
    /// Default value for Beta1
    /// The decay rate for the 1st moment estimates.
    static member Beta1Default : double = 0.899999976
    /// Default value for Beta2
    /// The decay rate for the 2nd moment estimates.
    static member Beta2Default : double = 0.999000013
    /// Default value for Epsilon
    /// A small constant for numerical stability.
    static member EpsilonDefault : double = 0.0000000099999999
    /// Default value for Wd
    /// Weight decay augments the objective function with a regularization term that penalizes large weights. The penalty scales with the square of the magnitude of each weight.
    static member WdDefault : double = 0.0
    /// Default value for ClipGradient
    /// Clip gradient to the range of [-clip_gradient, clip_gradient] If clip_gradient &lt;= 0, gradient clipping is turned off. grad = max(min(grad, clip_gradient), -clip_gradient).
    static member ClipGradientDefault : double = -1.0
    /// Weight
    member __.Weight = operatorArguments.GetInput "weight"
    /// Gradient
    member __.Grad = operatorArguments.GetInput "grad"
    /// Moving mean
    member __.Mean = operatorArguments.GetInput "mean"
    /// Moving variance
    member __.Var = operatorArguments.GetInput "var"
    /// Weight32
    member __.Weight32 = operatorArguments.GetInput "weight32"
    /// Rescale gradient to rescale_grad * grad. If NaN, Inf, or 0, the update is skipped.
    member __.RescaleGrad = operatorArguments.GetInput "rescale_grad"
    /// Learning rate
    member __.Lr : float = match operatorArguments.GetParameter "lr" with Some(v) -> unbox v | None -> failwithf "Required parameter lr is missing"
    /// Learning rate schedule multiplier
    member __.Eta : float = match operatorArguments.GetParameter "eta" with Some(v) -> unbox v | None -> failwithf "Required parameter eta is missing"
    /// The decay rate for the 1st moment estimates.
    member __.Beta1 = operatorArguments.GetParameter("beta1", MpAdamwUpdate.Beta1Default)
    /// The decay rate for the 2nd moment estimates.
    member __.Beta2 = operatorArguments.GetParameter("beta2", MpAdamwUpdate.Beta2Default)
    /// A small constant for numerical stability.
    member __.Epsilon = operatorArguments.GetParameter("epsilon", MpAdamwUpdate.EpsilonDefault)
    /// Weight decay augments the objective function with a regularization term that penalizes large weights. The penalty scales with the square of the magnitude of each weight.
    member __.Wd = operatorArguments.GetParameter("wd", MpAdamwUpdate.WdDefault)
    /// Clip gradient to the range of [-clip_gradient, clip_gradient] If clip_gradient &lt;= 0, gradient clipping is turned off. grad = max(min(grad, clip_gradient), -clip_gradient).
    member __.ClipGradient = operatorArguments.GetParameter("clip_gradient", MpAdamwUpdate.ClipGradientDefault)
    /// <summary>Copy MpAdamwUpdate instance with updated inputs/parameters.</summary>
    /// <param name="weight">Weight</param>
    /// <param name="grad">Gradient</param>
    /// <param name="mean">Moving mean</param>
    /// <param name="var">Moving variance</param>
    /// <param name="weight32">Weight32</param>
    /// <param name="rescaleGrad">Rescale gradient to rescale_grad * grad. If NaN, Inf, or 0, the update is skipped.</param>
    /// <param name="lr">Learning rate</param>
    /// <param name="eta">Learning rate schedule multiplier</param>
    /// <param name="beta1">The decay rate for the 1st moment estimates.</param>
    /// <param name="beta2">The decay rate for the 2nd moment estimates.</param>
    /// <param name="epsilon">A small constant for numerical stability.</param>
    /// <param name="wd">Weight decay augments the objective function with a regularization term that penalizes large weights. The penalty scales with the square of the magnitude of each weight.</param>
    /// <param name="clipGradient">Clip gradient to the range of [-clip_gradient, clip_gradient] If clip_gradient &lt;= 0, gradient clipping is turned off. grad = max(min(grad, clip_gradient), -clip_gradient).</param>
    member this.With([<Optional>] ?weight : Symbol,
        [<Optional>] ?grad : Symbol,
        [<Optional>] ?mean : Symbol,
        [<Optional>] ?var : Symbol,
        [<Optional>] ?weight32 : Symbol,
        [<Optional>] ?rescaleGrad : Symbol,
        [<Optional>] ?lr : float,
        [<Optional>] ?eta : float,
        [<Optional>] ?beta1 : float,
        [<Optional>] ?beta2 : float,
        [<Optional>] ?epsilon : float,
        [<Optional>] ?wd : float,
        [<Optional>] ?clipGradient : float) = 
        let operatorArguments = 
            [
                weight |> Option.map (fun x -> "weight", Input x)
                grad |> Option.map (fun x -> "grad", Input x)
                mean |> Option.map (fun x -> "mean", Input x)
                var |> Option.map (fun x -> "var", Input x)
                weight32 |> Option.map (fun x -> "weight32", Input x)
                rescaleGrad |> Option.map (fun x -> "rescale_grad", Input x)
                lr |> Option.map (fun x -> "lr", Parameter(Some (box x)))
                eta |> Option.map (fun x -> "eta", Parameter(Some (box x)))
                beta1 |> Option.map (fun x -> "beta1", Parameter(Some (box x)))
                beta2 |> Option.map (fun x -> "beta2", Parameter(Some (box x)))
                epsilon |> Option.map (fun x -> "epsilon", Parameter(Some (box x)))
                wd |> Option.map (fun x -> "wd", Parameter(Some (box x)))
                clipGradient |> Option.map (fun x -> "clip_gradient", Parameter(Some (box x)))
            ] |> List.choose id
        new MpAdamwUpdate(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type AdamwUpdate private (operatorArguments) = 
    inherit SymbolOperator("_adamw_update", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new AdamwUpdate(args)
    override this.WithArguments(args : Arguments<Symbol>) = new AdamwUpdate(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <summary>Update function for AdamW optimizer. AdamW is seen as a modification of
    /// Adam by decoupling the weight decay from the optimization steps taken w.r.t. the loss function.
    /// 
    /// Adam update consists of the following steps, where g represents gradient and m, v
    /// are 1st and 2nd order moment estimates (mean and variance).
    /// 
    /// .. math::
    /// 
    ///  g_t = \nabla J(W_{t-1})\\
    ///  m_t = \beta_1 m_{t-1} + (1 - \beta_1) g_t\\
    ///  v_t = \beta_2 v_{t-1} + (1 - \beta_2) g_t^2\\
    ///  W_t = W_{t-1} - \eta_t (\alpha \frac{ m_t }{ \sqrt{ v_t } + \epsilon } + wd W_{t-1})
    /// 
    /// It updates the weights using::
    /// 
    ///  m = beta1*m + (1-beta1)*grad
    ///  v = beta2*v + (1-beta2)*(grad**2)
    ///  w -= eta * (learning_rate * m / (sqrt(v) + epsilon) + w * wd)
    /// 
    /// Note that gradient is rescaled to grad = rescale_grad * grad. If rescale_grad is NaN, Inf, or 0,
    /// the update is skipped.
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\contrib\adamw.cc:L120</summary>
    /// <param name="weight">Weight</param>
    /// <param name="grad">Gradient</param>
    /// <param name="mean">Moving mean</param>
    /// <param name="var">Moving variance</param>
    /// <param name="rescaleGrad">Rescale gradient to rescale_grad * grad. If NaN, Inf, or 0, the update is skipped.</param>
    /// <param name="lr">Learning rate</param>
    /// <param name="eta">Learning rate schedule multiplier</param>
    /// <param name="beta1">The decay rate for the 1st moment estimates.</param>
    /// <param name="beta2">The decay rate for the 2nd moment estimates.</param>
    /// <param name="epsilon">A small constant for numerical stability.</param>
    /// <param name="wd">Weight decay augments the objective function with a regularization term that penalizes large weights. The penalty scales with the square of the magnitude of each weight.</param>
    /// <param name="clipGradient">Clip gradient to the range of [-clip_gradient, clip_gradient] If clip_gradient &lt;= 0, gradient clipping is turned off. grad = max(min(grad, clip_gradient), -clip_gradient).</param>
    new(weight : Symbol,
        grad : Symbol,
        mean : Symbol,
        var : Symbol,
        rescaleGrad : Symbol,
        lr : float,
        eta : float,
        [<Optional>] ?beta1 : float,
        [<Optional>] ?beta2 : float,
        [<Optional>] ?epsilon : float,
        [<Optional>] ?wd : float,
        [<Optional>] ?clipGradient : float) = 
        let operatorArguments = 
            [
                "weight", Input weight
                "grad", Input grad
                "mean", Input mean
                "var", Input var
                "rescale_grad", Input rescaleGrad
                "lr", Parameter(Some(box lr))
                "eta", Parameter(Some(box eta))
                "beta1", beta1 |> Option.map box |> Parameter
                "beta2", beta2 |> Option.map box |> Parameter
                "epsilon", epsilon |> Option.map box |> Parameter
                "wd", wd |> Option.map box |> Parameter
                "clip_gradient", clipGradient |> Option.map box |> Parameter
            ]
        new AdamwUpdate(Arguments<Symbol>(operatorArguments))
    /// <summary>Update function for AdamW optimizer. AdamW is seen as a modification of
    /// Adam by decoupling the weight decay from the optimization steps taken w.r.t. the loss function.
    /// 
    /// Adam update consists of the following steps, where g represents gradient and m, v
    /// are 1st and 2nd order moment estimates (mean and variance).
    /// 
    /// .. math::
    /// 
    ///  g_t = \nabla J(W_{t-1})\\
    ///  m_t = \beta_1 m_{t-1} + (1 - \beta_1) g_t\\
    ///  v_t = \beta_2 v_{t-1} + (1 - \beta_2) g_t^2\\
    ///  W_t = W_{t-1} - \eta_t (\alpha \frac{ m_t }{ \sqrt{ v_t } + \epsilon } + wd W_{t-1})
    /// 
    /// It updates the weights using::
    /// 
    ///  m = beta1*m + (1-beta1)*grad
    ///  v = beta2*v + (1-beta2)*(grad**2)
    ///  w -= eta * (learning_rate * m / (sqrt(v) + epsilon) + w * wd)
    /// 
    /// Note that gradient is rescaled to grad = rescale_grad * grad. If rescale_grad is NaN, Inf, or 0,
    /// the update is skipped.
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\contrib\adamw.cc:L120</summary>
    /// <param name="lr">Learning rate</param>
    /// <param name="eta">Learning rate schedule multiplier</param>
    /// <param name="weight">Weight</param>
    /// <param name="grad">Gradient</param>
    /// <param name="mean">Moving mean</param>
    /// <param name="var">Moving variance</param>
    /// <param name="rescaleGrad">Rescale gradient to rescale_grad * grad. If NaN, Inf, or 0, the update is skipped.</param>
    /// <param name="beta1">The decay rate for the 1st moment estimates.</param>
    /// <param name="beta2">The decay rate for the 2nd moment estimates.</param>
    /// <param name="epsilon">A small constant for numerical stability.</param>
    /// <param name="wd">Weight decay augments the objective function with a regularization term that penalizes large weights. The penalty scales with the square of the magnitude of each weight.</param>
    /// <param name="clipGradient">Clip gradient to the range of [-clip_gradient, clip_gradient] If clip_gradient &lt;= 0, gradient clipping is turned off. grad = max(min(grad, clip_gradient), -clip_gradient).</param>
    new(lr : float,
        eta : float,
        [<Optional>] ?weight : Symbol,
        [<Optional>] ?grad : Symbol,
        [<Optional>] ?mean : Symbol,
        [<Optional>] ?var : Symbol,
        [<Optional>] ?rescaleGrad : Symbol,
        [<Optional>] ?beta1 : float,
        [<Optional>] ?beta2 : float,
        [<Optional>] ?epsilon : float,
        [<Optional>] ?wd : float,
        [<Optional>] ?clipGradient : float) = 
        let weight = defaultArg weight (new ImplicitVariable() :> Symbol)
        let grad = defaultArg grad (new ImplicitVariable() :> Symbol)
        let mean = defaultArg mean (new ImplicitVariable() :> Symbol)
        let var = defaultArg var (new ImplicitVariable() :> Symbol)
        let rescaleGrad = defaultArg rescaleGrad (new ImplicitVariable() :> Symbol)
        let operatorArguments = 
            [
                "weight", Input weight
                "grad", Input grad
                "mean", Input mean
                "var", Input var
                "rescale_grad", Input rescaleGrad
                "lr", Parameter(Some(box lr))
                "eta", Parameter(Some(box eta))
                "beta1", beta1 |> Option.map box |> Parameter
                "beta2", beta2 |> Option.map box |> Parameter
                "epsilon", epsilon |> Option.map box |> Parameter
                "wd", wd |> Option.map box |> Parameter
                "clip_gradient", clipGradient |> Option.map box |> Parameter
            ]
        new AdamwUpdate(Arguments<Symbol>(operatorArguments))
    /// Default value for Beta1
    /// The decay rate for the 1st moment estimates.
    static member Beta1Default : double = 0.899999976
    /// Default value for Beta2
    /// The decay rate for the 2nd moment estimates.
    static member Beta2Default : double = 0.999000013
    /// Default value for Epsilon
    /// A small constant for numerical stability.
    static member EpsilonDefault : double = 0.0000000099999999
    /// Default value for Wd
    /// Weight decay augments the objective function with a regularization term that penalizes large weights. The penalty scales with the square of the magnitude of each weight.
    static member WdDefault : double = 0.0
    /// Default value for ClipGradient
    /// Clip gradient to the range of [-clip_gradient, clip_gradient] If clip_gradient &lt;= 0, gradient clipping is turned off. grad = max(min(grad, clip_gradient), -clip_gradient).
    static member ClipGradientDefault : double = -1.0
    /// Weight
    member __.Weight = operatorArguments.GetInput "weight"
    /// Gradient
    member __.Grad = operatorArguments.GetInput "grad"
    /// Moving mean
    member __.Mean = operatorArguments.GetInput "mean"
    /// Moving variance
    member __.Var = operatorArguments.GetInput "var"
    /// Rescale gradient to rescale_grad * grad. If NaN, Inf, or 0, the update is skipped.
    member __.RescaleGrad = operatorArguments.GetInput "rescale_grad"
    /// Learning rate
    member __.Lr : float = match operatorArguments.GetParameter "lr" with Some(v) -> unbox v | None -> failwithf "Required parameter lr is missing"
    /// Learning rate schedule multiplier
    member __.Eta : float = match operatorArguments.GetParameter "eta" with Some(v) -> unbox v | None -> failwithf "Required parameter eta is missing"
    /// The decay rate for the 1st moment estimates.
    member __.Beta1 = operatorArguments.GetParameter("beta1", AdamwUpdate.Beta1Default)
    /// The decay rate for the 2nd moment estimates.
    member __.Beta2 = operatorArguments.GetParameter("beta2", AdamwUpdate.Beta2Default)
    /// A small constant for numerical stability.
    member __.Epsilon = operatorArguments.GetParameter("epsilon", AdamwUpdate.EpsilonDefault)
    /// Weight decay augments the objective function with a regularization term that penalizes large weights. The penalty scales with the square of the magnitude of each weight.
    member __.Wd = operatorArguments.GetParameter("wd", AdamwUpdate.WdDefault)
    /// Clip gradient to the range of [-clip_gradient, clip_gradient] If clip_gradient &lt;= 0, gradient clipping is turned off. grad = max(min(grad, clip_gradient), -clip_gradient).
    member __.ClipGradient = operatorArguments.GetParameter("clip_gradient", AdamwUpdate.ClipGradientDefault)
    /// <summary>Copy AdamwUpdate instance with updated inputs/parameters.</summary>
    /// <param name="weight">Weight</param>
    /// <param name="grad">Gradient</param>
    /// <param name="mean">Moving mean</param>
    /// <param name="var">Moving variance</param>
    /// <param name="rescaleGrad">Rescale gradient to rescale_grad * grad. If NaN, Inf, or 0, the update is skipped.</param>
    /// <param name="lr">Learning rate</param>
    /// <param name="eta">Learning rate schedule multiplier</param>
    /// <param name="beta1">The decay rate for the 1st moment estimates.</param>
    /// <param name="beta2">The decay rate for the 2nd moment estimates.</param>
    /// <param name="epsilon">A small constant for numerical stability.</param>
    /// <param name="wd">Weight decay augments the objective function with a regularization term that penalizes large weights. The penalty scales with the square of the magnitude of each weight.</param>
    /// <param name="clipGradient">Clip gradient to the range of [-clip_gradient, clip_gradient] If clip_gradient &lt;= 0, gradient clipping is turned off. grad = max(min(grad, clip_gradient), -clip_gradient).</param>
    member this.With([<Optional>] ?weight : Symbol,
        [<Optional>] ?grad : Symbol,
        [<Optional>] ?mean : Symbol,
        [<Optional>] ?var : Symbol,
        [<Optional>] ?rescaleGrad : Symbol,
        [<Optional>] ?lr : float,
        [<Optional>] ?eta : float,
        [<Optional>] ?beta1 : float,
        [<Optional>] ?beta2 : float,
        [<Optional>] ?epsilon : float,
        [<Optional>] ?wd : float,
        [<Optional>] ?clipGradient : float) = 
        let operatorArguments = 
            [
                weight |> Option.map (fun x -> "weight", Input x)
                grad |> Option.map (fun x -> "grad", Input x)
                mean |> Option.map (fun x -> "mean", Input x)
                var |> Option.map (fun x -> "var", Input x)
                rescaleGrad |> Option.map (fun x -> "rescale_grad", Input x)
                lr |> Option.map (fun x -> "lr", Parameter(Some (box x)))
                eta |> Option.map (fun x -> "eta", Parameter(Some (box x)))
                beta1 |> Option.map (fun x -> "beta1", Parameter(Some (box x)))
                beta2 |> Option.map (fun x -> "beta2", Parameter(Some (box x)))
                epsilon |> Option.map (fun x -> "epsilon", Parameter(Some (box x)))
                wd |> Option.map (fun x -> "wd", Parameter(Some (box x)))
                clipGradient |> Option.map (fun x -> "clip_gradient", Parameter(Some (box x)))
            ] |> List.choose id
        new AdamwUpdate(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type ContribAdaptiveAvgPooling2D private (operatorArguments) = 
    inherit SymbolOperator("_contrib_AdaptiveAvgPooling2D", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new ContribAdaptiveAvgPooling2D(args)
    override this.WithArguments(args : Arguments<Symbol>) = new ContribAdaptiveAvgPooling2D(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <summary>
    /// Applies a 2D adaptive average pooling over a 4D input with the shape of (NCHW).
    /// The pooling kernel and stride sizes are automatically chosen for desired output sizes.
    /// 
    /// - If a single integer is provided for output_size, the output size is \
    ///   (N x C x output_size x output_size) for any input (NCHW).
    /// 
    /// - If a tuple of integers (height, width) are provided for output_size, the output size is \
    ///   (N x C x height x width) for any input (NCHW).
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\contrib\adaptive_avg_pooling.cc:L214</summary>
    /// <param name="data">Input data</param>
    /// <param name="outputSize">int (output size) or a tuple of int for output (height, width).</param>
    new([<Optional>] ?data : Symbol,
        [<Optional>] ?outputSize : int seq) = 
        let data = defaultArg data (new ImplicitVariable() :> Symbol)
        let operatorArguments = 
            [
                "data", Input data
                "output_size", outputSize |> Option.map box |> Parameter
            ]
        new ContribAdaptiveAvgPooling2D(Arguments<Symbol>(operatorArguments))
    /// Default value for OutputSize
    /// int (output size) or a tuple of int for output (height, width).
    static member OutputSizeDefault : int [] = [||]
    /// Input data
    member __.Data = operatorArguments.GetInput "data"
    /// int (output size) or a tuple of int for output (height, width).
    member __.OutputSize = operatorArguments.GetParameter("output_size", ContribAdaptiveAvgPooling2D.OutputSizeDefault)
    /// <summary>Copy ContribAdaptiveAvgPooling2D instance with updated inputs/parameters.</summary>
    /// <param name="data">Input data</param>
    /// <param name="outputSize">int (output size) or a tuple of int for output (height, width).</param>
    member this.With([<Optional>] ?data : Symbol,
        [<Optional>] ?outputSize : int seq) = 
        let operatorArguments = 
            [
                data |> Option.map (fun x -> "data", Input x)
                outputSize |> Option.map (fun x -> "output_size", Parameter(Some (box x)))
            ] |> List.choose id
        new ContribAdaptiveAvgPooling2D(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type MultiAllFinite private (operatorArguments) = 
    inherit SymbolOperator("multi_all_finite", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new MultiAllFinite(args)
    override this.WithArguments(args : Arguments<Symbol>) = new MultiAllFinite(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <summary>Check if all the float numbers in all the arrays are finite (used for AMP)
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\contrib\all_finite.cc:L133</summary>
    /// <param name="data">Arrays</param>
    /// <param name="numArrays">Number of arrays.</param>
    /// <param name="initOutput">Initialize output to 1.</param>
    new([<Optional>] ?data : Symbol seq,
        [<Optional>] ?numArrays : int,
        [<Optional>] ?initOutput : bool) = 
        let data = defaultArg (data |> Option.map Seq.toArray) Array.empty
        let operatorArguments = 
            [
                "data", VarArg("", data)
                "num_arrays", numArrays |> Option.map box |> Parameter
                "init_output", initOutput |> Option.map box |> Parameter
            ]
        new MultiAllFinite(Arguments<Symbol>(operatorArguments))
    /// Default value for NumArrays
    /// Number of arrays.
    static member NumArraysDefault : int = 1
    /// Default value for InitOutput
    /// Initialize output to 1.
    static member InitOutputDefault : bool = true
    /// Arrays
    member __.Data = operatorArguments.GetVarArg "data"
    /// Number of arrays.
    member __.NumArrays = operatorArguments.GetParameter("num_arrays", MultiAllFinite.NumArraysDefault)
    /// Initialize output to 1.
    member __.InitOutput = operatorArguments.GetParameter("init_output", MultiAllFinite.InitOutputDefault)
    /// <summary>Copy MultiAllFinite instance with updated inputs/parameters.</summary>
    /// <param name="data">Arrays</param>
    /// <param name="numArrays">Number of arrays.</param>
    /// <param name="initOutput">Initialize output to 1.</param>
    member this.With([<Optional>] ?data : Symbol seq,
        [<Optional>] ?numArrays : int,
        [<Optional>] ?initOutput : bool) = 
        let operatorArguments = 
            [
                data |> Option.map (fun x -> "data", VarArg("", Seq.toArray x))
                numArrays |> Option.map (fun x -> "num_arrays", Parameter(Some (box x)))
                initOutput |> Option.map (fun x -> "init_output", Parameter(Some (box x)))
            ] |> List.choose id
        new MultiAllFinite(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type ContribBilinearResize2D private (operatorArguments) = 
    inherit SymbolOperator("_contrib_BilinearResize2D", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new ContribBilinearResize2D(args)
    override this.WithArguments(args : Arguments<Symbol>) = new ContribBilinearResize2D(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <summary>
    /// Perform 2D resizing (upsampling or downsampling) for 4D input using bilinear interpolation.
    /// 
    /// Expected input is a 4 dimensional NDArray (NCHW) and the output
    /// with the shape of (N x C x height x width). 
    /// The key idea of bilinear interpolation is to perform linear interpolation
    /// first in one direction, and then again in the other direction. See the wikipedia of
    /// `Bilinear interpolation  &lt;https://en.wikipedia.org/wiki/Bilinear_interpolation&gt;`_
    /// for more details.
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\contrib\bilinear_resize.cc:L215</summary>
    /// <param name="data">Input data</param>
    /// <param name="like">Resize data to it&#39;s shape</param>
    /// <param name="height">output height (required, but ignored if scale_height is defined or mode is not &quot;size&quot;)</param>
    /// <param name="width">output width (required, but ignored if scale_width is defined or mode is not &quot;size&quot;)</param>
    /// <param name="scaleHeight">sampling scale of the height (optional, used in modes &quot;scale&quot; and &quot;odd_scale&quot;)</param>
    /// <param name="scaleWidth">sampling scale of the width (optional, used in modes &quot;scale&quot; and &quot;odd_scale&quot;)</param>
    /// <param name="mode">resizing mode. &quot;simple&quot; - output height equals parameter &quot;height&quot; if &quot;scale_height&quot; parameter is not defined or input height multiplied by &quot;scale_height&quot; otherwise. Same for width;&quot;odd_scale&quot; - if original height or width is odd, then result height is calculated like result_h = (original_h - 1) * scale + 1; for scale &gt; 1 the result shape would be like if we did deconvolution with kernel = (1, 1) and stride = (height_scale, width_scale); and for scale &lt; 1 shape would be like we did convolution with kernel = (1, 1) and stride = (int(1 / height_scale), int( 1/ width_scale);&quot;like&quot; - resize first input to the height and width of second input; &quot;to_even_down&quot; - resize input to nearest lower even height and width (if original height is odd then result height = original height - 1);&quot;to_even_up&quot; - resize input to nearest bigger even height and width (if original height is odd then result height = original height + 1);&quot;to_odd_down&quot; - resize input to nearest odd height and width (if original height is odd then result height = original height - 1);&quot;to_odd_up&quot; - resize input to nearest odd height and width (if original height is odd then result height = original height + 1);</param>
    new([<Optional>] ?data : Symbol,
        [<Optional>] ?like : Symbol,
        [<Optional>] ?height : int,
        [<Optional>] ?width : int,
        [<Optional>] ?scaleHeight : float,
        [<Optional>] ?scaleWidth : float,
        [<Optional>] ?mode : ContribBilinearResize2DMode) = 
        let data = defaultArg data (new ImplicitVariable() :> Symbol)
        let like = defaultArg like (new ImplicitVariable() :> Symbol)
        let operatorArguments = 
            [
                "data", Input data
                "like", Input like
                "height", height |> Option.map box |> Parameter
                "width", width |> Option.map box |> Parameter
                "scale_height", scaleHeight |> Option.map box |> Parameter
                "scale_width", scaleWidth |> Option.map box |> Parameter
                "mode", mode |> Option.map box |> Parameter
            ]
        new ContribBilinearResize2D(Arguments<Symbol>(operatorArguments))
    /// Default value for Height
    /// output height (required, but ignored if scale_height is defined or mode is not &quot;size&quot;)
    static member HeightDefault : int = 1
    /// Default value for Width
    /// output width (required, but ignored if scale_width is defined or mode is not &quot;size&quot;)
    static member WidthDefault : int = 1
    /// Default value for ScaleHeight
    /// sampling scale of the height (optional, used in modes &quot;scale&quot; and &quot;odd_scale&quot;)
    static member ScaleHeightDefault : double option = None
    /// Default value for ScaleWidth
    /// sampling scale of the width (optional, used in modes &quot;scale&quot; and &quot;odd_scale&quot;)
    static member ScaleWidthDefault : double option = None
    /// Default value for Mode
    /// resizing mode. &quot;simple&quot; - output height equals parameter &quot;height&quot; if &quot;scale_height&quot; parameter is not defined or input height multiplied by &quot;scale_height&quot; otherwise. Same for width;&quot;odd_scale&quot; - if original height or width is odd, then result height is calculated like result_h = (original_h - 1) * scale + 1; for scale &gt; 1 the result shape would be like if we did deconvolution with kernel = (1, 1) and stride = (height_scale, width_scale); and for scale &lt; 1 shape would be like we did convolution with kernel = (1, 1) and stride = (int(1 / height_scale), int( 1/ width_scale);&quot;like&quot; - resize first input to the height and width of second input; &quot;to_even_down&quot; - resize input to nearest lower even height and width (if original height is odd then result height = original height - 1);&quot;to_even_up&quot; - resize input to nearest bigger even height and width (if original height is odd then result height = original height + 1);&quot;to_odd_down&quot; - resize input to nearest odd height and width (if original height is odd then result height = original height - 1);&quot;to_odd_up&quot; - resize input to nearest odd height and width (if original height is odd then result height = original height + 1);
    static member ModeDefault : ContribBilinearResize2DMode = ContribBilinearResize2DMode.Size
    /// Input data
    member __.Data = operatorArguments.GetInput "data"
    /// Resize data to it&#39;s shape
    member __.Like = operatorArguments.GetInput "like"
    /// output height (required, but ignored if scale_height is defined or mode is not &quot;size&quot;)
    member __.Height = operatorArguments.GetParameter("height", ContribBilinearResize2D.HeightDefault)
    /// output width (required, but ignored if scale_width is defined or mode is not &quot;size&quot;)
    member __.Width = operatorArguments.GetParameter("width", ContribBilinearResize2D.WidthDefault)
    /// sampling scale of the height (optional, used in modes &quot;scale&quot; and &quot;odd_scale&quot;)
    member __.ScaleHeight = operatorArguments.GetParameter("scale_height", ContribBilinearResize2D.ScaleHeightDefault)
    /// sampling scale of the width (optional, used in modes &quot;scale&quot; and &quot;odd_scale&quot;)
    member __.ScaleWidth = operatorArguments.GetParameter("scale_width", ContribBilinearResize2D.ScaleWidthDefault)
    /// resizing mode. &quot;simple&quot; - output height equals parameter &quot;height&quot; if &quot;scale_height&quot; parameter is not defined or input height multiplied by &quot;scale_height&quot; otherwise. Same for width;&quot;odd_scale&quot; - if original height or width is odd, then result height is calculated like result_h = (original_h - 1) * scale + 1; for scale &gt; 1 the result shape would be like if we did deconvolution with kernel = (1, 1) and stride = (height_scale, width_scale); and for scale &lt; 1 shape would be like we did convolution with kernel = (1, 1) and stride = (int(1 / height_scale), int( 1/ width_scale);&quot;like&quot; - resize first input to the height and width of second input; &quot;to_even_down&quot; - resize input to nearest lower even height and width (if original height is odd then result height = original height - 1);&quot;to_even_up&quot; - resize input to nearest bigger even height and width (if original height is odd then result height = original height + 1);&quot;to_odd_down&quot; - resize input to nearest odd height and width (if original height is odd then result height = original height - 1);&quot;to_odd_up&quot; - resize input to nearest odd height and width (if original height is odd then result height = original height + 1);
    member __.Mode = operatorArguments.GetParameter("mode", ContribBilinearResize2D.ModeDefault)
    /// <summary>Copy ContribBilinearResize2D instance with updated inputs/parameters.</summary>
    /// <param name="data">Input data</param>
    /// <param name="like">Resize data to it&#39;s shape</param>
    /// <param name="height">output height (required, but ignored if scale_height is defined or mode is not &quot;size&quot;)</param>
    /// <param name="width">output width (required, but ignored if scale_width is defined or mode is not &quot;size&quot;)</param>
    /// <param name="scaleHeight">sampling scale of the height (optional, used in modes &quot;scale&quot; and &quot;odd_scale&quot;)</param>
    /// <param name="scaleWidth">sampling scale of the width (optional, used in modes &quot;scale&quot; and &quot;odd_scale&quot;)</param>
    /// <param name="mode">resizing mode. &quot;simple&quot; - output height equals parameter &quot;height&quot; if &quot;scale_height&quot; parameter is not defined or input height multiplied by &quot;scale_height&quot; otherwise. Same for width;&quot;odd_scale&quot; - if original height or width is odd, then result height is calculated like result_h = (original_h - 1) * scale + 1; for scale &gt; 1 the result shape would be like if we did deconvolution with kernel = (1, 1) and stride = (height_scale, width_scale); and for scale &lt; 1 shape would be like we did convolution with kernel = (1, 1) and stride = (int(1 / height_scale), int( 1/ width_scale);&quot;like&quot; - resize first input to the height and width of second input; &quot;to_even_down&quot; - resize input to nearest lower even height and width (if original height is odd then result height = original height - 1);&quot;to_even_up&quot; - resize input to nearest bigger even height and width (if original height is odd then result height = original height + 1);&quot;to_odd_down&quot; - resize input to nearest odd height and width (if original height is odd then result height = original height - 1);&quot;to_odd_up&quot; - resize input to nearest odd height and width (if original height is odd then result height = original height + 1);</param>
    member this.With([<Optional>] ?data : Symbol,
        [<Optional>] ?like : Symbol,
        [<Optional>] ?height : int,
        [<Optional>] ?width : int,
        [<Optional>] ?scaleHeight : float,
        [<Optional>] ?scaleWidth : float,
        [<Optional>] ?mode : ContribBilinearResize2DMode) = 
        let operatorArguments = 
            [
                data |> Option.map (fun x -> "data", Input x)
                like |> Option.map (fun x -> "like", Input x)
                height |> Option.map (fun x -> "height", Parameter(Some (box x)))
                width |> Option.map (fun x -> "width", Parameter(Some (box x)))
                scaleHeight |> Option.map (fun x -> "scale_height", Parameter(Some (box x)))
                scaleWidth |> Option.map (fun x -> "scale_width", Parameter(Some (box x)))
                mode |> Option.map (fun x -> "mode", Parameter(Some (box x)))
            ] |> List.choose id
        new ContribBilinearResize2D(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type ContribBooleanMask private (operatorArguments) = 
    inherit SymbolOperator("_contrib_boolean_mask", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new ContribBooleanMask(args)
    override this.WithArguments(args : Arguments<Symbol>) = new ContribBooleanMask(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <summary>
    /// Given an n-d NDArray data, and a 1-d NDArray index,
    /// the operator produces an un-predeterminable shaped n-d NDArray out,
    /// which stands for the rows in x where the corresonding element in index is non-zero.
    /// 
    /// &gt;&gt;&gt; data = mx.nd.array([[1, 2, 3],[4, 5, 6],[7, 8, 9]])
    /// &gt;&gt;&gt; index = mx.nd.array([0, 1, 0])
    /// &gt;&gt;&gt; out = mx.nd.contrib.boolean_mask(data, index)
    /// &gt;&gt;&gt; out
    /// 
    /// [[4. 5. 6.]]
    /// &lt;NDArray 1x3 @cpu(0)&gt;
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\contrib\boolean_mask.cc:L195</summary>
    /// <param name="data">Data</param>
    /// <param name="index">Mask</param>
    /// <param name="axis">An integer that represents the axis in NDArray to mask from.</param>
    new([<Optional>] ?data : Symbol,
        [<Optional>] ?index : Symbol,
        [<Optional>] ?axis : int) = 
        let data = defaultArg data (new ImplicitVariable() :> Symbol)
        let index = defaultArg index (new ImplicitVariable() :> Symbol)
        let operatorArguments = 
            [
                "data", Input data
                "index", Input index
                "axis", axis |> Option.map box |> Parameter
            ]
        new ContribBooleanMask(Arguments<Symbol>(operatorArguments))
    /// Default value for Axis
    /// An integer that represents the axis in NDArray to mask from.
    static member AxisDefault : int = 0
    /// Data
    member __.Data = operatorArguments.GetInput "data"
    /// Mask
    member __.Index = operatorArguments.GetInput "index"
    /// An integer that represents the axis in NDArray to mask from.
    member __.Axis = operatorArguments.GetParameter("axis", ContribBooleanMask.AxisDefault)
    /// <summary>Copy ContribBooleanMask instance with updated inputs/parameters.</summary>
    /// <param name="data">Data</param>
    /// <param name="index">Mask</param>
    /// <param name="axis">An integer that represents the axis in NDArray to mask from.</param>
    member this.With([<Optional>] ?data : Symbol,
        [<Optional>] ?index : Symbol,
        [<Optional>] ?axis : int) = 
        let operatorArguments = 
            [
                data |> Option.map (fun x -> "data", Input x)
                index |> Option.map (fun x -> "index", Input x)
                axis |> Option.map (fun x -> "axis", Parameter(Some (box x)))
            ] |> List.choose id
        new ContribBooleanMask(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type ContribBoxNms private (operatorArguments) = 
    inherit SymbolOperator("_contrib_box_nms", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new ContribBoxNms(args)
    override this.WithArguments(args : Arguments<Symbol>) = new ContribBoxNms(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <summary>Apply non-maximum suppression to input.
    /// 
    /// The output will be sorted in descending order according to `score`. Boxes with
    /// overlaps larger than `overlap_thresh`, smaller scores and background boxes
    /// will be removed and filled with -1, the corresponding position will be recorded
    /// for backward propogation.
    /// 
    /// During back-propagation, the gradient will be copied to the original
    /// position according to the input index. For positions that have been suppressed,
    /// the in_grad will be assigned 0.
    /// In summary, gradients are sticked to its boxes, will either be moved or discarded
    /// according to its original index in input.
    /// 
    /// Input requirements::
    /// 
    ///   1. Input tensor have at least 2 dimensions, (n, k), any higher dims will be regarded
    ///   as batch, e.g. (a, b, c, d, n, k) == (a*b*c*d, n, k)
    ///   2. n is the number of boxes in each batch
    ///   3. k is the width of each box item.
    /// 
    /// By default, a box is [id, score, xmin, ymin, xmax, ymax, ...],
    /// additional elements are allowed.
    /// 
    /// - `id_index`: optional, use -1 to ignore, useful if `force_suppress=False`, which means
    ///   we will skip highly overlapped boxes if one is `apple` while the other is `car`.
    /// 
    /// - `background_id`: optional, default=-1, class id for background boxes, useful
    ///   when `id_index &gt;= 0` which means boxes with background id will be filtered before nms.
    /// 
    /// - `coord_start`: required, default=2, the starting index of the 4 coordinates.
    ///   Two formats are supported:
    /// 
    ///     - `corner`: [xmin, ymin, xmax, ymax]
    /// 
    ///     - `center`: [x, y, width, height]
    /// 
    /// - `score_index`: required, default=1, box score/confidence.
    ///   When two boxes overlap IOU &gt; `overlap_thresh`, the one with smaller score will be suppressed.
    /// 
    /// - `in_format` and `out_format`: default=&#39;corner&#39;, specify in/out box formats.
    /// 
    /// Examples::
    /// 
    ///   x = [[0, 0.5, 0.1, 0.1, 0.2, 0.2], [1, 0.4, 0.1, 0.1, 0.2, 0.2],
    ///        [0, 0.3, 0.1, 0.1, 0.14, 0.14], [2, 0.6, 0.5, 0.5, 0.7, 0.8]]
    ///   box_nms(x, overlap_thresh=0.1, coord_start=2, score_index=1, id_index=0,
    ///       force_suppress=True, in_format=&#39;corner&#39;, out_typ=&#39;corner&#39;) =
    ///       [[2, 0.6, 0.5, 0.5, 0.7, 0.8], [0, 0.5, 0.1, 0.1, 0.2, 0.2],
    ///        [-1, -1, -1, -1, -1, -1], [-1, -1, -1, -1, -1, -1]]
    ///   out_grad = [[0.1, 0.1, 0.1, 0.1, 0.1, 0.1], [0.2, 0.2, 0.2, 0.2, 0.2, 0.2],
    ///               [0.3, 0.3, 0.3, 0.3, 0.3, 0.3], [0.4, 0.4, 0.4, 0.4, 0.4, 0.4]]
    ///   # exe.backward
    ///   in_grad = [[0.2, 0.2, 0.2, 0.2, 0.2, 0.2], [0, 0, 0, 0, 0, 0],
    ///              [0, 0, 0, 0, 0, 0], [0.1, 0.1, 0.1, 0.1, 0.1, 0.1]]
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\contrib\bounding_box.cc:L93</summary>
    /// <param name="data">The input</param>
    /// <param name="overlapThresh">Overlapping(IoU) threshold to suppress object with smaller score.</param>
    /// <param name="validThresh">Filter input boxes to those whose scores greater than valid_thresh.</param>
    /// <param name="topk">Apply nms to topk boxes with descending scores, -1 to no restriction.</param>
    /// <param name="coordStart">Start index of the consecutive 4 coordinates.</param>
    /// <param name="scoreIndex">Index of the scores/confidence of boxes.</param>
    /// <param name="idIndex">Optional, index of the class categories, -1 to disable.</param>
    /// <param name="backgroundId">Optional, id of the background class which will be ignored in nms.</param>
    /// <param name="forceSuppress">Optional, if set false and id_index is provided, nms will only apply to boxes belongs to the same category</param>
    /// <param name="inFormat">The input box encoding type. 
    ///  &quot;corner&quot; means boxes are encoded as [xmin, ymin, xmax, ymax], &quot;center&quot; means boxes are encodes as [x, y, width, height].</param>
    /// <param name="outFormat">The output box encoding type. 
    ///  &quot;corner&quot; means boxes are encoded as [xmin, ymin, xmax, ymax], &quot;center&quot; means boxes are encodes as [x, y, width, height].</param>
    new([<Optional>] ?data : Symbol,
        [<Optional>] ?overlapThresh : float,
        [<Optional>] ?validThresh : float,
        [<Optional>] ?topk : int,
        [<Optional>] ?coordStart : int,
        [<Optional>] ?scoreIndex : int,
        [<Optional>] ?idIndex : int,
        [<Optional>] ?backgroundId : int,
        [<Optional>] ?forceSuppress : bool,
        [<Optional>] ?inFormat : Format,
        [<Optional>] ?outFormat : Format) = 
        let data = defaultArg data (new ImplicitVariable() :> Symbol)
        let operatorArguments = 
            [
                "data", Input data
                "overlap_thresh", overlapThresh |> Option.map box |> Parameter
                "valid_thresh", validThresh |> Option.map box |> Parameter
                "topk", topk |> Option.map box |> Parameter
                "coord_start", coordStart |> Option.map box |> Parameter
                "score_index", scoreIndex |> Option.map box |> Parameter
                "id_index", idIndex |> Option.map box |> Parameter
                "background_id", backgroundId |> Option.map box |> Parameter
                "force_suppress", forceSuppress |> Option.map box |> Parameter
                "in_format", inFormat |> Option.map box |> Parameter
                "out_format", outFormat |> Option.map box |> Parameter
            ]
        new ContribBoxNms(Arguments<Symbol>(operatorArguments))
    /// Default value for OverlapThresh
    /// Overlapping(IoU) threshold to suppress object with smaller score.
    static member OverlapThreshDefault : double = 0.5
    /// Default value for ValidThresh
    /// Filter input boxes to those whose scores greater than valid_thresh.
    static member ValidThreshDefault : double = 0.0
    /// Default value for Topk
    /// Apply nms to topk boxes with descending scores, -1 to no restriction.
    static member TopkDefault : int = -1
    /// Default value for CoordStart
    /// Start index of the consecutive 4 coordinates.
    static member CoordStartDefault : int = 2
    /// Default value for ScoreIndex
    /// Index of the scores/confidence of boxes.
    static member ScoreIndexDefault : int = 1
    /// Default value for IdIndex
    /// Optional, index of the class categories, -1 to disable.
    static member IdIndexDefault : int = -1
    /// Default value for BackgroundId
    /// Optional, id of the background class which will be ignored in nms.
    static member BackgroundIdDefault : int = -1
    /// Default value for ForceSuppress
    /// Optional, if set false and id_index is provided, nms will only apply to boxes belongs to the same category
    static member ForceSuppressDefault : bool = false
    /// Default value for InFormat
    /// The input box encoding type. 
    ///  &quot;corner&quot; means boxes are encoded as [xmin, ymin, xmax, ymax], &quot;center&quot; means boxes are encodes as [x, y, width, height].
    static member InFormatDefault : Format = Format.Corner
    /// Default value for OutFormat
    /// The output box encoding type. 
    ///  &quot;corner&quot; means boxes are encoded as [xmin, ymin, xmax, ymax], &quot;center&quot; means boxes are encodes as [x, y, width, height].
    static member OutFormatDefault : Format = Format.Corner
    /// The input
    member __.Data = operatorArguments.GetInput "data"
    /// Overlapping(IoU) threshold to suppress object with smaller score.
    member __.OverlapThresh = operatorArguments.GetParameter("overlap_thresh", ContribBoxNms.OverlapThreshDefault)
    /// Filter input boxes to those whose scores greater than valid_thresh.
    member __.ValidThresh = operatorArguments.GetParameter("valid_thresh", ContribBoxNms.ValidThreshDefault)
    /// Apply nms to topk boxes with descending scores, -1 to no restriction.
    member __.Topk = operatorArguments.GetParameter("topk", ContribBoxNms.TopkDefault)
    /// Start index of the consecutive 4 coordinates.
    member __.CoordStart = operatorArguments.GetParameter("coord_start", ContribBoxNms.CoordStartDefault)
    /// Index of the scores/confidence of boxes.
    member __.ScoreIndex = operatorArguments.GetParameter("score_index", ContribBoxNms.ScoreIndexDefault)
    /// Optional, index of the class categories, -1 to disable.
    member __.IdIndex = operatorArguments.GetParameter("id_index", ContribBoxNms.IdIndexDefault)
    /// Optional, id of the background class which will be ignored in nms.
    member __.BackgroundId = operatorArguments.GetParameter("background_id", ContribBoxNms.BackgroundIdDefault)
    /// Optional, if set false and id_index is provided, nms will only apply to boxes belongs to the same category
    member __.ForceSuppress = operatorArguments.GetParameter("force_suppress", ContribBoxNms.ForceSuppressDefault)
    /// The input box encoding type. 
    ///  &quot;corner&quot; means boxes are encoded as [xmin, ymin, xmax, ymax], &quot;center&quot; means boxes are encodes as [x, y, width, height].
    member __.InFormat = operatorArguments.GetParameter("in_format", ContribBoxNms.InFormatDefault)
    /// The output box encoding type. 
    ///  &quot;corner&quot; means boxes are encoded as [xmin, ymin, xmax, ymax], &quot;center&quot; means boxes are encodes as [x, y, width, height].
    member __.OutFormat = operatorArguments.GetParameter("out_format", ContribBoxNms.OutFormatDefault)
    /// <summary>Copy ContribBoxNms instance with updated inputs/parameters.</summary>
    /// <param name="data">The input</param>
    /// <param name="overlapThresh">Overlapping(IoU) threshold to suppress object with smaller score.</param>
    /// <param name="validThresh">Filter input boxes to those whose scores greater than valid_thresh.</param>
    /// <param name="topk">Apply nms to topk boxes with descending scores, -1 to no restriction.</param>
    /// <param name="coordStart">Start index of the consecutive 4 coordinates.</param>
    /// <param name="scoreIndex">Index of the scores/confidence of boxes.</param>
    /// <param name="idIndex">Optional, index of the class categories, -1 to disable.</param>
    /// <param name="backgroundId">Optional, id of the background class which will be ignored in nms.</param>
    /// <param name="forceSuppress">Optional, if set false and id_index is provided, nms will only apply to boxes belongs to the same category</param>
    /// <param name="inFormat">The input box encoding type. 
    ///  &quot;corner&quot; means boxes are encoded as [xmin, ymin, xmax, ymax], &quot;center&quot; means boxes are encodes as [x, y, width, height].</param>
    /// <param name="outFormat">The output box encoding type. 
    ///  &quot;corner&quot; means boxes are encoded as [xmin, ymin, xmax, ymax], &quot;center&quot; means boxes are encodes as [x, y, width, height].</param>
    member this.With([<Optional>] ?data : Symbol,
        [<Optional>] ?overlapThresh : float,
        [<Optional>] ?validThresh : float,
        [<Optional>] ?topk : int,
        [<Optional>] ?coordStart : int,
        [<Optional>] ?scoreIndex : int,
        [<Optional>] ?idIndex : int,
        [<Optional>] ?backgroundId : int,
        [<Optional>] ?forceSuppress : bool,
        [<Optional>] ?inFormat : Format,
        [<Optional>] ?outFormat : Format) = 
        let operatorArguments = 
            [
                data |> Option.map (fun x -> "data", Input x)
                overlapThresh |> Option.map (fun x -> "overlap_thresh", Parameter(Some (box x)))
                validThresh |> Option.map (fun x -> "valid_thresh", Parameter(Some (box x)))
                topk |> Option.map (fun x -> "topk", Parameter(Some (box x)))
                coordStart |> Option.map (fun x -> "coord_start", Parameter(Some (box x)))
                scoreIndex |> Option.map (fun x -> "score_index", Parameter(Some (box x)))
                idIndex |> Option.map (fun x -> "id_index", Parameter(Some (box x)))
                backgroundId |> Option.map (fun x -> "background_id", Parameter(Some (box x)))
                forceSuppress |> Option.map (fun x -> "force_suppress", Parameter(Some (box x)))
                inFormat |> Option.map (fun x -> "in_format", Parameter(Some (box x)))
                outFormat |> Option.map (fun x -> "out_format", Parameter(Some (box x)))
            ] |> List.choose id
        new ContribBoxNms(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type ContribBoxIou private (operatorArguments) = 
    inherit SymbolOperator("_contrib_box_iou", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new ContribBoxIou(args)
    override this.WithArguments(args : Arguments<Symbol>) = new ContribBoxIou(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <summary>Bounding box overlap of two arrays.
    ///   The overlap is defined as Intersection-over-Union, aka, IOU.
    ///   - lhs: (a_1, a_2, ..., a_n, 4) array
    ///   - rhs: (b_1, b_2, ..., b_n, 4) array
    ///   - output: (a_1, a_2, ..., a_n, b_1, b_2, ..., b_n) array
    /// 
    ///   Note::
    /// 
    ///     Zero gradients are back-propagated in this op for now.
    /// 
    ///   Example::
    /// 
    ///     x = [[0.5, 0.5, 1.0, 1.0], [0.0, 0.0, 0.5, 0.5]]
    ///     y = [[0.25, 0.25, 0.75, 0.75]]
    ///     box_iou(x, y, format=&#39;corner&#39;) = [[0.1428], [0.1428]]
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\contrib\bounding_box.cc:L134</summary>
    /// <param name="lhs">The first input</param>
    /// <param name="rhs">The second input</param>
    /// <param name="format">The box encoding type. 
    ///  &quot;corner&quot; means boxes are encoded as [xmin, ymin, xmax, ymax], &quot;center&quot; means boxes are encodes as [x, y, width, height].</param>
    new([<Optional>] ?lhs : Symbol,
        [<Optional>] ?rhs : Symbol,
        [<Optional>] ?format : Format) = 
        let lhs = defaultArg lhs (new ImplicitVariable() :> Symbol)
        let rhs = defaultArg rhs (new ImplicitVariable() :> Symbol)
        let operatorArguments = 
            [
                "lhs", Input lhs
                "rhs", Input rhs
                "format", format |> Option.map box |> Parameter
            ]
        new ContribBoxIou(Arguments<Symbol>(operatorArguments))
    /// Default value for Format
    /// The box encoding type. 
    ///  &quot;corner&quot; means boxes are encoded as [xmin, ymin, xmax, ymax], &quot;center&quot; means boxes are encodes as [x, y, width, height].
    static member FormatDefault : Format = Format.Corner
    /// The first input
    member __.Lhs = operatorArguments.GetInput "lhs"
    /// The second input
    member __.Rhs = operatorArguments.GetInput "rhs"
    /// The box encoding type. 
    ///  &quot;corner&quot; means boxes are encoded as [xmin, ymin, xmax, ymax], &quot;center&quot; means boxes are encodes as [x, y, width, height].
    member __.Format = operatorArguments.GetParameter("format", ContribBoxIou.FormatDefault)
    /// <summary>Copy ContribBoxIou instance with updated inputs/parameters.</summary>
    /// <param name="lhs">The first input</param>
    /// <param name="rhs">The second input</param>
    /// <param name="format">The box encoding type. 
    ///  &quot;corner&quot; means boxes are encoded as [xmin, ymin, xmax, ymax], &quot;center&quot; means boxes are encodes as [x, y, width, height].</param>
    member this.With([<Optional>] ?lhs : Symbol,
        [<Optional>] ?rhs : Symbol,
        [<Optional>] ?format : Format) = 
        let operatorArguments = 
            [
                lhs |> Option.map (fun x -> "lhs", Input x)
                rhs |> Option.map (fun x -> "rhs", Input x)
                format |> Option.map (fun x -> "format", Parameter(Some (box x)))
            ] |> List.choose id
        new ContribBoxIou(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type ContribBipartiteMatching private (operatorArguments) = 
    inherit SymbolOperator("_contrib_bipartite_matching", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new ContribBipartiteMatching(args)
    override this.WithArguments(args : Arguments<Symbol>) = new ContribBipartiteMatching(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <summary>Compute bipartite matching.
    ///   The matching is performed on score matrix with shape [B, N, M]
    ///   - B: batch_size
    ///   - N: number of rows to match
    ///   - M: number of columns as reference to be matched against.
    /// 
    ///   Returns:
    ///   x : matched column indices. -1 indicating non-matched elements in rows.
    ///   y : matched row indices.
    /// 
    ///   Note::
    /// 
    ///     Zero gradients are back-propagated in this op for now.
    /// 
    ///   Example::
    /// 
    ///     s = [[0.5, 0.6], [0.1, 0.2], [0.3, 0.4]]
    ///     x, y = bipartite_matching(x, threshold=1e-12, is_ascend=False)
    ///     x = [1, -1, 0]
    ///     y = [2, 0]
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\contrib\bounding_box.cc:L180</summary>
    /// <param name="data">The input</param>
    /// <param name="threshold">Ignore matching when score &lt; thresh, if is_ascend=false, or ignore score &gt; thresh, if is_ascend=true.</param>
    /// <param name="isAscend">Use ascend order for scores instead of descending. Please set threshold accordingly.</param>
    /// <param name="topk">Limit the number of matches to topk, set -1 for no limit</param>
    new(data : Symbol,
        threshold : float,
        [<Optional>] ?isAscend : bool,
        [<Optional>] ?topk : int) = 
        let operatorArguments = 
            [
                "data", Input data
                "threshold", Parameter(Some(box threshold))
                "is_ascend", isAscend |> Option.map box |> Parameter
                "topk", topk |> Option.map box |> Parameter
            ]
        new ContribBipartiteMatching(Arguments<Symbol>(operatorArguments))
    /// <summary>Compute bipartite matching.
    ///   The matching is performed on score matrix with shape [B, N, M]
    ///   - B: batch_size
    ///   - N: number of rows to match
    ///   - M: number of columns as reference to be matched against.
    /// 
    ///   Returns:
    ///   x : matched column indices. -1 indicating non-matched elements in rows.
    ///   y : matched row indices.
    /// 
    ///   Note::
    /// 
    ///     Zero gradients are back-propagated in this op for now.
    /// 
    ///   Example::
    /// 
    ///     s = [[0.5, 0.6], [0.1, 0.2], [0.3, 0.4]]
    ///     x, y = bipartite_matching(x, threshold=1e-12, is_ascend=False)
    ///     x = [1, -1, 0]
    ///     y = [2, 0]
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\contrib\bounding_box.cc:L180</summary>
    /// <param name="threshold">Ignore matching when score &lt; thresh, if is_ascend=false, or ignore score &gt; thresh, if is_ascend=true.</param>
    /// <param name="data">The input</param>
    /// <param name="isAscend">Use ascend order for scores instead of descending. Please set threshold accordingly.</param>
    /// <param name="topk">Limit the number of matches to topk, set -1 for no limit</param>
    new(threshold : float,
        [<Optional>] ?data : Symbol,
        [<Optional>] ?isAscend : bool,
        [<Optional>] ?topk : int) = 
        let data = defaultArg data (new ImplicitVariable() :> Symbol)
        let operatorArguments = 
            [
                "data", Input data
                "threshold", Parameter(Some(box threshold))
                "is_ascend", isAscend |> Option.map box |> Parameter
                "topk", topk |> Option.map box |> Parameter
            ]
        new ContribBipartiteMatching(Arguments<Symbol>(operatorArguments))
    /// Default value for IsAscend
    /// Use ascend order for scores instead of descending. Please set threshold accordingly.
    static member IsAscendDefault : bool = false
    /// Default value for Topk
    /// Limit the number of matches to topk, set -1 for no limit
    static member TopkDefault : int = -1
    /// The input
    member __.Data = operatorArguments.GetInput "data"
    /// Ignore matching when score &lt; thresh, if is_ascend=false, or ignore score &gt; thresh, if is_ascend=true.
    member __.Threshold : float = match operatorArguments.GetParameter "threshold" with Some(v) -> unbox v | None -> failwithf "Required parameter threshold is missing"
    /// Use ascend order for scores instead of descending. Please set threshold accordingly.
    member __.IsAscend = operatorArguments.GetParameter("is_ascend", ContribBipartiteMatching.IsAscendDefault)
    /// Limit the number of matches to topk, set -1 for no limit
    member __.Topk = operatorArguments.GetParameter("topk", ContribBipartiteMatching.TopkDefault)
    /// <summary>Copy ContribBipartiteMatching instance with updated inputs/parameters.</summary>
    /// <param name="data">The input</param>
    /// <param name="threshold">Ignore matching when score &lt; thresh, if is_ascend=false, or ignore score &gt; thresh, if is_ascend=true.</param>
    /// <param name="isAscend">Use ascend order for scores instead of descending. Please set threshold accordingly.</param>
    /// <param name="topk">Limit the number of matches to topk, set -1 for no limit</param>
    member this.With([<Optional>] ?data : Symbol,
        [<Optional>] ?threshold : float,
        [<Optional>] ?isAscend : bool,
        [<Optional>] ?topk : int) = 
        let operatorArguments = 
            [
                data |> Option.map (fun x -> "data", Input x)
                threshold |> Option.map (fun x -> "threshold", Parameter(Some (box x)))
                isAscend |> Option.map (fun x -> "is_ascend", Parameter(Some (box x)))
                topk |> Option.map (fun x -> "topk", Parameter(Some (box x)))
            ] |> List.choose id
        new ContribBipartiteMatching(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type ContribDglCsrNeighborUniformSample private (operatorArguments) = 
    inherit SymbolOperator("_contrib_dgl_csr_neighbor_uniform_sample", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new ContribDglCsrNeighborUniformSample(args)
    override this.WithArguments(args : Arguments<Symbol>) = new ContribDglCsrNeighborUniformSample(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <summary>This operator samples sub-graphs from a csr graph via an
    /// uniform probability. The operator is designed for DGL.
    /// 
    /// The operator outputs three sets of NDArrays to represent the sampled results
    /// (the number of NDArrays in each set is the same as the number of seed NDArrays):
    /// 1) a set of 1D NDArrays containing the sampled vertices, 2) a set of CSRNDArrays representing
    /// the sampled edges, 3) a set of 1D NDArrays indicating the layer where a vertex is sampled.
    /// The first set of 1D NDArrays have a length of max_num_vertices+1. The last element in an NDArray
    /// indicate the acutal number of vertices in a subgraph. The third set of NDArrays have a length
    /// of max_num_vertices, and the valid number of vertices is the same as the ones in the first set.
    /// 
    /// Example:
    /// 
    ///    .. code:: python
    /// 
    ///   shape = (5, 5)
    ///   data_np = np.array([1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20], dtype=np.int64)
    ///   indices_np = np.array([1,2,3,4,0,2,3,4,0,1,3,4,0,1,2,4,0,1,2,3], dtype=np.int64)
    ///   indptr_np = np.array([0,4,8,12,16,20], dtype=np.int64)
    ///   a = mx.nd.sparse.csr_matrix((data_np, indices_np, indptr_np), shape=shape)
    ///   a.asnumpy()
    ///   seed = mx.nd.array([0,1,2,3,4], dtype=np.int64)
    ///   out = mx.nd.contrib.dgl_csr_neighbor_uniform_sample(a, seed, num_args=2, num_hops=1, num_neighbor=2, max_num_vertices=5)
    /// 
    ///   out[0]
    ///   [0 1 2 3 4 5]
    ///   &lt;NDArray 6 @cpu(0)&gt;
    /// 
    ///   out[1].asnumpy()
    ///   array([[ 0,  1,  0,  3,  0],
    ///          [ 5,  0,  0,  7,  0],
    ///          [ 9,  0,  0, 11,  0],
    ///          [13,  0, 15,  0,  0],
    ///          [17,  0, 19,  0,  0]])
    /// 
    ///   out[2]
    ///   [0 0 0 0 0]
    ///   &lt;NDArray 5 @cpu(0)&gt;
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\contrib\dgl_graph.cc:L784</summary>
    /// <param name="csrMatrix">csr matrix</param>
    /// <param name="seedArrays">seed vertices</param>
    /// <param name="numHops">Number of hops.</param>
    /// <param name="numNeighbor">Number of neighbor.</param>
    /// <param name="maxNumVertices">Max number of vertices.</param>
    new([<Optional>] ?csrMatrix : Symbol,
        [<Optional>] ?seedArrays : Symbol seq,
        [<Optional>] ?numHops : int64,
        [<Optional>] ?numNeighbor : int64,
        [<Optional>] ?maxNumVertices : int64) = 
        let csrMatrix = defaultArg csrMatrix (new ImplicitVariable() :> Symbol)
        let seedArrays = defaultArg (seedArrays |> Option.map Seq.toArray) Array.empty
        let operatorArguments = 
            [
                "csr_matrix", Input csrMatrix
                "seed_arrays", VarArg("num_args", seedArrays)
                "num_hops", numHops |> Option.map box |> Parameter
                "num_neighbor", numNeighbor |> Option.map box |> Parameter
                "max_num_vertices", maxNumVertices |> Option.map box |> Parameter
            ]
        new ContribDglCsrNeighborUniformSample(Arguments<Symbol>(operatorArguments))
    /// Default value for NumHops
    /// Number of hops.
    static member NumHopsDefault : int64 = 1L
    /// Default value for NumNeighbor
    /// Number of neighbor.
    static member NumNeighborDefault : int64 = 2L
    /// Default value for MaxNumVertices
    /// Max number of vertices.
    static member MaxNumVerticesDefault : int64 = 100L
    /// csr matrix
    member __.CsrMatrix = operatorArguments.GetInput "csr_matrix"
    /// seed vertices
    member __.SeedArrays = operatorArguments.GetVarArg "seed_arrays"
    /// Number of hops.
    member __.NumHops = operatorArguments.GetParameter("num_hops", ContribDglCsrNeighborUniformSample.NumHopsDefault)
    /// Number of neighbor.
    member __.NumNeighbor = operatorArguments.GetParameter("num_neighbor", ContribDglCsrNeighborUniformSample.NumNeighborDefault)
    /// Max number of vertices.
    member __.MaxNumVertices = operatorArguments.GetParameter("max_num_vertices", ContribDglCsrNeighborUniformSample.MaxNumVerticesDefault)
    /// <summary>Copy ContribDglCsrNeighborUniformSample instance with updated inputs/parameters.</summary>
    /// <param name="csrMatrix">csr matrix</param>
    /// <param name="seedArrays">seed vertices</param>
    /// <param name="numHops">Number of hops.</param>
    /// <param name="numNeighbor">Number of neighbor.</param>
    /// <param name="maxNumVertices">Max number of vertices.</param>
    member this.With([<Optional>] ?csrMatrix : Symbol,
        [<Optional>] ?seedArrays : Symbol seq,
        [<Optional>] ?numHops : int64,
        [<Optional>] ?numNeighbor : int64,
        [<Optional>] ?maxNumVertices : int64) = 
        let operatorArguments = 
            [
                csrMatrix |> Option.map (fun x -> "csr_matrix", Input x)
                seedArrays |> Option.map (fun x -> "seed_arrays", VarArg("num_args", Seq.toArray x))
                numHops |> Option.map (fun x -> "num_hops", Parameter(Some (box x)))
                numNeighbor |> Option.map (fun x -> "num_neighbor", Parameter(Some (box x)))
                maxNumVertices |> Option.map (fun x -> "max_num_vertices", Parameter(Some (box x)))
            ] |> List.choose id
        new ContribDglCsrNeighborUniformSample(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type ContribDglCsrNeighborNonUniformSample private (operatorArguments) = 
    inherit SymbolOperator("_contrib_dgl_csr_neighbor_non_uniform_sample", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new ContribDglCsrNeighborNonUniformSample(args)
    override this.WithArguments(args : Arguments<Symbol>) = new ContribDglCsrNeighborNonUniformSample(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <summary>This operator samples sub-graph from a csr graph via an
    /// non-uniform probability. The operator is designed for DGL.
    /// 
    /// The operator outputs four sets of NDArrays to represent the sampled results
    /// (the number of NDArrays in each set is the same as the number of seed NDArrays):
    /// 1) a set of 1D NDArrays containing the sampled vertices, 2) a set of CSRNDArrays representing
    /// the sampled edges, 3) a set of 1D NDArrays with the probability that vertices are sampled,
    /// 4) a set of 1D NDArrays indicating the layer where a vertex is sampled.
    /// The first set of 1D NDArrays have a length of max_num_vertices+1. The last element in an NDArray
    /// indicate the acutal number of vertices in a subgraph. The third and fourth set of NDArrays have a length
    /// of max_num_vertices, and the valid number of vertices is the same as the ones in the first set.
    /// 
    /// Example:
    /// 
    ///    .. code:: python
    /// 
    ///   shape = (5, 5)
    ///   prob = mx.nd.array([0.9, 0.8, 0.2, 0.4, 0.1], dtype=np.float32)
    ///   data_np = np.array([1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20], dtype=np.int64)
    ///   indices_np = np.array([1,2,3,4,0,2,3,4,0,1,3,4,0,1,2,4,0,1,2,3], dtype=np.int64)
    ///   indptr_np = np.array([0,4,8,12,16,20], dtype=np.int64)
    ///   a = mx.nd.sparse.csr_matrix((data_np, indices_np, indptr_np), shape=shape)
    ///   seed = mx.nd.array([0,1,2,3,4], dtype=np.int64)
    ///   out = mx.nd.contrib.dgl_csr_neighbor_non_uniform_sample(a, prob, seed, num_args=3, num_hops=1, num_neighbor=2, max_num_vertices=5)
    /// 
    ///   out[0]
    ///   [0 1 2 3 4 5]
    ///   &lt;NDArray 6 @cpu(0)&gt;
    /// 
    ///   out[1].asnumpy()
    ///   array([[ 0,  1,  2,  0,  0],
    ///          [ 5,  0,  6,  0,  0],
    ///          [ 9, 10,  0,  0,  0],
    ///          [13, 14,  0,  0,  0],
    ///          [ 0, 18, 19,  0,  0]])
    /// 
    ///   out[2]
    ///   [0.9 0.8 0.2 0.4 0.1]
    ///   &lt;NDArray 5 @cpu(0)&gt;
    /// 
    ///   out[3]
    ///   [0 0 0 0 0]
    ///   &lt;NDArray 5 @cpu(0)&gt;
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\contrib\dgl_graph.cc:L883</summary>
    /// <param name="csrMatrix">csr matrix</param>
    /// <param name="probability">probability vector</param>
    /// <param name="seedArrays">seed vertices</param>
    /// <param name="numHops">Number of hops.</param>
    /// <param name="numNeighbor">Number of neighbor.</param>
    /// <param name="maxNumVertices">Max number of vertices.</param>
    new([<Optional>] ?csrMatrix : Symbol,
        [<Optional>] ?probability : Symbol,
        [<Optional>] ?seedArrays : Symbol seq,
        [<Optional>] ?numHops : int64,
        [<Optional>] ?numNeighbor : int64,
        [<Optional>] ?maxNumVertices : int64) = 
        let csrMatrix = defaultArg csrMatrix (new ImplicitVariable() :> Symbol)
        let probability = defaultArg probability (new ImplicitVariable() :> Symbol)
        let seedArrays = defaultArg (seedArrays |> Option.map Seq.toArray) Array.empty
        let operatorArguments = 
            [
                "csr_matrix", Input csrMatrix
                "probability", Input probability
                "seed_arrays", VarArg("num_args", seedArrays)
                "num_hops", numHops |> Option.map box |> Parameter
                "num_neighbor", numNeighbor |> Option.map box |> Parameter
                "max_num_vertices", maxNumVertices |> Option.map box |> Parameter
            ]
        new ContribDglCsrNeighborNonUniformSample(Arguments<Symbol>(operatorArguments))
    /// Default value for NumHops
    /// Number of hops.
    static member NumHopsDefault : int64 = 1L
    /// Default value for NumNeighbor
    /// Number of neighbor.
    static member NumNeighborDefault : int64 = 2L
    /// Default value for MaxNumVertices
    /// Max number of vertices.
    static member MaxNumVerticesDefault : int64 = 100L
    /// csr matrix
    member __.CsrMatrix = operatorArguments.GetInput "csr_matrix"
    /// probability vector
    member __.Probability = operatorArguments.GetInput "probability"
    /// seed vertices
    member __.SeedArrays = operatorArguments.GetVarArg "seed_arrays"
    /// Number of hops.
    member __.NumHops = operatorArguments.GetParameter("num_hops", ContribDglCsrNeighborNonUniformSample.NumHopsDefault)
    /// Number of neighbor.
    member __.NumNeighbor = operatorArguments.GetParameter("num_neighbor", ContribDglCsrNeighborNonUniformSample.NumNeighborDefault)
    /// Max number of vertices.
    member __.MaxNumVertices = operatorArguments.GetParameter("max_num_vertices", ContribDglCsrNeighborNonUniformSample.MaxNumVerticesDefault)
    /// <summary>Copy ContribDglCsrNeighborNonUniformSample instance with updated inputs/parameters.</summary>
    /// <param name="csrMatrix">csr matrix</param>
    /// <param name="probability">probability vector</param>
    /// <param name="seedArrays">seed vertices</param>
    /// <param name="numHops">Number of hops.</param>
    /// <param name="numNeighbor">Number of neighbor.</param>
    /// <param name="maxNumVertices">Max number of vertices.</param>
    member this.With([<Optional>] ?csrMatrix : Symbol,
        [<Optional>] ?probability : Symbol,
        [<Optional>] ?seedArrays : Symbol seq,
        [<Optional>] ?numHops : int64,
        [<Optional>] ?numNeighbor : int64,
        [<Optional>] ?maxNumVertices : int64) = 
        let operatorArguments = 
            [
                csrMatrix |> Option.map (fun x -> "csr_matrix", Input x)
                probability |> Option.map (fun x -> "probability", Input x)
                seedArrays |> Option.map (fun x -> "seed_arrays", VarArg("num_args", Seq.toArray x))
                numHops |> Option.map (fun x -> "num_hops", Parameter(Some (box x)))
                numNeighbor |> Option.map (fun x -> "num_neighbor", Parameter(Some (box x)))
                maxNumVertices |> Option.map (fun x -> "max_num_vertices", Parameter(Some (box x)))
            ] |> List.choose id
        new ContribDglCsrNeighborNonUniformSample(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type ContribDglSubgraph private (operatorArguments) = 
    inherit SymbolOperator("_contrib_dgl_subgraph", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new ContribDglSubgraph(args)
    override this.WithArguments(args : Arguments<Symbol>) = new ContribDglSubgraph(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <summary>This operator constructs an induced subgraph for
    /// a given set of vertices from a graph. The operator accepts multiple
    /// sets of vertices as input. For each set of vertices, it returns a pair
    /// of CSR matrices if return_mapping is True: the first matrix contains edges
    /// with new edge Ids, the second matrix contains edges with the original
    /// edge Ids.
    /// 
    /// Example:
    /// 
    ///    .. code:: python
    /// 
    ///      x=[[1, 0, 0, 2],
    ///        [3, 0, 4, 0],
    ///        [0, 5, 0, 0],
    ///        [0, 6, 7, 0]]
    ///      v = [0, 1, 2]
    ///      dgl_subgraph(x, v, return_mapping=True) =
    ///        [[1, 0, 0],
    ///         [2, 0, 3],
    ///         [0, 4, 0]],
    ///        [[1, 0, 0],
    ///         [3, 0, 4],
    ///         [0, 5, 0]]
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\contrib\dgl_graph.cc:L1140</summary>
    /// <param name="graph">Input graph where we sample vertices.</param>
    /// <param name="data">The input arrays that include data arrays and states.</param>
    /// <param name="returnMapping">Return mapping of vid and eid between the subgraph and the parent graph.</param>
    new(graph : Symbol,
        data : Symbol seq,
        returnMapping : bool) = 
        let operatorArguments = 
            [
                "graph", Input graph
                "data", VarArg("num_args", data |> Seq.toArray)
                "return_mapping", Parameter(Some(box returnMapping))
            ]
        new ContribDglSubgraph(Arguments<Symbol>(operatorArguments))
    /// <summary>This operator constructs an induced subgraph for
    /// a given set of vertices from a graph. The operator accepts multiple
    /// sets of vertices as input. For each set of vertices, it returns a pair
    /// of CSR matrices if return_mapping is True: the first matrix contains edges
    /// with new edge Ids, the second matrix contains edges with the original
    /// edge Ids.
    /// 
    /// Example:
    /// 
    ///    .. code:: python
    /// 
    ///      x=[[1, 0, 0, 2],
    ///        [3, 0, 4, 0],
    ///        [0, 5, 0, 0],
    ///        [0, 6, 7, 0]]
    ///      v = [0, 1, 2]
    ///      dgl_subgraph(x, v, return_mapping=True) =
    ///        [[1, 0, 0],
    ///         [2, 0, 3],
    ///         [0, 4, 0]],
    ///        [[1, 0, 0],
    ///         [3, 0, 4],
    ///         [0, 5, 0]]
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\contrib\dgl_graph.cc:L1140</summary>
    /// <param name="returnMapping">Return mapping of vid and eid between the subgraph and the parent graph.</param>
    /// <param name="graph">Input graph where we sample vertices.</param>
    /// <param name="data">The input arrays that include data arrays and states.</param>
    new(returnMapping : bool,
        [<Optional>] ?graph : Symbol,
        [<Optional>] ?data : Symbol seq) = 
        let graph = defaultArg graph (new ImplicitVariable() :> Symbol)
        let data = defaultArg (data |> Option.map Seq.toArray) Array.empty
        let operatorArguments = 
            [
                "graph", Input graph
                "data", VarArg("num_args", data)
                "return_mapping", Parameter(Some(box returnMapping))
            ]
        new ContribDglSubgraph(Arguments<Symbol>(operatorArguments))
    /// Input graph where we sample vertices.
    member __.Graph = operatorArguments.GetInput "graph"
    /// The input arrays that include data arrays and states.
    member __.Data = operatorArguments.GetVarArg "data"
    /// Return mapping of vid and eid between the subgraph and the parent graph.
    member __.ReturnMapping : bool = match operatorArguments.GetParameter "return_mapping" with Some(v) -> unbox v | None -> failwithf "Required parameter return_mapping is missing"
    /// <summary>Copy ContribDglSubgraph instance with updated inputs/parameters.</summary>
    /// <param name="graph">Input graph where we sample vertices.</param>
    /// <param name="data">The input arrays that include data arrays and states.</param>
    /// <param name="returnMapping">Return mapping of vid and eid between the subgraph and the parent graph.</param>
    member this.With([<Optional>] ?graph : Symbol,
        [<Optional>] ?data : Symbol seq,
        [<Optional>] ?returnMapping : bool) = 
        let operatorArguments = 
            [
                graph |> Option.map (fun x -> "graph", Input x)
                data |> Option.map (fun x -> "data", VarArg("num_args", Seq.toArray x))
                returnMapping |> Option.map (fun x -> "return_mapping", Parameter(Some (box x)))
            ] |> List.choose id
        new ContribDglSubgraph(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type ContribEdgeId private (operatorArguments) = 
    inherit SymbolOperator("_contrib_edge_id", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new ContribEdgeId(args)
    override this.WithArguments(args : Arguments<Symbol>) = new ContribEdgeId(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <summary>This operator implements the edge_id function for a graph
    /// stored in a CSR matrix (the value of the CSR stores the edge Id of the graph).
    /// output[i] = input[u[i], v[i]] if there is an edge between u[i] and v[i]],
    /// otherwise output[i] will be -1. Both u and v should be 1D vectors.
    /// 
    /// Example:
    /// 
    ///    .. code:: python
    /// 
    ///       x = [[ 1, 0, 0 ],
    ///            [ 0, 2, 0 ],
    ///            [ 0, 0, 3 ]]
    ///       u = [ 0, 0, 1, 1, 2, 2 ]
    ///       v = [ 0, 1, 1, 2, 0, 2 ]
    ///       edge_id(x, u, v) = [ 1, -1, 2, -1, -1, 3 ]
    /// 
    /// The storage type of ``edge_id`` output depends on storage types of inputs
    ///   - edge_id(csr, default, default) = default
    ///   - default and rsp inputs are not supported
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\contrib\dgl_graph.cc:L1321</summary>
    /// <param name="data">Input ndarray</param>
    /// <param name="u">u ndarray</param>
    /// <param name="v">v ndarray</param>
    new([<Optional>] ?data : Symbol,
        [<Optional>] ?u : Symbol,
        [<Optional>] ?v : Symbol) = 
        let data = defaultArg data (new ImplicitVariable() :> Symbol)
        let u = defaultArg u (new ImplicitVariable() :> Symbol)
        let v = defaultArg v (new ImplicitVariable() :> Symbol)
        let operatorArguments = 
            [
                "data", Input data
                "u", Input u
                "v", Input v
            ]
        new ContribEdgeId(Arguments<Symbol>(operatorArguments))
    /// Input ndarray
    member __.Data = operatorArguments.GetInput "data"
    /// u ndarray
    member __.U = operatorArguments.GetInput "u"
    /// v ndarray
    member __.V = operatorArguments.GetInput "v"
    /// <summary>Copy ContribEdgeId instance with updated inputs/parameters.</summary>
    /// <param name="data">Input ndarray</param>
    /// <param name="u">u ndarray</param>
    /// <param name="v">v ndarray</param>
    member this.With([<Optional>] ?data : Symbol,
        [<Optional>] ?u : Symbol,
        [<Optional>] ?v : Symbol) = 
        let operatorArguments = 
            [
                data |> Option.map (fun x -> "data", Input x)
                u |> Option.map (fun x -> "u", Input x)
                v |> Option.map (fun x -> "v", Input x)
            ] |> List.choose id
        new ContribEdgeId(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type ContribDglAdjacency private (operatorArguments) = 
    inherit SymbolOperator("_contrib_dgl_adjacency", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new ContribDglAdjacency(args)
    override this.WithArguments(args : Arguments<Symbol>) = new ContribDglAdjacency(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <summary>This operator converts a CSR matrix whose values are edge Ids
    /// to an adjacency matrix whose values are ones. The output CSR matrix always has
    /// the data value of float32.
    /// 
    /// Example:
    /// 
    ///    .. code:: python
    /// 
    ///   x = [[ 1, 0, 0 ],
    ///        [ 0, 2, 0 ],
    ///        [ 0, 0, 3 ]]
    ///   dgl_adjacency(x) =
    ///       [[ 1, 0, 0 ],
    ///        [ 0, 1, 0 ],
    ///        [ 0, 0, 1 ]]
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\contrib\dgl_graph.cc:L1393</summary>
    /// <param name="data">Input ndarray</param>
    new([<Optional>] ?data : Symbol) =
        let data = defaultArg data (new ImplicitVariable() :> Symbol)
        let operatorArguments = 
            [
                "data", Input data
            ]
        new ContribDglAdjacency(Arguments<Symbol>(operatorArguments))
    /// Input ndarray
    member __.Data = operatorArguments.GetInput "data"
    /// <summary>Copy ContribDglAdjacency instance with updated inputs/parameters.</summary>
    /// <param name="data">Input ndarray</param>
    member this.With([<Optional>] ?data : Symbol) =
        let operatorArguments = 
            [
                data |> Option.map (fun x -> "data", Input x)
            ] |> List.choose id
        new ContribDglAdjacency(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type ContribDglGraphCompact private (operatorArguments) = 
    inherit SymbolOperator("_contrib_dgl_graph_compact", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new ContribDglGraphCompact(args)
    override this.WithArguments(args : Arguments<Symbol>) = new ContribDglGraphCompact(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <summary>This operator compacts a CSR matrix generated by
    /// dgl_csr_neighbor_uniform_sample and dgl_csr_neighbor_non_uniform_sample.
    /// The CSR matrices generated by these two operators may have many empty
    /// rows at the end and many empty columns. This operator removes these
    /// empty rows and empty columns.
    /// 
    /// Example:
    /// 
    ///    .. code:: python
    /// 
    ///   shape = (5, 5)
    ///   data_np = np.array([1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20], dtype=np.int64)
    ///   indices_np = np.array([1,2,3,4,0,2,3,4,0,1,3,4,0,1,2,4,0,1,2,3], dtype=np.int64)
    ///   indptr_np = np.array([0,4,8,12,16,20], dtype=np.int64)
    ///   a = mx.nd.sparse.csr_matrix((data_np, indices_np, indptr_np), shape=shape)
    ///   seed = mx.nd.array([0,1,2,3,4], dtype=np.int64)
    ///   out = mx.nd.contrib.dgl_csr_neighbor_uniform_sample(a, seed, num_args=2, num_hops=1,
    ///           num_neighbor=2, max_num_vertices=6)
    ///   subg_v = out[0]
    ///   subg = out[1]
    ///   compact = mx.nd.contrib.dgl_graph_compact(subg, subg_v,
    ///           graph_sizes=(subg_v[-1].asnumpy()[0]), return_mapping=False)
    /// 
    ///   compact.asnumpy()
    ///   array([[0, 0, 0, 1, 0],
    ///          [2, 0, 3, 0, 0],
    ///          [0, 4, 0, 0, 5],
    ///          [0, 6, 0, 0, 7],
    ///          [8, 9, 0, 0, 0]])
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\contrib\dgl_graph.cc:L1582</summary>
    /// <param name="graphData">Input graphs and input vertex Ids.</param>
    /// <param name="returnMapping">Return mapping of vid and eid between the subgraph and the parent graph.</param>
    /// <param name="graphSizes">the number of vertices in each graph.</param>
    new(graphData : Symbol seq,
        returnMapping : bool,
        graphSizes : int64 seq) = 
        let operatorArguments = 
            [
                "graph_data", VarArg("num_args", graphData |> Seq.toArray)
                "return_mapping", Parameter(Some(box returnMapping))
                "graph_sizes", Parameter(Some(box graphSizes))
            ]
        new ContribDglGraphCompact(Arguments<Symbol>(operatorArguments))
    /// <summary>This operator compacts a CSR matrix generated by
    /// dgl_csr_neighbor_uniform_sample and dgl_csr_neighbor_non_uniform_sample.
    /// The CSR matrices generated by these two operators may have many empty
    /// rows at the end and many empty columns. This operator removes these
    /// empty rows and empty columns.
    /// 
    /// Example:
    /// 
    ///    .. code:: python
    /// 
    ///   shape = (5, 5)
    ///   data_np = np.array([1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20], dtype=np.int64)
    ///   indices_np = np.array([1,2,3,4,0,2,3,4,0,1,3,4,0,1,2,4,0,1,2,3], dtype=np.int64)
    ///   indptr_np = np.array([0,4,8,12,16,20], dtype=np.int64)
    ///   a = mx.nd.sparse.csr_matrix((data_np, indices_np, indptr_np), shape=shape)
    ///   seed = mx.nd.array([0,1,2,3,4], dtype=np.int64)
    ///   out = mx.nd.contrib.dgl_csr_neighbor_uniform_sample(a, seed, num_args=2, num_hops=1,
    ///           num_neighbor=2, max_num_vertices=6)
    ///   subg_v = out[0]
    ///   subg = out[1]
    ///   compact = mx.nd.contrib.dgl_graph_compact(subg, subg_v,
    ///           graph_sizes=(subg_v[-1].asnumpy()[0]), return_mapping=False)
    /// 
    ///   compact.asnumpy()
    ///   array([[0, 0, 0, 1, 0],
    ///          [2, 0, 3, 0, 0],
    ///          [0, 4, 0, 0, 5],
    ///          [0, 6, 0, 0, 7],
    ///          [8, 9, 0, 0, 0]])
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\contrib\dgl_graph.cc:L1582</summary>
    /// <param name="returnMapping">Return mapping of vid and eid between the subgraph and the parent graph.</param>
    /// <param name="graphSizes">the number of vertices in each graph.</param>
    /// <param name="graphData">Input graphs and input vertex Ids.</param>
    new(returnMapping : bool,
        graphSizes : int64 seq,
        [<Optional>] ?graphData : Symbol seq) = 
        let graphData = defaultArg (graphData |> Option.map Seq.toArray) Array.empty
        let operatorArguments = 
            [
                "graph_data", VarArg("num_args", graphData)
                "return_mapping", Parameter(Some(box returnMapping))
                "graph_sizes", Parameter(Some(box graphSizes))
            ]
        new ContribDglGraphCompact(Arguments<Symbol>(operatorArguments))
    /// <summary>This operator compacts a CSR matrix generated by
    /// dgl_csr_neighbor_uniform_sample and dgl_csr_neighbor_non_uniform_sample.
    /// The CSR matrices generated by these two operators may have many empty
    /// rows at the end and many empty columns. This operator removes these
    /// empty rows and empty columns.
    /// 
    /// Example:
    /// 
    ///    .. code:: python
    /// 
    ///   shape = (5, 5)
    ///   data_np = np.array([1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20], dtype=np.int64)
    ///   indices_np = np.array([1,2,3,4,0,2,3,4,0,1,3,4,0,1,2,4,0,1,2,3], dtype=np.int64)
    ///   indptr_np = np.array([0,4,8,12,16,20], dtype=np.int64)
    ///   a = mx.nd.sparse.csr_matrix((data_np, indices_np, indptr_np), shape=shape)
    ///   seed = mx.nd.array([0,1,2,3,4], dtype=np.int64)
    ///   out = mx.nd.contrib.dgl_csr_neighbor_uniform_sample(a, seed, num_args=2, num_hops=1,
    ///           num_neighbor=2, max_num_vertices=6)
    ///   subg_v = out[0]
    ///   subg = out[1]
    ///   compact = mx.nd.contrib.dgl_graph_compact(subg, subg_v,
    ///           graph_sizes=(subg_v[-1].asnumpy()[0]), return_mapping=False)
    /// 
    ///   compact.asnumpy()
    ///   array([[0, 0, 0, 1, 0],
    ///          [2, 0, 3, 0, 0],
    ///          [0, 4, 0, 0, 5],
    ///          [0, 6, 0, 0, 7],
    ///          [8, 9, 0, 0, 0]])
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\contrib\dgl_graph.cc:L1582</summary>
    /// <param name="returnMapping">Return mapping of vid and eid between the subgraph and the parent graph.</param>
    /// <param name="graphSizes">the number of vertices in each graph.</param>
    /// <param name="graphData">Input graphs and input vertex Ids.</param>
    new(returnMapping : bool,
        graphSizes : int64 seq,
        [<ParamArray>] graphData : Symbol[]) = 
        let operatorArguments = 
            [
                "graph_data", VarArg("num_args", graphData)
                "return_mapping", Parameter(Some(box returnMapping))
                "graph_sizes", Parameter(Some(box graphSizes))
            ]
        new ContribDglGraphCompact(Arguments<Symbol>(operatorArguments))
    /// Input graphs and input vertex Ids.
    member __.GraphData = operatorArguments.GetVarArg "graph_data"
    /// Return mapping of vid and eid between the subgraph and the parent graph.
    member __.ReturnMapping : bool = match operatorArguments.GetParameter "return_mapping" with Some(v) -> unbox v | None -> failwithf "Required parameter return_mapping is missing"
    /// the number of vertices in each graph.
    member __.GraphSizes : int64 seq = match operatorArguments.GetParameter "graph_sizes" with Some(v) -> unbox v | None -> failwithf "Required parameter graph_sizes is missing"
    /// <summary>Copy ContribDglGraphCompact instance with updated inputs/parameters.</summary>
    /// <param name="graphData">Input graphs and input vertex Ids.</param>
    /// <param name="returnMapping">Return mapping of vid and eid between the subgraph and the parent graph.</param>
    /// <param name="graphSizes">the number of vertices in each graph.</param>
    member this.With([<Optional>] ?graphData : Symbol seq,
        [<Optional>] ?returnMapping : bool,
        [<Optional>] ?graphSizes : int64 seq) = 
        let operatorArguments = 
            [
                graphData |> Option.map (fun x -> "graph_data", VarArg("num_args", Seq.toArray x))
                returnMapping |> Option.map (fun x -> "return_mapping", Parameter(Some (box x)))
                graphSizes |> Option.map (fun x -> "graph_sizes", Parameter(Some (box x)))
            ] |> List.choose id
        new ContribDglGraphCompact(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type ContribGradientmultiplier private (operatorArguments) = 
    inherit SymbolOperator("_contrib_gradientmultiplier", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new ContribGradientmultiplier(args)
    override this.WithArguments(args : Arguments<Symbol>) = new ContribGradientmultiplier(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <summary>This operator implements the gradient multiplier function.
    /// In forward pass it acts as an identity transform. During backpropagation it
    /// multiplies the gradient from the subsequent level by a scalar factor lambda and passes it to
    /// the preceding layer.
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\contrib\gradient_multiplier_op.cc:L78</summary>
    /// <param name="data">The input array.</param>
    /// <param name="scalar">lambda multiplier</param>
    new(data : Symbol,
        scalar : float) = 
        let operatorArguments = 
            [
                "data", Input data
                "scalar", Parameter(Some(box scalar))
            ]
        new ContribGradientmultiplier(Arguments<Symbol>(operatorArguments))
    /// <summary>This operator implements the gradient multiplier function.
    /// In forward pass it acts as an identity transform. During backpropagation it
    /// multiplies the gradient from the subsequent level by a scalar factor lambda and passes it to
    /// the preceding layer.
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\contrib\gradient_multiplier_op.cc:L78</summary>
    /// <param name="scalar">lambda multiplier</param>
    /// <param name="data">The input array.</param>
    new(scalar : float,
        [<Optional>] ?data : Symbol) = 
        let data = defaultArg data (new ImplicitVariable() :> Symbol)
        let operatorArguments = 
            [
                "data", Input data
                "scalar", Parameter(Some(box scalar))
            ]
        new ContribGradientmultiplier(Arguments<Symbol>(operatorArguments))
    /// The input array.
    member __.Data = operatorArguments.GetInput "data"
    /// lambda multiplier
    member __.Scalar : float = match operatorArguments.GetParameter "scalar" with Some(v) -> unbox v | None -> failwithf "Required parameter scalar is missing"
    /// <summary>Copy ContribGradientmultiplier instance with updated inputs/parameters.</summary>
    /// <param name="data">The input array.</param>
    /// <param name="scalar">lambda multiplier</param>
    member this.With([<Optional>] ?data : Symbol,
        [<Optional>] ?scalar : float) = 
        let operatorArguments = 
            [
                data |> Option.map (fun x -> "data", Input x)
                scalar |> Option.map (fun x -> "scalar", Parameter(Some (box x)))
            ] |> List.choose id
        new ContribGradientmultiplier(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type ContribBackwardGradientmultiplier private (operatorArguments) = 
    inherit SymbolOperator("_contrib_backward_gradientmultiplier", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new ContribBackwardGradientmultiplier(args)
    override this.WithArguments(args : Arguments<Symbol>) = new ContribBackwardGradientmultiplier(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <param name="data">source input</param>
    /// <param name="scalar">scalar input</param>
    new(data : Symbol,
        scalar : float) = 
        let operatorArguments = 
            [
                "data", Input data
                "scalar", Parameter(Some(box scalar))
            ]
        new ContribBackwardGradientmultiplier(Arguments<Symbol>(operatorArguments))
    /// <param name="scalar">scalar input</param>
    /// <param name="data">source input</param>
    new(scalar : float,
        [<Optional>] ?data : Symbol) = 
        let data = defaultArg data (new ImplicitVariable() :> Symbol)
        let operatorArguments = 
            [
                "data", Input data
                "scalar", Parameter(Some(box scalar))
            ]
        new ContribBackwardGradientmultiplier(Arguments<Symbol>(operatorArguments))
    /// source input
    member __.Data = operatorArguments.GetInput "data"
    /// scalar input
    member __.Scalar : float = match operatorArguments.GetParameter "scalar" with Some(v) -> unbox v | None -> failwithf "Required parameter scalar is missing"
    /// <summary>Copy ContribBackwardGradientmultiplier instance with updated inputs/parameters.</summary>
    /// <param name="data">source input</param>
    /// <param name="scalar">scalar input</param>
    member this.With([<Optional>] ?data : Symbol,
        [<Optional>] ?scalar : float) = 
        let operatorArguments = 
            [
                data |> Option.map (fun x -> "data", Input x)
                scalar |> Option.map (fun x -> "scalar", Parameter(Some (box x)))
            ] |> List.choose id
        new ContribBackwardGradientmultiplier(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type ContribHawkesll private (operatorArguments) = 
    inherit SymbolOperator("_contrib_hawkesll", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new ContribHawkesll(args)
    override this.WithArguments(args : Arguments<Symbol>) = new ContribHawkesll(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <summary>Computes the log likelihood of a univariate Hawkes process.
    /// 
    /// The log likelihood is calculated on point process observations represented
    /// as *ragged* matrices for *lags* (interarrival times w.r.t. the previous point),
    /// and *marks* (identifiers for the process ID). Note that each mark is considered independent,
    /// i.e., computes the joint likelihood of a set of Hawkes processes determined by the conditional intensity:
    /// 
    /// .. math::
    /// 
    ///   \lambda_k^*(t) = \lambda_k + \alpha_k \sum_{\{t_i &lt; t, y_i = k\}} \beta_k \exp(-\beta_k (t - t_i))
    /// 
    /// where :math:`\lambda_k` specifies the background intensity ``lda``, :math:`\alpha_k` specifies the *branching ratio* or ``alpha``, and :math:`\beta_k` the delay density parameter ``beta``.
    /// 
    /// ``lags`` and ``marks`` are two NDArrays of shape (N, T) and correspond to the representation of the point process observation, the first dimension corresponds to the batch index, and the second to the sequence. These are &quot;left-aligned&quot; *ragged* matrices (the first index of the second dimension is the beginning of every sequence. The length of each sequence is given by ``valid_length``, of shape (N,) where ``valid_length[i]`` corresponds to the number of valid points in ``lags[i, :]`` and ``marks[i, :]``.
    /// 
    /// ``max_time`` is the length of the observation period of the point process. That is, specifying ``max_time[i] = 5`` computes the likelihood of the i-th sample as observed on the time interval :math:`(0, 5]`. Naturally, the sum of all valid ``lags[i, :valid_length[i]]`` must be less than or equal to 5.
    /// 
    /// The input ``state`` specifies the *memory* of the Hawkes process. Invoking the memoryless property of exponential decays, we compute the *memory* as
    /// 
    /// .. math::
    /// 
    ///     s_k(t) = \sum_{t_i &lt; t} \exp(-\beta_k (t - t_i)).
    /// 
    /// The ``state`` to be provided is :math:`s_k(0)` and carries the added intensity due to past events before the current batch. :math:`s_k(T)` is returned from the function where :math:`T` is ``max_time[T]``.
    /// 
    /// Example::
    /// 
    ///   # define the Hawkes process parameters
    ///   lda = nd.array([1.5, 2.0, 3.0]).tile((N, 1))
    ///   alpha = nd.array([0.2, 0.3, 0.4])  # branching ratios should be &lt; 1
    ///   beta = nd.array([1.0, 2.0, 3.0])
    /// 
    ///   # the &quot;data&quot;, or observations
    ///   ia_times = nd.array([[6, 7, 8, 9], [1, 2, 3, 4], [3, 4, 5, 6], [8, 9, 10, 11]])
    ///   marks = nd.zeros((N, T)).astype(np.int32)
    /// 
    ///   # starting &quot;state&quot; of the process
    ///   states = nd.zeros((N, K))
    /// 
    ///   valid_length = nd.array([1, 2, 3, 4])  # number of valid points in each sequence
    ///   max_time = nd.ones((N,)) * 100.0  # length of the observation period
    /// 
    ///   A = nd.contrib.hawkesll(
    ///       lda, alpha, beta, states, ia_times, marks, valid_length, max_time
    ///   )
    /// 
    /// References:
    /// 
    /// -  Bacry, E., Mastromatteo, I., &amp; Muzy, J. F. (2015).
    ///    Hawkes processes in finance. Market Microstructure and Liquidity
    ///    , 1(01), 1550005.
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\contrib\hawkes_ll.cc:L84</summary>
    /// <param name="lda">Shape (N, K) The intensity for each of the K processes, for each sample</param>
    /// <param name="alpha">Shape (K,) The infectivity factor (branching ratio) for each process</param>
    /// <param name="beta">Shape (K,) The decay parameter for each process</param>
    /// <param name="state">Shape (N, K) the Hawkes state for each process</param>
    /// <param name="lags">Shape (N, T) the interarrival times</param>
    /// <param name="marks">Shape (N, T) the marks (process ids)</param>
    /// <param name="validLength">The number of valid points in the process</param>
    /// <param name="maxTime">the length of the interval where the processes were sampled</param>
    new([<Optional>] ?lda : Symbol,
        [<Optional>] ?alpha : Symbol,
        [<Optional>] ?beta : Symbol,
        [<Optional>] ?state : Symbol,
        [<Optional>] ?lags : Symbol,
        [<Optional>] ?marks : Symbol,
        [<Optional>] ?validLength : Symbol,
        [<Optional>] ?maxTime : Symbol) = 
        let lda = defaultArg lda (new ImplicitVariable() :> Symbol)
        let alpha = defaultArg alpha (new ImplicitVariable() :> Symbol)
        let beta = defaultArg beta (new ImplicitVariable() :> Symbol)
        let state = defaultArg state (new ImplicitVariable() :> Symbol)
        let lags = defaultArg lags (new ImplicitVariable() :> Symbol)
        let marks = defaultArg marks (new ImplicitVariable() :> Symbol)
        let validLength = defaultArg validLength (new ImplicitVariable() :> Symbol)
        let maxTime = defaultArg maxTime (new ImplicitVariable() :> Symbol)
        let operatorArguments = 
            [
                "lda", Input lda
                "alpha", Input alpha
                "beta", Input beta
                "state", Input state
                "lags", Input lags
                "marks", Input marks
                "valid_length", Input validLength
                "max_time", Input maxTime
            ]
        new ContribHawkesll(Arguments<Symbol>(operatorArguments))
    /// Shape (N, K) The intensity for each of the K processes, for each sample
    member __.Lda = operatorArguments.GetInput "lda"
    /// Shape (K,) The infectivity factor (branching ratio) for each process
    member __.Alpha = operatorArguments.GetInput "alpha"
    /// Shape (K,) The decay parameter for each process
    member __.Beta = operatorArguments.GetInput "beta"
    /// Shape (N, K) the Hawkes state for each process
    member __.State = operatorArguments.GetInput "state"
    /// Shape (N, T) the interarrival times
    member __.Lags = operatorArguments.GetInput "lags"
    /// Shape (N, T) the marks (process ids)
    member __.Marks = operatorArguments.GetInput "marks"
    /// The number of valid points in the process
    member __.ValidLength = operatorArguments.GetInput "valid_length"
    /// the length of the interval where the processes were sampled
    member __.MaxTime = operatorArguments.GetInput "max_time"
    /// <summary>Copy ContribHawkesll instance with updated inputs/parameters.</summary>
    /// <param name="lda">Shape (N, K) The intensity for each of the K processes, for each sample</param>
    /// <param name="alpha">Shape (K,) The infectivity factor (branching ratio) for each process</param>
    /// <param name="beta">Shape (K,) The decay parameter for each process</param>
    /// <param name="state">Shape (N, K) the Hawkes state for each process</param>
    /// <param name="lags">Shape (N, T) the interarrival times</param>
    /// <param name="marks">Shape (N, T) the marks (process ids)</param>
    /// <param name="validLength">The number of valid points in the process</param>
    /// <param name="maxTime">the length of the interval where the processes were sampled</param>
    member this.With([<Optional>] ?lda : Symbol,
        [<Optional>] ?alpha : Symbol,
        [<Optional>] ?beta : Symbol,
        [<Optional>] ?state : Symbol,
        [<Optional>] ?lags : Symbol,
        [<Optional>] ?marks : Symbol,
        [<Optional>] ?validLength : Symbol,
        [<Optional>] ?maxTime : Symbol) = 
        let operatorArguments = 
            [
                lda |> Option.map (fun x -> "lda", Input x)
                alpha |> Option.map (fun x -> "alpha", Input x)
                beta |> Option.map (fun x -> "beta", Input x)
                state |> Option.map (fun x -> "state", Input x)
                lags |> Option.map (fun x -> "lags", Input x)
                marks |> Option.map (fun x -> "marks", Input x)
                validLength |> Option.map (fun x -> "valid_length", Input x)
                maxTime |> Option.map (fun x -> "max_time", Input x)
            ] |> List.choose id
        new ContribHawkesll(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type ContribBackwardHawkesll private (operatorArguments) = 
    inherit SymbolOperator("_contrib_backward_hawkesll", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new ContribBackwardHawkesll(args)
    override this.WithArguments(args : Arguments<Symbol>) = new ContribBackwardHawkesll(this.OperatorArguments.AddReplace(args)) :> Symbol
    new() =
        let operatorArguments = 
            [
            ]
        new ContribBackwardHawkesll(Arguments<Symbol>(operatorArguments))

type ContribIndexArray private (operatorArguments) = 
    inherit SymbolOperator("_contrib_index_array", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new ContribIndexArray(args)
    override this.WithArguments(args : Arguments<Symbol>) = new ContribIndexArray(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <summary>Returns an array of indexes of the input array.
    /// 
    /// For an input array with shape  :math:`(d_1, d_2, ..., d_n)`, `index_array` returns a
    /// :math:`(d_1, d_2, ..., d_n, n)` array `idx`, where
    /// :math:`idx[i_1, i_2, ..., i_n, :] = [i_1, i_2, ..., i_n]`.
    /// 
    /// Additionally, when the parameter `axes` is specified, `idx` will be a
    /// :math:`(d_1, d_2, ..., d_n, m)` array where `m` is the length of `axes`, and the following
    /// equality will hold: :math:`idx[i_1, i_2, ..., i_n, j] = i_{axes[j]}`.
    /// 
    /// Examples::
    /// 
    ///     x = mx.nd.ones((3, 2))
    /// 
    ///     mx.nd.contrib.index_array(x) = [[[0 0]
    ///                                      [0 1]]
    /// 
    ///                                     [[1 0]
    ///                                      [1 1]]
    /// 
    ///                                     [[2 0]
    ///                                      [2 1]]]
    /// 
    ///     x = mx.nd.ones((3, 2, 2))
    /// 
    ///     mx.nd.contrib.index_array(x, axes=(1, 0)) = [[[[0 0]
    ///                                                    [0 0]]
    /// 
    ///                                                   [[1 0]
    ///                                                    [1 0]]]
    /// 
    /// 
    ///                                                  [[[0 1]
    ///                                                    [0 1]]
    /// 
    ///                                                   [[1 1]
    ///                                                    [1 1]]]
    /// 
    /// 
    ///                                                  [[[0 2]
    ///                                                    [0 2]]
    /// 
    ///                                                   [[1 2]
    ///                                                    [1 2]]]]
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\contrib\index_array.cc:L118</summary>
    /// <param name="data">Input data</param>
    /// <param name="axes">The axes to include in the index array. Supports negative values.</param>
    new([<Optional>] ?data : Symbol,
        [<Optional>] ?axes : int seq) = 
        let data = defaultArg data (new ImplicitVariable() :> Symbol)
        let operatorArguments = 
            [
                "data", Input data
                "axes", axes |> Option.map box |> Parameter
            ]
        new ContribIndexArray(Arguments<Symbol>(operatorArguments))
    /// Default value for Axes
    /// The axes to include in the index array. Supports negative values.
    static member AxesDefault : int [] option = None
    /// Input data
    member __.Data = operatorArguments.GetInput "data"
    /// The axes to include in the index array. Supports negative values.
    member __.Axes = operatorArguments.GetParameter("axes", ContribIndexArray.AxesDefault)
    /// <summary>Copy ContribIndexArray instance with updated inputs/parameters.</summary>
    /// <param name="data">Input data</param>
    /// <param name="axes">The axes to include in the index array. Supports negative values.</param>
    member this.With([<Optional>] ?data : Symbol,
        [<Optional>] ?axes : int seq) = 
        let operatorArguments = 
            [
                data |> Option.map (fun x -> "data", Input x)
                axes |> Option.map (fun x -> "axes", Parameter(Some (box x)))
            ] |> List.choose id
        new ContribIndexArray(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type ContribIndexCopy private (operatorArguments) = 
    inherit SymbolOperator("_contrib_index_copy", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new ContribIndexCopy(args)
    override this.WithArguments(args : Arguments<Symbol>) = new ContribIndexCopy(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <summary>Copies the elements of a `new_tensor` into the `old_tensor`.
    /// 
    /// This operator copies the elements by selecting the indices in the order given in `index`.
    /// The output will be a new tensor containing the rest elements of old tensor and
    /// the copied elements of new tensor.
    /// For example, if `index[i] == j`, then the `i` th row of `new_tensor` is copied to the
    /// `j` th row of output.
    /// 
    /// The `index` must be a vector and it must have the same size with the `0` th dimension of
    /// `new_tensor`. Also, the `0` th dimension of old_tensor must `&gt;=` the `0` th dimension of
    /// `new_tensor`, or an error will be raised.
    /// 
    /// Examples::
    /// 
    ///     x = mx.nd.zeros((5,3))
    ///     t = mx.nd.array([[1,2,3],[4,5,6],[7,8,9]])
    ///     index = mx.nd.array([0,4,2])
    /// 
    ///     mx.nd.contrib.index_copy(x, index, t)
    /// 
    ///     [[1. 2. 3.]
    ///      [0. 0. 0.]
    ///      [7. 8. 9.]
    ///      [0. 0. 0.]
    ///      [4. 5. 6.]]
    ///     &lt;NDArray 5x3 @cpu(0)&gt;
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\contrib\index_copy.cc:L183</summary>
    /// <param name="oldTensor">Old tensor</param>
    /// <param name="indexVector">Index vector</param>
    /// <param name="newTensor">New tensor to be copied</param>
    new([<Optional>] ?oldTensor : Symbol,
        [<Optional>] ?indexVector : Symbol,
        [<Optional>] ?newTensor : Symbol) = 
        let oldTensor = defaultArg oldTensor (new ImplicitVariable() :> Symbol)
        let indexVector = defaultArg indexVector (new ImplicitVariable() :> Symbol)
        let newTensor = defaultArg newTensor (new ImplicitVariable() :> Symbol)
        let operatorArguments = 
            [
                "old_tensor", Input oldTensor
                "index_vector", Input indexVector
                "new_tensor", Input newTensor
            ]
        new ContribIndexCopy(Arguments<Symbol>(operatorArguments))
    /// Old tensor
    member __.OldTensor = operatorArguments.GetInput "old_tensor"
    /// Index vector
    member __.IndexVector = operatorArguments.GetInput "index_vector"
    /// New tensor to be copied
    member __.NewTensor = operatorArguments.GetInput "new_tensor"
    /// <summary>Copy ContribIndexCopy instance with updated inputs/parameters.</summary>
    /// <param name="oldTensor">Old tensor</param>
    /// <param name="indexVector">Index vector</param>
    /// <param name="newTensor">New tensor to be copied</param>
    member this.With([<Optional>] ?oldTensor : Symbol,
        [<Optional>] ?indexVector : Symbol,
        [<Optional>] ?newTensor : Symbol) = 
        let operatorArguments = 
            [
                oldTensor |> Option.map (fun x -> "old_tensor", Input x)
                indexVector |> Option.map (fun x -> "index_vector", Input x)
                newTensor |> Option.map (fun x -> "new_tensor", Input x)
            ] |> List.choose id
        new ContribIndexCopy(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type ContribBackwardIndexCopy private (operatorArguments) = 
    inherit SymbolOperator("_contrib_backward_index_copy", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new ContribBackwardIndexCopy(args)
    override this.WithArguments(args : Arguments<Symbol>) = new ContribBackwardIndexCopy(this.OperatorArguments.AddReplace(args)) :> Symbol
    new() =
        let operatorArguments = 
            [
            ]
        new ContribBackwardIndexCopy(Arguments<Symbol>(operatorArguments))

type KhatriRao private (operatorArguments) = 
    inherit SymbolOperator("khatri_rao", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new KhatriRao(args)
    override this.WithArguments(args : Arguments<Symbol>) = new KhatriRao(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <summary>Computes the Khatri-Rao product of the input matrices.
    /// 
    /// Given a collection of :math:`n` input matrices,
    /// 
    /// .. math::
    ///    A_1 \in \mathbb{R}^{M_1 \times M}, \ldots, A_n \in \mathbb{R}^{M_n \times N},
    /// 
    /// the (column-wise) Khatri-Rao product is defined as the matrix,
    /// 
    /// .. math::
    ///    X = A_1 \otimes \cdots \otimes A_n \in \mathbb{R}^{(M_1 \cdots M_n) \times N},
    /// 
    /// where the :math:`k` th column is equal to the column-wise outer product
    /// :math:`{A_1}_k \otimes \cdots \otimes {A_n}_k` where :math:`{A_i}_k` is the kth
    /// column of the ith matrix.
    /// 
    /// Example::
    /// 
    ///   &gt;&gt;&gt; A = mx.nd.array([[1, -1],
    ///   &gt;&gt;&gt;                  [2, -3]])
    ///   &gt;&gt;&gt; B = mx.nd.array([[1, 4],
    ///   &gt;&gt;&gt;                  [2, 5],
    ///   &gt;&gt;&gt;                  [3, 6]])
    ///   &gt;&gt;&gt; C = mx.nd.khatri_rao(A, B)
    ///   &gt;&gt;&gt; print(C.asnumpy())
    ///   [[  1.  -4.]
    ///    [  2.  -5.]
    ///    [  3.  -6.]
    ///    [  2. -12.]
    ///    [  4. -15.]
    ///    [  6. -18.]]
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\contrib\krprod.cc:L108</summary>
    /// <param name="args">Positional input matrices</param>
    new([<ParamArray>] args : Symbol[]) =
        let operatorArguments = 
            [
                "args", VarArg("num_args", args)
            ]
        new KhatriRao(Arguments<Symbol>(operatorArguments))
    /// Positional input matrices
    member __.Args = operatorArguments.GetVarArg "args"
    /// <summary>Copy KhatriRao instance with updated inputs/parameters.</summary>
    /// <param name="args">Positional input matrices</param>
    member this.With([<Optional>] ?args : Symbol seq) =
        let operatorArguments = 
            [
                args |> Option.map (fun x -> "args", VarArg("num_args", Seq.toArray x))
            ] |> List.choose id
        new KhatriRao(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type MultiLars private (operatorArguments) = 
    inherit SymbolOperator("multi_lars", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new MultiLars(args)
    override this.WithArguments(args : Arguments<Symbol>) = new MultiLars(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <summary>Compute the LARS coefficients of multiple weights and grads from their sums of square&quot;
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\contrib\multi_lars.cc:L37</summary>
    /// <param name="lrs">Learning rates to scale by LARS coefficient</param>
    /// <param name="weightsSumSq">sum of square of weights arrays</param>
    /// <param name="gradsSumSq">sum of square of gradients arrays</param>
    /// <param name="wds">weight decays</param>
    /// <param name="eta">LARS eta</param>
    /// <param name="eps">LARS eps</param>
    /// <param name="rescaleGrad">Gradient rescaling factor</param>
    new(lrs : Symbol,
        weightsSumSq : Symbol,
        gradsSumSq : Symbol,
        wds : Symbol,
        eta : float,
        eps : float,
        [<Optional>] ?rescaleGrad : float) = 
        let operatorArguments = 
            [
                "lrs", Input lrs
                "weights_sum_sq", Input weightsSumSq
                "grads_sum_sq", Input gradsSumSq
                "wds", Input wds
                "eta", Parameter(Some(box eta))
                "eps", Parameter(Some(box eps))
                "rescale_grad", rescaleGrad |> Option.map box |> Parameter
            ]
        new MultiLars(Arguments<Symbol>(operatorArguments))
    /// <summary>Compute the LARS coefficients of multiple weights and grads from their sums of square&quot;
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\contrib\multi_lars.cc:L37</summary>
    /// <param name="eta">LARS eta</param>
    /// <param name="eps">LARS eps</param>
    /// <param name="lrs">Learning rates to scale by LARS coefficient</param>
    /// <param name="weightsSumSq">sum of square of weights arrays</param>
    /// <param name="gradsSumSq">sum of square of gradients arrays</param>
    /// <param name="wds">weight decays</param>
    /// <param name="rescaleGrad">Gradient rescaling factor</param>
    new(eta : float,
        eps : float,
        [<Optional>] ?lrs : Symbol,
        [<Optional>] ?weightsSumSq : Symbol,
        [<Optional>] ?gradsSumSq : Symbol,
        [<Optional>] ?wds : Symbol,
        [<Optional>] ?rescaleGrad : float) = 
        let lrs = defaultArg lrs (new ImplicitVariable() :> Symbol)
        let weightsSumSq = defaultArg weightsSumSq (new ImplicitVariable() :> Symbol)
        let gradsSumSq = defaultArg gradsSumSq (new ImplicitVariable() :> Symbol)
        let wds = defaultArg wds (new ImplicitVariable() :> Symbol)
        let operatorArguments = 
            [
                "lrs", Input lrs
                "weights_sum_sq", Input weightsSumSq
                "grads_sum_sq", Input gradsSumSq
                "wds", Input wds
                "eta", Parameter(Some(box eta))
                "eps", Parameter(Some(box eps))
                "rescale_grad", rescaleGrad |> Option.map box |> Parameter
            ]
        new MultiLars(Arguments<Symbol>(operatorArguments))
    /// Default value for RescaleGrad
    /// Gradient rescaling factor
    static member RescaleGradDefault : double = 1.0
    /// Learning rates to scale by LARS coefficient
    member __.Lrs = operatorArguments.GetInput "lrs"
    /// sum of square of weights arrays
    member __.WeightsSumSq = operatorArguments.GetInput "weights_sum_sq"
    /// sum of square of gradients arrays
    member __.GradsSumSq = operatorArguments.GetInput "grads_sum_sq"
    /// weight decays
    member __.Wds = operatorArguments.GetInput "wds"
    /// LARS eta
    member __.Eta : float = match operatorArguments.GetParameter "eta" with Some(v) -> unbox v | None -> failwithf "Required parameter eta is missing"
    /// LARS eps
    member __.Eps : float = match operatorArguments.GetParameter "eps" with Some(v) -> unbox v | None -> failwithf "Required parameter eps is missing"
    /// Gradient rescaling factor
    member __.RescaleGrad = operatorArguments.GetParameter("rescale_grad", MultiLars.RescaleGradDefault)
    /// <summary>Copy MultiLars instance with updated inputs/parameters.</summary>
    /// <param name="lrs">Learning rates to scale by LARS coefficient</param>
    /// <param name="weightsSumSq">sum of square of weights arrays</param>
    /// <param name="gradsSumSq">sum of square of gradients arrays</param>
    /// <param name="wds">weight decays</param>
    /// <param name="eta">LARS eta</param>
    /// <param name="eps">LARS eps</param>
    /// <param name="rescaleGrad">Gradient rescaling factor</param>
    member this.With([<Optional>] ?lrs : Symbol,
        [<Optional>] ?weightsSumSq : Symbol,
        [<Optional>] ?gradsSumSq : Symbol,
        [<Optional>] ?wds : Symbol,
        [<Optional>] ?eta : float,
        [<Optional>] ?eps : float,
        [<Optional>] ?rescaleGrad : float) = 
        let operatorArguments = 
            [
                lrs |> Option.map (fun x -> "lrs", Input x)
                weightsSumSq |> Option.map (fun x -> "weights_sum_sq", Input x)
                gradsSumSq |> Option.map (fun x -> "grads_sum_sq", Input x)
                wds |> Option.map (fun x -> "wds", Input x)
                eta |> Option.map (fun x -> "eta", Parameter(Some (box x)))
                eps |> Option.map (fun x -> "eps", Parameter(Some (box x)))
                rescaleGrad |> Option.map (fun x -> "rescale_grad", Parameter(Some (box x)))
            ] |> List.choose id
        new MultiLars(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type MultiSumSq private (operatorArguments) = 
    inherit SymbolOperator("multi_sum_sq", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new MultiSumSq(args)
    override this.WithArguments(args : Arguments<Symbol>) = new MultiSumSq(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <summary>Compute the sums of squares of multiple arrays
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\contrib\multi_sum_sq.cc:L36</summary>
    /// <param name="data">Arrays</param>
    /// <param name="numArrays">number of input arrays.</param>
    new(data : Symbol seq,
        numArrays : int) = 
        let operatorArguments = 
            [
                "data", VarArg("", data |> Seq.toArray)
                "num_arrays", Parameter(Some(box numArrays))
            ]
        new MultiSumSq(Arguments<Symbol>(operatorArguments))
    /// <summary>Compute the sums of squares of multiple arrays
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\contrib\multi_sum_sq.cc:L36</summary>
    /// <param name="numArrays">number of input arrays.</param>
    /// <param name="data">Arrays</param>
    new(numArrays : int,
        [<Optional>] ?data : Symbol seq) = 
        let data = defaultArg (data |> Option.map Seq.toArray) Array.empty
        let operatorArguments = 
            [
                "data", VarArg("", data)
                "num_arrays", Parameter(Some(box numArrays))
            ]
        new MultiSumSq(Arguments<Symbol>(operatorArguments))
    /// <summary>Compute the sums of squares of multiple arrays
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\contrib\multi_sum_sq.cc:L36</summary>
    /// <param name="numArrays">number of input arrays.</param>
    /// <param name="data">Arrays</param>
    new(numArrays : int,
        [<ParamArray>] data : Symbol[]) = 
        let operatorArguments = 
            [
                "data", VarArg("", data)
                "num_arrays", Parameter(Some(box numArrays))
            ]
        new MultiSumSq(Arguments<Symbol>(operatorArguments))
    /// Arrays
    member __.Data = operatorArguments.GetVarArg "data"
    /// number of input arrays.
    member __.NumArrays : int = match operatorArguments.GetParameter "num_arrays" with Some(v) -> unbox v | None -> failwithf "Required parameter num_arrays is missing"
    /// <summary>Copy MultiSumSq instance with updated inputs/parameters.</summary>
    /// <param name="data">Arrays</param>
    /// <param name="numArrays">number of input arrays.</param>
    member this.With([<Optional>] ?data : Symbol seq,
        [<Optional>] ?numArrays : int) = 
        let operatorArguments = 
            [
                data |> Option.map (fun x -> "data", VarArg("", Seq.toArray x))
                numArrays |> Option.map (fun x -> "num_arrays", Parameter(Some (box x)))
            ] |> List.choose id
        new MultiSumSq(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type ContribMultiBoxDetection private (operatorArguments) = 
    inherit SymbolOperator("_contrib_MultiBoxDetection", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new ContribMultiBoxDetection(args)
    override this.WithArguments(args : Arguments<Symbol>) = new ContribMultiBoxDetection(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <summary>Convert multibox detection predictions.</summary>
    /// <param name="clsProb">Class probabilities.</param>
    /// <param name="locPred">Location regression predictions.</param>
    /// <param name="anchor">Multibox prior anchor boxes</param>
    /// <param name="clip">Clip out-of-boundary boxes.</param>
    /// <param name="threshold">Threshold to be a positive prediction.</param>
    /// <param name="backgroundId">Background id.</param>
    /// <param name="nmsThreshold">Non-maximum suppression threshold.</param>
    /// <param name="forceSuppress">Suppress all detections regardless of class_id.</param>
    /// <param name="variances">Variances to be decoded from box regression output.</param>
    /// <param name="nmsTopk">Keep maximum top k detections before nms, -1 for no limit.</param>
    new([<Optional>] ?clsProb : Symbol,
        [<Optional>] ?locPred : Symbol,
        [<Optional>] ?anchor : Symbol,
        [<Optional>] ?clip : bool,
        [<Optional>] ?threshold : float,
        [<Optional>] ?backgroundId : int,
        [<Optional>] ?nmsThreshold : float,
        [<Optional>] ?forceSuppress : bool,
        [<Optional>] ?variances : double seq,
        [<Optional>] ?nmsTopk : int) = 
        let clsProb = defaultArg clsProb (new ImplicitVariable() :> Symbol)
        let locPred = defaultArg locPred (new ImplicitVariable() :> Symbol)
        let anchor = defaultArg anchor (new ImplicitVariable() :> Symbol)
        let operatorArguments = 
            [
                "cls_prob", Input clsProb
                "loc_pred", Input locPred
                "anchor", Input anchor
                "clip", clip |> Option.map box |> Parameter
                "threshold", threshold |> Option.map box |> Parameter
                "background_id", backgroundId |> Option.map box |> Parameter
                "nms_threshold", nmsThreshold |> Option.map box |> Parameter
                "force_suppress", forceSuppress |> Option.map box |> Parameter
                "variances", variances |> Option.map box |> Parameter
                "nms_topk", nmsTopk |> Option.map box |> Parameter
            ]
        new ContribMultiBoxDetection(Arguments<Symbol>(operatorArguments))
    /// Default value for Clip
    /// Clip out-of-boundary boxes.
    static member ClipDefault : bool = true
    /// Default value for Threshold
    /// Threshold to be a positive prediction.
    static member ThresholdDefault : double = 0.00999999978
    /// Default value for BackgroundId
    /// Background id.
    static member BackgroundIdDefault : int = 0
    /// Default value for NmsThreshold
    /// Non-maximum suppression threshold.
    static member NmsThresholdDefault : double = 0.5
    /// Default value for ForceSuppress
    /// Suppress all detections regardless of class_id.
    static member ForceSuppressDefault : bool = false
    /// Default value for Variances
    /// Variances to be decoded from box regression output.
    static member VariancesDefault : double [] = [|0.1; 0.1; 0.2; 0.2|]
    /// Default value for NmsTopk
    /// Keep maximum top k detections before nms, -1 for no limit.
    static member NmsTopkDefault : int = -1
    /// Class probabilities.
    member __.ClsProb = operatorArguments.GetInput "cls_prob"
    /// Location regression predictions.
    member __.LocPred = operatorArguments.GetInput "loc_pred"
    /// Multibox prior anchor boxes
    member __.Anchor = operatorArguments.GetInput "anchor"
    /// Clip out-of-boundary boxes.
    member __.Clip = operatorArguments.GetParameter("clip", ContribMultiBoxDetection.ClipDefault)
    /// Threshold to be a positive prediction.
    member __.Threshold = operatorArguments.GetParameter("threshold", ContribMultiBoxDetection.ThresholdDefault)
    /// Background id.
    member __.BackgroundId = operatorArguments.GetParameter("background_id", ContribMultiBoxDetection.BackgroundIdDefault)
    /// Non-maximum suppression threshold.
    member __.NmsThreshold = operatorArguments.GetParameter("nms_threshold", ContribMultiBoxDetection.NmsThresholdDefault)
    /// Suppress all detections regardless of class_id.
    member __.ForceSuppress = operatorArguments.GetParameter("force_suppress", ContribMultiBoxDetection.ForceSuppressDefault)
    /// Variances to be decoded from box regression output.
    member __.Variances = operatorArguments.GetParameter("variances", ContribMultiBoxDetection.VariancesDefault)
    /// Keep maximum top k detections before nms, -1 for no limit.
    member __.NmsTopk = operatorArguments.GetParameter("nms_topk", ContribMultiBoxDetection.NmsTopkDefault)
    /// <summary>Copy ContribMultiBoxDetection instance with updated inputs/parameters.</summary>
    /// <param name="clsProb">Class probabilities.</param>
    /// <param name="locPred">Location regression predictions.</param>
    /// <param name="anchor">Multibox prior anchor boxes</param>
    /// <param name="clip">Clip out-of-boundary boxes.</param>
    /// <param name="threshold">Threshold to be a positive prediction.</param>
    /// <param name="backgroundId">Background id.</param>
    /// <param name="nmsThreshold">Non-maximum suppression threshold.</param>
    /// <param name="forceSuppress">Suppress all detections regardless of class_id.</param>
    /// <param name="variances">Variances to be decoded from box regression output.</param>
    /// <param name="nmsTopk">Keep maximum top k detections before nms, -1 for no limit.</param>
    member this.With([<Optional>] ?clsProb : Symbol,
        [<Optional>] ?locPred : Symbol,
        [<Optional>] ?anchor : Symbol,
        [<Optional>] ?clip : bool,
        [<Optional>] ?threshold : float,
        [<Optional>] ?backgroundId : int,
        [<Optional>] ?nmsThreshold : float,
        [<Optional>] ?forceSuppress : bool,
        [<Optional>] ?variances : double seq,
        [<Optional>] ?nmsTopk : int) = 
        let operatorArguments = 
            [
                clsProb |> Option.map (fun x -> "cls_prob", Input x)
                locPred |> Option.map (fun x -> "loc_pred", Input x)
                anchor |> Option.map (fun x -> "anchor", Input x)
                clip |> Option.map (fun x -> "clip", Parameter(Some (box x)))
                threshold |> Option.map (fun x -> "threshold", Parameter(Some (box x)))
                backgroundId |> Option.map (fun x -> "background_id", Parameter(Some (box x)))
                nmsThreshold |> Option.map (fun x -> "nms_threshold", Parameter(Some (box x)))
                forceSuppress |> Option.map (fun x -> "force_suppress", Parameter(Some (box x)))
                variances |> Option.map (fun x -> "variances", Parameter(Some (box x)))
                nmsTopk |> Option.map (fun x -> "nms_topk", Parameter(Some (box x)))
            ] |> List.choose id
        new ContribMultiBoxDetection(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type ContribMultiBoxPrior private (operatorArguments) = 
    inherit SymbolOperator("_contrib_MultiBoxPrior", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new ContribMultiBoxPrior(args)
    override this.WithArguments(args : Arguments<Symbol>) = new ContribMultiBoxPrior(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <summary>Generate prior(anchor) boxes from data, sizes and ratios.</summary>
    /// <param name="data">Input data.</param>
    /// <param name="sizes">List of sizes of generated MultiBoxPriores.</param>
    /// <param name="ratios">List of aspect ratios of generated MultiBoxPriores.</param>
    /// <param name="clip">Whether to clip out-of-boundary boxes.</param>
    /// <param name="steps">Priorbox step across y and x, -1 for auto calculation.</param>
    /// <param name="offsets">Priorbox center offsets, y and x respectively</param>
    new([<Optional>] ?data : Symbol,
        [<Optional>] ?sizes : double seq,
        [<Optional>] ?ratios : double seq,
        [<Optional>] ?clip : bool,
        [<Optional>] ?steps : double seq,
        [<Optional>] ?offsets : double seq) = 
        let data = defaultArg data (new ImplicitVariable() :> Symbol)
        let operatorArguments = 
            [
                "data", Input data
                "sizes", sizes |> Option.map box |> Parameter
                "ratios", ratios |> Option.map box |> Parameter
                "clip", clip |> Option.map box |> Parameter
                "steps", steps |> Option.map box |> Parameter
                "offsets", offsets |> Option.map box |> Parameter
            ]
        new ContribMultiBoxPrior(Arguments<Symbol>(operatorArguments))
    /// Default value for Sizes
    /// List of sizes of generated MultiBoxPriores.
    static member SizesDefault : double [] = [|1.0|]
    /// Default value for Ratios
    /// List of aspect ratios of generated MultiBoxPriores.
    static member RatiosDefault : double [] = [|1.0|]
    /// Default value for Clip
    /// Whether to clip out-of-boundary boxes.
    static member ClipDefault : bool = false
    /// Default value for Steps
    /// Priorbox step across y and x, -1 for auto calculation.
    static member StepsDefault : double [] = [|-1.0; -1.0|]
    /// Default value for Offsets
    /// Priorbox center offsets, y and x respectively
    static member OffsetsDefault : double [] = [|0.5; 0.5|]
    /// Input data.
    member __.Data = operatorArguments.GetInput "data"
    /// List of sizes of generated MultiBoxPriores.
    member __.Sizes = operatorArguments.GetParameter("sizes", ContribMultiBoxPrior.SizesDefault)
    /// List of aspect ratios of generated MultiBoxPriores.
    member __.Ratios = operatorArguments.GetParameter("ratios", ContribMultiBoxPrior.RatiosDefault)
    /// Whether to clip out-of-boundary boxes.
    member __.Clip = operatorArguments.GetParameter("clip", ContribMultiBoxPrior.ClipDefault)
    /// Priorbox step across y and x, -1 for auto calculation.
    member __.Steps = operatorArguments.GetParameter("steps", ContribMultiBoxPrior.StepsDefault)
    /// Priorbox center offsets, y and x respectively
    member __.Offsets = operatorArguments.GetParameter("offsets", ContribMultiBoxPrior.OffsetsDefault)
    /// <summary>Copy ContribMultiBoxPrior instance with updated inputs/parameters.</summary>
    /// <param name="data">Input data.</param>
    /// <param name="sizes">List of sizes of generated MultiBoxPriores.</param>
    /// <param name="ratios">List of aspect ratios of generated MultiBoxPriores.</param>
    /// <param name="clip">Whether to clip out-of-boundary boxes.</param>
    /// <param name="steps">Priorbox step across y and x, -1 for auto calculation.</param>
    /// <param name="offsets">Priorbox center offsets, y and x respectively</param>
    member this.With([<Optional>] ?data : Symbol,
        [<Optional>] ?sizes : double seq,
        [<Optional>] ?ratios : double seq,
        [<Optional>] ?clip : bool,
        [<Optional>] ?steps : double seq,
        [<Optional>] ?offsets : double seq) = 
        let operatorArguments = 
            [
                data |> Option.map (fun x -> "data", Input x)
                sizes |> Option.map (fun x -> "sizes", Parameter(Some (box x)))
                ratios |> Option.map (fun x -> "ratios", Parameter(Some (box x)))
                clip |> Option.map (fun x -> "clip", Parameter(Some (box x)))
                steps |> Option.map (fun x -> "steps", Parameter(Some (box x)))
                offsets |> Option.map (fun x -> "offsets", Parameter(Some (box x)))
            ] |> List.choose id
        new ContribMultiBoxPrior(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type ContribMultiBoxTarget private (operatorArguments) = 
    inherit SymbolOperator("_contrib_MultiBoxTarget", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new ContribMultiBoxTarget(args)
    override this.WithArguments(args : Arguments<Symbol>) = new ContribMultiBoxTarget(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <summary>Compute Multibox training targets</summary>
    /// <param name="anchor">Generated anchor boxes.</param>
    /// <param name="label">Object detection labels.</param>
    /// <param name="clsPred">Class predictions.</param>
    /// <param name="overlapThreshold">Anchor-GT overlap threshold to be regarded as a positive match.</param>
    /// <param name="ignoreLabel">Label for ignored anchors.</param>
    /// <param name="negativeMiningRatio">Max negative to positive samples ratio, use -1 to disable mining</param>
    /// <param name="negativeMiningThresh">Threshold used for negative mining.</param>
    /// <param name="minimumNegativeSamples">Minimum number of negative samples.</param>
    /// <param name="variances">Variances to be encoded in box regression target.</param>
    new([<Optional>] ?anchor : Symbol,
        [<Optional>] ?label : Symbol,
        [<Optional>] ?clsPred : Symbol,
        [<Optional>] ?overlapThreshold : float,
        [<Optional>] ?ignoreLabel : float,
        [<Optional>] ?negativeMiningRatio : float,
        [<Optional>] ?negativeMiningThresh : float,
        [<Optional>] ?minimumNegativeSamples : int,
        [<Optional>] ?variances : double seq) = 
        let anchor = defaultArg anchor (new ImplicitVariable() :> Symbol)
        let label = defaultArg label (new ImplicitVariable() :> Symbol)
        let clsPred = defaultArg clsPred (new ImplicitVariable() :> Symbol)
        let operatorArguments = 
            [
                "anchor", Input anchor
                "label", Input label
                "cls_pred", Input clsPred
                "overlap_threshold", overlapThreshold |> Option.map box |> Parameter
                "ignore_label", ignoreLabel |> Option.map box |> Parameter
                "negative_mining_ratio", negativeMiningRatio |> Option.map box |> Parameter
                "negative_mining_thresh", negativeMiningThresh |> Option.map box |> Parameter
                "minimum_negative_samples", minimumNegativeSamples |> Option.map box |> Parameter
                "variances", variances |> Option.map box |> Parameter
            ]
        new ContribMultiBoxTarget(Arguments<Symbol>(operatorArguments))
    /// Default value for OverlapThreshold
    /// Anchor-GT overlap threshold to be regarded as a positive match.
    static member OverlapThresholdDefault : double = 0.5
    /// Default value for IgnoreLabel
    /// Label for ignored anchors.
    static member IgnoreLabelDefault : double = -1.0
    /// Default value for NegativeMiningRatio
    /// Max negative to positive samples ratio, use -1 to disable mining
    static member NegativeMiningRatioDefault : double = -1.0
    /// Default value for NegativeMiningThresh
    /// Threshold used for negative mining.
    static member NegativeMiningThreshDefault : double = 0.5
    /// Default value for MinimumNegativeSamples
    /// Minimum number of negative samples.
    static member MinimumNegativeSamplesDefault : int = 0
    /// Default value for Variances
    /// Variances to be encoded in box regression target.
    static member VariancesDefault : double [] = [|0.1; 0.1; 0.2; 0.2|]
    /// Generated anchor boxes.
    member __.Anchor = operatorArguments.GetInput "anchor"
    /// Object detection labels.
    member __.Label = operatorArguments.GetInput "label"
    /// Class predictions.
    member __.ClsPred = operatorArguments.GetInput "cls_pred"
    /// Anchor-GT overlap threshold to be regarded as a positive match.
    member __.OverlapThreshold = operatorArguments.GetParameter("overlap_threshold", ContribMultiBoxTarget.OverlapThresholdDefault)
    /// Label for ignored anchors.
    member __.IgnoreLabel = operatorArguments.GetParameter("ignore_label", ContribMultiBoxTarget.IgnoreLabelDefault)
    /// Max negative to positive samples ratio, use -1 to disable mining
    member __.NegativeMiningRatio = operatorArguments.GetParameter("negative_mining_ratio", ContribMultiBoxTarget.NegativeMiningRatioDefault)
    /// Threshold used for negative mining.
    member __.NegativeMiningThresh = operatorArguments.GetParameter("negative_mining_thresh", ContribMultiBoxTarget.NegativeMiningThreshDefault)
    /// Minimum number of negative samples.
    member __.MinimumNegativeSamples = operatorArguments.GetParameter("minimum_negative_samples", ContribMultiBoxTarget.MinimumNegativeSamplesDefault)
    /// Variances to be encoded in box regression target.
    member __.Variances = operatorArguments.GetParameter("variances", ContribMultiBoxTarget.VariancesDefault)
    /// <summary>Copy ContribMultiBoxTarget instance with updated inputs/parameters.</summary>
    /// <param name="anchor">Generated anchor boxes.</param>
    /// <param name="label">Object detection labels.</param>
    /// <param name="clsPred">Class predictions.</param>
    /// <param name="overlapThreshold">Anchor-GT overlap threshold to be regarded as a positive match.</param>
    /// <param name="ignoreLabel">Label for ignored anchors.</param>
    /// <param name="negativeMiningRatio">Max negative to positive samples ratio, use -1 to disable mining</param>
    /// <param name="negativeMiningThresh">Threshold used for negative mining.</param>
    /// <param name="minimumNegativeSamples">Minimum number of negative samples.</param>
    /// <param name="variances">Variances to be encoded in box regression target.</param>
    member this.With([<Optional>] ?anchor : Symbol,
        [<Optional>] ?label : Symbol,
        [<Optional>] ?clsPred : Symbol,
        [<Optional>] ?overlapThreshold : float,
        [<Optional>] ?ignoreLabel : float,
        [<Optional>] ?negativeMiningRatio : float,
        [<Optional>] ?negativeMiningThresh : float,
        [<Optional>] ?minimumNegativeSamples : int,
        [<Optional>] ?variances : double seq) = 
        let operatorArguments = 
            [
                anchor |> Option.map (fun x -> "anchor", Input x)
                label |> Option.map (fun x -> "label", Input x)
                clsPred |> Option.map (fun x -> "cls_pred", Input x)
                overlapThreshold |> Option.map (fun x -> "overlap_threshold", Parameter(Some (box x)))
                ignoreLabel |> Option.map (fun x -> "ignore_label", Parameter(Some (box x)))
                negativeMiningRatio |> Option.map (fun x -> "negative_mining_ratio", Parameter(Some (box x)))
                negativeMiningThresh |> Option.map (fun x -> "negative_mining_thresh", Parameter(Some (box x)))
                minimumNegativeSamples |> Option.map (fun x -> "minimum_negative_samples", Parameter(Some (box x)))
                variances |> Option.map (fun x -> "variances", Parameter(Some (box x)))
            ] |> List.choose id
        new ContribMultiBoxTarget(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type ContribGetnnz private (operatorArguments) = 
    inherit SymbolOperator("_contrib_getnnz", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new ContribGetnnz(args)
    override this.WithArguments(args : Arguments<Symbol>) = new ContribGetnnz(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <summary>Number of stored values for a sparse tensor, including explicit zeros.
    /// 
    /// This operator only supports CSR matrix on CPU.
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\contrib\nnz.cc:L177</summary>
    /// <param name="data">Input</param>
    /// <param name="axis">Select between the number of values across the whole matrix, in each column, or in each row.</param>
    new([<Optional>] ?data : Symbol,
        [<Optional>] ?axis : int) = 
        let data = defaultArg data (new ImplicitVariable() :> Symbol)
        let operatorArguments = 
            [
                "data", Input data
                "axis", axis |> Option.map box |> Parameter
            ]
        new ContribGetnnz(Arguments<Symbol>(operatorArguments))
    /// Default value for Axis
    /// Select between the number of values across the whole matrix, in each column, or in each row.
    static member AxisDefault : int option = None
    /// Input
    member __.Data = operatorArguments.GetInput "data"
    /// Select between the number of values across the whole matrix, in each column, or in each row.
    member __.Axis = operatorArguments.GetParameter("axis", ContribGetnnz.AxisDefault)
    /// <summary>Copy ContribGetnnz instance with updated inputs/parameters.</summary>
    /// <param name="data">Input</param>
    /// <param name="axis">Select between the number of values across the whole matrix, in each column, or in each row.</param>
    member this.With([<Optional>] ?data : Symbol,
        [<Optional>] ?axis : int) = 
        let operatorArguments = 
            [
                data |> Option.map (fun x -> "data", Input x)
                axis |> Option.map (fun x -> "axis", Parameter(Some (box x)))
            ] |> List.choose id
        new ContribGetnnz(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type ContribGroupAdagradUpdate private (operatorArguments) = 
    inherit SymbolOperator("_contrib_group_adagrad_update", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new ContribGroupAdagradUpdate(args)
    override this.WithArguments(args : Arguments<Symbol>) = new ContribGroupAdagradUpdate(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <summary>Update function for Group AdaGrad optimizer.
    /// 
    /// Referenced from *Adaptive Subgradient Methods for Online Learning and Stochastic Optimization*,
    /// and available at http://www.jmlr.org/papers/volume12/duchi11a/duchi11a.pdf but
    /// uses only a single learning rate for every row of the parameter array.
    /// 
    /// Updates are applied by::
    /// 
    ///     grad = clip(grad * rescale_grad, clip_gradient)
    ///     history += mean(square(grad), axis=1, keepdims=True)
    ///     div = grad / sqrt(history + float_stable_eps)
    ///     weight -= div * lr
    /// 
    /// Weights are updated lazily if the gradient is sparse.
    /// 
    /// Note that non-zero values for the weight decay option are not supported.
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\contrib\optimizer_op.cc:L71</summary>
    /// <param name="weight">Weight</param>
    /// <param name="grad">Gradient</param>
    /// <param name="history">History</param>
    /// <param name="lr">Learning rate</param>
    /// <param name="rescaleGrad">Rescale gradient to grad = rescale_grad*grad.</param>
    /// <param name="clipGradient">Clip gradient to the range of [-clip_gradient, clip_gradient] If clip_gradient &lt;= 0, gradient clipping is turned off. grad = max(min(grad, clip_gradient), -clip_gradient).</param>
    /// <param name="epsilon">Epsilon for numerical stability</param>
    new(weight : Symbol,
        grad : Symbol,
        history : Symbol,
        lr : float,
        [<Optional>] ?rescaleGrad : float,
        [<Optional>] ?clipGradient : float,
        [<Optional>] ?epsilon : float) = 
        let operatorArguments = 
            [
                "weight", Input weight
                "grad", Input grad
                "history", Input history
                "lr", Parameter(Some(box lr))
                "rescale_grad", rescaleGrad |> Option.map box |> Parameter
                "clip_gradient", clipGradient |> Option.map box |> Parameter
                "epsilon", epsilon |> Option.map box |> Parameter
            ]
        new ContribGroupAdagradUpdate(Arguments<Symbol>(operatorArguments))
    /// <summary>Update function for Group AdaGrad optimizer.
    /// 
    /// Referenced from *Adaptive Subgradient Methods for Online Learning and Stochastic Optimization*,
    /// and available at http://www.jmlr.org/papers/volume12/duchi11a/duchi11a.pdf but
    /// uses only a single learning rate for every row of the parameter array.
    /// 
    /// Updates are applied by::
    /// 
    ///     grad = clip(grad * rescale_grad, clip_gradient)
    ///     history += mean(square(grad), axis=1, keepdims=True)
    ///     div = grad / sqrt(history + float_stable_eps)
    ///     weight -= div * lr
    /// 
    /// Weights are updated lazily if the gradient is sparse.
    /// 
    /// Note that non-zero values for the weight decay option are not supported.
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\contrib\optimizer_op.cc:L71</summary>
    /// <param name="lr">Learning rate</param>
    /// <param name="weight">Weight</param>
    /// <param name="grad">Gradient</param>
    /// <param name="history">History</param>
    /// <param name="rescaleGrad">Rescale gradient to grad = rescale_grad*grad.</param>
    /// <param name="clipGradient">Clip gradient to the range of [-clip_gradient, clip_gradient] If clip_gradient &lt;= 0, gradient clipping is turned off. grad = max(min(grad, clip_gradient), -clip_gradient).</param>
    /// <param name="epsilon">Epsilon for numerical stability</param>
    new(lr : float,
        [<Optional>] ?weight : Symbol,
        [<Optional>] ?grad : Symbol,
        [<Optional>] ?history : Symbol,
        [<Optional>] ?rescaleGrad : float,
        [<Optional>] ?clipGradient : float,
        [<Optional>] ?epsilon : float) = 
        let weight = defaultArg weight (new ImplicitVariable() :> Symbol)
        let grad = defaultArg grad (new ImplicitVariable() :> Symbol)
        let history = defaultArg history (new ImplicitVariable() :> Symbol)
        let operatorArguments = 
            [
                "weight", Input weight
                "grad", Input grad
                "history", Input history
                "lr", Parameter(Some(box lr))
                "rescale_grad", rescaleGrad |> Option.map box |> Parameter
                "clip_gradient", clipGradient |> Option.map box |> Parameter
                "epsilon", epsilon |> Option.map box |> Parameter
            ]
        new ContribGroupAdagradUpdate(Arguments<Symbol>(operatorArguments))
    /// Default value for RescaleGrad
    /// Rescale gradient to grad = rescale_grad*grad.
    static member RescaleGradDefault : double = 1.0
    /// Default value for ClipGradient
    /// Clip gradient to the range of [-clip_gradient, clip_gradient] If clip_gradient &lt;= 0, gradient clipping is turned off. grad = max(min(grad, clip_gradient), -clip_gradient).
    static member ClipGradientDefault : double = -1.0
    /// Default value for Epsilon
    /// Epsilon for numerical stability
    static member EpsilonDefault : double = 0.00000999999975
    /// Weight
    member __.Weight = operatorArguments.GetInput "weight"
    /// Gradient
    member __.Grad = operatorArguments.GetInput "grad"
    /// History
    member __.History = operatorArguments.GetInput "history"
    /// Learning rate
    member __.Lr : float = match operatorArguments.GetParameter "lr" with Some(v) -> unbox v | None -> failwithf "Required parameter lr is missing"
    /// Rescale gradient to grad = rescale_grad*grad.
    member __.RescaleGrad = operatorArguments.GetParameter("rescale_grad", ContribGroupAdagradUpdate.RescaleGradDefault)
    /// Clip gradient to the range of [-clip_gradient, clip_gradient] If clip_gradient &lt;= 0, gradient clipping is turned off. grad = max(min(grad, clip_gradient), -clip_gradient).
    member __.ClipGradient = operatorArguments.GetParameter("clip_gradient", ContribGroupAdagradUpdate.ClipGradientDefault)
    /// Epsilon for numerical stability
    member __.Epsilon = operatorArguments.GetParameter("epsilon", ContribGroupAdagradUpdate.EpsilonDefault)
    /// <summary>Copy ContribGroupAdagradUpdate instance with updated inputs/parameters.</summary>
    /// <param name="weight">Weight</param>
    /// <param name="grad">Gradient</param>
    /// <param name="history">History</param>
    /// <param name="lr">Learning rate</param>
    /// <param name="rescaleGrad">Rescale gradient to grad = rescale_grad*grad.</param>
    /// <param name="clipGradient">Clip gradient to the range of [-clip_gradient, clip_gradient] If clip_gradient &lt;= 0, gradient clipping is turned off. grad = max(min(grad, clip_gradient), -clip_gradient).</param>
    /// <param name="epsilon">Epsilon for numerical stability</param>
    member this.With([<Optional>] ?weight : Symbol,
        [<Optional>] ?grad : Symbol,
        [<Optional>] ?history : Symbol,
        [<Optional>] ?lr : float,
        [<Optional>] ?rescaleGrad : float,
        [<Optional>] ?clipGradient : float,
        [<Optional>] ?epsilon : float) = 
        let operatorArguments = 
            [
                weight |> Option.map (fun x -> "weight", Input x)
                grad |> Option.map (fun x -> "grad", Input x)
                history |> Option.map (fun x -> "history", Input x)
                lr |> Option.map (fun x -> "lr", Parameter(Some (box x)))
                rescaleGrad |> Option.map (fun x -> "rescale_grad", Parameter(Some (box x)))
                clipGradient |> Option.map (fun x -> "clip_gradient", Parameter(Some (box x)))
                epsilon |> Option.map (fun x -> "epsilon", Parameter(Some (box x)))
            ] |> List.choose id
        new ContribGroupAdagradUpdate(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type PreloadedMultiSgdUpdate private (operatorArguments) = 
    inherit SymbolOperator("preloaded_multi_sgd_update", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new PreloadedMultiSgdUpdate(args)
    override this.WithArguments(args : Arguments<Symbol>) = new PreloadedMultiSgdUpdate(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <summary>Update function for Stochastic Gradient Descent (SDG) optimizer.
    /// 
    /// It updates the weights using::
    /// 
    ///  weight = weight - learning_rate * (gradient + wd * weight)
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\contrib\preloaded_multi_sgd.cc:L42</summary>
    /// <param name="data">Weights, gradients, learning rates and weight decays</param>
    /// <param name="rescaleGrad">Rescale gradient to grad = rescale_grad*grad.</param>
    /// <param name="clipGradient">Clip gradient to the range of [-clip_gradient, clip_gradient] If clip_gradient &lt;= 0, gradient clipping is turned off. grad = max(min(grad, clip_gradient), -clip_gradient).</param>
    /// <param name="numWeights">Number of updated weights.</param>
    new([<Optional>] ?data : Symbol seq,
        [<Optional>] ?rescaleGrad : float,
        [<Optional>] ?clipGradient : float,
        [<Optional>] ?numWeights : int) = 
        let data = defaultArg (data |> Option.map Seq.toArray) Array.empty
        let operatorArguments = 
            [
                "data", VarArg("", data)
                "rescale_grad", rescaleGrad |> Option.map box |> Parameter
                "clip_gradient", clipGradient |> Option.map box |> Parameter
                "num_weights", numWeights |> Option.map box |> Parameter
            ]
        new PreloadedMultiSgdUpdate(Arguments<Symbol>(operatorArguments))
    /// Default value for RescaleGrad
    /// Rescale gradient to grad = rescale_grad*grad.
    static member RescaleGradDefault : double = 1.0
    /// Default value for ClipGradient
    /// Clip gradient to the range of [-clip_gradient, clip_gradient] If clip_gradient &lt;= 0, gradient clipping is turned off. grad = max(min(grad, clip_gradient), -clip_gradient).
    static member ClipGradientDefault : double = -1.0
    /// Default value for NumWeights
    /// Number of updated weights.
    static member NumWeightsDefault : int = 1
    /// Weights, gradients, learning rates and weight decays
    member __.Data = operatorArguments.GetVarArg "data"
    /// Rescale gradient to grad = rescale_grad*grad.
    member __.RescaleGrad = operatorArguments.GetParameter("rescale_grad", PreloadedMultiSgdUpdate.RescaleGradDefault)
    /// Clip gradient to the range of [-clip_gradient, clip_gradient] If clip_gradient &lt;= 0, gradient clipping is turned off. grad = max(min(grad, clip_gradient), -clip_gradient).
    member __.ClipGradient = operatorArguments.GetParameter("clip_gradient", PreloadedMultiSgdUpdate.ClipGradientDefault)
    /// Number of updated weights.
    member __.NumWeights = operatorArguments.GetParameter("num_weights", PreloadedMultiSgdUpdate.NumWeightsDefault)
    /// <summary>Copy PreloadedMultiSgdUpdate instance with updated inputs/parameters.</summary>
    /// <param name="data">Weights, gradients, learning rates and weight decays</param>
    /// <param name="rescaleGrad">Rescale gradient to grad = rescale_grad*grad.</param>
    /// <param name="clipGradient">Clip gradient to the range of [-clip_gradient, clip_gradient] If clip_gradient &lt;= 0, gradient clipping is turned off. grad = max(min(grad, clip_gradient), -clip_gradient).</param>
    /// <param name="numWeights">Number of updated weights.</param>
    member this.With([<Optional>] ?data : Symbol seq,
        [<Optional>] ?rescaleGrad : float,
        [<Optional>] ?clipGradient : float,
        [<Optional>] ?numWeights : int) = 
        let operatorArguments = 
            [
                data |> Option.map (fun x -> "data", VarArg("", Seq.toArray x))
                rescaleGrad |> Option.map (fun x -> "rescale_grad", Parameter(Some (box x)))
                clipGradient |> Option.map (fun x -> "clip_gradient", Parameter(Some (box x)))
                numWeights |> Option.map (fun x -> "num_weights", Parameter(Some (box x)))
            ] |> List.choose id
        new PreloadedMultiSgdUpdate(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type PreloadedMultiSgdMomUpdate private (operatorArguments) = 
    inherit SymbolOperator("preloaded_multi_sgd_mom_update", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new PreloadedMultiSgdMomUpdate(args)
    override this.WithArguments(args : Arguments<Symbol>) = new PreloadedMultiSgdMomUpdate(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <summary>Momentum update function for Stochastic Gradient Descent (SGD) optimizer.
    /// 
    /// Momentum update has better convergence rates on neural networks. Mathematically it looks
    /// like below:
    /// 
    /// .. math::
    /// 
    ///   v_1 = \alpha * \nabla J(W_0)\\
    ///   v_t = \gamma v_{t-1} - \alpha * \nabla J(W_{t-1})\\
    ///   W_t = W_{t-1} + v_t
    /// 
    /// It updates the weights using::
    /// 
    ///   v = momentum * v - learning_rate * gradient
    ///   weight += v
    /// 
    /// Where the parameter ``momentum`` is the decay rate of momentum estimates at each epoch.
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\contrib\preloaded_multi_sgd.cc:L91</summary>
    /// <param name="data">Weights, gradients, momentum, learning rates and weight decays</param>
    /// <param name="momentum">The decay rate of momentum estimates at each epoch.</param>
    /// <param name="rescaleGrad">Rescale gradient to grad = rescale_grad*grad.</param>
    /// <param name="clipGradient">Clip gradient to the range of [-clip_gradient, clip_gradient] If clip_gradient &lt;= 0, gradient clipping is turned off. grad = max(min(grad, clip_gradient), -clip_gradient).</param>
    /// <param name="numWeights">Number of updated weights.</param>
    new([<Optional>] ?data : Symbol seq,
        [<Optional>] ?momentum : float,
        [<Optional>] ?rescaleGrad : float,
        [<Optional>] ?clipGradient : float,
        [<Optional>] ?numWeights : int) = 
        let data = defaultArg (data |> Option.map Seq.toArray) Array.empty
        let operatorArguments = 
            [
                "data", VarArg("", data)
                "momentum", momentum |> Option.map box |> Parameter
                "rescale_grad", rescaleGrad |> Option.map box |> Parameter
                "clip_gradient", clipGradient |> Option.map box |> Parameter
                "num_weights", numWeights |> Option.map box |> Parameter
            ]
        new PreloadedMultiSgdMomUpdate(Arguments<Symbol>(operatorArguments))
    /// Default value for Momentum
    /// The decay rate of momentum estimates at each epoch.
    static member MomentumDefault : double = 0.0
    /// Default value for RescaleGrad
    /// Rescale gradient to grad = rescale_grad*grad.
    static member RescaleGradDefault : double = 1.0
    /// Default value for ClipGradient
    /// Clip gradient to the range of [-clip_gradient, clip_gradient] If clip_gradient &lt;= 0, gradient clipping is turned off. grad = max(min(grad, clip_gradient), -clip_gradient).
    static member ClipGradientDefault : double = -1.0
    /// Default value for NumWeights
    /// Number of updated weights.
    static member NumWeightsDefault : int = 1
    /// Weights, gradients, momentum, learning rates and weight decays
    member __.Data = operatorArguments.GetVarArg "data"
    /// The decay rate of momentum estimates at each epoch.
    member __.Momentum = operatorArguments.GetParameter("momentum", PreloadedMultiSgdMomUpdate.MomentumDefault)
    /// Rescale gradient to grad = rescale_grad*grad.
    member __.RescaleGrad = operatorArguments.GetParameter("rescale_grad", PreloadedMultiSgdMomUpdate.RescaleGradDefault)
    /// Clip gradient to the range of [-clip_gradient, clip_gradient] If clip_gradient &lt;= 0, gradient clipping is turned off. grad = max(min(grad, clip_gradient), -clip_gradient).
    member __.ClipGradient = operatorArguments.GetParameter("clip_gradient", PreloadedMultiSgdMomUpdate.ClipGradientDefault)
    /// Number of updated weights.
    member __.NumWeights = operatorArguments.GetParameter("num_weights", PreloadedMultiSgdMomUpdate.NumWeightsDefault)
    /// <summary>Copy PreloadedMultiSgdMomUpdate instance with updated inputs/parameters.</summary>
    /// <param name="data">Weights, gradients, momentum, learning rates and weight decays</param>
    /// <param name="momentum">The decay rate of momentum estimates at each epoch.</param>
    /// <param name="rescaleGrad">Rescale gradient to grad = rescale_grad*grad.</param>
    /// <param name="clipGradient">Clip gradient to the range of [-clip_gradient, clip_gradient] If clip_gradient &lt;= 0, gradient clipping is turned off. grad = max(min(grad, clip_gradient), -clip_gradient).</param>
    /// <param name="numWeights">Number of updated weights.</param>
    member this.With([<Optional>] ?data : Symbol seq,
        [<Optional>] ?momentum : float,
        [<Optional>] ?rescaleGrad : float,
        [<Optional>] ?clipGradient : float,
        [<Optional>] ?numWeights : int) = 
        let operatorArguments = 
            [
                data |> Option.map (fun x -> "data", VarArg("", Seq.toArray x))
                momentum |> Option.map (fun x -> "momentum", Parameter(Some (box x)))
                rescaleGrad |> Option.map (fun x -> "rescale_grad", Parameter(Some (box x)))
                clipGradient |> Option.map (fun x -> "clip_gradient", Parameter(Some (box x)))
                numWeights |> Option.map (fun x -> "num_weights", Parameter(Some (box x)))
            ] |> List.choose id
        new PreloadedMultiSgdMomUpdate(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type PreloadedMultiMpSgdUpdate private (operatorArguments) = 
    inherit SymbolOperator("preloaded_multi_mp_sgd_update", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new PreloadedMultiMpSgdUpdate(args)
    override this.WithArguments(args : Arguments<Symbol>) = new PreloadedMultiMpSgdUpdate(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <summary>Update function for multi-precision Stochastic Gradient Descent (SDG) optimizer.
    /// 
    /// It updates the weights using::
    /// 
    ///  weight = weight - learning_rate * (gradient + wd * weight)
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\contrib\preloaded_multi_sgd.cc:L140</summary>
    /// <param name="data">Weights, gradients, learning rates and weight decays</param>
    /// <param name="rescaleGrad">Rescale gradient to grad = rescale_grad*grad.</param>
    /// <param name="clipGradient">Clip gradient to the range of [-clip_gradient, clip_gradient] If clip_gradient &lt;= 0, gradient clipping is turned off. grad = max(min(grad, clip_gradient), -clip_gradient).</param>
    /// <param name="numWeights">Number of updated weights.</param>
    new([<Optional>] ?data : Symbol seq,
        [<Optional>] ?rescaleGrad : float,
        [<Optional>] ?clipGradient : float,
        [<Optional>] ?numWeights : int) = 
        let data = defaultArg (data |> Option.map Seq.toArray) Array.empty
        let operatorArguments = 
            [
                "data", VarArg("", data)
                "rescale_grad", rescaleGrad |> Option.map box |> Parameter
                "clip_gradient", clipGradient |> Option.map box |> Parameter
                "num_weights", numWeights |> Option.map box |> Parameter
            ]
        new PreloadedMultiMpSgdUpdate(Arguments<Symbol>(operatorArguments))
    /// Default value for RescaleGrad
    /// Rescale gradient to grad = rescale_grad*grad.
    static member RescaleGradDefault : double = 1.0
    /// Default value for ClipGradient
    /// Clip gradient to the range of [-clip_gradient, clip_gradient] If clip_gradient &lt;= 0, gradient clipping is turned off. grad = max(min(grad, clip_gradient), -clip_gradient).
    static member ClipGradientDefault : double = -1.0
    /// Default value for NumWeights
    /// Number of updated weights.
    static member NumWeightsDefault : int = 1
    /// Weights, gradients, learning rates and weight decays
    member __.Data = operatorArguments.GetVarArg "data"
    /// Rescale gradient to grad = rescale_grad*grad.
    member __.RescaleGrad = operatorArguments.GetParameter("rescale_grad", PreloadedMultiMpSgdUpdate.RescaleGradDefault)
    /// Clip gradient to the range of [-clip_gradient, clip_gradient] If clip_gradient &lt;= 0, gradient clipping is turned off. grad = max(min(grad, clip_gradient), -clip_gradient).
    member __.ClipGradient = operatorArguments.GetParameter("clip_gradient", PreloadedMultiMpSgdUpdate.ClipGradientDefault)
    /// Number of updated weights.
    member __.NumWeights = operatorArguments.GetParameter("num_weights", PreloadedMultiMpSgdUpdate.NumWeightsDefault)
    /// <summary>Copy PreloadedMultiMpSgdUpdate instance with updated inputs/parameters.</summary>
    /// <param name="data">Weights, gradients, learning rates and weight decays</param>
    /// <param name="rescaleGrad">Rescale gradient to grad = rescale_grad*grad.</param>
    /// <param name="clipGradient">Clip gradient to the range of [-clip_gradient, clip_gradient] If clip_gradient &lt;= 0, gradient clipping is turned off. grad = max(min(grad, clip_gradient), -clip_gradient).</param>
    /// <param name="numWeights">Number of updated weights.</param>
    member this.With([<Optional>] ?data : Symbol seq,
        [<Optional>] ?rescaleGrad : float,
        [<Optional>] ?clipGradient : float,
        [<Optional>] ?numWeights : int) = 
        let operatorArguments = 
            [
                data |> Option.map (fun x -> "data", VarArg("", Seq.toArray x))
                rescaleGrad |> Option.map (fun x -> "rescale_grad", Parameter(Some (box x)))
                clipGradient |> Option.map (fun x -> "clip_gradient", Parameter(Some (box x)))
                numWeights |> Option.map (fun x -> "num_weights", Parameter(Some (box x)))
            ] |> List.choose id
        new PreloadedMultiMpSgdUpdate(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type PreloadedMultiMpSgdMomUpdate private (operatorArguments) = 
    inherit SymbolOperator("preloaded_multi_mp_sgd_mom_update", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new PreloadedMultiMpSgdMomUpdate(args)
    override this.WithArguments(args : Arguments<Symbol>) = new PreloadedMultiMpSgdMomUpdate(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <summary>Momentum update function for multi-precision Stochastic Gradient Descent (SGD) optimizer.
    /// 
    /// Momentum update has better convergence rates on neural networks. Mathematically it looks
    /// like below:
    /// 
    /// .. math::
    /// 
    ///   v_1 = \alpha * \nabla J(W_0)\\
    ///   v_t = \gamma v_{t-1} - \alpha * \nabla J(W_{t-1})\\
    ///   W_t = W_{t-1} + v_t
    /// 
    /// It updates the weights using::
    /// 
    ///   v = momentum * v - learning_rate * gradient
    ///   weight += v
    /// 
    /// Where the parameter ``momentum`` is the decay rate of momentum estimates at each epoch.
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\contrib\preloaded_multi_sgd.cc:L200</summary>
    /// <param name="data">Weights, gradients, momentums, learning rates and weight decays</param>
    /// <param name="momentum">The decay rate of momentum estimates at each epoch.</param>
    /// <param name="rescaleGrad">Rescale gradient to grad = rescale_grad*grad.</param>
    /// <param name="clipGradient">Clip gradient to the range of [-clip_gradient, clip_gradient] If clip_gradient &lt;= 0, gradient clipping is turned off. grad = max(min(grad, clip_gradient), -clip_gradient).</param>
    /// <param name="numWeights">Number of updated weights.</param>
    new([<Optional>] ?data : Symbol seq,
        [<Optional>] ?momentum : float,
        [<Optional>] ?rescaleGrad : float,
        [<Optional>] ?clipGradient : float,
        [<Optional>] ?numWeights : int) = 
        let data = defaultArg (data |> Option.map Seq.toArray) Array.empty
        let operatorArguments = 
            [
                "data", VarArg("", data)
                "momentum", momentum |> Option.map box |> Parameter
                "rescale_grad", rescaleGrad |> Option.map box |> Parameter
                "clip_gradient", clipGradient |> Option.map box |> Parameter
                "num_weights", numWeights |> Option.map box |> Parameter
            ]
        new PreloadedMultiMpSgdMomUpdate(Arguments<Symbol>(operatorArguments))
    /// Default value for Momentum
    /// The decay rate of momentum estimates at each epoch.
    static member MomentumDefault : double = 0.0
    /// Default value for RescaleGrad
    /// Rescale gradient to grad = rescale_grad*grad.
    static member RescaleGradDefault : double = 1.0
    /// Default value for ClipGradient
    /// Clip gradient to the range of [-clip_gradient, clip_gradient] If clip_gradient &lt;= 0, gradient clipping is turned off. grad = max(min(grad, clip_gradient), -clip_gradient).
    static member ClipGradientDefault : double = -1.0
    /// Default value for NumWeights
    /// Number of updated weights.
    static member NumWeightsDefault : int = 1
    /// Weights, gradients, momentums, learning rates and weight decays
    member __.Data = operatorArguments.GetVarArg "data"
    /// The decay rate of momentum estimates at each epoch.
    member __.Momentum = operatorArguments.GetParameter("momentum", PreloadedMultiMpSgdMomUpdate.MomentumDefault)
    /// Rescale gradient to grad = rescale_grad*grad.
    member __.RescaleGrad = operatorArguments.GetParameter("rescale_grad", PreloadedMultiMpSgdMomUpdate.RescaleGradDefault)
    /// Clip gradient to the range of [-clip_gradient, clip_gradient] If clip_gradient &lt;= 0, gradient clipping is turned off. grad = max(min(grad, clip_gradient), -clip_gradient).
    member __.ClipGradient = operatorArguments.GetParameter("clip_gradient", PreloadedMultiMpSgdMomUpdate.ClipGradientDefault)
    /// Number of updated weights.
    member __.NumWeights = operatorArguments.GetParameter("num_weights", PreloadedMultiMpSgdMomUpdate.NumWeightsDefault)
    /// <summary>Copy PreloadedMultiMpSgdMomUpdate instance with updated inputs/parameters.</summary>
    /// <param name="data">Weights, gradients, momentums, learning rates and weight decays</param>
    /// <param name="momentum">The decay rate of momentum estimates at each epoch.</param>
    /// <param name="rescaleGrad">Rescale gradient to grad = rescale_grad*grad.</param>
    /// <param name="clipGradient">Clip gradient to the range of [-clip_gradient, clip_gradient] If clip_gradient &lt;= 0, gradient clipping is turned off. grad = max(min(grad, clip_gradient), -clip_gradient).</param>
    /// <param name="numWeights">Number of updated weights.</param>
    member this.With([<Optional>] ?data : Symbol seq,
        [<Optional>] ?momentum : float,
        [<Optional>] ?rescaleGrad : float,
        [<Optional>] ?clipGradient : float,
        [<Optional>] ?numWeights : int) = 
        let operatorArguments = 
            [
                data |> Option.map (fun x -> "data", VarArg("", Seq.toArray x))
                momentum |> Option.map (fun x -> "momentum", Parameter(Some (box x)))
                rescaleGrad |> Option.map (fun x -> "rescale_grad", Parameter(Some (box x)))
                clipGradient |> Option.map (fun x -> "clip_gradient", Parameter(Some (box x)))
                numWeights |> Option.map (fun x -> "num_weights", Parameter(Some (box x)))
            ] |> List.choose id
        new PreloadedMultiMpSgdMomUpdate(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type ContribQuadratic private (operatorArguments) = 
    inherit SymbolOperator("_contrib_quadratic", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new ContribQuadratic(args)
    override this.WithArguments(args : Arguments<Symbol>) = new ContribQuadratic(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <summary>This operators implements the quadratic function.
    /// 
    /// .. math::
    ///     f(x) = ax^2+bx+c
    /// 
    /// where :math:`x` is an input tensor and all operations
    /// in the function are element-wise.
    /// 
    /// Example::
    /// 
    ///   x = [[1, 2], [3, 4]]
    ///   y = quadratic(data=x, a=1, b=2, c=3)
    ///   y = [[6, 11], [18, 27]]
    /// 
    /// The storage type of ``quadratic`` output depends on storage types of inputs
    ///   - quadratic(csr, a, b, 0) = csr
    ///   - quadratic(default, a, b, c) = default
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\contrib\quadratic_op.cc:L50</summary>
    /// <param name="data">Input ndarray</param>
    /// <param name="a">Coefficient of the quadratic term in the quadratic function.</param>
    /// <param name="b">Coefficient of the linear term in the quadratic function.</param>
    /// <param name="c">Constant term in the quadratic function.</param>
    new([<Optional>] ?data : Symbol,
        [<Optional>] ?a : float,
        [<Optional>] ?b : float,
        [<Optional>] ?c : float) = 
        let data = defaultArg data (new ImplicitVariable() :> Symbol)
        let operatorArguments = 
            [
                "data", Input data
                "a", a |> Option.map box |> Parameter
                "b", b |> Option.map box |> Parameter
                "c", c |> Option.map box |> Parameter
            ]
        new ContribQuadratic(Arguments<Symbol>(operatorArguments))
    /// Default value for A
    /// Coefficient of the quadratic term in the quadratic function.
    static member ADefault : double = 0.0
    /// Default value for B
    /// Coefficient of the linear term in the quadratic function.
    static member BDefault : double = 0.0
    /// Default value for C
    /// Constant term in the quadratic function.
    static member CDefault : double = 0.0
    /// Input ndarray
    member __.Data = operatorArguments.GetInput "data"
    /// Coefficient of the quadratic term in the quadratic function.
    member __.A = operatorArguments.GetParameter("a", ContribQuadratic.ADefault)
    /// Coefficient of the linear term in the quadratic function.
    member __.B = operatorArguments.GetParameter("b", ContribQuadratic.BDefault)
    /// Constant term in the quadratic function.
    member __.C = operatorArguments.GetParameter("c", ContribQuadratic.CDefault)
    /// <summary>Copy ContribQuadratic instance with updated inputs/parameters.</summary>
    /// <param name="data">Input ndarray</param>
    /// <param name="a">Coefficient of the quadratic term in the quadratic function.</param>
    /// <param name="b">Coefficient of the linear term in the quadratic function.</param>
    /// <param name="c">Constant term in the quadratic function.</param>
    member this.With([<Optional>] ?data : Symbol,
        [<Optional>] ?a : float,
        [<Optional>] ?b : float,
        [<Optional>] ?c : float) = 
        let operatorArguments = 
            [
                data |> Option.map (fun x -> "data", Input x)
                a |> Option.map (fun x -> "a", Parameter(Some (box x)))
                b |> Option.map (fun x -> "b", Parameter(Some (box x)))
                c |> Option.map (fun x -> "c", Parameter(Some (box x)))
            ] |> List.choose id
        new ContribQuadratic(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type ContribBackwardQuadratic private (operatorArguments) = 
    inherit SymbolOperator("_contrib_backward_quadratic", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new ContribBackwardQuadratic(args)
    override this.WithArguments(args : Arguments<Symbol>) = new ContribBackwardQuadratic(this.OperatorArguments.AddReplace(args)) :> Symbol
    new() =
        let operatorArguments = 
            [
            ]
        new ContribBackwardQuadratic(Arguments<Symbol>(operatorArguments))

type ContribROIAlign private (operatorArguments) = 
    inherit SymbolOperator("_contrib_ROIAlign", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new ContribROIAlign(args)
    override this.WithArguments(args : Arguments<Symbol>) = new ContribROIAlign(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <summary>
    /// This operator takes a 4D feature map as an input array and region proposals as `rois`,
    /// then align the feature map over sub-regions of input and produces a fixed-sized output array.
    /// This operator is typically used in Faster R-CNN &amp; Mask R-CNN networks.
    /// 
    /// Different from ROI pooling, ROI Align removes the harsh quantization, properly aligning
    /// the extracted features with the input. RoIAlign computes the value of each sampling point
    /// by bilinear interpolation from the nearby grid points on the feature map. No quantization is
    /// performed on any coordinates involved in the RoI, its bins, or the sampling points.
    /// Bilinear interpolation is used to compute the exact values of the
    /// input features at four regularly sampled locations in each RoI bin.
    /// Then the feature map can be aggregated by avgpooling.
    /// 
    /// 
    /// References
    /// ----------
    /// 
    /// He, Kaiming, et al. &quot;Mask R-CNN.&quot; ICCV, 2017
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\contrib\roi_align.cc:L538</summary>
    /// <param name="data">Input data to the pooling operator, a 4D Feature maps</param>
    /// <param name="rois">Bounding box coordinates, a 2D array</param>
    /// <param name="pooledSize">ROI Align output roi feature map height and width: (h, w)</param>
    /// <param name="spatialScale">Ratio of input feature map height (or w) to raw image height (or w). Equals the reciprocal of total stride in convolutional layers</param>
    /// <param name="sampleRatio">Optional sampling ratio of ROI align, using adaptive size by default.</param>
    /// <param name="positionSensitive">Whether to perform position-sensitive RoI pooling. PSRoIPooling is first proposaled by R-FCN and it can reduce the input channels by ph*pw times, where (ph, pw) is the pooled_size</param>
    new(data : Symbol,
        rois : Symbol,
        pooledSize : int seq,
        spatialScale : float,
        [<Optional>] ?sampleRatio : int,
        [<Optional>] ?positionSensitive : bool) = 
        let operatorArguments = 
            [
                "data", Input data
                "rois", Input rois
                "pooled_size", Parameter(Some(box pooledSize))
                "spatial_scale", Parameter(Some(box spatialScale))
                "sample_ratio", sampleRatio |> Option.map box |> Parameter
                "position_sensitive", positionSensitive |> Option.map box |> Parameter
            ]
        new ContribROIAlign(Arguments<Symbol>(operatorArguments))
    /// <summary>
    /// This operator takes a 4D feature map as an input array and region proposals as `rois`,
    /// then align the feature map over sub-regions of input and produces a fixed-sized output array.
    /// This operator is typically used in Faster R-CNN &amp; Mask R-CNN networks.
    /// 
    /// Different from ROI pooling, ROI Align removes the harsh quantization, properly aligning
    /// the extracted features with the input. RoIAlign computes the value of each sampling point
    /// by bilinear interpolation from the nearby grid points on the feature map. No quantization is
    /// performed on any coordinates involved in the RoI, its bins, or the sampling points.
    /// Bilinear interpolation is used to compute the exact values of the
    /// input features at four regularly sampled locations in each RoI bin.
    /// Then the feature map can be aggregated by avgpooling.
    /// 
    /// 
    /// References
    /// ----------
    /// 
    /// He, Kaiming, et al. &quot;Mask R-CNN.&quot; ICCV, 2017
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\contrib\roi_align.cc:L538</summary>
    /// <param name="pooledSize">ROI Align output roi feature map height and width: (h, w)</param>
    /// <param name="spatialScale">Ratio of input feature map height (or w) to raw image height (or w). Equals the reciprocal of total stride in convolutional layers</param>
    /// <param name="data">Input data to the pooling operator, a 4D Feature maps</param>
    /// <param name="rois">Bounding box coordinates, a 2D array</param>
    /// <param name="sampleRatio">Optional sampling ratio of ROI align, using adaptive size by default.</param>
    /// <param name="positionSensitive">Whether to perform position-sensitive RoI pooling. PSRoIPooling is first proposaled by R-FCN and it can reduce the input channels by ph*pw times, where (ph, pw) is the pooled_size</param>
    new(pooledSize : int seq,
        spatialScale : float,
        [<Optional>] ?data : Symbol,
        [<Optional>] ?rois : Symbol,
        [<Optional>] ?sampleRatio : int,
        [<Optional>] ?positionSensitive : bool) = 
        let data = defaultArg data (new ImplicitVariable() :> Symbol)
        let rois = defaultArg rois (new ImplicitVariable() :> Symbol)
        let operatorArguments = 
            [
                "data", Input data
                "rois", Input rois
                "pooled_size", Parameter(Some(box pooledSize))
                "spatial_scale", Parameter(Some(box spatialScale))
                "sample_ratio", sampleRatio |> Option.map box |> Parameter
                "position_sensitive", positionSensitive |> Option.map box |> Parameter
            ]
        new ContribROIAlign(Arguments<Symbol>(operatorArguments))
    /// Default value for SampleRatio
    /// Optional sampling ratio of ROI align, using adaptive size by default.
    static member SampleRatioDefault : int = -1
    /// Default value for PositionSensitive
    /// Whether to perform position-sensitive RoI pooling. PSRoIPooling is first proposaled by R-FCN and it can reduce the input channels by ph*pw times, where (ph, pw) is the pooled_size
    static member PositionSensitiveDefault : bool = false
    /// Input data to the pooling operator, a 4D Feature maps
    member __.Data = operatorArguments.GetInput "data"
    /// Bounding box coordinates, a 2D array
    member __.Rois = operatorArguments.GetInput "rois"
    /// ROI Align output roi feature map height and width: (h, w)
    member __.PooledSize : int seq = match operatorArguments.GetParameter "pooled_size" with Some(v) -> unbox v | None -> failwithf "Required parameter pooled_size is missing"
    /// Ratio of input feature map height (or w) to raw image height (or w). Equals the reciprocal of total stride in convolutional layers
    member __.SpatialScale : float = match operatorArguments.GetParameter "spatial_scale" with Some(v) -> unbox v | None -> failwithf "Required parameter spatial_scale is missing"
    /// Optional sampling ratio of ROI align, using adaptive size by default.
    member __.SampleRatio = operatorArguments.GetParameter("sample_ratio", ContribROIAlign.SampleRatioDefault)
    /// Whether to perform position-sensitive RoI pooling. PSRoIPooling is first proposaled by R-FCN and it can reduce the input channels by ph*pw times, where (ph, pw) is the pooled_size
    member __.PositionSensitive = operatorArguments.GetParameter("position_sensitive", ContribROIAlign.PositionSensitiveDefault)
    /// <summary>Copy ContribROIAlign instance with updated inputs/parameters.</summary>
    /// <param name="data">Input data to the pooling operator, a 4D Feature maps</param>
    /// <param name="rois">Bounding box coordinates, a 2D array</param>
    /// <param name="pooledSize">ROI Align output roi feature map height and width: (h, w)</param>
    /// <param name="spatialScale">Ratio of input feature map height (or w) to raw image height (or w). Equals the reciprocal of total stride in convolutional layers</param>
    /// <param name="sampleRatio">Optional sampling ratio of ROI align, using adaptive size by default.</param>
    /// <param name="positionSensitive">Whether to perform position-sensitive RoI pooling. PSRoIPooling is first proposaled by R-FCN and it can reduce the input channels by ph*pw times, where (ph, pw) is the pooled_size</param>
    member this.With([<Optional>] ?data : Symbol,
        [<Optional>] ?rois : Symbol,
        [<Optional>] ?pooledSize : int seq,
        [<Optional>] ?spatialScale : float,
        [<Optional>] ?sampleRatio : int,
        [<Optional>] ?positionSensitive : bool) = 
        let operatorArguments = 
            [
                data |> Option.map (fun x -> "data", Input x)
                rois |> Option.map (fun x -> "rois", Input x)
                pooledSize |> Option.map (fun x -> "pooled_size", Parameter(Some (box x)))
                spatialScale |> Option.map (fun x -> "spatial_scale", Parameter(Some (box x)))
                sampleRatio |> Option.map (fun x -> "sample_ratio", Parameter(Some (box x)))
                positionSensitive |> Option.map (fun x -> "position_sensitive", Parameter(Some (box x)))
            ] |> List.choose id
        new ContribROIAlign(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type ContribRROIAlign private (operatorArguments) = 
    inherit SymbolOperator("_contrib_RROIAlign", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new ContribRROIAlign(args)
    override this.WithArguments(args : Arguments<Symbol>) = new ContribRROIAlign(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <summary>Performs Rotated ROI Align on the input array.
    /// 
    /// This operator takes a 4D feature map as an input array and region proposals as `rois`,
    /// then align the feature map over sub-regions of input and produces a fixed-sized output array.
    /// 
    /// Different from ROI Align, RROI Align uses rotated rois, which is suitable for text detection.
    /// RRoIAlign computes the value of each sampling point by bilinear interpolation from the nearby
    /// grid points on the rotated feature map. No quantization is performed on any coordinates
    /// involved in the RoI, its bins, or the sampling points. Bilinear interpolation is used to
    /// compute the exact values of the input features at four regularly sampled locations in
    /// each RoI bin. Then the feature map can be aggregated by avgpooling.
    /// 
    /// References
    /// ----------
    /// 
    /// Ma, Jianqi, et al. &quot;Arbitrary-Oriented Scene Text Detection via Rotation Proposals.&quot;
    /// IEEE Transactions on Multimedia, 2018.
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\contrib\rroi_align.cc:L274</summary>
    /// <param name="data">Input data to the pooling operator, a 4D Feature maps</param>
    /// <param name="rois">Bounding box coordinates, a 2D array</param>
    /// <param name="pooledSize">RROI align output shape (h,w) </param>
    /// <param name="spatialScale">Ratio of input feature map height (or width) to raw image height (or width). Equals the reciprocal of total stride in convolutional layers</param>
    /// <param name="samplingRatio">Optional sampling ratio of RROI align, using adaptive size by default.</param>
    new(data : Symbol,
        rois : Symbol,
        pooledSize : int seq,
        spatialScale : float,
        [<Optional>] ?samplingRatio : int) = 
        let operatorArguments = 
            [
                "data", Input data
                "rois", Input rois
                "pooled_size", Parameter(Some(box pooledSize))
                "spatial_scale", Parameter(Some(box spatialScale))
                "sampling_ratio", samplingRatio |> Option.map box |> Parameter
            ]
        new ContribRROIAlign(Arguments<Symbol>(operatorArguments))
    /// <summary>Performs Rotated ROI Align on the input array.
    /// 
    /// This operator takes a 4D feature map as an input array and region proposals as `rois`,
    /// then align the feature map over sub-regions of input and produces a fixed-sized output array.
    /// 
    /// Different from ROI Align, RROI Align uses rotated rois, which is suitable for text detection.
    /// RRoIAlign computes the value of each sampling point by bilinear interpolation from the nearby
    /// grid points on the rotated feature map. No quantization is performed on any coordinates
    /// involved in the RoI, its bins, or the sampling points. Bilinear interpolation is used to
    /// compute the exact values of the input features at four regularly sampled locations in
    /// each RoI bin. Then the feature map can be aggregated by avgpooling.
    /// 
    /// References
    /// ----------
    /// 
    /// Ma, Jianqi, et al. &quot;Arbitrary-Oriented Scene Text Detection via Rotation Proposals.&quot;
    /// IEEE Transactions on Multimedia, 2018.
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\contrib\rroi_align.cc:L274</summary>
    /// <param name="pooledSize">RROI align output shape (h,w) </param>
    /// <param name="spatialScale">Ratio of input feature map height (or width) to raw image height (or width). Equals the reciprocal of total stride in convolutional layers</param>
    /// <param name="data">Input data to the pooling operator, a 4D Feature maps</param>
    /// <param name="rois">Bounding box coordinates, a 2D array</param>
    /// <param name="samplingRatio">Optional sampling ratio of RROI align, using adaptive size by default.</param>
    new(pooledSize : int seq,
        spatialScale : float,
        [<Optional>] ?data : Symbol,
        [<Optional>] ?rois : Symbol,
        [<Optional>] ?samplingRatio : int) = 
        let data = defaultArg data (new ImplicitVariable() :> Symbol)
        let rois = defaultArg rois (new ImplicitVariable() :> Symbol)
        let operatorArguments = 
            [
                "data", Input data
                "rois", Input rois
                "pooled_size", Parameter(Some(box pooledSize))
                "spatial_scale", Parameter(Some(box spatialScale))
                "sampling_ratio", samplingRatio |> Option.map box |> Parameter
            ]
        new ContribRROIAlign(Arguments<Symbol>(operatorArguments))
    /// Default value for SamplingRatio
    /// Optional sampling ratio of RROI align, using adaptive size by default.
    static member SamplingRatioDefault : int = -1
    /// Input data to the pooling operator, a 4D Feature maps
    member __.Data = operatorArguments.GetInput "data"
    /// Bounding box coordinates, a 2D array
    member __.Rois = operatorArguments.GetInput "rois"
    /// RROI align output shape (h,w) 
    member __.PooledSize : int seq = match operatorArguments.GetParameter "pooled_size" with Some(v) -> unbox v | None -> failwithf "Required parameter pooled_size is missing"
    /// Ratio of input feature map height (or width) to raw image height (or width). Equals the reciprocal of total stride in convolutional layers
    member __.SpatialScale : float = match operatorArguments.GetParameter "spatial_scale" with Some(v) -> unbox v | None -> failwithf "Required parameter spatial_scale is missing"
    /// Optional sampling ratio of RROI align, using adaptive size by default.
    member __.SamplingRatio = operatorArguments.GetParameter("sampling_ratio", ContribRROIAlign.SamplingRatioDefault)
    /// <summary>Copy ContribRROIAlign instance with updated inputs/parameters.</summary>
    /// <param name="data">Input data to the pooling operator, a 4D Feature maps</param>
    /// <param name="rois">Bounding box coordinates, a 2D array</param>
    /// <param name="pooledSize">RROI align output shape (h,w) </param>
    /// <param name="spatialScale">Ratio of input feature map height (or width) to raw image height (or width). Equals the reciprocal of total stride in convolutional layers</param>
    /// <param name="samplingRatio">Optional sampling ratio of RROI align, using adaptive size by default.</param>
    member this.With([<Optional>] ?data : Symbol,
        [<Optional>] ?rois : Symbol,
        [<Optional>] ?pooledSize : int seq,
        [<Optional>] ?spatialScale : float,
        [<Optional>] ?samplingRatio : int) = 
        let operatorArguments = 
            [
                data |> Option.map (fun x -> "data", Input x)
                rois |> Option.map (fun x -> "rois", Input x)
                pooledSize |> Option.map (fun x -> "pooled_size", Parameter(Some (box x)))
                spatialScale |> Option.map (fun x -> "spatial_scale", Parameter(Some (box x)))
                samplingRatio |> Option.map (fun x -> "sampling_ratio", Parameter(Some (box x)))
            ] |> List.choose id
        new ContribRROIAlign(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type ContribSyncBatchNorm private (operatorArguments) = 
    inherit SymbolOperator("_contrib_SyncBatchNorm", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new ContribSyncBatchNorm(args)
    override this.WithArguments(args : Arguments<Symbol>) = new ContribSyncBatchNorm(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <summary>Batch normalization.
    /// 
    /// Normalizes a data batch by mean and variance, and applies a scale ``gamma`` as
    /// well as offset ``beta``.
    /// Standard BN [1]_ implementation only normalize the data within each device.
    /// SyncBN normalizes the input within the whole mini-batch.
    /// We follow the sync-onece implmentation described in the paper [2]_.
    /// 
    /// Assume the input has more than one dimension and we normalize along axis 1.
    /// We first compute the mean and variance along this axis:
    /// 
    /// .. math::
    /// 
    ///   data\_mean[i] = mean(data[:,i,:,...]) \\
    ///   data\_var[i] = var(data[:,i,:,...])
    /// 
    /// Then compute the normalized output, which has the same shape as input, as following:
    /// 
    /// .. math::
    /// 
    ///   out[:,i,:,...] = \frac{data[:,i,:,...] - data\_mean[i]}{\sqrt{data\_var[i]+\epsilon}} * gamma[i] + beta[i]
    /// 
    /// Both *mean* and *var* returns a scalar by treating the input as a vector.
    /// 
    /// Assume the input has size *k* on axis 1, then both ``gamma`` and ``beta``
    /// have shape *(k,)*. If ``output_mean_var`` is set to be true, then outputs both ``data_mean`` and
    /// ``data_var`` as well, which are needed for the backward pass.
    /// 
    /// Besides the inputs and the outputs, this operator accepts two auxiliary
    /// states, ``moving_mean`` and ``moving_var``, which are *k*-length
    /// vectors. They are global statistics for the whole dataset, which are updated
    /// by::
    /// 
    ///   moving_mean = moving_mean * momentum + data_mean * (1 - momentum)
    ///   moving_var = moving_var * momentum + data_var * (1 - momentum)
    /// 
    /// If ``use_global_stats`` is set to be true, then ``moving_mean`` and
    /// ``moving_var`` are used instead of ``data_mean`` and ``data_var`` to compute
    /// the output. It is often used during inference.
    /// 
    /// Both ``gamma`` and ``beta`` are learnable parameters. But if ``fix_gamma`` is true,
    /// then set ``gamma`` to 1 and its gradient to 0.
    /// 
    /// Reference:
    ///   .. [1] Ioffe, Sergey, and Christian Szegedy. &quot;Batch normalization: Accelerating \
    ///     deep network training by reducing internal covariate shift.&quot; *ICML 2015*
    ///   .. [2] Hang Zhang, Kristin Dana, Jianping Shi, Zhongyue Zhang, Xiaogang Wang, \
    ///     Ambrish Tyagi, and Amit Agrawal. &quot;Context Encoding for Semantic Segmentation.&quot; *CVPR 2018*
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\contrib\sync_batch_norm.cc:L97</summary>
    /// <param name="data">Input data to batch normalization</param>
    /// <param name="gamma">gamma array</param>
    /// <param name="beta">beta array</param>
    /// <param name="movingMean">running mean of input</param>
    /// <param name="movingVar">running variance of input</param>
    /// <param name="key">Hash key for synchronization, please set the same hash key for same layer, Block.prefix is typically used as in :class:`gluon.nn.contrib.SyncBatchNorm`.</param>
    /// <param name="eps">Epsilon to prevent div 0</param>
    /// <param name="momentum">Momentum for moving average</param>
    /// <param name="fixGamma">Fix gamma while training</param>
    /// <param name="useGlobalStats">Whether use global moving statistics instead of local batch-norm. This will force change batch-norm into a scale shift operator.</param>
    /// <param name="outputMeanVar">Output All,normal mean and var</param>
    /// <param name="ndev">The count of GPU devices</param>
    new(data : Symbol,
        gamma : Symbol,
        beta : Symbol,
        movingMean : Symbol,
        movingVar : Symbol,
        key : string,
        [<Optional>] ?eps : float,
        [<Optional>] ?momentum : float,
        [<Optional>] ?fixGamma : bool,
        [<Optional>] ?useGlobalStats : bool,
        [<Optional>] ?outputMeanVar : bool,
        [<Optional>] ?ndev : int) = 
        let operatorArguments = 
            [
                "data", Input data
                "gamma", Input gamma
                "beta", Input beta
                "moving_mean", Input movingMean
                "moving_var", Input movingVar
                "key", Parameter(Some(box key))
                "eps", eps |> Option.map box |> Parameter
                "momentum", momentum |> Option.map box |> Parameter
                "fix_gamma", fixGamma |> Option.map box |> Parameter
                "use_global_stats", useGlobalStats |> Option.map box |> Parameter
                "output_mean_var", outputMeanVar |> Option.map box |> Parameter
                "ndev", ndev |> Option.map box |> Parameter
            ]
        new ContribSyncBatchNorm(Arguments<Symbol>(operatorArguments))
    /// <summary>Batch normalization.
    /// 
    /// Normalizes a data batch by mean and variance, and applies a scale ``gamma`` as
    /// well as offset ``beta``.
    /// Standard BN [1]_ implementation only normalize the data within each device.
    /// SyncBN normalizes the input within the whole mini-batch.
    /// We follow the sync-onece implmentation described in the paper [2]_.
    /// 
    /// Assume the input has more than one dimension and we normalize along axis 1.
    /// We first compute the mean and variance along this axis:
    /// 
    /// .. math::
    /// 
    ///   data\_mean[i] = mean(data[:,i,:,...]) \\
    ///   data\_var[i] = var(data[:,i,:,...])
    /// 
    /// Then compute the normalized output, which has the same shape as input, as following:
    /// 
    /// .. math::
    /// 
    ///   out[:,i,:,...] = \frac{data[:,i,:,...] - data\_mean[i]}{\sqrt{data\_var[i]+\epsilon}} * gamma[i] + beta[i]
    /// 
    /// Both *mean* and *var* returns a scalar by treating the input as a vector.
    /// 
    /// Assume the input has size *k* on axis 1, then both ``gamma`` and ``beta``
    /// have shape *(k,)*. If ``output_mean_var`` is set to be true, then outputs both ``data_mean`` and
    /// ``data_var`` as well, which are needed for the backward pass.
    /// 
    /// Besides the inputs and the outputs, this operator accepts two auxiliary
    /// states, ``moving_mean`` and ``moving_var``, which are *k*-length
    /// vectors. They are global statistics for the whole dataset, which are updated
    /// by::
    /// 
    ///   moving_mean = moving_mean * momentum + data_mean * (1 - momentum)
    ///   moving_var = moving_var * momentum + data_var * (1 - momentum)
    /// 
    /// If ``use_global_stats`` is set to be true, then ``moving_mean`` and
    /// ``moving_var`` are used instead of ``data_mean`` and ``data_var`` to compute
    /// the output. It is often used during inference.
    /// 
    /// Both ``gamma`` and ``beta`` are learnable parameters. But if ``fix_gamma`` is true,
    /// then set ``gamma`` to 1 and its gradient to 0.
    /// 
    /// Reference:
    ///   .. [1] Ioffe, Sergey, and Christian Szegedy. &quot;Batch normalization: Accelerating \
    ///     deep network training by reducing internal covariate shift.&quot; *ICML 2015*
    ///   .. [2] Hang Zhang, Kristin Dana, Jianping Shi, Zhongyue Zhang, Xiaogang Wang, \
    ///     Ambrish Tyagi, and Amit Agrawal. &quot;Context Encoding for Semantic Segmentation.&quot; *CVPR 2018*
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\contrib\sync_batch_norm.cc:L97</summary>
    /// <param name="key">Hash key for synchronization, please set the same hash key for same layer, Block.prefix is typically used as in :class:`gluon.nn.contrib.SyncBatchNorm`.</param>
    /// <param name="data">Input data to batch normalization</param>
    /// <param name="gamma">gamma array</param>
    /// <param name="beta">beta array</param>
    /// <param name="movingMean">running mean of input</param>
    /// <param name="movingVar">running variance of input</param>
    /// <param name="eps">Epsilon to prevent div 0</param>
    /// <param name="momentum">Momentum for moving average</param>
    /// <param name="fixGamma">Fix gamma while training</param>
    /// <param name="useGlobalStats">Whether use global moving statistics instead of local batch-norm. This will force change batch-norm into a scale shift operator.</param>
    /// <param name="outputMeanVar">Output All,normal mean and var</param>
    /// <param name="ndev">The count of GPU devices</param>
    new(key : string,
        [<Optional>] ?data : Symbol,
        [<Optional>] ?gamma : Symbol,
        [<Optional>] ?beta : Symbol,
        [<Optional>] ?movingMean : Symbol,
        [<Optional>] ?movingVar : Symbol,
        [<Optional>] ?eps : float,
        [<Optional>] ?momentum : float,
        [<Optional>] ?fixGamma : bool,
        [<Optional>] ?useGlobalStats : bool,
        [<Optional>] ?outputMeanVar : bool,
        [<Optional>] ?ndev : int) = 
        let data = defaultArg data (new ImplicitVariable() :> Symbol)
        let gamma = defaultArg gamma (new ImplicitVariable() :> Symbol)
        let beta = defaultArg beta (new ImplicitVariable() :> Symbol)
        let movingMean = defaultArg movingMean (new ImplicitVariable() :> Symbol)
        let movingVar = defaultArg movingVar (new ImplicitVariable() :> Symbol)
        let operatorArguments = 
            [
                "data", Input data
                "gamma", Input gamma
                "beta", Input beta
                "moving_mean", Input movingMean
                "moving_var", Input movingVar
                "key", Parameter(Some(box key))
                "eps", eps |> Option.map box |> Parameter
                "momentum", momentum |> Option.map box |> Parameter
                "fix_gamma", fixGamma |> Option.map box |> Parameter
                "use_global_stats", useGlobalStats |> Option.map box |> Parameter
                "output_mean_var", outputMeanVar |> Option.map box |> Parameter
                "ndev", ndev |> Option.map box |> Parameter
            ]
        new ContribSyncBatchNorm(Arguments<Symbol>(operatorArguments))
    /// Default value for Eps
    /// Epsilon to prevent div 0
    static member EpsDefault : double = 0.00100000005
    /// Default value for Momentum
    /// Momentum for moving average
    static member MomentumDefault : double = 0.899999976
    /// Default value for FixGamma
    /// Fix gamma while training
    static member FixGammaDefault : bool = true
    /// Default value for UseGlobalStats
    /// Whether use global moving statistics instead of local batch-norm. This will force change batch-norm into a scale shift operator.
    static member UseGlobalStatsDefault : bool = false
    /// Default value for OutputMeanVar
    /// Output All,normal mean and var
    static member OutputMeanVarDefault : bool = false
    /// Default value for Ndev
    /// The count of GPU devices
    static member NdevDefault : int = 1
    /// Input data to batch normalization
    member __.Data = operatorArguments.GetInput "data"
    /// gamma array
    member __.Gamma = operatorArguments.GetInput "gamma"
    /// beta array
    member __.Beta = operatorArguments.GetInput "beta"
    /// running mean of input
    member __.MovingMean = operatorArguments.GetInput "moving_mean"
    /// running variance of input
    member __.MovingVar = operatorArguments.GetInput "moving_var"
    /// Hash key for synchronization, please set the same hash key for same layer, Block.prefix is typically used as in :class:`gluon.nn.contrib.SyncBatchNorm`.
    member __.Key : string = match operatorArguments.GetParameter "key" with Some(v) -> unbox v | None -> failwithf "Required parameter key is missing"
    /// Epsilon to prevent div 0
    member __.Eps = operatorArguments.GetParameter("eps", ContribSyncBatchNorm.EpsDefault)
    /// Momentum for moving average
    member __.Momentum = operatorArguments.GetParameter("momentum", ContribSyncBatchNorm.MomentumDefault)
    /// Fix gamma while training
    member __.FixGamma = operatorArguments.GetParameter("fix_gamma", ContribSyncBatchNorm.FixGammaDefault)
    /// Whether use global moving statistics instead of local batch-norm. This will force change batch-norm into a scale shift operator.
    member __.UseGlobalStats = operatorArguments.GetParameter("use_global_stats", ContribSyncBatchNorm.UseGlobalStatsDefault)
    /// Output All,normal mean and var
    member __.OutputMeanVar = operatorArguments.GetParameter("output_mean_var", ContribSyncBatchNorm.OutputMeanVarDefault)
    /// The count of GPU devices
    member __.Ndev = operatorArguments.GetParameter("ndev", ContribSyncBatchNorm.NdevDefault)
    /// <summary>Copy ContribSyncBatchNorm instance with updated inputs/parameters.</summary>
    /// <param name="data">Input data to batch normalization</param>
    /// <param name="gamma">gamma array</param>
    /// <param name="beta">beta array</param>
    /// <param name="movingMean">running mean of input</param>
    /// <param name="movingVar">running variance of input</param>
    /// <param name="key">Hash key for synchronization, please set the same hash key for same layer, Block.prefix is typically used as in :class:`gluon.nn.contrib.SyncBatchNorm`.</param>
    /// <param name="eps">Epsilon to prevent div 0</param>
    /// <param name="momentum">Momentum for moving average</param>
    /// <param name="fixGamma">Fix gamma while training</param>
    /// <param name="useGlobalStats">Whether use global moving statistics instead of local batch-norm. This will force change batch-norm into a scale shift operator.</param>
    /// <param name="outputMeanVar">Output All,normal mean and var</param>
    /// <param name="ndev">The count of GPU devices</param>
    member this.With([<Optional>] ?data : Symbol,
        [<Optional>] ?gamma : Symbol,
        [<Optional>] ?beta : Symbol,
        [<Optional>] ?movingMean : Symbol,
        [<Optional>] ?movingVar : Symbol,
        [<Optional>] ?key : string,
        [<Optional>] ?eps : float,
        [<Optional>] ?momentum : float,
        [<Optional>] ?fixGamma : bool,
        [<Optional>] ?useGlobalStats : bool,
        [<Optional>] ?outputMeanVar : bool,
        [<Optional>] ?ndev : int) = 
        let operatorArguments = 
            [
                data |> Option.map (fun x -> "data", Input x)
                gamma |> Option.map (fun x -> "gamma", Input x)
                beta |> Option.map (fun x -> "beta", Input x)
                movingMean |> Option.map (fun x -> "moving_mean", Input x)
                movingVar |> Option.map (fun x -> "moving_var", Input x)
                key |> Option.map (fun x -> "key", Parameter(Some (box x)))
                eps |> Option.map (fun x -> "eps", Parameter(Some (box x)))
                momentum |> Option.map (fun x -> "momentum", Parameter(Some (box x)))
                fixGamma |> Option.map (fun x -> "fix_gamma", Parameter(Some (box x)))
                useGlobalStats |> Option.map (fun x -> "use_global_stats", Parameter(Some (box x)))
                outputMeanVar |> Option.map (fun x -> "output_mean_var", Parameter(Some (box x)))
                ndev |> Option.map (fun x -> "ndev", Parameter(Some (box x)))
            ] |> List.choose id
        new ContribSyncBatchNorm(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type ContribDivSqrtDim private (operatorArguments) = 
    inherit SymbolOperator("_contrib_div_sqrt_dim", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new ContribDivSqrtDim(args)
    override this.WithArguments(args : Arguments<Symbol>) = new ContribDivSqrtDim(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <summary>Rescale the input by the square root of the channel dimension.
    /// 
    ///    out = data / sqrt(data.shape[-1])
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\contrib\transformer.cc:L38</summary>
    /// <param name="data">The input array.</param>
    new([<Optional>] ?data : Symbol) =
        let data = defaultArg data (new ImplicitVariable() :> Symbol)
        let operatorArguments = 
            [
                "data", Input data
            ]
        new ContribDivSqrtDim(Arguments<Symbol>(operatorArguments))
    /// The input array.
    member __.Data = operatorArguments.GetInput "data"
    /// <summary>Copy ContribDivSqrtDim instance with updated inputs/parameters.</summary>
    /// <param name="data">The input array.</param>
    member this.With([<Optional>] ?data : Symbol) =
        let operatorArguments = 
            [
                data |> Option.map (fun x -> "data", Input x)
            ] |> List.choose id
        new ContribDivSqrtDim(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type Foreach private (operatorArguments) = 
    inherit SymbolOperator("_foreach", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new Foreach(args)
    override this.WithArguments(args : Arguments<Symbol>) = new Foreach(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <summary>Run a for loop over an NDArray with user-defined computation
    /// 
    /// From:C:\Jenkins\workspace\mxnet\mxnet\src\operator\control_flow.cc:1090</summary>
    /// <param name="fn">Input graph.</param>
    /// <param name="data">The input arrays that include data arrays and states.</param>
    /// <param name="numOutputs">The number of outputs of the subgraph.</param>
    /// <param name="numOutData">The number of output data of the subgraph.</param>
    /// <param name="inStateLocs">The locations of loop states among the inputs.</param>
    /// <param name="inDataLocs">The locations of input data among the inputs.</param>
    /// <param name="remainLocs">The locations of remaining data among the inputs.</param>
    new(fn : Symbol,
        data : Symbol seq,
        numOutputs : int,
        numOutData : int,
        inStateLocs : int64 seq,
        inDataLocs : int64 seq,
        remainLocs : int64 seq) = 
        let operatorArguments = 
            [
                "fn", Input fn
                "data", VarArg("num_args", data |> Seq.toArray)
                "num_outputs", Parameter(Some(box numOutputs))
                "num_out_data", Parameter(Some(box numOutData))
                "in_state_locs", Parameter(Some(box inStateLocs))
                "in_data_locs", Parameter(Some(box inDataLocs))
                "remain_locs", Parameter(Some(box remainLocs))
            ]
        new Foreach(Arguments<Symbol>(operatorArguments))
    /// <summary>Run a for loop over an NDArray with user-defined computation
    /// 
    /// From:C:\Jenkins\workspace\mxnet\mxnet\src\operator\control_flow.cc:1090</summary>
    /// <param name="numOutputs">The number of outputs of the subgraph.</param>
    /// <param name="numOutData">The number of output data of the subgraph.</param>
    /// <param name="inStateLocs">The locations of loop states among the inputs.</param>
    /// <param name="inDataLocs">The locations of input data among the inputs.</param>
    /// <param name="remainLocs">The locations of remaining data among the inputs.</param>
    /// <param name="fn">Input graph.</param>
    /// <param name="data">The input arrays that include data arrays and states.</param>
    new(numOutputs : int,
        numOutData : int,
        inStateLocs : int64 seq,
        inDataLocs : int64 seq,
        remainLocs : int64 seq,
        [<Optional>] ?fn : Symbol,
        [<Optional>] ?data : Symbol seq) = 
        let fn = defaultArg fn (new ImplicitVariable() :> Symbol)
        let data = defaultArg (data |> Option.map Seq.toArray) Array.empty
        let operatorArguments = 
            [
                "fn", Input fn
                "data", VarArg("num_args", data)
                "num_outputs", Parameter(Some(box numOutputs))
                "num_out_data", Parameter(Some(box numOutData))
                "in_state_locs", Parameter(Some(box inStateLocs))
                "in_data_locs", Parameter(Some(box inDataLocs))
                "remain_locs", Parameter(Some(box remainLocs))
            ]
        new Foreach(Arguments<Symbol>(operatorArguments))
    /// Input graph.
    member __.Fn = operatorArguments.GetInput "fn"
    /// The input arrays that include data arrays and states.
    member __.Data = operatorArguments.GetVarArg "data"
    /// The number of outputs of the subgraph.
    member __.NumOutputs : int = match operatorArguments.GetParameter "num_outputs" with Some(v) -> unbox v | None -> failwithf "Required parameter num_outputs is missing"
    /// The number of output data of the subgraph.
    member __.NumOutData : int = match operatorArguments.GetParameter "num_out_data" with Some(v) -> unbox v | None -> failwithf "Required parameter num_out_data is missing"
    /// The locations of loop states among the inputs.
    member __.InStateLocs : int64 seq = match operatorArguments.GetParameter "in_state_locs" with Some(v) -> unbox v | None -> failwithf "Required parameter in_state_locs is missing"
    /// The locations of input data among the inputs.
    member __.InDataLocs : int64 seq = match operatorArguments.GetParameter "in_data_locs" with Some(v) -> unbox v | None -> failwithf "Required parameter in_data_locs is missing"
    /// The locations of remaining data among the inputs.
    member __.RemainLocs : int64 seq = match operatorArguments.GetParameter "remain_locs" with Some(v) -> unbox v | None -> failwithf "Required parameter remain_locs is missing"
    /// <summary>Copy Foreach instance with updated inputs/parameters.</summary>
    /// <param name="fn">Input graph.</param>
    /// <param name="data">The input arrays that include data arrays and states.</param>
    /// <param name="numOutputs">The number of outputs of the subgraph.</param>
    /// <param name="numOutData">The number of output data of the subgraph.</param>
    /// <param name="inStateLocs">The locations of loop states among the inputs.</param>
    /// <param name="inDataLocs">The locations of input data among the inputs.</param>
    /// <param name="remainLocs">The locations of remaining data among the inputs.</param>
    member this.With([<Optional>] ?fn : Symbol,
        [<Optional>] ?data : Symbol seq,
        [<Optional>] ?numOutputs : int,
        [<Optional>] ?numOutData : int,
        [<Optional>] ?inStateLocs : int64 seq,
        [<Optional>] ?inDataLocs : int64 seq,
        [<Optional>] ?remainLocs : int64 seq) = 
        let operatorArguments = 
            [
                fn |> Option.map (fun x -> "fn", Input x)
                data |> Option.map (fun x -> "data", VarArg("num_args", Seq.toArray x))
                numOutputs |> Option.map (fun x -> "num_outputs", Parameter(Some (box x)))
                numOutData |> Option.map (fun x -> "num_out_data", Parameter(Some (box x)))
                inStateLocs |> Option.map (fun x -> "in_state_locs", Parameter(Some (box x)))
                inDataLocs |> Option.map (fun x -> "in_data_locs", Parameter(Some (box x)))
                remainLocs |> Option.map (fun x -> "remain_locs", Parameter(Some (box x)))
            ] |> List.choose id
        new Foreach(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type WhileLoop private (operatorArguments) = 
    inherit SymbolOperator("_while_loop", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new WhileLoop(args)
    override this.WithArguments(args : Arguments<Symbol>) = new WhileLoop(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <summary>Run a while loop over with user-defined condition and computation
    /// 
    /// From:C:\Jenkins\workspace\mxnet\mxnet\src\operator\control_flow.cc:1151</summary>
    /// <param name="cond">Input graph for the loop condition.</param>
    /// <param name="func">Input graph for the loop body.</param>
    /// <param name="data">The input arrays that include data arrays and states.</param>
    /// <param name="numOutputs">The number of outputs of the subgraph.</param>
    /// <param name="numOutData">The number of outputs from the function body.</param>
    /// <param name="maxIterations">Maximum number of iterations.</param>
    /// <param name="condInputLocs">The locations of cond&#39;s inputs in the given inputs.</param>
    /// <param name="funcInputLocs">The locations of func&#39;s inputs in the given inputs.</param>
    /// <param name="funcVarLocs">The locations of loop_vars among func&#39;s inputs.</param>
    new(cond : Symbol,
        func : Symbol,
        data : Symbol seq,
        numOutputs : int,
        numOutData : int,
        maxIterations : int,
        condInputLocs : int64 seq,
        funcInputLocs : int64 seq,
        funcVarLocs : int64 seq) = 
        let operatorArguments = 
            [
                "cond", Input cond
                "func", Input func
                "data", VarArg("num_args", data |> Seq.toArray)
                "num_outputs", Parameter(Some(box numOutputs))
                "num_out_data", Parameter(Some(box numOutData))
                "max_iterations", Parameter(Some(box maxIterations))
                "cond_input_locs", Parameter(Some(box condInputLocs))
                "func_input_locs", Parameter(Some(box funcInputLocs))
                "func_var_locs", Parameter(Some(box funcVarLocs))
            ]
        new WhileLoop(Arguments<Symbol>(operatorArguments))
    /// <summary>Run a while loop over with user-defined condition and computation
    /// 
    /// From:C:\Jenkins\workspace\mxnet\mxnet\src\operator\control_flow.cc:1151</summary>
    /// <param name="numOutputs">The number of outputs of the subgraph.</param>
    /// <param name="numOutData">The number of outputs from the function body.</param>
    /// <param name="maxIterations">Maximum number of iterations.</param>
    /// <param name="condInputLocs">The locations of cond&#39;s inputs in the given inputs.</param>
    /// <param name="funcInputLocs">The locations of func&#39;s inputs in the given inputs.</param>
    /// <param name="funcVarLocs">The locations of loop_vars among func&#39;s inputs.</param>
    /// <param name="cond">Input graph for the loop condition.</param>
    /// <param name="func">Input graph for the loop body.</param>
    /// <param name="data">The input arrays that include data arrays and states.</param>
    new(numOutputs : int,
        numOutData : int,
        maxIterations : int,
        condInputLocs : int64 seq,
        funcInputLocs : int64 seq,
        funcVarLocs : int64 seq,
        [<Optional>] ?cond : Symbol,
        [<Optional>] ?func : Symbol,
        [<Optional>] ?data : Symbol seq) = 
        let cond = defaultArg cond (new ImplicitVariable() :> Symbol)
        let func = defaultArg func (new ImplicitVariable() :> Symbol)
        let data = defaultArg (data |> Option.map Seq.toArray) Array.empty
        let operatorArguments = 
            [
                "cond", Input cond
                "func", Input func
                "data", VarArg("num_args", data)
                "num_outputs", Parameter(Some(box numOutputs))
                "num_out_data", Parameter(Some(box numOutData))
                "max_iterations", Parameter(Some(box maxIterations))
                "cond_input_locs", Parameter(Some(box condInputLocs))
                "func_input_locs", Parameter(Some(box funcInputLocs))
                "func_var_locs", Parameter(Some(box funcVarLocs))
            ]
        new WhileLoop(Arguments<Symbol>(operatorArguments))
    /// Input graph for the loop condition.
    member __.Cond = operatorArguments.GetInput "cond"
    /// Input graph for the loop body.
    member __.Func = operatorArguments.GetInput "func"
    /// The input arrays that include data arrays and states.
    member __.Data = operatorArguments.GetVarArg "data"
    /// The number of outputs of the subgraph.
    member __.NumOutputs : int = match operatorArguments.GetParameter "num_outputs" with Some(v) -> unbox v | None -> failwithf "Required parameter num_outputs is missing"
    /// The number of outputs from the function body.
    member __.NumOutData : int = match operatorArguments.GetParameter "num_out_data" with Some(v) -> unbox v | None -> failwithf "Required parameter num_out_data is missing"
    /// Maximum number of iterations.
    member __.MaxIterations : int = match operatorArguments.GetParameter "max_iterations" with Some(v) -> unbox v | None -> failwithf "Required parameter max_iterations is missing"
    /// The locations of cond&#39;s inputs in the given inputs.
    member __.CondInputLocs : int64 seq = match operatorArguments.GetParameter "cond_input_locs" with Some(v) -> unbox v | None -> failwithf "Required parameter cond_input_locs is missing"
    /// The locations of func&#39;s inputs in the given inputs.
    member __.FuncInputLocs : int64 seq = match operatorArguments.GetParameter "func_input_locs" with Some(v) -> unbox v | None -> failwithf "Required parameter func_input_locs is missing"
    /// The locations of loop_vars among func&#39;s inputs.
    member __.FuncVarLocs : int64 seq = match operatorArguments.GetParameter "func_var_locs" with Some(v) -> unbox v | None -> failwithf "Required parameter func_var_locs is missing"
    /// <summary>Copy WhileLoop instance with updated inputs/parameters.</summary>
    /// <param name="cond">Input graph for the loop condition.</param>
    /// <param name="func">Input graph for the loop body.</param>
    /// <param name="data">The input arrays that include data arrays and states.</param>
    /// <param name="numOutputs">The number of outputs of the subgraph.</param>
    /// <param name="numOutData">The number of outputs from the function body.</param>
    /// <param name="maxIterations">Maximum number of iterations.</param>
    /// <param name="condInputLocs">The locations of cond&#39;s inputs in the given inputs.</param>
    /// <param name="funcInputLocs">The locations of func&#39;s inputs in the given inputs.</param>
    /// <param name="funcVarLocs">The locations of loop_vars among func&#39;s inputs.</param>
    member this.With([<Optional>] ?cond : Symbol,
        [<Optional>] ?func : Symbol,
        [<Optional>] ?data : Symbol seq,
        [<Optional>] ?numOutputs : int,
        [<Optional>] ?numOutData : int,
        [<Optional>] ?maxIterations : int,
        [<Optional>] ?condInputLocs : int64 seq,
        [<Optional>] ?funcInputLocs : int64 seq,
        [<Optional>] ?funcVarLocs : int64 seq) = 
        let operatorArguments = 
            [
                cond |> Option.map (fun x -> "cond", Input x)
                func |> Option.map (fun x -> "func", Input x)
                data |> Option.map (fun x -> "data", VarArg("num_args", Seq.toArray x))
                numOutputs |> Option.map (fun x -> "num_outputs", Parameter(Some (box x)))
                numOutData |> Option.map (fun x -> "num_out_data", Parameter(Some (box x)))
                maxIterations |> Option.map (fun x -> "max_iterations", Parameter(Some (box x)))
                condInputLocs |> Option.map (fun x -> "cond_input_locs", Parameter(Some (box x)))
                funcInputLocs |> Option.map (fun x -> "func_input_locs", Parameter(Some (box x)))
                funcVarLocs |> Option.map (fun x -> "func_var_locs", Parameter(Some (box x)))
            ] |> List.choose id
        new WhileLoop(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type Cond private (operatorArguments) = 
    inherit SymbolOperator("_cond", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new Cond(args)
    override this.WithArguments(args : Arguments<Symbol>) = new Cond(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <summary>Run a if-then-else using user-defined condition and computation
    /// 
    /// From:C:\Jenkins\workspace\mxnet\mxnet\src\operator\control_flow.cc:1212</summary>
    /// <param name="cond">Input graph for the condition.</param>
    /// <param name="thenBranch">Input graph for the then branch.</param>
    /// <param name="elseBranch">Input graph for the else branch.</param>
    /// <param name="data">The input arrays that include data arrays and states.</param>
    /// <param name="numOutputs">The number of outputs of the subgraph.</param>
    /// <param name="condInputLocs">The locations of cond&#39;s inputs in the given inputs.</param>
    /// <param name="thenInputLocs">The locations of then&#39;s inputs in the given inputs.</param>
    /// <param name="elseInputLocs">The locations of else&#39;s inputs in the given inputs.</param>
    new(cond : Symbol,
        thenBranch : Symbol,
        elseBranch : Symbol,
        data : Symbol seq,
        numOutputs : int,
        condInputLocs : int64 seq,
        thenInputLocs : int64 seq,
        elseInputLocs : int64 seq) = 
        let operatorArguments = 
            [
                "cond", Input cond
                "then_branch", Input thenBranch
                "else_branch", Input elseBranch
                "data", VarArg("num_args", data |> Seq.toArray)
                "num_outputs", Parameter(Some(box numOutputs))
                "cond_input_locs", Parameter(Some(box condInputLocs))
                "then_input_locs", Parameter(Some(box thenInputLocs))
                "else_input_locs", Parameter(Some(box elseInputLocs))
            ]
        new Cond(Arguments<Symbol>(operatorArguments))
    /// <summary>Run a if-then-else using user-defined condition and computation
    /// 
    /// From:C:\Jenkins\workspace\mxnet\mxnet\src\operator\control_flow.cc:1212</summary>
    /// <param name="numOutputs">The number of outputs of the subgraph.</param>
    /// <param name="condInputLocs">The locations of cond&#39;s inputs in the given inputs.</param>
    /// <param name="thenInputLocs">The locations of then&#39;s inputs in the given inputs.</param>
    /// <param name="elseInputLocs">The locations of else&#39;s inputs in the given inputs.</param>
    /// <param name="cond">Input graph for the condition.</param>
    /// <param name="thenBranch">Input graph for the then branch.</param>
    /// <param name="elseBranch">Input graph for the else branch.</param>
    /// <param name="data">The input arrays that include data arrays and states.</param>
    new(numOutputs : int,
        condInputLocs : int64 seq,
        thenInputLocs : int64 seq,
        elseInputLocs : int64 seq,
        [<Optional>] ?cond : Symbol,
        [<Optional>] ?thenBranch : Symbol,
        [<Optional>] ?elseBranch : Symbol,
        [<Optional>] ?data : Symbol seq) = 
        let cond = defaultArg cond (new ImplicitVariable() :> Symbol)
        let thenBranch = defaultArg thenBranch (new ImplicitVariable() :> Symbol)
        let elseBranch = defaultArg elseBranch (new ImplicitVariable() :> Symbol)
        let data = defaultArg (data |> Option.map Seq.toArray) Array.empty
        let operatorArguments = 
            [
                "cond", Input cond
                "then_branch", Input thenBranch
                "else_branch", Input elseBranch
                "data", VarArg("num_args", data)
                "num_outputs", Parameter(Some(box numOutputs))
                "cond_input_locs", Parameter(Some(box condInputLocs))
                "then_input_locs", Parameter(Some(box thenInputLocs))
                "else_input_locs", Parameter(Some(box elseInputLocs))
            ]
        new Cond(Arguments<Symbol>(operatorArguments))
    /// Input graph for the condition.
    member __.Cond = operatorArguments.GetInput "cond"
    /// Input graph for the then branch.
    member __.ThenBranch = operatorArguments.GetInput "then_branch"
    /// Input graph for the else branch.
    member __.ElseBranch = operatorArguments.GetInput "else_branch"
    /// The input arrays that include data arrays and states.
    member __.Data = operatorArguments.GetVarArg "data"
    /// The number of outputs of the subgraph.
    member __.NumOutputs : int = match operatorArguments.GetParameter "num_outputs" with Some(v) -> unbox v | None -> failwithf "Required parameter num_outputs is missing"
    /// The locations of cond&#39;s inputs in the given inputs.
    member __.CondInputLocs : int64 seq = match operatorArguments.GetParameter "cond_input_locs" with Some(v) -> unbox v | None -> failwithf "Required parameter cond_input_locs is missing"
    /// The locations of then&#39;s inputs in the given inputs.
    member __.ThenInputLocs : int64 seq = match operatorArguments.GetParameter "then_input_locs" with Some(v) -> unbox v | None -> failwithf "Required parameter then_input_locs is missing"
    /// The locations of else&#39;s inputs in the given inputs.
    member __.ElseInputLocs : int64 seq = match operatorArguments.GetParameter "else_input_locs" with Some(v) -> unbox v | None -> failwithf "Required parameter else_input_locs is missing"
    /// <summary>Copy Cond instance with updated inputs/parameters.</summary>
    /// <param name="cond">Input graph for the condition.</param>
    /// <param name="thenBranch">Input graph for the then branch.</param>
    /// <param name="elseBranch">Input graph for the else branch.</param>
    /// <param name="data">The input arrays that include data arrays and states.</param>
    /// <param name="numOutputs">The number of outputs of the subgraph.</param>
    /// <param name="condInputLocs">The locations of cond&#39;s inputs in the given inputs.</param>
    /// <param name="thenInputLocs">The locations of then&#39;s inputs in the given inputs.</param>
    /// <param name="elseInputLocs">The locations of else&#39;s inputs in the given inputs.</param>
    member this.With([<Optional>] ?cond : Symbol,
        [<Optional>] ?thenBranch : Symbol,
        [<Optional>] ?elseBranch : Symbol,
        [<Optional>] ?data : Symbol seq,
        [<Optional>] ?numOutputs : int,
        [<Optional>] ?condInputLocs : int64 seq,
        [<Optional>] ?thenInputLocs : int64 seq,
        [<Optional>] ?elseInputLocs : int64 seq) = 
        let operatorArguments = 
            [
                cond |> Option.map (fun x -> "cond", Input x)
                thenBranch |> Option.map (fun x -> "then_branch", Input x)
                elseBranch |> Option.map (fun x -> "else_branch", Input x)
                data |> Option.map (fun x -> "data", VarArg("num_args", Seq.toArray x))
                numOutputs |> Option.map (fun x -> "num_outputs", Parameter(Some (box x)))
                condInputLocs |> Option.map (fun x -> "cond_input_locs", Parameter(Some (box x)))
                thenInputLocs |> Option.map (fun x -> "then_input_locs", Parameter(Some (box x)))
                elseInputLocs |> Option.map (fun x -> "else_input_locs", Parameter(Some (box x)))
            ] |> List.choose id
        new Cond(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type Custom private (operatorArguments) = 
    inherit SymbolOperator("Custom", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new Custom(args)
    override this.WithArguments(args : Arguments<Symbol>) = new Custom(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <summary>Apply a custom operator implemented in a frontend language (like Python).
    /// 
    /// Custom operators should override required methods like `forward` and `backward`.
    /// The custom operator must be registered before it can be used.
    /// Please check the tutorial here: https://mxnet.incubator.apache.org/api/faq/new_op
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\custom\custom.cc:L546</summary>
    /// <param name="data">Input data for the custom operator.</param>
    /// <param name="opType">Name of the custom operator. This is the name that is passed to `mx.operator.register` to register the operator.</param>
    new(data : Symbol seq,
        opType : string) = 
        let operatorArguments = 
            [
                "data", VarArg("", data |> Seq.toArray)
                "op_type", Parameter(Some(box opType))
            ]
        new Custom(Arguments<Symbol>(operatorArguments))
    /// <summary>Apply a custom operator implemented in a frontend language (like Python).
    /// 
    /// Custom operators should override required methods like `forward` and `backward`.
    /// The custom operator must be registered before it can be used.
    /// Please check the tutorial here: https://mxnet.incubator.apache.org/api/faq/new_op
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\custom\custom.cc:L546</summary>
    /// <param name="opType">Name of the custom operator. This is the name that is passed to `mx.operator.register` to register the operator.</param>
    /// <param name="data">Input data for the custom operator.</param>
    new(opType : string,
        [<Optional>] ?data : Symbol seq) = 
        let data = defaultArg (data |> Option.map Seq.toArray) Array.empty
        let operatorArguments = 
            [
                "data", VarArg("", data)
                "op_type", Parameter(Some(box opType))
            ]
        new Custom(Arguments<Symbol>(operatorArguments))
    /// <summary>Apply a custom operator implemented in a frontend language (like Python).
    /// 
    /// Custom operators should override required methods like `forward` and `backward`.
    /// The custom operator must be registered before it can be used.
    /// Please check the tutorial here: https://mxnet.incubator.apache.org/api/faq/new_op
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\custom\custom.cc:L546</summary>
    /// <param name="opType">Name of the custom operator. This is the name that is passed to `mx.operator.register` to register the operator.</param>
    /// <param name="data">Input data for the custom operator.</param>
    new(opType : string,
        [<ParamArray>] data : Symbol[]) = 
        let operatorArguments = 
            [
                "data", VarArg("", data)
                "op_type", Parameter(Some(box opType))
            ]
        new Custom(Arguments<Symbol>(operatorArguments))
    /// Input data for the custom operator.
    member __.Data = operatorArguments.GetVarArg "data"
    /// Name of the custom operator. This is the name that is passed to `mx.operator.register` to register the operator.
    member __.OpType : string = match operatorArguments.GetParameter "op_type" with Some(v) -> unbox v | None -> failwithf "Required parameter op_type is missing"
    /// <summary>Copy Custom instance with updated inputs/parameters.</summary>
    /// <param name="data">Input data for the custom operator.</param>
    /// <param name="opType">Name of the custom operator. This is the name that is passed to `mx.operator.register` to register the operator.</param>
    member this.With([<Optional>] ?data : Symbol seq,
        [<Optional>] ?opType : string) = 
        let operatorArguments = 
            [
                data |> Option.map (fun x -> "data", VarArg("", Seq.toArray x))
                opType |> Option.map (fun x -> "op_type", Parameter(Some (box x)))
            ] |> List.choose id
        new Custom(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type IdentityAttachKLSparseReg private (operatorArguments) = 
    inherit SymbolOperator("IdentityAttachKLSparseReg", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new IdentityAttachKLSparseReg(args)
    override this.WithArguments(args : Arguments<Symbol>) = new IdentityAttachKLSparseReg(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <summary>Apply a sparse regularization to the output a sigmoid activation function.</summary>
    /// <param name="data">Input data.</param>
    /// <param name="sparsenessTarget">The sparseness target</param>
    /// <param name="penalty">The tradeoff parameter for the sparseness penalty</param>
    /// <param name="momentum">The momentum for running average</param>
    new([<Optional>] ?data : Symbol,
        [<Optional>] ?sparsenessTarget : float,
        [<Optional>] ?penalty : float,
        [<Optional>] ?momentum : float) = 
        let data = defaultArg data (new ImplicitVariable() :> Symbol)
        let operatorArguments = 
            [
                "data", Input data
                "sparseness_target", sparsenessTarget |> Option.map box |> Parameter
                "penalty", penalty |> Option.map box |> Parameter
                "momentum", momentum |> Option.map box |> Parameter
            ]
        new IdentityAttachKLSparseReg(Arguments<Symbol>(operatorArguments))
    /// Default value for SparsenessTarget
    /// The sparseness target
    static member SparsenessTargetDefault : double = 0.100000001
    /// Default value for Penalty
    /// The tradeoff parameter for the sparseness penalty
    static member PenaltyDefault : double = 0.00100000005
    /// Default value for Momentum
    /// The momentum for running average
    static member MomentumDefault : double = 0.899999976
    /// Input data.
    member __.Data = operatorArguments.GetInput "data"
    /// The sparseness target
    member __.SparsenessTarget = operatorArguments.GetParameter("sparseness_target", IdentityAttachKLSparseReg.SparsenessTargetDefault)
    /// The tradeoff parameter for the sparseness penalty
    member __.Penalty = operatorArguments.GetParameter("penalty", IdentityAttachKLSparseReg.PenaltyDefault)
    /// The momentum for running average
    member __.Momentum = operatorArguments.GetParameter("momentum", IdentityAttachKLSparseReg.MomentumDefault)
    /// <summary>Copy IdentityAttachKLSparseReg instance with updated inputs/parameters.</summary>
    /// <param name="data">Input data.</param>
    /// <param name="sparsenessTarget">The sparseness target</param>
    /// <param name="penalty">The tradeoff parameter for the sparseness penalty</param>
    /// <param name="momentum">The momentum for running average</param>
    member this.With([<Optional>] ?data : Symbol,
        [<Optional>] ?sparsenessTarget : float,
        [<Optional>] ?penalty : float,
        [<Optional>] ?momentum : float) = 
        let operatorArguments = 
            [
                data |> Option.map (fun x -> "data", Input x)
                sparsenessTarget |> Option.map (fun x -> "sparseness_target", Parameter(Some (box x)))
                penalty |> Option.map (fun x -> "penalty", Parameter(Some (box x)))
                momentum |> Option.map (fun x -> "momentum", Parameter(Some (box x)))
            ] |> List.choose id
        new IdentityAttachKLSparseReg(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type ImageCrop private (operatorArguments) = 
    inherit SymbolOperator("_image_crop", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new ImageCrop(args)
    override this.WithArguments(args : Arguments<Symbol>) = new ImageCrop(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <summary>Crop an image NDArray of shape (H x W x C) or (N x H x W x C) 
    /// to the given size.
    /// Example:
    ///     .. code-block:: python
    ///         image = mx.nd.random.uniform(0, 255, (4, 2, 3)).astype(dtype=np.uint8)
    ///         mx.nd.image.crop(image, 1, 1, 2, 2)
    ///             [[[144  34   4]
    ///               [ 82 157  38]]
    /// 
    ///              [[156 111 230]
    ///               [177  25  15]]]
    ///             &lt;NDArray 2x2x3 @cpu(0)&gt;
    ///         image = mx.nd.random.uniform(0, 255, (2, 4, 2, 3)).astype(dtype=np.uint8)
    ///         mx.nd.image.crop(image, 1, 1, 2, 2)            
    ///             [[[[ 35 198  50]
    ///                [242  94 168]]
    /// 
    ///               [[223 119 129]
    ///                [249  14 154]]]
    /// 
    /// 
    ///               [[[137 215 106]
    ///                 [ 79 174 133]]
    /// 
    ///                [[116 142 109]
    ///                 [ 35 239  50]]]]
    ///             &lt;NDArray 2x2x2x3 @cpu(0)&gt;
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\image\crop.cc:L66</summary>
    /// <param name="data">The input.</param>
    /// <param name="x">Left boundary of the cropping area.</param>
    /// <param name="y">Top boundary of the cropping area.</param>
    /// <param name="width">Width of the cropping area.</param>
    /// <param name="height">Height of the cropping area.</param>
    new(data : Symbol,
        x : int,
        y : int,
        width : int,
        height : int) = 
        let operatorArguments = 
            [
                "data", Input data
                "x", Parameter(Some(box x))
                "y", Parameter(Some(box y))
                "width", Parameter(Some(box width))
                "height", Parameter(Some(box height))
            ]
        new ImageCrop(Arguments<Symbol>(operatorArguments))
    /// <summary>Crop an image NDArray of shape (H x W x C) or (N x H x W x C) 
    /// to the given size.
    /// Example:
    ///     .. code-block:: python
    ///         image = mx.nd.random.uniform(0, 255, (4, 2, 3)).astype(dtype=np.uint8)
    ///         mx.nd.image.crop(image, 1, 1, 2, 2)
    ///             [[[144  34   4]
    ///               [ 82 157  38]]
    /// 
    ///              [[156 111 230]
    ///               [177  25  15]]]
    ///             &lt;NDArray 2x2x3 @cpu(0)&gt;
    ///         image = mx.nd.random.uniform(0, 255, (2, 4, 2, 3)).astype(dtype=np.uint8)
    ///         mx.nd.image.crop(image, 1, 1, 2, 2)            
    ///             [[[[ 35 198  50]
    ///                [242  94 168]]
    /// 
    ///               [[223 119 129]
    ///                [249  14 154]]]
    /// 
    /// 
    ///               [[[137 215 106]
    ///                 [ 79 174 133]]
    /// 
    ///                [[116 142 109]
    ///                 [ 35 239  50]]]]
    ///             &lt;NDArray 2x2x2x3 @cpu(0)&gt;
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\image\crop.cc:L66</summary>
    /// <param name="x">Left boundary of the cropping area.</param>
    /// <param name="y">Top boundary of the cropping area.</param>
    /// <param name="width">Width of the cropping area.</param>
    /// <param name="height">Height of the cropping area.</param>
    /// <param name="data">The input.</param>
    new(x : int,
        y : int,
        width : int,
        height : int,
        [<Optional>] ?data : Symbol) = 
        let data = defaultArg data (new ImplicitVariable() :> Symbol)
        let operatorArguments = 
            [
                "data", Input data
                "x", Parameter(Some(box x))
                "y", Parameter(Some(box y))
                "width", Parameter(Some(box width))
                "height", Parameter(Some(box height))
            ]
        new ImageCrop(Arguments<Symbol>(operatorArguments))
    /// The input.
    member __.Data = operatorArguments.GetInput "data"
    /// Left boundary of the cropping area.
    member __.X : int = match operatorArguments.GetParameter "x" with Some(v) -> unbox v | None -> failwithf "Required parameter x is missing"
    /// Top boundary of the cropping area.
    member __.Y : int = match operatorArguments.GetParameter "y" with Some(v) -> unbox v | None -> failwithf "Required parameter y is missing"
    /// Width of the cropping area.
    member __.Width : int = match operatorArguments.GetParameter "width" with Some(v) -> unbox v | None -> failwithf "Required parameter width is missing"
    /// Height of the cropping area.
    member __.Height : int = match operatorArguments.GetParameter "height" with Some(v) -> unbox v | None -> failwithf "Required parameter height is missing"
    /// <summary>Copy ImageCrop instance with updated inputs/parameters.</summary>
    /// <param name="data">The input.</param>
    /// <param name="x">Left boundary of the cropping area.</param>
    /// <param name="y">Top boundary of the cropping area.</param>
    /// <param name="width">Width of the cropping area.</param>
    /// <param name="height">Height of the cropping area.</param>
    member this.With([<Optional>] ?data : Symbol,
        [<Optional>] ?x : int,
        [<Optional>] ?y : int,
        [<Optional>] ?width : int,
        [<Optional>] ?height : int) = 
        let operatorArguments = 
            [
                data |> Option.map (fun x -> "data", Input x)
                x |> Option.map (fun x -> "x", Parameter(Some (box x)))
                y |> Option.map (fun x -> "y", Parameter(Some (box x)))
                width |> Option.map (fun x -> "width", Parameter(Some (box x)))
                height |> Option.map (fun x -> "height", Parameter(Some (box x)))
            ] |> List.choose id
        new ImageCrop(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type ImageToTensor private (operatorArguments) = 
    inherit SymbolOperator("_image_to_tensor", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new ImageToTensor(args)
    override this.WithArguments(args : Arguments<Symbol>) = new ImageToTensor(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <summary>Converts an image NDArray of shape (H x W x C) or (N x H x W x C) 
    /// with values in the range [0, 255] to a tensor NDArray of shape (C x H x W) or (N x C x H x W)
    /// with values in the range [0, 1]
    /// 
    /// Example:
    ///     .. code-block:: python
    ///         image = mx.nd.random.uniform(0, 255, (4, 2, 3)).astype(dtype=np.uint8)
    ///         to_tensor(image)
    ///             [[[ 0.85490197  0.72156864]
    ///               [ 0.09019608  0.74117649]
    ///               [ 0.61960787  0.92941177]
    ///               [ 0.96470588  0.1882353 ]]
    ///              [[ 0.6156863   0.73725492]
    ///               [ 0.46666667  0.98039216]
    ///               [ 0.44705883  0.45490196]
    ///               [ 0.01960784  0.8509804 ]]
    ///              [[ 0.39607844  0.03137255]
    ///               [ 0.72156864  0.52941179]
    ///               [ 0.16470589  0.7647059 ]
    ///               [ 0.05490196  0.70588237]]]
    ///              &lt;NDArray 3x4x2 @cpu(0)&gt;
    /// 
    ///         image = mx.nd.random.uniform(0, 255, (2, 4, 2, 3)).astype(dtype=np.uint8)
    ///         to_tensor(image)
    ///             [[[[0.11764706 0.5803922 ]
    ///                [0.9411765  0.10588235]
    ///                [0.2627451  0.73333335]
    ///                [0.5647059  0.32156864]]
    ///               [[0.7176471  0.14117648]
    ///                [0.75686276 0.4117647 ]
    ///                [0.18431373 0.45490196]
    ///                [0.13333334 0.6156863 ]]
    ///               [[0.6392157  0.5372549 ]
    ///                [0.52156866 0.47058824]
    ///                [0.77254903 0.21568628]
    ///                [0.01568628 0.14901961]]]
    ///              [[[0.6117647  0.38431373]
    ///                [0.6784314  0.6117647 ]
    ///                [0.69411767 0.96862745]
    ///                [0.67058825 0.35686275]]
    ///               [[0.21960784 0.9411765 ]
    ///                [0.44705883 0.43529412]
    ///                [0.09803922 0.6666667 ]
    ///                [0.16862746 0.1254902 ]]
    ///               [[0.6156863  0.9019608 ]
    ///                [0.35686275 0.9019608 ]
    ///                [0.05882353 0.6509804 ]
    ///                [0.20784314 0.7490196 ]]]]
    ///             &lt;NDArray 2x3x4x2 @cpu(0)&gt;
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\image\image_random.cc:L92</summary>
    /// <param name="data">Input ndarray</param>
    new([<Optional>] ?data : Symbol) =
        let data = defaultArg data (new ImplicitVariable() :> Symbol)
        let operatorArguments = 
            [
                "data", Input data
            ]
        new ImageToTensor(Arguments<Symbol>(operatorArguments))
    /// Input ndarray
    member __.Data = operatorArguments.GetInput "data"
    /// <summary>Copy ImageToTensor instance with updated inputs/parameters.</summary>
    /// <param name="data">Input ndarray</param>
    member this.With([<Optional>] ?data : Symbol) =
        let operatorArguments = 
            [
                data |> Option.map (fun x -> "data", Input x)
            ] |> List.choose id
        new ImageToTensor(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type ImageNormalize private (operatorArguments) = 
    inherit SymbolOperator("_image_normalize", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new ImageNormalize(args)
    override this.WithArguments(args : Arguments<Symbol>) = new ImageNormalize(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <summary>Normalize an tensor of shape (C x H x W) or (N x C x H x W) with mean and
    ///     standard deviation.
    /// 
    ///     Given mean `(m1, ..., mn)` and std `(s\ :sub:`1`\ , ..., s\ :sub:`n`)` for `n` channels,
    ///     this transform normalizes each channel of the input tensor with:
    /// 
    /// .. math::
    /// 
    ///         output[i] = (input[i] - m\ :sub:`i`\ ) / s\ :sub:`i`
    /// 
    ///     If mean or std is scalar, the same value will be applied to all channels.
    /// 
    ///     Default value for mean is 0.0 and stand deviation is 1.0.
    /// 
    /// Example:
    /// 
    ///     .. code-block:: python
    ///         image = mx.nd.random.uniform(0, 1, (3, 4, 2))
    ///         normalize(image, mean=(0, 1, 2), std=(3, 2, 1))
    ///             [[[ 0.18293785  0.19761486]
    ///               [ 0.23839645  0.28142193]
    ///               [ 0.20092112  0.28598186]
    ///               [ 0.18162774  0.28241724]]
    ///              [[-0.2881726  -0.18821815]
    ///               [-0.17705294 -0.30780914]
    ///               [-0.2812064  -0.3512327 ]
    ///               [-0.05411351 -0.4716435 ]]
    ///              [[-1.0363373  -1.7273437 ]
    ///               [-1.6165586  -1.5223348 ]
    ///               [-1.208275   -1.1878313 ]
    ///               [-1.4711051  -1.5200229 ]]]
    ///             &lt;NDArray 3x4x2 @cpu(0)&gt;
    /// 
    ///         image = mx.nd.random.uniform(0, 1, (2, 3, 4, 2))
    ///         normalize(image, mean=(0, 1, 2), std=(3, 2, 1))
    ///             [[[[ 0.18934818  0.13092826]
    ///                [ 0.3085322   0.27869293]
    ///                [ 0.02367868  0.11246539]
    ///                [ 0.0290431   0.2160573 ]]
    ///               [[-0.4898908  -0.31587923]
    ///                [-0.08369008 -0.02142242]
    ///                [-0.11092162 -0.42982462]
    ///                [-0.06499392 -0.06495637]]
    ///               [[-1.0213816  -1.526392  ]
    ///                [-1.2008414  -1.1990893 ]
    ///                [-1.5385206  -1.4795225 ]
    ///                [-1.2194707  -1.3211205 ]]]
    ///              [[[ 0.03942481  0.24021089]
    ///                [ 0.21330701  0.1940066 ]
    ///                [ 0.04778443  0.17912441]
    ///                [ 0.31488964  0.25287187]]
    ///               [[-0.23907584 -0.4470462 ]
    ///                [-0.29266903 -0.2631998 ]
    ///                [-0.3677222  -0.40683383]
    ///                [-0.11288315 -0.13154092]]
    ///               [[-1.5438497  -1.7834496 ]
    ///                [-1.431566   -1.8647819 ]
    ///                [-1.9812102  -1.675859  ]
    ///                [-1.3823645  -1.8503251 ]]]]
    ///             &lt;NDArray 2x3x4x2 @cpu(0)&gt;
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\image\image_random.cc:L167</summary>
    /// <param name="data">Input ndarray</param>
    /// <param name="mean">Sequence of means for each channel. Default value is 0.</param>
    /// <param name="std">Sequence of standard deviations for each channel. Default value is 1.</param>
    new([<Optional>] ?data : Symbol,
        [<Optional>] ?mean : double seq,
        [<Optional>] ?std : double seq) = 
        let data = defaultArg data (new ImplicitVariable() :> Symbol)
        let operatorArguments = 
            [
                "data", Input data
                "mean", mean |> Option.map box |> Parameter
                "std", std |> Option.map box |> Parameter
            ]
        new ImageNormalize(Arguments<Symbol>(operatorArguments))
    /// Default value for Mean
    /// Sequence of means for each channel. Default value is 0.
    static member MeanDefault : double [] = [|0.0; 0.0; 0.0; 0.0|]
    /// Default value for Std
    /// Sequence of standard deviations for each channel. Default value is 1.
    static member StdDefault : double [] = [|1.0; 1.0; 1.0; 1.0|]
    /// Input ndarray
    member __.Data = operatorArguments.GetInput "data"
    /// Sequence of means for each channel. Default value is 0.
    member __.Mean = operatorArguments.GetParameter("mean", ImageNormalize.MeanDefault)
    /// Sequence of standard deviations for each channel. Default value is 1.
    member __.Std = operatorArguments.GetParameter("std", ImageNormalize.StdDefault)
    /// <summary>Copy ImageNormalize instance with updated inputs/parameters.</summary>
    /// <param name="data">Input ndarray</param>
    /// <param name="mean">Sequence of means for each channel. Default value is 0.</param>
    /// <param name="std">Sequence of standard deviations for each channel. Default value is 1.</param>
    member this.With([<Optional>] ?data : Symbol,
        [<Optional>] ?mean : double seq,
        [<Optional>] ?std : double seq) = 
        let operatorArguments = 
            [
                data |> Option.map (fun x -> "data", Input x)
                mean |> Option.map (fun x -> "mean", Parameter(Some (box x)))
                std |> Option.map (fun x -> "std", Parameter(Some (box x)))
            ] |> List.choose id
        new ImageNormalize(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type ImageFlipLeftRight private (operatorArguments) = 
    inherit SymbolOperator("_image_flip_left_right", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new ImageFlipLeftRight(args)
    override this.WithArguments(args : Arguments<Symbol>) = new ImageFlipLeftRight(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <summary>
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\image\image_random.cc:L195</summary>
    /// <param name="data">The input.</param>
    new([<Optional>] ?data : Symbol) =
        let data = defaultArg data (new ImplicitVariable() :> Symbol)
        let operatorArguments = 
            [
                "data", Input data
            ]
        new ImageFlipLeftRight(Arguments<Symbol>(operatorArguments))
    /// The input.
    member __.Data = operatorArguments.GetInput "data"
    /// <summary>Copy ImageFlipLeftRight instance with updated inputs/parameters.</summary>
    /// <param name="data">The input.</param>
    member this.With([<Optional>] ?data : Symbol) =
        let operatorArguments = 
            [
                data |> Option.map (fun x -> "data", Input x)
            ] |> List.choose id
        new ImageFlipLeftRight(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type ImageRandomFlipLeftRight private (operatorArguments) = 
    inherit SymbolOperator("_image_random_flip_left_right", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new ImageRandomFlipLeftRight(args)
    override this.WithArguments(args : Arguments<Symbol>) = new ImageRandomFlipLeftRight(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <summary>
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\image\image_random.cc:L200</summary>
    /// <param name="data">The input.</param>
    new([<Optional>] ?data : Symbol) =
        let data = defaultArg data (new ImplicitVariable() :> Symbol)
        let operatorArguments = 
            [
                "data", Input data
            ]
        new ImageRandomFlipLeftRight(Arguments<Symbol>(operatorArguments))
    /// The input.
    member __.Data = operatorArguments.GetInput "data"
    /// <summary>Copy ImageRandomFlipLeftRight instance with updated inputs/parameters.</summary>
    /// <param name="data">The input.</param>
    member this.With([<Optional>] ?data : Symbol) =
        let operatorArguments = 
            [
                data |> Option.map (fun x -> "data", Input x)
            ] |> List.choose id
        new ImageRandomFlipLeftRight(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type ImageFlipTopBottom private (operatorArguments) = 
    inherit SymbolOperator("_image_flip_top_bottom", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new ImageFlipTopBottom(args)
    override this.WithArguments(args : Arguments<Symbol>) = new ImageFlipTopBottom(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <summary>
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\image\image_random.cc:L205</summary>
    /// <param name="data">The input.</param>
    new([<Optional>] ?data : Symbol) =
        let data = defaultArg data (new ImplicitVariable() :> Symbol)
        let operatorArguments = 
            [
                "data", Input data
            ]
        new ImageFlipTopBottom(Arguments<Symbol>(operatorArguments))
    /// The input.
    member __.Data = operatorArguments.GetInput "data"
    /// <summary>Copy ImageFlipTopBottom instance with updated inputs/parameters.</summary>
    /// <param name="data">The input.</param>
    member this.With([<Optional>] ?data : Symbol) =
        let operatorArguments = 
            [
                data |> Option.map (fun x -> "data", Input x)
            ] |> List.choose id
        new ImageFlipTopBottom(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type ImageRandomFlipTopBottom private (operatorArguments) = 
    inherit SymbolOperator("_image_random_flip_top_bottom", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new ImageRandomFlipTopBottom(args)
    override this.WithArguments(args : Arguments<Symbol>) = new ImageRandomFlipTopBottom(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <summary>
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\image\image_random.cc:L210</summary>
    /// <param name="data">The input.</param>
    new([<Optional>] ?data : Symbol) =
        let data = defaultArg data (new ImplicitVariable() :> Symbol)
        let operatorArguments = 
            [
                "data", Input data
            ]
        new ImageRandomFlipTopBottom(Arguments<Symbol>(operatorArguments))
    /// The input.
    member __.Data = operatorArguments.GetInput "data"
    /// <summary>Copy ImageRandomFlipTopBottom instance with updated inputs/parameters.</summary>
    /// <param name="data">The input.</param>
    member this.With([<Optional>] ?data : Symbol) =
        let operatorArguments = 
            [
                data |> Option.map (fun x -> "data", Input x)
            ] |> List.choose id
        new ImageRandomFlipTopBottom(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type ImageRandomBrightness private (operatorArguments) = 
    inherit SymbolOperator("_image_random_brightness", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new ImageRandomBrightness(args)
    override this.WithArguments(args : Arguments<Symbol>) = new ImageRandomBrightness(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <summary>
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\image\image_random.cc:L215</summary>
    /// <param name="data">The input.</param>
    /// <param name="minFactor">Minimum factor.</param>
    /// <param name="maxFactor">Maximum factor.</param>
    new(data : Symbol,
        minFactor : float,
        maxFactor : float) = 
        let operatorArguments = 
            [
                "data", Input data
                "min_factor", Parameter(Some(box minFactor))
                "max_factor", Parameter(Some(box maxFactor))
            ]
        new ImageRandomBrightness(Arguments<Symbol>(operatorArguments))
    /// <summary>
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\image\image_random.cc:L215</summary>
    /// <param name="minFactor">Minimum factor.</param>
    /// <param name="maxFactor">Maximum factor.</param>
    /// <param name="data">The input.</param>
    new(minFactor : float,
        maxFactor : float,
        [<Optional>] ?data : Symbol) = 
        let data = defaultArg data (new ImplicitVariable() :> Symbol)
        let operatorArguments = 
            [
                "data", Input data
                "min_factor", Parameter(Some(box minFactor))
                "max_factor", Parameter(Some(box maxFactor))
            ]
        new ImageRandomBrightness(Arguments<Symbol>(operatorArguments))
    /// The input.
    member __.Data = operatorArguments.GetInput "data"
    /// Minimum factor.
    member __.MinFactor : float = match operatorArguments.GetParameter "min_factor" with Some(v) -> unbox v | None -> failwithf "Required parameter min_factor is missing"
    /// Maximum factor.
    member __.MaxFactor : float = match operatorArguments.GetParameter "max_factor" with Some(v) -> unbox v | None -> failwithf "Required parameter max_factor is missing"
    /// <summary>Copy ImageRandomBrightness instance with updated inputs/parameters.</summary>
    /// <param name="data">The input.</param>
    /// <param name="minFactor">Minimum factor.</param>
    /// <param name="maxFactor">Maximum factor.</param>
    member this.With([<Optional>] ?data : Symbol,
        [<Optional>] ?minFactor : float,
        [<Optional>] ?maxFactor : float) = 
        let operatorArguments = 
            [
                data |> Option.map (fun x -> "data", Input x)
                minFactor |> Option.map (fun x -> "min_factor", Parameter(Some (box x)))
                maxFactor |> Option.map (fun x -> "max_factor", Parameter(Some (box x)))
            ] |> List.choose id
        new ImageRandomBrightness(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type ImageRandomContrast private (operatorArguments) = 
    inherit SymbolOperator("_image_random_contrast", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new ImageRandomContrast(args)
    override this.WithArguments(args : Arguments<Symbol>) = new ImageRandomContrast(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <summary>
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\image\image_random.cc:L222</summary>
    /// <param name="data">The input.</param>
    /// <param name="minFactor">Minimum factor.</param>
    /// <param name="maxFactor">Maximum factor.</param>
    new(data : Symbol,
        minFactor : float,
        maxFactor : float) = 
        let operatorArguments = 
            [
                "data", Input data
                "min_factor", Parameter(Some(box minFactor))
                "max_factor", Parameter(Some(box maxFactor))
            ]
        new ImageRandomContrast(Arguments<Symbol>(operatorArguments))
    /// <summary>
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\image\image_random.cc:L222</summary>
    /// <param name="minFactor">Minimum factor.</param>
    /// <param name="maxFactor">Maximum factor.</param>
    /// <param name="data">The input.</param>
    new(minFactor : float,
        maxFactor : float,
        [<Optional>] ?data : Symbol) = 
        let data = defaultArg data (new ImplicitVariable() :> Symbol)
        let operatorArguments = 
            [
                "data", Input data
                "min_factor", Parameter(Some(box minFactor))
                "max_factor", Parameter(Some(box maxFactor))
            ]
        new ImageRandomContrast(Arguments<Symbol>(operatorArguments))
    /// The input.
    member __.Data = operatorArguments.GetInput "data"
    /// Minimum factor.
    member __.MinFactor : float = match operatorArguments.GetParameter "min_factor" with Some(v) -> unbox v | None -> failwithf "Required parameter min_factor is missing"
    /// Maximum factor.
    member __.MaxFactor : float = match operatorArguments.GetParameter "max_factor" with Some(v) -> unbox v | None -> failwithf "Required parameter max_factor is missing"
    /// <summary>Copy ImageRandomContrast instance with updated inputs/parameters.</summary>
    /// <param name="data">The input.</param>
    /// <param name="minFactor">Minimum factor.</param>
    /// <param name="maxFactor">Maximum factor.</param>
    member this.With([<Optional>] ?data : Symbol,
        [<Optional>] ?minFactor : float,
        [<Optional>] ?maxFactor : float) = 
        let operatorArguments = 
            [
                data |> Option.map (fun x -> "data", Input x)
                minFactor |> Option.map (fun x -> "min_factor", Parameter(Some (box x)))
                maxFactor |> Option.map (fun x -> "max_factor", Parameter(Some (box x)))
            ] |> List.choose id
        new ImageRandomContrast(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type ImageRandomSaturation private (operatorArguments) = 
    inherit SymbolOperator("_image_random_saturation", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new ImageRandomSaturation(args)
    override this.WithArguments(args : Arguments<Symbol>) = new ImageRandomSaturation(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <summary>
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\image\image_random.cc:L230</summary>
    /// <param name="data">The input.</param>
    /// <param name="minFactor">Minimum factor.</param>
    /// <param name="maxFactor">Maximum factor.</param>
    new(data : Symbol,
        minFactor : float,
        maxFactor : float) = 
        let operatorArguments = 
            [
                "data", Input data
                "min_factor", Parameter(Some(box minFactor))
                "max_factor", Parameter(Some(box maxFactor))
            ]
        new ImageRandomSaturation(Arguments<Symbol>(operatorArguments))
    /// <summary>
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\image\image_random.cc:L230</summary>
    /// <param name="minFactor">Minimum factor.</param>
    /// <param name="maxFactor">Maximum factor.</param>
    /// <param name="data">The input.</param>
    new(minFactor : float,
        maxFactor : float,
        [<Optional>] ?data : Symbol) = 
        let data = defaultArg data (new ImplicitVariable() :> Symbol)
        let operatorArguments = 
            [
                "data", Input data
                "min_factor", Parameter(Some(box minFactor))
                "max_factor", Parameter(Some(box maxFactor))
            ]
        new ImageRandomSaturation(Arguments<Symbol>(operatorArguments))
    /// The input.
    member __.Data = operatorArguments.GetInput "data"
    /// Minimum factor.
    member __.MinFactor : float = match operatorArguments.GetParameter "min_factor" with Some(v) -> unbox v | None -> failwithf "Required parameter min_factor is missing"
    /// Maximum factor.
    member __.MaxFactor : float = match operatorArguments.GetParameter "max_factor" with Some(v) -> unbox v | None -> failwithf "Required parameter max_factor is missing"
    /// <summary>Copy ImageRandomSaturation instance with updated inputs/parameters.</summary>
    /// <param name="data">The input.</param>
    /// <param name="minFactor">Minimum factor.</param>
    /// <param name="maxFactor">Maximum factor.</param>
    member this.With([<Optional>] ?data : Symbol,
        [<Optional>] ?minFactor : float,
        [<Optional>] ?maxFactor : float) = 
        let operatorArguments = 
            [
                data |> Option.map (fun x -> "data", Input x)
                minFactor |> Option.map (fun x -> "min_factor", Parameter(Some (box x)))
                maxFactor |> Option.map (fun x -> "max_factor", Parameter(Some (box x)))
            ] |> List.choose id
        new ImageRandomSaturation(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type ImageRandomHue private (operatorArguments) = 
    inherit SymbolOperator("_image_random_hue", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new ImageRandomHue(args)
    override this.WithArguments(args : Arguments<Symbol>) = new ImageRandomHue(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <summary>
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\image\image_random.cc:L238</summary>
    /// <param name="data">The input.</param>
    /// <param name="minFactor">Minimum factor.</param>
    /// <param name="maxFactor">Maximum factor.</param>
    new(data : Symbol,
        minFactor : float,
        maxFactor : float) = 
        let operatorArguments = 
            [
                "data", Input data
                "min_factor", Parameter(Some(box minFactor))
                "max_factor", Parameter(Some(box maxFactor))
            ]
        new ImageRandomHue(Arguments<Symbol>(operatorArguments))
    /// <summary>
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\image\image_random.cc:L238</summary>
    /// <param name="minFactor">Minimum factor.</param>
    /// <param name="maxFactor">Maximum factor.</param>
    /// <param name="data">The input.</param>
    new(minFactor : float,
        maxFactor : float,
        [<Optional>] ?data : Symbol) = 
        let data = defaultArg data (new ImplicitVariable() :> Symbol)
        let operatorArguments = 
            [
                "data", Input data
                "min_factor", Parameter(Some(box minFactor))
                "max_factor", Parameter(Some(box maxFactor))
            ]
        new ImageRandomHue(Arguments<Symbol>(operatorArguments))
    /// The input.
    member __.Data = operatorArguments.GetInput "data"
    /// Minimum factor.
    member __.MinFactor : float = match operatorArguments.GetParameter "min_factor" with Some(v) -> unbox v | None -> failwithf "Required parameter min_factor is missing"
    /// Maximum factor.
    member __.MaxFactor : float = match operatorArguments.GetParameter "max_factor" with Some(v) -> unbox v | None -> failwithf "Required parameter max_factor is missing"
    /// <summary>Copy ImageRandomHue instance with updated inputs/parameters.</summary>
    /// <param name="data">The input.</param>
    /// <param name="minFactor">Minimum factor.</param>
    /// <param name="maxFactor">Maximum factor.</param>
    member this.With([<Optional>] ?data : Symbol,
        [<Optional>] ?minFactor : float,
        [<Optional>] ?maxFactor : float) = 
        let operatorArguments = 
            [
                data |> Option.map (fun x -> "data", Input x)
                minFactor |> Option.map (fun x -> "min_factor", Parameter(Some (box x)))
                maxFactor |> Option.map (fun x -> "max_factor", Parameter(Some (box x)))
            ] |> List.choose id
        new ImageRandomHue(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type ImageRandomColorJitter private (operatorArguments) = 
    inherit SymbolOperator("_image_random_color_jitter", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new ImageRandomColorJitter(args)
    override this.WithArguments(args : Arguments<Symbol>) = new ImageRandomColorJitter(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <summary>
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\image\image_random.cc:L246</summary>
    /// <param name="data">The input.</param>
    /// <param name="brightness">How much to jitter brightness.</param>
    /// <param name="contrast">How much to jitter contrast.</param>
    /// <param name="saturation">How much to jitter saturation.</param>
    /// <param name="hue">How much to jitter hue.</param>
    new(data : Symbol,
        brightness : float,
        contrast : float,
        saturation : float,
        hue : float) = 
        let operatorArguments = 
            [
                "data", Input data
                "brightness", Parameter(Some(box brightness))
                "contrast", Parameter(Some(box contrast))
                "saturation", Parameter(Some(box saturation))
                "hue", Parameter(Some(box hue))
            ]
        new ImageRandomColorJitter(Arguments<Symbol>(operatorArguments))
    /// <summary>
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\image\image_random.cc:L246</summary>
    /// <param name="brightness">How much to jitter brightness.</param>
    /// <param name="contrast">How much to jitter contrast.</param>
    /// <param name="saturation">How much to jitter saturation.</param>
    /// <param name="hue">How much to jitter hue.</param>
    /// <param name="data">The input.</param>
    new(brightness : float,
        contrast : float,
        saturation : float,
        hue : float,
        [<Optional>] ?data : Symbol) = 
        let data = defaultArg data (new ImplicitVariable() :> Symbol)
        let operatorArguments = 
            [
                "data", Input data
                "brightness", Parameter(Some(box brightness))
                "contrast", Parameter(Some(box contrast))
                "saturation", Parameter(Some(box saturation))
                "hue", Parameter(Some(box hue))
            ]
        new ImageRandomColorJitter(Arguments<Symbol>(operatorArguments))
    /// The input.
    member __.Data = operatorArguments.GetInput "data"
    /// How much to jitter brightness.
    member __.Brightness : float = match operatorArguments.GetParameter "brightness" with Some(v) -> unbox v | None -> failwithf "Required parameter brightness is missing"
    /// How much to jitter contrast.
    member __.Contrast : float = match operatorArguments.GetParameter "contrast" with Some(v) -> unbox v | None -> failwithf "Required parameter contrast is missing"
    /// How much to jitter saturation.
    member __.Saturation : float = match operatorArguments.GetParameter "saturation" with Some(v) -> unbox v | None -> failwithf "Required parameter saturation is missing"
    /// How much to jitter hue.
    member __.Hue : float = match operatorArguments.GetParameter "hue" with Some(v) -> unbox v | None -> failwithf "Required parameter hue is missing"
    /// <summary>Copy ImageRandomColorJitter instance with updated inputs/parameters.</summary>
    /// <param name="data">The input.</param>
    /// <param name="brightness">How much to jitter brightness.</param>
    /// <param name="contrast">How much to jitter contrast.</param>
    /// <param name="saturation">How much to jitter saturation.</param>
    /// <param name="hue">How much to jitter hue.</param>
    member this.With([<Optional>] ?data : Symbol,
        [<Optional>] ?brightness : float,
        [<Optional>] ?contrast : float,
        [<Optional>] ?saturation : float,
        [<Optional>] ?hue : float) = 
        let operatorArguments = 
            [
                data |> Option.map (fun x -> "data", Input x)
                brightness |> Option.map (fun x -> "brightness", Parameter(Some (box x)))
                contrast |> Option.map (fun x -> "contrast", Parameter(Some (box x)))
                saturation |> Option.map (fun x -> "saturation", Parameter(Some (box x)))
                hue |> Option.map (fun x -> "hue", Parameter(Some (box x)))
            ] |> List.choose id
        new ImageRandomColorJitter(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type ImageAdjustLighting private (operatorArguments) = 
    inherit SymbolOperator("_image_adjust_lighting", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new ImageAdjustLighting(args)
    override this.WithArguments(args : Arguments<Symbol>) = new ImageAdjustLighting(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <summary>Adjust the lighting level of the input. Follow the AlexNet style.
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\image\image_random.cc:L254</summary>
    /// <param name="data">The input.</param>
    /// <param name="alpha">The lighting alphas for the R, G, B channels.</param>
    new(data : Symbol,
        alpha : double seq) = 
        let operatorArguments = 
            [
                "data", Input data
                "alpha", Parameter(Some(box alpha))
            ]
        new ImageAdjustLighting(Arguments<Symbol>(operatorArguments))
    /// <summary>Adjust the lighting level of the input. Follow the AlexNet style.
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\image\image_random.cc:L254</summary>
    /// <param name="alpha">The lighting alphas for the R, G, B channels.</param>
    /// <param name="data">The input.</param>
    new(alpha : double seq,
        [<Optional>] ?data : Symbol) = 
        let data = defaultArg data (new ImplicitVariable() :> Symbol)
        let operatorArguments = 
            [
                "data", Input data
                "alpha", Parameter(Some(box alpha))
            ]
        new ImageAdjustLighting(Arguments<Symbol>(operatorArguments))
    /// The input.
    member __.Data = operatorArguments.GetInput "data"
    /// The lighting alphas for the R, G, B channels.
    member __.Alpha : double seq = match operatorArguments.GetParameter "alpha" with Some(v) -> unbox v | None -> failwithf "Required parameter alpha is missing"
    /// <summary>Copy ImageAdjustLighting instance with updated inputs/parameters.</summary>
    /// <param name="data">The input.</param>
    /// <param name="alpha">The lighting alphas for the R, G, B channels.</param>
    member this.With([<Optional>] ?data : Symbol,
        [<Optional>] ?alpha : double seq) = 
        let operatorArguments = 
            [
                data |> Option.map (fun x -> "data", Input x)
                alpha |> Option.map (fun x -> "alpha", Parameter(Some (box x)))
            ] |> List.choose id
        new ImageAdjustLighting(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type ImageRandomLighting private (operatorArguments) = 
    inherit SymbolOperator("_image_random_lighting", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new ImageRandomLighting(args)
    override this.WithArguments(args : Arguments<Symbol>) = new ImageRandomLighting(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <summary>Randomly add PCA noise. Follow the AlexNet style.
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\image\image_random.cc:L262</summary>
    /// <param name="data">The input.</param>
    /// <param name="alphaStd">Level of the lighting noise.</param>
    new([<Optional>] ?data : Symbol,
        [<Optional>] ?alphaStd : float) = 
        let data = defaultArg data (new ImplicitVariable() :> Symbol)
        let operatorArguments = 
            [
                "data", Input data
                "alpha_std", alphaStd |> Option.map box |> Parameter
            ]
        new ImageRandomLighting(Arguments<Symbol>(operatorArguments))
    /// Default value for AlphaStd
    /// Level of the lighting noise.
    static member AlphaStdDefault : double = 0.0500000007
    /// The input.
    member __.Data = operatorArguments.GetInput "data"
    /// Level of the lighting noise.
    member __.AlphaStd = operatorArguments.GetParameter("alpha_std", ImageRandomLighting.AlphaStdDefault)
    /// <summary>Copy ImageRandomLighting instance with updated inputs/parameters.</summary>
    /// <param name="data">The input.</param>
    /// <param name="alphaStd">Level of the lighting noise.</param>
    member this.With([<Optional>] ?data : Symbol,
        [<Optional>] ?alphaStd : float) = 
        let operatorArguments = 
            [
                data |> Option.map (fun x -> "data", Input x)
                alphaStd |> Option.map (fun x -> "alpha_std", Parameter(Some (box x)))
            ] |> List.choose id
        new ImageRandomLighting(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type ImageResize private (operatorArguments) = 
    inherit SymbolOperator("_image_resize", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new ImageResize(args)
    override this.WithArguments(args : Arguments<Symbol>) = new ImageResize(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <summary>Resize an image NDArray of shape (H x W x C) or (N x H x W x C) 
    /// to the given size
    /// Example:
    ///     .. code-block:: python
    ///         image = mx.nd.random.uniform(0, 255, (4, 2, 3)).astype(dtype=np.uint8)
    ///         mx.nd.image.resize(image, (3, 3))
    ///             [[[124 111 197]
    ///               [158  80 155]
    ///               [193  50 112]]
    /// 
    ///              [[110 100 113]
    ///               [134 165 148]
    ///               [157 231 182]]
    /// 
    ///              [[202 176 134]
    ///               [174 191 149]
    ///               [147 207 164]]]
    ///             &lt;NDArray 3x3x3 @cpu(0)&gt;
    ///         image = mx.nd.random.uniform(0, 255, (2, 4, 2, 3)).astype(dtype=np.uint8)
    ///         mx.nd.image.resize(image, (2, 2))            
    ///             [[[[ 59 133  80]
    ///                [187 114 153]]
    /// 
    ///               [[ 38 142  39]
    ///                [207 131 124]]]
    /// 
    /// 
    ///               [[[117 125 136]
    ///                [191 166 150]]
    /// 
    ///               [[129  63 113]
    ///                [182 109  48]]]]
    ///             &lt;NDArray 2x2x2x3 @cpu(0)&gt;
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\image\resize.cc:L71</summary>
    /// <param name="data">The input.</param>
    /// <param name="size">Size of new image. Could be (width, height) or (size)</param>
    /// <param name="keepRatio">Whether to resize the short edge or both edges to `size`, if size is give as an integer.</param>
    /// <param name="interp">Interpolation method for resizing. By default uses bilinear interpolationOptions are INTER_NEAREST - a nearest-neighbor interpolationINTER_LINEAR - a bilinear interpolationINTER_AREA - resampling using pixel area relationINTER_CUBIC - a bicubic interpolation over 4x4 pixel neighborhoodINTER_LANCZOS4 - a Lanczos interpolation over 8x8 pixel neighborhoodNote that the GPU version only support bilinear interpolation(1) and the result on cpu would be slightly different from gpu.It uses opencv resize function which tend to align center on cpuwhile using contrib.bilinearResize2D which aligns corner on gpu</param>
    new([<Optional>] ?data : Symbol,
        [<Optional>] ?size : int seq,
        [<Optional>] ?keepRatio : bool,
        [<Optional>] ?interp : int) = 
        let data = defaultArg data (new ImplicitVariable() :> Symbol)
        let operatorArguments = 
            [
                "data", Input data
                "size", size |> Option.map box |> Parameter
                "keep_ratio", keepRatio |> Option.map box |> Parameter
                "interp", interp |> Option.map box |> Parameter
            ]
        new ImageResize(Arguments<Symbol>(operatorArguments))
    /// Default value for Size
    /// Size of new image. Could be (width, height) or (size)
    static member SizeDefault : int [] = [||]
    /// Default value for KeepRatio
    /// Whether to resize the short edge or both edges to `size`, if size is give as an integer.
    static member KeepRatioDefault : bool = false
    /// Default value for Interp
    /// Interpolation method for resizing. By default uses bilinear interpolationOptions are INTER_NEAREST - a nearest-neighbor interpolationINTER_LINEAR - a bilinear interpolationINTER_AREA - resampling using pixel area relationINTER_CUBIC - a bicubic interpolation over 4x4 pixel neighborhoodINTER_LANCZOS4 - a Lanczos interpolation over 8x8 pixel neighborhoodNote that the GPU version only support bilinear interpolation(1) and the result on cpu would be slightly different from gpu.It uses opencv resize function which tend to align center on cpuwhile using contrib.bilinearResize2D which aligns corner on gpu
    static member InterpDefault : int = 1
    /// The input.
    member __.Data = operatorArguments.GetInput "data"
    /// Size of new image. Could be (width, height) or (size)
    member __.Size = operatorArguments.GetParameter("size", ImageResize.SizeDefault)
    /// Whether to resize the short edge or both edges to `size`, if size is give as an integer.
    member __.KeepRatio = operatorArguments.GetParameter("keep_ratio", ImageResize.KeepRatioDefault)
    /// Interpolation method for resizing. By default uses bilinear interpolationOptions are INTER_NEAREST - a nearest-neighbor interpolationINTER_LINEAR - a bilinear interpolationINTER_AREA - resampling using pixel area relationINTER_CUBIC - a bicubic interpolation over 4x4 pixel neighborhoodINTER_LANCZOS4 - a Lanczos interpolation over 8x8 pixel neighborhoodNote that the GPU version only support bilinear interpolation(1) and the result on cpu would be slightly different from gpu.It uses opencv resize function which tend to align center on cpuwhile using contrib.bilinearResize2D which aligns corner on gpu
    member __.Interp = operatorArguments.GetParameter("interp", ImageResize.InterpDefault)
    /// <summary>Copy ImageResize instance with updated inputs/parameters.</summary>
    /// <param name="data">The input.</param>
    /// <param name="size">Size of new image. Could be (width, height) or (size)</param>
    /// <param name="keepRatio">Whether to resize the short edge or both edges to `size`, if size is give as an integer.</param>
    /// <param name="interp">Interpolation method for resizing. By default uses bilinear interpolationOptions are INTER_NEAREST - a nearest-neighbor interpolationINTER_LINEAR - a bilinear interpolationINTER_AREA - resampling using pixel area relationINTER_CUBIC - a bicubic interpolation over 4x4 pixel neighborhoodINTER_LANCZOS4 - a Lanczos interpolation over 8x8 pixel neighborhoodNote that the GPU version only support bilinear interpolation(1) and the result on cpu would be slightly different from gpu.It uses opencv resize function which tend to align center on cpuwhile using contrib.bilinearResize2D which aligns corner on gpu</param>
    member this.With([<Optional>] ?data : Symbol,
        [<Optional>] ?size : int seq,
        [<Optional>] ?keepRatio : bool,
        [<Optional>] ?interp : int) = 
        let operatorArguments = 
            [
                data |> Option.map (fun x -> "data", Input x)
                size |> Option.map (fun x -> "size", Parameter(Some (box x)))
                keepRatio |> Option.map (fun x -> "keep_ratio", Parameter(Some (box x)))
                interp |> Option.map (fun x -> "interp", Parameter(Some (box x)))
            ] |> List.choose id
        new ImageResize(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type LeakyReLU private (operatorArguments) = 
    inherit SymbolOperator("LeakyReLU", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new LeakyReLU(args)
    override this.WithArguments(args : Arguments<Symbol>) = new LeakyReLU(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <summary>Applies Leaky rectified linear unit activation element-wise to the input.
    /// 
    /// Leaky ReLUs attempt to fix the &quot;dying ReLU&quot; problem by allowing a small `slope`
    /// when the input is negative and has a slope of one when input is positive.
    /// 
    /// The following modified ReLU Activation functions are supported:
    /// 
    /// - *elu*: Exponential Linear Unit. `y = x &gt; 0 ? x : slope * (exp(x)-1)`
    /// - *selu*: Scaled Exponential Linear Unit. `y = lambda * (x &gt; 0 ? x : alpha * (exp(x) - 1))` where
    ///   *lambda = 1.0507009873554804934193349852946* and *alpha = 1.6732632423543772848170429916717*.
    /// - *leaky*: Leaky ReLU. `y = x &gt; 0 ? x : slope * x`
    /// - *prelu*: Parametric ReLU. This is same as *leaky* except that `slope` is learnt during training.
    /// - *rrelu*: Randomized ReLU. same as *leaky* but the `slope` is uniformly and randomly chosen from
    ///   *[lower_bound, upper_bound)* for training, while fixed to be
    ///   *(lower_bound+upper_bound)/2* for inference.
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\leaky_relu.cc:L161</summary>
    /// <param name="data">Input data to activation function.</param>
    /// <param name="gamma">Input data to activation function.</param>
    /// <param name="actType">Activation function to be applied.</param>
    /// <param name="slope">Init slope for the activation. (For leaky and elu only)</param>
    /// <param name="lowerBound">Lower bound of random slope. (For rrelu only)</param>
    /// <param name="upperBound">Upper bound of random slope. (For rrelu only)</param>
    new([<Optional>] ?data : Symbol,
        [<Optional>] ?gamma : Symbol,
        [<Optional>] ?actType : LeakyReLUType,
        [<Optional>] ?slope : float,
        [<Optional>] ?lowerBound : float,
        [<Optional>] ?upperBound : float) = 
        let data = defaultArg data (new ImplicitVariable() :> Symbol)
        let gamma = defaultArg gamma (new ImplicitVariable() :> Symbol)
        let operatorArguments = 
            [
                "data", Input data
                "gamma", Input gamma
                "act_type", actType |> Option.map box |> Parameter
                "slope", slope |> Option.map box |> Parameter
                "lower_bound", lowerBound |> Option.map box |> Parameter
                "upper_bound", upperBound |> Option.map box |> Parameter
            ]
        new LeakyReLU(Arguments<Symbol>(operatorArguments))
    /// Default value for ActType
    /// Activation function to be applied.
    static member ActTypeDefault : LeakyReLUType = LeakyReLUType.Leaky
    /// Default value for Slope
    /// Init slope for the activation. (For leaky and elu only)
    static member SlopeDefault : double = 0.25
    /// Default value for LowerBound
    /// Lower bound of random slope. (For rrelu only)
    static member LowerBoundDefault : double = 0.125
    /// Default value for UpperBound
    /// Upper bound of random slope. (For rrelu only)
    static member UpperBoundDefault : double = 0.333999991
    /// Input data to activation function.
    member __.Data = operatorArguments.GetInput "data"
    /// Input data to activation function.
    member __.Gamma = operatorArguments.GetInput "gamma"
    /// Activation function to be applied.
    member __.ActType = operatorArguments.GetParameter("act_type", LeakyReLU.ActTypeDefault)
    /// Init slope for the activation. (For leaky and elu only)
    member __.Slope = operatorArguments.GetParameter("slope", LeakyReLU.SlopeDefault)
    /// Lower bound of random slope. (For rrelu only)
    member __.LowerBound = operatorArguments.GetParameter("lower_bound", LeakyReLU.LowerBoundDefault)
    /// Upper bound of random slope. (For rrelu only)
    member __.UpperBound = operatorArguments.GetParameter("upper_bound", LeakyReLU.UpperBoundDefault)
    /// <summary>Copy LeakyReLU instance with updated inputs/parameters.</summary>
    /// <param name="data">Input data to activation function.</param>
    /// <param name="gamma">Input data to activation function.</param>
    /// <param name="actType">Activation function to be applied.</param>
    /// <param name="slope">Init slope for the activation. (For leaky and elu only)</param>
    /// <param name="lowerBound">Lower bound of random slope. (For rrelu only)</param>
    /// <param name="upperBound">Upper bound of random slope. (For rrelu only)</param>
    member this.With([<Optional>] ?data : Symbol,
        [<Optional>] ?gamma : Symbol,
        [<Optional>] ?actType : LeakyReLUType,
        [<Optional>] ?slope : float,
        [<Optional>] ?lowerBound : float,
        [<Optional>] ?upperBound : float) = 
        let operatorArguments = 
            [
                data |> Option.map (fun x -> "data", Input x)
                gamma |> Option.map (fun x -> "gamma", Input x)
                actType |> Option.map (fun x -> "act_type", Parameter(Some (box x)))
                slope |> Option.map (fun x -> "slope", Parameter(Some (box x)))
                lowerBound |> Option.map (fun x -> "lower_bound", Parameter(Some (box x)))
                upperBound |> Option.map (fun x -> "upper_bound", Parameter(Some (box x)))
            ] |> List.choose id
        new LeakyReLU(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type SoftmaxCrossEntropy private (operatorArguments) = 
    inherit SymbolOperator("softmax_cross_entropy", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new SoftmaxCrossEntropy(args)
    override this.WithArguments(args : Arguments<Symbol>) = new SoftmaxCrossEntropy(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <summary>Calculate cross entropy of softmax output and one-hot label.
    /// 
    /// - This operator computes the cross entropy in two steps:
    ///   - Applies softmax function on the input array.
    ///   - Computes and returns the cross entropy loss between the softmax output and the labels.
    /// 
    /// - The softmax function and cross entropy loss is given by:
    /// 
    ///   - Softmax Function:
    /// 
    ///   .. math:: \text{softmax}(x)_i = \frac{exp(x_i)}{\sum_j exp(x_j)}
    /// 
    ///   - Cross Entropy Function:
    /// 
    ///   .. math:: \text{CE(label, output)} = - \sum_i \text{label}_i \log(\text{output}_i)
    /// 
    /// Example::
    /// 
    ///   x = [[1, 2, 3],
    ///        [11, 7, 5]]
    /// 
    ///   label = [2, 0]
    /// 
    ///   softmax(x) = [[0.09003057, 0.24472848, 0.66524094],
    ///                 [0.97962922, 0.01794253, 0.00242826]]
    /// 
    ///   softmax_cross_entropy(data, label) = - log(0.66524084) - log(0.97962922) = 0.4281871
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\loss_binary_op.cc:L59</summary>
    /// <param name="data">Input data</param>
    /// <param name="label">Input label</param>
    new([<Optional>] ?data : Symbol,
        [<Optional>] ?label : Symbol) = 
        let data = defaultArg data (new ImplicitVariable() :> Symbol)
        let label = defaultArg label (new ImplicitVariable() :> Symbol)
        let operatorArguments = 
            [
                "data", Input data
                "label", Input label
            ]
        new SoftmaxCrossEntropy(Arguments<Symbol>(operatorArguments))
    /// Input data
    member __.Data = operatorArguments.GetInput "data"
    /// Input label
    member __.Label = operatorArguments.GetInput "label"
    /// <summary>Copy SoftmaxCrossEntropy instance with updated inputs/parameters.</summary>
    /// <param name="data">Input data</param>
    /// <param name="label">Input label</param>
    member this.With([<Optional>] ?data : Symbol,
        [<Optional>] ?label : Symbol) = 
        let operatorArguments = 
            [
                data |> Option.map (fun x -> "data", Input x)
                label |> Option.map (fun x -> "label", Input x)
            ] |> List.choose id
        new SoftmaxCrossEntropy(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type Activation private (operatorArguments) = 
    inherit SymbolOperator("Activation", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new Activation(args)
    override this.WithArguments(args : Arguments<Symbol>) = new Activation(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <summary>Applies an activation function element-wise to the input.
    /// 
    /// The following activation functions are supported:
    /// 
    /// - `relu`: Rectified Linear Unit, :math:`y = max(x, 0)`
    /// - `sigmoid`: :math:`y = \frac{1}{1 + exp(-x)}`
    /// - `tanh`: Hyperbolic tangent, :math:`y = \frac{exp(x) - exp(-x)}{exp(x) + exp(-x)}`
    /// - `softrelu`: Soft ReLU, or SoftPlus, :math:`y = log(1 + exp(x))`
    /// - `softsign`: :math:`y = \frac{x}{1 + abs(x)}`
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\nn\activation.cc:L168</summary>
    /// <param name="data">The input array.</param>
    /// <param name="actType">Activation function to be applied.</param>
    new(data : Symbol,
        actType : ActType) = 
        let operatorArguments = 
            [
                "data", Input data
                "act_type", Parameter(Some(box actType))
            ]
        new Activation(Arguments<Symbol>(operatorArguments))
    /// <summary>Applies an activation function element-wise to the input.
    /// 
    /// The following activation functions are supported:
    /// 
    /// - `relu`: Rectified Linear Unit, :math:`y = max(x, 0)`
    /// - `sigmoid`: :math:`y = \frac{1}{1 + exp(-x)}`
    /// - `tanh`: Hyperbolic tangent, :math:`y = \frac{exp(x) - exp(-x)}{exp(x) + exp(-x)}`
    /// - `softrelu`: Soft ReLU, or SoftPlus, :math:`y = log(1 + exp(x))`
    /// - `softsign`: :math:`y = \frac{x}{1 + abs(x)}`
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\nn\activation.cc:L168</summary>
    /// <param name="actType">Activation function to be applied.</param>
    /// <param name="data">The input array.</param>
    new(actType : ActType,
        [<Optional>] ?data : Symbol) = 
        let data = defaultArg data (new ImplicitVariable() :> Symbol)
        let operatorArguments = 
            [
                "data", Input data
                "act_type", Parameter(Some(box actType))
            ]
        new Activation(Arguments<Symbol>(operatorArguments))
    /// The input array.
    member __.Data = operatorArguments.GetInput "data"
    /// Activation function to be applied.
    member __.ActType : ActType = match operatorArguments.GetParameter "act_type" with Some(v) -> unbox v | None -> failwithf "Required parameter act_type is missing"
    /// <summary>Copy Activation instance with updated inputs/parameters.</summary>
    /// <param name="data">The input array.</param>
    /// <param name="actType">Activation function to be applied.</param>
    member this.With([<Optional>] ?data : Symbol,
        [<Optional>] ?actType : ActType) = 
        let operatorArguments = 
            [
                data |> Option.map (fun x -> "data", Input x)
                actType |> Option.map (fun x -> "act_type", Parameter(Some (box x)))
            ] |> List.choose id
        new Activation(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type BatchNorm private (operatorArguments) = 
    inherit SymbolOperator("BatchNorm", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new BatchNorm(args)
    override this.WithArguments(args : Arguments<Symbol>) = new BatchNorm(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <summary>Batch normalization.
    /// 
    /// Normalizes a data batch by mean and variance, and applies a scale ``gamma`` as
    /// well as offset ``beta``.
    /// 
    /// Assume the input has more than one dimension and we normalize along axis 1.
    /// We first compute the mean and variance along this axis:
    /// 
    /// .. math::
    /// 
    ///   data\_mean[i] = mean(data[:,i,:,...]) \\
    ///   data\_var[i] = var(data[:,i,:,...])
    /// 
    /// Then compute the normalized output, which has the same shape as input, as following:
    /// 
    /// .. math::
    /// 
    ///   out[:,i,:,...] = \frac{data[:,i,:,...] - data\_mean[i]}{\sqrt{data\_var[i]+\epsilon}} * gamma[i] + beta[i]
    /// 
    /// Both *mean* and *var* returns a scalar by treating the input as a vector.
    /// 
    /// Assume the input has size *k* on axis 1, then both ``gamma`` and ``beta``
    /// have shape *(k,)*. If ``output_mean_var`` is set to be true, then outputs both ``data_mean`` and
    /// the inverse of ``data_var``, which are needed for the backward pass. Note that gradient of these
    /// two outputs are blocked.
    /// 
    /// Besides the inputs and the outputs, this operator accepts two auxiliary
    /// states, ``moving_mean`` and ``moving_var``, which are *k*-length
    /// vectors. They are global statistics for the whole dataset, which are updated
    /// by::
    /// 
    ///   moving_mean = moving_mean * momentum + data_mean * (1 - momentum)
    ///   moving_var = moving_var * momentum + data_var * (1 - momentum)
    /// 
    /// If ``use_global_stats`` is set to be true, then ``moving_mean`` and
    /// ``moving_var`` are used instead of ``data_mean`` and ``data_var`` to compute
    /// the output. It is often used during inference.
    /// 
    /// The parameter ``axis`` specifies which axis of the input shape denotes
    /// the &#39;channel&#39; (separately normalized groups).  The default is 1.  Specifying -1 sets the channel
    /// axis to be the last item in the input shape.
    /// 
    /// Both ``gamma`` and ``beta`` are learnable parameters. But if ``fix_gamma`` is true,
    /// then set ``gamma`` to 1 and its gradient to 0.
    /// 
    /// .. Note::
    ///   When ``fix_gamma`` is set to True, no sparse support is provided. If ``fix_gamma is`` set to False,
    ///   the sparse tensors will fallback.
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\nn\batch_norm.cc:L571</summary>
    /// <param name="data">Input data to batch normalization</param>
    /// <param name="gamma">gamma array</param>
    /// <param name="beta">beta array</param>
    /// <param name="movingMean">running mean of input</param>
    /// <param name="movingVar">running variance of input</param>
    /// <param name="eps">Epsilon to prevent div 0. Must be no less than CUDNN_BN_MIN_EPSILON defined in cudnn.h when using cudnn (usually 1e-5)</param>
    /// <param name="momentum">Momentum for moving average</param>
    /// <param name="fixGamma">Fix gamma while training</param>
    /// <param name="useGlobalStats">Whether use global moving statistics instead of local batch-norm. This will force change batch-norm into a scale shift operator.</param>
    /// <param name="outputMeanVar">Output the mean and inverse std </param>
    /// <param name="axis">Specify which shape axis the channel is specified</param>
    /// <param name="cudnnOff">Do not select CUDNN operator, if available</param>
    /// <param name="minCalibRange">The minimum scalar value in the form of float32 obtained through calibration. If present, it will be used to by quantized batch norm op to calculate primitive scale.Note: this calib_range is to calib bn output.</param>
    /// <param name="maxCalibRange">The maximum scalar value in the form of float32 obtained through calibration. If present, it will be used to by quantized batch norm op to calculate primitive scale.Note: this calib_range is to calib bn output.</param>
    new([<Optional>] ?data : Symbol,
        [<Optional>] ?gamma : Symbol,
        [<Optional>] ?beta : Symbol,
        [<Optional>] ?movingMean : Symbol,
        [<Optional>] ?movingVar : Symbol,
        [<Optional>] ?eps : double,
        [<Optional>] ?momentum : float,
        [<Optional>] ?fixGamma : bool,
        [<Optional>] ?useGlobalStats : bool,
        [<Optional>] ?outputMeanVar : bool,
        [<Optional>] ?axis : int,
        [<Optional>] ?cudnnOff : bool,
        [<Optional>] ?minCalibRange : float,
        [<Optional>] ?maxCalibRange : float) = 
        let data = defaultArg data (new ImplicitVariable() :> Symbol)
        let gamma = defaultArg gamma (new ImplicitVariable() :> Symbol)
        let beta = defaultArg beta (new ImplicitVariable() :> Symbol)
        let movingMean = defaultArg movingMean (new ImplicitVariable() :> Symbol)
        let movingVar = defaultArg movingVar (new ImplicitVariable() :> Symbol)
        let operatorArguments = 
            [
                "data", Input data
                "gamma", Input gamma
                "beta", Input beta
                "moving_mean", Input movingMean
                "moving_var", Input movingVar
                "eps", eps |> Option.map box |> Parameter
                "momentum", momentum |> Option.map box |> Parameter
                "fix_gamma", fixGamma |> Option.map box |> Parameter
                "use_global_stats", useGlobalStats |> Option.map box |> Parameter
                "output_mean_var", outputMeanVar |> Option.map box |> Parameter
                "axis", axis |> Option.map box |> Parameter
                "cudnn_off", cudnnOff |> Option.map box |> Parameter
                "min_calib_range", minCalibRange |> Option.map box |> Parameter
                "max_calib_range", maxCalibRange |> Option.map box |> Parameter
            ]
        new BatchNorm(Arguments<Symbol>(operatorArguments))
    /// Default value for Eps
    /// Epsilon to prevent div 0. Must be no less than CUDNN_BN_MIN_EPSILON defined in cudnn.h when using cudnn (usually 1e-5)
    static member EpsDefault : double = 0.0010000000474975
    /// Default value for Momentum
    /// Momentum for moving average
    static member MomentumDefault : double = 0.899999976
    /// Default value for FixGamma
    /// Fix gamma while training
    static member FixGammaDefault : bool = true
    /// Default value for UseGlobalStats
    /// Whether use global moving statistics instead of local batch-norm. This will force change batch-norm into a scale shift operator.
    static member UseGlobalStatsDefault : bool = false
    /// Default value for OutputMeanVar
    /// Output the mean and inverse std 
    static member OutputMeanVarDefault : bool = false
    /// Default value for Axis
    /// Specify which shape axis the channel is specified
    static member AxisDefault : int = 1
    /// Default value for CudnnOff
    /// Do not select CUDNN operator, if available
    static member CudnnOffDefault : bool = false
    /// Default value for MinCalibRange
    /// The minimum scalar value in the form of float32 obtained through calibration. If present, it will be used to by quantized batch norm op to calculate primitive scale.Note: this calib_range is to calib bn output.
    static member MinCalibRangeDefault : double option = None
    /// Default value for MaxCalibRange
    /// The maximum scalar value in the form of float32 obtained through calibration. If present, it will be used to by quantized batch norm op to calculate primitive scale.Note: this calib_range is to calib bn output.
    static member MaxCalibRangeDefault : double option = None
    /// Input data to batch normalization
    member __.Data = operatorArguments.GetInput "data"
    /// gamma array
    member __.Gamma = operatorArguments.GetInput "gamma"
    /// beta array
    member __.Beta = operatorArguments.GetInput "beta"
    /// running mean of input
    member __.MovingMean = operatorArguments.GetInput "moving_mean"
    /// running variance of input
    member __.MovingVar = operatorArguments.GetInput "moving_var"
    /// Epsilon to prevent div 0. Must be no less than CUDNN_BN_MIN_EPSILON defined in cudnn.h when using cudnn (usually 1e-5)
    member __.Eps = operatorArguments.GetParameter("eps", BatchNorm.EpsDefault)
    /// Momentum for moving average
    member __.Momentum = operatorArguments.GetParameter("momentum", BatchNorm.MomentumDefault)
    /// Fix gamma while training
    member __.FixGamma = operatorArguments.GetParameter("fix_gamma", BatchNorm.FixGammaDefault)
    /// Whether use global moving statistics instead of local batch-norm. This will force change batch-norm into a scale shift operator.
    member __.UseGlobalStats = operatorArguments.GetParameter("use_global_stats", BatchNorm.UseGlobalStatsDefault)
    /// Output the mean and inverse std 
    member __.OutputMeanVar = operatorArguments.GetParameter("output_mean_var", BatchNorm.OutputMeanVarDefault)
    /// Specify which shape axis the channel is specified
    member __.Axis = operatorArguments.GetParameter("axis", BatchNorm.AxisDefault)
    /// Do not select CUDNN operator, if available
    member __.CudnnOff = operatorArguments.GetParameter("cudnn_off", BatchNorm.CudnnOffDefault)
    /// The minimum scalar value in the form of float32 obtained through calibration. If present, it will be used to by quantized batch norm op to calculate primitive scale.Note: this calib_range is to calib bn output.
    member __.MinCalibRange = operatorArguments.GetParameter("min_calib_range", BatchNorm.MinCalibRangeDefault)
    /// The maximum scalar value in the form of float32 obtained through calibration. If present, it will be used to by quantized batch norm op to calculate primitive scale.Note: this calib_range is to calib bn output.
    member __.MaxCalibRange = operatorArguments.GetParameter("max_calib_range", BatchNorm.MaxCalibRangeDefault)
    /// <summary>Copy BatchNorm instance with updated inputs/parameters.</summary>
    /// <param name="data">Input data to batch normalization</param>
    /// <param name="gamma">gamma array</param>
    /// <param name="beta">beta array</param>
    /// <param name="movingMean">running mean of input</param>
    /// <param name="movingVar">running variance of input</param>
    /// <param name="eps">Epsilon to prevent div 0. Must be no less than CUDNN_BN_MIN_EPSILON defined in cudnn.h when using cudnn (usually 1e-5)</param>
    /// <param name="momentum">Momentum for moving average</param>
    /// <param name="fixGamma">Fix gamma while training</param>
    /// <param name="useGlobalStats">Whether use global moving statistics instead of local batch-norm. This will force change batch-norm into a scale shift operator.</param>
    /// <param name="outputMeanVar">Output the mean and inverse std </param>
    /// <param name="axis">Specify which shape axis the channel is specified</param>
    /// <param name="cudnnOff">Do not select CUDNN operator, if available</param>
    /// <param name="minCalibRange">The minimum scalar value in the form of float32 obtained through calibration. If present, it will be used to by quantized batch norm op to calculate primitive scale.Note: this calib_range is to calib bn output.</param>
    /// <param name="maxCalibRange">The maximum scalar value in the form of float32 obtained through calibration. If present, it will be used to by quantized batch norm op to calculate primitive scale.Note: this calib_range is to calib bn output.</param>
    member this.With([<Optional>] ?data : Symbol,
        [<Optional>] ?gamma : Symbol,
        [<Optional>] ?beta : Symbol,
        [<Optional>] ?movingMean : Symbol,
        [<Optional>] ?movingVar : Symbol,
        [<Optional>] ?eps : double,
        [<Optional>] ?momentum : float,
        [<Optional>] ?fixGamma : bool,
        [<Optional>] ?useGlobalStats : bool,
        [<Optional>] ?outputMeanVar : bool,
        [<Optional>] ?axis : int,
        [<Optional>] ?cudnnOff : bool,
        [<Optional>] ?minCalibRange : float,
        [<Optional>] ?maxCalibRange : float) = 
        let operatorArguments = 
            [
                data |> Option.map (fun x -> "data", Input x)
                gamma |> Option.map (fun x -> "gamma", Input x)
                beta |> Option.map (fun x -> "beta", Input x)
                movingMean |> Option.map (fun x -> "moving_mean", Input x)
                movingVar |> Option.map (fun x -> "moving_var", Input x)
                eps |> Option.map (fun x -> "eps", Parameter(Some (box x)))
                momentum |> Option.map (fun x -> "momentum", Parameter(Some (box x)))
                fixGamma |> Option.map (fun x -> "fix_gamma", Parameter(Some (box x)))
                useGlobalStats |> Option.map (fun x -> "use_global_stats", Parameter(Some (box x)))
                outputMeanVar |> Option.map (fun x -> "output_mean_var", Parameter(Some (box x)))
                axis |> Option.map (fun x -> "axis", Parameter(Some (box x)))
                cudnnOff |> Option.map (fun x -> "cudnn_off", Parameter(Some (box x)))
                minCalibRange |> Option.map (fun x -> "min_calib_range", Parameter(Some (box x)))
                maxCalibRange |> Option.map (fun x -> "max_calib_range", Parameter(Some (box x)))
            ] |> List.choose id
        new BatchNorm(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type Concat private (operatorArguments) = 
    inherit SymbolOperator("Concat", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new Concat(args)
    override this.WithArguments(args : Arguments<Symbol>) = new Concat(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <summary>Joins input arrays along a given axis.
    /// 
    /// .. note:: `Concat` is deprecated. Use `concat` instead.
    /// 
    /// The dimensions of the input arrays should be the same except the axis along
    /// which they will be concatenated.
    /// The dimension of the output array along the concatenated axis will be equal
    /// to the sum of the corresponding dimensions of the input arrays.
    /// 
    /// The storage type of ``concat`` output depends on storage types of inputs
    /// 
    /// - concat(csr, csr, ..., csr, dim=0) = csr
    /// - otherwise, ``concat`` generates output with default storage
    /// 
    /// Example::
    /// 
    ///    x = [[1,1],[2,2]]
    ///    y = [[3,3],[4,4],[5,5]]
    ///    z = [[6,6], [7,7],[8,8]]
    /// 
    ///    concat(x,y,z,dim=0) = [[ 1.,  1.],
    ///                           [ 2.,  2.],
    ///                           [ 3.,  3.],
    ///                           [ 4.,  4.],
    ///                           [ 5.,  5.],
    ///                           [ 6.,  6.],
    ///                           [ 7.,  7.],
    ///                           [ 8.,  8.]]
    /// 
    ///    Note that you cannot concat x,y,z along dimension 1 since dimension
    ///    0 is not the same for all the input arrays.
    /// 
    ///    concat(y,z,dim=1) = [[ 3.,  3.,  6.,  6.],
    ///                          [ 4.,  4.,  7.,  7.],
    ///                          [ 5.,  5.,  8.,  8.]]
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\nn\concat.cc:L383</summary>
    /// <param name="data">List of arrays to concatenate</param>
    /// <param name="dim">the dimension to be concated.</param>
    new([<Optional>] ?data : Symbol seq,
        [<Optional>] ?dim : int) = 
        let data = defaultArg (data |> Option.map Seq.toArray) Array.empty
        let operatorArguments = 
            [
                "data", VarArg("num_args", data)
                "dim", dim |> Option.map box |> Parameter
            ]
        new Concat(Arguments<Symbol>(operatorArguments))
    /// Default value for Dim
    /// the dimension to be concated.
    static member DimDefault : int = 1
    /// List of arrays to concatenate
    member __.Data = operatorArguments.GetVarArg "data"
    /// the dimension to be concated.
    member __.Dim = operatorArguments.GetParameter("dim", Concat.DimDefault)
    /// <summary>Copy Concat instance with updated inputs/parameters.</summary>
    /// <param name="data">List of arrays to concatenate</param>
    /// <param name="dim">the dimension to be concated.</param>
    member this.With([<Optional>] ?data : Symbol seq,
        [<Optional>] ?dim : int) = 
        let operatorArguments = 
            [
                data |> Option.map (fun x -> "data", VarArg("num_args", Seq.toArray x))
                dim |> Option.map (fun x -> "dim", Parameter(Some (box x)))
            ] |> List.choose id
        new Concat(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type RnnParamConcat private (operatorArguments) = 
    inherit SymbolOperator("_rnn_param_concat", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new RnnParamConcat(args)
    override this.WithArguments(args : Arguments<Symbol>) = new RnnParamConcat(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <param name="data">List of arrays to concatenate</param>
    /// <param name="dim">the dimension to be concated.</param>
    new([<Optional>] ?data : Symbol seq,
        [<Optional>] ?dim : int) = 
        let data = defaultArg (data |> Option.map Seq.toArray) Array.empty
        let operatorArguments = 
            [
                "data", VarArg("num_args", data)
                "dim", dim |> Option.map box |> Parameter
            ]
        new RnnParamConcat(Arguments<Symbol>(operatorArguments))
    /// Default value for Dim
    /// the dimension to be concated.
    static member DimDefault : int = 1
    /// List of arrays to concatenate
    member __.Data = operatorArguments.GetVarArg "data"
    /// the dimension to be concated.
    member __.Dim = operatorArguments.GetParameter("dim", RnnParamConcat.DimDefault)
    /// <summary>Copy RnnParamConcat instance with updated inputs/parameters.</summary>
    /// <param name="data">List of arrays to concatenate</param>
    /// <param name="dim">the dimension to be concated.</param>
    member this.With([<Optional>] ?data : Symbol seq,
        [<Optional>] ?dim : int) = 
        let operatorArguments = 
            [
                data |> Option.map (fun x -> "data", VarArg("num_args", Seq.toArray x))
                dim |> Option.map (fun x -> "dim", Parameter(Some (box x)))
            ] |> List.choose id
        new RnnParamConcat(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type Convolution private (operatorArguments) = 
    inherit SymbolOperator("Convolution", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new Convolution(args)
    override this.WithArguments(args : Arguments<Symbol>) = new Convolution(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <summary>Compute *N*-D convolution on *(N+2)*-D input.
    /// 
    /// In the 2-D convolution, given input data with shape *(batch_size,
    /// channel, height, width)*, the output is computed by
    /// 
    /// .. math::
    /// 
    ///    out[n,i,:,:] = bias[i] + \sum_{j=0}^{channel} data[n,j,:,:] \star
    ///    weight[i,j,:,:]
    /// 
    /// where :math:`\star` is the 2-D cross-correlation operator.
    /// 
    /// For general 2-D convolution, the shapes are
    /// 
    /// - **data**: *(batch_size, channel, height, width)*
    /// - **weight**: *(num_filter, channel, kernel[0], kernel[1])*
    /// - **bias**: *(num_filter,)*
    /// - **out**: *(batch_size, num_filter, out_height, out_width)*.
    /// 
    /// Define::
    /// 
    ///   f(x,k,p,s,d) = floor((x+2*p-d*(k-1)-1)/s)+1
    /// 
    /// then we have::
    /// 
    ///   out_height=f(height, kernel[0], pad[0], stride[0], dilate[0])
    ///   out_width=f(width, kernel[1], pad[1], stride[1], dilate[1])
    /// 
    /// If ``no_bias`` is set to be true, then the ``bias`` term is ignored.
    /// 
    /// The default data ``layout`` is *NCHW*, namely *(batch_size, channel, height,
    /// width)*. We can choose other layouts such as *NWC*.
    /// 
    /// If ``num_group`` is larger than 1, denoted by *g*, then split the input ``data``
    /// evenly into *g* parts along the channel axis, and also evenly split ``weight``
    /// along the first dimension. Next compute the convolution on the *i*-th part of
    /// the data with the *i*-th weight part. The output is obtained by concatenating all
    /// the *g* results.
    /// 
    /// 1-D convolution does not have *height* dimension but only *width* in space.
    /// 
    /// - **data**: *(batch_size, channel, width)*
    /// - **weight**: *(num_filter, channel, kernel[0])*
    /// - **bias**: *(num_filter,)*
    /// - **out**: *(batch_size, num_filter, out_width)*.
    /// 
    /// 3-D convolution adds an additional *depth* dimension besides *height* and
    /// *width*. The shapes are
    /// 
    /// - **data**: *(batch_size, channel, depth, height, width)*
    /// - **weight**: *(num_filter, channel, kernel[0], kernel[1], kernel[2])*
    /// - **bias**: *(num_filter,)*
    /// - **out**: *(batch_size, num_filter, out_depth, out_height, out_width)*.
    /// 
    /// Both ``weight`` and ``bias`` are learnable parameters.
    /// 
    /// There are other options to tune the performance.
    /// 
    /// - **cudnn_tune**: enable this option leads to higher startup time but may give
    ///   faster speed. Options are
    /// 
    ///   - **off**: no tuning
    ///   - **limited_workspace**:run test and pick the fastest algorithm that doesn&#39;t
    ///     exceed workspace limit.
    ///   - **fastest**: pick the fastest algorithm and ignore workspace limit.
    ///   - **None** (default): the behavior is determined by environment variable
    ///     ``MXNET_CUDNN_AUTOTUNE_DEFAULT``. 0 for off, 1 for limited workspace
    ///     (default), 2 for fastest.
    /// 
    /// - **workspace**: A large number leads to more (GPU) memory usage but may improve
    ///   the performance.
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\nn\convolution.cc:L473</summary>
    /// <param name="data">Input data to the ConvolutionOp.</param>
    /// <param name="weight">Weight matrix.</param>
    /// <param name="bias">Bias parameter.</param>
    /// <param name="kernel">Convolution kernel size: (w,), (h, w) or (d, h, w)</param>
    /// <param name="numFilter">Convolution filter(channel) number</param>
    /// <param name="stride">Convolution stride: (w,), (h, w) or (d, h, w). Defaults to 1 for each dimension.</param>
    /// <param name="dilate">Convolution dilate: (w,), (h, w) or (d, h, w). Defaults to 1 for each dimension.</param>
    /// <param name="pad">Zero pad for convolution: (w,), (h, w) or (d, h, w). Defaults to no padding.</param>
    /// <param name="numGroup">Number of group partitions.</param>
    /// <param name="workspace">Maximum temporary workspace allowed (MB) in convolution.This parameter has two usages. When CUDNN is not used, it determines the effective batch size of the convolution kernel. When CUDNN is used, it controls the maximum temporary storage used for tuning the best CUDNN kernel when `limited_workspace` strategy is used.</param>
    /// <param name="noBias">Whether to disable bias parameter.</param>
    /// <param name="cudnnTune">Whether to pick convolution algo by running performance test.</param>
    /// <param name="cudnnOff">Turn off cudnn for this layer.</param>
    /// <param name="layout">Set layout for input, output and weight. Empty for
    ///     default layout: NCW for 1d, NCHW for 2d and NCDHW for 3d.NHWC and NDHWC are only supported on GPU.</param>
    new(data : Symbol,
        weight : Symbol,
        bias : Symbol,
        kernel : int seq,
        numFilter : int,
        [<Optional>] ?stride : int seq,
        [<Optional>] ?dilate : int seq,
        [<Optional>] ?pad : int seq,
        [<Optional>] ?numGroup : int,
        [<Optional>] ?workspace : int64,
        [<Optional>] ?noBias : bool,
        [<Optional>] ?cudnnTune : CudnnTune,
        [<Optional>] ?cudnnOff : bool,
        [<Optional>] ?layout : ConvolutionLayout) = 
        let operatorArguments = 
            [
                "data", Input data
                "weight", Input weight
                "bias", Input bias
                "kernel", Parameter(Some(box kernel))
                "num_filter", Parameter(Some(box numFilter))
                "stride", stride |> Option.map box |> Parameter
                "dilate", dilate |> Option.map box |> Parameter
                "pad", pad |> Option.map box |> Parameter
                "num_group", numGroup |> Option.map box |> Parameter
                "workspace", workspace |> Option.map box |> Parameter
                "no_bias", noBias |> Option.map box |> Parameter
                "cudnn_tune", cudnnTune |> Option.map box |> Parameter
                "cudnn_off", cudnnOff |> Option.map box |> Parameter
                "layout", layout |> Option.map box |> Parameter
            ]
        new Convolution(Arguments<Symbol>(operatorArguments))
    /// <summary>Compute *N*-D convolution on *(N+2)*-D input.
    /// 
    /// In the 2-D convolution, given input data with shape *(batch_size,
    /// channel, height, width)*, the output is computed by
    /// 
    /// .. math::
    /// 
    ///    out[n,i,:,:] = bias[i] + \sum_{j=0}^{channel} data[n,j,:,:] \star
    ///    weight[i,j,:,:]
    /// 
    /// where :math:`\star` is the 2-D cross-correlation operator.
    /// 
    /// For general 2-D convolution, the shapes are
    /// 
    /// - **data**: *(batch_size, channel, height, width)*
    /// - **weight**: *(num_filter, channel, kernel[0], kernel[1])*
    /// - **bias**: *(num_filter,)*
    /// - **out**: *(batch_size, num_filter, out_height, out_width)*.
    /// 
    /// Define::
    /// 
    ///   f(x,k,p,s,d) = floor((x+2*p-d*(k-1)-1)/s)+1
    /// 
    /// then we have::
    /// 
    ///   out_height=f(height, kernel[0], pad[0], stride[0], dilate[0])
    ///   out_width=f(width, kernel[1], pad[1], stride[1], dilate[1])
    /// 
    /// If ``no_bias`` is set to be true, then the ``bias`` term is ignored.
    /// 
    /// The default data ``layout`` is *NCHW*, namely *(batch_size, channel, height,
    /// width)*. We can choose other layouts such as *NWC*.
    /// 
    /// If ``num_group`` is larger than 1, denoted by *g*, then split the input ``data``
    /// evenly into *g* parts along the channel axis, and also evenly split ``weight``
    /// along the first dimension. Next compute the convolution on the *i*-th part of
    /// the data with the *i*-th weight part. The output is obtained by concatenating all
    /// the *g* results.
    /// 
    /// 1-D convolution does not have *height* dimension but only *width* in space.
    /// 
    /// - **data**: *(batch_size, channel, width)*
    /// - **weight**: *(num_filter, channel, kernel[0])*
    /// - **bias**: *(num_filter,)*
    /// - **out**: *(batch_size, num_filter, out_width)*.
    /// 
    /// 3-D convolution adds an additional *depth* dimension besides *height* and
    /// *width*. The shapes are
    /// 
    /// - **data**: *(batch_size, channel, depth, height, width)*
    /// - **weight**: *(num_filter, channel, kernel[0], kernel[1], kernel[2])*
    /// - **bias**: *(num_filter,)*
    /// - **out**: *(batch_size, num_filter, out_depth, out_height, out_width)*.
    /// 
    /// Both ``weight`` and ``bias`` are learnable parameters.
    /// 
    /// There are other options to tune the performance.
    /// 
    /// - **cudnn_tune**: enable this option leads to higher startup time but may give
    ///   faster speed. Options are
    /// 
    ///   - **off**: no tuning
    ///   - **limited_workspace**:run test and pick the fastest algorithm that doesn&#39;t
    ///     exceed workspace limit.
    ///   - **fastest**: pick the fastest algorithm and ignore workspace limit.
    ///   - **None** (default): the behavior is determined by environment variable
    ///     ``MXNET_CUDNN_AUTOTUNE_DEFAULT``. 0 for off, 1 for limited workspace
    ///     (default), 2 for fastest.
    /// 
    /// - **workspace**: A large number leads to more (GPU) memory usage but may improve
    ///   the performance.
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\nn\convolution.cc:L473</summary>
    /// <param name="kernel">Convolution kernel size: (w,), (h, w) or (d, h, w)</param>
    /// <param name="numFilter">Convolution filter(channel) number</param>
    /// <param name="data">Input data to the ConvolutionOp.</param>
    /// <param name="weight">Weight matrix.</param>
    /// <param name="bias">Bias parameter.</param>
    /// <param name="stride">Convolution stride: (w,), (h, w) or (d, h, w). Defaults to 1 for each dimension.</param>
    /// <param name="dilate">Convolution dilate: (w,), (h, w) or (d, h, w). Defaults to 1 for each dimension.</param>
    /// <param name="pad">Zero pad for convolution: (w,), (h, w) or (d, h, w). Defaults to no padding.</param>
    /// <param name="numGroup">Number of group partitions.</param>
    /// <param name="workspace">Maximum temporary workspace allowed (MB) in convolution.This parameter has two usages. When CUDNN is not used, it determines the effective batch size of the convolution kernel. When CUDNN is used, it controls the maximum temporary storage used for tuning the best CUDNN kernel when `limited_workspace` strategy is used.</param>
    /// <param name="noBias">Whether to disable bias parameter.</param>
    /// <param name="cudnnTune">Whether to pick convolution algo by running performance test.</param>
    /// <param name="cudnnOff">Turn off cudnn for this layer.</param>
    /// <param name="layout">Set layout for input, output and weight. Empty for
    ///     default layout: NCW for 1d, NCHW for 2d and NCDHW for 3d.NHWC and NDHWC are only supported on GPU.</param>
    new(kernel : int seq,
        numFilter : int,
        [<Optional>] ?data : Symbol,
        [<Optional>] ?weight : Symbol,
        [<Optional>] ?bias : Symbol,
        [<Optional>] ?stride : int seq,
        [<Optional>] ?dilate : int seq,
        [<Optional>] ?pad : int seq,
        [<Optional>] ?numGroup : int,
        [<Optional>] ?workspace : int64,
        [<Optional>] ?noBias : bool,
        [<Optional>] ?cudnnTune : CudnnTune,
        [<Optional>] ?cudnnOff : bool,
        [<Optional>] ?layout : ConvolutionLayout) = 
        let data = defaultArg data (new ImplicitVariable() :> Symbol)
        let weight = defaultArg weight (new ImplicitVariable() :> Symbol)
        let bias = defaultArg bias (new ImplicitVariable() :> Symbol)
        let operatorArguments = 
            [
                "data", Input data
                "weight", Input weight
                "bias", Input bias
                "kernel", Parameter(Some(box kernel))
                "num_filter", Parameter(Some(box numFilter))
                "stride", stride |> Option.map box |> Parameter
                "dilate", dilate |> Option.map box |> Parameter
                "pad", pad |> Option.map box |> Parameter
                "num_group", numGroup |> Option.map box |> Parameter
                "workspace", workspace |> Option.map box |> Parameter
                "no_bias", noBias |> Option.map box |> Parameter
                "cudnn_tune", cudnnTune |> Option.map box |> Parameter
                "cudnn_off", cudnnOff |> Option.map box |> Parameter
                "layout", layout |> Option.map box |> Parameter
            ]
        new Convolution(Arguments<Symbol>(operatorArguments))
    /// Default value for Stride
    /// Convolution stride: (w,), (h, w) or (d, h, w). Defaults to 1 for each dimension.
    static member StrideDefault : int [] = [||]
    /// Default value for Dilate
    /// Convolution dilate: (w,), (h, w) or (d, h, w). Defaults to 1 for each dimension.
    static member DilateDefault : int [] = [||]
    /// Default value for Pad
    /// Zero pad for convolution: (w,), (h, w) or (d, h, w). Defaults to no padding.
    static member PadDefault : int [] = [||]
    /// Default value for NumGroup
    /// Number of group partitions.
    static member NumGroupDefault : int = 1
    /// Default value for Workspace
    /// Maximum temporary workspace allowed (MB) in convolution.This parameter has two usages. When CUDNN is not used, it determines the effective batch size of the convolution kernel. When CUDNN is used, it controls the maximum temporary storage used for tuning the best CUDNN kernel when `limited_workspace` strategy is used.
    static member WorkspaceDefault : int64 = 1024L
    /// Default value for NoBias
    /// Whether to disable bias parameter.
    static member NoBiasDefault : bool = false
    /// Default value for CudnnTune
    /// Whether to pick convolution algo by running performance test.
    static member CudnnTuneDefault : CudnnTune option = None
    /// Default value for CudnnOff
    /// Turn off cudnn for this layer.
    static member CudnnOffDefault : bool = false
    /// Default value for Layout
    /// Set layout for input, output and weight. Empty for
    ///     default layout: NCW for 1d, NCHW for 2d and NCDHW for 3d.NHWC and NDHWC are only supported on GPU.
    static member LayoutDefault : ConvolutionLayout option = None
    /// Input data to the ConvolutionOp.
    member __.Data = operatorArguments.GetInput "data"
    /// Weight matrix.
    member __.Weight = operatorArguments.GetInput "weight"
    /// Bias parameter.
    member __.Bias = operatorArguments.GetInput "bias"
    /// Convolution kernel size: (w,), (h, w) or (d, h, w)
    member __.Kernel : int seq = match operatorArguments.GetParameter "kernel" with Some(v) -> unbox v | None -> failwithf "Required parameter kernel is missing"
    /// Convolution filter(channel) number
    member __.NumFilter : int = match operatorArguments.GetParameter "num_filter" with Some(v) -> unbox v | None -> failwithf "Required parameter num_filter is missing"
    /// Convolution stride: (w,), (h, w) or (d, h, w). Defaults to 1 for each dimension.
    member __.Stride = operatorArguments.GetParameter("stride", Convolution.StrideDefault)
    /// Convolution dilate: (w,), (h, w) or (d, h, w). Defaults to 1 for each dimension.
    member __.Dilate = operatorArguments.GetParameter("dilate", Convolution.DilateDefault)
    /// Zero pad for convolution: (w,), (h, w) or (d, h, w). Defaults to no padding.
    member __.Pad = operatorArguments.GetParameter("pad", Convolution.PadDefault)
    /// Number of group partitions.
    member __.NumGroup = operatorArguments.GetParameter("num_group", Convolution.NumGroupDefault)
    /// Maximum temporary workspace allowed (MB) in convolution.This parameter has two usages. When CUDNN is not used, it determines the effective batch size of the convolution kernel. When CUDNN is used, it controls the maximum temporary storage used for tuning the best CUDNN kernel when `limited_workspace` strategy is used.
    member __.Workspace = operatorArguments.GetParameter("workspace", Convolution.WorkspaceDefault)
    /// Whether to disable bias parameter.
    member __.NoBias = operatorArguments.GetParameter("no_bias", Convolution.NoBiasDefault)
    /// Whether to pick convolution algo by running performance test.
    member __.CudnnTune = operatorArguments.GetParameter("cudnn_tune", Convolution.CudnnTuneDefault)
    /// Turn off cudnn for this layer.
    member __.CudnnOff = operatorArguments.GetParameter("cudnn_off", Convolution.CudnnOffDefault)
    /// Set layout for input, output and weight. Empty for
    ///     default layout: NCW for 1d, NCHW for 2d and NCDHW for 3d.NHWC and NDHWC are only supported on GPU.
    member __.Layout = operatorArguments.GetParameter("layout", Convolution.LayoutDefault)
    /// <summary>Copy Convolution instance with updated inputs/parameters.</summary>
    /// <param name="data">Input data to the ConvolutionOp.</param>
    /// <param name="weight">Weight matrix.</param>
    /// <param name="bias">Bias parameter.</param>
    /// <param name="kernel">Convolution kernel size: (w,), (h, w) or (d, h, w)</param>
    /// <param name="numFilter">Convolution filter(channel) number</param>
    /// <param name="stride">Convolution stride: (w,), (h, w) or (d, h, w). Defaults to 1 for each dimension.</param>
    /// <param name="dilate">Convolution dilate: (w,), (h, w) or (d, h, w). Defaults to 1 for each dimension.</param>
    /// <param name="pad">Zero pad for convolution: (w,), (h, w) or (d, h, w). Defaults to no padding.</param>
    /// <param name="numGroup">Number of group partitions.</param>
    /// <param name="workspace">Maximum temporary workspace allowed (MB) in convolution.This parameter has two usages. When CUDNN is not used, it determines the effective batch size of the convolution kernel. When CUDNN is used, it controls the maximum temporary storage used for tuning the best CUDNN kernel when `limited_workspace` strategy is used.</param>
    /// <param name="noBias">Whether to disable bias parameter.</param>
    /// <param name="cudnnTune">Whether to pick convolution algo by running performance test.</param>
    /// <param name="cudnnOff">Turn off cudnn for this layer.</param>
    /// <param name="layout">Set layout for input, output and weight. Empty for
    ///     default layout: NCW for 1d, NCHW for 2d and NCDHW for 3d.NHWC and NDHWC are only supported on GPU.</param>
    member this.With([<Optional>] ?data : Symbol,
        [<Optional>] ?weight : Symbol,
        [<Optional>] ?bias : Symbol,
        [<Optional>] ?kernel : int seq,
        [<Optional>] ?numFilter : int,
        [<Optional>] ?stride : int seq,
        [<Optional>] ?dilate : int seq,
        [<Optional>] ?pad : int seq,
        [<Optional>] ?numGroup : int,
        [<Optional>] ?workspace : int64,
        [<Optional>] ?noBias : bool,
        [<Optional>] ?cudnnTune : CudnnTune,
        [<Optional>] ?cudnnOff : bool,
        [<Optional>] ?layout : ConvolutionLayout) = 
        let operatorArguments = 
            [
                data |> Option.map (fun x -> "data", Input x)
                weight |> Option.map (fun x -> "weight", Input x)
                bias |> Option.map (fun x -> "bias", Input x)
                kernel |> Option.map (fun x -> "kernel", Parameter(Some (box x)))
                numFilter |> Option.map (fun x -> "num_filter", Parameter(Some (box x)))
                stride |> Option.map (fun x -> "stride", Parameter(Some (box x)))
                dilate |> Option.map (fun x -> "dilate", Parameter(Some (box x)))
                pad |> Option.map (fun x -> "pad", Parameter(Some (box x)))
                numGroup |> Option.map (fun x -> "num_group", Parameter(Some (box x)))
                workspace |> Option.map (fun x -> "workspace", Parameter(Some (box x)))
                noBias |> Option.map (fun x -> "no_bias", Parameter(Some (box x)))
                cudnnTune |> Option.map (fun x -> "cudnn_tune", Parameter(Some (box x)))
                cudnnOff |> Option.map (fun x -> "cudnn_off", Parameter(Some (box x)))
                layout |> Option.map (fun x -> "layout", Parameter(Some (box x)))
            ] |> List.choose id
        new Convolution(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type CTCLoss private (operatorArguments) = 
    inherit SymbolOperator("CTCLoss", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new CTCLoss(args)
    override this.WithArguments(args : Arguments<Symbol>) = new CTCLoss(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <summary>Connectionist Temporal Classification Loss.
    /// 
    /// .. note:: The existing alias ``contrib_CTCLoss`` is deprecated.
    /// 
    /// The shapes of the inputs and outputs:
    /// 
    /// - **data**: `(sequence_length, batch_size, alphabet_size)`
    /// - **label**: `(batch_size, label_sequence_length)`
    /// - **out**: `(batch_size)`
    /// 
    /// The `data` tensor consists of sequences of activation vectors (without applying softmax),
    /// with i-th channel in the last dimension corresponding to i-th label
    /// for i between 0 and alphabet_size-1 (i.e always 0-indexed).
    /// Alphabet size should include one additional value reserved for blank label.
    /// When `blank_label` is ``&quot;first&quot;``, the ``0``-th channel is be reserved for
    /// activation of blank label, or otherwise if it is &quot;last&quot;, ``(alphabet_size-1)``-th channel should be
    /// reserved for blank label.
    /// 
    /// ``label`` is an index matrix of integers. When `blank_label` is ``&quot;first&quot;``,
    /// the value 0 is then reserved for blank label, and should not be passed in this matrix. Otherwise,
    /// when `blank_label` is ``&quot;last&quot;``, the value `(alphabet_size-1)` is reserved for blank label.
    /// 
    /// If a sequence of labels is shorter than *label_sequence_length*, use the special
    /// padding value at the end of the sequence to conform it to the correct
    /// length. The padding value is `0` when `blank_label` is ``&quot;first&quot;``, and `-1` otherwise.
    /// 
    /// For example, suppose the vocabulary is `[a, b, c]`, and in one batch we have three sequences
    /// &#39;ba&#39;, &#39;cbb&#39;, and &#39;abac&#39;. When `blank_label` is ``&quot;first&quot;``, we can index the labels as
    /// `{&#39;a&#39;: 1, &#39;b&#39;: 2, &#39;c&#39;: 3}`, and we reserve the 0-th channel for blank label in data tensor.
    /// The resulting `label` tensor should be padded to be::
    /// 
    ///   [[2, 1, 0, 0], [3, 2, 2, 0], [1, 2, 1, 3]]
    /// 
    /// When `blank_label` is ``&quot;last&quot;``, we can index the labels as
    /// `{&#39;a&#39;: 0, &#39;b&#39;: 1, &#39;c&#39;: 2}`, and we reserve the channel index 3 for blank label in data tensor.
    /// The resulting `label` tensor should be padded to be::
    /// 
    ///   [[1, 0, -1, -1], [2, 1, 1, -1], [0, 1, 0, 2]]
    /// 
    /// ``out`` is a list of CTC loss values, one per example in the batch.
    /// 
    /// See *Connectionist Temporal Classification: Labelling Unsegmented
    /// Sequence Data with Recurrent Neural Networks*, A. Graves *et al*. for more
    /// information on the definition and the algorithm.
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\nn\ctc_loss.cc:L100</summary>
    /// <param name="data">Input ndarray</param>
    /// <param name="label">Ground-truth labels for the loss.</param>
    /// <param name="dataLengths">Lengths of data for each of the samples. Only required when use_data_lengths is true.</param>
    /// <param name="labelLengths">Lengths of labels for each of the samples. Only required when use_label_lengths is true.</param>
    /// <param name="useDataLengths">Whether the data lenghts are decided by `data_lengths`. If false, the lengths are equal to the max sequence length.</param>
    /// <param name="useLabelLengths">Whether the label lenghts are decided by `label_lengths`, or derived from `padding_mask`. If false, the lengths are derived from the first occurrence of the value of `padding_mask`. The value of `padding_mask` is ``0`` when first CTC label is reserved for blank, and ``-1`` when last label is reserved for blank. See `blank_label`.</param>
    /// <param name="blankLabel">Set the label that is reserved for blank label.If &quot;first&quot;, 0-th label is reserved, and label values for tokens in the vocabulary are between ``1`` and ``alphabet_size-1``, and the padding mask is ``-1``. If &quot;last&quot;, last label value ``alphabet_size-1`` is reserved for blank label instead, and label values for tokens in the vocabulary are between ``0`` and ``alphabet_size-2``, and the padding mask is ``0``.</param>
    new([<Optional>] ?data : Symbol,
        [<Optional>] ?label : Symbol,
        [<Optional>] ?dataLengths : Symbol,
        [<Optional>] ?labelLengths : Symbol,
        [<Optional>] ?useDataLengths : bool,
        [<Optional>] ?useLabelLengths : bool,
        [<Optional>] ?blankLabel : BlankLabel) = 
        let data = defaultArg data (new ImplicitVariable() :> Symbol)
        let label = defaultArg label (new ImplicitVariable() :> Symbol)
        let dataLengths = defaultArg dataLengths (new ImplicitVariable() :> Symbol)
        let labelLengths = defaultArg labelLengths (new ImplicitVariable() :> Symbol)
        let operatorArguments = 
            [
                "data", Input data
                "label", Input label
                "data_lengths", Input dataLengths
                "label_lengths", Input labelLengths
                "use_data_lengths", useDataLengths |> Option.map box |> Parameter
                "use_label_lengths", useLabelLengths |> Option.map box |> Parameter
                "blank_label", blankLabel |> Option.map box |> Parameter
            ]
        new CTCLoss(Arguments<Symbol>(operatorArguments))
    /// Default value for UseDataLengths
    /// Whether the data lenghts are decided by `data_lengths`. If false, the lengths are equal to the max sequence length.
    static member UseDataLengthsDefault : bool = false
    /// Default value for UseLabelLengths
    /// Whether the label lenghts are decided by `label_lengths`, or derived from `padding_mask`. If false, the lengths are derived from the first occurrence of the value of `padding_mask`. The value of `padding_mask` is ``0`` when first CTC label is reserved for blank, and ``-1`` when last label is reserved for blank. See `blank_label`.
    static member UseLabelLengthsDefault : bool = false
    /// Default value for BlankLabel
    /// Set the label that is reserved for blank label.If &quot;first&quot;, 0-th label is reserved, and label values for tokens in the vocabulary are between ``1`` and ``alphabet_size-1``, and the padding mask is ``-1``. If &quot;last&quot;, last label value ``alphabet_size-1`` is reserved for blank label instead, and label values for tokens in the vocabulary are between ``0`` and ``alphabet_size-2``, and the padding mask is ``0``.
    static member BlankLabelDefault : BlankLabel = BlankLabel.First
    /// Input ndarray
    member __.Data = operatorArguments.GetInput "data"
    /// Ground-truth labels for the loss.
    member __.Label = operatorArguments.GetInput "label"
    /// Lengths of data for each of the samples. Only required when use_data_lengths is true.
    member __.DataLengths = operatorArguments.GetInput "data_lengths"
    /// Lengths of labels for each of the samples. Only required when use_label_lengths is true.
    member __.LabelLengths = operatorArguments.GetInput "label_lengths"
    /// Whether the data lenghts are decided by `data_lengths`. If false, the lengths are equal to the max sequence length.
    member __.UseDataLengths = operatorArguments.GetParameter("use_data_lengths", CTCLoss.UseDataLengthsDefault)
    /// Whether the label lenghts are decided by `label_lengths`, or derived from `padding_mask`. If false, the lengths are derived from the first occurrence of the value of `padding_mask`. The value of `padding_mask` is ``0`` when first CTC label is reserved for blank, and ``-1`` when last label is reserved for blank. See `blank_label`.
    member __.UseLabelLengths = operatorArguments.GetParameter("use_label_lengths", CTCLoss.UseLabelLengthsDefault)
    /// Set the label that is reserved for blank label.If &quot;first&quot;, 0-th label is reserved, and label values for tokens in the vocabulary are between ``1`` and ``alphabet_size-1``, and the padding mask is ``-1``. If &quot;last&quot;, last label value ``alphabet_size-1`` is reserved for blank label instead, and label values for tokens in the vocabulary are between ``0`` and ``alphabet_size-2``, and the padding mask is ``0``.
    member __.BlankLabel = operatorArguments.GetParameter("blank_label", CTCLoss.BlankLabelDefault)
    /// <summary>Copy CTCLoss instance with updated inputs/parameters.</summary>
    /// <param name="data">Input ndarray</param>
    /// <param name="label">Ground-truth labels for the loss.</param>
    /// <param name="dataLengths">Lengths of data for each of the samples. Only required when use_data_lengths is true.</param>
    /// <param name="labelLengths">Lengths of labels for each of the samples. Only required when use_label_lengths is true.</param>
    /// <param name="useDataLengths">Whether the data lenghts are decided by `data_lengths`. If false, the lengths are equal to the max sequence length.</param>
    /// <param name="useLabelLengths">Whether the label lenghts are decided by `label_lengths`, or derived from `padding_mask`. If false, the lengths are derived from the first occurrence of the value of `padding_mask`. The value of `padding_mask` is ``0`` when first CTC label is reserved for blank, and ``-1`` when last label is reserved for blank. See `blank_label`.</param>
    /// <param name="blankLabel">Set the label that is reserved for blank label.If &quot;first&quot;, 0-th label is reserved, and label values for tokens in the vocabulary are between ``1`` and ``alphabet_size-1``, and the padding mask is ``-1``. If &quot;last&quot;, last label value ``alphabet_size-1`` is reserved for blank label instead, and label values for tokens in the vocabulary are between ``0`` and ``alphabet_size-2``, and the padding mask is ``0``.</param>
    member this.With([<Optional>] ?data : Symbol,
        [<Optional>] ?label : Symbol,
        [<Optional>] ?dataLengths : Symbol,
        [<Optional>] ?labelLengths : Symbol,
        [<Optional>] ?useDataLengths : bool,
        [<Optional>] ?useLabelLengths : bool,
        [<Optional>] ?blankLabel : BlankLabel) = 
        let operatorArguments = 
            [
                data |> Option.map (fun x -> "data", Input x)
                label |> Option.map (fun x -> "label", Input x)
                dataLengths |> Option.map (fun x -> "data_lengths", Input x)
                labelLengths |> Option.map (fun x -> "label_lengths", Input x)
                useDataLengths |> Option.map (fun x -> "use_data_lengths", Parameter(Some (box x)))
                useLabelLengths |> Option.map (fun x -> "use_label_lengths", Parameter(Some (box x)))
                blankLabel |> Option.map (fun x -> "blank_label", Parameter(Some (box x)))
            ] |> List.choose id
        new CTCLoss(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type CuDNNBatchNorm private (operatorArguments) = 
    inherit SymbolOperator("CuDNNBatchNorm", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new CuDNNBatchNorm(args)
    override this.WithArguments(args : Arguments<Symbol>) = new CuDNNBatchNorm(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <summary>Apply batch normalization to input.</summary>
    /// <param name="data">Input data to batch normalization</param>
    /// <param name="gamma">gamma array</param>
    /// <param name="beta">beta array</param>
    /// <param name="movingMean">running mean of input</param>
    /// <param name="movingVar">running variance of input</param>
    /// <param name="eps">Epsilon to prevent div 0. Must be no less than CUDNN_BN_MIN_EPSILON defined in cudnn.h when using cudnn (usually 1e-5)</param>
    /// <param name="momentum">Momentum for moving average</param>
    /// <param name="fixGamma">Fix gamma while training</param>
    /// <param name="useGlobalStats">Whether use global moving statistics instead of local batch-norm. This will force change batch-norm into a scale shift operator.</param>
    /// <param name="outputMeanVar">Output the mean and inverse std </param>
    /// <param name="axis">Specify which shape axis the channel is specified</param>
    /// <param name="cudnnOff">Do not select CUDNN operator, if available</param>
    /// <param name="minCalibRange">The minimum scalar value in the form of float32 obtained through calibration. If present, it will be used to by quantized batch norm op to calculate primitive scale.Note: this calib_range is to calib bn output.</param>
    /// <param name="maxCalibRange">The maximum scalar value in the form of float32 obtained through calibration. If present, it will be used to by quantized batch norm op to calculate primitive scale.Note: this calib_range is to calib bn output.</param>
    new([<Optional>] ?data : Symbol,
        [<Optional>] ?gamma : Symbol,
        [<Optional>] ?beta : Symbol,
        [<Optional>] ?movingMean : Symbol,
        [<Optional>] ?movingVar : Symbol,
        [<Optional>] ?eps : double,
        [<Optional>] ?momentum : float,
        [<Optional>] ?fixGamma : bool,
        [<Optional>] ?useGlobalStats : bool,
        [<Optional>] ?outputMeanVar : bool,
        [<Optional>] ?axis : int,
        [<Optional>] ?cudnnOff : bool,
        [<Optional>] ?minCalibRange : float,
        [<Optional>] ?maxCalibRange : float) = 
        let data = defaultArg data (new ImplicitVariable() :> Symbol)
        let gamma = defaultArg gamma (new ImplicitVariable() :> Symbol)
        let beta = defaultArg beta (new ImplicitVariable() :> Symbol)
        let movingMean = defaultArg movingMean (new ImplicitVariable() :> Symbol)
        let movingVar = defaultArg movingVar (new ImplicitVariable() :> Symbol)
        let operatorArguments = 
            [
                "data", Input data
                "gamma", Input gamma
                "beta", Input beta
                "moving_mean", Input movingMean
                "moving_var", Input movingVar
                "eps", eps |> Option.map box |> Parameter
                "momentum", momentum |> Option.map box |> Parameter
                "fix_gamma", fixGamma |> Option.map box |> Parameter
                "use_global_stats", useGlobalStats |> Option.map box |> Parameter
                "output_mean_var", outputMeanVar |> Option.map box |> Parameter
                "axis", axis |> Option.map box |> Parameter
                "cudnn_off", cudnnOff |> Option.map box |> Parameter
                "min_calib_range", minCalibRange |> Option.map box |> Parameter
                "max_calib_range", maxCalibRange |> Option.map box |> Parameter
            ]
        new CuDNNBatchNorm(Arguments<Symbol>(operatorArguments))
    /// Default value for Eps
    /// Epsilon to prevent div 0. Must be no less than CUDNN_BN_MIN_EPSILON defined in cudnn.h when using cudnn (usually 1e-5)
    static member EpsDefault : double = 0.0010000000474975
    /// Default value for Momentum
    /// Momentum for moving average
    static member MomentumDefault : double = 0.899999976
    /// Default value for FixGamma
    /// Fix gamma while training
    static member FixGammaDefault : bool = true
    /// Default value for UseGlobalStats
    /// Whether use global moving statistics instead of local batch-norm. This will force change batch-norm into a scale shift operator.
    static member UseGlobalStatsDefault : bool = false
    /// Default value for OutputMeanVar
    /// Output the mean and inverse std 
    static member OutputMeanVarDefault : bool = false
    /// Default value for Axis
    /// Specify which shape axis the channel is specified
    static member AxisDefault : int = 1
    /// Default value for CudnnOff
    /// Do not select CUDNN operator, if available
    static member CudnnOffDefault : bool = false
    /// Default value for MinCalibRange
    /// The minimum scalar value in the form of float32 obtained through calibration. If present, it will be used to by quantized batch norm op to calculate primitive scale.Note: this calib_range is to calib bn output.
    static member MinCalibRangeDefault : double option = None
    /// Default value for MaxCalibRange
    /// The maximum scalar value in the form of float32 obtained through calibration. If present, it will be used to by quantized batch norm op to calculate primitive scale.Note: this calib_range is to calib bn output.
    static member MaxCalibRangeDefault : double option = None
    /// Input data to batch normalization
    member __.Data = operatorArguments.GetInput "data"
    /// gamma array
    member __.Gamma = operatorArguments.GetInput "gamma"
    /// beta array
    member __.Beta = operatorArguments.GetInput "beta"
    /// running mean of input
    member __.MovingMean = operatorArguments.GetInput "moving_mean"
    /// running variance of input
    member __.MovingVar = operatorArguments.GetInput "moving_var"
    /// Epsilon to prevent div 0. Must be no less than CUDNN_BN_MIN_EPSILON defined in cudnn.h when using cudnn (usually 1e-5)
    member __.Eps = operatorArguments.GetParameter("eps", CuDNNBatchNorm.EpsDefault)
    /// Momentum for moving average
    member __.Momentum = operatorArguments.GetParameter("momentum", CuDNNBatchNorm.MomentumDefault)
    /// Fix gamma while training
    member __.FixGamma = operatorArguments.GetParameter("fix_gamma", CuDNNBatchNorm.FixGammaDefault)
    /// Whether use global moving statistics instead of local batch-norm. This will force change batch-norm into a scale shift operator.
    member __.UseGlobalStats = operatorArguments.GetParameter("use_global_stats", CuDNNBatchNorm.UseGlobalStatsDefault)
    /// Output the mean and inverse std 
    member __.OutputMeanVar = operatorArguments.GetParameter("output_mean_var", CuDNNBatchNorm.OutputMeanVarDefault)
    /// Specify which shape axis the channel is specified
    member __.Axis = operatorArguments.GetParameter("axis", CuDNNBatchNorm.AxisDefault)
    /// Do not select CUDNN operator, if available
    member __.CudnnOff = operatorArguments.GetParameter("cudnn_off", CuDNNBatchNorm.CudnnOffDefault)
    /// The minimum scalar value in the form of float32 obtained through calibration. If present, it will be used to by quantized batch norm op to calculate primitive scale.Note: this calib_range is to calib bn output.
    member __.MinCalibRange = operatorArguments.GetParameter("min_calib_range", CuDNNBatchNorm.MinCalibRangeDefault)
    /// The maximum scalar value in the form of float32 obtained through calibration. If present, it will be used to by quantized batch norm op to calculate primitive scale.Note: this calib_range is to calib bn output.
    member __.MaxCalibRange = operatorArguments.GetParameter("max_calib_range", CuDNNBatchNorm.MaxCalibRangeDefault)
    /// <summary>Copy CuDNNBatchNorm instance with updated inputs/parameters.</summary>
    /// <param name="data">Input data to batch normalization</param>
    /// <param name="gamma">gamma array</param>
    /// <param name="beta">beta array</param>
    /// <param name="movingMean">running mean of input</param>
    /// <param name="movingVar">running variance of input</param>
    /// <param name="eps">Epsilon to prevent div 0. Must be no less than CUDNN_BN_MIN_EPSILON defined in cudnn.h when using cudnn (usually 1e-5)</param>
    /// <param name="momentum">Momentum for moving average</param>
    /// <param name="fixGamma">Fix gamma while training</param>
    /// <param name="useGlobalStats">Whether use global moving statistics instead of local batch-norm. This will force change batch-norm into a scale shift operator.</param>
    /// <param name="outputMeanVar">Output the mean and inverse std </param>
    /// <param name="axis">Specify which shape axis the channel is specified</param>
    /// <param name="cudnnOff">Do not select CUDNN operator, if available</param>
    /// <param name="minCalibRange">The minimum scalar value in the form of float32 obtained through calibration. If present, it will be used to by quantized batch norm op to calculate primitive scale.Note: this calib_range is to calib bn output.</param>
    /// <param name="maxCalibRange">The maximum scalar value in the form of float32 obtained through calibration. If present, it will be used to by quantized batch norm op to calculate primitive scale.Note: this calib_range is to calib bn output.</param>
    member this.With([<Optional>] ?data : Symbol,
        [<Optional>] ?gamma : Symbol,
        [<Optional>] ?beta : Symbol,
        [<Optional>] ?movingMean : Symbol,
        [<Optional>] ?movingVar : Symbol,
        [<Optional>] ?eps : double,
        [<Optional>] ?momentum : float,
        [<Optional>] ?fixGamma : bool,
        [<Optional>] ?useGlobalStats : bool,
        [<Optional>] ?outputMeanVar : bool,
        [<Optional>] ?axis : int,
        [<Optional>] ?cudnnOff : bool,
        [<Optional>] ?minCalibRange : float,
        [<Optional>] ?maxCalibRange : float) = 
        let operatorArguments = 
            [
                data |> Option.map (fun x -> "data", Input x)
                gamma |> Option.map (fun x -> "gamma", Input x)
                beta |> Option.map (fun x -> "beta", Input x)
                movingMean |> Option.map (fun x -> "moving_mean", Input x)
                movingVar |> Option.map (fun x -> "moving_var", Input x)
                eps |> Option.map (fun x -> "eps", Parameter(Some (box x)))
                momentum |> Option.map (fun x -> "momentum", Parameter(Some (box x)))
                fixGamma |> Option.map (fun x -> "fix_gamma", Parameter(Some (box x)))
                useGlobalStats |> Option.map (fun x -> "use_global_stats", Parameter(Some (box x)))
                outputMeanVar |> Option.map (fun x -> "output_mean_var", Parameter(Some (box x)))
                axis |> Option.map (fun x -> "axis", Parameter(Some (box x)))
                cudnnOff |> Option.map (fun x -> "cudnn_off", Parameter(Some (box x)))
                minCalibRange |> Option.map (fun x -> "min_calib_range", Parameter(Some (box x)))
                maxCalibRange |> Option.map (fun x -> "max_calib_range", Parameter(Some (box x)))
            ] |> List.choose id
        new CuDNNBatchNorm(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type Deconvolution private (operatorArguments) = 
    inherit SymbolOperator("Deconvolution", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new Deconvolution(args)
    override this.WithArguments(args : Arguments<Symbol>) = new Deconvolution(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <summary>Computes 1D or 2D transposed convolution (aka fractionally strided convolution) of the input tensor. This operation can be seen as the gradient of Convolution operation with respect to its input. Convolution usually reduces the size of the input. Transposed convolution works the other way, going from a smaller input to a larger output while preserving the connectivity pattern.</summary>
    /// <param name="data">Input tensor to the deconvolution operation.</param>
    /// <param name="weight">Weights representing the kernel.</param>
    /// <param name="bias">Bias added to the result after the deconvolution operation.</param>
    /// <param name="kernel">Deconvolution kernel size: (w,), (h, w) or (d, h, w). This is same as the kernel size used for the corresponding convolution</param>
    /// <param name="numFilter">Number of output filters.</param>
    /// <param name="stride">The stride used for the corresponding convolution: (w,), (h, w) or (d, h, w). Defaults to 1 for each dimension.</param>
    /// <param name="dilate">Dilation factor for each dimension of the input: (w,), (h, w) or (d, h, w). Defaults to 1 for each dimension.</param>
    /// <param name="pad">The amount of implicit zero padding added during convolution for each dimension of the input: (w,), (h, w) or (d, h, w). ``(kernel-1)/2`` is usually a good choice. If `target_shape` is set, `pad` will be ignored and a padding that will generate the target shape will be used. Defaults to no padding.</param>
    /// <param name="adj">Adjustment for output shape: (w,), (h, w) or (d, h, w). If `target_shape` is set, `adj` will be ignored and computed accordingly.</param>
    /// <param name="targetShape">Shape of the output tensor: (w,), (h, w) or (d, h, w).</param>
    /// <param name="numGroup">Number of groups partition.</param>
    /// <param name="workspace">Maximum temporary workspace allowed (MB) in deconvolution.This parameter has two usages. When CUDNN is not used, it determines the effective batch size of the deconvolution kernel. When CUDNN is used, it controls the maximum temporary storage used for tuning the best CUDNN kernel when `limited_workspace` strategy is used.</param>
    /// <param name="noBias">Whether to disable bias parameter.</param>
    /// <param name="cudnnTune">Whether to pick convolution algorithm by running performance test.</param>
    /// <param name="cudnnOff">Turn off cudnn for this layer.</param>
    /// <param name="layout">Set layout for input, output and weight. Empty for default layout, NCW for 1d, NCHW for 2d and NCDHW for 3d.NHWC and NDHWC are only supported on GPU.</param>
    new(data : Symbol,
        weight : Symbol,
        bias : Symbol,
        kernel : int seq,
        numFilter : int,
        [<Optional>] ?stride : int seq,
        [<Optional>] ?dilate : int seq,
        [<Optional>] ?pad : int seq,
        [<Optional>] ?adj : int seq,
        [<Optional>] ?targetShape : int seq,
        [<Optional>] ?numGroup : int,
        [<Optional>] ?workspace : int64,
        [<Optional>] ?noBias : bool,
        [<Optional>] ?cudnnTune : CudnnTune,
        [<Optional>] ?cudnnOff : bool,
        [<Optional>] ?layout : DeconvolutionLayout) = 
        let operatorArguments = 
            [
                "data", Input data
                "weight", Input weight
                "bias", Input bias
                "kernel", Parameter(Some(box kernel))
                "num_filter", Parameter(Some(box numFilter))
                "stride", stride |> Option.map box |> Parameter
                "dilate", dilate |> Option.map box |> Parameter
                "pad", pad |> Option.map box |> Parameter
                "adj", adj |> Option.map box |> Parameter
                "target_shape", targetShape |> Option.map box |> Parameter
                "num_group", numGroup |> Option.map box |> Parameter
                "workspace", workspace |> Option.map box |> Parameter
                "no_bias", noBias |> Option.map box |> Parameter
                "cudnn_tune", cudnnTune |> Option.map box |> Parameter
                "cudnn_off", cudnnOff |> Option.map box |> Parameter
                "layout", layout |> Option.map box |> Parameter
            ]
        new Deconvolution(Arguments<Symbol>(operatorArguments))
    /// <summary>Computes 1D or 2D transposed convolution (aka fractionally strided convolution) of the input tensor. This operation can be seen as the gradient of Convolution operation with respect to its input. Convolution usually reduces the size of the input. Transposed convolution works the other way, going from a smaller input to a larger output while preserving the connectivity pattern.</summary>
    /// <param name="kernel">Deconvolution kernel size: (w,), (h, w) or (d, h, w). This is same as the kernel size used for the corresponding convolution</param>
    /// <param name="numFilter">Number of output filters.</param>
    /// <param name="data">Input tensor to the deconvolution operation.</param>
    /// <param name="weight">Weights representing the kernel.</param>
    /// <param name="bias">Bias added to the result after the deconvolution operation.</param>
    /// <param name="stride">The stride used for the corresponding convolution: (w,), (h, w) or (d, h, w). Defaults to 1 for each dimension.</param>
    /// <param name="dilate">Dilation factor for each dimension of the input: (w,), (h, w) or (d, h, w). Defaults to 1 for each dimension.</param>
    /// <param name="pad">The amount of implicit zero padding added during convolution for each dimension of the input: (w,), (h, w) or (d, h, w). ``(kernel-1)/2`` is usually a good choice. If `target_shape` is set, `pad` will be ignored and a padding that will generate the target shape will be used. Defaults to no padding.</param>
    /// <param name="adj">Adjustment for output shape: (w,), (h, w) or (d, h, w). If `target_shape` is set, `adj` will be ignored and computed accordingly.</param>
    /// <param name="targetShape">Shape of the output tensor: (w,), (h, w) or (d, h, w).</param>
    /// <param name="numGroup">Number of groups partition.</param>
    /// <param name="workspace">Maximum temporary workspace allowed (MB) in deconvolution.This parameter has two usages. When CUDNN is not used, it determines the effective batch size of the deconvolution kernel. When CUDNN is used, it controls the maximum temporary storage used for tuning the best CUDNN kernel when `limited_workspace` strategy is used.</param>
    /// <param name="noBias">Whether to disable bias parameter.</param>
    /// <param name="cudnnTune">Whether to pick convolution algorithm by running performance test.</param>
    /// <param name="cudnnOff">Turn off cudnn for this layer.</param>
    /// <param name="layout">Set layout for input, output and weight. Empty for default layout, NCW for 1d, NCHW for 2d and NCDHW for 3d.NHWC and NDHWC are only supported on GPU.</param>
    new(kernel : int seq,
        numFilter : int,
        [<Optional>] ?data : Symbol,
        [<Optional>] ?weight : Symbol,
        [<Optional>] ?bias : Symbol,
        [<Optional>] ?stride : int seq,
        [<Optional>] ?dilate : int seq,
        [<Optional>] ?pad : int seq,
        [<Optional>] ?adj : int seq,
        [<Optional>] ?targetShape : int seq,
        [<Optional>] ?numGroup : int,
        [<Optional>] ?workspace : int64,
        [<Optional>] ?noBias : bool,
        [<Optional>] ?cudnnTune : CudnnTune,
        [<Optional>] ?cudnnOff : bool,
        [<Optional>] ?layout : DeconvolutionLayout) = 
        let data = defaultArg data (new ImplicitVariable() :> Symbol)
        let weight = defaultArg weight (new ImplicitVariable() :> Symbol)
        let bias = defaultArg bias (new ImplicitVariable() :> Symbol)
        let operatorArguments = 
            [
                "data", Input data
                "weight", Input weight
                "bias", Input bias
                "kernel", Parameter(Some(box kernel))
                "num_filter", Parameter(Some(box numFilter))
                "stride", stride |> Option.map box |> Parameter
                "dilate", dilate |> Option.map box |> Parameter
                "pad", pad |> Option.map box |> Parameter
                "adj", adj |> Option.map box |> Parameter
                "target_shape", targetShape |> Option.map box |> Parameter
                "num_group", numGroup |> Option.map box |> Parameter
                "workspace", workspace |> Option.map box |> Parameter
                "no_bias", noBias |> Option.map box |> Parameter
                "cudnn_tune", cudnnTune |> Option.map box |> Parameter
                "cudnn_off", cudnnOff |> Option.map box |> Parameter
                "layout", layout |> Option.map box |> Parameter
            ]
        new Deconvolution(Arguments<Symbol>(operatorArguments))
    /// Default value for Stride
    /// The stride used for the corresponding convolution: (w,), (h, w) or (d, h, w). Defaults to 1 for each dimension.
    static member StrideDefault : int [] = [||]
    /// Default value for Dilate
    /// Dilation factor for each dimension of the input: (w,), (h, w) or (d, h, w). Defaults to 1 for each dimension.
    static member DilateDefault : int [] = [||]
    /// Default value for Pad
    /// The amount of implicit zero padding added during convolution for each dimension of the input: (w,), (h, w) or (d, h, w). ``(kernel-1)/2`` is usually a good choice. If `target_shape` is set, `pad` will be ignored and a padding that will generate the target shape will be used. Defaults to no padding.
    static member PadDefault : int [] = [||]
    /// Default value for Adj
    /// Adjustment for output shape: (w,), (h, w) or (d, h, w). If `target_shape` is set, `adj` will be ignored and computed accordingly.
    static member AdjDefault : int [] = [||]
    /// Default value for TargetShape
    /// Shape of the output tensor: (w,), (h, w) or (d, h, w).
    static member TargetShapeDefault : int [] = [||]
    /// Default value for NumGroup
    /// Number of groups partition.
    static member NumGroupDefault : int = 1
    /// Default value for Workspace
    /// Maximum temporary workspace allowed (MB) in deconvolution.This parameter has two usages. When CUDNN is not used, it determines the effective batch size of the deconvolution kernel. When CUDNN is used, it controls the maximum temporary storage used for tuning the best CUDNN kernel when `limited_workspace` strategy is used.
    static member WorkspaceDefault : int64 = 512L
    /// Default value for NoBias
    /// Whether to disable bias parameter.
    static member NoBiasDefault : bool = true
    /// Default value for CudnnTune
    /// Whether to pick convolution algorithm by running performance test.
    static member CudnnTuneDefault : CudnnTune option = None
    /// Default value for CudnnOff
    /// Turn off cudnn for this layer.
    static member CudnnOffDefault : bool = false
    /// Default value for Layout
    /// Set layout for input, output and weight. Empty for default layout, NCW for 1d, NCHW for 2d and NCDHW for 3d.NHWC and NDHWC are only supported on GPU.
    static member LayoutDefault : DeconvolutionLayout option = None
    /// Input tensor to the deconvolution operation.
    member __.Data = operatorArguments.GetInput "data"
    /// Weights representing the kernel.
    member __.Weight = operatorArguments.GetInput "weight"
    /// Bias added to the result after the deconvolution operation.
    member __.Bias = operatorArguments.GetInput "bias"
    /// Deconvolution kernel size: (w,), (h, w) or (d, h, w). This is same as the kernel size used for the corresponding convolution
    member __.Kernel : int seq = match operatorArguments.GetParameter "kernel" with Some(v) -> unbox v | None -> failwithf "Required parameter kernel is missing"
    /// Number of output filters.
    member __.NumFilter : int = match operatorArguments.GetParameter "num_filter" with Some(v) -> unbox v | None -> failwithf "Required parameter num_filter is missing"
    /// The stride used for the corresponding convolution: (w,), (h, w) or (d, h, w). Defaults to 1 for each dimension.
    member __.Stride = operatorArguments.GetParameter("stride", Deconvolution.StrideDefault)
    /// Dilation factor for each dimension of the input: (w,), (h, w) or (d, h, w). Defaults to 1 for each dimension.
    member __.Dilate = operatorArguments.GetParameter("dilate", Deconvolution.DilateDefault)
    /// The amount of implicit zero padding added during convolution for each dimension of the input: (w,), (h, w) or (d, h, w). ``(kernel-1)/2`` is usually a good choice. If `target_shape` is set, `pad` will be ignored and a padding that will generate the target shape will be used. Defaults to no padding.
    member __.Pad = operatorArguments.GetParameter("pad", Deconvolution.PadDefault)
    /// Adjustment for output shape: (w,), (h, w) or (d, h, w). If `target_shape` is set, `adj` will be ignored and computed accordingly.
    member __.Adj = operatorArguments.GetParameter("adj", Deconvolution.AdjDefault)
    /// Shape of the output tensor: (w,), (h, w) or (d, h, w).
    member __.TargetShape = operatorArguments.GetParameter("target_shape", Deconvolution.TargetShapeDefault)
    /// Number of groups partition.
    member __.NumGroup = operatorArguments.GetParameter("num_group", Deconvolution.NumGroupDefault)
    /// Maximum temporary workspace allowed (MB) in deconvolution.This parameter has two usages. When CUDNN is not used, it determines the effective batch size of the deconvolution kernel. When CUDNN is used, it controls the maximum temporary storage used for tuning the best CUDNN kernel when `limited_workspace` strategy is used.
    member __.Workspace = operatorArguments.GetParameter("workspace", Deconvolution.WorkspaceDefault)
    /// Whether to disable bias parameter.
    member __.NoBias = operatorArguments.GetParameter("no_bias", Deconvolution.NoBiasDefault)
    /// Whether to pick convolution algorithm by running performance test.
    member __.CudnnTune = operatorArguments.GetParameter("cudnn_tune", Deconvolution.CudnnTuneDefault)
    /// Turn off cudnn for this layer.
    member __.CudnnOff = operatorArguments.GetParameter("cudnn_off", Deconvolution.CudnnOffDefault)
    /// Set layout for input, output and weight. Empty for default layout, NCW for 1d, NCHW for 2d and NCDHW for 3d.NHWC and NDHWC are only supported on GPU.
    member __.Layout = operatorArguments.GetParameter("layout", Deconvolution.LayoutDefault)
    /// <summary>Copy Deconvolution instance with updated inputs/parameters.</summary>
    /// <param name="data">Input tensor to the deconvolution operation.</param>
    /// <param name="weight">Weights representing the kernel.</param>
    /// <param name="bias">Bias added to the result after the deconvolution operation.</param>
    /// <param name="kernel">Deconvolution kernel size: (w,), (h, w) or (d, h, w). This is same as the kernel size used for the corresponding convolution</param>
    /// <param name="numFilter">Number of output filters.</param>
    /// <param name="stride">The stride used for the corresponding convolution: (w,), (h, w) or (d, h, w). Defaults to 1 for each dimension.</param>
    /// <param name="dilate">Dilation factor for each dimension of the input: (w,), (h, w) or (d, h, w). Defaults to 1 for each dimension.</param>
    /// <param name="pad">The amount of implicit zero padding added during convolution for each dimension of the input: (w,), (h, w) or (d, h, w). ``(kernel-1)/2`` is usually a good choice. If `target_shape` is set, `pad` will be ignored and a padding that will generate the target shape will be used. Defaults to no padding.</param>
    /// <param name="adj">Adjustment for output shape: (w,), (h, w) or (d, h, w). If `target_shape` is set, `adj` will be ignored and computed accordingly.</param>
    /// <param name="targetShape">Shape of the output tensor: (w,), (h, w) or (d, h, w).</param>
    /// <param name="numGroup">Number of groups partition.</param>
    /// <param name="workspace">Maximum temporary workspace allowed (MB) in deconvolution.This parameter has two usages. When CUDNN is not used, it determines the effective batch size of the deconvolution kernel. When CUDNN is used, it controls the maximum temporary storage used for tuning the best CUDNN kernel when `limited_workspace` strategy is used.</param>
    /// <param name="noBias">Whether to disable bias parameter.</param>
    /// <param name="cudnnTune">Whether to pick convolution algorithm by running performance test.</param>
    /// <param name="cudnnOff">Turn off cudnn for this layer.</param>
    /// <param name="layout">Set layout for input, output and weight. Empty for default layout, NCW for 1d, NCHW for 2d and NCDHW for 3d.NHWC and NDHWC are only supported on GPU.</param>
    member this.With([<Optional>] ?data : Symbol,
        [<Optional>] ?weight : Symbol,
        [<Optional>] ?bias : Symbol,
        [<Optional>] ?kernel : int seq,
        [<Optional>] ?numFilter : int,
        [<Optional>] ?stride : int seq,
        [<Optional>] ?dilate : int seq,
        [<Optional>] ?pad : int seq,
        [<Optional>] ?adj : int seq,
        [<Optional>] ?targetShape : int seq,
        [<Optional>] ?numGroup : int,
        [<Optional>] ?workspace : int64,
        [<Optional>] ?noBias : bool,
        [<Optional>] ?cudnnTune : CudnnTune,
        [<Optional>] ?cudnnOff : bool,
        [<Optional>] ?layout : DeconvolutionLayout) = 
        let operatorArguments = 
            [
                data |> Option.map (fun x -> "data", Input x)
                weight |> Option.map (fun x -> "weight", Input x)
                bias |> Option.map (fun x -> "bias", Input x)
                kernel |> Option.map (fun x -> "kernel", Parameter(Some (box x)))
                numFilter |> Option.map (fun x -> "num_filter", Parameter(Some (box x)))
                stride |> Option.map (fun x -> "stride", Parameter(Some (box x)))
                dilate |> Option.map (fun x -> "dilate", Parameter(Some (box x)))
                pad |> Option.map (fun x -> "pad", Parameter(Some (box x)))
                adj |> Option.map (fun x -> "adj", Parameter(Some (box x)))
                targetShape |> Option.map (fun x -> "target_shape", Parameter(Some (box x)))
                numGroup |> Option.map (fun x -> "num_group", Parameter(Some (box x)))
                workspace |> Option.map (fun x -> "workspace", Parameter(Some (box x)))
                noBias |> Option.map (fun x -> "no_bias", Parameter(Some (box x)))
                cudnnTune |> Option.map (fun x -> "cudnn_tune", Parameter(Some (box x)))
                cudnnOff |> Option.map (fun x -> "cudnn_off", Parameter(Some (box x)))
                layout |> Option.map (fun x -> "layout", Parameter(Some (box x)))
            ] |> List.choose id
        new Deconvolution(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type Dropout private (operatorArguments) = 
    inherit SymbolOperator("Dropout", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new Dropout(args)
    override this.WithArguments(args : Arguments<Symbol>) = new Dropout(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <summary>Applies dropout operation to input array.
    /// 
    /// - During training, each element of the input is set to zero with probability p.
    ///   The whole array is rescaled by :math:`1/(1-p)` to keep the expected
    ///   sum of the input unchanged.
    /// 
    /// - During testing, this operator does not change the input if mode is &#39;training&#39;.
    ///   If mode is &#39;always&#39;, the same computaion as during training will be applied.
    /// 
    /// Example::
    /// 
    ///   random.seed(998)
    ///   input_array = array([[3., 0.5,  -0.5,  2., 7.],
    ///                       [2., -0.4,   7.,  3., 0.2]])
    ///   a = symbol.Variable(&#39;a&#39;)
    ///   dropout = symbol.Dropout(a, p = 0.2)
    ///   executor = dropout.simple_bind(a = input_array.shape)
    /// 
    ///   ## If training
    ///   executor.forward(is_train = True, a = input_array)
    ///   executor.outputs
    ///   [[ 3.75   0.625 -0.     2.5    8.75 ]
    ///    [ 2.5   -0.5    8.75   3.75   0.   ]]
    /// 
    ///   ## If testing
    ///   executor.forward(is_train = False, a = input_array)
    ///   executor.outputs
    ///   [[ 3.     0.5   -0.5    2.     7.   ]
    ///    [ 2.    -0.4    7.     3.     0.2  ]]
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\nn\dropout.cc:L96</summary>
    /// <param name="data">Input array to which dropout will be applied.</param>
    /// <param name="p">Fraction of the input that gets dropped out during training time.</param>
    /// <param name="mode">Whether to only turn on dropout during training or to also turn on for inference.</param>
    /// <param name="axes">Axes for variational dropout kernel.</param>
    /// <param name="cudnnOff">Whether to turn off cudnn in dropout operator. This option is ignored if axes is specified.</param>
    new([<Optional>] ?data : Symbol,
        [<Optional>] ?p : float,
        [<Optional>] ?mode : DropoutMode,
        [<Optional>] ?axes : int seq,
        [<Optional>] ?cudnnOff : bool) = 
        let data = defaultArg data (new ImplicitVariable() :> Symbol)
        let operatorArguments = 
            [
                "data", Input data
                "p", p |> Option.map box |> Parameter
                "mode", mode |> Option.map box |> Parameter
                "axes", axes |> Option.map box |> Parameter
                "cudnn_off", cudnnOff |> Option.map box |> Parameter
            ]
        new Dropout(Arguments<Symbol>(operatorArguments))
    /// Default value for P
    /// Fraction of the input that gets dropped out during training time.
    static member PDefault : double = 0.5
    /// Default value for Mode
    /// Whether to only turn on dropout during training or to also turn on for inference.
    static member ModeDefault : DropoutMode = DropoutMode.Training
    /// Default value for Axes
    /// Axes for variational dropout kernel.
    static member AxesDefault : int [] = [||]
    /// Default value for CudnnOff
    /// Whether to turn off cudnn in dropout operator. This option is ignored if axes is specified.
    static member CudnnOffDefault : bool option = Some(false)
    /// Input array to which dropout will be applied.
    member __.Data = operatorArguments.GetInput "data"
    /// Fraction of the input that gets dropped out during training time.
    member __.P = operatorArguments.GetParameter("p", Dropout.PDefault)
    /// Whether to only turn on dropout during training or to also turn on for inference.
    member __.Mode = operatorArguments.GetParameter("mode", Dropout.ModeDefault)
    /// Axes for variational dropout kernel.
    member __.Axes = operatorArguments.GetParameter("axes", Dropout.AxesDefault)
    /// Whether to turn off cudnn in dropout operator. This option is ignored if axes is specified.
    member __.CudnnOff = operatorArguments.GetParameter("cudnn_off", Dropout.CudnnOffDefault)
    /// <summary>Copy Dropout instance with updated inputs/parameters.</summary>
    /// <param name="data">Input array to which dropout will be applied.</param>
    /// <param name="p">Fraction of the input that gets dropped out during training time.</param>
    /// <param name="mode">Whether to only turn on dropout during training or to also turn on for inference.</param>
    /// <param name="axes">Axes for variational dropout kernel.</param>
    /// <param name="cudnnOff">Whether to turn off cudnn in dropout operator. This option is ignored if axes is specified.</param>
    member this.With([<Optional>] ?data : Symbol,
        [<Optional>] ?p : float,
        [<Optional>] ?mode : DropoutMode,
        [<Optional>] ?axes : int seq,
        [<Optional>] ?cudnnOff : bool) = 
        let operatorArguments = 
            [
                data |> Option.map (fun x -> "data", Input x)
                p |> Option.map (fun x -> "p", Parameter(Some (box x)))
                mode |> Option.map (fun x -> "mode", Parameter(Some (box x)))
                axes |> Option.map (fun x -> "axes", Parameter(Some (box x)))
                cudnnOff |> Option.map (fun x -> "cudnn_off", Parameter(Some (box x)))
            ] |> List.choose id
        new Dropout(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type FullyConnected private (operatorArguments) = 
    inherit SymbolOperator("FullyConnected", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new FullyConnected(args)
    override this.WithArguments(args : Arguments<Symbol>) = new FullyConnected(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <summary>Applies a linear transformation: :math:`Y = XW^T + b`.
    /// 
    /// If ``flatten`` is set to be true, then the shapes are:
    /// 
    /// - **data**: `(batch_size, x1, x2, ..., xn)`
    /// - **weight**: `(num_hidden, x1 * x2 * ... * xn)`
    /// - **bias**: `(num_hidden,)`
    /// - **out**: `(batch_size, num_hidden)`
    /// 
    /// If ``flatten`` is set to be false, then the shapes are:
    /// 
    /// - **data**: `(x1, x2, ..., xn, input_dim)`
    /// - **weight**: `(num_hidden, input_dim)`
    /// - **bias**: `(num_hidden,)`
    /// - **out**: `(x1, x2, ..., xn, num_hidden)`
    /// 
    /// The learnable parameters include both ``weight`` and ``bias``.
    /// 
    /// If ``no_bias`` is set to be true, then the ``bias`` term is ignored.
    /// 
    /// .. Note::
    /// 
    ///     The sparse support for FullyConnected is limited to forward evaluation with `row_sparse`
    ///     weight and bias, where the length of `weight.indices` and `bias.indices` must be equal
    ///     to `num_hidden`. This could be useful for model inference with `row_sparse` weights
    ///     trained with importance sampling or noise contrastive estimation.
    /// 
    ///     To compute linear transformation with &#39;csr&#39; sparse data, sparse.dot is recommended instead
    ///     of sparse.FullyConnected.
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\nn\fully_connected.cc:L288</summary>
    /// <param name="data">Input data.</param>
    /// <param name="weight">Weight matrix.</param>
    /// <param name="bias">Bias parameter.</param>
    /// <param name="numHidden">Number of hidden nodes of the output.</param>
    /// <param name="noBias">Whether to disable bias parameter.</param>
    /// <param name="flatten">Whether to collapse all but the first axis of the input data tensor.</param>
    new(data : Symbol,
        weight : Symbol,
        bias : Symbol,
        numHidden : int,
        [<Optional>] ?noBias : bool,
        [<Optional>] ?flatten : bool) = 
        let operatorArguments = 
            [
                "data", Input data
                "weight", Input weight
                "bias", Input bias
                "num_hidden", Parameter(Some(box numHidden))
                "no_bias", noBias |> Option.map box |> Parameter
                "flatten", flatten |> Option.map box |> Parameter
            ]
        new FullyConnected(Arguments<Symbol>(operatorArguments))
    /// <summary>Applies a linear transformation: :math:`Y = XW^T + b`.
    /// 
    /// If ``flatten`` is set to be true, then the shapes are:
    /// 
    /// - **data**: `(batch_size, x1, x2, ..., xn)`
    /// - **weight**: `(num_hidden, x1 * x2 * ... * xn)`
    /// - **bias**: `(num_hidden,)`
    /// - **out**: `(batch_size, num_hidden)`
    /// 
    /// If ``flatten`` is set to be false, then the shapes are:
    /// 
    /// - **data**: `(x1, x2, ..., xn, input_dim)`
    /// - **weight**: `(num_hidden, input_dim)`
    /// - **bias**: `(num_hidden,)`
    /// - **out**: `(x1, x2, ..., xn, num_hidden)`
    /// 
    /// The learnable parameters include both ``weight`` and ``bias``.
    /// 
    /// If ``no_bias`` is set to be true, then the ``bias`` term is ignored.
    /// 
    /// .. Note::
    /// 
    ///     The sparse support for FullyConnected is limited to forward evaluation with `row_sparse`
    ///     weight and bias, where the length of `weight.indices` and `bias.indices` must be equal
    ///     to `num_hidden`. This could be useful for model inference with `row_sparse` weights
    ///     trained with importance sampling or noise contrastive estimation.
    /// 
    ///     To compute linear transformation with &#39;csr&#39; sparse data, sparse.dot is recommended instead
    ///     of sparse.FullyConnected.
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\nn\fully_connected.cc:L288</summary>
    /// <param name="numHidden">Number of hidden nodes of the output.</param>
    /// <param name="data">Input data.</param>
    /// <param name="weight">Weight matrix.</param>
    /// <param name="bias">Bias parameter.</param>
    /// <param name="noBias">Whether to disable bias parameter.</param>
    /// <param name="flatten">Whether to collapse all but the first axis of the input data tensor.</param>
    new(numHidden : int,
        [<Optional>] ?data : Symbol,
        [<Optional>] ?weight : Symbol,
        [<Optional>] ?bias : Symbol,
        [<Optional>] ?noBias : bool,
        [<Optional>] ?flatten : bool) = 
        let data = defaultArg data (new ImplicitVariable() :> Symbol)
        let weight = defaultArg weight (new ImplicitVariable() :> Symbol)
        let bias = defaultArg bias (new ImplicitVariable() :> Symbol)
        let operatorArguments = 
            [
                "data", Input data
                "weight", Input weight
                "bias", Input bias
                "num_hidden", Parameter(Some(box numHidden))
                "no_bias", noBias |> Option.map box |> Parameter
                "flatten", flatten |> Option.map box |> Parameter
            ]
        new FullyConnected(Arguments<Symbol>(operatorArguments))
    /// Default value for NoBias
    /// Whether to disable bias parameter.
    static member NoBiasDefault : bool = false
    /// Default value for Flatten
    /// Whether to collapse all but the first axis of the input data tensor.
    static member FlattenDefault : bool = true
    /// Input data.
    member __.Data = operatorArguments.GetInput "data"
    /// Weight matrix.
    member __.Weight = operatorArguments.GetInput "weight"
    /// Bias parameter.
    member __.Bias = operatorArguments.GetInput "bias"
    /// Number of hidden nodes of the output.
    member __.NumHidden : int = match operatorArguments.GetParameter "num_hidden" with Some(v) -> unbox v | None -> failwithf "Required parameter num_hidden is missing"
    /// Whether to disable bias parameter.
    member __.NoBias = operatorArguments.GetParameter("no_bias", FullyConnected.NoBiasDefault)
    /// Whether to collapse all but the first axis of the input data tensor.
    member __.Flatten = operatorArguments.GetParameter("flatten", FullyConnected.FlattenDefault)
    /// <summary>Copy FullyConnected instance with updated inputs/parameters.</summary>
    /// <param name="data">Input data.</param>
    /// <param name="weight">Weight matrix.</param>
    /// <param name="bias">Bias parameter.</param>
    /// <param name="numHidden">Number of hidden nodes of the output.</param>
    /// <param name="noBias">Whether to disable bias parameter.</param>
    /// <param name="flatten">Whether to collapse all but the first axis of the input data tensor.</param>
    member this.With([<Optional>] ?data : Symbol,
        [<Optional>] ?weight : Symbol,
        [<Optional>] ?bias : Symbol,
        [<Optional>] ?numHidden : int,
        [<Optional>] ?noBias : bool,
        [<Optional>] ?flatten : bool) = 
        let operatorArguments = 
            [
                data |> Option.map (fun x -> "data", Input x)
                weight |> Option.map (fun x -> "weight", Input x)
                bias |> Option.map (fun x -> "bias", Input x)
                numHidden |> Option.map (fun x -> "num_hidden", Parameter(Some (box x)))
                noBias |> Option.map (fun x -> "no_bias", Parameter(Some (box x)))
                flatten |> Option.map (fun x -> "flatten", Parameter(Some (box x)))
            ] |> List.choose id
        new FullyConnected(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type GroupNorm private (operatorArguments) = 
    inherit SymbolOperator("GroupNorm", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new GroupNorm(args)
    override this.WithArguments(args : Arguments<Symbol>) = new GroupNorm(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <summary>Group normalization.
    /// 
    /// The input channels are separated into ``num_groups`` groups, each containing ``num_channels / num_groups`` channels.
    /// The mean and standard-deviation are calculated separately over the each group.
    /// 
    /// .. math::
    /// 
    ///   data = data.reshape((N, num_groups, C // num_groups, ...))
    ///   out = \frac{data - mean(data, axis)}{\sqrt{var(data, axis) + \epsilon}} * gamma + beta
    /// 
    /// Both ``gamma`` and ``beta`` are learnable parameters.
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\nn\group_norm.cc:L77</summary>
    /// <param name="data">Input data</param>
    /// <param name="gamma">gamma array</param>
    /// <param name="beta">beta array</param>
    /// <param name="numGroups">Total number of groups.</param>
    /// <param name="eps">An `epsilon` parameter to prevent division by 0.</param>
    /// <param name="outputMeanVar">Output the mean and std calculated along the given axis.</param>
    new([<Optional>] ?data : Symbol,
        [<Optional>] ?gamma : Symbol,
        [<Optional>] ?beta : Symbol,
        [<Optional>] ?numGroups : int,
        [<Optional>] ?eps : float,
        [<Optional>] ?outputMeanVar : bool) = 
        let data = defaultArg data (new ImplicitVariable() :> Symbol)
        let gamma = defaultArg gamma (new ImplicitVariable() :> Symbol)
        let beta = defaultArg beta (new ImplicitVariable() :> Symbol)
        let operatorArguments = 
            [
                "data", Input data
                "gamma", Input gamma
                "beta", Input beta
                "num_groups", numGroups |> Option.map box |> Parameter
                "eps", eps |> Option.map box |> Parameter
                "output_mean_var", outputMeanVar |> Option.map box |> Parameter
            ]
        new GroupNorm(Arguments<Symbol>(operatorArguments))
    /// Default value for NumGroups
    /// Total number of groups.
    static member NumGroupsDefault : int = 1
    /// Default value for Eps
    /// An `epsilon` parameter to prevent division by 0.
    static member EpsDefault : double = 0.00000999999975
    /// Default value for OutputMeanVar
    /// Output the mean and std calculated along the given axis.
    static member OutputMeanVarDefault : bool = false
    /// Input data
    member __.Data = operatorArguments.GetInput "data"
    /// gamma array
    member __.Gamma = operatorArguments.GetInput "gamma"
    /// beta array
    member __.Beta = operatorArguments.GetInput "beta"
    /// Total number of groups.
    member __.NumGroups = operatorArguments.GetParameter("num_groups", GroupNorm.NumGroupsDefault)
    /// An `epsilon` parameter to prevent division by 0.
    member __.Eps = operatorArguments.GetParameter("eps", GroupNorm.EpsDefault)
    /// Output the mean and std calculated along the given axis.
    member __.OutputMeanVar = operatorArguments.GetParameter("output_mean_var", GroupNorm.OutputMeanVarDefault)
    /// <summary>Copy GroupNorm instance with updated inputs/parameters.</summary>
    /// <param name="data">Input data</param>
    /// <param name="gamma">gamma array</param>
    /// <param name="beta">beta array</param>
    /// <param name="numGroups">Total number of groups.</param>
    /// <param name="eps">An `epsilon` parameter to prevent division by 0.</param>
    /// <param name="outputMeanVar">Output the mean and std calculated along the given axis.</param>
    member this.With([<Optional>] ?data : Symbol,
        [<Optional>] ?gamma : Symbol,
        [<Optional>] ?beta : Symbol,
        [<Optional>] ?numGroups : int,
        [<Optional>] ?eps : float,
        [<Optional>] ?outputMeanVar : bool) = 
        let operatorArguments = 
            [
                data |> Option.map (fun x -> "data", Input x)
                gamma |> Option.map (fun x -> "gamma", Input x)
                beta |> Option.map (fun x -> "beta", Input x)
                numGroups |> Option.map (fun x -> "num_groups", Parameter(Some (box x)))
                eps |> Option.map (fun x -> "eps", Parameter(Some (box x)))
                outputMeanVar |> Option.map (fun x -> "output_mean_var", Parameter(Some (box x)))
            ] |> List.choose id
        new GroupNorm(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type LayerNorm private (operatorArguments) = 
    inherit SymbolOperator("LayerNorm", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new LayerNorm(args)
    override this.WithArguments(args : Arguments<Symbol>) = new LayerNorm(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <summary>Layer normalization.
    /// 
    /// Normalizes the channels of the input tensor by mean and variance, and applies a scale ``gamma`` as
    /// well as offset ``beta``.
    /// 
    /// Assume the input has more than one dimension and we normalize along axis 1.
    /// We first compute the mean and variance along this axis and then 
    /// compute the normalized output, which has the same shape as input, as following:
    /// 
    /// .. math::
    /// 
    ///   out = \frac{data - mean(data, axis)}{\sqrt{var(data, axis) + \epsilon}} * gamma + beta
    /// 
    /// Both ``gamma`` and ``beta`` are learnable parameters.
    /// 
    /// Unlike BatchNorm and InstanceNorm,  the *mean* and *var* are computed along the channel dimension.
    /// 
    /// Assume the input has size *k* on axis 1, then both ``gamma`` and ``beta``
    /// have shape *(k,)*. If ``output_mean_var`` is set to be true, then outputs both ``data_mean`` and
    /// ``data_std``. Note that no gradient will be passed through these two outputs.
    /// 
    /// The parameter ``axis`` specifies which axis of the input shape denotes
    /// the &#39;channel&#39; (separately normalized groups).  The default is -1, which sets the channel
    /// axis to be the last item in the input shape.
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\nn\layer_norm.cc:L156</summary>
    /// <param name="data">Input data to layer normalization</param>
    /// <param name="gamma">gamma array</param>
    /// <param name="beta">beta array</param>
    /// <param name="axis">The axis to perform layer normalization. Usually, this should be be axis of the channel dimension. Negative values means indexing from right to left.</param>
    /// <param name="eps">An `epsilon` parameter to prevent division by 0.</param>
    /// <param name="outputMeanVar">Output the mean and std calculated along the given axis.</param>
    new([<Optional>] ?data : Symbol,
        [<Optional>] ?gamma : Symbol,
        [<Optional>] ?beta : Symbol,
        [<Optional>] ?axis : int,
        [<Optional>] ?eps : float,
        [<Optional>] ?outputMeanVar : bool) = 
        let data = defaultArg data (new ImplicitVariable() :> Symbol)
        let gamma = defaultArg gamma (new ImplicitVariable() :> Symbol)
        let beta = defaultArg beta (new ImplicitVariable() :> Symbol)
        let operatorArguments = 
            [
                "data", Input data
                "gamma", Input gamma
                "beta", Input beta
                "axis", axis |> Option.map box |> Parameter
                "eps", eps |> Option.map box |> Parameter
                "output_mean_var", outputMeanVar |> Option.map box |> Parameter
            ]
        new LayerNorm(Arguments<Symbol>(operatorArguments))
    /// Default value for Axis
    /// The axis to perform layer normalization. Usually, this should be be axis of the channel dimension. Negative values means indexing from right to left.
    static member AxisDefault : int = -1
    /// Default value for Eps
    /// An `epsilon` parameter to prevent division by 0.
    static member EpsDefault : double = 0.00000999999975
    /// Default value for OutputMeanVar
    /// Output the mean and std calculated along the given axis.
    static member OutputMeanVarDefault : bool = false
    /// Input data to layer normalization
    member __.Data = operatorArguments.GetInput "data"
    /// gamma array
    member __.Gamma = operatorArguments.GetInput "gamma"
    /// beta array
    member __.Beta = operatorArguments.GetInput "beta"
    /// The axis to perform layer normalization. Usually, this should be be axis of the channel dimension. Negative values means indexing from right to left.
    member __.Axis = operatorArguments.GetParameter("axis", LayerNorm.AxisDefault)
    /// An `epsilon` parameter to prevent division by 0.
    member __.Eps = operatorArguments.GetParameter("eps", LayerNorm.EpsDefault)
    /// Output the mean and std calculated along the given axis.
    member __.OutputMeanVar = operatorArguments.GetParameter("output_mean_var", LayerNorm.OutputMeanVarDefault)
    /// <summary>Copy LayerNorm instance with updated inputs/parameters.</summary>
    /// <param name="data">Input data to layer normalization</param>
    /// <param name="gamma">gamma array</param>
    /// <param name="beta">beta array</param>
    /// <param name="axis">The axis to perform layer normalization. Usually, this should be be axis of the channel dimension. Negative values means indexing from right to left.</param>
    /// <param name="eps">An `epsilon` parameter to prevent division by 0.</param>
    /// <param name="outputMeanVar">Output the mean and std calculated along the given axis.</param>
    member this.With([<Optional>] ?data : Symbol,
        [<Optional>] ?gamma : Symbol,
        [<Optional>] ?beta : Symbol,
        [<Optional>] ?axis : int,
        [<Optional>] ?eps : float,
        [<Optional>] ?outputMeanVar : bool) = 
        let operatorArguments = 
            [
                data |> Option.map (fun x -> "data", Input x)
                gamma |> Option.map (fun x -> "gamma", Input x)
                beta |> Option.map (fun x -> "beta", Input x)
                axis |> Option.map (fun x -> "axis", Parameter(Some (box x)))
                eps |> Option.map (fun x -> "eps", Parameter(Some (box x)))
                outputMeanVar |> Option.map (fun x -> "output_mean_var", Parameter(Some (box x)))
            ] |> List.choose id
        new LayerNorm(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type LogSoftmax private (operatorArguments) = 
    inherit SymbolOperator("log_softmax", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new LogSoftmax(args)
    override this.WithArguments(args : Arguments<Symbol>) = new LogSoftmax(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <summary>Computes the log softmax of the input.
    /// This is equivalent to computing softmax followed by log.
    /// 
    /// Examples::
    /// 
    ///   &gt;&gt;&gt; x = mx.nd.array([1, 2, .1])
    ///   &gt;&gt;&gt; mx.nd.log_softmax(x).asnumpy()
    ///   array([-1.41702998, -0.41702995, -2.31702995], dtype=float32)
    /// 
    ///   &gt;&gt;&gt; x = mx.nd.array( [[1, 2, .1],[.1, 2, 1]] )
    ///   &gt;&gt;&gt; mx.nd.log_softmax(x, axis=0).asnumpy()
    ///   array([[-0.34115392, -0.69314718, -1.24115396],
    ///          [-1.24115396, -0.69314718, -0.34115392]], dtype=float32)
    /// 
    /// 
    /// </summary>
    /// <param name="data">The input array.</param>
    /// <param name="axis">The axis along which to compute softmax.</param>
    /// <param name="temperature">Temperature parameter in softmax</param>
    /// <param name="dtype">DType of the output in case this can&#39;t be inferred. Defaults to the same as input&#39;s dtype if not defined (dtype=None).</param>
    /// <param name="useLength">Whether to use the length input as a mask over the data input.</param>
    new([<Optional>] ?data : Symbol,
        [<Optional>] ?axis : int,
        [<Optional>] ?temperature : float,
        [<Optional>] ?dtype : FloatDType,
        [<Optional>] ?useLength : bool) = 
        let data = defaultArg data (new ImplicitVariable() :> Symbol)
        let operatorArguments = 
            [
                "data", Input data
                "axis", axis |> Option.map box |> Parameter
                "temperature", temperature |> Option.map box |> Parameter
                "dtype", dtype |> Option.map box |> Parameter
                "use_length", useLength |> Option.map box |> Parameter
            ]
        new LogSoftmax(Arguments<Symbol>(operatorArguments))
    /// Default value for Axis
    /// The axis along which to compute softmax.
    static member AxisDefault : int = -1
    /// Default value for Temperature
    /// Temperature parameter in softmax
    static member TemperatureDefault : double option = None
    /// Default value for Dtype
    /// DType of the output in case this can&#39;t be inferred. Defaults to the same as input&#39;s dtype if not defined (dtype=None).
    static member DtypeDefault : FloatDType option = None
    /// Default value for UseLength
    /// Whether to use the length input as a mask over the data input.
    static member UseLengthDefault : bool option = Some(false)
    /// The input array.
    member __.Data = operatorArguments.GetInput "data"
    /// The axis along which to compute softmax.
    member __.Axis = operatorArguments.GetParameter("axis", LogSoftmax.AxisDefault)
    /// Temperature parameter in softmax
    member __.Temperature = operatorArguments.GetParameter("temperature", LogSoftmax.TemperatureDefault)
    /// DType of the output in case this can&#39;t be inferred. Defaults to the same as input&#39;s dtype if not defined (dtype=None).
    member __.Dtype = operatorArguments.GetParameter("dtype", LogSoftmax.DtypeDefault)
    /// Whether to use the length input as a mask over the data input.
    member __.UseLength = operatorArguments.GetParameter("use_length", LogSoftmax.UseLengthDefault)
    /// <summary>Copy LogSoftmax instance with updated inputs/parameters.</summary>
    /// <param name="data">The input array.</param>
    /// <param name="axis">The axis along which to compute softmax.</param>
    /// <param name="temperature">Temperature parameter in softmax</param>
    /// <param name="dtype">DType of the output in case this can&#39;t be inferred. Defaults to the same as input&#39;s dtype if not defined (dtype=None).</param>
    /// <param name="useLength">Whether to use the length input as a mask over the data input.</param>
    member this.With([<Optional>] ?data : Symbol,
        [<Optional>] ?axis : int,
        [<Optional>] ?temperature : float,
        [<Optional>] ?dtype : FloatDType,
        [<Optional>] ?useLength : bool) = 
        let operatorArguments = 
            [
                data |> Option.map (fun x -> "data", Input x)
                axis |> Option.map (fun x -> "axis", Parameter(Some (box x)))
                temperature |> Option.map (fun x -> "temperature", Parameter(Some (box x)))
                dtype |> Option.map (fun x -> "dtype", Parameter(Some (box x)))
                useLength |> Option.map (fun x -> "use_length", Parameter(Some (box x)))
            ] |> List.choose id
        new LogSoftmax(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type LRN private (operatorArguments) = 
    inherit SymbolOperator("LRN", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new LRN(args)
    override this.WithArguments(args : Arguments<Symbol>) = new LRN(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <summary>Applies local response normalization to the input.
    /// 
    /// The local response normalization layer performs &quot;lateral inhibition&quot; by normalizing
    /// over local input regions.
    /// 
    /// If :math:`a_{x,y}^{i}` is the activity of a neuron computed by applying kernel :math:`i` at position
    /// :math:`(x, y)` and then applying the ReLU nonlinearity, the response-normalized
    /// activity :math:`b_{x,y}^{i}` is given by the expression:
    /// 
    /// .. math::
    ///    b_{x,y}^{i} = \frac{a_{x,y}^{i}}{\Bigg({k + \frac{\alpha}{n} \sum_{j=max(0, i-\frac{n}{2})}^{min(N-1, i+\frac{n}{2})} (a_{x,y}^{j})^{2}}\Bigg)^{\beta}}
    /// 
    /// where the sum runs over :math:`n` &quot;adjacent&quot; kernel maps at the same spatial position, and :math:`N` is the total
    /// number of kernels in the layer.
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\nn\lrn.cc:L164</summary>
    /// <param name="data">Input data to LRN</param>
    /// <param name="nsize">normalization window width in elements.</param>
    /// <param name="alpha">The variance scaling parameter :math:`lpha` in the LRN expression.</param>
    /// <param name="beta">The power parameter :math:`eta` in the LRN expression.</param>
    /// <param name="knorm">The parameter :math:`k` in the LRN expression.</param>
    new(data : Symbol,
        nsize : int,
        [<Optional>] ?alpha : float,
        [<Optional>] ?beta : float,
        [<Optional>] ?knorm : float) = 
        let operatorArguments = 
            [
                "data", Input data
                "nsize", Parameter(Some(box nsize))
                "alpha", alpha |> Option.map box |> Parameter
                "beta", beta |> Option.map box |> Parameter
                "knorm", knorm |> Option.map box |> Parameter
            ]
        new LRN(Arguments<Symbol>(operatorArguments))
    /// <summary>Applies local response normalization to the input.
    /// 
    /// The local response normalization layer performs &quot;lateral inhibition&quot; by normalizing
    /// over local input regions.
    /// 
    /// If :math:`a_{x,y}^{i}` is the activity of a neuron computed by applying kernel :math:`i` at position
    /// :math:`(x, y)` and then applying the ReLU nonlinearity, the response-normalized
    /// activity :math:`b_{x,y}^{i}` is given by the expression:
    /// 
    /// .. math::
    ///    b_{x,y}^{i} = \frac{a_{x,y}^{i}}{\Bigg({k + \frac{\alpha}{n} \sum_{j=max(0, i-\frac{n}{2})}^{min(N-1, i+\frac{n}{2})} (a_{x,y}^{j})^{2}}\Bigg)^{\beta}}
    /// 
    /// where the sum runs over :math:`n` &quot;adjacent&quot; kernel maps at the same spatial position, and :math:`N` is the total
    /// number of kernels in the layer.
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\nn\lrn.cc:L164</summary>
    /// <param name="nsize">normalization window width in elements.</param>
    /// <param name="data">Input data to LRN</param>
    /// <param name="alpha">The variance scaling parameter :math:`lpha` in the LRN expression.</param>
    /// <param name="beta">The power parameter :math:`eta` in the LRN expression.</param>
    /// <param name="knorm">The parameter :math:`k` in the LRN expression.</param>
    new(nsize : int,
        [<Optional>] ?data : Symbol,
        [<Optional>] ?alpha : float,
        [<Optional>] ?beta : float,
        [<Optional>] ?knorm : float) = 
        let data = defaultArg data (new ImplicitVariable() :> Symbol)
        let operatorArguments = 
            [
                "data", Input data
                "nsize", Parameter(Some(box nsize))
                "alpha", alpha |> Option.map box |> Parameter
                "beta", beta |> Option.map box |> Parameter
                "knorm", knorm |> Option.map box |> Parameter
            ]
        new LRN(Arguments<Symbol>(operatorArguments))
    /// Default value for Alpha
    /// The variance scaling parameter :math:`lpha` in the LRN expression.
    static member AlphaDefault : double = 0.0000999999975
    /// Default value for Beta
    /// The power parameter :math:`eta` in the LRN expression.
    static member BetaDefault : double = 0.75
    /// Default value for Knorm
    /// The parameter :math:`k` in the LRN expression.
    static member KnormDefault : double = 2.0
    /// Input data to LRN
    member __.Data = operatorArguments.GetInput "data"
    /// normalization window width in elements.
    member __.Nsize : int = match operatorArguments.GetParameter "nsize" with Some(v) -> unbox v | None -> failwithf "Required parameter nsize is missing"
    /// The variance scaling parameter :math:`lpha` in the LRN expression.
    member __.Alpha = operatorArguments.GetParameter("alpha", LRN.AlphaDefault)
    /// The power parameter :math:`eta` in the LRN expression.
    member __.Beta = operatorArguments.GetParameter("beta", LRN.BetaDefault)
    /// The parameter :math:`k` in the LRN expression.
    member __.Knorm = operatorArguments.GetParameter("knorm", LRN.KnormDefault)
    /// <summary>Copy LRN instance with updated inputs/parameters.</summary>
    /// <param name="data">Input data to LRN</param>
    /// <param name="nsize">normalization window width in elements.</param>
    /// <param name="alpha">The variance scaling parameter :math:`lpha` in the LRN expression.</param>
    /// <param name="beta">The power parameter :math:`eta` in the LRN expression.</param>
    /// <param name="knorm">The parameter :math:`k` in the LRN expression.</param>
    member this.With([<Optional>] ?data : Symbol,
        [<Optional>] ?nsize : int,
        [<Optional>] ?alpha : float,
        [<Optional>] ?beta : float,
        [<Optional>] ?knorm : float) = 
        let operatorArguments = 
            [
                data |> Option.map (fun x -> "data", Input x)
                nsize |> Option.map (fun x -> "nsize", Parameter(Some (box x)))
                alpha |> Option.map (fun x -> "alpha", Parameter(Some (box x)))
                beta |> Option.map (fun x -> "beta", Parameter(Some (box x)))
                knorm |> Option.map (fun x -> "knorm", Parameter(Some (box x)))
            ] |> List.choose id
        new LRN(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type Moments private (operatorArguments) = 
    inherit SymbolOperator("moments", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new Moments(args)
    override this.WithArguments(args : Arguments<Symbol>) = new Moments(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <summary>
    /// Calculate the mean and variance of `data`.
    /// 
    /// The mean and variance are calculated by aggregating the contents of data across axes.
    /// If x is 1-D and axes = [0] this is just the mean and variance of a vector.
    /// 
    /// Example:
    /// 
    ///      x = [[1, 2, 3], [4, 5, 6]]
    ///      mean, var = moments(data=x, axes=[0])
    ///      mean = [2.5, 3.5, 4.5]
    ///      var = [2.25, 2.25, 2.25]
    ///      mean, var = moments(data=x, axes=[1])
    ///      mean = [2.0, 5.0]
    ///      var = [0.66666667, 0.66666667]
    ///      mean, var = moments(data=x, axis=[0, 1])
    ///      mean = [3.5]
    ///      var = [2.9166667]
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\nn\moments.cc:L54</summary>
    /// <param name="data">Input ndarray</param>
    /// <param name="axes">Array of ints. Axes along which to compute mean and variance.</param>
    /// <param name="keepdims">produce moments with the same dimensionality as the input.</param>
    new([<Optional>] ?data : Symbol,
        [<Optional>] ?axes : int seq,
        [<Optional>] ?keepdims : bool) = 
        let data = defaultArg data (new ImplicitVariable() :> Symbol)
        let operatorArguments = 
            [
                "data", Input data
                "axes", axes |> Option.map box |> Parameter
                "keepdims", keepdims |> Option.map box |> Parameter
            ]
        new Moments(Arguments<Symbol>(operatorArguments))
    /// Default value for Axes
    /// Array of ints. Axes along which to compute mean and variance.
    static member AxesDefault : int [] option = None
    /// Default value for Keepdims
    /// produce moments with the same dimensionality as the input.
    static member KeepdimsDefault : bool = false
    /// Input ndarray
    member __.Data = operatorArguments.GetInput "data"
    /// Array of ints. Axes along which to compute mean and variance.
    member __.Axes = operatorArguments.GetParameter("axes", Moments.AxesDefault)
    /// produce moments with the same dimensionality as the input.
    member __.Keepdims = operatorArguments.GetParameter("keepdims", Moments.KeepdimsDefault)
    /// <summary>Copy Moments instance with updated inputs/parameters.</summary>
    /// <param name="data">Input ndarray</param>
    /// <param name="axes">Array of ints. Axes along which to compute mean and variance.</param>
    /// <param name="keepdims">produce moments with the same dimensionality as the input.</param>
    member this.With([<Optional>] ?data : Symbol,
        [<Optional>] ?axes : int seq,
        [<Optional>] ?keepdims : bool) = 
        let operatorArguments = 
            [
                data |> Option.map (fun x -> "data", Input x)
                axes |> Option.map (fun x -> "axes", Parameter(Some (box x)))
                keepdims |> Option.map (fun x -> "keepdims", Parameter(Some (box x)))
            ] |> List.choose id
        new Moments(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type Pooling private (operatorArguments) = 
    inherit SymbolOperator("Pooling", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new Pooling(args)
    override this.WithArguments(args : Arguments<Symbol>) = new Pooling(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <summary>Performs pooling on the input.
    /// 
    /// The shapes for 1-D pooling are
    /// 
    /// - **data** and **out**: *(batch_size, channel, width)* (NCW layout) or
    ///   *(batch_size, width, channel)* (NWC layout),
    /// 
    /// The shapes for 2-D pooling are
    /// 
    /// - **data** and **out**: *(batch_size, channel, height, width)* (NCHW layout) or
    ///   *(batch_size, height, width, channel)* (NHWC layout),
    /// 
    ///     out_height = f(height, kernel[0], pad[0], stride[0])
    ///     out_width = f(width, kernel[1], pad[1], stride[1])
    /// 
    /// The definition of *f* depends on ``pooling_convention``, which has two options:
    /// 
    /// - **valid** (default)::
    /// 
    ///     f(x, k, p, s) = floor((x+2*p-k)/s)+1
    /// 
    /// - **full**, which is compatible with Caffe::
    /// 
    ///     f(x, k, p, s) = ceil((x+2*p-k)/s)+1
    /// 
    /// When ``global_pool`` is set to be true, then global pooling is performed. It will reset
    /// ``kernel=(height, width)`` and set the appropiate padding to 0.
    /// 
    /// Three pooling options are supported by ``pool_type``:
    /// 
    /// - **avg**: average pooling
    /// - **max**: max pooling
    /// - **sum**: sum pooling
    /// - **lp**: Lp pooling
    /// 
    /// For 3-D pooling, an additional *depth* dimension is added before
    /// *height*. Namely the input data and output will have shape *(batch_size, channel, depth,
    /// height, width)* (NCDHW layout) or *(batch_size, depth, height, width, channel)* (NDHWC layout).
    /// 
    /// Notes on Lp pooling:
    /// 
    /// Lp pooling was first introduced by this paper: https://arxiv.org/pdf/1204.3968.pdf.
    /// L-1 pooling is simply sum pooling, while L-inf pooling is simply max pooling.
    /// We can see that Lp pooling stands between those two, in practice the most common value for p is 2.
    /// 
    /// For each window ``X``, the mathematical expression for Lp pooling is:
    /// 
    /// :math:`f(X) = \sqrt[p]{\sum_{x}^{X} x^p}`
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\nn\pooling.cc:L417</summary>
    /// <param name="data">Input data to the pooling operator.</param>
    /// <param name="kernel">Pooling kernel size: (y, x) or (d, y, x)</param>
    /// <param name="poolType">Pooling type to be applied.</param>
    /// <param name="globalPool">Ignore kernel size, do global pooling based on current input feature map. </param>
    /// <param name="cudnnOff">Turn off cudnn pooling and use MXNet pooling operator. </param>
    /// <param name="poolingConvention">Pooling convention to be applied.</param>
    /// <param name="stride">Stride: for pooling (y, x) or (d, y, x). Defaults to 1 for each dimension.</param>
    /// <param name="pad">Pad for pooling: (y, x) or (d, y, x). Defaults to no padding.</param>
    /// <param name="pValue">Value of p for Lp pooling, can be 1 or 2, required for Lp Pooling.</param>
    /// <param name="countIncludePad">Only used for AvgPool, specify whether to count padding elements for averagecalculation. For example, with a 5*5 kernel on a 3*3 corner of a image,the sum of the 9 valid elements will be divided by 25 if this is set to true,or it will be divided by 9 if this is set to false. Defaults to true.</param>
    /// <param name="layout">Set layout for input and output. Empty for
    ///     default layout: NCW for 1d, NCHW for 2d and NCDHW for 3d.</param>
    new([<Optional>] ?data : Symbol,
        [<Optional>] ?kernel : int seq,
        [<Optional>] ?poolType : PoolType,
        [<Optional>] ?globalPool : bool,
        [<Optional>] ?cudnnOff : bool,
        [<Optional>] ?poolingConvention : PoolingConvention,
        [<Optional>] ?stride : int seq,
        [<Optional>] ?pad : int seq,
        [<Optional>] ?pValue : int,
        [<Optional>] ?countIncludePad : bool,
        [<Optional>] ?layout : PoolingLayout) = 
        let data = defaultArg data (new ImplicitVariable() :> Symbol)
        let operatorArguments = 
            [
                "data", Input data
                "kernel", kernel |> Option.map box |> Parameter
                "pool_type", poolType |> Option.map box |> Parameter
                "global_pool", globalPool |> Option.map box |> Parameter
                "cudnn_off", cudnnOff |> Option.map box |> Parameter
                "pooling_convention", poolingConvention |> Option.map box |> Parameter
                "stride", stride |> Option.map box |> Parameter
                "pad", pad |> Option.map box |> Parameter
                "p_value", pValue |> Option.map box |> Parameter
                "count_include_pad", countIncludePad |> Option.map box |> Parameter
                "layout", layout |> Option.map box |> Parameter
            ]
        new Pooling(Arguments<Symbol>(operatorArguments))
    /// Default value for Kernel
    /// Pooling kernel size: (y, x) or (d, y, x)
    static member KernelDefault : int [] = [||]
    /// Default value for PoolType
    /// Pooling type to be applied.
    static member PoolTypeDefault : PoolType = PoolType.Max
    /// Default value for GlobalPool
    /// Ignore kernel size, do global pooling based on current input feature map. 
    static member GlobalPoolDefault : bool = false
    /// Default value for CudnnOff
    /// Turn off cudnn pooling and use MXNet pooling operator. 
    static member CudnnOffDefault : bool = false
    /// Default value for PoolingConvention
    /// Pooling convention to be applied.
    static member PoolingConventionDefault : PoolingConvention = PoolingConvention.Valid
    /// Default value for Stride
    /// Stride: for pooling (y, x) or (d, y, x). Defaults to 1 for each dimension.
    static member StrideDefault : int [] = [||]
    /// Default value for Pad
    /// Pad for pooling: (y, x) or (d, y, x). Defaults to no padding.
    static member PadDefault : int [] = [||]
    /// Default value for PValue
    /// Value of p for Lp pooling, can be 1 or 2, required for Lp Pooling.
    static member PValueDefault : int option = None
    /// Default value for CountIncludePad
    /// Only used for AvgPool, specify whether to count padding elements for averagecalculation. For example, with a 5*5 kernel on a 3*3 corner of a image,the sum of the 9 valid elements will be divided by 25 if this is set to true,or it will be divided by 9 if this is set to false. Defaults to true.
    static member CountIncludePadDefault : bool option = None
    /// Default value for Layout
    /// Set layout for input and output. Empty for
    ///     default layout: NCW for 1d, NCHW for 2d and NCDHW for 3d.
    static member LayoutDefault : PoolingLayout option = None
    /// Input data to the pooling operator.
    member __.Data = operatorArguments.GetInput "data"
    /// Pooling kernel size: (y, x) or (d, y, x)
    member __.Kernel = operatorArguments.GetParameter("kernel", Pooling.KernelDefault)
    /// Pooling type to be applied.
    member __.PoolType = operatorArguments.GetParameter("pool_type", Pooling.PoolTypeDefault)
    /// Ignore kernel size, do global pooling based on current input feature map. 
    member __.GlobalPool = operatorArguments.GetParameter("global_pool", Pooling.GlobalPoolDefault)
    /// Turn off cudnn pooling and use MXNet pooling operator. 
    member __.CudnnOff = operatorArguments.GetParameter("cudnn_off", Pooling.CudnnOffDefault)
    /// Pooling convention to be applied.
    member __.PoolingConvention = operatorArguments.GetParameter("pooling_convention", Pooling.PoolingConventionDefault)
    /// Stride: for pooling (y, x) or (d, y, x). Defaults to 1 for each dimension.
    member __.Stride = operatorArguments.GetParameter("stride", Pooling.StrideDefault)
    /// Pad for pooling: (y, x) or (d, y, x). Defaults to no padding.
    member __.Pad = operatorArguments.GetParameter("pad", Pooling.PadDefault)
    /// Value of p for Lp pooling, can be 1 or 2, required for Lp Pooling.
    member __.PValue = operatorArguments.GetParameter("p_value", Pooling.PValueDefault)
    /// Only used for AvgPool, specify whether to count padding elements for averagecalculation. For example, with a 5*5 kernel on a 3*3 corner of a image,the sum of the 9 valid elements will be divided by 25 if this is set to true,or it will be divided by 9 if this is set to false. Defaults to true.
    member __.CountIncludePad = operatorArguments.GetParameter("count_include_pad", Pooling.CountIncludePadDefault)
    /// Set layout for input and output. Empty for
    ///     default layout: NCW for 1d, NCHW for 2d and NCDHW for 3d.
    member __.Layout = operatorArguments.GetParameter("layout", Pooling.LayoutDefault)
    /// <summary>Copy Pooling instance with updated inputs/parameters.</summary>
    /// <param name="data">Input data to the pooling operator.</param>
    /// <param name="kernel">Pooling kernel size: (y, x) or (d, y, x)</param>
    /// <param name="poolType">Pooling type to be applied.</param>
    /// <param name="globalPool">Ignore kernel size, do global pooling based on current input feature map. </param>
    /// <param name="cudnnOff">Turn off cudnn pooling and use MXNet pooling operator. </param>
    /// <param name="poolingConvention">Pooling convention to be applied.</param>
    /// <param name="stride">Stride: for pooling (y, x) or (d, y, x). Defaults to 1 for each dimension.</param>
    /// <param name="pad">Pad for pooling: (y, x) or (d, y, x). Defaults to no padding.</param>
    /// <param name="pValue">Value of p for Lp pooling, can be 1 or 2, required for Lp Pooling.</param>
    /// <param name="countIncludePad">Only used for AvgPool, specify whether to count padding elements for averagecalculation. For example, with a 5*5 kernel on a 3*3 corner of a image,the sum of the 9 valid elements will be divided by 25 if this is set to true,or it will be divided by 9 if this is set to false. Defaults to true.</param>
    /// <param name="layout">Set layout for input and output. Empty for
    ///     default layout: NCW for 1d, NCHW for 2d and NCDHW for 3d.</param>
    member this.With([<Optional>] ?data : Symbol,
        [<Optional>] ?kernel : int seq,
        [<Optional>] ?poolType : PoolType,
        [<Optional>] ?globalPool : bool,
        [<Optional>] ?cudnnOff : bool,
        [<Optional>] ?poolingConvention : PoolingConvention,
        [<Optional>] ?stride : int seq,
        [<Optional>] ?pad : int seq,
        [<Optional>] ?pValue : int,
        [<Optional>] ?countIncludePad : bool,
        [<Optional>] ?layout : PoolingLayout) = 
        let operatorArguments = 
            [
                data |> Option.map (fun x -> "data", Input x)
                kernel |> Option.map (fun x -> "kernel", Parameter(Some (box x)))
                poolType |> Option.map (fun x -> "pool_type", Parameter(Some (box x)))
                globalPool |> Option.map (fun x -> "global_pool", Parameter(Some (box x)))
                cudnnOff |> Option.map (fun x -> "cudnn_off", Parameter(Some (box x)))
                poolingConvention |> Option.map (fun x -> "pooling_convention", Parameter(Some (box x)))
                stride |> Option.map (fun x -> "stride", Parameter(Some (box x)))
                pad |> Option.map (fun x -> "pad", Parameter(Some (box x)))
                pValue |> Option.map (fun x -> "p_value", Parameter(Some (box x)))
                countIncludePad |> Option.map (fun x -> "count_include_pad", Parameter(Some (box x)))
                layout |> Option.map (fun x -> "layout", Parameter(Some (box x)))
            ] |> List.choose id
        new Pooling(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type Softmax private (operatorArguments) = 
    inherit SymbolOperator("softmax", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new Softmax(args)
    override this.WithArguments(args : Arguments<Symbol>) = new Softmax(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <summary>Applies the softmax function.
    /// 
    /// The resulting array contains elements in the range (0,1) and the elements along the given axis sum up to 1.
    /// 
    /// .. math::
    ///    softmax(\mathbf{z/t})_j = \frac{e^{z_j/t}}{\sum_{k=1}^K e^{z_k/t}}
    /// 
    /// for :math:`j = 1, ..., K`
    /// 
    /// t is the temperature parameter in softmax function. By default, t equals 1.0
    /// 
    /// Example::
    /// 
    ///   x = [[ 1.  1.  1.]
    ///        [ 1.  1.  1.]]
    /// 
    ///   softmax(x,axis=0) = [[ 0.5  0.5  0.5]
    ///                        [ 0.5  0.5  0.5]]
    /// 
    ///   softmax(x,axis=1) = [[ 0.33333334,  0.33333334,  0.33333334],
    ///                        [ 0.33333334,  0.33333334,  0.33333334]]
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\nn\softmax.cc:L103</summary>
    /// <param name="data">The input array.</param>
    /// <param name="length">The length array.</param>
    /// <param name="axis">The axis along which to compute softmax.</param>
    /// <param name="temperature">Temperature parameter in softmax</param>
    /// <param name="dtype">DType of the output in case this can&#39;t be inferred. Defaults to the same as input&#39;s dtype if not defined (dtype=None).</param>
    /// <param name="useLength">Whether to use the length input as a mask over the data input.</param>
    new([<Optional>] ?data : Symbol,
        [<Optional>] ?length : Symbol,
        [<Optional>] ?axis : int,
        [<Optional>] ?temperature : float,
        [<Optional>] ?dtype : FloatDType,
        [<Optional>] ?useLength : bool) = 
        let data = defaultArg data (new ImplicitVariable() :> Symbol)
        let length = defaultArg length (new ImplicitVariable() :> Symbol)
        let operatorArguments = 
            [
                "data", Input data
                "length", Input length
                "axis", axis |> Option.map box |> Parameter
                "temperature", temperature |> Option.map box |> Parameter
                "dtype", dtype |> Option.map box |> Parameter
                "use_length", useLength |> Option.map box |> Parameter
            ]
        new Softmax(Arguments<Symbol>(operatorArguments))
    /// Default value for Axis
    /// The axis along which to compute softmax.
    static member AxisDefault : int = -1
    /// Default value for Temperature
    /// Temperature parameter in softmax
    static member TemperatureDefault : double option = None
    /// Default value for Dtype
    /// DType of the output in case this can&#39;t be inferred. Defaults to the same as input&#39;s dtype if not defined (dtype=None).
    static member DtypeDefault : FloatDType option = None
    /// Default value for UseLength
    /// Whether to use the length input as a mask over the data input.
    static member UseLengthDefault : bool option = Some(false)
    /// The input array.
    member __.Data = operatorArguments.GetInput "data"
    /// The length array.
    member __.Length = operatorArguments.GetInput "length"
    /// The axis along which to compute softmax.
    member __.Axis = operatorArguments.GetParameter("axis", Softmax.AxisDefault)
    /// Temperature parameter in softmax
    member __.Temperature = operatorArguments.GetParameter("temperature", Softmax.TemperatureDefault)
    /// DType of the output in case this can&#39;t be inferred. Defaults to the same as input&#39;s dtype if not defined (dtype=None).
    member __.Dtype = operatorArguments.GetParameter("dtype", Softmax.DtypeDefault)
    /// Whether to use the length input as a mask over the data input.
    member __.UseLength = operatorArguments.GetParameter("use_length", Softmax.UseLengthDefault)
    /// <summary>Copy Softmax instance with updated inputs/parameters.</summary>
    /// <param name="data">The input array.</param>
    /// <param name="length">The length array.</param>
    /// <param name="axis">The axis along which to compute softmax.</param>
    /// <param name="temperature">Temperature parameter in softmax</param>
    /// <param name="dtype">DType of the output in case this can&#39;t be inferred. Defaults to the same as input&#39;s dtype if not defined (dtype=None).</param>
    /// <param name="useLength">Whether to use the length input as a mask over the data input.</param>
    member this.With([<Optional>] ?data : Symbol,
        [<Optional>] ?length : Symbol,
        [<Optional>] ?axis : int,
        [<Optional>] ?temperature : float,
        [<Optional>] ?dtype : FloatDType,
        [<Optional>] ?useLength : bool) = 
        let operatorArguments = 
            [
                data |> Option.map (fun x -> "data", Input x)
                length |> Option.map (fun x -> "length", Input x)
                axis |> Option.map (fun x -> "axis", Parameter(Some (box x)))
                temperature |> Option.map (fun x -> "temperature", Parameter(Some (box x)))
                dtype |> Option.map (fun x -> "dtype", Parameter(Some (box x)))
                useLength |> Option.map (fun x -> "use_length", Parameter(Some (box x)))
            ] |> List.choose id
        new Softmax(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type SoftmaxActivation private (operatorArguments) = 
    inherit SymbolOperator("SoftmaxActivation", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new SoftmaxActivation(args)
    override this.WithArguments(args : Arguments<Symbol>) = new SoftmaxActivation(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <summary>Applies softmax activation to input. This is intended for internal layers.
    /// 
    /// .. note::
    /// 
    ///   This operator has been deprecated, please use `softmax`.
    /// 
    /// If `mode` = ``instance``, this operator will compute a softmax for each instance in the batch.
    /// This is the default mode.
    /// 
    /// If `mode` = ``channel``, this operator will compute a k-class softmax at each position
    /// of each instance, where `k` = ``num_channel``. This mode can only be used when the input array
    /// has at least 3 dimensions.
    /// This can be used for `fully convolutional network`, `image segmentation`, etc.
    /// 
    /// Example::
    /// 
    ///   &gt;&gt;&gt; input_array = mx.nd.array([[3., 0.5, -0.5, 2., 7.],
    ///   &gt;&gt;&gt;                            [2., -.4, 7.,   3., 0.2]])
    ///   &gt;&gt;&gt; softmax_act = mx.nd.SoftmaxActivation(input_array)
    ///   &gt;&gt;&gt; print softmax_act.asnumpy()
    ///   [[  1.78322066e-02   1.46375655e-03   5.38485940e-04   6.56010211e-03   9.73605454e-01]
    ///    [  6.56221947e-03   5.95310994e-04   9.73919690e-01   1.78379621e-02   1.08472735e-03]]
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\nn\softmax_activation.cc:L59</summary>
    /// <param name="data">The input array.</param>
    /// <param name="mode">Specifies how to compute the softmax. If set to ``instance``, it computes softmax for each instance. If set to ``channel``, It computes cross channel softmax for each position of each instance.</param>
    new([<Optional>] ?data : Symbol,
        [<Optional>] ?mode : SoftmaxActivationMode) = 
        let data = defaultArg data (new ImplicitVariable() :> Symbol)
        let operatorArguments = 
            [
                "data", Input data
                "mode", mode |> Option.map box |> Parameter
            ]
        new SoftmaxActivation(Arguments<Symbol>(operatorArguments))
    /// Default value for Mode
    /// Specifies how to compute the softmax. If set to ``instance``, it computes softmax for each instance. If set to ``channel``, It computes cross channel softmax for each position of each instance.
    static member ModeDefault : SoftmaxActivationMode = SoftmaxActivationMode.Instance
    /// The input array.
    member __.Data = operatorArguments.GetInput "data"
    /// Specifies how to compute the softmax. If set to ``instance``, it computes softmax for each instance. If set to ``channel``, It computes cross channel softmax for each position of each instance.
    member __.Mode = operatorArguments.GetParameter("mode", SoftmaxActivation.ModeDefault)
    /// <summary>Copy SoftmaxActivation instance with updated inputs/parameters.</summary>
    /// <param name="data">The input array.</param>
    /// <param name="mode">Specifies how to compute the softmax. If set to ``instance``, it computes softmax for each instance. If set to ``channel``, It computes cross channel softmax for each position of each instance.</param>
    member this.With([<Optional>] ?data : Symbol,
        [<Optional>] ?mode : SoftmaxActivationMode) = 
        let operatorArguments = 
            [
                data |> Option.map (fun x -> "data", Input x)
                mode |> Option.map (fun x -> "mode", Parameter(Some (box x)))
            ] |> List.choose id
        new SoftmaxActivation(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type Softmin private (operatorArguments) = 
    inherit SymbolOperator("softmin", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new Softmin(args)
    override this.WithArguments(args : Arguments<Symbol>) = new Softmin(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <summary>Applies the softmin function.
    /// 
    /// The resulting array contains elements in the range (0,1) and the elements along the given axis sum
    /// up to 1.
    /// 
    /// .. math::
    ///    softmin(\mathbf{z/t})_j = \frac{e^{-z_j/t}}{\sum_{k=1}^K e^{-z_k/t}}
    /// 
    /// for :math:`j = 1, ..., K`
    /// 
    /// t is the temperature parameter in softmax function. By default, t equals 1.0
    /// 
    /// Example::
    /// 
    ///   x = [[ 1.  2.  3.]
    ///        [ 3.  2.  1.]]
    /// 
    ///   softmin(x,axis=0) = [[ 0.88079703,  0.5,  0.11920292],
    ///                        [ 0.11920292,  0.5,  0.88079703]]
    /// 
    ///   softmin(x,axis=1) = [[ 0.66524094,  0.24472848,  0.09003057],
    ///                        [ 0.09003057,  0.24472848,  0.66524094]]
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\nn\softmin.cc:L57</summary>
    /// <param name="data">The input array.</param>
    /// <param name="axis">The axis along which to compute softmax.</param>
    /// <param name="temperature">Temperature parameter in softmax</param>
    /// <param name="dtype">DType of the output in case this can&#39;t be inferred. Defaults to the same as input&#39;s dtype if not defined (dtype=None).</param>
    /// <param name="useLength">Whether to use the length input as a mask over the data input.</param>
    new([<Optional>] ?data : Symbol,
        [<Optional>] ?axis : int,
        [<Optional>] ?temperature : float,
        [<Optional>] ?dtype : FloatDType,
        [<Optional>] ?useLength : bool) = 
        let data = defaultArg data (new ImplicitVariable() :> Symbol)
        let operatorArguments = 
            [
                "data", Input data
                "axis", axis |> Option.map box |> Parameter
                "temperature", temperature |> Option.map box |> Parameter
                "dtype", dtype |> Option.map box |> Parameter
                "use_length", useLength |> Option.map box |> Parameter
            ]
        new Softmin(Arguments<Symbol>(operatorArguments))
    /// Default value for Axis
    /// The axis along which to compute softmax.
    static member AxisDefault : int = -1
    /// Default value for Temperature
    /// Temperature parameter in softmax
    static member TemperatureDefault : double option = None
    /// Default value for Dtype
    /// DType of the output in case this can&#39;t be inferred. Defaults to the same as input&#39;s dtype if not defined (dtype=None).
    static member DtypeDefault : FloatDType option = None
    /// Default value for UseLength
    /// Whether to use the length input as a mask over the data input.
    static member UseLengthDefault : bool option = Some(false)
    /// The input array.
    member __.Data = operatorArguments.GetInput "data"
    /// The axis along which to compute softmax.
    member __.Axis = operatorArguments.GetParameter("axis", Softmin.AxisDefault)
    /// Temperature parameter in softmax
    member __.Temperature = operatorArguments.GetParameter("temperature", Softmin.TemperatureDefault)
    /// DType of the output in case this can&#39;t be inferred. Defaults to the same as input&#39;s dtype if not defined (dtype=None).
    member __.Dtype = operatorArguments.GetParameter("dtype", Softmin.DtypeDefault)
    /// Whether to use the length input as a mask over the data input.
    member __.UseLength = operatorArguments.GetParameter("use_length", Softmin.UseLengthDefault)
    /// <summary>Copy Softmin instance with updated inputs/parameters.</summary>
    /// <param name="data">The input array.</param>
    /// <param name="axis">The axis along which to compute softmax.</param>
    /// <param name="temperature">Temperature parameter in softmax</param>
    /// <param name="dtype">DType of the output in case this can&#39;t be inferred. Defaults to the same as input&#39;s dtype if not defined (dtype=None).</param>
    /// <param name="useLength">Whether to use the length input as a mask over the data input.</param>
    member this.With([<Optional>] ?data : Symbol,
        [<Optional>] ?axis : int,
        [<Optional>] ?temperature : float,
        [<Optional>] ?dtype : FloatDType,
        [<Optional>] ?useLength : bool) = 
        let operatorArguments = 
            [
                data |> Option.map (fun x -> "data", Input x)
                axis |> Option.map (fun x -> "axis", Parameter(Some (box x)))
                temperature |> Option.map (fun x -> "temperature", Parameter(Some (box x)))
                dtype |> Option.map (fun x -> "dtype", Parameter(Some (box x)))
                useLength |> Option.map (fun x -> "use_length", Parameter(Some (box x)))
            ] |> List.choose id
        new Softmin(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type UpSampling private (operatorArguments) = 
    inherit SymbolOperator("UpSampling", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new UpSampling(args)
    override this.WithArguments(args : Arguments<Symbol>) = new UpSampling(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <summary>Upsamples the given input data.
    /// 
    /// Two algorithms (``sample_type``) are available for upsampling:
    /// 
    /// - Nearest Neighbor
    /// - Bilinear
    /// 
    /// **Nearest Neighbor Upsampling**
    /// 
    /// Input data is expected to be NCHW.
    /// 
    /// Example::
    /// 
    ///   x = [[[[1. 1. 1.]
    ///          [1. 1. 1.]
    ///          [1. 1. 1.]]]]
    /// 
    ///   UpSampling(x, scale=2, sample_type=&#39;nearest&#39;) = [[[[1. 1. 1. 1. 1. 1.]
    ///                                                      [1. 1. 1. 1. 1. 1.]
    ///                                                      [1. 1. 1. 1. 1. 1.]
    ///                                                      [1. 1. 1. 1. 1. 1.]
    ///                                                      [1. 1. 1. 1. 1. 1.]
    ///                                                      [1. 1. 1. 1. 1. 1.]]]]
    /// 
    /// **Bilinear Upsampling**
    /// 
    /// Uses `deconvolution` algorithm under the hood. You need provide both input data and the kernel.
    /// 
    /// Input data is expected to be NCHW.
    /// 
    /// `num_filter` is expected to be same as the number of channels.
    /// 
    /// Example::
    /// 
    ///   x = [[[[1. 1. 1.]
    ///          [1. 1. 1.]
    ///          [1. 1. 1.]]]]
    /// 
    ///   w = [[[[1. 1. 1. 1.]
    ///          [1. 1. 1. 1.]
    ///          [1. 1. 1. 1.]
    ///          [1. 1. 1. 1.]]]]
    ///   
    ///   UpSampling(x, w, scale=2, sample_type=&#39;bilinear&#39;, num_filter=1) = [[[[1. 2. 2. 2. 2. 1.]
    ///                                                                        [2. 4. 4. 4. 4. 2.]
    ///                                                                        [2. 4. 4. 4. 4. 2.]
    ///                                                                        [2. 4. 4. 4. 4. 2.]
    ///                                                                        [2. 4. 4. 4. 4. 2.]
    ///                                                                        [1. 2. 2. 2. 2. 1.]]]]
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\nn\upsampling.cc:L173</summary>
    /// <param name="data">Array of tensors to upsample. For bilinear upsampling, there should be 2 inputs - 1 data and 1 weight.</param>
    /// <param name="scale">Up sampling scale</param>
    /// <param name="sampleType">upsampling method</param>
    /// <param name="numFilter">Input filter. Only used by bilinear sample_type.Since bilinear upsampling uses deconvolution, num_filters is set to the number of channels.</param>
    /// <param name="multiInputMode">How to handle multiple input. concat means concatenate upsampled images along the channel dimension. sum means add all images together, only available for nearest neighbor upsampling.</param>
    /// <param name="workspace">Tmp workspace for deconvolution (MB)</param>
    new(data : Symbol seq,
        scale : int,
        sampleType : SampleType,
        [<Optional>] ?numFilter : int,
        [<Optional>] ?multiInputMode : MultiInputMode,
        [<Optional>] ?workspace : int64) = 
        let operatorArguments = 
            [
                "data", VarArg("num_args", data |> Seq.toArray)
                "scale", Parameter(Some(box scale))
                "sample_type", Parameter(Some(box sampleType))
                "num_filter", numFilter |> Option.map box |> Parameter
                "multi_input_mode", multiInputMode |> Option.map box |> Parameter
                "workspace", workspace |> Option.map box |> Parameter
            ]
        new UpSampling(Arguments<Symbol>(operatorArguments))
    /// <summary>Upsamples the given input data.
    /// 
    /// Two algorithms (``sample_type``) are available for upsampling:
    /// 
    /// - Nearest Neighbor
    /// - Bilinear
    /// 
    /// **Nearest Neighbor Upsampling**
    /// 
    /// Input data is expected to be NCHW.
    /// 
    /// Example::
    /// 
    ///   x = [[[[1. 1. 1.]
    ///          [1. 1. 1.]
    ///          [1. 1. 1.]]]]
    /// 
    ///   UpSampling(x, scale=2, sample_type=&#39;nearest&#39;) = [[[[1. 1. 1. 1. 1. 1.]
    ///                                                      [1. 1. 1. 1. 1. 1.]
    ///                                                      [1. 1. 1. 1. 1. 1.]
    ///                                                      [1. 1. 1. 1. 1. 1.]
    ///                                                      [1. 1. 1. 1. 1. 1.]
    ///                                                      [1. 1. 1. 1. 1. 1.]]]]
    /// 
    /// **Bilinear Upsampling**
    /// 
    /// Uses `deconvolution` algorithm under the hood. You need provide both input data and the kernel.
    /// 
    /// Input data is expected to be NCHW.
    /// 
    /// `num_filter` is expected to be same as the number of channels.
    /// 
    /// Example::
    /// 
    ///   x = [[[[1. 1. 1.]
    ///          [1. 1. 1.]
    ///          [1. 1. 1.]]]]
    /// 
    ///   w = [[[[1. 1. 1. 1.]
    ///          [1. 1. 1. 1.]
    ///          [1. 1. 1. 1.]
    ///          [1. 1. 1. 1.]]]]
    ///   
    ///   UpSampling(x, w, scale=2, sample_type=&#39;bilinear&#39;, num_filter=1) = [[[[1. 2. 2. 2. 2. 1.]
    ///                                                                        [2. 4. 4. 4. 4. 2.]
    ///                                                                        [2. 4. 4. 4. 4. 2.]
    ///                                                                        [2. 4. 4. 4. 4. 2.]
    ///                                                                        [2. 4. 4. 4. 4. 2.]
    ///                                                                        [1. 2. 2. 2. 2. 1.]]]]
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\nn\upsampling.cc:L173</summary>
    /// <param name="scale">Up sampling scale</param>
    /// <param name="sampleType">upsampling method</param>
    /// <param name="data">Array of tensors to upsample. For bilinear upsampling, there should be 2 inputs - 1 data and 1 weight.</param>
    /// <param name="numFilter">Input filter. Only used by bilinear sample_type.Since bilinear upsampling uses deconvolution, num_filters is set to the number of channels.</param>
    /// <param name="multiInputMode">How to handle multiple input. concat means concatenate upsampled images along the channel dimension. sum means add all images together, only available for nearest neighbor upsampling.</param>
    /// <param name="workspace">Tmp workspace for deconvolution (MB)</param>
    new(scale : int,
        sampleType : SampleType,
        [<Optional>] ?data : Symbol seq,
        [<Optional>] ?numFilter : int,
        [<Optional>] ?multiInputMode : MultiInputMode,
        [<Optional>] ?workspace : int64) = 
        let data = defaultArg (data |> Option.map Seq.toArray) Array.empty
        let operatorArguments = 
            [
                "data", VarArg("num_args", data)
                "scale", Parameter(Some(box scale))
                "sample_type", Parameter(Some(box sampleType))
                "num_filter", numFilter |> Option.map box |> Parameter
                "multi_input_mode", multiInputMode |> Option.map box |> Parameter
                "workspace", workspace |> Option.map box |> Parameter
            ]
        new UpSampling(Arguments<Symbol>(operatorArguments))
    /// Default value for NumFilter
    /// Input filter. Only used by bilinear sample_type.Since bilinear upsampling uses deconvolution, num_filters is set to the number of channels.
    static member NumFilterDefault : int = 0
    /// Default value for MultiInputMode
    /// How to handle multiple input. concat means concatenate upsampled images along the channel dimension. sum means add all images together, only available for nearest neighbor upsampling.
    static member MultiInputModeDefault : MultiInputMode = MultiInputMode.Concat
    /// Default value for Workspace
    /// Tmp workspace for deconvolution (MB)
    static member WorkspaceDefault : int64 = 512L
    /// Array of tensors to upsample. For bilinear upsampling, there should be 2 inputs - 1 data and 1 weight.
    member __.Data = operatorArguments.GetVarArg "data"
    /// Up sampling scale
    member __.Scale : int = match operatorArguments.GetParameter "scale" with Some(v) -> unbox v | None -> failwithf "Required parameter scale is missing"
    /// upsampling method
    member __.SampleType : SampleType = match operatorArguments.GetParameter "sample_type" with Some(v) -> unbox v | None -> failwithf "Required parameter sample_type is missing"
    /// Input filter. Only used by bilinear sample_type.Since bilinear upsampling uses deconvolution, num_filters is set to the number of channels.
    member __.NumFilter = operatorArguments.GetParameter("num_filter", UpSampling.NumFilterDefault)
    /// How to handle multiple input. concat means concatenate upsampled images along the channel dimension. sum means add all images together, only available for nearest neighbor upsampling.
    member __.MultiInputMode = operatorArguments.GetParameter("multi_input_mode", UpSampling.MultiInputModeDefault)
    /// Tmp workspace for deconvolution (MB)
    member __.Workspace = operatorArguments.GetParameter("workspace", UpSampling.WorkspaceDefault)
    /// <summary>Copy UpSampling instance with updated inputs/parameters.</summary>
    /// <param name="data">Array of tensors to upsample. For bilinear upsampling, there should be 2 inputs - 1 data and 1 weight.</param>
    /// <param name="scale">Up sampling scale</param>
    /// <param name="sampleType">upsampling method</param>
    /// <param name="numFilter">Input filter. Only used by bilinear sample_type.Since bilinear upsampling uses deconvolution, num_filters is set to the number of channels.</param>
    /// <param name="multiInputMode">How to handle multiple input. concat means concatenate upsampled images along the channel dimension. sum means add all images together, only available for nearest neighbor upsampling.</param>
    /// <param name="workspace">Tmp workspace for deconvolution (MB)</param>
    member this.With([<Optional>] ?data : Symbol seq,
        [<Optional>] ?scale : int,
        [<Optional>] ?sampleType : SampleType,
        [<Optional>] ?numFilter : int,
        [<Optional>] ?multiInputMode : MultiInputMode,
        [<Optional>] ?workspace : int64) = 
        let operatorArguments = 
            [
                data |> Option.map (fun x -> "data", VarArg("num_args", Seq.toArray x))
                scale |> Option.map (fun x -> "scale", Parameter(Some (box x)))
                sampleType |> Option.map (fun x -> "sample_type", Parameter(Some (box x)))
                numFilter |> Option.map (fun x -> "num_filter", Parameter(Some (box x)))
                multiInputMode |> Option.map (fun x -> "multi_input_mode", Parameter(Some (box x)))
                workspace |> Option.map (fun x -> "workspace", Parameter(Some (box x)))
            ] |> List.choose id
        new UpSampling(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type NpLinalgSvd private (operatorArguments) = 
    inherit SymbolOperator("_np__linalg_svd", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new NpLinalgSvd(args)
    override this.WithArguments(args : Arguments<Symbol>) = new NpLinalgSvd(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <summary>
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\numpy\linalg\np_gesvd.cc:L93</summary>
    /// <param name="A">Input matrices to be factorized</param>
    new([<Optional>] ?A : Symbol) =
        let A = defaultArg A (new ImplicitVariable() :> Symbol)
        let operatorArguments = 
            [
                "A", Input A
            ]
        new NpLinalgSvd(Arguments<Symbol>(operatorArguments))
    /// Input matrices to be factorized
    member __.A = operatorArguments.GetInput "A"
    /// <summary>Copy NpLinalgSvd instance with updated inputs/parameters.</summary>
    /// <param name="A">Input matrices to be factorized</param>
    member this.With([<Optional>] ?A : Symbol) =
        let operatorArguments = 
            [
                A |> Option.map (fun x -> "A", Input x)
            ] |> List.choose id
        new NpLinalgSvd(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type NpiArgmax private (operatorArguments) = 
    inherit SymbolOperator("_npi_argmax", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new NpiArgmax(args)
    override this.WithArguments(args : Arguments<Symbol>) = new NpiArgmax(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <param name="data">The input</param>
    /// <param name="axis">The axis along which to perform the reduction. Negative values means indexing from right to left. ``Requires axis to be set as int, because global reduction is not supported yet.``</param>
    /// <param name="keepdims">If this is set to `True`, the reduced axis is left in the result as dimension with size one.</param>
    new([<Optional>] ?data : Symbol,
        [<Optional>] ?axis : int,
        [<Optional>] ?keepdims : bool) = 
        let data = defaultArg data (new ImplicitVariable() :> Symbol)
        let operatorArguments = 
            [
                "data", Input data
                "axis", axis |> Option.map box |> Parameter
                "keepdims", keepdims |> Option.map box |> Parameter
            ]
        new NpiArgmax(Arguments<Symbol>(operatorArguments))
    /// Default value for Axis
    /// The axis along which to perform the reduction. Negative values means indexing from right to left. ``Requires axis to be set as int, because global reduction is not supported yet.``
    static member AxisDefault : int option = None
    /// Default value for Keepdims
    /// If this is set to `True`, the reduced axis is left in the result as dimension with size one.
    static member KeepdimsDefault : bool = false
    /// The input
    member __.Data = operatorArguments.GetInput "data"
    /// The axis along which to perform the reduction. Negative values means indexing from right to left. ``Requires axis to be set as int, because global reduction is not supported yet.``
    member __.Axis = operatorArguments.GetParameter("axis", NpiArgmax.AxisDefault)
    /// If this is set to `True`, the reduced axis is left in the result as dimension with size one.
    member __.Keepdims = operatorArguments.GetParameter("keepdims", NpiArgmax.KeepdimsDefault)
    /// <summary>Copy NpiArgmax instance with updated inputs/parameters.</summary>
    /// <param name="data">The input</param>
    /// <param name="axis">The axis along which to perform the reduction. Negative values means indexing from right to left. ``Requires axis to be set as int, because global reduction is not supported yet.``</param>
    /// <param name="keepdims">If this is set to `True`, the reduced axis is left in the result as dimension with size one.</param>
    member this.With([<Optional>] ?data : Symbol,
        [<Optional>] ?axis : int,
        [<Optional>] ?keepdims : bool) = 
        let operatorArguments = 
            [
                data |> Option.map (fun x -> "data", Input x)
                axis |> Option.map (fun x -> "axis", Parameter(Some (box x)))
                keepdims |> Option.map (fun x -> "keepdims", Parameter(Some (box x)))
            ] |> List.choose id
        new NpiArgmax(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type NpSum private (operatorArguments) = 
    inherit SymbolOperator("_np_sum", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new NpSum(args)
    override this.WithArguments(args : Arguments<Symbol>) = new NpSum(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <summary>
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\numpy\np_broadcast_reduce_op_value.cc:L53</summary>
    /// <param name="a">The input</param>
    /// <param name="axis">Axis or axes along which a sum is performed. The default, axis=None, will sum all of the elements of the input array. If axis is negative it counts from the last to the first axis.</param>
    /// <param name="dtype">The type of the returned array and of the accumulator in which the elements are summed. The dtype of a is used by default unless a has an integer dtype of less precision than the default platform integer. In that case, if a is signed then the platform integer is used while if a is unsigned then an unsigned integer of the same precision as the platform integer is used.</param>
    /// <param name="keepdims">If this is set to `True`, the reduced axes are left in the result as dimension with size one.</param>
    /// <param name="initial">Starting value for the sum.</param>
    new([<Optional>] ?a : Symbol,
        [<Optional>] ?axis : int seq,
        [<Optional>] ?dtype : NpSumDtype,
        [<Optional>] ?keepdims : bool,
        [<Optional>] ?initial : float) = 
        let a = defaultArg a (new ImplicitVariable() :> Symbol)
        let operatorArguments = 
            [
                "a", Input a
                "axis", axis |> Option.map box |> Parameter
                "dtype", dtype |> Option.map box |> Parameter
                "keepdims", keepdims |> Option.map box |> Parameter
                "initial", initial |> Option.map box |> Parameter
            ]
        new NpSum(Arguments<Symbol>(operatorArguments))
    /// Default value for Axis
    /// Axis or axes along which a sum is performed. The default, axis=None, will sum all of the elements of the input array. If axis is negative it counts from the last to the first axis.
    static member AxisDefault : int [] option = None
    /// Default value for Dtype
    /// The type of the returned array and of the accumulator in which the elements are summed. The dtype of a is used by default unless a has an integer dtype of less precision than the default platform integer. In that case, if a is signed then the platform integer is used while if a is unsigned then an unsigned integer of the same precision as the platform integer is used.
    static member DtypeDefault : NpSumDtype option = None
    /// Default value for Keepdims
    /// If this is set to `True`, the reduced axes are left in the result as dimension with size one.
    static member KeepdimsDefault : bool = false
    /// Default value for Initial
    /// Starting value for the sum.
    static member InitialDefault : double option = None
    /// The input
    member __.A = operatorArguments.GetInput "a"
    /// Axis or axes along which a sum is performed. The default, axis=None, will sum all of the elements of the input array. If axis is negative it counts from the last to the first axis.
    member __.Axis = operatorArguments.GetParameter("axis", NpSum.AxisDefault)
    /// The type of the returned array and of the accumulator in which the elements are summed. The dtype of a is used by default unless a has an integer dtype of less precision than the default platform integer. In that case, if a is signed then the platform integer is used while if a is unsigned then an unsigned integer of the same precision as the platform integer is used.
    member __.Dtype = operatorArguments.GetParameter("dtype", NpSum.DtypeDefault)
    /// If this is set to `True`, the reduced axes are left in the result as dimension with size one.
    member __.Keepdims = operatorArguments.GetParameter("keepdims", NpSum.KeepdimsDefault)
    /// Starting value for the sum.
    member __.Initial = operatorArguments.GetParameter("initial", NpSum.InitialDefault)
    /// <summary>Copy NpSum instance with updated inputs/parameters.</summary>
    /// <param name="a">The input</param>
    /// <param name="axis">Axis or axes along which a sum is performed. The default, axis=None, will sum all of the elements of the input array. If axis is negative it counts from the last to the first axis.</param>
    /// <param name="dtype">The type of the returned array and of the accumulator in which the elements are summed. The dtype of a is used by default unless a has an integer dtype of less precision than the default platform integer. In that case, if a is signed then the platform integer is used while if a is unsigned then an unsigned integer of the same precision as the platform integer is used.</param>
    /// <param name="keepdims">If this is set to `True`, the reduced axes are left in the result as dimension with size one.</param>
    /// <param name="initial">Starting value for the sum.</param>
    member this.With([<Optional>] ?a : Symbol,
        [<Optional>] ?axis : int seq,
        [<Optional>] ?dtype : NpSumDtype,
        [<Optional>] ?keepdims : bool,
        [<Optional>] ?initial : float) = 
        let operatorArguments = 
            [
                a |> Option.map (fun x -> "a", Input x)
                axis |> Option.map (fun x -> "axis", Parameter(Some (box x)))
                dtype |> Option.map (fun x -> "dtype", Parameter(Some (box x)))
                keepdims |> Option.map (fun x -> "keepdims", Parameter(Some (box x)))
                initial |> Option.map (fun x -> "initial", Parameter(Some (box x)))
            ] |> List.choose id
        new NpSum(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type NpMax private (operatorArguments) = 
    inherit SymbolOperator("_np_max", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new NpMax(args)
    override this.WithArguments(args : Arguments<Symbol>) = new NpMax(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <summary>
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\numpy\np_broadcast_reduce_op_value.cc:L91</summary>
    /// <param name="a">The input</param>
    /// <param name="axis">Axis or axes along which a sum is performed. The default, axis=None, will sum all of the elements of the input array. If axis is negative it counts from the last to the first axis.</param>
    /// <param name="keepdims">If this is set to `True`, the reduced axes are left in the result as dimension with size one.</param>
    /// <param name="initial">Starting value for the sum.</param>
    new([<Optional>] ?a : Symbol,
        [<Optional>] ?axis : int seq,
        [<Optional>] ?keepdims : bool,
        [<Optional>] ?initial : float) = 
        let a = defaultArg a (new ImplicitVariable() :> Symbol)
        let operatorArguments = 
            [
                "a", Input a
                "axis", axis |> Option.map box |> Parameter
                "keepdims", keepdims |> Option.map box |> Parameter
                "initial", initial |> Option.map box |> Parameter
            ]
        new NpMax(Arguments<Symbol>(operatorArguments))
    /// Default value for Axis
    /// Axis or axes along which a sum is performed. The default, axis=None, will sum all of the elements of the input array. If axis is negative it counts from the last to the first axis.
    static member AxisDefault : int [] option = None
    /// Default value for Keepdims
    /// If this is set to `True`, the reduced axes are left in the result as dimension with size one.
    static member KeepdimsDefault : bool = false
    /// Default value for Initial
    /// Starting value for the sum.
    static member InitialDefault : double option = None
    /// The input
    member __.A = operatorArguments.GetInput "a"
    /// Axis or axes along which a sum is performed. The default, axis=None, will sum all of the elements of the input array. If axis is negative it counts from the last to the first axis.
    member __.Axis = operatorArguments.GetParameter("axis", NpMax.AxisDefault)
    /// If this is set to `True`, the reduced axes are left in the result as dimension with size one.
    member __.Keepdims = operatorArguments.GetParameter("keepdims", NpMax.KeepdimsDefault)
    /// Starting value for the sum.
    member __.Initial = operatorArguments.GetParameter("initial", NpMax.InitialDefault)
    /// <summary>Copy NpMax instance with updated inputs/parameters.</summary>
    /// <param name="a">The input</param>
    /// <param name="axis">Axis or axes along which a sum is performed. The default, axis=None, will sum all of the elements of the input array. If axis is negative it counts from the last to the first axis.</param>
    /// <param name="keepdims">If this is set to `True`, the reduced axes are left in the result as dimension with size one.</param>
    /// <param name="initial">Starting value for the sum.</param>
    member this.With([<Optional>] ?a : Symbol,
        [<Optional>] ?axis : int seq,
        [<Optional>] ?keepdims : bool,
        [<Optional>] ?initial : float) = 
        let operatorArguments = 
            [
                a |> Option.map (fun x -> "a", Input x)
                axis |> Option.map (fun x -> "axis", Parameter(Some (box x)))
                keepdims |> Option.map (fun x -> "keepdims", Parameter(Some (box x)))
                initial |> Option.map (fun x -> "initial", Parameter(Some (box x)))
            ] |> List.choose id
        new NpMax(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type NpMin private (operatorArguments) = 
    inherit SymbolOperator("_np_min", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new NpMin(args)
    override this.WithArguments(args : Arguments<Symbol>) = new NpMin(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <summary>
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\numpy\np_broadcast_reduce_op_value.cc:L118</summary>
    /// <param name="a">The input</param>
    /// <param name="axis">Axis or axes along which a sum is performed. The default, axis=None, will sum all of the elements of the input array. If axis is negative it counts from the last to the first axis.</param>
    /// <param name="keepdims">If this is set to `True`, the reduced axes are left in the result as dimension with size one.</param>
    /// <param name="initial">Starting value for the sum.</param>
    new([<Optional>] ?a : Symbol,
        [<Optional>] ?axis : int seq,
        [<Optional>] ?keepdims : bool,
        [<Optional>] ?initial : float) = 
        let a = defaultArg a (new ImplicitVariable() :> Symbol)
        let operatorArguments = 
            [
                "a", Input a
                "axis", axis |> Option.map box |> Parameter
                "keepdims", keepdims |> Option.map box |> Parameter
                "initial", initial |> Option.map box |> Parameter
            ]
        new NpMin(Arguments<Symbol>(operatorArguments))
    /// Default value for Axis
    /// Axis or axes along which a sum is performed. The default, axis=None, will sum all of the elements of the input array. If axis is negative it counts from the last to the first axis.
    static member AxisDefault : int [] option = None
    /// Default value for Keepdims
    /// If this is set to `True`, the reduced axes are left in the result as dimension with size one.
    static member KeepdimsDefault : bool = false
    /// Default value for Initial
    /// Starting value for the sum.
    static member InitialDefault : double option = None
    /// The input
    member __.A = operatorArguments.GetInput "a"
    /// Axis or axes along which a sum is performed. The default, axis=None, will sum all of the elements of the input array. If axis is negative it counts from the last to the first axis.
    member __.Axis = operatorArguments.GetParameter("axis", NpMin.AxisDefault)
    /// If this is set to `True`, the reduced axes are left in the result as dimension with size one.
    member __.Keepdims = operatorArguments.GetParameter("keepdims", NpMin.KeepdimsDefault)
    /// Starting value for the sum.
    member __.Initial = operatorArguments.GetParameter("initial", NpMin.InitialDefault)
    /// <summary>Copy NpMin instance with updated inputs/parameters.</summary>
    /// <param name="a">The input</param>
    /// <param name="axis">Axis or axes along which a sum is performed. The default, axis=None, will sum all of the elements of the input array. If axis is negative it counts from the last to the first axis.</param>
    /// <param name="keepdims">If this is set to `True`, the reduced axes are left in the result as dimension with size one.</param>
    /// <param name="initial">Starting value for the sum.</param>
    member this.With([<Optional>] ?a : Symbol,
        [<Optional>] ?axis : int seq,
        [<Optional>] ?keepdims : bool,
        [<Optional>] ?initial : float) = 
        let operatorArguments = 
            [
                a |> Option.map (fun x -> "a", Input x)
                axis |> Option.map (fun x -> "axis", Parameter(Some (box x)))
                keepdims |> Option.map (fun x -> "keepdims", Parameter(Some (box x)))
                initial |> Option.map (fun x -> "initial", Parameter(Some (box x)))
            ] |> List.choose id
        new NpMin(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type NpProd private (operatorArguments) = 
    inherit SymbolOperator("_np_prod", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new NpProd(args)
    override this.WithArguments(args : Arguments<Symbol>) = new NpProd(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <param name="a">The input</param>
    /// <param name="axis">Axis or axes along which a sum is performed. The default, axis=None, will sum all of the elements of the input array. If axis is negative it counts from the last to the first axis.</param>
    /// <param name="dtype">The type of the returned array and of the accumulator in which the elements are summed. The dtype of a is used by default unless a has an integer dtype of less precision than the default platform integer. In that case, if a is signed then the platform integer is used while if a is unsigned then an unsigned integer of the same precision as the platform integer is used.</param>
    /// <param name="keepdims">If this is set to `True`, the reduced axes are left in the result as dimension with size one.</param>
    /// <param name="initial">Starting value for the sum.</param>
    new([<Optional>] ?a : Symbol,
        [<Optional>] ?axis : int seq,
        [<Optional>] ?dtype : NpProdDtype,
        [<Optional>] ?keepdims : bool,
        [<Optional>] ?initial : float) = 
        let a = defaultArg a (new ImplicitVariable() :> Symbol)
        let operatorArguments = 
            [
                "a", Input a
                "axis", axis |> Option.map box |> Parameter
                "dtype", dtype |> Option.map box |> Parameter
                "keepdims", keepdims |> Option.map box |> Parameter
                "initial", initial |> Option.map box |> Parameter
            ]
        new NpProd(Arguments<Symbol>(operatorArguments))
    /// Default value for Axis
    /// Axis or axes along which a sum is performed. The default, axis=None, will sum all of the elements of the input array. If axis is negative it counts from the last to the first axis.
    static member AxisDefault : int [] option = None
    /// Default value for Dtype
    /// The type of the returned array and of the accumulator in which the elements are summed. The dtype of a is used by default unless a has an integer dtype of less precision than the default platform integer. In that case, if a is signed then the platform integer is used while if a is unsigned then an unsigned integer of the same precision as the platform integer is used.
    static member DtypeDefault : NpProdDtype option = None
    /// Default value for Keepdims
    /// If this is set to `True`, the reduced axes are left in the result as dimension with size one.
    static member KeepdimsDefault : bool = false
    /// Default value for Initial
    /// Starting value for the sum.
    static member InitialDefault : double option = None
    /// The input
    member __.A = operatorArguments.GetInput "a"
    /// Axis or axes along which a sum is performed. The default, axis=None, will sum all of the elements of the input array. If axis is negative it counts from the last to the first axis.
    member __.Axis = operatorArguments.GetParameter("axis", NpProd.AxisDefault)
    /// The type of the returned array and of the accumulator in which the elements are summed. The dtype of a is used by default unless a has an integer dtype of less precision than the default platform integer. In that case, if a is signed then the platform integer is used while if a is unsigned then an unsigned integer of the same precision as the platform integer is used.
    member __.Dtype = operatorArguments.GetParameter("dtype", NpProd.DtypeDefault)
    /// If this is set to `True`, the reduced axes are left in the result as dimension with size one.
    member __.Keepdims = operatorArguments.GetParameter("keepdims", NpProd.KeepdimsDefault)
    /// Starting value for the sum.
    member __.Initial = operatorArguments.GetParameter("initial", NpProd.InitialDefault)
    /// <summary>Copy NpProd instance with updated inputs/parameters.</summary>
    /// <param name="a">The input</param>
    /// <param name="axis">Axis or axes along which a sum is performed. The default, axis=None, will sum all of the elements of the input array. If axis is negative it counts from the last to the first axis.</param>
    /// <param name="dtype">The type of the returned array and of the accumulator in which the elements are summed. The dtype of a is used by default unless a has an integer dtype of less precision than the default platform integer. In that case, if a is signed then the platform integer is used while if a is unsigned then an unsigned integer of the same precision as the platform integer is used.</param>
    /// <param name="keepdims">If this is set to `True`, the reduced axes are left in the result as dimension with size one.</param>
    /// <param name="initial">Starting value for the sum.</param>
    member this.With([<Optional>] ?a : Symbol,
        [<Optional>] ?axis : int seq,
        [<Optional>] ?dtype : NpProdDtype,
        [<Optional>] ?keepdims : bool,
        [<Optional>] ?initial : float) = 
        let operatorArguments = 
            [
                a |> Option.map (fun x -> "a", Input x)
                axis |> Option.map (fun x -> "axis", Parameter(Some (box x)))
                dtype |> Option.map (fun x -> "dtype", Parameter(Some (box x)))
                keepdims |> Option.map (fun x -> "keepdims", Parameter(Some (box x)))
                initial |> Option.map (fun x -> "initial", Parameter(Some (box x)))
            ] |> List.choose id
        new NpProd(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type NpiMean private (operatorArguments) = 
    inherit SymbolOperator("_npi_mean", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new NpiMean(args)
    override this.WithArguments(args : Arguments<Symbol>) = new NpiMean(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <param name="a">The input</param>
    /// <param name="axis">Axis or axes along which a sum is performed. The default, axis=None, will sum all of the elements of the input array. If axis is negative it counts from the last to the first axis.</param>
    /// <param name="dtype">The type of the returned array and of the accumulator in which the elements are summed. The dtype of a is used by default unless a has an integer dtype of less precision than the default platform integer. In that case, if a is signed then the platform integer is used while if a is unsigned then an unsigned integer of the same precision as the platform integer is used.</param>
    /// <param name="keepdims">If this is set to `True`, the reduced axes are left in the result as dimension with size one.</param>
    /// <param name="initial">Starting value for the sum.</param>
    new([<Optional>] ?a : Symbol,
        [<Optional>] ?axis : int seq,
        [<Optional>] ?dtype : NpiMeanDtype,
        [<Optional>] ?keepdims : bool,
        [<Optional>] ?initial : float) = 
        let a = defaultArg a (new ImplicitVariable() :> Symbol)
        let operatorArguments = 
            [
                "a", Input a
                "axis", axis |> Option.map box |> Parameter
                "dtype", dtype |> Option.map box |> Parameter
                "keepdims", keepdims |> Option.map box |> Parameter
                "initial", initial |> Option.map box |> Parameter
            ]
        new NpiMean(Arguments<Symbol>(operatorArguments))
    /// Default value for Axis
    /// Axis or axes along which a sum is performed. The default, axis=None, will sum all of the elements of the input array. If axis is negative it counts from the last to the first axis.
    static member AxisDefault : int [] option = None
    /// Default value for Dtype
    /// The type of the returned array and of the accumulator in which the elements are summed. The dtype of a is used by default unless a has an integer dtype of less precision than the default platform integer. In that case, if a is signed then the platform integer is used while if a is unsigned then an unsigned integer of the same precision as the platform integer is used.
    static member DtypeDefault : NpiMeanDtype option = None
    /// Default value for Keepdims
    /// If this is set to `True`, the reduced axes are left in the result as dimension with size one.
    static member KeepdimsDefault : bool = false
    /// Default value for Initial
    /// Starting value for the sum.
    static member InitialDefault : double option = None
    /// The input
    member __.A = operatorArguments.GetInput "a"
    /// Axis or axes along which a sum is performed. The default, axis=None, will sum all of the elements of the input array. If axis is negative it counts from the last to the first axis.
    member __.Axis = operatorArguments.GetParameter("axis", NpiMean.AxisDefault)
    /// The type of the returned array and of the accumulator in which the elements are summed. The dtype of a is used by default unless a has an integer dtype of less precision than the default platform integer. In that case, if a is signed then the platform integer is used while if a is unsigned then an unsigned integer of the same precision as the platform integer is used.
    member __.Dtype = operatorArguments.GetParameter("dtype", NpiMean.DtypeDefault)
    /// If this is set to `True`, the reduced axes are left in the result as dimension with size one.
    member __.Keepdims = operatorArguments.GetParameter("keepdims", NpiMean.KeepdimsDefault)
    /// Starting value for the sum.
    member __.Initial = operatorArguments.GetParameter("initial", NpiMean.InitialDefault)
    /// <summary>Copy NpiMean instance with updated inputs/parameters.</summary>
    /// <param name="a">The input</param>
    /// <param name="axis">Axis or axes along which a sum is performed. The default, axis=None, will sum all of the elements of the input array. If axis is negative it counts from the last to the first axis.</param>
    /// <param name="dtype">The type of the returned array and of the accumulator in which the elements are summed. The dtype of a is used by default unless a has an integer dtype of less precision than the default platform integer. In that case, if a is signed then the platform integer is used while if a is unsigned then an unsigned integer of the same precision as the platform integer is used.</param>
    /// <param name="keepdims">If this is set to `True`, the reduced axes are left in the result as dimension with size one.</param>
    /// <param name="initial">Starting value for the sum.</param>
    member this.With([<Optional>] ?a : Symbol,
        [<Optional>] ?axis : int seq,
        [<Optional>] ?dtype : NpiMeanDtype,
        [<Optional>] ?keepdims : bool,
        [<Optional>] ?initial : float) = 
        let operatorArguments = 
            [
                a |> Option.map (fun x -> "a", Input x)
                axis |> Option.map (fun x -> "axis", Parameter(Some (box x)))
                dtype |> Option.map (fun x -> "dtype", Parameter(Some (box x)))
                keepdims |> Option.map (fun x -> "keepdims", Parameter(Some (box x)))
                initial |> Option.map (fun x -> "initial", Parameter(Some (box x)))
            ] |> List.choose id
        new NpiMean(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type NpiStd private (operatorArguments) = 
    inherit SymbolOperator("_npi_std", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new NpiStd(args)
    override this.WithArguments(args : Arguments<Symbol>) = new NpiStd(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <param name="a">The input</param>
    /// <param name="axis">Axis or axes along which a sum is performed. The default, axis=None, will sum all of the elements of the input array. If axis is negative it counts from the last to the first axis.</param>
    /// <param name="dtype">The type of the returned array and of the accumulator in which the elements are summed. The dtype of a is used by default unless a has an integer dtype of less precision than the default platform integer. In that case, if a is signed then the platform integer is used while if a is unsigned then an unsigned integer of the same precision as the platform integer is used.</param>
    /// <param name="ddof">Starting value for the sum.</param>
    /// <param name="keepdims">If this is set to `True`, the reduced axes are left in the result as dimension with size one.</param>
    new([<Optional>] ?a : Symbol,
        [<Optional>] ?axis : int seq,
        [<Optional>] ?dtype : NpiStdDtype,
        [<Optional>] ?ddof : int,
        [<Optional>] ?keepdims : bool) = 
        let a = defaultArg a (new ImplicitVariable() :> Symbol)
        let operatorArguments = 
            [
                "a", Input a
                "axis", axis |> Option.map box |> Parameter
                "dtype", dtype |> Option.map box |> Parameter
                "ddof", ddof |> Option.map box |> Parameter
                "keepdims", keepdims |> Option.map box |> Parameter
            ]
        new NpiStd(Arguments<Symbol>(operatorArguments))
    /// Default value for Axis
    /// Axis or axes along which a sum is performed. The default, axis=None, will sum all of the elements of the input array. If axis is negative it counts from the last to the first axis.
    static member AxisDefault : int [] option = None
    /// Default value for Dtype
    /// The type of the returned array and of the accumulator in which the elements are summed. The dtype of a is used by default unless a has an integer dtype of less precision than the default platform integer. In that case, if a is signed then the platform integer is used while if a is unsigned then an unsigned integer of the same precision as the platform integer is used.
    static member DtypeDefault : NpiStdDtype option = None
    /// Default value for Ddof
    /// Starting value for the sum.
    static member DdofDefault : int = 0
    /// Default value for Keepdims
    /// If this is set to `True`, the reduced axes are left in the result as dimension with size one.
    static member KeepdimsDefault : bool = false
    /// The input
    member __.A = operatorArguments.GetInput "a"
    /// Axis or axes along which a sum is performed. The default, axis=None, will sum all of the elements of the input array. If axis is negative it counts from the last to the first axis.
    member __.Axis = operatorArguments.GetParameter("axis", NpiStd.AxisDefault)
    /// The type of the returned array and of the accumulator in which the elements are summed. The dtype of a is used by default unless a has an integer dtype of less precision than the default platform integer. In that case, if a is signed then the platform integer is used while if a is unsigned then an unsigned integer of the same precision as the platform integer is used.
    member __.Dtype = operatorArguments.GetParameter("dtype", NpiStd.DtypeDefault)
    /// Starting value for the sum.
    member __.Ddof = operatorArguments.GetParameter("ddof", NpiStd.DdofDefault)
    /// If this is set to `True`, the reduced axes are left in the result as dimension with size one.
    member __.Keepdims = operatorArguments.GetParameter("keepdims", NpiStd.KeepdimsDefault)
    /// <summary>Copy NpiStd instance with updated inputs/parameters.</summary>
    /// <param name="a">The input</param>
    /// <param name="axis">Axis or axes along which a sum is performed. The default, axis=None, will sum all of the elements of the input array. If axis is negative it counts from the last to the first axis.</param>
    /// <param name="dtype">The type of the returned array and of the accumulator in which the elements are summed. The dtype of a is used by default unless a has an integer dtype of less precision than the default platform integer. In that case, if a is signed then the platform integer is used while if a is unsigned then an unsigned integer of the same precision as the platform integer is used.</param>
    /// <param name="ddof">Starting value for the sum.</param>
    /// <param name="keepdims">If this is set to `True`, the reduced axes are left in the result as dimension with size one.</param>
    member this.With([<Optional>] ?a : Symbol,
        [<Optional>] ?axis : int seq,
        [<Optional>] ?dtype : NpiStdDtype,
        [<Optional>] ?ddof : int,
        [<Optional>] ?keepdims : bool) = 
        let operatorArguments = 
            [
                a |> Option.map (fun x -> "a", Input x)
                axis |> Option.map (fun x -> "axis", Parameter(Some (box x)))
                dtype |> Option.map (fun x -> "dtype", Parameter(Some (box x)))
                ddof |> Option.map (fun x -> "ddof", Parameter(Some (box x)))
                keepdims |> Option.map (fun x -> "keepdims", Parameter(Some (box x)))
            ] |> List.choose id
        new NpiStd(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type NpiVar private (operatorArguments) = 
    inherit SymbolOperator("_npi_var", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new NpiVar(args)
    override this.WithArguments(args : Arguments<Symbol>) = new NpiVar(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <param name="a">The input</param>
    /// <param name="axis">Axis or axes along which a sum is performed. The default, axis=None, will sum all of the elements of the input array. If axis is negative it counts from the last to the first axis.</param>
    /// <param name="dtype">The type of the returned array and of the accumulator in which the elements are summed. The dtype of a is used by default unless a has an integer dtype of less precision than the default platform integer. In that case, if a is signed then the platform integer is used while if a is unsigned then an unsigned integer of the same precision as the platform integer is used.</param>
    /// <param name="ddof">Starting value for the sum.</param>
    /// <param name="keepdims">If this is set to `True`, the reduced axes are left in the result as dimension with size one.</param>
    new([<Optional>] ?a : Symbol,
        [<Optional>] ?axis : int seq,
        [<Optional>] ?dtype : NpiVarDtype,
        [<Optional>] ?ddof : int,
        [<Optional>] ?keepdims : bool) = 
        let a = defaultArg a (new ImplicitVariable() :> Symbol)
        let operatorArguments = 
            [
                "a", Input a
                "axis", axis |> Option.map box |> Parameter
                "dtype", dtype |> Option.map box |> Parameter
                "ddof", ddof |> Option.map box |> Parameter
                "keepdims", keepdims |> Option.map box |> Parameter
            ]
        new NpiVar(Arguments<Symbol>(operatorArguments))
    /// Default value for Axis
    /// Axis or axes along which a sum is performed. The default, axis=None, will sum all of the elements of the input array. If axis is negative it counts from the last to the first axis.
    static member AxisDefault : int [] option = None
    /// Default value for Dtype
    /// The type of the returned array and of the accumulator in which the elements are summed. The dtype of a is used by default unless a has an integer dtype of less precision than the default platform integer. In that case, if a is signed then the platform integer is used while if a is unsigned then an unsigned integer of the same precision as the platform integer is used.
    static member DtypeDefault : NpiVarDtype option = None
    /// Default value for Ddof
    /// Starting value for the sum.
    static member DdofDefault : int = 0
    /// Default value for Keepdims
    /// If this is set to `True`, the reduced axes are left in the result as dimension with size one.
    static member KeepdimsDefault : bool = false
    /// The input
    member __.A = operatorArguments.GetInput "a"
    /// Axis or axes along which a sum is performed. The default, axis=None, will sum all of the elements of the input array. If axis is negative it counts from the last to the first axis.
    member __.Axis = operatorArguments.GetParameter("axis", NpiVar.AxisDefault)
    /// The type of the returned array and of the accumulator in which the elements are summed. The dtype of a is used by default unless a has an integer dtype of less precision than the default platform integer. In that case, if a is signed then the platform integer is used while if a is unsigned then an unsigned integer of the same precision as the platform integer is used.
    member __.Dtype = operatorArguments.GetParameter("dtype", NpiVar.DtypeDefault)
    /// Starting value for the sum.
    member __.Ddof = operatorArguments.GetParameter("ddof", NpiVar.DdofDefault)
    /// If this is set to `True`, the reduced axes are left in the result as dimension with size one.
    member __.Keepdims = operatorArguments.GetParameter("keepdims", NpiVar.KeepdimsDefault)
    /// <summary>Copy NpiVar instance with updated inputs/parameters.</summary>
    /// <param name="a">The input</param>
    /// <param name="axis">Axis or axes along which a sum is performed. The default, axis=None, will sum all of the elements of the input array. If axis is negative it counts from the last to the first axis.</param>
    /// <param name="dtype">The type of the returned array and of the accumulator in which the elements are summed. The dtype of a is used by default unless a has an integer dtype of less precision than the default platform integer. In that case, if a is signed then the platform integer is used while if a is unsigned then an unsigned integer of the same precision as the platform integer is used.</param>
    /// <param name="ddof">Starting value for the sum.</param>
    /// <param name="keepdims">If this is set to `True`, the reduced axes are left in the result as dimension with size one.</param>
    member this.With([<Optional>] ?a : Symbol,
        [<Optional>] ?axis : int seq,
        [<Optional>] ?dtype : NpiVarDtype,
        [<Optional>] ?ddof : int,
        [<Optional>] ?keepdims : bool) = 
        let operatorArguments = 
            [
                a |> Option.map (fun x -> "a", Input x)
                axis |> Option.map (fun x -> "axis", Parameter(Some (box x)))
                dtype |> Option.map (fun x -> "dtype", Parameter(Some (box x)))
                ddof |> Option.map (fun x -> "ddof", Parameter(Some (box x)))
                keepdims |> Option.map (fun x -> "keepdims", Parameter(Some (box x)))
            ] |> List.choose id
        new NpiVar(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type NpBroadcastTo private (operatorArguments) = 
    inherit SymbolOperator("_np_broadcast_to", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new NpBroadcastTo(args)
    override this.WithArguments(args : Arguments<Symbol>) = new NpBroadcastTo(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <param name="array">The input</param>
    /// <param name="shape">The shape of the desired array. We can set the dim to zero if it&#39;s same as the original. E.g `A = broadcast_to(B, shape=(10, 0, 0))` has the same meaning as `A = broadcast_axis(B, axis=0, size=10)`.</param>
    new([<Optional>] ?array : Symbol,
        [<Optional>] ?shape : int seq) = 
        let array = defaultArg array (new ImplicitVariable() :> Symbol)
        let operatorArguments = 
            [
                "array", Input array
                "shape", shape |> Option.map box |> Parameter
            ]
        new NpBroadcastTo(Arguments<Symbol>(operatorArguments))
    /// Default value for Shape
    /// The shape of the desired array. We can set the dim to zero if it&#39;s same as the original. E.g `A = broadcast_to(B, shape=(10, 0, 0))` has the same meaning as `A = broadcast_axis(B, axis=0, size=10)`.
    static member ShapeDefault : int [] = [||]
    /// The input
    member __.Array = operatorArguments.GetInput "array"
    /// The shape of the desired array. We can set the dim to zero if it&#39;s same as the original. E.g `A = broadcast_to(B, shape=(10, 0, 0))` has the same meaning as `A = broadcast_axis(B, axis=0, size=10)`.
    member __.Shape = operatorArguments.GetParameter("shape", NpBroadcastTo.ShapeDefault)
    /// <summary>Copy NpBroadcastTo instance with updated inputs/parameters.</summary>
    /// <param name="array">The input</param>
    /// <param name="shape">The shape of the desired array. We can set the dim to zero if it&#39;s same as the original. E.g `A = broadcast_to(B, shape=(10, 0, 0))` has the same meaning as `A = broadcast_axis(B, axis=0, size=10)`.</param>
    member this.With([<Optional>] ?array : Symbol,
        [<Optional>] ?shape : int seq) = 
        let operatorArguments = 
            [
                array |> Option.map (fun x -> "array", Input x)
                shape |> Option.map (fun x -> "shape", Parameter(Some (box x)))
            ] |> List.choose id
        new NpBroadcastTo(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type NpCumsum private (operatorArguments) = 
    inherit SymbolOperator("_np_cumsum", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new NpCumsum(args)
    override this.WithArguments(args : Arguments<Symbol>) = new NpCumsum(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <summary>Return the cumulative sum of the elements along a given axis.
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\numpy\np_cumsum.cc:L67</summary>
    /// <param name="a">Input ndarray</param>
    /// <param name="axis">Axis along which the cumulative sum is computed. The default (None) is to compute the cumsum over the flattened array.</param>
    /// <param name="dtype">Type of the returned array and of the accumulator in which the elements are summed. If dtype is not specified, it defaults to the dtype of a, unless a has an integer dtype with a precision less than that of the default platform integer. In that case, the default platform integer is used.</param>
    new([<Optional>] ?a : Symbol,
        [<Optional>] ?axis : int,
        [<Optional>] ?dtype : NpCumsumDtype) = 
        let a = defaultArg a (new ImplicitVariable() :> Symbol)
        let operatorArguments = 
            [
                "a", Input a
                "axis", axis |> Option.map box |> Parameter
                "dtype", dtype |> Option.map box |> Parameter
            ]
        new NpCumsum(Arguments<Symbol>(operatorArguments))
    /// Default value for Axis
    /// Axis along which the cumulative sum is computed. The default (None) is to compute the cumsum over the flattened array.
    static member AxisDefault : int option = None
    /// Default value for Dtype
    /// Type of the returned array and of the accumulator in which the elements are summed. If dtype is not specified, it defaults to the dtype of a, unless a has an integer dtype with a precision less than that of the default platform integer. In that case, the default platform integer is used.
    static member DtypeDefault : NpCumsumDtype option = None
    /// Input ndarray
    member __.A = operatorArguments.GetInput "a"
    /// Axis along which the cumulative sum is computed. The default (None) is to compute the cumsum over the flattened array.
    member __.Axis = operatorArguments.GetParameter("axis", NpCumsum.AxisDefault)
    /// Type of the returned array and of the accumulator in which the elements are summed. If dtype is not specified, it defaults to the dtype of a, unless a has an integer dtype with a precision less than that of the default platform integer. In that case, the default platform integer is used.
    member __.Dtype = operatorArguments.GetParameter("dtype", NpCumsum.DtypeDefault)
    /// <summary>Copy NpCumsum instance with updated inputs/parameters.</summary>
    /// <param name="a">Input ndarray</param>
    /// <param name="axis">Axis along which the cumulative sum is computed. The default (None) is to compute the cumsum over the flattened array.</param>
    /// <param name="dtype">Type of the returned array and of the accumulator in which the elements are summed. If dtype is not specified, it defaults to the dtype of a, unless a has an integer dtype with a precision less than that of the default platform integer. In that case, the default platform integer is used.</param>
    member this.With([<Optional>] ?a : Symbol,
        [<Optional>] ?axis : int,
        [<Optional>] ?dtype : NpCumsumDtype) = 
        let operatorArguments = 
            [
                a |> Option.map (fun x -> "a", Input x)
                axis |> Option.map (fun x -> "axis", Parameter(Some (box x)))
                dtype |> Option.map (fun x -> "dtype", Parameter(Some (box x)))
            ] |> List.choose id
        new NpCumsum(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type NpDot private (operatorArguments) = 
    inherit SymbolOperator("_np_dot", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new NpDot(args)
    override this.WithArguments(args : Arguments<Symbol>) = new NpDot(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <summary>Dot product of two arrays. Specifically,
    /// 
    /// - If both a and b are 1-D arrays, it is inner product of vectors.
    /// 
    /// - If both a and b are 2-D arrays, it is matrix multiplication.
    /// 
    /// - If either a or b is 0-D (scalar), it is equivalent to multiply and using numpy.multiply(a, b) or a * b is preferred.
    /// 
    /// - If a is an N-D array and b is a 1-D array, it is a sum product over the last axis of a and b.
    /// 
    /// - If a is an N-D array and b is an M-D array (where M&gt;=2), it is a sum product over the last axis of a and the second-to-last axis of b:
    /// 
    ///   Example ::
    /// 
    ///     dot(a, b)[i,j,k,m] = sum(a[i,j,:] * b[k,:,m])
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\numpy\np_dot.cc:L121</summary>
    /// <param name="a">First input</param>
    /// <param name="b">Second input</param>
    new([<Optional>] ?a : Symbol,
        [<Optional>] ?b : Symbol) = 
        let a = defaultArg a (new ImplicitVariable() :> Symbol)
        let b = defaultArg b (new ImplicitVariable() :> Symbol)
        let operatorArguments = 
            [
                "a", Input a
                "b", Input b
            ]
        new NpDot(Arguments<Symbol>(operatorArguments))
    /// First input
    member __.A = operatorArguments.GetInput "a"
    /// Second input
    member __.B = operatorArguments.GetInput "b"
    /// <summary>Copy NpDot instance with updated inputs/parameters.</summary>
    /// <param name="a">First input</param>
    /// <param name="b">Second input</param>
    member this.With([<Optional>] ?a : Symbol,
        [<Optional>] ?b : Symbol) = 
        let operatorArguments = 
            [
                a |> Option.map (fun x -> "a", Input x)
                b |> Option.map (fun x -> "b", Input x)
            ] |> List.choose id
        new NpDot(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type NpiAdd private (operatorArguments) = 
    inherit SymbolOperator("_npi_add", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new NpiAdd(args)
    override this.WithArguments(args : Arguments<Symbol>) = new NpiAdd(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <param name="lhs">First input to the function</param>
    /// <param name="rhs">Second input to the function</param>
    new([<Optional>] ?lhs : Symbol,
        [<Optional>] ?rhs : Symbol) = 
        let lhs = defaultArg lhs (new ImplicitVariable() :> Symbol)
        let rhs = defaultArg rhs (new ImplicitVariable() :> Symbol)
        let operatorArguments = 
            [
                "lhs", Input lhs
                "rhs", Input rhs
            ]
        new NpiAdd(Arguments<Symbol>(operatorArguments))
    /// First input to the function
    member __.Lhs = operatorArguments.GetInput "lhs"
    /// Second input to the function
    member __.Rhs = operatorArguments.GetInput "rhs"
    /// <summary>Copy NpiAdd instance with updated inputs/parameters.</summary>
    /// <param name="lhs">First input to the function</param>
    /// <param name="rhs">Second input to the function</param>
    member this.With([<Optional>] ?lhs : Symbol,
        [<Optional>] ?rhs : Symbol) = 
        let operatorArguments = 
            [
                lhs |> Option.map (fun x -> "lhs", Input x)
                rhs |> Option.map (fun x -> "rhs", Input x)
            ] |> List.choose id
        new NpiAdd(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type NpiSubtract private (operatorArguments) = 
    inherit SymbolOperator("_npi_subtract", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new NpiSubtract(args)
    override this.WithArguments(args : Arguments<Symbol>) = new NpiSubtract(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <param name="lhs">First input to the function</param>
    /// <param name="rhs">Second input to the function</param>
    new([<Optional>] ?lhs : Symbol,
        [<Optional>] ?rhs : Symbol) = 
        let lhs = defaultArg lhs (new ImplicitVariable() :> Symbol)
        let rhs = defaultArg rhs (new ImplicitVariable() :> Symbol)
        let operatorArguments = 
            [
                "lhs", Input lhs
                "rhs", Input rhs
            ]
        new NpiSubtract(Arguments<Symbol>(operatorArguments))
    /// First input to the function
    member __.Lhs = operatorArguments.GetInput "lhs"
    /// Second input to the function
    member __.Rhs = operatorArguments.GetInput "rhs"
    /// <summary>Copy NpiSubtract instance with updated inputs/parameters.</summary>
    /// <param name="lhs">First input to the function</param>
    /// <param name="rhs">Second input to the function</param>
    member this.With([<Optional>] ?lhs : Symbol,
        [<Optional>] ?rhs : Symbol) = 
        let operatorArguments = 
            [
                lhs |> Option.map (fun x -> "lhs", Input x)
                rhs |> Option.map (fun x -> "rhs", Input x)
            ] |> List.choose id
        new NpiSubtract(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type NpiMultiply private (operatorArguments) = 
    inherit SymbolOperator("_npi_multiply", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new NpiMultiply(args)
    override this.WithArguments(args : Arguments<Symbol>) = new NpiMultiply(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <param name="lhs">First input to the function</param>
    /// <param name="rhs">Second input to the function</param>
    new([<Optional>] ?lhs : Symbol,
        [<Optional>] ?rhs : Symbol) = 
        let lhs = defaultArg lhs (new ImplicitVariable() :> Symbol)
        let rhs = defaultArg rhs (new ImplicitVariable() :> Symbol)
        let operatorArguments = 
            [
                "lhs", Input lhs
                "rhs", Input rhs
            ]
        new NpiMultiply(Arguments<Symbol>(operatorArguments))
    /// First input to the function
    member __.Lhs = operatorArguments.GetInput "lhs"
    /// Second input to the function
    member __.Rhs = operatorArguments.GetInput "rhs"
    /// <summary>Copy NpiMultiply instance with updated inputs/parameters.</summary>
    /// <param name="lhs">First input to the function</param>
    /// <param name="rhs">Second input to the function</param>
    member this.With([<Optional>] ?lhs : Symbol,
        [<Optional>] ?rhs : Symbol) = 
        let operatorArguments = 
            [
                lhs |> Option.map (fun x -> "lhs", Input x)
                rhs |> Option.map (fun x -> "rhs", Input x)
            ] |> List.choose id
        new NpiMultiply(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type NpiMod private (operatorArguments) = 
    inherit SymbolOperator("_npi_mod", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new NpiMod(args)
    override this.WithArguments(args : Arguments<Symbol>) = new NpiMod(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <param name="lhs">First input to the function</param>
    /// <param name="rhs">Second input to the function</param>
    new([<Optional>] ?lhs : Symbol,
        [<Optional>] ?rhs : Symbol) = 
        let lhs = defaultArg lhs (new ImplicitVariable() :> Symbol)
        let rhs = defaultArg rhs (new ImplicitVariable() :> Symbol)
        let operatorArguments = 
            [
                "lhs", Input lhs
                "rhs", Input rhs
            ]
        new NpiMod(Arguments<Symbol>(operatorArguments))
    /// First input to the function
    member __.Lhs = operatorArguments.GetInput "lhs"
    /// Second input to the function
    member __.Rhs = operatorArguments.GetInput "rhs"
    /// <summary>Copy NpiMod instance with updated inputs/parameters.</summary>
    /// <param name="lhs">First input to the function</param>
    /// <param name="rhs">Second input to the function</param>
    member this.With([<Optional>] ?lhs : Symbol,
        [<Optional>] ?rhs : Symbol) = 
        let operatorArguments = 
            [
                lhs |> Option.map (fun x -> "lhs", Input x)
                rhs |> Option.map (fun x -> "rhs", Input x)
            ] |> List.choose id
        new NpiMod(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type NpiPower private (operatorArguments) = 
    inherit SymbolOperator("_npi_power", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new NpiPower(args)
    override this.WithArguments(args : Arguments<Symbol>) = new NpiPower(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <param name="lhs">First input to the function</param>
    /// <param name="rhs">Second input to the function</param>
    new([<Optional>] ?lhs : Symbol,
        [<Optional>] ?rhs : Symbol) = 
        let lhs = defaultArg lhs (new ImplicitVariable() :> Symbol)
        let rhs = defaultArg rhs (new ImplicitVariable() :> Symbol)
        let operatorArguments = 
            [
                "lhs", Input lhs
                "rhs", Input rhs
            ]
        new NpiPower(Arguments<Symbol>(operatorArguments))
    /// First input to the function
    member __.Lhs = operatorArguments.GetInput "lhs"
    /// Second input to the function
    member __.Rhs = operatorArguments.GetInput "rhs"
    /// <summary>Copy NpiPower instance with updated inputs/parameters.</summary>
    /// <param name="lhs">First input to the function</param>
    /// <param name="rhs">Second input to the function</param>
    member this.With([<Optional>] ?lhs : Symbol,
        [<Optional>] ?rhs : Symbol) = 
        let operatorArguments = 
            [
                lhs |> Option.map (fun x -> "lhs", Input x)
                rhs |> Option.map (fun x -> "rhs", Input x)
            ] |> List.choose id
        new NpiPower(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type NpiCopysign private (operatorArguments) = 
    inherit SymbolOperator("_npi_copysign", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new NpiCopysign(args)
    override this.WithArguments(args : Arguments<Symbol>) = new NpiCopysign(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <summary>
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\numpy\np_elemwise_broadcast_op.cc:L80</summary>
    /// <param name="lhs">First input to the function</param>
    /// <param name="rhs">Second input to the function</param>
    new([<Optional>] ?lhs : Symbol,
        [<Optional>] ?rhs : Symbol) = 
        let lhs = defaultArg lhs (new ImplicitVariable() :> Symbol)
        let rhs = defaultArg rhs (new ImplicitVariable() :> Symbol)
        let operatorArguments = 
            [
                "lhs", Input lhs
                "rhs", Input rhs
            ]
        new NpiCopysign(Arguments<Symbol>(operatorArguments))
    /// First input to the function
    member __.Lhs = operatorArguments.GetInput "lhs"
    /// Second input to the function
    member __.Rhs = operatorArguments.GetInput "rhs"
    /// <summary>Copy NpiCopysign instance with updated inputs/parameters.</summary>
    /// <param name="lhs">First input to the function</param>
    /// <param name="rhs">Second input to the function</param>
    member this.With([<Optional>] ?lhs : Symbol,
        [<Optional>] ?rhs : Symbol) = 
        let operatorArguments = 
            [
                lhs |> Option.map (fun x -> "lhs", Input x)
                rhs |> Option.map (fun x -> "rhs", Input x)
            ] |> List.choose id
        new NpiCopysign(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type NpiLcm private (operatorArguments) = 
    inherit SymbolOperator("_npi_lcm", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new NpiLcm(args)
    override this.WithArguments(args : Arguments<Symbol>) = new NpiLcm(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <param name="lhs">First input to the function</param>
    /// <param name="rhs">Second input to the function</param>
    new([<Optional>] ?lhs : Symbol,
        [<Optional>] ?rhs : Symbol) = 
        let lhs = defaultArg lhs (new ImplicitVariable() :> Symbol)
        let rhs = defaultArg rhs (new ImplicitVariable() :> Symbol)
        let operatorArguments = 
            [
                "lhs", Input lhs
                "rhs", Input rhs
            ]
        new NpiLcm(Arguments<Symbol>(operatorArguments))
    /// First input to the function
    member __.Lhs = operatorArguments.GetInput "lhs"
    /// Second input to the function
    member __.Rhs = operatorArguments.GetInput "rhs"
    /// <summary>Copy NpiLcm instance with updated inputs/parameters.</summary>
    /// <param name="lhs">First input to the function</param>
    /// <param name="rhs">Second input to the function</param>
    member this.With([<Optional>] ?lhs : Symbol,
        [<Optional>] ?rhs : Symbol) = 
        let operatorArguments = 
            [
                lhs |> Option.map (fun x -> "lhs", Input x)
                rhs |> Option.map (fun x -> "rhs", Input x)
            ] |> List.choose id
        new NpiLcm(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type NpiAddScalar private (operatorArguments) = 
    inherit SymbolOperator("_npi_add_scalar", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new NpiAddScalar(args)
    override this.WithArguments(args : Arguments<Symbol>) = new NpiAddScalar(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <param name="data">source input</param>
    /// <param name="scalar">scalar input</param>
    new(data : Symbol,
        scalar : float) = 
        let operatorArguments = 
            [
                "data", Input data
                "scalar", Parameter(Some(box scalar))
            ]
        new NpiAddScalar(Arguments<Symbol>(operatorArguments))
    /// <param name="scalar">scalar input</param>
    /// <param name="data">source input</param>
    new(scalar : float,
        [<Optional>] ?data : Symbol) = 
        let data = defaultArg data (new ImplicitVariable() :> Symbol)
        let operatorArguments = 
            [
                "data", Input data
                "scalar", Parameter(Some(box scalar))
            ]
        new NpiAddScalar(Arguments<Symbol>(operatorArguments))
    /// source input
    member __.Data = operatorArguments.GetInput "data"
    /// scalar input
    member __.Scalar : float = match operatorArguments.GetParameter "scalar" with Some(v) -> unbox v | None -> failwithf "Required parameter scalar is missing"
    /// <summary>Copy NpiAddScalar instance with updated inputs/parameters.</summary>
    /// <param name="data">source input</param>
    /// <param name="scalar">scalar input</param>
    member this.With([<Optional>] ?data : Symbol,
        [<Optional>] ?scalar : float) = 
        let operatorArguments = 
            [
                data |> Option.map (fun x -> "data", Input x)
                scalar |> Option.map (fun x -> "scalar", Parameter(Some (box x)))
            ] |> List.choose id
        new NpiAddScalar(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type NpiSubtractScalar private (operatorArguments) = 
    inherit SymbolOperator("_npi_subtract_scalar", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new NpiSubtractScalar(args)
    override this.WithArguments(args : Arguments<Symbol>) = new NpiSubtractScalar(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <param name="data">source input</param>
    /// <param name="scalar">scalar input</param>
    new(data : Symbol,
        scalar : float) = 
        let operatorArguments = 
            [
                "data", Input data
                "scalar", Parameter(Some(box scalar))
            ]
        new NpiSubtractScalar(Arguments<Symbol>(operatorArguments))
    /// <param name="scalar">scalar input</param>
    /// <param name="data">source input</param>
    new(scalar : float,
        [<Optional>] ?data : Symbol) = 
        let data = defaultArg data (new ImplicitVariable() :> Symbol)
        let operatorArguments = 
            [
                "data", Input data
                "scalar", Parameter(Some(box scalar))
            ]
        new NpiSubtractScalar(Arguments<Symbol>(operatorArguments))
    /// source input
    member __.Data = operatorArguments.GetInput "data"
    /// scalar input
    member __.Scalar : float = match operatorArguments.GetParameter "scalar" with Some(v) -> unbox v | None -> failwithf "Required parameter scalar is missing"
    /// <summary>Copy NpiSubtractScalar instance with updated inputs/parameters.</summary>
    /// <param name="data">source input</param>
    /// <param name="scalar">scalar input</param>
    member this.With([<Optional>] ?data : Symbol,
        [<Optional>] ?scalar : float) = 
        let operatorArguments = 
            [
                data |> Option.map (fun x -> "data", Input x)
                scalar |> Option.map (fun x -> "scalar", Parameter(Some (box x)))
            ] |> List.choose id
        new NpiSubtractScalar(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type NpiRsubtractScalar private (operatorArguments) = 
    inherit SymbolOperator("_npi_rsubtract_scalar", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new NpiRsubtractScalar(args)
    override this.WithArguments(args : Arguments<Symbol>) = new NpiRsubtractScalar(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <param name="data">source input</param>
    /// <param name="scalar">scalar input</param>
    new(data : Symbol,
        scalar : float) = 
        let operatorArguments = 
            [
                "data", Input data
                "scalar", Parameter(Some(box scalar))
            ]
        new NpiRsubtractScalar(Arguments<Symbol>(operatorArguments))
    /// <param name="scalar">scalar input</param>
    /// <param name="data">source input</param>
    new(scalar : float,
        [<Optional>] ?data : Symbol) = 
        let data = defaultArg data (new ImplicitVariable() :> Symbol)
        let operatorArguments = 
            [
                "data", Input data
                "scalar", Parameter(Some(box scalar))
            ]
        new NpiRsubtractScalar(Arguments<Symbol>(operatorArguments))
    /// source input
    member __.Data = operatorArguments.GetInput "data"
    /// scalar input
    member __.Scalar : float = match operatorArguments.GetParameter "scalar" with Some(v) -> unbox v | None -> failwithf "Required parameter scalar is missing"
    /// <summary>Copy NpiRsubtractScalar instance with updated inputs/parameters.</summary>
    /// <param name="data">source input</param>
    /// <param name="scalar">scalar input</param>
    member this.With([<Optional>] ?data : Symbol,
        [<Optional>] ?scalar : float) = 
        let operatorArguments = 
            [
                data |> Option.map (fun x -> "data", Input x)
                scalar |> Option.map (fun x -> "scalar", Parameter(Some (box x)))
            ] |> List.choose id
        new NpiRsubtractScalar(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type NpiMultiplyScalar private (operatorArguments) = 
    inherit SymbolOperator("_npi_multiply_scalar", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new NpiMultiplyScalar(args)
    override this.WithArguments(args : Arguments<Symbol>) = new NpiMultiplyScalar(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <param name="data">source input</param>
    /// <param name="scalar">scalar input</param>
    new(data : Symbol,
        scalar : float) = 
        let operatorArguments = 
            [
                "data", Input data
                "scalar", Parameter(Some(box scalar))
            ]
        new NpiMultiplyScalar(Arguments<Symbol>(operatorArguments))
    /// <param name="scalar">scalar input</param>
    /// <param name="data">source input</param>
    new(scalar : float,
        [<Optional>] ?data : Symbol) = 
        let data = defaultArg data (new ImplicitVariable() :> Symbol)
        let operatorArguments = 
            [
                "data", Input data
                "scalar", Parameter(Some(box scalar))
            ]
        new NpiMultiplyScalar(Arguments<Symbol>(operatorArguments))
    /// source input
    member __.Data = operatorArguments.GetInput "data"
    /// scalar input
    member __.Scalar : float = match operatorArguments.GetParameter "scalar" with Some(v) -> unbox v | None -> failwithf "Required parameter scalar is missing"
    /// <summary>Copy NpiMultiplyScalar instance with updated inputs/parameters.</summary>
    /// <param name="data">source input</param>
    /// <param name="scalar">scalar input</param>
    member this.With([<Optional>] ?data : Symbol,
        [<Optional>] ?scalar : float) = 
        let operatorArguments = 
            [
                data |> Option.map (fun x -> "data", Input x)
                scalar |> Option.map (fun x -> "scalar", Parameter(Some (box x)))
            ] |> List.choose id
        new NpiMultiplyScalar(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type NpiModScalar private (operatorArguments) = 
    inherit SymbolOperator("_npi_mod_scalar", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new NpiModScalar(args)
    override this.WithArguments(args : Arguments<Symbol>) = new NpiModScalar(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <param name="data">source input</param>
    /// <param name="scalar">scalar input</param>
    new(data : Symbol,
        scalar : float) = 
        let operatorArguments = 
            [
                "data", Input data
                "scalar", Parameter(Some(box scalar))
            ]
        new NpiModScalar(Arguments<Symbol>(operatorArguments))
    /// <param name="scalar">scalar input</param>
    /// <param name="data">source input</param>
    new(scalar : float,
        [<Optional>] ?data : Symbol) = 
        let data = defaultArg data (new ImplicitVariable() :> Symbol)
        let operatorArguments = 
            [
                "data", Input data
                "scalar", Parameter(Some(box scalar))
            ]
        new NpiModScalar(Arguments<Symbol>(operatorArguments))
    /// source input
    member __.Data = operatorArguments.GetInput "data"
    /// scalar input
    member __.Scalar : float = match operatorArguments.GetParameter "scalar" with Some(v) -> unbox v | None -> failwithf "Required parameter scalar is missing"
    /// <summary>Copy NpiModScalar instance with updated inputs/parameters.</summary>
    /// <param name="data">source input</param>
    /// <param name="scalar">scalar input</param>
    member this.With([<Optional>] ?data : Symbol,
        [<Optional>] ?scalar : float) = 
        let operatorArguments = 
            [
                data |> Option.map (fun x -> "data", Input x)
                scalar |> Option.map (fun x -> "scalar", Parameter(Some (box x)))
            ] |> List.choose id
        new NpiModScalar(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type NpiRmodScalar private (operatorArguments) = 
    inherit SymbolOperator("_npi_rmod_scalar", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new NpiRmodScalar(args)
    override this.WithArguments(args : Arguments<Symbol>) = new NpiRmodScalar(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <param name="data">source input</param>
    /// <param name="scalar">scalar input</param>
    new(data : Symbol,
        scalar : float) = 
        let operatorArguments = 
            [
                "data", Input data
                "scalar", Parameter(Some(box scalar))
            ]
        new NpiRmodScalar(Arguments<Symbol>(operatorArguments))
    /// <param name="scalar">scalar input</param>
    /// <param name="data">source input</param>
    new(scalar : float,
        [<Optional>] ?data : Symbol) = 
        let data = defaultArg data (new ImplicitVariable() :> Symbol)
        let operatorArguments = 
            [
                "data", Input data
                "scalar", Parameter(Some(box scalar))
            ]
        new NpiRmodScalar(Arguments<Symbol>(operatorArguments))
    /// source input
    member __.Data = operatorArguments.GetInput "data"
    /// scalar input
    member __.Scalar : float = match operatorArguments.GetParameter "scalar" with Some(v) -> unbox v | None -> failwithf "Required parameter scalar is missing"
    /// <summary>Copy NpiRmodScalar instance with updated inputs/parameters.</summary>
    /// <param name="data">source input</param>
    /// <param name="scalar">scalar input</param>
    member this.With([<Optional>] ?data : Symbol,
        [<Optional>] ?scalar : float) = 
        let operatorArguments = 
            [
                data |> Option.map (fun x -> "data", Input x)
                scalar |> Option.map (fun x -> "scalar", Parameter(Some (box x)))
            ] |> List.choose id
        new NpiRmodScalar(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type NpiPowerScalar private (operatorArguments) = 
    inherit SymbolOperator("_npi_power_scalar", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new NpiPowerScalar(args)
    override this.WithArguments(args : Arguments<Symbol>) = new NpiPowerScalar(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <param name="data">source input</param>
    /// <param name="scalar">scalar input</param>
    new(data : Symbol,
        scalar : float) = 
        let operatorArguments = 
            [
                "data", Input data
                "scalar", Parameter(Some(box scalar))
            ]
        new NpiPowerScalar(Arguments<Symbol>(operatorArguments))
    /// <param name="scalar">scalar input</param>
    /// <param name="data">source input</param>
    new(scalar : float,
        [<Optional>] ?data : Symbol) = 
        let data = defaultArg data (new ImplicitVariable() :> Symbol)
        let operatorArguments = 
            [
                "data", Input data
                "scalar", Parameter(Some(box scalar))
            ]
        new NpiPowerScalar(Arguments<Symbol>(operatorArguments))
    /// source input
    member __.Data = operatorArguments.GetInput "data"
    /// scalar input
    member __.Scalar : float = match operatorArguments.GetParameter "scalar" with Some(v) -> unbox v | None -> failwithf "Required parameter scalar is missing"
    /// <summary>Copy NpiPowerScalar instance with updated inputs/parameters.</summary>
    /// <param name="data">source input</param>
    /// <param name="scalar">scalar input</param>
    member this.With([<Optional>] ?data : Symbol,
        [<Optional>] ?scalar : float) = 
        let operatorArguments = 
            [
                data |> Option.map (fun x -> "data", Input x)
                scalar |> Option.map (fun x -> "scalar", Parameter(Some (box x)))
            ] |> List.choose id
        new NpiPowerScalar(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type NpiRpowerScalar private (operatorArguments) = 
    inherit SymbolOperator("_npi_rpower_scalar", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new NpiRpowerScalar(args)
    override this.WithArguments(args : Arguments<Symbol>) = new NpiRpowerScalar(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <param name="data">source input</param>
    /// <param name="scalar">scalar input</param>
    new(data : Symbol,
        scalar : float) = 
        let operatorArguments = 
            [
                "data", Input data
                "scalar", Parameter(Some(box scalar))
            ]
        new NpiRpowerScalar(Arguments<Symbol>(operatorArguments))
    /// <param name="scalar">scalar input</param>
    /// <param name="data">source input</param>
    new(scalar : float,
        [<Optional>] ?data : Symbol) = 
        let data = defaultArg data (new ImplicitVariable() :> Symbol)
        let operatorArguments = 
            [
                "data", Input data
                "scalar", Parameter(Some(box scalar))
            ]
        new NpiRpowerScalar(Arguments<Symbol>(operatorArguments))
    /// source input
    member __.Data = operatorArguments.GetInput "data"
    /// scalar input
    member __.Scalar : float = match operatorArguments.GetParameter "scalar" with Some(v) -> unbox v | None -> failwithf "Required parameter scalar is missing"
    /// <summary>Copy NpiRpowerScalar instance with updated inputs/parameters.</summary>
    /// <param name="data">source input</param>
    /// <param name="scalar">scalar input</param>
    member this.With([<Optional>] ?data : Symbol,
        [<Optional>] ?scalar : float) = 
        let operatorArguments = 
            [
                data |> Option.map (fun x -> "data", Input x)
                scalar |> Option.map (fun x -> "scalar", Parameter(Some (box x)))
            ] |> List.choose id
        new NpiRpowerScalar(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type NpiCopysignScalar private (operatorArguments) = 
    inherit SymbolOperator("_npi_copysign_scalar", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new NpiCopysignScalar(args)
    override this.WithArguments(args : Arguments<Symbol>) = new NpiCopysignScalar(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <param name="data">source input</param>
    /// <param name="scalar">scalar input</param>
    new(data : Symbol,
        scalar : float) = 
        let operatorArguments = 
            [
                "data", Input data
                "scalar", Parameter(Some(box scalar))
            ]
        new NpiCopysignScalar(Arguments<Symbol>(operatorArguments))
    /// <param name="scalar">scalar input</param>
    /// <param name="data">source input</param>
    new(scalar : float,
        [<Optional>] ?data : Symbol) = 
        let data = defaultArg data (new ImplicitVariable() :> Symbol)
        let operatorArguments = 
            [
                "data", Input data
                "scalar", Parameter(Some(box scalar))
            ]
        new NpiCopysignScalar(Arguments<Symbol>(operatorArguments))
    /// source input
    member __.Data = operatorArguments.GetInput "data"
    /// scalar input
    member __.Scalar : float = match operatorArguments.GetParameter "scalar" with Some(v) -> unbox v | None -> failwithf "Required parameter scalar is missing"
    /// <summary>Copy NpiCopysignScalar instance with updated inputs/parameters.</summary>
    /// <param name="data">source input</param>
    /// <param name="scalar">scalar input</param>
    member this.With([<Optional>] ?data : Symbol,
        [<Optional>] ?scalar : float) = 
        let operatorArguments = 
            [
                data |> Option.map (fun x -> "data", Input x)
                scalar |> Option.map (fun x -> "scalar", Parameter(Some (box x)))
            ] |> List.choose id
        new NpiCopysignScalar(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type NpiRcopysignScalar private (operatorArguments) = 
    inherit SymbolOperator("_npi_rcopysign_scalar", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new NpiRcopysignScalar(args)
    override this.WithArguments(args : Arguments<Symbol>) = new NpiRcopysignScalar(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <param name="data">source input</param>
    /// <param name="scalar">scalar input</param>
    new(data : Symbol,
        scalar : float) = 
        let operatorArguments = 
            [
                "data", Input data
                "scalar", Parameter(Some(box scalar))
            ]
        new NpiRcopysignScalar(Arguments<Symbol>(operatorArguments))
    /// <param name="scalar">scalar input</param>
    /// <param name="data">source input</param>
    new(scalar : float,
        [<Optional>] ?data : Symbol) = 
        let data = defaultArg data (new ImplicitVariable() :> Symbol)
        let operatorArguments = 
            [
                "data", Input data
                "scalar", Parameter(Some(box scalar))
            ]
        new NpiRcopysignScalar(Arguments<Symbol>(operatorArguments))
    /// source input
    member __.Data = operatorArguments.GetInput "data"
    /// scalar input
    member __.Scalar : float = match operatorArguments.GetParameter "scalar" with Some(v) -> unbox v | None -> failwithf "Required parameter scalar is missing"
    /// <summary>Copy NpiRcopysignScalar instance with updated inputs/parameters.</summary>
    /// <param name="data">source input</param>
    /// <param name="scalar">scalar input</param>
    member this.With([<Optional>] ?data : Symbol,
        [<Optional>] ?scalar : float) = 
        let operatorArguments = 
            [
                data |> Option.map (fun x -> "data", Input x)
                scalar |> Option.map (fun x -> "scalar", Parameter(Some (box x)))
            ] |> List.choose id
        new NpiRcopysignScalar(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type NpiArctan2 private (operatorArguments) = 
    inherit SymbolOperator("_npi_arctan2", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new NpiArctan2(args)
    override this.WithArguments(args : Arguments<Symbol>) = new NpiArctan2(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <param name="x1">The input array</param>
    /// <param name="x2">The input array</param>
    new([<Optional>] ?x1 : Symbol,
        [<Optional>] ?x2 : Symbol) = 
        let x1 = defaultArg x1 (new ImplicitVariable() :> Symbol)
        let x2 = defaultArg x2 (new ImplicitVariable() :> Symbol)
        let operatorArguments = 
            [
                "x1", Input x1
                "x2", Input x2
            ]
        new NpiArctan2(Arguments<Symbol>(operatorArguments))
    /// The input array
    member __.X1 = operatorArguments.GetInput "x1"
    /// The input array
    member __.X2 = operatorArguments.GetInput "x2"
    /// <summary>Copy NpiArctan2 instance with updated inputs/parameters.</summary>
    /// <param name="x1">The input array</param>
    /// <param name="x2">The input array</param>
    member this.With([<Optional>] ?x1 : Symbol,
        [<Optional>] ?x2 : Symbol) = 
        let operatorArguments = 
            [
                x1 |> Option.map (fun x -> "x1", Input x)
                x2 |> Option.map (fun x -> "x2", Input x)
            ] |> List.choose id
        new NpiArctan2(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type NpiArctan2Scalar private (operatorArguments) = 
    inherit SymbolOperator("_npi_arctan2_scalar", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new NpiArctan2Scalar(args)
    override this.WithArguments(args : Arguments<Symbol>) = new NpiArctan2Scalar(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <param name="data">source input</param>
    /// <param name="scalar">scalar input</param>
    new(data : Symbol,
        scalar : float) = 
        let operatorArguments = 
            [
                "data", Input data
                "scalar", Parameter(Some(box scalar))
            ]
        new NpiArctan2Scalar(Arguments<Symbol>(operatorArguments))
    /// <param name="scalar">scalar input</param>
    /// <param name="data">source input</param>
    new(scalar : float,
        [<Optional>] ?data : Symbol) = 
        let data = defaultArg data (new ImplicitVariable() :> Symbol)
        let operatorArguments = 
            [
                "data", Input data
                "scalar", Parameter(Some(box scalar))
            ]
        new NpiArctan2Scalar(Arguments<Symbol>(operatorArguments))
    /// source input
    member __.Data = operatorArguments.GetInput "data"
    /// scalar input
    member __.Scalar : float = match operatorArguments.GetParameter "scalar" with Some(v) -> unbox v | None -> failwithf "Required parameter scalar is missing"
    /// <summary>Copy NpiArctan2Scalar instance with updated inputs/parameters.</summary>
    /// <param name="data">source input</param>
    /// <param name="scalar">scalar input</param>
    member this.With([<Optional>] ?data : Symbol,
        [<Optional>] ?scalar : float) = 
        let operatorArguments = 
            [
                data |> Option.map (fun x -> "data", Input x)
                scalar |> Option.map (fun x -> "scalar", Parameter(Some (box x)))
            ] |> List.choose id
        new NpiArctan2Scalar(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type NpiRarctan2Scalar private (operatorArguments) = 
    inherit SymbolOperator("_npi_rarctan2_scalar", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new NpiRarctan2Scalar(args)
    override this.WithArguments(args : Arguments<Symbol>) = new NpiRarctan2Scalar(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <param name="data">source input</param>
    /// <param name="scalar">scalar input</param>
    new(data : Symbol,
        scalar : float) = 
        let operatorArguments = 
            [
                "data", Input data
                "scalar", Parameter(Some(box scalar))
            ]
        new NpiRarctan2Scalar(Arguments<Symbol>(operatorArguments))
    /// <param name="scalar">scalar input</param>
    /// <param name="data">source input</param>
    new(scalar : float,
        [<Optional>] ?data : Symbol) = 
        let data = defaultArg data (new ImplicitVariable() :> Symbol)
        let operatorArguments = 
            [
                "data", Input data
                "scalar", Parameter(Some(box scalar))
            ]
        new NpiRarctan2Scalar(Arguments<Symbol>(operatorArguments))
    /// source input
    member __.Data = operatorArguments.GetInput "data"
    /// scalar input
    member __.Scalar : float = match operatorArguments.GetParameter "scalar" with Some(v) -> unbox v | None -> failwithf "Required parameter scalar is missing"
    /// <summary>Copy NpiRarctan2Scalar instance with updated inputs/parameters.</summary>
    /// <param name="data">source input</param>
    /// <param name="scalar">scalar input</param>
    member this.With([<Optional>] ?data : Symbol,
        [<Optional>] ?scalar : float) = 
        let operatorArguments = 
            [
                data |> Option.map (fun x -> "data", Input x)
                scalar |> Option.map (fun x -> "scalar", Parameter(Some (box x)))
            ] |> List.choose id
        new NpiRarctan2Scalar(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type NpiHypot private (operatorArguments) = 
    inherit SymbolOperator("_npi_hypot", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new NpiHypot(args)
    override this.WithArguments(args : Arguments<Symbol>) = new NpiHypot(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <param name="x1">The input array</param>
    /// <param name="x2">The input array</param>
    new([<Optional>] ?x1 : Symbol,
        [<Optional>] ?x2 : Symbol) = 
        let x1 = defaultArg x1 (new ImplicitVariable() :> Symbol)
        let x2 = defaultArg x2 (new ImplicitVariable() :> Symbol)
        let operatorArguments = 
            [
                "x1", Input x1
                "x2", Input x2
            ]
        new NpiHypot(Arguments<Symbol>(operatorArguments))
    /// The input array
    member __.X1 = operatorArguments.GetInput "x1"
    /// The input array
    member __.X2 = operatorArguments.GetInput "x2"
    /// <summary>Copy NpiHypot instance with updated inputs/parameters.</summary>
    /// <param name="x1">The input array</param>
    /// <param name="x2">The input array</param>
    member this.With([<Optional>] ?x1 : Symbol,
        [<Optional>] ?x2 : Symbol) = 
        let operatorArguments = 
            [
                x1 |> Option.map (fun x -> "x1", Input x)
                x2 |> Option.map (fun x -> "x2", Input x)
            ] |> List.choose id
        new NpiHypot(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type NpiLcmScalar private (operatorArguments) = 
    inherit SymbolOperator("_npi_lcm_scalar", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new NpiLcmScalar(args)
    override this.WithArguments(args : Arguments<Symbol>) = new NpiLcmScalar(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <param name="data">source input</param>
    /// <param name="scalar">scalar input</param>
    new(data : Symbol,
        scalar : int) = 
        let operatorArguments = 
            [
                "data", Input data
                "scalar", Parameter(Some(box scalar))
            ]
        new NpiLcmScalar(Arguments<Symbol>(operatorArguments))
    /// <param name="scalar">scalar input</param>
    /// <param name="data">source input</param>
    new(scalar : int,
        [<Optional>] ?data : Symbol) = 
        let data = defaultArg data (new ImplicitVariable() :> Symbol)
        let operatorArguments = 
            [
                "data", Input data
                "scalar", Parameter(Some(box scalar))
            ]
        new NpiLcmScalar(Arguments<Symbol>(operatorArguments))
    /// source input
    member __.Data = operatorArguments.GetInput "data"
    /// scalar input
    member __.Scalar : int = match operatorArguments.GetParameter "scalar" with Some(v) -> unbox v | None -> failwithf "Required parameter scalar is missing"
    /// <summary>Copy NpiLcmScalar instance with updated inputs/parameters.</summary>
    /// <param name="data">source input</param>
    /// <param name="scalar">scalar input</param>
    member this.With([<Optional>] ?data : Symbol,
        [<Optional>] ?scalar : int) = 
        let operatorArguments = 
            [
                data |> Option.map (fun x -> "data", Input x)
                scalar |> Option.map (fun x -> "scalar", Parameter(Some (box x)))
            ] |> List.choose id
        new NpiLcmScalar(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type NpxRelu private (operatorArguments) = 
    inherit SymbolOperator("_npx_relu", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new NpxRelu(args)
    override this.WithArguments(args : Arguments<Symbol>) = new NpxRelu(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <summary>Computes rectified linear activation.
    /// .. math::
    ///    max(features, 0)
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\numpy\np_elemwise_unary_op_basic.cc:L34</summary>
    /// <param name="data">The input array.</param>
    new([<Optional>] ?data : Symbol) =
        let data = defaultArg data (new ImplicitVariable() :> Symbol)
        let operatorArguments = 
            [
                "data", Input data
            ]
        new NpxRelu(Arguments<Symbol>(operatorArguments))
    /// The input array.
    member __.Data = operatorArguments.GetInput "data"
    /// <summary>Copy NpxRelu instance with updated inputs/parameters.</summary>
    /// <param name="data">The input array.</param>
    member this.With([<Optional>] ?data : Symbol) =
        let operatorArguments = 
            [
                data |> Option.map (fun x -> "data", Input x)
            ] |> List.choose id
        new NpxRelu(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type NpxSigmoid private (operatorArguments) = 
    inherit SymbolOperator("_npx_sigmoid", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new NpxSigmoid(args)
    override this.WithArguments(args : Arguments<Symbol>) = new NpxSigmoid(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <summary>Computes sigmoid of x element-wise.
    /// .. math::
    ///    y = 1 / (1 + exp(-x))
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\numpy\np_elemwise_unary_op_basic.cc:L42</summary>
    /// <param name="data">The input array.</param>
    new([<Optional>] ?data : Symbol) =
        let data = defaultArg data (new ImplicitVariable() :> Symbol)
        let operatorArguments = 
            [
                "data", Input data
            ]
        new NpxSigmoid(Arguments<Symbol>(operatorArguments))
    /// The input array.
    member __.Data = operatorArguments.GetInput "data"
    /// <summary>Copy NpxSigmoid instance with updated inputs/parameters.</summary>
    /// <param name="data">The input array.</param>
    member this.With([<Optional>] ?data : Symbol) =
        let operatorArguments = 
            [
                data |> Option.map (fun x -> "data", Input x)
            ] |> List.choose id
        new NpxSigmoid(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type NpCopy private (operatorArguments) = 
    inherit SymbolOperator("_np_copy", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new NpCopy(args)
    override this.WithArguments(args : Arguments<Symbol>) = new NpCopy(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <summary>Return an array copy of the given object.
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\numpy\np_elemwise_unary_op_basic.cc:L47</summary>
    /// <param name="a">The input</param>
    new([<Optional>] ?a : Symbol) =
        let a = defaultArg a (new ImplicitVariable() :> Symbol)
        let operatorArguments = 
            [
                "a", Input a
            ]
        new NpCopy(Arguments<Symbol>(operatorArguments))
    /// The input
    member __.A = operatorArguments.GetInput "a"
    /// <summary>Copy NpCopy instance with updated inputs/parameters.</summary>
    /// <param name="a">The input</param>
    member this.With([<Optional>] ?a : Symbol) =
        let operatorArguments = 
            [
                a |> Option.map (fun x -> "a", Input x)
            ] |> List.choose id
        new NpCopy(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type NpiNegative private (operatorArguments) = 
    inherit SymbolOperator("_npi_negative", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new NpiNegative(args)
    override this.WithArguments(args : Arguments<Symbol>) = new NpiNegative(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <summary>Numerical negative, element-wise.
    /// Example::
    ///     negative([1.,  -1.]) = [-1.,  1.]
    /// </summary>
    /// <param name="x">The input array.</param>
    new([<Optional>] ?x : Symbol) =
        let x = defaultArg x (new ImplicitVariable() :> Symbol)
        let operatorArguments = 
            [
                "x", Input x
            ]
        new NpiNegative(Arguments<Symbol>(operatorArguments))
    /// The input array.
    member __.X = operatorArguments.GetInput "x"
    /// <summary>Copy NpiNegative instance with updated inputs/parameters.</summary>
    /// <param name="x">The input array.</param>
    member this.With([<Optional>] ?x : Symbol) =
        let operatorArguments = 
            [
                x |> Option.map (fun x -> "x", Input x)
            ] |> List.choose id
        new NpiNegative(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type NpiReciprocal private (operatorArguments) = 
    inherit SymbolOperator("_npi_reciprocal", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new NpiReciprocal(args)
    override this.WithArguments(args : Arguments<Symbol>) = new NpiReciprocal(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <summary>Return the reciprocal of the argument, element-wise.
    /// Example::
    ///     reciprocal([-2, 1, 3, 1.6, 0.2]) = [-0.5, 1.0, 0.33333334, 0.625, 5.0]
    /// </summary>
    /// <param name="x">The input array.</param>
    new([<Optional>] ?x : Symbol) =
        let x = defaultArg x (new ImplicitVariable() :> Symbol)
        let operatorArguments = 
            [
                "x", Input x
            ]
        new NpiReciprocal(Arguments<Symbol>(operatorArguments))
    /// The input array.
    member __.X = operatorArguments.GetInput "x"
    /// <summary>Copy NpiReciprocal instance with updated inputs/parameters.</summary>
    /// <param name="x">The input array.</param>
    member this.With([<Optional>] ?x : Symbol) =
        let operatorArguments = 
            [
                x |> Option.map (fun x -> "x", Input x)
            ] |> List.choose id
        new NpiReciprocal(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type NpiAbsolute private (operatorArguments) = 
    inherit SymbolOperator("_npi_absolute", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new NpiAbsolute(args)
    override this.WithArguments(args : Arguments<Symbol>) = new NpiAbsolute(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <summary>Returns element-wise absolute value of the input.
    /// Example::
    ///    absolute([-2, 0, 3]) = [2, 0, 3]
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\numpy\np_elemwise_unary_op_basic.cc:L107</summary>
    /// <param name="x">The input array.</param>
    new([<Optional>] ?x : Symbol) =
        let x = defaultArg x (new ImplicitVariable() :> Symbol)
        let operatorArguments = 
            [
                "x", Input x
            ]
        new NpiAbsolute(Arguments<Symbol>(operatorArguments))
    /// The input array.
    member __.X = operatorArguments.GetInput "x"
    /// <summary>Copy NpiAbsolute instance with updated inputs/parameters.</summary>
    /// <param name="x">The input array.</param>
    member this.With([<Optional>] ?x : Symbol) =
        let operatorArguments = 
            [
                x |> Option.map (fun x -> "x", Input x)
            ] |> List.choose id
        new NpiAbsolute(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type NpiSign private (operatorArguments) = 
    inherit SymbolOperator("_npi_sign", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new NpiSign(args)
    override this.WithArguments(args : Arguments<Symbol>) = new NpiSign(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <summary>Returns an element-wise indication of the sign of a number.
    /// The sign function returns -1 if x &lt; 0, 0 if x==0, 1 if x &gt; 0.
    /// Example::
    ///    sign([-2, 0, 3]) = [-1, 0, 1]
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\numpy\np_elemwise_unary_op_basic.cc:L116</summary>
    /// <param name="x">The input array.</param>
    new([<Optional>] ?x : Symbol) =
        let x = defaultArg x (new ImplicitVariable() :> Symbol)
        let operatorArguments = 
            [
                "x", Input x
            ]
        new NpiSign(Arguments<Symbol>(operatorArguments))
    /// The input array.
    member __.X = operatorArguments.GetInput "x"
    /// <summary>Copy NpiSign instance with updated inputs/parameters.</summary>
    /// <param name="x">The input array.</param>
    member this.With([<Optional>] ?x : Symbol) =
        let operatorArguments = 
            [
                x |> Option.map (fun x -> "x", Input x)
            ] |> List.choose id
        new NpiSign(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type NpiRint private (operatorArguments) = 
    inherit SymbolOperator("_npi_rint", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new NpiRint(args)
    override this.WithArguments(args : Arguments<Symbol>) = new NpiRint(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <summary>Round elements of the array to the nearest integer.
    /// Example::
    ///    rint([-1.7, -1.5, -0.2, 0.2, 1.5, 1.7, 2.0]) = [-2., -2., -0.,  0.,  2.,  2.,  2.]
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\numpy\np_elemwise_unary_op_basic.cc:L124</summary>
    /// <param name="x">The input array.</param>
    new([<Optional>] ?x : Symbol) =
        let x = defaultArg x (new ImplicitVariable() :> Symbol)
        let operatorArguments = 
            [
                "x", Input x
            ]
        new NpiRint(Arguments<Symbol>(operatorArguments))
    /// The input array.
    member __.X = operatorArguments.GetInput "x"
    /// <summary>Copy NpiRint instance with updated inputs/parameters.</summary>
    /// <param name="x">The input array.</param>
    member this.With([<Optional>] ?x : Symbol) =
        let operatorArguments = 
            [
                x |> Option.map (fun x -> "x", Input x)
            ] |> List.choose id
        new NpiRint(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type NpiCeil private (operatorArguments) = 
    inherit SymbolOperator("_npi_ceil", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new NpiCeil(args)
    override this.WithArguments(args : Arguments<Symbol>) = new NpiCeil(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <summary>Return the ceiling of the input, element-wise.
    /// The ceil of the scalar x is the smallest integer i, such that i &gt;= x.
    /// Example::
    ///    ceil([-1.7, -1.5, -0.2, 0.2, 1.5, 1.7, 2.0]) = [-1., -1., -0.,  1.,  2.,  2.,  2.]
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\numpy\np_elemwise_unary_op_basic.cc:L133</summary>
    /// <param name="x">The input array.</param>
    new([<Optional>] ?x : Symbol) =
        let x = defaultArg x (new ImplicitVariable() :> Symbol)
        let operatorArguments = 
            [
                "x", Input x
            ]
        new NpiCeil(Arguments<Symbol>(operatorArguments))
    /// The input array.
    member __.X = operatorArguments.GetInput "x"
    /// <summary>Copy NpiCeil instance with updated inputs/parameters.</summary>
    /// <param name="x">The input array.</param>
    member this.With([<Optional>] ?x : Symbol) =
        let operatorArguments = 
            [
                x |> Option.map (fun x -> "x", Input x)
            ] |> List.choose id
        new NpiCeil(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type NpiFloor private (operatorArguments) = 
    inherit SymbolOperator("_npi_floor", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new NpiFloor(args)
    override this.WithArguments(args : Arguments<Symbol>) = new NpiFloor(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <summary>Return the floor of the input, element-wise.
    /// The floor of the scalar x is the largest integer i, such that i &lt;= x.
    /// Example::
    ///    floor([-1.7, -1.5, -0.2, 0.2, 1.5, 1.7, 2.0]) = [-2., -2., -1.,  0.,  1.,  1.,  2.]
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\numpy\np_elemwise_unary_op_basic.cc:L142</summary>
    /// <param name="x">The input array.</param>
    new([<Optional>] ?x : Symbol) =
        let x = defaultArg x (new ImplicitVariable() :> Symbol)
        let operatorArguments = 
            [
                "x", Input x
            ]
        new NpiFloor(Arguments<Symbol>(operatorArguments))
    /// The input array.
    member __.X = operatorArguments.GetInput "x"
    /// <summary>Copy NpiFloor instance with updated inputs/parameters.</summary>
    /// <param name="x">The input array.</param>
    member this.With([<Optional>] ?x : Symbol) =
        let operatorArguments = 
            [
                x |> Option.map (fun x -> "x", Input x)
            ] |> List.choose id
        new NpiFloor(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type NpiTrunc private (operatorArguments) = 
    inherit SymbolOperator("_npi_trunc", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new NpiTrunc(args)
    override this.WithArguments(args : Arguments<Symbol>) = new NpiTrunc(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <summary>Return the truncated value of the input, element-wise.
    /// The truncated value of the scalar x is the nearest integer i which is closer to
    /// zero than x is. In short, the fractional part of the signed number x is discarded.
    /// Example::
    ///    trunc([-1.7, -1.5, -0.2, 0.2, 1.5, 1.7, 2.0]) = [-1., -1., -0.,  0.,  1.,  1.,  2.]
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\numpy\np_elemwise_unary_op_basic.cc:L152</summary>
    /// <param name="x">The input array.</param>
    new([<Optional>] ?x : Symbol) =
        let x = defaultArg x (new ImplicitVariable() :> Symbol)
        let operatorArguments = 
            [
                "x", Input x
            ]
        new NpiTrunc(Arguments<Symbol>(operatorArguments))
    /// The input array.
    member __.X = operatorArguments.GetInput "x"
    /// <summary>Copy NpiTrunc instance with updated inputs/parameters.</summary>
    /// <param name="x">The input array.</param>
    member this.With([<Optional>] ?x : Symbol) =
        let operatorArguments = 
            [
                x |> Option.map (fun x -> "x", Input x)
            ] |> List.choose id
        new NpiTrunc(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type NpiFix private (operatorArguments) = 
    inherit SymbolOperator("_npi_fix", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new NpiFix(args)
    override this.WithArguments(args : Arguments<Symbol>) = new NpiFix(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <summary>Round to nearest integer towards zero.
    /// Round an array of floats element-wise to nearest integer towards zero.
    /// The rounded values are returned as floats.
    /// Example::
    ///    fix([-2.1, -1.9, 1.9, 2.1]) = [-2., -1.,  1., 2.]
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\numpy\np_elemwise_unary_op_basic.cc:L162</summary>
    /// <param name="x">The input array.</param>
    new([<Optional>] ?x : Symbol) =
        let x = defaultArg x (new ImplicitVariable() :> Symbol)
        let operatorArguments = 
            [
                "x", Input x
            ]
        new NpiFix(Arguments<Symbol>(operatorArguments))
    /// The input array.
    member __.X = operatorArguments.GetInput "x"
    /// <summary>Copy NpiFix instance with updated inputs/parameters.</summary>
    /// <param name="x">The input array.</param>
    member this.With([<Optional>] ?x : Symbol) =
        let operatorArguments = 
            [
                x |> Option.map (fun x -> "x", Input x)
            ] |> List.choose id
        new NpiFix(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type NpiSquare private (operatorArguments) = 
    inherit SymbolOperator("_npi_square", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new NpiSquare(args)
    override this.WithArguments(args : Arguments<Symbol>) = new NpiSquare(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <summary>Return the element-wise square of the input.
    /// Example::
    ///    square([2, 3, 4]) = [4, 9, 16]
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\numpy\np_elemwise_unary_op_basic.cc:L170</summary>
    /// <param name="x">The input array.</param>
    new([<Optional>] ?x : Symbol) =
        let x = defaultArg x (new ImplicitVariable() :> Symbol)
        let operatorArguments = 
            [
                "x", Input x
            ]
        new NpiSquare(Arguments<Symbol>(operatorArguments))
    /// The input array.
    member __.X = operatorArguments.GetInput "x"
    /// <summary>Copy NpiSquare instance with updated inputs/parameters.</summary>
    /// <param name="x">The input array.</param>
    member this.With([<Optional>] ?x : Symbol) =
        let operatorArguments = 
            [
                x |> Option.map (fun x -> "x", Input x)
            ] |> List.choose id
        new NpiSquare(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type NpiSqrt private (operatorArguments) = 
    inherit SymbolOperator("_npi_sqrt", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new NpiSqrt(args)
    override this.WithArguments(args : Arguments<Symbol>) = new NpiSqrt(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <summary>Return the non-negative square-root of an array, element-wise.
    /// Example::
    ///    sqrt([4, 9, 16]) = [2, 3, 4]
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\numpy\np_elemwise_unary_op_basic.cc:L178</summary>
    /// <param name="x">The input array.</param>
    new([<Optional>] ?x : Symbol) =
        let x = defaultArg x (new ImplicitVariable() :> Symbol)
        let operatorArguments = 
            [
                "x", Input x
            ]
        new NpiSqrt(Arguments<Symbol>(operatorArguments))
    /// The input array.
    member __.X = operatorArguments.GetInput "x"
    /// <summary>Copy NpiSqrt instance with updated inputs/parameters.</summary>
    /// <param name="x">The input array.</param>
    member this.With([<Optional>] ?x : Symbol) =
        let operatorArguments = 
            [
                x |> Option.map (fun x -> "x", Input x)
            ] |> List.choose id
        new NpiSqrt(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type NpiCbrt private (operatorArguments) = 
    inherit SymbolOperator("_npi_cbrt", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new NpiCbrt(args)
    override this.WithArguments(args : Arguments<Symbol>) = new NpiCbrt(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <summary>Return the cube-root of an array, element-wise.
    /// Example::
    ///    cbrt([1, 8, -125]) = [1, 2, -5]
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\numpy\np_elemwise_unary_op_basic.cc:L186</summary>
    /// <param name="x">The input array.</param>
    new([<Optional>] ?x : Symbol) =
        let x = defaultArg x (new ImplicitVariable() :> Symbol)
        let operatorArguments = 
            [
                "x", Input x
            ]
        new NpiCbrt(Arguments<Symbol>(operatorArguments))
    /// The input array.
    member __.X = operatorArguments.GetInput "x"
    /// <summary>Copy NpiCbrt instance with updated inputs/parameters.</summary>
    /// <param name="x">The input array.</param>
    member this.With([<Optional>] ?x : Symbol) =
        let operatorArguments = 
            [
                x |> Option.map (fun x -> "x", Input x)
            ] |> List.choose id
        new NpiCbrt(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type NpiExp private (operatorArguments) = 
    inherit SymbolOperator("_npi_exp", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new NpiExp(args)
    override this.WithArguments(args : Arguments<Symbol>) = new NpiExp(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <summary>Calculate the exponential of all elements in the input array.
    /// Example::
    ///    exp([0, 1, 2]) = [1., 2.71828175, 7.38905621]
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\numpy\np_elemwise_unary_op_basic.cc:L194</summary>
    /// <param name="x">The input array.</param>
    new([<Optional>] ?x : Symbol) =
        let x = defaultArg x (new ImplicitVariable() :> Symbol)
        let operatorArguments = 
            [
                "x", Input x
            ]
        new NpiExp(Arguments<Symbol>(operatorArguments))
    /// The input array.
    member __.X = operatorArguments.GetInput "x"
    /// <summary>Copy NpiExp instance with updated inputs/parameters.</summary>
    /// <param name="x">The input array.</param>
    member this.With([<Optional>] ?x : Symbol) =
        let operatorArguments = 
            [
                x |> Option.map (fun x -> "x", Input x)
            ] |> List.choose id
        new NpiExp(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type NpiLog private (operatorArguments) = 
    inherit SymbolOperator("_npi_log", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new NpiLog(args)
    override this.WithArguments(args : Arguments<Symbol>) = new NpiLog(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <summary>Returns element-wise Natural logarithmic value of the input.
    /// The natural logarithm is logarithm in base *e*, so that ``log(exp(x)) = x``
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\numpy\np_elemwise_unary_op_basic.cc:L201</summary>
    /// <param name="x">The input array.</param>
    new([<Optional>] ?x : Symbol) =
        let x = defaultArg x (new ImplicitVariable() :> Symbol)
        let operatorArguments = 
            [
                "x", Input x
            ]
        new NpiLog(Arguments<Symbol>(operatorArguments))
    /// The input array.
    member __.X = operatorArguments.GetInput "x"
    /// <summary>Copy NpiLog instance with updated inputs/parameters.</summary>
    /// <param name="x">The input array.</param>
    member this.With([<Optional>] ?x : Symbol) =
        let operatorArguments = 
            [
                x |> Option.map (fun x -> "x", Input x)
            ] |> List.choose id
        new NpiLog(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type NpiLog10 private (operatorArguments) = 
    inherit SymbolOperator("_npi_log10", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new NpiLog10(args)
    override this.WithArguments(args : Arguments<Symbol>) = new NpiLog10(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <summary>Returns element-wise Base-10 logarithmic value of the input.
    /// ``10**log10(x) = x``
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\numpy\np_elemwise_unary_op_basic.cc:L222</summary>
    /// <param name="x">The input array.</param>
    new([<Optional>] ?x : Symbol) =
        let x = defaultArg x (new ImplicitVariable() :> Symbol)
        let operatorArguments = 
            [
                "x", Input x
            ]
        new NpiLog10(Arguments<Symbol>(operatorArguments))
    /// The input array.
    member __.X = operatorArguments.GetInput "x"
    /// <summary>Copy NpiLog10 instance with updated inputs/parameters.</summary>
    /// <param name="x">The input array.</param>
    member this.With([<Optional>] ?x : Symbol) =
        let operatorArguments = 
            [
                x |> Option.map (fun x -> "x", Input x)
            ] |> List.choose id
        new NpiLog10(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type NpiLog2 private (operatorArguments) = 
    inherit SymbolOperator("_npi_log2", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new NpiLog2(args)
    override this.WithArguments(args : Arguments<Symbol>) = new NpiLog2(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <summary>Returns element-wise Base-2 logarithmic value of the input.
    /// ``2**log2(x) = x``
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\numpy\np_elemwise_unary_op_basic.cc:L229</summary>
    /// <param name="x">The input array.</param>
    new([<Optional>] ?x : Symbol) =
        let x = defaultArg x (new ImplicitVariable() :> Symbol)
        let operatorArguments = 
            [
                "x", Input x
            ]
        new NpiLog2(Arguments<Symbol>(operatorArguments))
    /// The input array.
    member __.X = operatorArguments.GetInput "x"
    /// <summary>Copy NpiLog2 instance with updated inputs/parameters.</summary>
    /// <param name="x">The input array.</param>
    member this.With([<Optional>] ?x : Symbol) =
        let operatorArguments = 
            [
                x |> Option.map (fun x -> "x", Input x)
            ] |> List.choose id
        new NpiLog2(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type NpiLog1p private (operatorArguments) = 
    inherit SymbolOperator("_npi_log1p", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new NpiLog1p(args)
    override this.WithArguments(args : Arguments<Symbol>) = new NpiLog1p(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <summary>Return the natural logarithm of one plus the input array, element-wise.
    /// Calculates ``log(1 + x)``.
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\numpy\np_elemwise_unary_op_basic.cc:L236</summary>
    /// <param name="x">The input array.</param>
    new([<Optional>] ?x : Symbol) =
        let x = defaultArg x (new ImplicitVariable() :> Symbol)
        let operatorArguments = 
            [
                "x", Input x
            ]
        new NpiLog1p(Arguments<Symbol>(operatorArguments))
    /// The input array.
    member __.X = operatorArguments.GetInput "x"
    /// <summary>Copy NpiLog1p instance with updated inputs/parameters.</summary>
    /// <param name="x">The input array.</param>
    member this.With([<Optional>] ?x : Symbol) =
        let operatorArguments = 
            [
                x |> Option.map (fun x -> "x", Input x)
            ] |> List.choose id
        new NpiLog1p(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type NpiExpm1 private (operatorArguments) = 
    inherit SymbolOperator("_npi_expm1", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new NpiExpm1(args)
    override this.WithArguments(args : Arguments<Symbol>) = new NpiExpm1(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <summary>Calculate ``exp(x) - 1`` for all elements in the array.
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\numpy\np_elemwise_unary_op_basic.cc:L241</summary>
    /// <param name="x">The input array.</param>
    new([<Optional>] ?x : Symbol) =
        let x = defaultArg x (new ImplicitVariable() :> Symbol)
        let operatorArguments = 
            [
                "x", Input x
            ]
        new NpiExpm1(Arguments<Symbol>(operatorArguments))
    /// The input array.
    member __.X = operatorArguments.GetInput "x"
    /// <summary>Copy NpiExpm1 instance with updated inputs/parameters.</summary>
    /// <param name="x">The input array.</param>
    member this.With([<Optional>] ?x : Symbol) =
        let operatorArguments = 
            [
                x |> Option.map (fun x -> "x", Input x)
            ] |> List.choose id
        new NpiExpm1(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type NpiLogicalNot private (operatorArguments) = 
    inherit SymbolOperator("_npi_logical_not", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new NpiLogicalNot(args)
    override this.WithArguments(args : Arguments<Symbol>) = new NpiLogicalNot(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <summary>Compute the truth value of NOT x element-wise.
    /// Example::
    ///   logical_not([-2., 0., 1.]) = [0., 1., 0.]
    /// </summary>
    /// <param name="x">The input array.</param>
    new([<Optional>] ?x : Symbol) =
        let x = defaultArg x (new ImplicitVariable() :> Symbol)
        let operatorArguments = 
            [
                "x", Input x
            ]
        new NpiLogicalNot(Arguments<Symbol>(operatorArguments))
    /// The input array.
    member __.X = operatorArguments.GetInput "x"
    /// <summary>Copy NpiLogicalNot instance with updated inputs/parameters.</summary>
    /// <param name="x">The input array.</param>
    member this.With([<Optional>] ?x : Symbol) =
        let operatorArguments = 
            [
                x |> Option.map (fun x -> "x", Input x)
            ] |> List.choose id
        new NpiLogicalNot(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type NpiSin private (operatorArguments) = 
    inherit SymbolOperator("_npi_sin", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new NpiSin(args)
    override this.WithArguments(args : Arguments<Symbol>) = new NpiSin(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <summary>Trigonometric sine, element-wise.
    /// .. math::
    ///    sin([0, \pi/4, \pi/2]) = [0, 0.707, 1]
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\numpy\np_elemwise_unary_op_basic.cc:L258</summary>
    /// <param name="x">The input array.</param>
    new([<Optional>] ?x : Symbol) =
        let x = defaultArg x (new ImplicitVariable() :> Symbol)
        let operatorArguments = 
            [
                "x", Input x
            ]
        new NpiSin(Arguments<Symbol>(operatorArguments))
    /// The input array.
    member __.X = operatorArguments.GetInput "x"
    /// <summary>Copy NpiSin instance with updated inputs/parameters.</summary>
    /// <param name="x">The input array.</param>
    member this.With([<Optional>] ?x : Symbol) =
        let operatorArguments = 
            [
                x |> Option.map (fun x -> "x", Input x)
            ] |> List.choose id
        new NpiSin(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type NpiCos private (operatorArguments) = 
    inherit SymbolOperator("_npi_cos", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new NpiCos(args)
    override this.WithArguments(args : Arguments<Symbol>) = new NpiCos(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <summary>Computes the element-wise cosine of the input array.
    /// .. math::
    ///    cos([0, \pi/4, \pi/2]) = [1, 0.707, 0]
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\numpy\np_elemwise_unary_op_basic.cc:L266</summary>
    /// <param name="x">The input array.</param>
    new([<Optional>] ?x : Symbol) =
        let x = defaultArg x (new ImplicitVariable() :> Symbol)
        let operatorArguments = 
            [
                "x", Input x
            ]
        new NpiCos(Arguments<Symbol>(operatorArguments))
    /// The input array.
    member __.X = operatorArguments.GetInput "x"
    /// <summary>Copy NpiCos instance with updated inputs/parameters.</summary>
    /// <param name="x">The input array.</param>
    member this.With([<Optional>] ?x : Symbol) =
        let operatorArguments = 
            [
                x |> Option.map (fun x -> "x", Input x)
            ] |> List.choose id
        new NpiCos(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type NpiTan private (operatorArguments) = 
    inherit SymbolOperator("_npi_tan", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new NpiTan(args)
    override this.WithArguments(args : Arguments<Symbol>) = new NpiTan(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <summary>Computes the element-wise tangent of the input array.
    /// .. math::
    ///    tan([0, \pi/4, \pi/2]) = [0, 1, -inf]
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\numpy\np_elemwise_unary_op_basic.cc:L274</summary>
    /// <param name="x">The input array.</param>
    new([<Optional>] ?x : Symbol) =
        let x = defaultArg x (new ImplicitVariable() :> Symbol)
        let operatorArguments = 
            [
                "x", Input x
            ]
        new NpiTan(Arguments<Symbol>(operatorArguments))
    /// The input array.
    member __.X = operatorArguments.GetInput "x"
    /// <summary>Copy NpiTan instance with updated inputs/parameters.</summary>
    /// <param name="x">The input array.</param>
    member this.With([<Optional>] ?x : Symbol) =
        let operatorArguments = 
            [
                x |> Option.map (fun x -> "x", Input x)
            ] |> List.choose id
        new NpiTan(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type NpiArcsin private (operatorArguments) = 
    inherit SymbolOperator("_npi_arcsin", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new NpiArcsin(args)
    override this.WithArguments(args : Arguments<Symbol>) = new NpiArcsin(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <summary>Returns element-wise inverse sine of the input array.
    /// .. math::
    ///    arcsin([-1, -.707, 0, .707, 1]) = [-\pi/2, -\pi/4, 0, \pi/4, \pi/2]
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\numpy\np_elemwise_unary_op_basic.cc:L282</summary>
    /// <param name="x">The input array.</param>
    new([<Optional>] ?x : Symbol) =
        let x = defaultArg x (new ImplicitVariable() :> Symbol)
        let operatorArguments = 
            [
                "x", Input x
            ]
        new NpiArcsin(Arguments<Symbol>(operatorArguments))
    /// The input array.
    member __.X = operatorArguments.GetInput "x"
    /// <summary>Copy NpiArcsin instance with updated inputs/parameters.</summary>
    /// <param name="x">The input array.</param>
    member this.With([<Optional>] ?x : Symbol) =
        let operatorArguments = 
            [
                x |> Option.map (fun x -> "x", Input x)
            ] |> List.choose id
        new NpiArcsin(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type NpiArccos private (operatorArguments) = 
    inherit SymbolOperator("_npi_arccos", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new NpiArccos(args)
    override this.WithArguments(args : Arguments<Symbol>) = new NpiArccos(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <summary>Returns element-wise inverse cosine of the input array.
    /// The input should be in range `[-1, 1]`.
    /// The output is in the closed interval :math:`[0, \pi]`
    /// .. math::
    ///    arccos([-1, -.707, 0, .707, 1]) = [\pi, 3\pi/4, \pi/2, \pi/4, 0]
    /// The storage type of ``arccos`` output is always dense
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\numpy\np_elemwise_unary_op_basic.cc:L293</summary>
    /// <param name="x">The input array.</param>
    new([<Optional>] ?x : Symbol) =
        let x = defaultArg x (new ImplicitVariable() :> Symbol)
        let operatorArguments = 
            [
                "x", Input x
            ]
        new NpiArccos(Arguments<Symbol>(operatorArguments))
    /// The input array.
    member __.X = operatorArguments.GetInput "x"
    /// <summary>Copy NpiArccos instance with updated inputs/parameters.</summary>
    /// <param name="x">The input array.</param>
    member this.With([<Optional>] ?x : Symbol) =
        let operatorArguments = 
            [
                x |> Option.map (fun x -> "x", Input x)
            ] |> List.choose id
        new NpiArccos(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type NpiArctan private (operatorArguments) = 
    inherit SymbolOperator("_npi_arctan", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new NpiArctan(args)
    override this.WithArguments(args : Arguments<Symbol>) = new NpiArctan(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <summary>Returns element-wise inverse tangent of the input array.
    /// .. math::
    ///    arctan([-1, 0, 1]) = [-\pi/4, 0, \pi/4]
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\numpy\np_elemwise_unary_op_basic.cc:L301</summary>
    /// <param name="x">The input array.</param>
    new([<Optional>] ?x : Symbol) =
        let x = defaultArg x (new ImplicitVariable() :> Symbol)
        let operatorArguments = 
            [
                "x", Input x
            ]
        new NpiArctan(Arguments<Symbol>(operatorArguments))
    /// The input array.
    member __.X = operatorArguments.GetInput "x"
    /// <summary>Copy NpiArctan instance with updated inputs/parameters.</summary>
    /// <param name="x">The input array.</param>
    member this.With([<Optional>] ?x : Symbol) =
        let operatorArguments = 
            [
                x |> Option.map (fun x -> "x", Input x)
            ] |> List.choose id
        new NpiArctan(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type NpiDegrees private (operatorArguments) = 
    inherit SymbolOperator("_npi_degrees", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new NpiDegrees(args)
    override this.WithArguments(args : Arguments<Symbol>) = new NpiDegrees(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <summary>Converts each element of the input array from radians to degrees.
    /// .. math::
    ///    degrees([0, \pi/2, \pi, 3\pi/2, 2\pi]) = [0, 90, 180, 270, 360]
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\numpy\np_elemwise_unary_op_basic.cc:L309</summary>
    /// <param name="x">The input array.</param>
    new([<Optional>] ?x : Symbol) =
        let x = defaultArg x (new ImplicitVariable() :> Symbol)
        let operatorArguments = 
            [
                "x", Input x
            ]
        new NpiDegrees(Arguments<Symbol>(operatorArguments))
    /// The input array.
    member __.X = operatorArguments.GetInput "x"
    /// <summary>Copy NpiDegrees instance with updated inputs/parameters.</summary>
    /// <param name="x">The input array.</param>
    member this.With([<Optional>] ?x : Symbol) =
        let operatorArguments = 
            [
                x |> Option.map (fun x -> "x", Input x)
            ] |> List.choose id
        new NpiDegrees(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type NpiRadians private (operatorArguments) = 
    inherit SymbolOperator("_npi_radians", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new NpiRadians(args)
    override this.WithArguments(args : Arguments<Symbol>) = new NpiRadians(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <summary>Converts each element of the input array from degrees to radians.
    /// .. math::
    ///    radians([0, 90, 180, 270, 360]) = [0, \pi/2, \pi, 3\pi/2, 2\pi]
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\numpy\np_elemwise_unary_op_basic.cc:L317</summary>
    /// <param name="x">The input array.</param>
    new([<Optional>] ?x : Symbol) =
        let x = defaultArg x (new ImplicitVariable() :> Symbol)
        let operatorArguments = 
            [
                "x", Input x
            ]
        new NpiRadians(Arguments<Symbol>(operatorArguments))
    /// The input array.
    member __.X = operatorArguments.GetInput "x"
    /// <summary>Copy NpiRadians instance with updated inputs/parameters.</summary>
    /// <param name="x">The input array.</param>
    member this.With([<Optional>] ?x : Symbol) =
        let operatorArguments = 
            [
                x |> Option.map (fun x -> "x", Input x)
            ] |> List.choose id
        new NpiRadians(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type NpiSinh private (operatorArguments) = 
    inherit SymbolOperator("_npi_sinh", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new NpiSinh(args)
    override this.WithArguments(args : Arguments<Symbol>) = new NpiSinh(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <summary>Returns the hyperbolic sine of the input array, computed element-wise.
    /// .. math::
    ///    sinh(x) = 0.5\times(exp(x) - exp(-x))
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\numpy\np_elemwise_unary_op_basic.cc:L325</summary>
    /// <param name="x">The input array.</param>
    new([<Optional>] ?x : Symbol) =
        let x = defaultArg x (new ImplicitVariable() :> Symbol)
        let operatorArguments = 
            [
                "x", Input x
            ]
        new NpiSinh(Arguments<Symbol>(operatorArguments))
    /// The input array.
    member __.X = operatorArguments.GetInput "x"
    /// <summary>Copy NpiSinh instance with updated inputs/parameters.</summary>
    /// <param name="x">The input array.</param>
    member this.With([<Optional>] ?x : Symbol) =
        let operatorArguments = 
            [
                x |> Option.map (fun x -> "x", Input x)
            ] |> List.choose id
        new NpiSinh(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type NpiCosh private (operatorArguments) = 
    inherit SymbolOperator("_npi_cosh", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new NpiCosh(args)
    override this.WithArguments(args : Arguments<Symbol>) = new NpiCosh(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <summary>Returns the hyperbolic cosine  of the input array, computed element-wise.
    /// .. math::
    ///    cosh(x) = 0.5\times(exp(x) + exp(-x))
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\numpy\np_elemwise_unary_op_basic.cc:L333</summary>
    /// <param name="x">The input array.</param>
    new([<Optional>] ?x : Symbol) =
        let x = defaultArg x (new ImplicitVariable() :> Symbol)
        let operatorArguments = 
            [
                "x", Input x
            ]
        new NpiCosh(Arguments<Symbol>(operatorArguments))
    /// The input array.
    member __.X = operatorArguments.GetInput "x"
    /// <summary>Copy NpiCosh instance with updated inputs/parameters.</summary>
    /// <param name="x">The input array.</param>
    member this.With([<Optional>] ?x : Symbol) =
        let operatorArguments = 
            [
                x |> Option.map (fun x -> "x", Input x)
            ] |> List.choose id
        new NpiCosh(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type NpiTanh private (operatorArguments) = 
    inherit SymbolOperator("_npi_tanh", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new NpiTanh(args)
    override this.WithArguments(args : Arguments<Symbol>) = new NpiTanh(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <summary>Returns the hyperbolic tangent of the input array, computed element-wise.
    /// .. math::
    ///    tanh(x) = sinh(x) / cosh(x)
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\numpy\np_elemwise_unary_op_basic.cc:L341</summary>
    /// <param name="x">The input array.</param>
    new([<Optional>] ?x : Symbol) =
        let x = defaultArg x (new ImplicitVariable() :> Symbol)
        let operatorArguments = 
            [
                "x", Input x
            ]
        new NpiTanh(Arguments<Symbol>(operatorArguments))
    /// The input array.
    member __.X = operatorArguments.GetInput "x"
    /// <summary>Copy NpiTanh instance with updated inputs/parameters.</summary>
    /// <param name="x">The input array.</param>
    member this.With([<Optional>] ?x : Symbol) =
        let operatorArguments = 
            [
                x |> Option.map (fun x -> "x", Input x)
            ] |> List.choose id
        new NpiTanh(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type NpiArcsinh private (operatorArguments) = 
    inherit SymbolOperator("_npi_arcsinh", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new NpiArcsinh(args)
    override this.WithArguments(args : Arguments<Symbol>) = new NpiArcsinh(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <summary>Returns the element-wise inverse hyperbolic sine of the input array, \
    /// computed element-wise.
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\numpy\np_elemwise_unary_op_basic.cc:L348</summary>
    /// <param name="x">The input array.</param>
    new([<Optional>] ?x : Symbol) =
        let x = defaultArg x (new ImplicitVariable() :> Symbol)
        let operatorArguments = 
            [
                "x", Input x
            ]
        new NpiArcsinh(Arguments<Symbol>(operatorArguments))
    /// The input array.
    member __.X = operatorArguments.GetInput "x"
    /// <summary>Copy NpiArcsinh instance with updated inputs/parameters.</summary>
    /// <param name="x">The input array.</param>
    member this.With([<Optional>] ?x : Symbol) =
        let operatorArguments = 
            [
                x |> Option.map (fun x -> "x", Input x)
            ] |> List.choose id
        new NpiArcsinh(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type NpiArccosh private (operatorArguments) = 
    inherit SymbolOperator("_npi_arccosh", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new NpiArccosh(args)
    override this.WithArguments(args : Arguments<Symbol>) = new NpiArccosh(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <summary>Returns the element-wise inverse hyperbolic cosine of the input array, \
    /// computed element-wise.
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\numpy\np_elemwise_unary_op_basic.cc:L355</summary>
    /// <param name="x">The input array.</param>
    new([<Optional>] ?x : Symbol) =
        let x = defaultArg x (new ImplicitVariable() :> Symbol)
        let operatorArguments = 
            [
                "x", Input x
            ]
        new NpiArccosh(Arguments<Symbol>(operatorArguments))
    /// The input array.
    member __.X = operatorArguments.GetInput "x"
    /// <summary>Copy NpiArccosh instance with updated inputs/parameters.</summary>
    /// <param name="x">The input array.</param>
    member this.With([<Optional>] ?x : Symbol) =
        let operatorArguments = 
            [
                x |> Option.map (fun x -> "x", Input x)
            ] |> List.choose id
        new NpiArccosh(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type NpiArctanh private (operatorArguments) = 
    inherit SymbolOperator("_npi_arctanh", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new NpiArctanh(args)
    override this.WithArguments(args : Arguments<Symbol>) = new NpiArctanh(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <summary>Returns the element-wise inverse hyperbolic tangent of the input array, \
    /// computed element-wise.
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\numpy\np_elemwise_unary_op_basic.cc:L362</summary>
    /// <param name="x">The input array.</param>
    new([<Optional>] ?x : Symbol) =
        let x = defaultArg x (new ImplicitVariable() :> Symbol)
        let operatorArguments = 
            [
                "x", Input x
            ]
        new NpiArctanh(Arguments<Symbol>(operatorArguments))
    /// The input array.
    member __.X = operatorArguments.GetInput "x"
    /// <summary>Copy NpiArctanh instance with updated inputs/parameters.</summary>
    /// <param name="x">The input array.</param>
    member this.With([<Optional>] ?x : Symbol) =
        let operatorArguments = 
            [
                x |> Option.map (fun x -> "x", Input x)
            ] |> List.choose id
        new NpiArctanh(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type NpiAround private (operatorArguments) = 
    inherit SymbolOperator("_npi_around", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new NpiAround(args)
    override this.WithArguments(args : Arguments<Symbol>) = new NpiAround(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <param name="x">Input ndarray</param>
    /// <param name="decimals">Number of decimal places to round to.</param>
    new([<Optional>] ?x : Symbol,
        [<Optional>] ?decimals : int) = 
        let x = defaultArg x (new ImplicitVariable() :> Symbol)
        let operatorArguments = 
            [
                "x", Input x
                "decimals", decimals |> Option.map box |> Parameter
            ]
        new NpiAround(Arguments<Symbol>(operatorArguments))
    /// Default value for Decimals
    /// Number of decimal places to round to.
    static member DecimalsDefault : int = 0
    /// Input ndarray
    member __.X = operatorArguments.GetInput "x"
    /// Number of decimal places to round to.
    member __.Decimals = operatorArguments.GetParameter("decimals", NpiAround.DecimalsDefault)
    /// <summary>Copy NpiAround instance with updated inputs/parameters.</summary>
    /// <param name="x">Input ndarray</param>
    /// <param name="decimals">Number of decimal places to round to.</param>
    member this.With([<Optional>] ?x : Symbol,
        [<Optional>] ?decimals : int) = 
        let operatorArguments = 
            [
                x |> Option.map (fun x -> "x", Input x)
                decimals |> Option.map (fun x -> "decimals", Parameter(Some (box x)))
            ] |> List.choose id
        new NpiAround(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type NpiZeros private (operatorArguments) = 
    inherit SymbolOperator("_npi_zeros", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new NpiZeros(args)
    override this.WithArguments(args : Arguments<Symbol>) = new NpiZeros(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <param name="shape">The shape of the output</param>
    /// <param name="dtype">Target data type.</param>
    new([<Optional>] ?shape : int seq,
        [<Optional>] ?dtype : IntOrFloatDType) = 
        let operatorArguments = 
            [
                "shape", shape |> Option.map box |> Parameter
                "dtype", dtype |> Option.map box |> Parameter
            ]
        new NpiZeros(Arguments<Symbol>(operatorArguments))
    /// Default value for Shape
    /// The shape of the output
    static member ShapeDefault : int [] = [||]
    /// Default value for Dtype
    /// Target data type.
    static member DtypeDefault : IntOrFloatDType = IntOrFloatDType.Float32
    /// The shape of the output
    member __.Shape = operatorArguments.GetParameter("shape", NpiZeros.ShapeDefault)
    /// Target data type.
    member __.Dtype = operatorArguments.GetParameter("dtype", NpiZeros.DtypeDefault)
    /// <summary>Copy NpiZeros instance with updated inputs/parameters.</summary>
    /// <param name="shape">The shape of the output</param>
    /// <param name="dtype">Target data type.</param>
    member this.With([<Optional>] ?shape : int seq,
        [<Optional>] ?dtype : IntOrFloatDType) = 
        let operatorArguments = 
            [
                shape |> Option.map (fun x -> "shape", Parameter(Some (box x)))
                dtype |> Option.map (fun x -> "dtype", Parameter(Some (box x)))
            ] |> List.choose id
        new NpiZeros(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type NpiOnes private (operatorArguments) = 
    inherit SymbolOperator("_npi_ones", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new NpiOnes(args)
    override this.WithArguments(args : Arguments<Symbol>) = new NpiOnes(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <summary>Return a new array of given shape, type, and context, filled with ones.</summary>
    /// <param name="shape">The shape of the output</param>
    /// <param name="dtype">Target data type.</param>
    new([<Optional>] ?shape : int seq,
        [<Optional>] ?dtype : IntOrFloatDType) = 
        let operatorArguments = 
            [
                "shape", shape |> Option.map box |> Parameter
                "dtype", dtype |> Option.map box |> Parameter
            ]
        new NpiOnes(Arguments<Symbol>(operatorArguments))
    /// Default value for Shape
    /// The shape of the output
    static member ShapeDefault : int [] = [||]
    /// Default value for Dtype
    /// Target data type.
    static member DtypeDefault : IntOrFloatDType = IntOrFloatDType.Float32
    /// The shape of the output
    member __.Shape = operatorArguments.GetParameter("shape", NpiOnes.ShapeDefault)
    /// Target data type.
    member __.Dtype = operatorArguments.GetParameter("dtype", NpiOnes.DtypeDefault)
    /// <summary>Copy NpiOnes instance with updated inputs/parameters.</summary>
    /// <param name="shape">The shape of the output</param>
    /// <param name="dtype">Target data type.</param>
    member this.With([<Optional>] ?shape : int seq,
        [<Optional>] ?dtype : IntOrFloatDType) = 
        let operatorArguments = 
            [
                shape |> Option.map (fun x -> "shape", Parameter(Some (box x)))
                dtype |> Option.map (fun x -> "dtype", Parameter(Some (box x)))
            ] |> List.choose id
        new NpiOnes(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type NpiIdentity private (operatorArguments) = 
    inherit SymbolOperator("_npi_identity", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new NpiIdentity(args)
    override this.WithArguments(args : Arguments<Symbol>) = new NpiIdentity(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <summary>Return a new identity array of given shape, type, and context.</summary>
    /// <param name="shape">The shape of the output</param>
    /// <param name="dtype">Target data type.</param>
    new([<Optional>] ?shape : int seq,
        [<Optional>] ?dtype : IntOrFloatDType) = 
        let operatorArguments = 
            [
                "shape", shape |> Option.map box |> Parameter
                "dtype", dtype |> Option.map box |> Parameter
            ]
        new NpiIdentity(Arguments<Symbol>(operatorArguments))
    /// Default value for Shape
    /// The shape of the output
    static member ShapeDefault : int [] = [||]
    /// Default value for Dtype
    /// Target data type.
    static member DtypeDefault : IntOrFloatDType = IntOrFloatDType.Float32
    /// The shape of the output
    member __.Shape = operatorArguments.GetParameter("shape", NpiIdentity.ShapeDefault)
    /// Target data type.
    member __.Dtype = operatorArguments.GetParameter("dtype", NpiIdentity.DtypeDefault)
    /// <summary>Copy NpiIdentity instance with updated inputs/parameters.</summary>
    /// <param name="shape">The shape of the output</param>
    /// <param name="dtype">Target data type.</param>
    member this.With([<Optional>] ?shape : int seq,
        [<Optional>] ?dtype : IntOrFloatDType) = 
        let operatorArguments = 
            [
                shape |> Option.map (fun x -> "shape", Parameter(Some (box x)))
                dtype |> Option.map (fun x -> "dtype", Parameter(Some (box x)))
            ] |> List.choose id
        new NpiIdentity(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type NpZerosLike private (operatorArguments) = 
    inherit SymbolOperator("_np_zeros_like", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new NpZerosLike(args)
    override this.WithArguments(args : Arguments<Symbol>) = new NpZerosLike(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <param name="a">The shape and data-type of a define these same attributes of the returned array.</param>
    new([<Optional>] ?a : Symbol) =
        let a = defaultArg a (new ImplicitVariable() :> Symbol)
        let operatorArguments = 
            [
                "a", Input a
            ]
        new NpZerosLike(Arguments<Symbol>(operatorArguments))
    /// The shape and data-type of a define these same attributes of the returned array.
    member __.A = operatorArguments.GetInput "a"
    /// <summary>Copy NpZerosLike instance with updated inputs/parameters.</summary>
    /// <param name="a">The shape and data-type of a define these same attributes of the returned array.</param>
    member this.With([<Optional>] ?a : Symbol) =
        let operatorArguments = 
            [
                a |> Option.map (fun x -> "a", Input x)
            ] |> List.choose id
        new NpZerosLike(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type NpOnesLike private (operatorArguments) = 
    inherit SymbolOperator("_np_ones_like", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new NpOnesLike(args)
    override this.WithArguments(args : Arguments<Symbol>) = new NpOnesLike(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <param name="a">The shape and data-type of a define these same attributes of the returned array.</param>
    new([<Optional>] ?a : Symbol) =
        let a = defaultArg a (new ImplicitVariable() :> Symbol)
        let operatorArguments = 
            [
                "a", Input a
            ]
        new NpOnesLike(Arguments<Symbol>(operatorArguments))
    /// The shape and data-type of a define these same attributes of the returned array.
    member __.A = operatorArguments.GetInput "a"
    /// <summary>Copy NpOnesLike instance with updated inputs/parameters.</summary>
    /// <param name="a">The shape and data-type of a define these same attributes of the returned array.</param>
    member this.With([<Optional>] ?a : Symbol) =
        let operatorArguments = 
            [
                a |> Option.map (fun x -> "a", Input x)
            ] |> List.choose id
        new NpOnesLike(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type NpiArange private (operatorArguments) = 
    inherit SymbolOperator("_npi_arange", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new NpiArange(args)
    override this.WithArguments(args : Arguments<Symbol>) = new NpiArange(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <param name="start">Start of interval. The interval includes this value. The default start value is 0.</param>
    /// <param name="stop">End of interval. The interval does not include this value, except in some cases where step is not an integer and floating point round-off affects the length of out.</param>
    /// <param name="step">Spacing between values.</param>
    /// <param name="repeat">The repeating time of all elements. E.g repeat=3, the element a will be repeated three times --&gt; a, a, a.</param>
    /// <param name="inferRange">When set to True, infer the stop position from the start, step, repeat, and output tensor size.</param>
    /// <param name="dtype">Target data type.</param>
    new(start : double,
        [<Optional>] ?stop : float,
        [<Optional>] ?step : double,
        [<Optional>] ?repeat : int,
        [<Optional>] ?inferRange : bool,
        [<Optional>] ?dtype : IntOrFloatDType) = 
        let operatorArguments = 
            [
                "start", Parameter(Some(box start))
                "stop", stop |> Option.map box |> Parameter
                "step", step |> Option.map box |> Parameter
                "repeat", repeat |> Option.map box |> Parameter
                "infer_range", inferRange |> Option.map box |> Parameter
                "dtype", dtype |> Option.map box |> Parameter
            ]
        new NpiArange(Arguments<Symbol>(operatorArguments))
    /// Default value for Stop
    /// End of interval. The interval does not include this value, except in some cases where step is not an integer and floating point round-off affects the length of out.
    static member StopDefault : double option = None
    /// Default value for Step
    /// Spacing between values.
    static member StepDefault : double = 1.0
    /// Default value for Repeat
    /// The repeating time of all elements. E.g repeat=3, the element a will be repeated three times --&gt; a, a, a.
    static member RepeatDefault : int = 1
    /// Default value for InferRange
    /// When set to True, infer the stop position from the start, step, repeat, and output tensor size.
    static member InferRangeDefault : bool = false
    /// Default value for Dtype
    /// Target data type.
    static member DtypeDefault : IntOrFloatDType = IntOrFloatDType.Float32
    /// Start of interval. The interval includes this value. The default start value is 0.
    member __.Start : double = match operatorArguments.GetParameter "start" with Some(v) -> unbox v | None -> failwithf "Required parameter start is missing"
    /// End of interval. The interval does not include this value, except in some cases where step is not an integer and floating point round-off affects the length of out.
    member __.Stop = operatorArguments.GetParameter("stop", NpiArange.StopDefault)
    /// Spacing between values.
    member __.Step = operatorArguments.GetParameter("step", NpiArange.StepDefault)
    /// The repeating time of all elements. E.g repeat=3, the element a will be repeated three times --&gt; a, a, a.
    member __.Repeat = operatorArguments.GetParameter("repeat", NpiArange.RepeatDefault)
    /// When set to True, infer the stop position from the start, step, repeat, and output tensor size.
    member __.InferRange = operatorArguments.GetParameter("infer_range", NpiArange.InferRangeDefault)
    /// Target data type.
    member __.Dtype = operatorArguments.GetParameter("dtype", NpiArange.DtypeDefault)
    /// <summary>Copy NpiArange instance with updated inputs/parameters.</summary>
    /// <param name="start">Start of interval. The interval includes this value. The default start value is 0.</param>
    /// <param name="stop">End of interval. The interval does not include this value, except in some cases where step is not an integer and floating point round-off affects the length of out.</param>
    /// <param name="step">Spacing between values.</param>
    /// <param name="repeat">The repeating time of all elements. E.g repeat=3, the element a will be repeated three times --&gt; a, a, a.</param>
    /// <param name="inferRange">When set to True, infer the stop position from the start, step, repeat, and output tensor size.</param>
    /// <param name="dtype">Target data type.</param>
    member this.With([<Optional>] ?start : double,
        [<Optional>] ?stop : float,
        [<Optional>] ?step : double,
        [<Optional>] ?repeat : int,
        [<Optional>] ?inferRange : bool,
        [<Optional>] ?dtype : IntOrFloatDType) = 
        let operatorArguments = 
            [
                start |> Option.map (fun x -> "start", Parameter(Some (box x)))
                stop |> Option.map (fun x -> "stop", Parameter(Some (box x)))
                step |> Option.map (fun x -> "step", Parameter(Some (box x)))
                repeat |> Option.map (fun x -> "repeat", Parameter(Some (box x)))
                inferRange |> Option.map (fun x -> "infer_range", Parameter(Some (box x)))
                dtype |> Option.map (fun x -> "dtype", Parameter(Some (box x)))
            ] |> List.choose id
        new NpiArange(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type NpiIndices private (operatorArguments) = 
    inherit SymbolOperator("_npi_indices", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new NpiIndices(args)
    override this.WithArguments(args : Arguments<Symbol>) = new NpiIndices(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <summary>Return an array representing the indices of a grid.</summary>
    /// <param name="dimensions">The shape of the grid.</param>
    /// <param name="dtype">Target data type.</param>
    new(dimensions : int seq,
        [<Optional>] ?dtype : IntOrFloatDType) = 
        let operatorArguments = 
            [
                "dimensions", Parameter(Some(box dimensions))
                "dtype", dtype |> Option.map box |> Parameter
            ]
        new NpiIndices(Arguments<Symbol>(operatorArguments))
    /// Default value for Dtype
    /// Target data type.
    static member DtypeDefault : IntOrFloatDType = IntOrFloatDType.Int32
    /// The shape of the grid.
    member __.Dimensions : int seq = match operatorArguments.GetParameter "dimensions" with Some(v) -> unbox v | None -> failwithf "Required parameter dimensions is missing"
    /// Target data type.
    member __.Dtype = operatorArguments.GetParameter("dtype", NpiIndices.DtypeDefault)
    /// <summary>Copy NpiIndices instance with updated inputs/parameters.</summary>
    /// <param name="dimensions">The shape of the grid.</param>
    /// <param name="dtype">Target data type.</param>
    member this.With([<Optional>] ?dimensions : int seq,
        [<Optional>] ?dtype : IntOrFloatDType) = 
        let operatorArguments = 
            [
                dimensions |> Option.map (fun x -> "dimensions", Parameter(Some (box x)))
                dtype |> Option.map (fun x -> "dtype", Parameter(Some (box x)))
            ] |> List.choose id
        new NpiIndices(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type NpTranspose private (operatorArguments) = 
    inherit SymbolOperator("_np_transpose", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new NpTranspose(args)
    override this.WithArguments(args : Arguments<Symbol>) = new NpTranspose(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <param name="a">Source input</param>
    /// <param name="axes">By default, reverse the dimensions, otherwise permute the axes according to the values given.</param>
    new([<Optional>] ?a : Symbol,
        [<Optional>] ?axes : int seq) = 
        let a = defaultArg a (new ImplicitVariable() :> Symbol)
        let operatorArguments = 
            [
                "a", Input a
                "axes", axes |> Option.map box |> Parameter
            ]
        new NpTranspose(Arguments<Symbol>(operatorArguments))
    /// Default value for Axes
    /// By default, reverse the dimensions, otherwise permute the axes according to the values given.
    static member AxesDefault : int [] option = None
    /// Source input
    member __.A = operatorArguments.GetInput "a"
    /// By default, reverse the dimensions, otherwise permute the axes according to the values given.
    member __.Axes = operatorArguments.GetParameter("axes", NpTranspose.AxesDefault)
    /// <summary>Copy NpTranspose instance with updated inputs/parameters.</summary>
    /// <param name="a">Source input</param>
    /// <param name="axes">By default, reverse the dimensions, otherwise permute the axes according to the values given.</param>
    member this.With([<Optional>] ?a : Symbol,
        [<Optional>] ?axes : int seq) = 
        let operatorArguments = 
            [
                a |> Option.map (fun x -> "a", Input x)
                axes |> Option.map (fun x -> "axes", Parameter(Some (box x)))
            ] |> List.choose id
        new NpTranspose(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type NpReshape private (operatorArguments) = 
    inherit SymbolOperator("_np_reshape", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new NpReshape(args)
    override this.WithArguments(args : Arguments<Symbol>) = new NpReshape(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <summary>
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\numpy\np_matrix_op.cc:L167</summary>
    /// <param name="a">Array to be reshaped.</param>
    /// <param name="newshape">The new shape should be compatible with the original shape. If an integer, then the result will be a 1-D array of that length. One shape dimension can be -1. In this case, the value is inferred from the length of the array and remaining dimensions.</param>
    /// <param name="order">Read the elements of a using this index order, and place the elements into the reshaped array using this index order. &#39;C&#39; means to read/write the elements using C-like index order, with the last axis index changing fastest, back to the first axis index changing slowest. Note that currently only C-like order is supported</param>
    new(a : Symbol,
        newshape : int seq,
        [<Optional>] ?order : string) = 
        let operatorArguments = 
            [
                "a", Input a
                "newshape", Parameter(Some(box newshape))
                "order", order |> Option.map box |> Parameter
            ]
        new NpReshape(Arguments<Symbol>(operatorArguments))
    /// <summary>
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\numpy\np_matrix_op.cc:L167</summary>
    /// <param name="newshape">The new shape should be compatible with the original shape. If an integer, then the result will be a 1-D array of that length. One shape dimension can be -1. In this case, the value is inferred from the length of the array and remaining dimensions.</param>
    /// <param name="a">Array to be reshaped.</param>
    /// <param name="order">Read the elements of a using this index order, and place the elements into the reshaped array using this index order. &#39;C&#39; means to read/write the elements using C-like index order, with the last axis index changing fastest, back to the first axis index changing slowest. Note that currently only C-like order is supported</param>
    new(newshape : int seq,
        [<Optional>] ?a : Symbol,
        [<Optional>] ?order : string) = 
        let a = defaultArg a (new ImplicitVariable() :> Symbol)
        let operatorArguments = 
            [
                "a", Input a
                "newshape", Parameter(Some(box newshape))
                "order", order |> Option.map box |> Parameter
            ]
        new NpReshape(Arguments<Symbol>(operatorArguments))
    /// Default value for Order
    /// Read the elements of a using this index order, and place the elements into the reshaped array using this index order. &#39;C&#39; means to read/write the elements using C-like index order, with the last axis index changing fastest, back to the first axis index changing slowest. Note that currently only C-like order is supported
    static member OrderDefault : string = "C"
    /// Array to be reshaped.
    member __.A = operatorArguments.GetInput "a"
    /// The new shape should be compatible with the original shape. If an integer, then the result will be a 1-D array of that length. One shape dimension can be -1. In this case, the value is inferred from the length of the array and remaining dimensions.
    member __.Newshape : int seq = match operatorArguments.GetParameter "newshape" with Some(v) -> unbox v | None -> failwithf "Required parameter newshape is missing"
    /// Read the elements of a using this index order, and place the elements into the reshaped array using this index order. &#39;C&#39; means to read/write the elements using C-like index order, with the last axis index changing fastest, back to the first axis index changing slowest. Note that currently only C-like order is supported
    member __.Order = operatorArguments.GetParameter("order", NpReshape.OrderDefault)
    /// <summary>Copy NpReshape instance with updated inputs/parameters.</summary>
    /// <param name="a">Array to be reshaped.</param>
    /// <param name="newshape">The new shape should be compatible with the original shape. If an integer, then the result will be a 1-D array of that length. One shape dimension can be -1. In this case, the value is inferred from the length of the array and remaining dimensions.</param>
    /// <param name="order">Read the elements of a using this index order, and place the elements into the reshaped array using this index order. &#39;C&#39; means to read/write the elements using C-like index order, with the last axis index changing fastest, back to the first axis index changing slowest. Note that currently only C-like order is supported</param>
    member this.With([<Optional>] ?a : Symbol,
        [<Optional>] ?newshape : int seq,
        [<Optional>] ?order : string) = 
        let operatorArguments = 
            [
                a |> Option.map (fun x -> "a", Input x)
                newshape |> Option.map (fun x -> "newshape", Parameter(Some (box x)))
                order |> Option.map (fun x -> "order", Parameter(Some (box x)))
            ] |> List.choose id
        new NpReshape(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type NpSqueeze private (operatorArguments) = 
    inherit SymbolOperator("_np_squeeze", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new NpSqueeze(args)
    override this.WithArguments(args : Arguments<Symbol>) = new NpSqueeze(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <param name="a">data to squeeze</param>
    /// <param name="axis">Selects a subset of the single-dimensional entries in the shape. If an axis is selected with shape entry greater than one, an error is raised.</param>
    new([<Optional>] ?a : Symbol seq,
        [<Optional>] ?axis : int seq) = 
        let a = defaultArg (a |> Option.map Seq.toArray) Array.empty
        let operatorArguments = 
            [
                "a", VarArg("", a)
                "axis", axis |> Option.map box |> Parameter
            ]
        new NpSqueeze(Arguments<Symbol>(operatorArguments))
    /// Default value for Axis
    /// Selects a subset of the single-dimensional entries in the shape. If an axis is selected with shape entry greater than one, an error is raised.
    static member AxisDefault : int [] option = None
    /// data to squeeze
    member __.A = operatorArguments.GetVarArg "a"
    /// Selects a subset of the single-dimensional entries in the shape. If an axis is selected with shape entry greater than one, an error is raised.
    member __.Axis = operatorArguments.GetParameter("axis", NpSqueeze.AxisDefault)
    /// <summary>Copy NpSqueeze instance with updated inputs/parameters.</summary>
    /// <param name="a">data to squeeze</param>
    /// <param name="axis">Selects a subset of the single-dimensional entries in the shape. If an axis is selected with shape entry greater than one, an error is raised.</param>
    member this.With([<Optional>] ?a : Symbol seq,
        [<Optional>] ?axis : int seq) = 
        let operatorArguments = 
            [
                a |> Option.map (fun x -> "a", VarArg("", Seq.toArray x))
                axis |> Option.map (fun x -> "axis", Parameter(Some (box x)))
            ] |> List.choose id
        new NpSqueeze(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type NpiConcatenate private (operatorArguments) = 
    inherit SymbolOperator("_npi_concatenate", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new NpiConcatenate(args)
    override this.WithArguments(args : Arguments<Symbol>) = new NpiConcatenate(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <summary>Join a sequence of arrays along an existing axis.
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\numpy\np_matrix_op.cc:L274</summary>
    /// <param name="data">List of arrays to concatenate</param>
    /// <param name="dim">the dimension to be concated.</param>
    new([<Optional>] ?data : Symbol seq,
        [<Optional>] ?dim : int) = 
        let data = defaultArg (data |> Option.map Seq.toArray) Array.empty
        let operatorArguments = 
            [
                "data", VarArg("num_args", data)
                "dim", dim |> Option.map box |> Parameter
            ]
        new NpiConcatenate(Arguments<Symbol>(operatorArguments))
    /// Default value for Dim
    /// the dimension to be concated.
    static member DimDefault : int = 1
    /// List of arrays to concatenate
    member __.Data = operatorArguments.GetVarArg "data"
    /// the dimension to be concated.
    member __.Dim = operatorArguments.GetParameter("dim", NpiConcatenate.DimDefault)
    /// <summary>Copy NpiConcatenate instance with updated inputs/parameters.</summary>
    /// <param name="data">List of arrays to concatenate</param>
    /// <param name="dim">the dimension to be concated.</param>
    member this.With([<Optional>] ?data : Symbol seq,
        [<Optional>] ?dim : int) = 
        let operatorArguments = 
            [
                data |> Option.map (fun x -> "data", VarArg("num_args", Seq.toArray x))
                dim |> Option.map (fun x -> "dim", Parameter(Some (box x)))
            ] |> List.choose id
        new NpiConcatenate(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type NpiStack private (operatorArguments) = 
    inherit SymbolOperator("_npi_stack", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new NpiStack(args)
    override this.WithArguments(args : Arguments<Symbol>) = new NpiStack(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <summary>Join a sequence of arrays along a new axis.
    /// 
    /// The axis parameter specifies the index of the new axis in the dimensions of the
    /// result. For example, if axis=0 it will be the first dimension and if axis=-1 it
    /// will be the last dimension.
    /// 
    /// Examples::
    /// 
    ///   x = [1, 2]
    ///   y = [3, 4]
    /// 
    ///   stack(x, y) = [[1, 2],
    ///                  [3, 4]]
    ///   stack(x, y, axis=1) = [[1, 3],
    ///                          [2, 4]]
    /// </summary>
    /// <param name="data">List of arrays to stack</param>
    /// <param name="axis">The axis in the result array along which the input arrays are stacked.</param>
    new([<Optional>] ?data : Symbol seq,
        [<Optional>] ?axis : int) = 
        let data = defaultArg (data |> Option.map Seq.toArray) Array.empty
        let operatorArguments = 
            [
                "data", VarArg("num_args", data)
                "axis", axis |> Option.map box |> Parameter
            ]
        new NpiStack(Arguments<Symbol>(operatorArguments))
    /// Default value for Axis
    /// The axis in the result array along which the input arrays are stacked.
    static member AxisDefault : int = 0
    /// List of arrays to stack
    member __.Data = operatorArguments.GetVarArg "data"
    /// The axis in the result array along which the input arrays are stacked.
    member __.Axis = operatorArguments.GetParameter("axis", NpiStack.AxisDefault)
    /// <summary>Copy NpiStack instance with updated inputs/parameters.</summary>
    /// <param name="data">List of arrays to stack</param>
    /// <param name="axis">The axis in the result array along which the input arrays are stacked.</param>
    member this.With([<Optional>] ?data : Symbol seq,
        [<Optional>] ?axis : int) = 
        let operatorArguments = 
            [
                data |> Option.map (fun x -> "data", VarArg("num_args", Seq.toArray x))
                axis |> Option.map (fun x -> "axis", Parameter(Some (box x)))
            ] |> List.choose id
        new NpiStack(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type NpiVstack private (operatorArguments) = 
    inherit SymbolOperator("_npi_vstack", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new NpiVstack(args)
    override this.WithArguments(args : Arguments<Symbol>) = new NpiVstack(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <summary>
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\numpy\np_matrix_op.cc:L459</summary>
    /// <param name="data">List of arrays to vstack</param>
    new([<ParamArray>] data : Symbol[]) =
        let operatorArguments = 
            [
                "data", VarArg("num_args", data)
            ]
        new NpiVstack(Arguments<Symbol>(operatorArguments))
    /// List of arrays to vstack
    member __.Data = operatorArguments.GetVarArg "data"
    /// <summary>Copy NpiVstack instance with updated inputs/parameters.</summary>
    /// <param name="data">List of arrays to vstack</param>
    member this.With([<Optional>] ?data : Symbol seq) =
        let operatorArguments = 
            [
                data |> Option.map (fun x -> "data", VarArg("num_args", Seq.toArray x))
            ] |> List.choose id
        new NpiVstack(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type NpRoll private (operatorArguments) = 
    inherit SymbolOperator("_np_roll", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new NpRoll(args)
    override this.WithArguments(args : Arguments<Symbol>) = new NpRoll(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <param name="data">Input ndarray</param>
    /// <param name="shift">The number of places by which elements are shifted. If a tuple,then axis must be a tuple of the same size, and each of the given axes is shiftedby the corresponding number. If an int while axis is a tuple of ints, then the same value is used for all given axes.</param>
    /// <param name="axis">Axis or axes along which elements are shifted. By default, the array is flattenedbefore shifting, after which the original shape is restored.</param>
    new([<Optional>] ?data : Symbol,
        [<Optional>] ?shift : int seq,
        [<Optional>] ?axis : int seq) = 
        let data = defaultArg data (new ImplicitVariable() :> Symbol)
        let operatorArguments = 
            [
                "data", Input data
                "shift", shift |> Option.map box |> Parameter
                "axis", axis |> Option.map box |> Parameter
            ]
        new NpRoll(Arguments<Symbol>(operatorArguments))
    /// Default value for Shift
    /// The number of places by which elements are shifted. If a tuple,then axis must be a tuple of the same size, and each of the given axes is shiftedby the corresponding number. If an int while axis is a tuple of ints, then the same value is used for all given axes.
    static member ShiftDefault : int [] option = None
    /// Default value for Axis
    /// Axis or axes along which elements are shifted. By default, the array is flattenedbefore shifting, after which the original shape is restored.
    static member AxisDefault : int [] option = None
    /// Input ndarray
    member __.Data = operatorArguments.GetInput "data"
    /// The number of places by which elements are shifted. If a tuple,then axis must be a tuple of the same size, and each of the given axes is shiftedby the corresponding number. If an int while axis is a tuple of ints, then the same value is used for all given axes.
    member __.Shift = operatorArguments.GetParameter("shift", NpRoll.ShiftDefault)
    /// Axis or axes along which elements are shifted. By default, the array is flattenedbefore shifting, after which the original shape is restored.
    member __.Axis = operatorArguments.GetParameter("axis", NpRoll.AxisDefault)
    /// <summary>Copy NpRoll instance with updated inputs/parameters.</summary>
    /// <param name="data">Input ndarray</param>
    /// <param name="shift">The number of places by which elements are shifted. If a tuple,then axis must be a tuple of the same size, and each of the given axes is shiftedby the corresponding number. If an int while axis is a tuple of ints, then the same value is used for all given axes.</param>
    /// <param name="axis">Axis or axes along which elements are shifted. By default, the array is flattenedbefore shifting, after which the original shape is restored.</param>
    member this.With([<Optional>] ?data : Symbol,
        [<Optional>] ?shift : int seq,
        [<Optional>] ?axis : int seq) = 
        let operatorArguments = 
            [
                data |> Option.map (fun x -> "data", Input x)
                shift |> Option.map (fun x -> "shift", Parameter(Some (box x)))
                axis |> Option.map (fun x -> "axis", Parameter(Some (box x)))
            ] |> List.choose id
        new NpRoll(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type NpiFlip private (operatorArguments) = 
    inherit SymbolOperator("_npi_flip", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new NpiFlip(args)
    override this.WithArguments(args : Arguments<Symbol>) = new NpiFlip(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <param name="data">Input data array</param>
    /// <param name="axis">The axis which to flip elements.</param>
    new(data : Symbol,
        axis : int seq) = 
        let operatorArguments = 
            [
                "data", Input data
                "axis", Parameter(Some(box axis))
            ]
        new NpiFlip(Arguments<Symbol>(operatorArguments))
    /// <param name="axis">The axis which to flip elements.</param>
    /// <param name="data">Input data array</param>
    new(axis : int seq,
        [<Optional>] ?data : Symbol) = 
        let data = defaultArg data (new ImplicitVariable() :> Symbol)
        let operatorArguments = 
            [
                "data", Input data
                "axis", Parameter(Some(box axis))
            ]
        new NpiFlip(Arguments<Symbol>(operatorArguments))
    /// Input data array
    member __.Data = operatorArguments.GetInput "data"
    /// The axis which to flip elements.
    member __.Axis : int seq = match operatorArguments.GetParameter "axis" with Some(v) -> unbox v | None -> failwithf "Required parameter axis is missing"
    /// <summary>Copy NpiFlip instance with updated inputs/parameters.</summary>
    /// <param name="data">Input data array</param>
    /// <param name="axis">The axis which to flip elements.</param>
    member this.With([<Optional>] ?data : Symbol,
        [<Optional>] ?axis : int seq) = 
        let operatorArguments = 
            [
                data |> Option.map (fun x -> "data", Input x)
                axis |> Option.map (fun x -> "axis", Parameter(Some (box x)))
            ] |> List.choose id
        new NpiFlip(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type NpxNonzero private (operatorArguments) = 
    inherit SymbolOperator("_npx_nonzero", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new NpxNonzero(args)
    override this.WithArguments(args : Arguments<Symbol>) = new NpxNonzero(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <param name="x">The input array.</param>
    new([<Optional>] ?x : Symbol) =
        let x = defaultArg x (new ImplicitVariable() :> Symbol)
        let operatorArguments = 
            [
                "x", Input x
            ]
        new NpxNonzero(Arguments<Symbol>(operatorArguments))
    /// The input array.
    member __.X = operatorArguments.GetInput "x"
    /// <summary>Copy NpxNonzero instance with updated inputs/parameters.</summary>
    /// <param name="x">The input array.</param>
    member this.With([<Optional>] ?x : Symbol) =
        let operatorArguments = 
            [
                x |> Option.map (fun x -> "x", Input x)
            ] |> List.choose id
        new NpxNonzero(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type NpiTensordot private (operatorArguments) = 
    inherit SymbolOperator("_npi_tensordot", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new NpiTensordot(args)
    override this.WithArguments(args : Arguments<Symbol>) = new NpiTensordot(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <param name="a">First input</param>
    /// <param name="b">Second input</param>
    /// <param name="aAxesSummed"></param>
    /// <param name="bAxesSummed"></param>
    new(a : Symbol,
        b : Symbol,
        aAxesSummed : int seq,
        bAxesSummed : int seq) = 
        let operatorArguments = 
            [
                "a", Input a
                "b", Input b
                "a_axes_summed", Parameter(Some(box aAxesSummed))
                "b_axes_summed", Parameter(Some(box bAxesSummed))
            ]
        new NpiTensordot(Arguments<Symbol>(operatorArguments))
    /// <param name="aAxesSummed"></param>
    /// <param name="bAxesSummed"></param>
    /// <param name="a">First input</param>
    /// <param name="b">Second input</param>
    new(aAxesSummed : int seq,
        bAxesSummed : int seq,
        [<Optional>] ?a : Symbol,
        [<Optional>] ?b : Symbol) = 
        let a = defaultArg a (new ImplicitVariable() :> Symbol)
        let b = defaultArg b (new ImplicitVariable() :> Symbol)
        let operatorArguments = 
            [
                "a", Input a
                "b", Input b
                "a_axes_summed", Parameter(Some(box aAxesSummed))
                "b_axes_summed", Parameter(Some(box bAxesSummed))
            ]
        new NpiTensordot(Arguments<Symbol>(operatorArguments))
    /// First input
    member __.A = operatorArguments.GetInput "a"
    /// Second input
    member __.B = operatorArguments.GetInput "b"
    /// 
    member __.AAxesSummed : int seq = match operatorArguments.GetParameter "a_axes_summed" with Some(v) -> unbox v | None -> failwithf "Required parameter a_axes_summed is missing"
    /// 
    member __.BAxesSummed : int seq = match operatorArguments.GetParameter "b_axes_summed" with Some(v) -> unbox v | None -> failwithf "Required parameter b_axes_summed is missing"
    /// <summary>Copy NpiTensordot instance with updated inputs/parameters.</summary>
    /// <param name="a">First input</param>
    /// <param name="b">Second input</param>
    /// <param name="aAxesSummed"></param>
    /// <param name="bAxesSummed"></param>
    member this.With([<Optional>] ?a : Symbol,
        [<Optional>] ?b : Symbol,
        [<Optional>] ?aAxesSummed : int seq,
        [<Optional>] ?bAxesSummed : int seq) = 
        let operatorArguments = 
            [
                a |> Option.map (fun x -> "a", Input x)
                b |> Option.map (fun x -> "b", Input x)
                aAxesSummed |> Option.map (fun x -> "a_axes_summed", Parameter(Some (box x)))
                bAxesSummed |> Option.map (fun x -> "b_axes_summed", Parameter(Some (box x)))
            ] |> List.choose id
        new NpiTensordot(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type NpiTensordotIntAxes private (operatorArguments) = 
    inherit SymbolOperator("_npi_tensordot_int_axes", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new NpiTensordotIntAxes(args)
    override this.WithArguments(args : Arguments<Symbol>) = new NpiTensordotIntAxes(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <param name="a">First input</param>
    /// <param name="b">Second input</param>
    /// <param name="axes"></param>
    new(a : Symbol,
        b : Symbol,
        axes : int) = 
        let operatorArguments = 
            [
                "a", Input a
                "b", Input b
                "axes", Parameter(Some(box axes))
            ]
        new NpiTensordotIntAxes(Arguments<Symbol>(operatorArguments))
    /// <param name="axes"></param>
    /// <param name="a">First input</param>
    /// <param name="b">Second input</param>
    new(axes : int,
        [<Optional>] ?a : Symbol,
        [<Optional>] ?b : Symbol) = 
        let a = defaultArg a (new ImplicitVariable() :> Symbol)
        let b = defaultArg b (new ImplicitVariable() :> Symbol)
        let operatorArguments = 
            [
                "a", Input a
                "b", Input b
                "axes", Parameter(Some(box axes))
            ]
        new NpiTensordotIntAxes(Arguments<Symbol>(operatorArguments))
    /// First input
    member __.A = operatorArguments.GetInput "a"
    /// Second input
    member __.B = operatorArguments.GetInput "b"
    /// 
    member __.Axes : int = match operatorArguments.GetParameter "axes" with Some(v) -> unbox v | None -> failwithf "Required parameter axes is missing"
    /// <summary>Copy NpiTensordotIntAxes instance with updated inputs/parameters.</summary>
    /// <param name="a">First input</param>
    /// <param name="b">Second input</param>
    /// <param name="axes"></param>
    member this.With([<Optional>] ?a : Symbol,
        [<Optional>] ?b : Symbol,
        [<Optional>] ?axes : int) = 
        let operatorArguments = 
            [
                a |> Option.map (fun x -> "a", Input x)
                b |> Option.map (fun x -> "b", Input x)
                axes |> Option.map (fun x -> "axes", Parameter(Some (box x)))
            ] |> List.choose id
        new NpiTensordotIntAxes(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type NpTrace private (operatorArguments) = 
    inherit SymbolOperator("_np_trace", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new NpTrace(args)
    override this.WithArguments(args : Arguments<Symbol>) = new NpTrace(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <summary>Computes the sum of the diagonal elements of a matrix.
    /// Input is a tensor *A* of dimension *n &gt;= 2*.
    /// 
    /// If *n=2*, we sum the diagonal elements. The result has shape ().
    /// 
    /// If *n&gt;2*, *trace* is performed separately on the matrix defined by *axis1* and *axis2* for all
    /// inputs (batch mode).
    /// 
    /// Examples::
    /// 
    ///    // Single matrix reduction
    ///    A = [[1.0, 1.0], [1.0, 7.0]]
    ///    trace(A) = 8.0
    /// 
    ///    // Batch matrix reduction
    ///    A = [[[1.0, 1.0], [1.0, 7.0]], [[3.0, 0], [0, 17.0]]]
    ///    trace(A) = [1.0, 18.0]
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\numpy\np_trace_op.cc:L75</summary>
    /// <param name="data">Input ndarray</param>
    /// <param name="offset">Offset of the diagonal from the main diagonal. Can be both positive and negative. Defaults to 0.</param>
    /// <param name="axis1">Axes to be used as the first axis of the 2-D sub-arrays from which the diagonals should be taken. Defaults to 0.</param>
    /// <param name="axis2">Axes to be used as the second axis of the 2-D sub-arrays from which the diagonals should be taken. Defaults to 1.</param>
    new([<Optional>] ?data : Symbol,
        [<Optional>] ?offset : int,
        [<Optional>] ?axis1 : int,
        [<Optional>] ?axis2 : int) = 
        let data = defaultArg data (new ImplicitVariable() :> Symbol)
        let operatorArguments = 
            [
                "data", Input data
                "offset", offset |> Option.map box |> Parameter
                "axis1", axis1 |> Option.map box |> Parameter
                "axis2", axis2 |> Option.map box |> Parameter
            ]
        new NpTrace(Arguments<Symbol>(operatorArguments))
    /// Default value for Offset
    /// Offset of the diagonal from the main diagonal. Can be both positive and negative. Defaults to 0.
    static member OffsetDefault : int = 0
    /// Default value for Axis1
    /// Axes to be used as the first axis of the 2-D sub-arrays from which the diagonals should be taken. Defaults to 0.
    static member Axis1Default : int = 0
    /// Default value for Axis2
    /// Axes to be used as the second axis of the 2-D sub-arrays from which the diagonals should be taken. Defaults to 1.
    static member Axis2Default : int = 1
    /// Input ndarray
    member __.Data = operatorArguments.GetInput "data"
    /// Offset of the diagonal from the main diagonal. Can be both positive and negative. Defaults to 0.
    member __.Offset = operatorArguments.GetParameter("offset", NpTrace.OffsetDefault)
    /// Axes to be used as the first axis of the 2-D sub-arrays from which the diagonals should be taken. Defaults to 0.
    member __.Axis1 = operatorArguments.GetParameter("axis1", NpTrace.Axis1Default)
    /// Axes to be used as the second axis of the 2-D sub-arrays from which the diagonals should be taken. Defaults to 1.
    member __.Axis2 = operatorArguments.GetParameter("axis2", NpTrace.Axis2Default)
    /// <summary>Copy NpTrace instance with updated inputs/parameters.</summary>
    /// <param name="data">Input ndarray</param>
    /// <param name="offset">Offset of the diagonal from the main diagonal. Can be both positive and negative. Defaults to 0.</param>
    /// <param name="axis1">Axes to be used as the first axis of the 2-D sub-arrays from which the diagonals should be taken. Defaults to 0.</param>
    /// <param name="axis2">Axes to be used as the second axis of the 2-D sub-arrays from which the diagonals should be taken. Defaults to 1.</param>
    member this.With([<Optional>] ?data : Symbol,
        [<Optional>] ?offset : int,
        [<Optional>] ?axis1 : int,
        [<Optional>] ?axis2 : int) = 
        let operatorArguments = 
            [
                data |> Option.map (fun x -> "data", Input x)
                offset |> Option.map (fun x -> "offset", Parameter(Some (box x)))
                axis1 |> Option.map (fun x -> "axis1", Parameter(Some (box x)))
                axis2 |> Option.map (fun x -> "axis2", Parameter(Some (box x)))
            ] |> List.choose id
        new NpTrace(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type NpiTril private (operatorArguments) = 
    inherit SymbolOperator("_npi_tril", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new NpiTril(args)
    override this.WithArguments(args : Arguments<Symbol>) = new NpiTril(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <param name="data">Input ndarray</param>
    /// <param name="k">Diagonal in question. The default is 0. Use k&gt;0 for diagonals above the main diagonal, and k&lt;0 for diagonals below the main diagonal. If input has shape (S0 S1) k must be between -S0 and S1</param>
    new([<Optional>] ?data : Symbol,
        [<Optional>] ?k : int) = 
        let data = defaultArg data (new ImplicitVariable() :> Symbol)
        let operatorArguments = 
            [
                "data", Input data
                "k", k |> Option.map box |> Parameter
            ]
        new NpiTril(Arguments<Symbol>(operatorArguments))
    /// Default value for K
    /// Diagonal in question. The default is 0. Use k&gt;0 for diagonals above the main diagonal, and k&lt;0 for diagonals below the main diagonal. If input has shape (S0 S1) k must be between -S0 and S1
    static member KDefault : int = 0
    /// Input ndarray
    member __.Data = operatorArguments.GetInput "data"
    /// Diagonal in question. The default is 0. Use k&gt;0 for diagonals above the main diagonal, and k&lt;0 for diagonals below the main diagonal. If input has shape (S0 S1) k must be between -S0 and S1
    member __.K = operatorArguments.GetParameter("k", NpiTril.KDefault)
    /// <summary>Copy NpiTril instance with updated inputs/parameters.</summary>
    /// <param name="data">Input ndarray</param>
    /// <param name="k">Diagonal in question. The default is 0. Use k&gt;0 for diagonals above the main diagonal, and k&lt;0 for diagonals below the main diagonal. If input has shape (S0 S1) k must be between -S0 and S1</param>
    member this.With([<Optional>] ?data : Symbol,
        [<Optional>] ?k : int) = 
        let operatorArguments = 
            [
                data |> Option.map (fun x -> "data", Input x)
                k |> Option.map (fun x -> "k", Parameter(Some (box x)))
            ] |> List.choose id
        new NpiTril(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type NpiTrueDivide private (operatorArguments) = 
    inherit SymbolOperator("_npi_true_divide", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new NpiTrueDivide(args)
    override this.WithArguments(args : Arguments<Symbol>) = new NpiTrueDivide(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <summary>
    /// Returns a true division of the inputs, element-wise.
    /// 
    /// It currently only supports dtype float16, float32, and float64.
    /// 
    /// Example::
    /// 
    ///    x = [[ 6.,  6.,  6.],
    ///         [ 6.,  6.,  6.]]
    /// 
    ///    y = [[ 2.],
    ///         [ 3.]]
    /// 
    ///    _true_divide(x, y) = [[ 3.,  3.,  3.],
    ///                          [ 2.,  2.,  2.]]
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\numpy\np_true_divide.cc:L74</summary>
    /// <param name="lhs">Dividend array</param>
    /// <param name="rhs">Divisor array</param>
    new([<Optional>] ?lhs : Symbol,
        [<Optional>] ?rhs : Symbol) = 
        let lhs = defaultArg lhs (new ImplicitVariable() :> Symbol)
        let rhs = defaultArg rhs (new ImplicitVariable() :> Symbol)
        let operatorArguments = 
            [
                "lhs", Input lhs
                "rhs", Input rhs
            ]
        new NpiTrueDivide(Arguments<Symbol>(operatorArguments))
    /// Dividend array
    member __.Lhs = operatorArguments.GetInput "lhs"
    /// Divisor array
    member __.Rhs = operatorArguments.GetInput "rhs"
    /// <summary>Copy NpiTrueDivide instance with updated inputs/parameters.</summary>
    /// <param name="lhs">Dividend array</param>
    /// <param name="rhs">Divisor array</param>
    member this.With([<Optional>] ?lhs : Symbol,
        [<Optional>] ?rhs : Symbol) = 
        let operatorArguments = 
            [
                lhs |> Option.map (fun x -> "lhs", Input x)
                rhs |> Option.map (fun x -> "rhs", Input x)
            ] |> List.choose id
        new NpiTrueDivide(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type NpiTrueDivideScalar private (operatorArguments) = 
    inherit SymbolOperator("_npi_true_divide_scalar", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new NpiTrueDivideScalar(args)
    override this.WithArguments(args : Arguments<Symbol>) = new NpiTrueDivideScalar(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <param name="data">source input</param>
    /// <param name="scalar">scalar input</param>
    new(data : Symbol,
        scalar : float) = 
        let operatorArguments = 
            [
                "data", Input data
                "scalar", Parameter(Some(box scalar))
            ]
        new NpiTrueDivideScalar(Arguments<Symbol>(operatorArguments))
    /// <param name="scalar">scalar input</param>
    /// <param name="data">source input</param>
    new(scalar : float,
        [<Optional>] ?data : Symbol) = 
        let data = defaultArg data (new ImplicitVariable() :> Symbol)
        let operatorArguments = 
            [
                "data", Input data
                "scalar", Parameter(Some(box scalar))
            ]
        new NpiTrueDivideScalar(Arguments<Symbol>(operatorArguments))
    /// source input
    member __.Data = operatorArguments.GetInput "data"
    /// scalar input
    member __.Scalar : float = match operatorArguments.GetParameter "scalar" with Some(v) -> unbox v | None -> failwithf "Required parameter scalar is missing"
    /// <summary>Copy NpiTrueDivideScalar instance with updated inputs/parameters.</summary>
    /// <param name="data">source input</param>
    /// <param name="scalar">scalar input</param>
    member this.With([<Optional>] ?data : Symbol,
        [<Optional>] ?scalar : float) = 
        let operatorArguments = 
            [
                data |> Option.map (fun x -> "data", Input x)
                scalar |> Option.map (fun x -> "scalar", Parameter(Some (box x)))
            ] |> List.choose id
        new NpiTrueDivideScalar(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type NpiRtrueDivideScalar private (operatorArguments) = 
    inherit SymbolOperator("_npi_rtrue_divide_scalar", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new NpiRtrueDivideScalar(args)
    override this.WithArguments(args : Arguments<Symbol>) = new NpiRtrueDivideScalar(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <param name="data">source input</param>
    /// <param name="scalar">scalar input</param>
    new(data : Symbol,
        scalar : float) = 
        let operatorArguments = 
            [
                "data", Input data
                "scalar", Parameter(Some(box scalar))
            ]
        new NpiRtrueDivideScalar(Arguments<Symbol>(operatorArguments))
    /// <param name="scalar">scalar input</param>
    /// <param name="data">source input</param>
    new(scalar : float,
        [<Optional>] ?data : Symbol) = 
        let data = defaultArg data (new ImplicitVariable() :> Symbol)
        let operatorArguments = 
            [
                "data", Input data
                "scalar", Parameter(Some(box scalar))
            ]
        new NpiRtrueDivideScalar(Arguments<Symbol>(operatorArguments))
    /// source input
    member __.Data = operatorArguments.GetInput "data"
    /// scalar input
    member __.Scalar : float = match operatorArguments.GetParameter "scalar" with Some(v) -> unbox v | None -> failwithf "Required parameter scalar is missing"
    /// <summary>Copy NpiRtrueDivideScalar instance with updated inputs/parameters.</summary>
    /// <param name="data">source input</param>
    /// <param name="scalar">scalar input</param>
    member this.With([<Optional>] ?data : Symbol,
        [<Optional>] ?scalar : float) = 
        let operatorArguments = 
            [
                data |> Option.map (fun x -> "data", Input x)
                scalar |> Option.map (fun x -> "scalar", Parameter(Some (box x)))
            ] |> List.choose id
        new NpiRtrueDivideScalar(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type NpiUnique private (operatorArguments) = 
    inherit SymbolOperator("_npi_unique", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new NpiUnique(args)
    override this.WithArguments(args : Arguments<Symbol>) = new NpiUnique(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <param name="data">The input array</param>
    /// <param name="returnIndex">If true, return the indices of the input.</param>
    /// <param name="returnInverse">If true, return the indices of the input.</param>
    /// <param name="returnCounts">If true, return the number of times each unique item appears in input.</param>
    /// <param name="axis">An integer that represents the axis to operator on.</param>
    new([<Optional>] ?data : Symbol,
        [<Optional>] ?returnIndex : bool,
        [<Optional>] ?returnInverse : bool,
        [<Optional>] ?returnCounts : bool,
        [<Optional>] ?axis : int) = 
        let data = defaultArg data (new ImplicitVariable() :> Symbol)
        let operatorArguments = 
            [
                "data", Input data
                "return_index", returnIndex |> Option.map box |> Parameter
                "return_inverse", returnInverse |> Option.map box |> Parameter
                "return_counts", returnCounts |> Option.map box |> Parameter
                "axis", axis |> Option.map box |> Parameter
            ]
        new NpiUnique(Arguments<Symbol>(operatorArguments))
    /// Default value for ReturnIndex
    /// If true, return the indices of the input.
    static member ReturnIndexDefault : bool = false
    /// Default value for ReturnInverse
    /// If true, return the indices of the input.
    static member ReturnInverseDefault : bool = false
    /// Default value for ReturnCounts
    /// If true, return the number of times each unique item appears in input.
    static member ReturnCountsDefault : bool = false
    /// Default value for Axis
    /// An integer that represents the axis to operator on.
    static member AxisDefault : int option = None
    /// The input array
    member __.Data = operatorArguments.GetInput "data"
    /// If true, return the indices of the input.
    member __.ReturnIndex = operatorArguments.GetParameter("return_index", NpiUnique.ReturnIndexDefault)
    /// If true, return the indices of the input.
    member __.ReturnInverse = operatorArguments.GetParameter("return_inverse", NpiUnique.ReturnInverseDefault)
    /// If true, return the number of times each unique item appears in input.
    member __.ReturnCounts = operatorArguments.GetParameter("return_counts", NpiUnique.ReturnCountsDefault)
    /// An integer that represents the axis to operator on.
    member __.Axis = operatorArguments.GetParameter("axis", NpiUnique.AxisDefault)
    /// <summary>Copy NpiUnique instance with updated inputs/parameters.</summary>
    /// <param name="data">The input array</param>
    /// <param name="returnIndex">If true, return the indices of the input.</param>
    /// <param name="returnInverse">If true, return the indices of the input.</param>
    /// <param name="returnCounts">If true, return the number of times each unique item appears in input.</param>
    /// <param name="axis">An integer that represents the axis to operator on.</param>
    member this.With([<Optional>] ?data : Symbol,
        [<Optional>] ?returnIndex : bool,
        [<Optional>] ?returnInverse : bool,
        [<Optional>] ?returnCounts : bool,
        [<Optional>] ?axis : int) = 
        let operatorArguments = 
            [
                data |> Option.map (fun x -> "data", Input x)
                returnIndex |> Option.map (fun x -> "return_index", Parameter(Some (box x)))
                returnInverse |> Option.map (fun x -> "return_inverse", Parameter(Some (box x)))
                returnCounts |> Option.map (fun x -> "return_counts", Parameter(Some (box x)))
                axis |> Option.map (fun x -> "axis", Parameter(Some (box x)))
            ] |> List.choose id
        new NpiUnique(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type NpiHanning private (operatorArguments) = 
    inherit SymbolOperator("_npi_hanning", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new NpiHanning(args)
    override this.WithArguments(args : Arguments<Symbol>) = new NpiHanning(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <summary>Return the Hanning window.The Hanning window is a taper formed by using a weighted cosine.</summary>
    /// <param name="M">Number of points in the output window. If zero or less, an empty array is returned.</param>
    /// <param name="dtype">Data-type of the returned array.</param>
    new(M : int,
        [<Optional>] ?dtype : IntOrFloatDType) = 
        let operatorArguments = 
            [
                "M", Parameter(Some(box M))
                "dtype", dtype |> Option.map box |> Parameter
            ]
        new NpiHanning(Arguments<Symbol>(operatorArguments))
    /// Default value for Dtype
    /// Data-type of the returned array.
    static member DtypeDefault : IntOrFloatDType = IntOrFloatDType.Float32
    /// Number of points in the output window. If zero or less, an empty array is returned.
    member __.M : int = match operatorArguments.GetParameter "M" with Some(v) -> unbox v | None -> failwithf "Required parameter M is missing"
    /// Data-type of the returned array.
    member __.Dtype = operatorArguments.GetParameter("dtype", NpiHanning.DtypeDefault)
    /// <summary>Copy NpiHanning instance with updated inputs/parameters.</summary>
    /// <param name="M">Number of points in the output window. If zero or less, an empty array is returned.</param>
    /// <param name="dtype">Data-type of the returned array.</param>
    member this.With([<Optional>] ?M : int,
        [<Optional>] ?dtype : IntOrFloatDType) = 
        let operatorArguments = 
            [
                M |> Option.map (fun x -> "M", Parameter(Some (box x)))
                dtype |> Option.map (fun x -> "dtype", Parameter(Some (box x)))
            ] |> List.choose id
        new NpiHanning(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type NpiHamming private (operatorArguments) = 
    inherit SymbolOperator("_npi_hamming", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new NpiHamming(args)
    override this.WithArguments(args : Arguments<Symbol>) = new NpiHamming(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <summary>Return the Hamming window.The Hamming window is a taper formed by using a weighted cosine.</summary>
    /// <param name="M">Number of points in the output window. If zero or less, an empty array is returned.</param>
    /// <param name="dtype">Data-type of the returned array.</param>
    new(M : int,
        [<Optional>] ?dtype : IntOrFloatDType) = 
        let operatorArguments = 
            [
                "M", Parameter(Some(box M))
                "dtype", dtype |> Option.map box |> Parameter
            ]
        new NpiHamming(Arguments<Symbol>(operatorArguments))
    /// Default value for Dtype
    /// Data-type of the returned array.
    static member DtypeDefault : IntOrFloatDType = IntOrFloatDType.Float32
    /// Number of points in the output window. If zero or less, an empty array is returned.
    member __.M : int = match operatorArguments.GetParameter "M" with Some(v) -> unbox v | None -> failwithf "Required parameter M is missing"
    /// Data-type of the returned array.
    member __.Dtype = operatorArguments.GetParameter("dtype", NpiHamming.DtypeDefault)
    /// <summary>Copy NpiHamming instance with updated inputs/parameters.</summary>
    /// <param name="M">Number of points in the output window. If zero or less, an empty array is returned.</param>
    /// <param name="dtype">Data-type of the returned array.</param>
    member this.With([<Optional>] ?M : int,
        [<Optional>] ?dtype : IntOrFloatDType) = 
        let operatorArguments = 
            [
                M |> Option.map (fun x -> "M", Parameter(Some (box x)))
                dtype |> Option.map (fun x -> "dtype", Parameter(Some (box x)))
            ] |> List.choose id
        new NpiHamming(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type NpiBlackman private (operatorArguments) = 
    inherit SymbolOperator("_npi_blackman", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new NpiBlackman(args)
    override this.WithArguments(args : Arguments<Symbol>) = new NpiBlackman(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <summary>Return the Blackman window.The Blackman window is a taper formed by using a weighted cosine.</summary>
    /// <param name="M">Number of points in the output window. If zero or less, an empty array is returned.</param>
    /// <param name="dtype">Data-type of the returned array.</param>
    new(M : int,
        [<Optional>] ?dtype : IntOrFloatDType) = 
        let operatorArguments = 
            [
                "M", Parameter(Some(box M))
                "dtype", dtype |> Option.map box |> Parameter
            ]
        new NpiBlackman(Arguments<Symbol>(operatorArguments))
    /// Default value for Dtype
    /// Data-type of the returned array.
    static member DtypeDefault : IntOrFloatDType = IntOrFloatDType.Float32
    /// Number of points in the output window. If zero or less, an empty array is returned.
    member __.M : int = match operatorArguments.GetParameter "M" with Some(v) -> unbox v | None -> failwithf "Required parameter M is missing"
    /// Data-type of the returned array.
    member __.Dtype = operatorArguments.GetParameter("dtype", NpiBlackman.DtypeDefault)
    /// <summary>Copy NpiBlackman instance with updated inputs/parameters.</summary>
    /// <param name="M">Number of points in the output window. If zero or less, an empty array is returned.</param>
    /// <param name="dtype">Data-type of the returned array.</param>
    member this.With([<Optional>] ?M : int,
        [<Optional>] ?dtype : IntOrFloatDType) = 
        let operatorArguments = 
            [
                M |> Option.map (fun x -> "M", Parameter(Some (box x)))
                dtype |> Option.map (fun x -> "dtype", Parameter(Some (box x)))
            ] |> List.choose id
        new NpiBlackman(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type NpiChoice private (operatorArguments) = 
    inherit SymbolOperator("_npi_choice", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new NpiChoice(args)
    override this.WithArguments(args : Arguments<Symbol>) = new NpiChoice(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <summary>random choice</summary>
    /// <param name="input1">Source input</param>
    /// <param name="input2">Source input</param>
    /// <param name="a"></param>
    /// <param name="size"></param>
    /// <param name="replace"></param>
    /// <param name="weighted"></param>
    new(input1 : Symbol,
        input2 : Symbol,
        a : int64,
        size : int seq,
        [<Optional>] ?replace : bool,
        [<Optional>] ?weighted : bool) = 
        let operatorArguments = 
            [
                "input1", Input input1
                "input2", Input input2
                "a", Parameter(Some(box a))
                "size", Parameter(Some(box size))
                "replace", replace |> Option.map box |> Parameter
                "weighted", weighted |> Option.map box |> Parameter
            ]
        new NpiChoice(Arguments<Symbol>(operatorArguments))
    /// <summary>random choice</summary>
    /// <param name="a"></param>
    /// <param name="size"></param>
    /// <param name="input1">Source input</param>
    /// <param name="input2">Source input</param>
    /// <param name="replace"></param>
    /// <param name="weighted"></param>
    new(a : int64,
        size : int seq,
        [<Optional>] ?input1 : Symbol,
        [<Optional>] ?input2 : Symbol,
        [<Optional>] ?replace : bool,
        [<Optional>] ?weighted : bool) = 
        let input1 = defaultArg input1 (new ImplicitVariable() :> Symbol)
        let input2 = defaultArg input2 (new ImplicitVariable() :> Symbol)
        let operatorArguments = 
            [
                "input1", Input input1
                "input2", Input input2
                "a", Parameter(Some(box a))
                "size", Parameter(Some(box size))
                "replace", replace |> Option.map box |> Parameter
                "weighted", weighted |> Option.map box |> Parameter
            ]
        new NpiChoice(Arguments<Symbol>(operatorArguments))
    /// Default value for Replace
    /// 
    static member ReplaceDefault : bool = true
    /// Default value for Weighted
    /// 
    static member WeightedDefault : bool = false
    /// Source input
    member __.Input1 = operatorArguments.GetInput "input1"
    /// Source input
    member __.Input2 = operatorArguments.GetInput "input2"
    /// 
    member __.A : int64 = match operatorArguments.GetParameter "a" with Some(v) -> unbox v | None -> failwithf "Required parameter a is missing"
    /// 
    member __.Size : int seq = match operatorArguments.GetParameter "size" with Some(v) -> unbox v | None -> failwithf "Required parameter size is missing"
    /// 
    member __.Replace = operatorArguments.GetParameter("replace", NpiChoice.ReplaceDefault)
    /// 
    member __.Weighted = operatorArguments.GetParameter("weighted", NpiChoice.WeightedDefault)
    /// <summary>Copy NpiChoice instance with updated inputs/parameters.</summary>
    /// <param name="input1">Source input</param>
    /// <param name="input2">Source input</param>
    /// <param name="a"></param>
    /// <param name="size"></param>
    /// <param name="replace"></param>
    /// <param name="weighted"></param>
    member this.With([<Optional>] ?input1 : Symbol,
        [<Optional>] ?input2 : Symbol,
        [<Optional>] ?a : int64,
        [<Optional>] ?size : int seq,
        [<Optional>] ?replace : bool,
        [<Optional>] ?weighted : bool) = 
        let operatorArguments = 
            [
                input1 |> Option.map (fun x -> "input1", Input x)
                input2 |> Option.map (fun x -> "input2", Input x)
                a |> Option.map (fun x -> "a", Parameter(Some (box x)))
                size |> Option.map (fun x -> "size", Parameter(Some (box x)))
                replace |> Option.map (fun x -> "replace", Parameter(Some (box x)))
                weighted |> Option.map (fun x -> "weighted", Parameter(Some (box x)))
            ] |> List.choose id
        new NpiChoice(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type NpiMultinomial private (operatorArguments) = 
    inherit SymbolOperator("_npi_multinomial", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new NpiMultinomial(args)
    override this.WithArguments(args : Arguments<Symbol>) = new NpiMultinomial(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <summary>Draw samples from a multinomial distribution. &quot;
    /// &quot;The multinomial distribution is a multivariate generalisation of the binomial distribution. &quot;
    /// &quot;Take an experiment with one of p possible outcomes. &quot;
    /// &quot;An example of such an experiment is throwing a dice, where the outcome can be 1 through 6. &quot;
    /// &quot;Each sample drawn from the distribution represents n such experiments. &quot;
    /// &quot;Its values, X_i = [X_0, X_1, ..., X_p], represent the number of times the outcome was i.
    /// </summary>
    /// <param name="a">Source input</param>
    /// <param name="n">Number of experiments.</param>
    /// <param name="pvals">Probabilities of each of the p different outcomes. These should sum to 1 (however, the last element is always assumed to account for the remaining probability, as long as sum(pvals[:-1]) &lt;= 1)Note that this is for internal usage only. This operator will only have either input mx.ndarray or this list of pvals</param>
    /// <param name="size">Output shape. If the given shape is, e.g., (m, n, k), then m * n * k samples are drawn. Default is None, in which case a single value is returned.</param>
    new(a : Symbol,
        n : int,
        pvals : double seq,
        [<Optional>] ?size : int seq) = 
        let operatorArguments = 
            [
                "a", Input a
                "n", Parameter(Some(box n))
                "pvals", Parameter(Some(box pvals))
                "size", size |> Option.map box |> Parameter
            ]
        new NpiMultinomial(Arguments<Symbol>(operatorArguments))
    /// <summary>Draw samples from a multinomial distribution. &quot;
    /// &quot;The multinomial distribution is a multivariate generalisation of the binomial distribution. &quot;
    /// &quot;Take an experiment with one of p possible outcomes. &quot;
    /// &quot;An example of such an experiment is throwing a dice, where the outcome can be 1 through 6. &quot;
    /// &quot;Each sample drawn from the distribution represents n such experiments. &quot;
    /// &quot;Its values, X_i = [X_0, X_1, ..., X_p], represent the number of times the outcome was i.
    /// </summary>
    /// <param name="n">Number of experiments.</param>
    /// <param name="pvals">Probabilities of each of the p different outcomes. These should sum to 1 (however, the last element is always assumed to account for the remaining probability, as long as sum(pvals[:-1]) &lt;= 1)Note that this is for internal usage only. This operator will only have either input mx.ndarray or this list of pvals</param>
    /// <param name="a">Source input</param>
    /// <param name="size">Output shape. If the given shape is, e.g., (m, n, k), then m * n * k samples are drawn. Default is None, in which case a single value is returned.</param>
    new(n : int,
        pvals : double seq,
        [<Optional>] ?a : Symbol,
        [<Optional>] ?size : int seq) = 
        let a = defaultArg a (new ImplicitVariable() :> Symbol)
        let operatorArguments = 
            [
                "a", Input a
                "n", Parameter(Some(box n))
                "pvals", Parameter(Some(box pvals))
                "size", size |> Option.map box |> Parameter
            ]
        new NpiMultinomial(Arguments<Symbol>(operatorArguments))
    /// Default value for Size
    /// Output shape. If the given shape is, e.g., (m, n, k), then m * n * k samples are drawn. Default is None, in which case a single value is returned.
    static member SizeDefault : int [] option = None
    /// Source input
    member __.A = operatorArguments.GetInput "a"
    /// Number of experiments.
    member __.N : int = match operatorArguments.GetParameter "n" with Some(v) -> unbox v | None -> failwithf "Required parameter n is missing"
    /// Probabilities of each of the p different outcomes. These should sum to 1 (however, the last element is always assumed to account for the remaining probability, as long as sum(pvals[:-1]) &lt;= 1)Note that this is for internal usage only. This operator will only have either input mx.ndarray or this list of pvals
    member __.Pvals : double seq = match operatorArguments.GetParameter "pvals" with Some(v) -> unbox v | None -> failwithf "Required parameter pvals is missing"
    /// Output shape. If the given shape is, e.g., (m, n, k), then m * n * k samples are drawn. Default is None, in which case a single value is returned.
    member __.Size = operatorArguments.GetParameter("size", NpiMultinomial.SizeDefault)
    /// <summary>Copy NpiMultinomial instance with updated inputs/parameters.</summary>
    /// <param name="a">Source input</param>
    /// <param name="n">Number of experiments.</param>
    /// <param name="pvals">Probabilities of each of the p different outcomes. These should sum to 1 (however, the last element is always assumed to account for the remaining probability, as long as sum(pvals[:-1]) &lt;= 1)Note that this is for internal usage only. This operator will only have either input mx.ndarray or this list of pvals</param>
    /// <param name="size">Output shape. If the given shape is, e.g., (m, n, k), then m * n * k samples are drawn. Default is None, in which case a single value is returned.</param>
    member this.With([<Optional>] ?a : Symbol,
        [<Optional>] ?n : int,
        [<Optional>] ?pvals : double seq,
        [<Optional>] ?size : int seq) = 
        let operatorArguments = 
            [
                a |> Option.map (fun x -> "a", Input x)
                n |> Option.map (fun x -> "n", Parameter(Some (box x)))
                pvals |> Option.map (fun x -> "pvals", Parameter(Some (box x)))
                size |> Option.map (fun x -> "size", Parameter(Some (box x)))
            ] |> List.choose id
        new NpiMultinomial(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type NpiNormal private (operatorArguments) = 
    inherit SymbolOperator("_npi_normal", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new NpiNormal(args)
    override this.WithArguments(args : Arguments<Symbol>) = new NpiNormal(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <summary>Numpy behavior normal</summary>
    /// <param name="input1">Source input</param>
    /// <param name="input2">Source input</param>
    /// <param name="loc"></param>
    /// <param name="scale"></param>
    /// <param name="size">Output shape. If the given shape is, e.g., (m, n, k), then m * n * k samples are drawn. Default is None, in which case a single value is returned.</param>
    /// <param name="dtype">DType of the output in case this can&#39;t be inferred. Defaults to float32 if not defined (dtype=None).</param>
    new([<Optional>] ?input1 : Symbol,
        [<Optional>] ?input2 : Symbol,
        [<Optional>] ?loc : float,
        [<Optional>] ?scale : float,
        [<Optional>] ?size : int seq,
        [<Optional>] ?dtype : FloatDType) = 
        let input1 = defaultArg input1 (new ImplicitVariable() :> Symbol)
        let input2 = defaultArg input2 (new ImplicitVariable() :> Symbol)
        let operatorArguments = 
            [
                "input1", Input input1
                "input2", Input input2
                "loc", loc |> Option.map box |> Parameter
                "scale", scale |> Option.map box |> Parameter
                "size", size |> Option.map box |> Parameter
                "dtype", dtype |> Option.map box |> Parameter
            ]
        new NpiNormal(Arguments<Symbol>(operatorArguments))
    /// Default value for Loc
    /// 
    static member LocDefault : double option = None
    /// Default value for Scale
    /// 
    static member ScaleDefault : double option = None
    /// Default value for Size
    /// Output shape. If the given shape is, e.g., (m, n, k), then m * n * k samples are drawn. Default is None, in which case a single value is returned.
    static member SizeDefault : int [] option = None
    /// Default value for Dtype
    /// DType of the output in case this can&#39;t be inferred. Defaults to float32 if not defined (dtype=None).
    static member DtypeDefault : FloatDType = FloatDType.Float32
    /// Source input
    member __.Input1 = operatorArguments.GetInput "input1"
    /// Source input
    member __.Input2 = operatorArguments.GetInput "input2"
    /// 
    member __.Loc = operatorArguments.GetParameter("loc", NpiNormal.LocDefault)
    /// 
    member __.Scale = operatorArguments.GetParameter("scale", NpiNormal.ScaleDefault)
    /// Output shape. If the given shape is, e.g., (m, n, k), then m * n * k samples are drawn. Default is None, in which case a single value is returned.
    member __.Size = operatorArguments.GetParameter("size", NpiNormal.SizeDefault)
    /// DType of the output in case this can&#39;t be inferred. Defaults to float32 if not defined (dtype=None).
    member __.Dtype = operatorArguments.GetParameter("dtype", NpiNormal.DtypeDefault)
    /// <summary>Copy NpiNormal instance with updated inputs/parameters.</summary>
    /// <param name="input1">Source input</param>
    /// <param name="input2">Source input</param>
    /// <param name="loc"></param>
    /// <param name="scale"></param>
    /// <param name="size">Output shape. If the given shape is, e.g., (m, n, k), then m * n * k samples are drawn. Default is None, in which case a single value is returned.</param>
    /// <param name="dtype">DType of the output in case this can&#39;t be inferred. Defaults to float32 if not defined (dtype=None).</param>
    member this.With([<Optional>] ?input1 : Symbol,
        [<Optional>] ?input2 : Symbol,
        [<Optional>] ?loc : float,
        [<Optional>] ?scale : float,
        [<Optional>] ?size : int seq,
        [<Optional>] ?dtype : FloatDType) = 
        let operatorArguments = 
            [
                input1 |> Option.map (fun x -> "input1", Input x)
                input2 |> Option.map (fun x -> "input2", Input x)
                loc |> Option.map (fun x -> "loc", Parameter(Some (box x)))
                scale |> Option.map (fun x -> "scale", Parameter(Some (box x)))
                size |> Option.map (fun x -> "size", Parameter(Some (box x)))
                dtype |> Option.map (fun x -> "dtype", Parameter(Some (box x)))
            ] |> List.choose id
        new NpiNormal(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type NpiUniform private (operatorArguments) = 
    inherit SymbolOperator("_npi_uniform", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new NpiUniform(args)
    override this.WithArguments(args : Arguments<Symbol>) = new NpiUniform(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <summary>numpy behavior uniform</summary>
    /// <param name="input1">Source input</param>
    /// <param name="input2">Source input</param>
    /// <param name="low"></param>
    /// <param name="high"></param>
    /// <param name="size">Output shape. If the given shape is, e.g., (m, n, k), then m * n * k samples are drawn. Default is None, in which case a single value is returned.</param>
    /// <param name="dtype">DType of the output in case this can&#39;t be inferred. Defaults to float32 if not defined (dtype=None).</param>
    new([<Optional>] ?input1 : Symbol,
        [<Optional>] ?input2 : Symbol,
        [<Optional>] ?low : float,
        [<Optional>] ?high : float,
        [<Optional>] ?size : int seq,
        [<Optional>] ?dtype : FloatDType) = 
        let input1 = defaultArg input1 (new ImplicitVariable() :> Symbol)
        let input2 = defaultArg input2 (new ImplicitVariable() :> Symbol)
        let operatorArguments = 
            [
                "input1", Input input1
                "input2", Input input2
                "low", low |> Option.map box |> Parameter
                "high", high |> Option.map box |> Parameter
                "size", size |> Option.map box |> Parameter
                "dtype", dtype |> Option.map box |> Parameter
            ]
        new NpiUniform(Arguments<Symbol>(operatorArguments))
    /// Default value for Low
    /// 
    static member LowDefault : double option = None
    /// Default value for High
    /// 
    static member HighDefault : double option = None
    /// Default value for Size
    /// Output shape. If the given shape is, e.g., (m, n, k), then m * n * k samples are drawn. Default is None, in which case a single value is returned.
    static member SizeDefault : int [] option = None
    /// Default value for Dtype
    /// DType of the output in case this can&#39;t be inferred. Defaults to float32 if not defined (dtype=None).
    static member DtypeDefault : FloatDType = FloatDType.Float32
    /// Source input
    member __.Input1 = operatorArguments.GetInput "input1"
    /// Source input
    member __.Input2 = operatorArguments.GetInput "input2"
    /// 
    member __.Low = operatorArguments.GetParameter("low", NpiUniform.LowDefault)
    /// 
    member __.High = operatorArguments.GetParameter("high", NpiUniform.HighDefault)
    /// Output shape. If the given shape is, e.g., (m, n, k), then m * n * k samples are drawn. Default is None, in which case a single value is returned.
    member __.Size = operatorArguments.GetParameter("size", NpiUniform.SizeDefault)
    /// DType of the output in case this can&#39;t be inferred. Defaults to float32 if not defined (dtype=None).
    member __.Dtype = operatorArguments.GetParameter("dtype", NpiUniform.DtypeDefault)
    /// <summary>Copy NpiUniform instance with updated inputs/parameters.</summary>
    /// <param name="input1">Source input</param>
    /// <param name="input2">Source input</param>
    /// <param name="low"></param>
    /// <param name="high"></param>
    /// <param name="size">Output shape. If the given shape is, e.g., (m, n, k), then m * n * k samples are drawn. Default is None, in which case a single value is returned.</param>
    /// <param name="dtype">DType of the output in case this can&#39;t be inferred. Defaults to float32 if not defined (dtype=None).</param>
    member this.With([<Optional>] ?input1 : Symbol,
        [<Optional>] ?input2 : Symbol,
        [<Optional>] ?low : float,
        [<Optional>] ?high : float,
        [<Optional>] ?size : int seq,
        [<Optional>] ?dtype : FloatDType) = 
        let operatorArguments = 
            [
                input1 |> Option.map (fun x -> "input1", Input x)
                input2 |> Option.map (fun x -> "input2", Input x)
                low |> Option.map (fun x -> "low", Parameter(Some (box x)))
                high |> Option.map (fun x -> "high", Parameter(Some (box x)))
                size |> Option.map (fun x -> "size", Parameter(Some (box x)))
                dtype |> Option.map (fun x -> "dtype", Parameter(Some (box x)))
            ] |> List.choose id
        new NpiUniform(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type SignsgdUpdate private (operatorArguments) = 
    inherit SymbolOperator("signsgd_update", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new SignsgdUpdate(args)
    override this.WithArguments(args : Arguments<Symbol>) = new SignsgdUpdate(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <summary>Update function for SignSGD optimizer.
    /// 
    /// .. math::
    /// 
    ///  g_t = \nabla J(W_{t-1})\\
    ///  W_t = W_{t-1} - \eta_t \text{sign}(g_t)
    /// 
    /// It updates the weights using::
    /// 
    ///  weight = weight - learning_rate * sign(gradient)
    /// 
    /// .. note::
    ///    - sparse ndarray not supported for this optimizer yet.
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\optimizer_op.cc:L61</summary>
    /// <param name="weight">Weight</param>
    /// <param name="grad">Gradient</param>
    /// <param name="lr">Learning rate</param>
    /// <param name="wd">Weight decay augments the objective function with a regularization term that penalizes large weights. The penalty scales with the square of the magnitude of each weight.</param>
    /// <param name="rescaleGrad">Rescale gradient to grad = rescale_grad*grad.</param>
    /// <param name="clipGradient">Clip gradient to the range of [-clip_gradient, clip_gradient] If clip_gradient &lt;= 0, gradient clipping is turned off. grad = max(min(grad, clip_gradient), -clip_gradient).</param>
    new(weight : Symbol,
        grad : Symbol,
        lr : float,
        [<Optional>] ?wd : float,
        [<Optional>] ?rescaleGrad : float,
        [<Optional>] ?clipGradient : float) = 
        let operatorArguments = 
            [
                "weight", Input weight
                "grad", Input grad
                "lr", Parameter(Some(box lr))
                "wd", wd |> Option.map box |> Parameter
                "rescale_grad", rescaleGrad |> Option.map box |> Parameter
                "clip_gradient", clipGradient |> Option.map box |> Parameter
            ]
        new SignsgdUpdate(Arguments<Symbol>(operatorArguments))
    /// <summary>Update function for SignSGD optimizer.
    /// 
    /// .. math::
    /// 
    ///  g_t = \nabla J(W_{t-1})\\
    ///  W_t = W_{t-1} - \eta_t \text{sign}(g_t)
    /// 
    /// It updates the weights using::
    /// 
    ///  weight = weight - learning_rate * sign(gradient)
    /// 
    /// .. note::
    ///    - sparse ndarray not supported for this optimizer yet.
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\optimizer_op.cc:L61</summary>
    /// <param name="lr">Learning rate</param>
    /// <param name="weight">Weight</param>
    /// <param name="grad">Gradient</param>
    /// <param name="wd">Weight decay augments the objective function with a regularization term that penalizes large weights. The penalty scales with the square of the magnitude of each weight.</param>
    /// <param name="rescaleGrad">Rescale gradient to grad = rescale_grad*grad.</param>
    /// <param name="clipGradient">Clip gradient to the range of [-clip_gradient, clip_gradient] If clip_gradient &lt;= 0, gradient clipping is turned off. grad = max(min(grad, clip_gradient), -clip_gradient).</param>
    new(lr : float,
        [<Optional>] ?weight : Symbol,
        [<Optional>] ?grad : Symbol,
        [<Optional>] ?wd : float,
        [<Optional>] ?rescaleGrad : float,
        [<Optional>] ?clipGradient : float) = 
        let weight = defaultArg weight (new ImplicitVariable() :> Symbol)
        let grad = defaultArg grad (new ImplicitVariable() :> Symbol)
        let operatorArguments = 
            [
                "weight", Input weight
                "grad", Input grad
                "lr", Parameter(Some(box lr))
                "wd", wd |> Option.map box |> Parameter
                "rescale_grad", rescaleGrad |> Option.map box |> Parameter
                "clip_gradient", clipGradient |> Option.map box |> Parameter
            ]
        new SignsgdUpdate(Arguments<Symbol>(operatorArguments))
    /// Default value for Wd
    /// Weight decay augments the objective function with a regularization term that penalizes large weights. The penalty scales with the square of the magnitude of each weight.
    static member WdDefault : double = 0.0
    /// Default value for RescaleGrad
    /// Rescale gradient to grad = rescale_grad*grad.
    static member RescaleGradDefault : double = 1.0
    /// Default value for ClipGradient
    /// Clip gradient to the range of [-clip_gradient, clip_gradient] If clip_gradient &lt;= 0, gradient clipping is turned off. grad = max(min(grad, clip_gradient), -clip_gradient).
    static member ClipGradientDefault : double = -1.0
    /// Weight
    member __.Weight = operatorArguments.GetInput "weight"
    /// Gradient
    member __.Grad = operatorArguments.GetInput "grad"
    /// Learning rate
    member __.Lr : float = match operatorArguments.GetParameter "lr" with Some(v) -> unbox v | None -> failwithf "Required parameter lr is missing"
    /// Weight decay augments the objective function with a regularization term that penalizes large weights. The penalty scales with the square of the magnitude of each weight.
    member __.Wd = operatorArguments.GetParameter("wd", SignsgdUpdate.WdDefault)
    /// Rescale gradient to grad = rescale_grad*grad.
    member __.RescaleGrad = operatorArguments.GetParameter("rescale_grad", SignsgdUpdate.RescaleGradDefault)
    /// Clip gradient to the range of [-clip_gradient, clip_gradient] If clip_gradient &lt;= 0, gradient clipping is turned off. grad = max(min(grad, clip_gradient), -clip_gradient).
    member __.ClipGradient = operatorArguments.GetParameter("clip_gradient", SignsgdUpdate.ClipGradientDefault)
    /// <summary>Copy SignsgdUpdate instance with updated inputs/parameters.</summary>
    /// <param name="weight">Weight</param>
    /// <param name="grad">Gradient</param>
    /// <param name="lr">Learning rate</param>
    /// <param name="wd">Weight decay augments the objective function with a regularization term that penalizes large weights. The penalty scales with the square of the magnitude of each weight.</param>
    /// <param name="rescaleGrad">Rescale gradient to grad = rescale_grad*grad.</param>
    /// <param name="clipGradient">Clip gradient to the range of [-clip_gradient, clip_gradient] If clip_gradient &lt;= 0, gradient clipping is turned off. grad = max(min(grad, clip_gradient), -clip_gradient).</param>
    member this.With([<Optional>] ?weight : Symbol,
        [<Optional>] ?grad : Symbol,
        [<Optional>] ?lr : float,
        [<Optional>] ?wd : float,
        [<Optional>] ?rescaleGrad : float,
        [<Optional>] ?clipGradient : float) = 
        let operatorArguments = 
            [
                weight |> Option.map (fun x -> "weight", Input x)
                grad |> Option.map (fun x -> "grad", Input x)
                lr |> Option.map (fun x -> "lr", Parameter(Some (box x)))
                wd |> Option.map (fun x -> "wd", Parameter(Some (box x)))
                rescaleGrad |> Option.map (fun x -> "rescale_grad", Parameter(Some (box x)))
                clipGradient |> Option.map (fun x -> "clip_gradient", Parameter(Some (box x)))
            ] |> List.choose id
        new SignsgdUpdate(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type SignumUpdate private (operatorArguments) = 
    inherit SymbolOperator("signum_update", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new SignumUpdate(args)
    override this.WithArguments(args : Arguments<Symbol>) = new SignumUpdate(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <summary>SIGN momentUM (Signum) optimizer.
    /// 
    /// .. math::
    /// 
    ///  g_t = \nabla J(W_{t-1})\\
    ///  m_t = \beta m_{t-1} + (1 - \beta) g_t\\
    ///  W_t = W_{t-1} - \eta_t \text{sign}(m_t)
    /// 
    /// It updates the weights using::
    ///  state = momentum * state + (1-momentum) * gradient
    ///  weight = weight - learning_rate * sign(state)
    /// 
    /// Where the parameter ``momentum`` is the decay rate of momentum estimates at each epoch.
    /// 
    /// .. note::
    ///    - sparse ndarray not supported for this optimizer yet.
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\optimizer_op.cc:L90</summary>
    /// <param name="weight">Weight</param>
    /// <param name="grad">Gradient</param>
    /// <param name="mom">Momentum</param>
    /// <param name="lr">Learning rate</param>
    /// <param name="momentum">The decay rate of momentum estimates at each epoch.</param>
    /// <param name="wd">Weight decay augments the objective function with a regularization term that penalizes large weights. The penalty scales with the square of the magnitude of each weight.</param>
    /// <param name="rescaleGrad">Rescale gradient to grad = rescale_grad*grad.</param>
    /// <param name="clipGradient">Clip gradient to the range of [-clip_gradient, clip_gradient] If clip_gradient &lt;= 0, gradient clipping is turned off. grad = max(min(grad, clip_gradient), -clip_gradient).</param>
    /// <param name="wdLh">The amount of weight decay that does not go into gradient/momentum calculationsotherwise do weight decay algorithmically only.</param>
    new(weight : Symbol,
        grad : Symbol,
        mom : Symbol,
        lr : float,
        [<Optional>] ?momentum : float,
        [<Optional>] ?wd : float,
        [<Optional>] ?rescaleGrad : float,
        [<Optional>] ?clipGradient : float,
        [<Optional>] ?wdLh : float) = 
        let operatorArguments = 
            [
                "weight", Input weight
                "grad", Input grad
                "mom", Input mom
                "lr", Parameter(Some(box lr))
                "momentum", momentum |> Option.map box |> Parameter
                "wd", wd |> Option.map box |> Parameter
                "rescale_grad", rescaleGrad |> Option.map box |> Parameter
                "clip_gradient", clipGradient |> Option.map box |> Parameter
                "wd_lh", wdLh |> Option.map box |> Parameter
            ]
        new SignumUpdate(Arguments<Symbol>(operatorArguments))
    /// <summary>SIGN momentUM (Signum) optimizer.
    /// 
    /// .. math::
    /// 
    ///  g_t = \nabla J(W_{t-1})\\
    ///  m_t = \beta m_{t-1} + (1 - \beta) g_t\\
    ///  W_t = W_{t-1} - \eta_t \text{sign}(m_t)
    /// 
    /// It updates the weights using::
    ///  state = momentum * state + (1-momentum) * gradient
    ///  weight = weight - learning_rate * sign(state)
    /// 
    /// Where the parameter ``momentum`` is the decay rate of momentum estimates at each epoch.
    /// 
    /// .. note::
    ///    - sparse ndarray not supported for this optimizer yet.
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\optimizer_op.cc:L90</summary>
    /// <param name="lr">Learning rate</param>
    /// <param name="weight">Weight</param>
    /// <param name="grad">Gradient</param>
    /// <param name="mom">Momentum</param>
    /// <param name="momentum">The decay rate of momentum estimates at each epoch.</param>
    /// <param name="wd">Weight decay augments the objective function with a regularization term that penalizes large weights. The penalty scales with the square of the magnitude of each weight.</param>
    /// <param name="rescaleGrad">Rescale gradient to grad = rescale_grad*grad.</param>
    /// <param name="clipGradient">Clip gradient to the range of [-clip_gradient, clip_gradient] If clip_gradient &lt;= 0, gradient clipping is turned off. grad = max(min(grad, clip_gradient), -clip_gradient).</param>
    /// <param name="wdLh">The amount of weight decay that does not go into gradient/momentum calculationsotherwise do weight decay algorithmically only.</param>
    new(lr : float,
        [<Optional>] ?weight : Symbol,
        [<Optional>] ?grad : Symbol,
        [<Optional>] ?mom : Symbol,
        [<Optional>] ?momentum : float,
        [<Optional>] ?wd : float,
        [<Optional>] ?rescaleGrad : float,
        [<Optional>] ?clipGradient : float,
        [<Optional>] ?wdLh : float) = 
        let weight = defaultArg weight (new ImplicitVariable() :> Symbol)
        let grad = defaultArg grad (new ImplicitVariable() :> Symbol)
        let mom = defaultArg mom (new ImplicitVariable() :> Symbol)
        let operatorArguments = 
            [
                "weight", Input weight
                "grad", Input grad
                "mom", Input mom
                "lr", Parameter(Some(box lr))
                "momentum", momentum |> Option.map box |> Parameter
                "wd", wd |> Option.map box |> Parameter
                "rescale_grad", rescaleGrad |> Option.map box |> Parameter
                "clip_gradient", clipGradient |> Option.map box |> Parameter
                "wd_lh", wdLh |> Option.map box |> Parameter
            ]
        new SignumUpdate(Arguments<Symbol>(operatorArguments))
    /// Default value for Momentum
    /// The decay rate of momentum estimates at each epoch.
    static member MomentumDefault : double = 0.0
    /// Default value for Wd
    /// Weight decay augments the objective function with a regularization term that penalizes large weights. The penalty scales with the square of the magnitude of each weight.
    static member WdDefault : double = 0.0
    /// Default value for RescaleGrad
    /// Rescale gradient to grad = rescale_grad*grad.
    static member RescaleGradDefault : double = 1.0
    /// Default value for ClipGradient
    /// Clip gradient to the range of [-clip_gradient, clip_gradient] If clip_gradient &lt;= 0, gradient clipping is turned off. grad = max(min(grad, clip_gradient), -clip_gradient).
    static member ClipGradientDefault : double = -1.0
    /// Default value for WdLh
    /// The amount of weight decay that does not go into gradient/momentum calculationsotherwise do weight decay algorithmically only.
    static member WdLhDefault : double = 0.0
    /// Weight
    member __.Weight = operatorArguments.GetInput "weight"
    /// Gradient
    member __.Grad = operatorArguments.GetInput "grad"
    /// Momentum
    member __.Mom = operatorArguments.GetInput "mom"
    /// Learning rate
    member __.Lr : float = match operatorArguments.GetParameter "lr" with Some(v) -> unbox v | None -> failwithf "Required parameter lr is missing"
    /// The decay rate of momentum estimates at each epoch.
    member __.Momentum = operatorArguments.GetParameter("momentum", SignumUpdate.MomentumDefault)
    /// Weight decay augments the objective function with a regularization term that penalizes large weights. The penalty scales with the square of the magnitude of each weight.
    member __.Wd = operatorArguments.GetParameter("wd", SignumUpdate.WdDefault)
    /// Rescale gradient to grad = rescale_grad*grad.
    member __.RescaleGrad = operatorArguments.GetParameter("rescale_grad", SignumUpdate.RescaleGradDefault)
    /// Clip gradient to the range of [-clip_gradient, clip_gradient] If clip_gradient &lt;= 0, gradient clipping is turned off. grad = max(min(grad, clip_gradient), -clip_gradient).
    member __.ClipGradient = operatorArguments.GetParameter("clip_gradient", SignumUpdate.ClipGradientDefault)
    /// The amount of weight decay that does not go into gradient/momentum calculationsotherwise do weight decay algorithmically only.
    member __.WdLh = operatorArguments.GetParameter("wd_lh", SignumUpdate.WdLhDefault)
    /// <summary>Copy SignumUpdate instance with updated inputs/parameters.</summary>
    /// <param name="weight">Weight</param>
    /// <param name="grad">Gradient</param>
    /// <param name="mom">Momentum</param>
    /// <param name="lr">Learning rate</param>
    /// <param name="momentum">The decay rate of momentum estimates at each epoch.</param>
    /// <param name="wd">Weight decay augments the objective function with a regularization term that penalizes large weights. The penalty scales with the square of the magnitude of each weight.</param>
    /// <param name="rescaleGrad">Rescale gradient to grad = rescale_grad*grad.</param>
    /// <param name="clipGradient">Clip gradient to the range of [-clip_gradient, clip_gradient] If clip_gradient &lt;= 0, gradient clipping is turned off. grad = max(min(grad, clip_gradient), -clip_gradient).</param>
    /// <param name="wdLh">The amount of weight decay that does not go into gradient/momentum calculationsotherwise do weight decay algorithmically only.</param>
    member this.With([<Optional>] ?weight : Symbol,
        [<Optional>] ?grad : Symbol,
        [<Optional>] ?mom : Symbol,
        [<Optional>] ?lr : float,
        [<Optional>] ?momentum : float,
        [<Optional>] ?wd : float,
        [<Optional>] ?rescaleGrad : float,
        [<Optional>] ?clipGradient : float,
        [<Optional>] ?wdLh : float) = 
        let operatorArguments = 
            [
                weight |> Option.map (fun x -> "weight", Input x)
                grad |> Option.map (fun x -> "grad", Input x)
                mom |> Option.map (fun x -> "mom", Input x)
                lr |> Option.map (fun x -> "lr", Parameter(Some (box x)))
                momentum |> Option.map (fun x -> "momentum", Parameter(Some (box x)))
                wd |> Option.map (fun x -> "wd", Parameter(Some (box x)))
                rescaleGrad |> Option.map (fun x -> "rescale_grad", Parameter(Some (box x)))
                clipGradient |> Option.map (fun x -> "clip_gradient", Parameter(Some (box x)))
                wdLh |> Option.map (fun x -> "wd_lh", Parameter(Some (box x)))
            ] |> List.choose id
        new SignumUpdate(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type MultiSgdUpdate private (operatorArguments) = 
    inherit SymbolOperator("multi_sgd_update", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new MultiSgdUpdate(args)
    override this.WithArguments(args : Arguments<Symbol>) = new MultiSgdUpdate(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <summary>Update function for Stochastic Gradient Descent (SDG) optimizer.
    /// 
    /// It updates the weights using::
    /// 
    ///  weight = weight - learning_rate * (gradient + wd * weight)
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\optimizer_op.cc:L327</summary>
    /// <param name="data">Weights</param>
    /// <param name="lrs">Learning rates.</param>
    /// <param name="wds">Weight decay augments the objective function with a regularization term that penalizes large weights. The penalty scales with the square of the magnitude of each weight.</param>
    /// <param name="rescaleGrad">Rescale gradient to grad = rescale_grad*grad.</param>
    /// <param name="clipGradient">Clip gradient to the range of [-clip_gradient, clip_gradient] If clip_gradient &lt;= 0, gradient clipping is turned off. grad = max(min(grad, clip_gradient), -clip_gradient).</param>
    /// <param name="numWeights">Number of updated weights.</param>
    new(data : Symbol seq,
        lrs : double seq,
        wds : double seq,
        [<Optional>] ?rescaleGrad : float,
        [<Optional>] ?clipGradient : float,
        [<Optional>] ?numWeights : int) = 
        let operatorArguments = 
            [
                "data", VarArg("", data |> Seq.toArray)
                "lrs", Parameter(Some(box lrs))
                "wds", Parameter(Some(box wds))
                "rescale_grad", rescaleGrad |> Option.map box |> Parameter
                "clip_gradient", clipGradient |> Option.map box |> Parameter
                "num_weights", numWeights |> Option.map box |> Parameter
            ]
        new MultiSgdUpdate(Arguments<Symbol>(operatorArguments))
    /// <summary>Update function for Stochastic Gradient Descent (SDG) optimizer.
    /// 
    /// It updates the weights using::
    /// 
    ///  weight = weight - learning_rate * (gradient + wd * weight)
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\optimizer_op.cc:L327</summary>
    /// <param name="lrs">Learning rates.</param>
    /// <param name="wds">Weight decay augments the objective function with a regularization term that penalizes large weights. The penalty scales with the square of the magnitude of each weight.</param>
    /// <param name="data">Weights</param>
    /// <param name="rescaleGrad">Rescale gradient to grad = rescale_grad*grad.</param>
    /// <param name="clipGradient">Clip gradient to the range of [-clip_gradient, clip_gradient] If clip_gradient &lt;= 0, gradient clipping is turned off. grad = max(min(grad, clip_gradient), -clip_gradient).</param>
    /// <param name="numWeights">Number of updated weights.</param>
    new(lrs : double seq,
        wds : double seq,
        [<Optional>] ?data : Symbol seq,
        [<Optional>] ?rescaleGrad : float,
        [<Optional>] ?clipGradient : float,
        [<Optional>] ?numWeights : int) = 
        let data = defaultArg (data |> Option.map Seq.toArray) Array.empty
        let operatorArguments = 
            [
                "data", VarArg("", data)
                "lrs", Parameter(Some(box lrs))
                "wds", Parameter(Some(box wds))
                "rescale_grad", rescaleGrad |> Option.map box |> Parameter
                "clip_gradient", clipGradient |> Option.map box |> Parameter
                "num_weights", numWeights |> Option.map box |> Parameter
            ]
        new MultiSgdUpdate(Arguments<Symbol>(operatorArguments))
    /// Default value for RescaleGrad
    /// Rescale gradient to grad = rescale_grad*grad.
    static member RescaleGradDefault : double = 1.0
    /// Default value for ClipGradient
    /// Clip gradient to the range of [-clip_gradient, clip_gradient] If clip_gradient &lt;= 0, gradient clipping is turned off. grad = max(min(grad, clip_gradient), -clip_gradient).
    static member ClipGradientDefault : double = -1.0
    /// Default value for NumWeights
    /// Number of updated weights.
    static member NumWeightsDefault : int = 1
    /// Weights
    member __.Data = operatorArguments.GetVarArg "data"
    /// Learning rates.
    member __.Lrs : double seq = match operatorArguments.GetParameter "lrs" with Some(v) -> unbox v | None -> failwithf "Required parameter lrs is missing"
    /// Weight decay augments the objective function with a regularization term that penalizes large weights. The penalty scales with the square of the magnitude of each weight.
    member __.Wds : double seq = match operatorArguments.GetParameter "wds" with Some(v) -> unbox v | None -> failwithf "Required parameter wds is missing"
    /// Rescale gradient to grad = rescale_grad*grad.
    member __.RescaleGrad = operatorArguments.GetParameter("rescale_grad", MultiSgdUpdate.RescaleGradDefault)
    /// Clip gradient to the range of [-clip_gradient, clip_gradient] If clip_gradient &lt;= 0, gradient clipping is turned off. grad = max(min(grad, clip_gradient), -clip_gradient).
    member __.ClipGradient = operatorArguments.GetParameter("clip_gradient", MultiSgdUpdate.ClipGradientDefault)
    /// Number of updated weights.
    member __.NumWeights = operatorArguments.GetParameter("num_weights", MultiSgdUpdate.NumWeightsDefault)
    /// <summary>Copy MultiSgdUpdate instance with updated inputs/parameters.</summary>
    /// <param name="data">Weights</param>
    /// <param name="lrs">Learning rates.</param>
    /// <param name="wds">Weight decay augments the objective function with a regularization term that penalizes large weights. The penalty scales with the square of the magnitude of each weight.</param>
    /// <param name="rescaleGrad">Rescale gradient to grad = rescale_grad*grad.</param>
    /// <param name="clipGradient">Clip gradient to the range of [-clip_gradient, clip_gradient] If clip_gradient &lt;= 0, gradient clipping is turned off. grad = max(min(grad, clip_gradient), -clip_gradient).</param>
    /// <param name="numWeights">Number of updated weights.</param>
    member this.With([<Optional>] ?data : Symbol seq,
        [<Optional>] ?lrs : double seq,
        [<Optional>] ?wds : double seq,
        [<Optional>] ?rescaleGrad : float,
        [<Optional>] ?clipGradient : float,
        [<Optional>] ?numWeights : int) = 
        let operatorArguments = 
            [
                data |> Option.map (fun x -> "data", VarArg("", Seq.toArray x))
                lrs |> Option.map (fun x -> "lrs", Parameter(Some (box x)))
                wds |> Option.map (fun x -> "wds", Parameter(Some (box x)))
                rescaleGrad |> Option.map (fun x -> "rescale_grad", Parameter(Some (box x)))
                clipGradient |> Option.map (fun x -> "clip_gradient", Parameter(Some (box x)))
                numWeights |> Option.map (fun x -> "num_weights", Parameter(Some (box x)))
            ] |> List.choose id
        new MultiSgdUpdate(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type MultiSgdMomUpdate private (operatorArguments) = 
    inherit SymbolOperator("multi_sgd_mom_update", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new MultiSgdMomUpdate(args)
    override this.WithArguments(args : Arguments<Symbol>) = new MultiSgdMomUpdate(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <summary>Momentum update function for Stochastic Gradient Descent (SGD) optimizer.
    /// 
    /// Momentum update has better convergence rates on neural networks. Mathematically it looks
    /// like below:
    /// 
    /// .. math::
    /// 
    ///   v_1 = \alpha * \nabla J(W_0)\\
    ///   v_t = \gamma v_{t-1} - \alpha * \nabla J(W_{t-1})\\
    ///   W_t = W_{t-1} + v_t
    /// 
    /// It updates the weights using::
    /// 
    ///   v = momentum * v - learning_rate * gradient
    ///   weight += v
    /// 
    /// Where the parameter ``momentum`` is the decay rate of momentum estimates at each epoch.
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\optimizer_op.cc:L372</summary>
    /// <param name="data">Weights, gradients and momentum</param>
    /// <param name="lrs">Learning rates.</param>
    /// <param name="wds">Weight decay augments the objective function with a regularization term that penalizes large weights. The penalty scales with the square of the magnitude of each weight.</param>
    /// <param name="momentum">The decay rate of momentum estimates at each epoch.</param>
    /// <param name="rescaleGrad">Rescale gradient to grad = rescale_grad*grad.</param>
    /// <param name="clipGradient">Clip gradient to the range of [-clip_gradient, clip_gradient] If clip_gradient &lt;= 0, gradient clipping is turned off. grad = max(min(grad, clip_gradient), -clip_gradient).</param>
    /// <param name="numWeights">Number of updated weights.</param>
    new(data : Symbol seq,
        lrs : double seq,
        wds : double seq,
        [<Optional>] ?momentum : float,
        [<Optional>] ?rescaleGrad : float,
        [<Optional>] ?clipGradient : float,
        [<Optional>] ?numWeights : int) = 
        let operatorArguments = 
            [
                "data", VarArg("", data |> Seq.toArray)
                "lrs", Parameter(Some(box lrs))
                "wds", Parameter(Some(box wds))
                "momentum", momentum |> Option.map box |> Parameter
                "rescale_grad", rescaleGrad |> Option.map box |> Parameter
                "clip_gradient", clipGradient |> Option.map box |> Parameter
                "num_weights", numWeights |> Option.map box |> Parameter
            ]
        new MultiSgdMomUpdate(Arguments<Symbol>(operatorArguments))
    /// <summary>Momentum update function for Stochastic Gradient Descent (SGD) optimizer.
    /// 
    /// Momentum update has better convergence rates on neural networks. Mathematically it looks
    /// like below:
    /// 
    /// .. math::
    /// 
    ///   v_1 = \alpha * \nabla J(W_0)\\
    ///   v_t = \gamma v_{t-1} - \alpha * \nabla J(W_{t-1})\\
    ///   W_t = W_{t-1} + v_t
    /// 
    /// It updates the weights using::
    /// 
    ///   v = momentum * v - learning_rate * gradient
    ///   weight += v
    /// 
    /// Where the parameter ``momentum`` is the decay rate of momentum estimates at each epoch.
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\optimizer_op.cc:L372</summary>
    /// <param name="lrs">Learning rates.</param>
    /// <param name="wds">Weight decay augments the objective function with a regularization term that penalizes large weights. The penalty scales with the square of the magnitude of each weight.</param>
    /// <param name="data">Weights, gradients and momentum</param>
    /// <param name="momentum">The decay rate of momentum estimates at each epoch.</param>
    /// <param name="rescaleGrad">Rescale gradient to grad = rescale_grad*grad.</param>
    /// <param name="clipGradient">Clip gradient to the range of [-clip_gradient, clip_gradient] If clip_gradient &lt;= 0, gradient clipping is turned off. grad = max(min(grad, clip_gradient), -clip_gradient).</param>
    /// <param name="numWeights">Number of updated weights.</param>
    new(lrs : double seq,
        wds : double seq,
        [<Optional>] ?data : Symbol seq,
        [<Optional>] ?momentum : float,
        [<Optional>] ?rescaleGrad : float,
        [<Optional>] ?clipGradient : float,
        [<Optional>] ?numWeights : int) = 
        let data = defaultArg (data |> Option.map Seq.toArray) Array.empty
        let operatorArguments = 
            [
                "data", VarArg("", data)
                "lrs", Parameter(Some(box lrs))
                "wds", Parameter(Some(box wds))
                "momentum", momentum |> Option.map box |> Parameter
                "rescale_grad", rescaleGrad |> Option.map box |> Parameter
                "clip_gradient", clipGradient |> Option.map box |> Parameter
                "num_weights", numWeights |> Option.map box |> Parameter
            ]
        new MultiSgdMomUpdate(Arguments<Symbol>(operatorArguments))
    /// Default value for Momentum
    /// The decay rate of momentum estimates at each epoch.
    static member MomentumDefault : double = 0.0
    /// Default value for RescaleGrad
    /// Rescale gradient to grad = rescale_grad*grad.
    static member RescaleGradDefault : double = 1.0
    /// Default value for ClipGradient
    /// Clip gradient to the range of [-clip_gradient, clip_gradient] If clip_gradient &lt;= 0, gradient clipping is turned off. grad = max(min(grad, clip_gradient), -clip_gradient).
    static member ClipGradientDefault : double = -1.0
    /// Default value for NumWeights
    /// Number of updated weights.
    static member NumWeightsDefault : int = 1
    /// Weights, gradients and momentum
    member __.Data = operatorArguments.GetVarArg "data"
    /// Learning rates.
    member __.Lrs : double seq = match operatorArguments.GetParameter "lrs" with Some(v) -> unbox v | None -> failwithf "Required parameter lrs is missing"
    /// Weight decay augments the objective function with a regularization term that penalizes large weights. The penalty scales with the square of the magnitude of each weight.
    member __.Wds : double seq = match operatorArguments.GetParameter "wds" with Some(v) -> unbox v | None -> failwithf "Required parameter wds is missing"
    /// The decay rate of momentum estimates at each epoch.
    member __.Momentum = operatorArguments.GetParameter("momentum", MultiSgdMomUpdate.MomentumDefault)
    /// Rescale gradient to grad = rescale_grad*grad.
    member __.RescaleGrad = operatorArguments.GetParameter("rescale_grad", MultiSgdMomUpdate.RescaleGradDefault)
    /// Clip gradient to the range of [-clip_gradient, clip_gradient] If clip_gradient &lt;= 0, gradient clipping is turned off. grad = max(min(grad, clip_gradient), -clip_gradient).
    member __.ClipGradient = operatorArguments.GetParameter("clip_gradient", MultiSgdMomUpdate.ClipGradientDefault)
    /// Number of updated weights.
    member __.NumWeights = operatorArguments.GetParameter("num_weights", MultiSgdMomUpdate.NumWeightsDefault)
    /// <summary>Copy MultiSgdMomUpdate instance with updated inputs/parameters.</summary>
    /// <param name="data">Weights, gradients and momentum</param>
    /// <param name="lrs">Learning rates.</param>
    /// <param name="wds">Weight decay augments the objective function with a regularization term that penalizes large weights. The penalty scales with the square of the magnitude of each weight.</param>
    /// <param name="momentum">The decay rate of momentum estimates at each epoch.</param>
    /// <param name="rescaleGrad">Rescale gradient to grad = rescale_grad*grad.</param>
    /// <param name="clipGradient">Clip gradient to the range of [-clip_gradient, clip_gradient] If clip_gradient &lt;= 0, gradient clipping is turned off. grad = max(min(grad, clip_gradient), -clip_gradient).</param>
    /// <param name="numWeights">Number of updated weights.</param>
    member this.With([<Optional>] ?data : Symbol seq,
        [<Optional>] ?lrs : double seq,
        [<Optional>] ?wds : double seq,
        [<Optional>] ?momentum : float,
        [<Optional>] ?rescaleGrad : float,
        [<Optional>] ?clipGradient : float,
        [<Optional>] ?numWeights : int) = 
        let operatorArguments = 
            [
                data |> Option.map (fun x -> "data", VarArg("", Seq.toArray x))
                lrs |> Option.map (fun x -> "lrs", Parameter(Some (box x)))
                wds |> Option.map (fun x -> "wds", Parameter(Some (box x)))
                momentum |> Option.map (fun x -> "momentum", Parameter(Some (box x)))
                rescaleGrad |> Option.map (fun x -> "rescale_grad", Parameter(Some (box x)))
                clipGradient |> Option.map (fun x -> "clip_gradient", Parameter(Some (box x)))
                numWeights |> Option.map (fun x -> "num_weights", Parameter(Some (box x)))
            ] |> List.choose id
        new MultiSgdMomUpdate(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type MultiMpSgdUpdate private (operatorArguments) = 
    inherit SymbolOperator("multi_mp_sgd_update", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new MultiMpSgdUpdate(args)
    override this.WithArguments(args : Arguments<Symbol>) = new MultiMpSgdUpdate(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <summary>Update function for multi-precision Stochastic Gradient Descent (SDG) optimizer.
    /// 
    /// It updates the weights using::
    /// 
    ///  weight = weight - learning_rate * (gradient + wd * weight)
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\optimizer_op.cc:L415</summary>
    /// <param name="data">Weights</param>
    /// <param name="lrs">Learning rates.</param>
    /// <param name="wds">Weight decay augments the objective function with a regularization term that penalizes large weights. The penalty scales with the square of the magnitude of each weight.</param>
    /// <param name="rescaleGrad">Rescale gradient to grad = rescale_grad*grad.</param>
    /// <param name="clipGradient">Clip gradient to the range of [-clip_gradient, clip_gradient] If clip_gradient &lt;= 0, gradient clipping is turned off. grad = max(min(grad, clip_gradient), -clip_gradient).</param>
    /// <param name="numWeights">Number of updated weights.</param>
    new(data : Symbol seq,
        lrs : double seq,
        wds : double seq,
        [<Optional>] ?rescaleGrad : float,
        [<Optional>] ?clipGradient : float,
        [<Optional>] ?numWeights : int) = 
        let operatorArguments = 
            [
                "data", VarArg("", data |> Seq.toArray)
                "lrs", Parameter(Some(box lrs))
                "wds", Parameter(Some(box wds))
                "rescale_grad", rescaleGrad |> Option.map box |> Parameter
                "clip_gradient", clipGradient |> Option.map box |> Parameter
                "num_weights", numWeights |> Option.map box |> Parameter
            ]
        new MultiMpSgdUpdate(Arguments<Symbol>(operatorArguments))
    /// <summary>Update function for multi-precision Stochastic Gradient Descent (SDG) optimizer.
    /// 
    /// It updates the weights using::
    /// 
    ///  weight = weight - learning_rate * (gradient + wd * weight)
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\optimizer_op.cc:L415</summary>
    /// <param name="lrs">Learning rates.</param>
    /// <param name="wds">Weight decay augments the objective function with a regularization term that penalizes large weights. The penalty scales with the square of the magnitude of each weight.</param>
    /// <param name="data">Weights</param>
    /// <param name="rescaleGrad">Rescale gradient to grad = rescale_grad*grad.</param>
    /// <param name="clipGradient">Clip gradient to the range of [-clip_gradient, clip_gradient] If clip_gradient &lt;= 0, gradient clipping is turned off. grad = max(min(grad, clip_gradient), -clip_gradient).</param>
    /// <param name="numWeights">Number of updated weights.</param>
    new(lrs : double seq,
        wds : double seq,
        [<Optional>] ?data : Symbol seq,
        [<Optional>] ?rescaleGrad : float,
        [<Optional>] ?clipGradient : float,
        [<Optional>] ?numWeights : int) = 
        let data = defaultArg (data |> Option.map Seq.toArray) Array.empty
        let operatorArguments = 
            [
                "data", VarArg("", data)
                "lrs", Parameter(Some(box lrs))
                "wds", Parameter(Some(box wds))
                "rescale_grad", rescaleGrad |> Option.map box |> Parameter
                "clip_gradient", clipGradient |> Option.map box |> Parameter
                "num_weights", numWeights |> Option.map box |> Parameter
            ]
        new MultiMpSgdUpdate(Arguments<Symbol>(operatorArguments))
    /// Default value for RescaleGrad
    /// Rescale gradient to grad = rescale_grad*grad.
    static member RescaleGradDefault : double = 1.0
    /// Default value for ClipGradient
    /// Clip gradient to the range of [-clip_gradient, clip_gradient] If clip_gradient &lt;= 0, gradient clipping is turned off. grad = max(min(grad, clip_gradient), -clip_gradient).
    static member ClipGradientDefault : double = -1.0
    /// Default value for NumWeights
    /// Number of updated weights.
    static member NumWeightsDefault : int = 1
    /// Weights
    member __.Data = operatorArguments.GetVarArg "data"
    /// Learning rates.
    member __.Lrs : double seq = match operatorArguments.GetParameter "lrs" with Some(v) -> unbox v | None -> failwithf "Required parameter lrs is missing"
    /// Weight decay augments the objective function with a regularization term that penalizes large weights. The penalty scales with the square of the magnitude of each weight.
    member __.Wds : double seq = match operatorArguments.GetParameter "wds" with Some(v) -> unbox v | None -> failwithf "Required parameter wds is missing"
    /// Rescale gradient to grad = rescale_grad*grad.
    member __.RescaleGrad = operatorArguments.GetParameter("rescale_grad", MultiMpSgdUpdate.RescaleGradDefault)
    /// Clip gradient to the range of [-clip_gradient, clip_gradient] If clip_gradient &lt;= 0, gradient clipping is turned off. grad = max(min(grad, clip_gradient), -clip_gradient).
    member __.ClipGradient = operatorArguments.GetParameter("clip_gradient", MultiMpSgdUpdate.ClipGradientDefault)
    /// Number of updated weights.
    member __.NumWeights = operatorArguments.GetParameter("num_weights", MultiMpSgdUpdate.NumWeightsDefault)
    /// <summary>Copy MultiMpSgdUpdate instance with updated inputs/parameters.</summary>
    /// <param name="data">Weights</param>
    /// <param name="lrs">Learning rates.</param>
    /// <param name="wds">Weight decay augments the objective function with a regularization term that penalizes large weights. The penalty scales with the square of the magnitude of each weight.</param>
    /// <param name="rescaleGrad">Rescale gradient to grad = rescale_grad*grad.</param>
    /// <param name="clipGradient">Clip gradient to the range of [-clip_gradient, clip_gradient] If clip_gradient &lt;= 0, gradient clipping is turned off. grad = max(min(grad, clip_gradient), -clip_gradient).</param>
    /// <param name="numWeights">Number of updated weights.</param>
    member this.With([<Optional>] ?data : Symbol seq,
        [<Optional>] ?lrs : double seq,
        [<Optional>] ?wds : double seq,
        [<Optional>] ?rescaleGrad : float,
        [<Optional>] ?clipGradient : float,
        [<Optional>] ?numWeights : int) = 
        let operatorArguments = 
            [
                data |> Option.map (fun x -> "data", VarArg("", Seq.toArray x))
                lrs |> Option.map (fun x -> "lrs", Parameter(Some (box x)))
                wds |> Option.map (fun x -> "wds", Parameter(Some (box x)))
                rescaleGrad |> Option.map (fun x -> "rescale_grad", Parameter(Some (box x)))
                clipGradient |> Option.map (fun x -> "clip_gradient", Parameter(Some (box x)))
                numWeights |> Option.map (fun x -> "num_weights", Parameter(Some (box x)))
            ] |> List.choose id
        new MultiMpSgdUpdate(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type MultiMpSgdMomUpdate private (operatorArguments) = 
    inherit SymbolOperator("multi_mp_sgd_mom_update", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new MultiMpSgdMomUpdate(args)
    override this.WithArguments(args : Arguments<Symbol>) = new MultiMpSgdMomUpdate(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <summary>Momentum update function for multi-precision Stochastic Gradient Descent (SGD) optimizer.
    /// 
    /// Momentum update has better convergence rates on neural networks. Mathematically it looks
    /// like below:
    /// 
    /// .. math::
    /// 
    ///   v_1 = \alpha * \nabla J(W_0)\\
    ///   v_t = \gamma v_{t-1} - \alpha * \nabla J(W_{t-1})\\
    ///   W_t = W_{t-1} + v_t
    /// 
    /// It updates the weights using::
    /// 
    ///   v = momentum * v - learning_rate * gradient
    ///   weight += v
    /// 
    /// Where the parameter ``momentum`` is the decay rate of momentum estimates at each epoch.
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\optimizer_op.cc:L470</summary>
    /// <param name="data">Weights</param>
    /// <param name="lrs">Learning rates.</param>
    /// <param name="wds">Weight decay augments the objective function with a regularization term that penalizes large weights. The penalty scales with the square of the magnitude of each weight.</param>
    /// <param name="momentum">The decay rate of momentum estimates at each epoch.</param>
    /// <param name="rescaleGrad">Rescale gradient to grad = rescale_grad*grad.</param>
    /// <param name="clipGradient">Clip gradient to the range of [-clip_gradient, clip_gradient] If clip_gradient &lt;= 0, gradient clipping is turned off. grad = max(min(grad, clip_gradient), -clip_gradient).</param>
    /// <param name="numWeights">Number of updated weights.</param>
    new(data : Symbol seq,
        lrs : double seq,
        wds : double seq,
        [<Optional>] ?momentum : float,
        [<Optional>] ?rescaleGrad : float,
        [<Optional>] ?clipGradient : float,
        [<Optional>] ?numWeights : int) = 
        let operatorArguments = 
            [
                "data", VarArg("", data |> Seq.toArray)
                "lrs", Parameter(Some(box lrs))
                "wds", Parameter(Some(box wds))
                "momentum", momentum |> Option.map box |> Parameter
                "rescale_grad", rescaleGrad |> Option.map box |> Parameter
                "clip_gradient", clipGradient |> Option.map box |> Parameter
                "num_weights", numWeights |> Option.map box |> Parameter
            ]
        new MultiMpSgdMomUpdate(Arguments<Symbol>(operatorArguments))
    /// <summary>Momentum update function for multi-precision Stochastic Gradient Descent (SGD) optimizer.
    /// 
    /// Momentum update has better convergence rates on neural networks. Mathematically it looks
    /// like below:
    /// 
    /// .. math::
    /// 
    ///   v_1 = \alpha * \nabla J(W_0)\\
    ///   v_t = \gamma v_{t-1} - \alpha * \nabla J(W_{t-1})\\
    ///   W_t = W_{t-1} + v_t
    /// 
    /// It updates the weights using::
    /// 
    ///   v = momentum * v - learning_rate * gradient
    ///   weight += v
    /// 
    /// Where the parameter ``momentum`` is the decay rate of momentum estimates at each epoch.
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\optimizer_op.cc:L470</summary>
    /// <param name="lrs">Learning rates.</param>
    /// <param name="wds">Weight decay augments the objective function with a regularization term that penalizes large weights. The penalty scales with the square of the magnitude of each weight.</param>
    /// <param name="data">Weights</param>
    /// <param name="momentum">The decay rate of momentum estimates at each epoch.</param>
    /// <param name="rescaleGrad">Rescale gradient to grad = rescale_grad*grad.</param>
    /// <param name="clipGradient">Clip gradient to the range of [-clip_gradient, clip_gradient] If clip_gradient &lt;= 0, gradient clipping is turned off. grad = max(min(grad, clip_gradient), -clip_gradient).</param>
    /// <param name="numWeights">Number of updated weights.</param>
    new(lrs : double seq,
        wds : double seq,
        [<Optional>] ?data : Symbol seq,
        [<Optional>] ?momentum : float,
        [<Optional>] ?rescaleGrad : float,
        [<Optional>] ?clipGradient : float,
        [<Optional>] ?numWeights : int) = 
        let data = defaultArg (data |> Option.map Seq.toArray) Array.empty
        let operatorArguments = 
            [
                "data", VarArg("", data)
                "lrs", Parameter(Some(box lrs))
                "wds", Parameter(Some(box wds))
                "momentum", momentum |> Option.map box |> Parameter
                "rescale_grad", rescaleGrad |> Option.map box |> Parameter
                "clip_gradient", clipGradient |> Option.map box |> Parameter
                "num_weights", numWeights |> Option.map box |> Parameter
            ]
        new MultiMpSgdMomUpdate(Arguments<Symbol>(operatorArguments))
    /// Default value for Momentum
    /// The decay rate of momentum estimates at each epoch.
    static member MomentumDefault : double = 0.0
    /// Default value for RescaleGrad
    /// Rescale gradient to grad = rescale_grad*grad.
    static member RescaleGradDefault : double = 1.0
    /// Default value for ClipGradient
    /// Clip gradient to the range of [-clip_gradient, clip_gradient] If clip_gradient &lt;= 0, gradient clipping is turned off. grad = max(min(grad, clip_gradient), -clip_gradient).
    static member ClipGradientDefault : double = -1.0
    /// Default value for NumWeights
    /// Number of updated weights.
    static member NumWeightsDefault : int = 1
    /// Weights
    member __.Data = operatorArguments.GetVarArg "data"
    /// Learning rates.
    member __.Lrs : double seq = match operatorArguments.GetParameter "lrs" with Some(v) -> unbox v | None -> failwithf "Required parameter lrs is missing"
    /// Weight decay augments the objective function with a regularization term that penalizes large weights. The penalty scales with the square of the magnitude of each weight.
    member __.Wds : double seq = match operatorArguments.GetParameter "wds" with Some(v) -> unbox v | None -> failwithf "Required parameter wds is missing"
    /// The decay rate of momentum estimates at each epoch.
    member __.Momentum = operatorArguments.GetParameter("momentum", MultiMpSgdMomUpdate.MomentumDefault)
    /// Rescale gradient to grad = rescale_grad*grad.
    member __.RescaleGrad = operatorArguments.GetParameter("rescale_grad", MultiMpSgdMomUpdate.RescaleGradDefault)
    /// Clip gradient to the range of [-clip_gradient, clip_gradient] If clip_gradient &lt;= 0, gradient clipping is turned off. grad = max(min(grad, clip_gradient), -clip_gradient).
    member __.ClipGradient = operatorArguments.GetParameter("clip_gradient", MultiMpSgdMomUpdate.ClipGradientDefault)
    /// Number of updated weights.
    member __.NumWeights = operatorArguments.GetParameter("num_weights", MultiMpSgdMomUpdate.NumWeightsDefault)
    /// <summary>Copy MultiMpSgdMomUpdate instance with updated inputs/parameters.</summary>
    /// <param name="data">Weights</param>
    /// <param name="lrs">Learning rates.</param>
    /// <param name="wds">Weight decay augments the objective function with a regularization term that penalizes large weights. The penalty scales with the square of the magnitude of each weight.</param>
    /// <param name="momentum">The decay rate of momentum estimates at each epoch.</param>
    /// <param name="rescaleGrad">Rescale gradient to grad = rescale_grad*grad.</param>
    /// <param name="clipGradient">Clip gradient to the range of [-clip_gradient, clip_gradient] If clip_gradient &lt;= 0, gradient clipping is turned off. grad = max(min(grad, clip_gradient), -clip_gradient).</param>
    /// <param name="numWeights">Number of updated weights.</param>
    member this.With([<Optional>] ?data : Symbol seq,
        [<Optional>] ?lrs : double seq,
        [<Optional>] ?wds : double seq,
        [<Optional>] ?momentum : float,
        [<Optional>] ?rescaleGrad : float,
        [<Optional>] ?clipGradient : float,
        [<Optional>] ?numWeights : int) = 
        let operatorArguments = 
            [
                data |> Option.map (fun x -> "data", VarArg("", Seq.toArray x))
                lrs |> Option.map (fun x -> "lrs", Parameter(Some (box x)))
                wds |> Option.map (fun x -> "wds", Parameter(Some (box x)))
                momentum |> Option.map (fun x -> "momentum", Parameter(Some (box x)))
                rescaleGrad |> Option.map (fun x -> "rescale_grad", Parameter(Some (box x)))
                clipGradient |> Option.map (fun x -> "clip_gradient", Parameter(Some (box x)))
                numWeights |> Option.map (fun x -> "num_weights", Parameter(Some (box x)))
            ] |> List.choose id
        new MultiMpSgdMomUpdate(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type SgdUpdate private (operatorArguments) = 
    inherit SymbolOperator("sgd_update", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new SgdUpdate(args)
    override this.WithArguments(args : Arguments<Symbol>) = new SgdUpdate(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <summary>Update function for Stochastic Gradient Descent (SGD) optimizer.
    /// 
    /// It updates the weights using::
    /// 
    ///  weight = weight - learning_rate * (gradient + wd * weight)
    /// 
    /// However, if gradient is of ``row_sparse`` storage type and ``lazy_update`` is True,
    /// only the row slices whose indices appear in grad.indices are updated::
    /// 
    ///  for row in gradient.indices:
    ///      weight[row] = weight[row] - learning_rate * (gradient[row] + wd * weight[row])
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\optimizer_op.cc:L522</summary>
    /// <param name="weight">Weight</param>
    /// <param name="grad">Gradient</param>
    /// <param name="lr">Learning rate</param>
    /// <param name="wd">Weight decay augments the objective function with a regularization term that penalizes large weights. The penalty scales with the square of the magnitude of each weight.</param>
    /// <param name="rescaleGrad">Rescale gradient to grad = rescale_grad*grad.</param>
    /// <param name="clipGradient">Clip gradient to the range of [-clip_gradient, clip_gradient] If clip_gradient &lt;= 0, gradient clipping is turned off. grad = max(min(grad, clip_gradient), -clip_gradient).</param>
    /// <param name="lazyUpdate">If true, lazy updates are applied if gradient&#39;s stype is row_sparse.</param>
    new(weight : Symbol,
        grad : Symbol,
        lr : float,
        [<Optional>] ?wd : float,
        [<Optional>] ?rescaleGrad : float,
        [<Optional>] ?clipGradient : float,
        [<Optional>] ?lazyUpdate : bool) = 
        let operatorArguments = 
            [
                "weight", Input weight
                "grad", Input grad
                "lr", Parameter(Some(box lr))
                "wd", wd |> Option.map box |> Parameter
                "rescale_grad", rescaleGrad |> Option.map box |> Parameter
                "clip_gradient", clipGradient |> Option.map box |> Parameter
                "lazy_update", lazyUpdate |> Option.map box |> Parameter
            ]
        new SgdUpdate(Arguments<Symbol>(operatorArguments))
    /// <summary>Update function for Stochastic Gradient Descent (SGD) optimizer.
    /// 
    /// It updates the weights using::
    /// 
    ///  weight = weight - learning_rate * (gradient + wd * weight)
    /// 
    /// However, if gradient is of ``row_sparse`` storage type and ``lazy_update`` is True,
    /// only the row slices whose indices appear in grad.indices are updated::
    /// 
    ///  for row in gradient.indices:
    ///      weight[row] = weight[row] - learning_rate * (gradient[row] + wd * weight[row])
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\optimizer_op.cc:L522</summary>
    /// <param name="lr">Learning rate</param>
    /// <param name="weight">Weight</param>
    /// <param name="grad">Gradient</param>
    /// <param name="wd">Weight decay augments the objective function with a regularization term that penalizes large weights. The penalty scales with the square of the magnitude of each weight.</param>
    /// <param name="rescaleGrad">Rescale gradient to grad = rescale_grad*grad.</param>
    /// <param name="clipGradient">Clip gradient to the range of [-clip_gradient, clip_gradient] If clip_gradient &lt;= 0, gradient clipping is turned off. grad = max(min(grad, clip_gradient), -clip_gradient).</param>
    /// <param name="lazyUpdate">If true, lazy updates are applied if gradient&#39;s stype is row_sparse.</param>
    new(lr : float,
        [<Optional>] ?weight : Symbol,
        [<Optional>] ?grad : Symbol,
        [<Optional>] ?wd : float,
        [<Optional>] ?rescaleGrad : float,
        [<Optional>] ?clipGradient : float,
        [<Optional>] ?lazyUpdate : bool) = 
        let weight = defaultArg weight (new ImplicitVariable() :> Symbol)
        let grad = defaultArg grad (new ImplicitVariable() :> Symbol)
        let operatorArguments = 
            [
                "weight", Input weight
                "grad", Input grad
                "lr", Parameter(Some(box lr))
                "wd", wd |> Option.map box |> Parameter
                "rescale_grad", rescaleGrad |> Option.map box |> Parameter
                "clip_gradient", clipGradient |> Option.map box |> Parameter
                "lazy_update", lazyUpdate |> Option.map box |> Parameter
            ]
        new SgdUpdate(Arguments<Symbol>(operatorArguments))
    /// Default value for Wd
    /// Weight decay augments the objective function with a regularization term that penalizes large weights. The penalty scales with the square of the magnitude of each weight.
    static member WdDefault : double = 0.0
    /// Default value for RescaleGrad
    /// Rescale gradient to grad = rescale_grad*grad.
    static member RescaleGradDefault : double = 1.0
    /// Default value for ClipGradient
    /// Clip gradient to the range of [-clip_gradient, clip_gradient] If clip_gradient &lt;= 0, gradient clipping is turned off. grad = max(min(grad, clip_gradient), -clip_gradient).
    static member ClipGradientDefault : double = -1.0
    /// Default value for LazyUpdate
    /// If true, lazy updates are applied if gradient&#39;s stype is row_sparse.
    static member LazyUpdateDefault : bool = true
    /// Weight
    member __.Weight = operatorArguments.GetInput "weight"
    /// Gradient
    member __.Grad = operatorArguments.GetInput "grad"
    /// Learning rate
    member __.Lr : float = match operatorArguments.GetParameter "lr" with Some(v) -> unbox v | None -> failwithf "Required parameter lr is missing"
    /// Weight decay augments the objective function with a regularization term that penalizes large weights. The penalty scales with the square of the magnitude of each weight.
    member __.Wd = operatorArguments.GetParameter("wd", SgdUpdate.WdDefault)
    /// Rescale gradient to grad = rescale_grad*grad.
    member __.RescaleGrad = operatorArguments.GetParameter("rescale_grad", SgdUpdate.RescaleGradDefault)
    /// Clip gradient to the range of [-clip_gradient, clip_gradient] If clip_gradient &lt;= 0, gradient clipping is turned off. grad = max(min(grad, clip_gradient), -clip_gradient).
    member __.ClipGradient = operatorArguments.GetParameter("clip_gradient", SgdUpdate.ClipGradientDefault)
    /// If true, lazy updates are applied if gradient&#39;s stype is row_sparse.
    member __.LazyUpdate = operatorArguments.GetParameter("lazy_update", SgdUpdate.LazyUpdateDefault)
    /// <summary>Copy SgdUpdate instance with updated inputs/parameters.</summary>
    /// <param name="weight">Weight</param>
    /// <param name="grad">Gradient</param>
    /// <param name="lr">Learning rate</param>
    /// <param name="wd">Weight decay augments the objective function with a regularization term that penalizes large weights. The penalty scales with the square of the magnitude of each weight.</param>
    /// <param name="rescaleGrad">Rescale gradient to grad = rescale_grad*grad.</param>
    /// <param name="clipGradient">Clip gradient to the range of [-clip_gradient, clip_gradient] If clip_gradient &lt;= 0, gradient clipping is turned off. grad = max(min(grad, clip_gradient), -clip_gradient).</param>
    /// <param name="lazyUpdate">If true, lazy updates are applied if gradient&#39;s stype is row_sparse.</param>
    member this.With([<Optional>] ?weight : Symbol,
        [<Optional>] ?grad : Symbol,
        [<Optional>] ?lr : float,
        [<Optional>] ?wd : float,
        [<Optional>] ?rescaleGrad : float,
        [<Optional>] ?clipGradient : float,
        [<Optional>] ?lazyUpdate : bool) = 
        let operatorArguments = 
            [
                weight |> Option.map (fun x -> "weight", Input x)
                grad |> Option.map (fun x -> "grad", Input x)
                lr |> Option.map (fun x -> "lr", Parameter(Some (box x)))
                wd |> Option.map (fun x -> "wd", Parameter(Some (box x)))
                rescaleGrad |> Option.map (fun x -> "rescale_grad", Parameter(Some (box x)))
                clipGradient |> Option.map (fun x -> "clip_gradient", Parameter(Some (box x)))
                lazyUpdate |> Option.map (fun x -> "lazy_update", Parameter(Some (box x)))
            ] |> List.choose id
        new SgdUpdate(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type SgdMomUpdate private (operatorArguments) = 
    inherit SymbolOperator("sgd_mom_update", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new SgdMomUpdate(args)
    override this.WithArguments(args : Arguments<Symbol>) = new SgdMomUpdate(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <summary>Momentum update function for Stochastic Gradient Descent (SGD) optimizer.
    /// 
    /// Momentum update has better convergence rates on neural networks. Mathematically it looks
    /// like below:
    /// 
    /// .. math::
    /// 
    ///   v_1 = \alpha * \nabla J(W_0)\\
    ///   v_t = \gamma v_{t-1} - \alpha * \nabla J(W_{t-1})\\
    ///   W_t = W_{t-1} + v_t
    /// 
    /// It updates the weights using::
    /// 
    ///   v = momentum * v - learning_rate * gradient
    ///   weight += v
    /// 
    /// Where the parameter ``momentum`` is the decay rate of momentum estimates at each epoch.
    /// 
    /// However, if grad&#39;s storage type is ``row_sparse``, ``lazy_update`` is True and weight&#39;s storage
    /// type is the same as momentum&#39;s storage type,
    /// only the row slices whose indices appear in grad.indices are updated (for both weight and momentum)::
    /// 
    ///   for row in gradient.indices:
    ///       v[row] = momentum[row] * v[row] - learning_rate * gradient[row]
    ///       weight[row] += v[row]
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\optimizer_op.cc:L563</summary>
    /// <param name="weight">Weight</param>
    /// <param name="grad">Gradient</param>
    /// <param name="mom">Momentum</param>
    /// <param name="lr">Learning rate</param>
    /// <param name="momentum">The decay rate of momentum estimates at each epoch.</param>
    /// <param name="wd">Weight decay augments the objective function with a regularization term that penalizes large weights. The penalty scales with the square of the magnitude of each weight.</param>
    /// <param name="rescaleGrad">Rescale gradient to grad = rescale_grad*grad.</param>
    /// <param name="clipGradient">Clip gradient to the range of [-clip_gradient, clip_gradient] If clip_gradient &lt;= 0, gradient clipping is turned off. grad = max(min(grad, clip_gradient), -clip_gradient).</param>
    /// <param name="lazyUpdate">If true, lazy updates are applied if gradient&#39;s stype is row_sparse and both weight and momentum have the same stype</param>
    new(weight : Symbol,
        grad : Symbol,
        mom : Symbol,
        lr : float,
        [<Optional>] ?momentum : float,
        [<Optional>] ?wd : float,
        [<Optional>] ?rescaleGrad : float,
        [<Optional>] ?clipGradient : float,
        [<Optional>] ?lazyUpdate : bool) = 
        let operatorArguments = 
            [
                "weight", Input weight
                "grad", Input grad
                "mom", Input mom
                "lr", Parameter(Some(box lr))
                "momentum", momentum |> Option.map box |> Parameter
                "wd", wd |> Option.map box |> Parameter
                "rescale_grad", rescaleGrad |> Option.map box |> Parameter
                "clip_gradient", clipGradient |> Option.map box |> Parameter
                "lazy_update", lazyUpdate |> Option.map box |> Parameter
            ]
        new SgdMomUpdate(Arguments<Symbol>(operatorArguments))
    /// <summary>Momentum update function for Stochastic Gradient Descent (SGD) optimizer.
    /// 
    /// Momentum update has better convergence rates on neural networks. Mathematically it looks
    /// like below:
    /// 
    /// .. math::
    /// 
    ///   v_1 = \alpha * \nabla J(W_0)\\
    ///   v_t = \gamma v_{t-1} - \alpha * \nabla J(W_{t-1})\\
    ///   W_t = W_{t-1} + v_t
    /// 
    /// It updates the weights using::
    /// 
    ///   v = momentum * v - learning_rate * gradient
    ///   weight += v
    /// 
    /// Where the parameter ``momentum`` is the decay rate of momentum estimates at each epoch.
    /// 
    /// However, if grad&#39;s storage type is ``row_sparse``, ``lazy_update`` is True and weight&#39;s storage
    /// type is the same as momentum&#39;s storage type,
    /// only the row slices whose indices appear in grad.indices are updated (for both weight and momentum)::
    /// 
    ///   for row in gradient.indices:
    ///       v[row] = momentum[row] * v[row] - learning_rate * gradient[row]
    ///       weight[row] += v[row]
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\optimizer_op.cc:L563</summary>
    /// <param name="lr">Learning rate</param>
    /// <param name="weight">Weight</param>
    /// <param name="grad">Gradient</param>
    /// <param name="mom">Momentum</param>
    /// <param name="momentum">The decay rate of momentum estimates at each epoch.</param>
    /// <param name="wd">Weight decay augments the objective function with a regularization term that penalizes large weights. The penalty scales with the square of the magnitude of each weight.</param>
    /// <param name="rescaleGrad">Rescale gradient to grad = rescale_grad*grad.</param>
    /// <param name="clipGradient">Clip gradient to the range of [-clip_gradient, clip_gradient] If clip_gradient &lt;= 0, gradient clipping is turned off. grad = max(min(grad, clip_gradient), -clip_gradient).</param>
    /// <param name="lazyUpdate">If true, lazy updates are applied if gradient&#39;s stype is row_sparse and both weight and momentum have the same stype</param>
    new(lr : float,
        [<Optional>] ?weight : Symbol,
        [<Optional>] ?grad : Symbol,
        [<Optional>] ?mom : Symbol,
        [<Optional>] ?momentum : float,
        [<Optional>] ?wd : float,
        [<Optional>] ?rescaleGrad : float,
        [<Optional>] ?clipGradient : float,
        [<Optional>] ?lazyUpdate : bool) = 
        let weight = defaultArg weight (new ImplicitVariable() :> Symbol)
        let grad = defaultArg grad (new ImplicitVariable() :> Symbol)
        let mom = defaultArg mom (new ImplicitVariable() :> Symbol)
        let operatorArguments = 
            [
                "weight", Input weight
                "grad", Input grad
                "mom", Input mom
                "lr", Parameter(Some(box lr))
                "momentum", momentum |> Option.map box |> Parameter
                "wd", wd |> Option.map box |> Parameter
                "rescale_grad", rescaleGrad |> Option.map box |> Parameter
                "clip_gradient", clipGradient |> Option.map box |> Parameter
                "lazy_update", lazyUpdate |> Option.map box |> Parameter
            ]
        new SgdMomUpdate(Arguments<Symbol>(operatorArguments))
    /// Default value for Momentum
    /// The decay rate of momentum estimates at each epoch.
    static member MomentumDefault : double = 0.0
    /// Default value for Wd
    /// Weight decay augments the objective function with a regularization term that penalizes large weights. The penalty scales with the square of the magnitude of each weight.
    static member WdDefault : double = 0.0
    /// Default value for RescaleGrad
    /// Rescale gradient to grad = rescale_grad*grad.
    static member RescaleGradDefault : double = 1.0
    /// Default value for ClipGradient
    /// Clip gradient to the range of [-clip_gradient, clip_gradient] If clip_gradient &lt;= 0, gradient clipping is turned off. grad = max(min(grad, clip_gradient), -clip_gradient).
    static member ClipGradientDefault : double = -1.0
    /// Default value for LazyUpdate
    /// If true, lazy updates are applied if gradient&#39;s stype is row_sparse and both weight and momentum have the same stype
    static member LazyUpdateDefault : bool = true
    /// Weight
    member __.Weight = operatorArguments.GetInput "weight"
    /// Gradient
    member __.Grad = operatorArguments.GetInput "grad"
    /// Momentum
    member __.Mom = operatorArguments.GetInput "mom"
    /// Learning rate
    member __.Lr : float = match operatorArguments.GetParameter "lr" with Some(v) -> unbox v | None -> failwithf "Required parameter lr is missing"
    /// The decay rate of momentum estimates at each epoch.
    member __.Momentum = operatorArguments.GetParameter("momentum", SgdMomUpdate.MomentumDefault)
    /// Weight decay augments the objective function with a regularization term that penalizes large weights. The penalty scales with the square of the magnitude of each weight.
    member __.Wd = operatorArguments.GetParameter("wd", SgdMomUpdate.WdDefault)
    /// Rescale gradient to grad = rescale_grad*grad.
    member __.RescaleGrad = operatorArguments.GetParameter("rescale_grad", SgdMomUpdate.RescaleGradDefault)
    /// Clip gradient to the range of [-clip_gradient, clip_gradient] If clip_gradient &lt;= 0, gradient clipping is turned off. grad = max(min(grad, clip_gradient), -clip_gradient).
    member __.ClipGradient = operatorArguments.GetParameter("clip_gradient", SgdMomUpdate.ClipGradientDefault)
    /// If true, lazy updates are applied if gradient&#39;s stype is row_sparse and both weight and momentum have the same stype
    member __.LazyUpdate = operatorArguments.GetParameter("lazy_update", SgdMomUpdate.LazyUpdateDefault)
    /// <summary>Copy SgdMomUpdate instance with updated inputs/parameters.</summary>
    /// <param name="weight">Weight</param>
    /// <param name="grad">Gradient</param>
    /// <param name="mom">Momentum</param>
    /// <param name="lr">Learning rate</param>
    /// <param name="momentum">The decay rate of momentum estimates at each epoch.</param>
    /// <param name="wd">Weight decay augments the objective function with a regularization term that penalizes large weights. The penalty scales with the square of the magnitude of each weight.</param>
    /// <param name="rescaleGrad">Rescale gradient to grad = rescale_grad*grad.</param>
    /// <param name="clipGradient">Clip gradient to the range of [-clip_gradient, clip_gradient] If clip_gradient &lt;= 0, gradient clipping is turned off. grad = max(min(grad, clip_gradient), -clip_gradient).</param>
    /// <param name="lazyUpdate">If true, lazy updates are applied if gradient&#39;s stype is row_sparse and both weight and momentum have the same stype</param>
    member this.With([<Optional>] ?weight : Symbol,
        [<Optional>] ?grad : Symbol,
        [<Optional>] ?mom : Symbol,
        [<Optional>] ?lr : float,
        [<Optional>] ?momentum : float,
        [<Optional>] ?wd : float,
        [<Optional>] ?rescaleGrad : float,
        [<Optional>] ?clipGradient : float,
        [<Optional>] ?lazyUpdate : bool) = 
        let operatorArguments = 
            [
                weight |> Option.map (fun x -> "weight", Input x)
                grad |> Option.map (fun x -> "grad", Input x)
                mom |> Option.map (fun x -> "mom", Input x)
                lr |> Option.map (fun x -> "lr", Parameter(Some (box x)))
                momentum |> Option.map (fun x -> "momentum", Parameter(Some (box x)))
                wd |> Option.map (fun x -> "wd", Parameter(Some (box x)))
                rescaleGrad |> Option.map (fun x -> "rescale_grad", Parameter(Some (box x)))
                clipGradient |> Option.map (fun x -> "clip_gradient", Parameter(Some (box x)))
                lazyUpdate |> Option.map (fun x -> "lazy_update", Parameter(Some (box x)))
            ] |> List.choose id
        new SgdMomUpdate(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type MpSgdUpdate private (operatorArguments) = 
    inherit SymbolOperator("mp_sgd_update", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new MpSgdUpdate(args)
    override this.WithArguments(args : Arguments<Symbol>) = new MpSgdUpdate(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <summary>Updater function for multi-precision sgd optimizer</summary>
    /// <param name="weight">Weight</param>
    /// <param name="grad">gradient</param>
    /// <param name="weight32">Weight32</param>
    /// <param name="lr">Learning rate</param>
    /// <param name="wd">Weight decay augments the objective function with a regularization term that penalizes large weights. The penalty scales with the square of the magnitude of each weight.</param>
    /// <param name="rescaleGrad">Rescale gradient to grad = rescale_grad*grad.</param>
    /// <param name="clipGradient">Clip gradient to the range of [-clip_gradient, clip_gradient] If clip_gradient &lt;= 0, gradient clipping is turned off. grad = max(min(grad, clip_gradient), -clip_gradient).</param>
    /// <param name="lazyUpdate">If true, lazy updates are applied if gradient&#39;s stype is row_sparse.</param>
    new(weight : Symbol,
        grad : Symbol,
        weight32 : Symbol,
        lr : float,
        [<Optional>] ?wd : float,
        [<Optional>] ?rescaleGrad : float,
        [<Optional>] ?clipGradient : float,
        [<Optional>] ?lazyUpdate : bool) = 
        let operatorArguments = 
            [
                "weight", Input weight
                "grad", Input grad
                "weight32", Input weight32
                "lr", Parameter(Some(box lr))
                "wd", wd |> Option.map box |> Parameter
                "rescale_grad", rescaleGrad |> Option.map box |> Parameter
                "clip_gradient", clipGradient |> Option.map box |> Parameter
                "lazy_update", lazyUpdate |> Option.map box |> Parameter
            ]
        new MpSgdUpdate(Arguments<Symbol>(operatorArguments))
    /// <summary>Updater function for multi-precision sgd optimizer</summary>
    /// <param name="lr">Learning rate</param>
    /// <param name="weight">Weight</param>
    /// <param name="grad">gradient</param>
    /// <param name="weight32">Weight32</param>
    /// <param name="wd">Weight decay augments the objective function with a regularization term that penalizes large weights. The penalty scales with the square of the magnitude of each weight.</param>
    /// <param name="rescaleGrad">Rescale gradient to grad = rescale_grad*grad.</param>
    /// <param name="clipGradient">Clip gradient to the range of [-clip_gradient, clip_gradient] If clip_gradient &lt;= 0, gradient clipping is turned off. grad = max(min(grad, clip_gradient), -clip_gradient).</param>
    /// <param name="lazyUpdate">If true, lazy updates are applied if gradient&#39;s stype is row_sparse.</param>
    new(lr : float,
        [<Optional>] ?weight : Symbol,
        [<Optional>] ?grad : Symbol,
        [<Optional>] ?weight32 : Symbol,
        [<Optional>] ?wd : float,
        [<Optional>] ?rescaleGrad : float,
        [<Optional>] ?clipGradient : float,
        [<Optional>] ?lazyUpdate : bool) = 
        let weight = defaultArg weight (new ImplicitVariable() :> Symbol)
        let grad = defaultArg grad (new ImplicitVariable() :> Symbol)
        let weight32 = defaultArg weight32 (new ImplicitVariable() :> Symbol)
        let operatorArguments = 
            [
                "weight", Input weight
                "grad", Input grad
                "weight32", Input weight32
                "lr", Parameter(Some(box lr))
                "wd", wd |> Option.map box |> Parameter
                "rescale_grad", rescaleGrad |> Option.map box |> Parameter
                "clip_gradient", clipGradient |> Option.map box |> Parameter
                "lazy_update", lazyUpdate |> Option.map box |> Parameter
            ]
        new MpSgdUpdate(Arguments<Symbol>(operatorArguments))
    /// Default value for Wd
    /// Weight decay augments the objective function with a regularization term that penalizes large weights. The penalty scales with the square of the magnitude of each weight.
    static member WdDefault : double = 0.0
    /// Default value for RescaleGrad
    /// Rescale gradient to grad = rescale_grad*grad.
    static member RescaleGradDefault : double = 1.0
    /// Default value for ClipGradient
    /// Clip gradient to the range of [-clip_gradient, clip_gradient] If clip_gradient &lt;= 0, gradient clipping is turned off. grad = max(min(grad, clip_gradient), -clip_gradient).
    static member ClipGradientDefault : double = -1.0
    /// Default value for LazyUpdate
    /// If true, lazy updates are applied if gradient&#39;s stype is row_sparse.
    static member LazyUpdateDefault : bool = true
    /// Weight
    member __.Weight = operatorArguments.GetInput "weight"
    /// gradient
    member __.Grad = operatorArguments.GetInput "grad"
    /// Weight32
    member __.Weight32 = operatorArguments.GetInput "weight32"
    /// Learning rate
    member __.Lr : float = match operatorArguments.GetParameter "lr" with Some(v) -> unbox v | None -> failwithf "Required parameter lr is missing"
    /// Weight decay augments the objective function with a regularization term that penalizes large weights. The penalty scales with the square of the magnitude of each weight.
    member __.Wd = operatorArguments.GetParameter("wd", MpSgdUpdate.WdDefault)
    /// Rescale gradient to grad = rescale_grad*grad.
    member __.RescaleGrad = operatorArguments.GetParameter("rescale_grad", MpSgdUpdate.RescaleGradDefault)
    /// Clip gradient to the range of [-clip_gradient, clip_gradient] If clip_gradient &lt;= 0, gradient clipping is turned off. grad = max(min(grad, clip_gradient), -clip_gradient).
    member __.ClipGradient = operatorArguments.GetParameter("clip_gradient", MpSgdUpdate.ClipGradientDefault)
    /// If true, lazy updates are applied if gradient&#39;s stype is row_sparse.
    member __.LazyUpdate = operatorArguments.GetParameter("lazy_update", MpSgdUpdate.LazyUpdateDefault)
    /// <summary>Copy MpSgdUpdate instance with updated inputs/parameters.</summary>
    /// <param name="weight">Weight</param>
    /// <param name="grad">gradient</param>
    /// <param name="weight32">Weight32</param>
    /// <param name="lr">Learning rate</param>
    /// <param name="wd">Weight decay augments the objective function with a regularization term that penalizes large weights. The penalty scales with the square of the magnitude of each weight.</param>
    /// <param name="rescaleGrad">Rescale gradient to grad = rescale_grad*grad.</param>
    /// <param name="clipGradient">Clip gradient to the range of [-clip_gradient, clip_gradient] If clip_gradient &lt;= 0, gradient clipping is turned off. grad = max(min(grad, clip_gradient), -clip_gradient).</param>
    /// <param name="lazyUpdate">If true, lazy updates are applied if gradient&#39;s stype is row_sparse.</param>
    member this.With([<Optional>] ?weight : Symbol,
        [<Optional>] ?grad : Symbol,
        [<Optional>] ?weight32 : Symbol,
        [<Optional>] ?lr : float,
        [<Optional>] ?wd : float,
        [<Optional>] ?rescaleGrad : float,
        [<Optional>] ?clipGradient : float,
        [<Optional>] ?lazyUpdate : bool) = 
        let operatorArguments = 
            [
                weight |> Option.map (fun x -> "weight", Input x)
                grad |> Option.map (fun x -> "grad", Input x)
                weight32 |> Option.map (fun x -> "weight32", Input x)
                lr |> Option.map (fun x -> "lr", Parameter(Some (box x)))
                wd |> Option.map (fun x -> "wd", Parameter(Some (box x)))
                rescaleGrad |> Option.map (fun x -> "rescale_grad", Parameter(Some (box x)))
                clipGradient |> Option.map (fun x -> "clip_gradient", Parameter(Some (box x)))
                lazyUpdate |> Option.map (fun x -> "lazy_update", Parameter(Some (box x)))
            ] |> List.choose id
        new MpSgdUpdate(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type MpSgdMomUpdate private (operatorArguments) = 
    inherit SymbolOperator("mp_sgd_mom_update", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new MpSgdMomUpdate(args)
    override this.WithArguments(args : Arguments<Symbol>) = new MpSgdMomUpdate(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <summary>Updater function for multi-precision sgd optimizer</summary>
    /// <param name="weight">Weight</param>
    /// <param name="grad">Gradient</param>
    /// <param name="mom">Momentum</param>
    /// <param name="weight32">Weight32</param>
    /// <param name="lr">Learning rate</param>
    /// <param name="momentum">The decay rate of momentum estimates at each epoch.</param>
    /// <param name="wd">Weight decay augments the objective function with a regularization term that penalizes large weights. The penalty scales with the square of the magnitude of each weight.</param>
    /// <param name="rescaleGrad">Rescale gradient to grad = rescale_grad*grad.</param>
    /// <param name="clipGradient">Clip gradient to the range of [-clip_gradient, clip_gradient] If clip_gradient &lt;= 0, gradient clipping is turned off. grad = max(min(grad, clip_gradient), -clip_gradient).</param>
    /// <param name="lazyUpdate">If true, lazy updates are applied if gradient&#39;s stype is row_sparse and both weight and momentum have the same stype</param>
    new(weight : Symbol,
        grad : Symbol,
        mom : Symbol,
        weight32 : Symbol,
        lr : float,
        [<Optional>] ?momentum : float,
        [<Optional>] ?wd : float,
        [<Optional>] ?rescaleGrad : float,
        [<Optional>] ?clipGradient : float,
        [<Optional>] ?lazyUpdate : bool) = 
        let operatorArguments = 
            [
                "weight", Input weight
                "grad", Input grad
                "mom", Input mom
                "weight32", Input weight32
                "lr", Parameter(Some(box lr))
                "momentum", momentum |> Option.map box |> Parameter
                "wd", wd |> Option.map box |> Parameter
                "rescale_grad", rescaleGrad |> Option.map box |> Parameter
                "clip_gradient", clipGradient |> Option.map box |> Parameter
                "lazy_update", lazyUpdate |> Option.map box |> Parameter
            ]
        new MpSgdMomUpdate(Arguments<Symbol>(operatorArguments))
    /// <summary>Updater function for multi-precision sgd optimizer</summary>
    /// <param name="lr">Learning rate</param>
    /// <param name="weight">Weight</param>
    /// <param name="grad">Gradient</param>
    /// <param name="mom">Momentum</param>
    /// <param name="weight32">Weight32</param>
    /// <param name="momentum">The decay rate of momentum estimates at each epoch.</param>
    /// <param name="wd">Weight decay augments the objective function with a regularization term that penalizes large weights. The penalty scales with the square of the magnitude of each weight.</param>
    /// <param name="rescaleGrad">Rescale gradient to grad = rescale_grad*grad.</param>
    /// <param name="clipGradient">Clip gradient to the range of [-clip_gradient, clip_gradient] If clip_gradient &lt;= 0, gradient clipping is turned off. grad = max(min(grad, clip_gradient), -clip_gradient).</param>
    /// <param name="lazyUpdate">If true, lazy updates are applied if gradient&#39;s stype is row_sparse and both weight and momentum have the same stype</param>
    new(lr : float,
        [<Optional>] ?weight : Symbol,
        [<Optional>] ?grad : Symbol,
        [<Optional>] ?mom : Symbol,
        [<Optional>] ?weight32 : Symbol,
        [<Optional>] ?momentum : float,
        [<Optional>] ?wd : float,
        [<Optional>] ?rescaleGrad : float,
        [<Optional>] ?clipGradient : float,
        [<Optional>] ?lazyUpdate : bool) = 
        let weight = defaultArg weight (new ImplicitVariable() :> Symbol)
        let grad = defaultArg grad (new ImplicitVariable() :> Symbol)
        let mom = defaultArg mom (new ImplicitVariable() :> Symbol)
        let weight32 = defaultArg weight32 (new ImplicitVariable() :> Symbol)
        let operatorArguments = 
            [
                "weight", Input weight
                "grad", Input grad
                "mom", Input mom
                "weight32", Input weight32
                "lr", Parameter(Some(box lr))
                "momentum", momentum |> Option.map box |> Parameter
                "wd", wd |> Option.map box |> Parameter
                "rescale_grad", rescaleGrad |> Option.map box |> Parameter
                "clip_gradient", clipGradient |> Option.map box |> Parameter
                "lazy_update", lazyUpdate |> Option.map box |> Parameter
            ]
        new MpSgdMomUpdate(Arguments<Symbol>(operatorArguments))
    /// Default value for Momentum
    /// The decay rate of momentum estimates at each epoch.
    static member MomentumDefault : double = 0.0
    /// Default value for Wd
    /// Weight decay augments the objective function with a regularization term that penalizes large weights. The penalty scales with the square of the magnitude of each weight.
    static member WdDefault : double = 0.0
    /// Default value for RescaleGrad
    /// Rescale gradient to grad = rescale_grad*grad.
    static member RescaleGradDefault : double = 1.0
    /// Default value for ClipGradient
    /// Clip gradient to the range of [-clip_gradient, clip_gradient] If clip_gradient &lt;= 0, gradient clipping is turned off. grad = max(min(grad, clip_gradient), -clip_gradient).
    static member ClipGradientDefault : double = -1.0
    /// Default value for LazyUpdate
    /// If true, lazy updates are applied if gradient&#39;s stype is row_sparse and both weight and momentum have the same stype
    static member LazyUpdateDefault : bool = true
    /// Weight
    member __.Weight = operatorArguments.GetInput "weight"
    /// Gradient
    member __.Grad = operatorArguments.GetInput "grad"
    /// Momentum
    member __.Mom = operatorArguments.GetInput "mom"
    /// Weight32
    member __.Weight32 = operatorArguments.GetInput "weight32"
    /// Learning rate
    member __.Lr : float = match operatorArguments.GetParameter "lr" with Some(v) -> unbox v | None -> failwithf "Required parameter lr is missing"
    /// The decay rate of momentum estimates at each epoch.
    member __.Momentum = operatorArguments.GetParameter("momentum", MpSgdMomUpdate.MomentumDefault)
    /// Weight decay augments the objective function with a regularization term that penalizes large weights. The penalty scales with the square of the magnitude of each weight.
    member __.Wd = operatorArguments.GetParameter("wd", MpSgdMomUpdate.WdDefault)
    /// Rescale gradient to grad = rescale_grad*grad.
    member __.RescaleGrad = operatorArguments.GetParameter("rescale_grad", MpSgdMomUpdate.RescaleGradDefault)
    /// Clip gradient to the range of [-clip_gradient, clip_gradient] If clip_gradient &lt;= 0, gradient clipping is turned off. grad = max(min(grad, clip_gradient), -clip_gradient).
    member __.ClipGradient = operatorArguments.GetParameter("clip_gradient", MpSgdMomUpdate.ClipGradientDefault)
    /// If true, lazy updates are applied if gradient&#39;s stype is row_sparse and both weight and momentum have the same stype
    member __.LazyUpdate = operatorArguments.GetParameter("lazy_update", MpSgdMomUpdate.LazyUpdateDefault)
    /// <summary>Copy MpSgdMomUpdate instance with updated inputs/parameters.</summary>
    /// <param name="weight">Weight</param>
    /// <param name="grad">Gradient</param>
    /// <param name="mom">Momentum</param>
    /// <param name="weight32">Weight32</param>
    /// <param name="lr">Learning rate</param>
    /// <param name="momentum">The decay rate of momentum estimates at each epoch.</param>
    /// <param name="wd">Weight decay augments the objective function with a regularization term that penalizes large weights. The penalty scales with the square of the magnitude of each weight.</param>
    /// <param name="rescaleGrad">Rescale gradient to grad = rescale_grad*grad.</param>
    /// <param name="clipGradient">Clip gradient to the range of [-clip_gradient, clip_gradient] If clip_gradient &lt;= 0, gradient clipping is turned off. grad = max(min(grad, clip_gradient), -clip_gradient).</param>
    /// <param name="lazyUpdate">If true, lazy updates are applied if gradient&#39;s stype is row_sparse and both weight and momentum have the same stype</param>
    member this.With([<Optional>] ?weight : Symbol,
        [<Optional>] ?grad : Symbol,
        [<Optional>] ?mom : Symbol,
        [<Optional>] ?weight32 : Symbol,
        [<Optional>] ?lr : float,
        [<Optional>] ?momentum : float,
        [<Optional>] ?wd : float,
        [<Optional>] ?rescaleGrad : float,
        [<Optional>] ?clipGradient : float,
        [<Optional>] ?lazyUpdate : bool) = 
        let operatorArguments = 
            [
                weight |> Option.map (fun x -> "weight", Input x)
                grad |> Option.map (fun x -> "grad", Input x)
                mom |> Option.map (fun x -> "mom", Input x)
                weight32 |> Option.map (fun x -> "weight32", Input x)
                lr |> Option.map (fun x -> "lr", Parameter(Some (box x)))
                momentum |> Option.map (fun x -> "momentum", Parameter(Some (box x)))
                wd |> Option.map (fun x -> "wd", Parameter(Some (box x)))
                rescaleGrad |> Option.map (fun x -> "rescale_grad", Parameter(Some (box x)))
                clipGradient |> Option.map (fun x -> "clip_gradient", Parameter(Some (box x)))
                lazyUpdate |> Option.map (fun x -> "lazy_update", Parameter(Some (box x)))
            ] |> List.choose id
        new MpSgdMomUpdate(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type FtmlUpdate private (operatorArguments) = 
    inherit SymbolOperator("ftml_update", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new FtmlUpdate(args)
    override this.WithArguments(args : Arguments<Symbol>) = new FtmlUpdate(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <summary>The FTML optimizer described in
    /// *FTML - Follow the Moving Leader in Deep Learning*,
    /// available at http://proceedings.mlr.press/v70/zheng17a/zheng17a.pdf.
    /// 
    /// .. math::
    /// 
    ///  g_t = \nabla J(W_{t-1})\\
    ///  v_t = \beta_2 v_{t-1} + (1 - \beta_2) g_t^2\\
    ///  d_t = \frac{ 1 - \beta_1^t }{ \eta_t } (\sqrt{ \frac{ v_t }{ 1 - \beta_2^t } } + \epsilon)
    ///  \sigma_t = d_t - \beta_1 d_{t-1}
    ///  z_t = \beta_1 z_{ t-1 } + (1 - \beta_1^t) g_t - \sigma_t W_{t-1}
    ///  W_t = - \frac{ z_t }{ d_t }
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\optimizer_op.cc:L638</summary>
    /// <param name="weight">Weight</param>
    /// <param name="grad">Gradient</param>
    /// <param name="d">Internal state ``d_t``</param>
    /// <param name="v">Internal state ``v_t``</param>
    /// <param name="z">Internal state ``z_t``</param>
    /// <param name="lr">Learning rate.</param>
    /// <param name="t">Number of update.</param>
    /// <param name="beta1">Generally close to 0.5.</param>
    /// <param name="beta2">Generally close to 1.</param>
    /// <param name="epsilon">Epsilon to prevent div 0.</param>
    /// <param name="wd">Weight decay augments the objective function with a regularization term that penalizes large weights. The penalty scales with the square of the magnitude of each weight.</param>
    /// <param name="rescaleGrad">Rescale gradient to grad = rescale_grad*grad.</param>
    /// <param name="clipGrad">Clip gradient to the range of [-clip_gradient, clip_gradient] If clip_gradient &lt;= 0, gradient clipping is turned off. grad = max(min(grad, clip_gradient), -clip_gradient).</param>
    new(weight : Symbol,
        grad : Symbol,
        d : Symbol,
        v : Symbol,
        z : Symbol,
        lr : float,
        t : int,
        [<Optional>] ?beta1 : float,
        [<Optional>] ?beta2 : float,
        [<Optional>] ?epsilon : double,
        [<Optional>] ?wd : float,
        [<Optional>] ?rescaleGrad : float,
        [<Optional>] ?clipGrad : float) = 
        let operatorArguments = 
            [
                "weight", Input weight
                "grad", Input grad
                "d", Input d
                "v", Input v
                "z", Input z
                "lr", Parameter(Some(box lr))
                "t", Parameter(Some(box t))
                "beta1", beta1 |> Option.map box |> Parameter
                "beta2", beta2 |> Option.map box |> Parameter
                "epsilon", epsilon |> Option.map box |> Parameter
                "wd", wd |> Option.map box |> Parameter
                "rescale_grad", rescaleGrad |> Option.map box |> Parameter
                "clip_grad", clipGrad |> Option.map box |> Parameter
            ]
        new FtmlUpdate(Arguments<Symbol>(operatorArguments))
    /// <summary>The FTML optimizer described in
    /// *FTML - Follow the Moving Leader in Deep Learning*,
    /// available at http://proceedings.mlr.press/v70/zheng17a/zheng17a.pdf.
    /// 
    /// .. math::
    /// 
    ///  g_t = \nabla J(W_{t-1})\\
    ///  v_t = \beta_2 v_{t-1} + (1 - \beta_2) g_t^2\\
    ///  d_t = \frac{ 1 - \beta_1^t }{ \eta_t } (\sqrt{ \frac{ v_t }{ 1 - \beta_2^t } } + \epsilon)
    ///  \sigma_t = d_t - \beta_1 d_{t-1}
    ///  z_t = \beta_1 z_{ t-1 } + (1 - \beta_1^t) g_t - \sigma_t W_{t-1}
    ///  W_t = - \frac{ z_t }{ d_t }
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\optimizer_op.cc:L638</summary>
    /// <param name="lr">Learning rate.</param>
    /// <param name="t">Number of update.</param>
    /// <param name="weight">Weight</param>
    /// <param name="grad">Gradient</param>
    /// <param name="d">Internal state ``d_t``</param>
    /// <param name="v">Internal state ``v_t``</param>
    /// <param name="z">Internal state ``z_t``</param>
    /// <param name="beta1">Generally close to 0.5.</param>
    /// <param name="beta2">Generally close to 1.</param>
    /// <param name="epsilon">Epsilon to prevent div 0.</param>
    /// <param name="wd">Weight decay augments the objective function with a regularization term that penalizes large weights. The penalty scales with the square of the magnitude of each weight.</param>
    /// <param name="rescaleGrad">Rescale gradient to grad = rescale_grad*grad.</param>
    /// <param name="clipGrad">Clip gradient to the range of [-clip_gradient, clip_gradient] If clip_gradient &lt;= 0, gradient clipping is turned off. grad = max(min(grad, clip_gradient), -clip_gradient).</param>
    new(lr : float,
        t : int,
        [<Optional>] ?weight : Symbol,
        [<Optional>] ?grad : Symbol,
        [<Optional>] ?d : Symbol,
        [<Optional>] ?v : Symbol,
        [<Optional>] ?z : Symbol,
        [<Optional>] ?beta1 : float,
        [<Optional>] ?beta2 : float,
        [<Optional>] ?epsilon : double,
        [<Optional>] ?wd : float,
        [<Optional>] ?rescaleGrad : float,
        [<Optional>] ?clipGrad : float) = 
        let weight = defaultArg weight (new ImplicitVariable() :> Symbol)
        let grad = defaultArg grad (new ImplicitVariable() :> Symbol)
        let d = defaultArg d (new ImplicitVariable() :> Symbol)
        let v = defaultArg v (new ImplicitVariable() :> Symbol)
        let z = defaultArg z (new ImplicitVariable() :> Symbol)
        let operatorArguments = 
            [
                "weight", Input weight
                "grad", Input grad
                "d", Input d
                "v", Input v
                "z", Input z
                "lr", Parameter(Some(box lr))
                "t", Parameter(Some(box t))
                "beta1", beta1 |> Option.map box |> Parameter
                "beta2", beta2 |> Option.map box |> Parameter
                "epsilon", epsilon |> Option.map box |> Parameter
                "wd", wd |> Option.map box |> Parameter
                "rescale_grad", rescaleGrad |> Option.map box |> Parameter
                "clip_grad", clipGrad |> Option.map box |> Parameter
            ]
        new FtmlUpdate(Arguments<Symbol>(operatorArguments))
    /// Default value for Beta1
    /// Generally close to 0.5.
    static member Beta1Default : double = 0.600000024
    /// Default value for Beta2
    /// Generally close to 1.
    static member Beta2Default : double = 0.999000013
    /// Default value for Epsilon
    /// Epsilon to prevent div 0.
    static member EpsilonDefault : double = 0.0000000099999999
    /// Default value for Wd
    /// Weight decay augments the objective function with a regularization term that penalizes large weights. The penalty scales with the square of the magnitude of each weight.
    static member WdDefault : double = 0.0
    /// Default value for RescaleGrad
    /// Rescale gradient to grad = rescale_grad*grad.
    static member RescaleGradDefault : double = 1.0
    /// Default value for ClipGrad
    /// Clip gradient to the range of [-clip_gradient, clip_gradient] If clip_gradient &lt;= 0, gradient clipping is turned off. grad = max(min(grad, clip_gradient), -clip_gradient).
    static member ClipGradDefault : double = -1.0
    /// Weight
    member __.Weight = operatorArguments.GetInput "weight"
    /// Gradient
    member __.Grad = operatorArguments.GetInput "grad"
    /// Internal state ``d_t``
    member __.D = operatorArguments.GetInput "d"
    /// Internal state ``v_t``
    member __.V = operatorArguments.GetInput "v"
    /// Internal state ``z_t``
    member __.Z = operatorArguments.GetInput "z"
    /// Learning rate.
    member __.Lr : float = match operatorArguments.GetParameter "lr" with Some(v) -> unbox v | None -> failwithf "Required parameter lr is missing"
    /// Number of update.
    member __.T : int = match operatorArguments.GetParameter "t" with Some(v) -> unbox v | None -> failwithf "Required parameter t is missing"
    /// Generally close to 0.5.
    member __.Beta1 = operatorArguments.GetParameter("beta1", FtmlUpdate.Beta1Default)
    /// Generally close to 1.
    member __.Beta2 = operatorArguments.GetParameter("beta2", FtmlUpdate.Beta2Default)
    /// Epsilon to prevent div 0.
    member __.Epsilon = operatorArguments.GetParameter("epsilon", FtmlUpdate.EpsilonDefault)
    /// Weight decay augments the objective function with a regularization term that penalizes large weights. The penalty scales with the square of the magnitude of each weight.
    member __.Wd = operatorArguments.GetParameter("wd", FtmlUpdate.WdDefault)
    /// Rescale gradient to grad = rescale_grad*grad.
    member __.RescaleGrad = operatorArguments.GetParameter("rescale_grad", FtmlUpdate.RescaleGradDefault)
    /// Clip gradient to the range of [-clip_gradient, clip_gradient] If clip_gradient &lt;= 0, gradient clipping is turned off. grad = max(min(grad, clip_gradient), -clip_gradient).
    member __.ClipGrad = operatorArguments.GetParameter("clip_grad", FtmlUpdate.ClipGradDefault)
    /// <summary>Copy FtmlUpdate instance with updated inputs/parameters.</summary>
    /// <param name="weight">Weight</param>
    /// <param name="grad">Gradient</param>
    /// <param name="d">Internal state ``d_t``</param>
    /// <param name="v">Internal state ``v_t``</param>
    /// <param name="z">Internal state ``z_t``</param>
    /// <param name="lr">Learning rate.</param>
    /// <param name="t">Number of update.</param>
    /// <param name="beta1">Generally close to 0.5.</param>
    /// <param name="beta2">Generally close to 1.</param>
    /// <param name="epsilon">Epsilon to prevent div 0.</param>
    /// <param name="wd">Weight decay augments the objective function with a regularization term that penalizes large weights. The penalty scales with the square of the magnitude of each weight.</param>
    /// <param name="rescaleGrad">Rescale gradient to grad = rescale_grad*grad.</param>
    /// <param name="clipGrad">Clip gradient to the range of [-clip_gradient, clip_gradient] If clip_gradient &lt;= 0, gradient clipping is turned off. grad = max(min(grad, clip_gradient), -clip_gradient).</param>
    member this.With([<Optional>] ?weight : Symbol,
        [<Optional>] ?grad : Symbol,
        [<Optional>] ?d : Symbol,
        [<Optional>] ?v : Symbol,
        [<Optional>] ?z : Symbol,
        [<Optional>] ?lr : float,
        [<Optional>] ?t : int,
        [<Optional>] ?beta1 : float,
        [<Optional>] ?beta2 : float,
        [<Optional>] ?epsilon : double,
        [<Optional>] ?wd : float,
        [<Optional>] ?rescaleGrad : float,
        [<Optional>] ?clipGrad : float) = 
        let operatorArguments = 
            [
                weight |> Option.map (fun x -> "weight", Input x)
                grad |> Option.map (fun x -> "grad", Input x)
                d |> Option.map (fun x -> "d", Input x)
                v |> Option.map (fun x -> "v", Input x)
                z |> Option.map (fun x -> "z", Input x)
                lr |> Option.map (fun x -> "lr", Parameter(Some (box x)))
                t |> Option.map (fun x -> "t", Parameter(Some (box x)))
                beta1 |> Option.map (fun x -> "beta1", Parameter(Some (box x)))
                beta2 |> Option.map (fun x -> "beta2", Parameter(Some (box x)))
                epsilon |> Option.map (fun x -> "epsilon", Parameter(Some (box x)))
                wd |> Option.map (fun x -> "wd", Parameter(Some (box x)))
                rescaleGrad |> Option.map (fun x -> "rescale_grad", Parameter(Some (box x)))
                clipGrad |> Option.map (fun x -> "clip_grad", Parameter(Some (box x)))
            ] |> List.choose id
        new FtmlUpdate(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type AdamUpdate private (operatorArguments) = 
    inherit SymbolOperator("adam_update", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new AdamUpdate(args)
    override this.WithArguments(args : Arguments<Symbol>) = new AdamUpdate(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <summary>Update function for Adam optimizer. Adam is seen as a generalization
    /// of AdaGrad.
    /// 
    /// Adam update consists of the following steps, where g represents gradient and m, v
    /// are 1st and 2nd order moment estimates (mean and variance).
    /// 
    /// .. math::
    /// 
    ///  g_t = \nabla J(W_{t-1})\\
    ///  m_t = \beta_1 m_{t-1} + (1 - \beta_1) g_t\\
    ///  v_t = \beta_2 v_{t-1} + (1 - \beta_2) g_t^2\\
    ///  W_t = W_{t-1} - \alpha \frac{ m_t }{ \sqrt{ v_t } + \epsilon }
    /// 
    /// It updates the weights using::
    /// 
    ///  m = beta1*m + (1-beta1)*grad
    ///  v = beta2*v + (1-beta2)*(grad**2)
    ///  w += - learning_rate * m / (sqrt(v) + epsilon)
    /// 
    /// However, if grad&#39;s storage type is ``row_sparse``, ``lazy_update`` is True and the storage
    /// type of weight is the same as those of m and v,
    /// only the row slices whose indices appear in grad.indices are updated (for w, m and v)::
    /// 
    ///  for row in grad.indices:
    ///      m[row] = beta1*m[row] + (1-beta1)*grad[row]
    ///      v[row] = beta2*v[row] + (1-beta2)*(grad[row]**2)
    ///      w[row] += - learning_rate * m[row] / (sqrt(v[row]) + epsilon)
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\optimizer_op.cc:L686</summary>
    /// <param name="weight">Weight</param>
    /// <param name="grad">Gradient</param>
    /// <param name="mean">Moving mean</param>
    /// <param name="var">Moving variance</param>
    /// <param name="lr">Learning rate</param>
    /// <param name="beta1">The decay rate for the 1st moment estimates.</param>
    /// <param name="beta2">The decay rate for the 2nd moment estimates.</param>
    /// <param name="epsilon">A small constant for numerical stability.</param>
    /// <param name="wd">Weight decay augments the objective function with a regularization term that penalizes large weights. The penalty scales with the square of the magnitude of each weight.</param>
    /// <param name="rescaleGrad">Rescale gradient to grad = rescale_grad*grad.</param>
    /// <param name="clipGradient">Clip gradient to the range of [-clip_gradient, clip_gradient] If clip_gradient &lt;= 0, gradient clipping is turned off. grad = max(min(grad, clip_gradient), -clip_gradient).</param>
    /// <param name="lazyUpdate">If true, lazy updates are applied if gradient&#39;s stype is row_sparse and all of w, m and v have the same stype</param>
    new(weight : Symbol,
        grad : Symbol,
        mean : Symbol,
        var : Symbol,
        lr : float,
        [<Optional>] ?beta1 : float,
        [<Optional>] ?beta2 : float,
        [<Optional>] ?epsilon : float,
        [<Optional>] ?wd : float,
        [<Optional>] ?rescaleGrad : float,
        [<Optional>] ?clipGradient : float,
        [<Optional>] ?lazyUpdate : bool) = 
        let operatorArguments = 
            [
                "weight", Input weight
                "grad", Input grad
                "mean", Input mean
                "var", Input var
                "lr", Parameter(Some(box lr))
                "beta1", beta1 |> Option.map box |> Parameter
                "beta2", beta2 |> Option.map box |> Parameter
                "epsilon", epsilon |> Option.map box |> Parameter
                "wd", wd |> Option.map box |> Parameter
                "rescale_grad", rescaleGrad |> Option.map box |> Parameter
                "clip_gradient", clipGradient |> Option.map box |> Parameter
                "lazy_update", lazyUpdate |> Option.map box |> Parameter
            ]
        new AdamUpdate(Arguments<Symbol>(operatorArguments))
    /// <summary>Update function for Adam optimizer. Adam is seen as a generalization
    /// of AdaGrad.
    /// 
    /// Adam update consists of the following steps, where g represents gradient and m, v
    /// are 1st and 2nd order moment estimates (mean and variance).
    /// 
    /// .. math::
    /// 
    ///  g_t = \nabla J(W_{t-1})\\
    ///  m_t = \beta_1 m_{t-1} + (1 - \beta_1) g_t\\
    ///  v_t = \beta_2 v_{t-1} + (1 - \beta_2) g_t^2\\
    ///  W_t = W_{t-1} - \alpha \frac{ m_t }{ \sqrt{ v_t } + \epsilon }
    /// 
    /// It updates the weights using::
    /// 
    ///  m = beta1*m + (1-beta1)*grad
    ///  v = beta2*v + (1-beta2)*(grad**2)
    ///  w += - learning_rate * m / (sqrt(v) + epsilon)
    /// 
    /// However, if grad&#39;s storage type is ``row_sparse``, ``lazy_update`` is True and the storage
    /// type of weight is the same as those of m and v,
    /// only the row slices whose indices appear in grad.indices are updated (for w, m and v)::
    /// 
    ///  for row in grad.indices:
    ///      m[row] = beta1*m[row] + (1-beta1)*grad[row]
    ///      v[row] = beta2*v[row] + (1-beta2)*(grad[row]**2)
    ///      w[row] += - learning_rate * m[row] / (sqrt(v[row]) + epsilon)
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\optimizer_op.cc:L686</summary>
    /// <param name="lr">Learning rate</param>
    /// <param name="weight">Weight</param>
    /// <param name="grad">Gradient</param>
    /// <param name="mean">Moving mean</param>
    /// <param name="var">Moving variance</param>
    /// <param name="beta1">The decay rate for the 1st moment estimates.</param>
    /// <param name="beta2">The decay rate for the 2nd moment estimates.</param>
    /// <param name="epsilon">A small constant for numerical stability.</param>
    /// <param name="wd">Weight decay augments the objective function with a regularization term that penalizes large weights. The penalty scales with the square of the magnitude of each weight.</param>
    /// <param name="rescaleGrad">Rescale gradient to grad = rescale_grad*grad.</param>
    /// <param name="clipGradient">Clip gradient to the range of [-clip_gradient, clip_gradient] If clip_gradient &lt;= 0, gradient clipping is turned off. grad = max(min(grad, clip_gradient), -clip_gradient).</param>
    /// <param name="lazyUpdate">If true, lazy updates are applied if gradient&#39;s stype is row_sparse and all of w, m and v have the same stype</param>
    new(lr : float,
        [<Optional>] ?weight : Symbol,
        [<Optional>] ?grad : Symbol,
        [<Optional>] ?mean : Symbol,
        [<Optional>] ?var : Symbol,
        [<Optional>] ?beta1 : float,
        [<Optional>] ?beta2 : float,
        [<Optional>] ?epsilon : float,
        [<Optional>] ?wd : float,
        [<Optional>] ?rescaleGrad : float,
        [<Optional>] ?clipGradient : float,
        [<Optional>] ?lazyUpdate : bool) = 
        let weight = defaultArg weight (new ImplicitVariable() :> Symbol)
        let grad = defaultArg grad (new ImplicitVariable() :> Symbol)
        let mean = defaultArg mean (new ImplicitVariable() :> Symbol)
        let var = defaultArg var (new ImplicitVariable() :> Symbol)
        let operatorArguments = 
            [
                "weight", Input weight
                "grad", Input grad
                "mean", Input mean
                "var", Input var
                "lr", Parameter(Some(box lr))
                "beta1", beta1 |> Option.map box |> Parameter
                "beta2", beta2 |> Option.map box |> Parameter
                "epsilon", epsilon |> Option.map box |> Parameter
                "wd", wd |> Option.map box |> Parameter
                "rescale_grad", rescaleGrad |> Option.map box |> Parameter
                "clip_gradient", clipGradient |> Option.map box |> Parameter
                "lazy_update", lazyUpdate |> Option.map box |> Parameter
            ]
        new AdamUpdate(Arguments<Symbol>(operatorArguments))
    /// Default value for Beta1
    /// The decay rate for the 1st moment estimates.
    static member Beta1Default : double = 0.899999976
    /// Default value for Beta2
    /// The decay rate for the 2nd moment estimates.
    static member Beta2Default : double = 0.999000013
    /// Default value for Epsilon
    /// A small constant for numerical stability.
    static member EpsilonDefault : double = 0.0000000099999999
    /// Default value for Wd
    /// Weight decay augments the objective function with a regularization term that penalizes large weights. The penalty scales with the square of the magnitude of each weight.
    static member WdDefault : double = 0.0
    /// Default value for RescaleGrad
    /// Rescale gradient to grad = rescale_grad*grad.
    static member RescaleGradDefault : double = 1.0
    /// Default value for ClipGradient
    /// Clip gradient to the range of [-clip_gradient, clip_gradient] If clip_gradient &lt;= 0, gradient clipping is turned off. grad = max(min(grad, clip_gradient), -clip_gradient).
    static member ClipGradientDefault : double = -1.0
    /// Default value for LazyUpdate
    /// If true, lazy updates are applied if gradient&#39;s stype is row_sparse and all of w, m and v have the same stype
    static member LazyUpdateDefault : bool = true
    /// Weight
    member __.Weight = operatorArguments.GetInput "weight"
    /// Gradient
    member __.Grad = operatorArguments.GetInput "grad"
    /// Moving mean
    member __.Mean = operatorArguments.GetInput "mean"
    /// Moving variance
    member __.Var = operatorArguments.GetInput "var"
    /// Learning rate
    member __.Lr : float = match operatorArguments.GetParameter "lr" with Some(v) -> unbox v | None -> failwithf "Required parameter lr is missing"
    /// The decay rate for the 1st moment estimates.
    member __.Beta1 = operatorArguments.GetParameter("beta1", AdamUpdate.Beta1Default)
    /// The decay rate for the 2nd moment estimates.
    member __.Beta2 = operatorArguments.GetParameter("beta2", AdamUpdate.Beta2Default)
    /// A small constant for numerical stability.
    member __.Epsilon = operatorArguments.GetParameter("epsilon", AdamUpdate.EpsilonDefault)
    /// Weight decay augments the objective function with a regularization term that penalizes large weights. The penalty scales with the square of the magnitude of each weight.
    member __.Wd = operatorArguments.GetParameter("wd", AdamUpdate.WdDefault)
    /// Rescale gradient to grad = rescale_grad*grad.
    member __.RescaleGrad = operatorArguments.GetParameter("rescale_grad", AdamUpdate.RescaleGradDefault)
    /// Clip gradient to the range of [-clip_gradient, clip_gradient] If clip_gradient &lt;= 0, gradient clipping is turned off. grad = max(min(grad, clip_gradient), -clip_gradient).
    member __.ClipGradient = operatorArguments.GetParameter("clip_gradient", AdamUpdate.ClipGradientDefault)
    /// If true, lazy updates are applied if gradient&#39;s stype is row_sparse and all of w, m and v have the same stype
    member __.LazyUpdate = operatorArguments.GetParameter("lazy_update", AdamUpdate.LazyUpdateDefault)
    /// <summary>Copy AdamUpdate instance with updated inputs/parameters.</summary>
    /// <param name="weight">Weight</param>
    /// <param name="grad">Gradient</param>
    /// <param name="mean">Moving mean</param>
    /// <param name="var">Moving variance</param>
    /// <param name="lr">Learning rate</param>
    /// <param name="beta1">The decay rate for the 1st moment estimates.</param>
    /// <param name="beta2">The decay rate for the 2nd moment estimates.</param>
    /// <param name="epsilon">A small constant for numerical stability.</param>
    /// <param name="wd">Weight decay augments the objective function with a regularization term that penalizes large weights. The penalty scales with the square of the magnitude of each weight.</param>
    /// <param name="rescaleGrad">Rescale gradient to grad = rescale_grad*grad.</param>
    /// <param name="clipGradient">Clip gradient to the range of [-clip_gradient, clip_gradient] If clip_gradient &lt;= 0, gradient clipping is turned off. grad = max(min(grad, clip_gradient), -clip_gradient).</param>
    /// <param name="lazyUpdate">If true, lazy updates are applied if gradient&#39;s stype is row_sparse and all of w, m and v have the same stype</param>
    member this.With([<Optional>] ?weight : Symbol,
        [<Optional>] ?grad : Symbol,
        [<Optional>] ?mean : Symbol,
        [<Optional>] ?var : Symbol,
        [<Optional>] ?lr : float,
        [<Optional>] ?beta1 : float,
        [<Optional>] ?beta2 : float,
        [<Optional>] ?epsilon : float,
        [<Optional>] ?wd : float,
        [<Optional>] ?rescaleGrad : float,
        [<Optional>] ?clipGradient : float,
        [<Optional>] ?lazyUpdate : bool) = 
        let operatorArguments = 
            [
                weight |> Option.map (fun x -> "weight", Input x)
                grad |> Option.map (fun x -> "grad", Input x)
                mean |> Option.map (fun x -> "mean", Input x)
                var |> Option.map (fun x -> "var", Input x)
                lr |> Option.map (fun x -> "lr", Parameter(Some (box x)))
                beta1 |> Option.map (fun x -> "beta1", Parameter(Some (box x)))
                beta2 |> Option.map (fun x -> "beta2", Parameter(Some (box x)))
                epsilon |> Option.map (fun x -> "epsilon", Parameter(Some (box x)))
                wd |> Option.map (fun x -> "wd", Parameter(Some (box x)))
                rescaleGrad |> Option.map (fun x -> "rescale_grad", Parameter(Some (box x)))
                clipGradient |> Option.map (fun x -> "clip_gradient", Parameter(Some (box x)))
                lazyUpdate |> Option.map (fun x -> "lazy_update", Parameter(Some (box x)))
            ] |> List.choose id
        new AdamUpdate(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type NagMomUpdate private (operatorArguments) = 
    inherit SymbolOperator("nag_mom_update", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new NagMomUpdate(args)
    override this.WithArguments(args : Arguments<Symbol>) = new NagMomUpdate(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <summary>Update function for Nesterov Accelerated Gradient( NAG) optimizer.
    /// It updates the weights using the following formula,
    /// 
    /// .. math::
    ///   v_t = \gamma v_{t-1} + \eta * \nabla J(W_{t-1} - \gamma v_{t-1})\\
    ///   W_t = W_{t-1} - v_t
    /// 
    /// Where 
    /// :math:`\eta` is the learning rate of the optimizer
    /// :math:`\gamma` is the decay rate of the momentum estimate
    /// :math:`\v_t` is the update vector at time step `t`
    /// :math:`\W_t` is the weight vector at time step `t`
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\optimizer_op.cc:L724</summary>
    /// <param name="weight">Weight</param>
    /// <param name="grad">Gradient</param>
    /// <param name="mom">Momentum</param>
    /// <param name="lr">Learning rate</param>
    /// <param name="momentum">The decay rate of momentum estimates at each epoch.</param>
    /// <param name="wd">Weight decay augments the objective function with a regularization term that penalizes large weights. The penalty scales with the square of the magnitude of each weight.</param>
    /// <param name="rescaleGrad">Rescale gradient to grad = rescale_grad*grad.</param>
    /// <param name="clipGradient">Clip gradient to the range of [-clip_gradient, clip_gradient] If clip_gradient &lt;= 0, gradient clipping is turned off. grad = max(min(grad, clip_gradient), -clip_gradient).</param>
    new(weight : Symbol,
        grad : Symbol,
        mom : Symbol,
        lr : float,
        [<Optional>] ?momentum : float,
        [<Optional>] ?wd : float,
        [<Optional>] ?rescaleGrad : float,
        [<Optional>] ?clipGradient : float) = 
        let operatorArguments = 
            [
                "weight", Input weight
                "grad", Input grad
                "mom", Input mom
                "lr", Parameter(Some(box lr))
                "momentum", momentum |> Option.map box |> Parameter
                "wd", wd |> Option.map box |> Parameter
                "rescale_grad", rescaleGrad |> Option.map box |> Parameter
                "clip_gradient", clipGradient |> Option.map box |> Parameter
            ]
        new NagMomUpdate(Arguments<Symbol>(operatorArguments))
    /// <summary>Update function for Nesterov Accelerated Gradient( NAG) optimizer.
    /// It updates the weights using the following formula,
    /// 
    /// .. math::
    ///   v_t = \gamma v_{t-1} + \eta * \nabla J(W_{t-1} - \gamma v_{t-1})\\
    ///   W_t = W_{t-1} - v_t
    /// 
    /// Where 
    /// :math:`\eta` is the learning rate of the optimizer
    /// :math:`\gamma` is the decay rate of the momentum estimate
    /// :math:`\v_t` is the update vector at time step `t`
    /// :math:`\W_t` is the weight vector at time step `t`
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\optimizer_op.cc:L724</summary>
    /// <param name="lr">Learning rate</param>
    /// <param name="weight">Weight</param>
    /// <param name="grad">Gradient</param>
    /// <param name="mom">Momentum</param>
    /// <param name="momentum">The decay rate of momentum estimates at each epoch.</param>
    /// <param name="wd">Weight decay augments the objective function with a regularization term that penalizes large weights. The penalty scales with the square of the magnitude of each weight.</param>
    /// <param name="rescaleGrad">Rescale gradient to grad = rescale_grad*grad.</param>
    /// <param name="clipGradient">Clip gradient to the range of [-clip_gradient, clip_gradient] If clip_gradient &lt;= 0, gradient clipping is turned off. grad = max(min(grad, clip_gradient), -clip_gradient).</param>
    new(lr : float,
        [<Optional>] ?weight : Symbol,
        [<Optional>] ?grad : Symbol,
        [<Optional>] ?mom : Symbol,
        [<Optional>] ?momentum : float,
        [<Optional>] ?wd : float,
        [<Optional>] ?rescaleGrad : float,
        [<Optional>] ?clipGradient : float) = 
        let weight = defaultArg weight (new ImplicitVariable() :> Symbol)
        let grad = defaultArg grad (new ImplicitVariable() :> Symbol)
        let mom = defaultArg mom (new ImplicitVariable() :> Symbol)
        let operatorArguments = 
            [
                "weight", Input weight
                "grad", Input grad
                "mom", Input mom
                "lr", Parameter(Some(box lr))
                "momentum", momentum |> Option.map box |> Parameter
                "wd", wd |> Option.map box |> Parameter
                "rescale_grad", rescaleGrad |> Option.map box |> Parameter
                "clip_gradient", clipGradient |> Option.map box |> Parameter
            ]
        new NagMomUpdate(Arguments<Symbol>(operatorArguments))
    /// Default value for Momentum
    /// The decay rate of momentum estimates at each epoch.
    static member MomentumDefault : double = 0.0
    /// Default value for Wd
    /// Weight decay augments the objective function with a regularization term that penalizes large weights. The penalty scales with the square of the magnitude of each weight.
    static member WdDefault : double = 0.0
    /// Default value for RescaleGrad
    /// Rescale gradient to grad = rescale_grad*grad.
    static member RescaleGradDefault : double = 1.0
    /// Default value for ClipGradient
    /// Clip gradient to the range of [-clip_gradient, clip_gradient] If clip_gradient &lt;= 0, gradient clipping is turned off. grad = max(min(grad, clip_gradient), -clip_gradient).
    static member ClipGradientDefault : double = -1.0
    /// Weight
    member __.Weight = operatorArguments.GetInput "weight"
    /// Gradient
    member __.Grad = operatorArguments.GetInput "grad"
    /// Momentum
    member __.Mom = operatorArguments.GetInput "mom"
    /// Learning rate
    member __.Lr : float = match operatorArguments.GetParameter "lr" with Some(v) -> unbox v | None -> failwithf "Required parameter lr is missing"
    /// The decay rate of momentum estimates at each epoch.
    member __.Momentum = operatorArguments.GetParameter("momentum", NagMomUpdate.MomentumDefault)
    /// Weight decay augments the objective function with a regularization term that penalizes large weights. The penalty scales with the square of the magnitude of each weight.
    member __.Wd = operatorArguments.GetParameter("wd", NagMomUpdate.WdDefault)
    /// Rescale gradient to grad = rescale_grad*grad.
    member __.RescaleGrad = operatorArguments.GetParameter("rescale_grad", NagMomUpdate.RescaleGradDefault)
    /// Clip gradient to the range of [-clip_gradient, clip_gradient] If clip_gradient &lt;= 0, gradient clipping is turned off. grad = max(min(grad, clip_gradient), -clip_gradient).
    member __.ClipGradient = operatorArguments.GetParameter("clip_gradient", NagMomUpdate.ClipGradientDefault)
    /// <summary>Copy NagMomUpdate instance with updated inputs/parameters.</summary>
    /// <param name="weight">Weight</param>
    /// <param name="grad">Gradient</param>
    /// <param name="mom">Momentum</param>
    /// <param name="lr">Learning rate</param>
    /// <param name="momentum">The decay rate of momentum estimates at each epoch.</param>
    /// <param name="wd">Weight decay augments the objective function with a regularization term that penalizes large weights. The penalty scales with the square of the magnitude of each weight.</param>
    /// <param name="rescaleGrad">Rescale gradient to grad = rescale_grad*grad.</param>
    /// <param name="clipGradient">Clip gradient to the range of [-clip_gradient, clip_gradient] If clip_gradient &lt;= 0, gradient clipping is turned off. grad = max(min(grad, clip_gradient), -clip_gradient).</param>
    member this.With([<Optional>] ?weight : Symbol,
        [<Optional>] ?grad : Symbol,
        [<Optional>] ?mom : Symbol,
        [<Optional>] ?lr : float,
        [<Optional>] ?momentum : float,
        [<Optional>] ?wd : float,
        [<Optional>] ?rescaleGrad : float,
        [<Optional>] ?clipGradient : float) = 
        let operatorArguments = 
            [
                weight |> Option.map (fun x -> "weight", Input x)
                grad |> Option.map (fun x -> "grad", Input x)
                mom |> Option.map (fun x -> "mom", Input x)
                lr |> Option.map (fun x -> "lr", Parameter(Some (box x)))
                momentum |> Option.map (fun x -> "momentum", Parameter(Some (box x)))
                wd |> Option.map (fun x -> "wd", Parameter(Some (box x)))
                rescaleGrad |> Option.map (fun x -> "rescale_grad", Parameter(Some (box x)))
                clipGradient |> Option.map (fun x -> "clip_gradient", Parameter(Some (box x)))
            ] |> List.choose id
        new NagMomUpdate(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type MpNagMomUpdate private (operatorArguments) = 
    inherit SymbolOperator("mp_nag_mom_update", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new MpNagMomUpdate(args)
    override this.WithArguments(args : Arguments<Symbol>) = new MpNagMomUpdate(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <summary>Update function for multi-precision Nesterov Accelerated Gradient( NAG) optimizer.
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\optimizer_op.cc:L743</summary>
    /// <param name="weight">Weight</param>
    /// <param name="grad">Gradient</param>
    /// <param name="mom">Momentum</param>
    /// <param name="weight32">Weight32</param>
    /// <param name="lr">Learning rate</param>
    /// <param name="momentum">The decay rate of momentum estimates at each epoch.</param>
    /// <param name="wd">Weight decay augments the objective function with a regularization term that penalizes large weights. The penalty scales with the square of the magnitude of each weight.</param>
    /// <param name="rescaleGrad">Rescale gradient to grad = rescale_grad*grad.</param>
    /// <param name="clipGradient">Clip gradient to the range of [-clip_gradient, clip_gradient] If clip_gradient &lt;= 0, gradient clipping is turned off. grad = max(min(grad, clip_gradient), -clip_gradient).</param>
    new(weight : Symbol,
        grad : Symbol,
        mom : Symbol,
        weight32 : Symbol,
        lr : float,
        [<Optional>] ?momentum : float,
        [<Optional>] ?wd : float,
        [<Optional>] ?rescaleGrad : float,
        [<Optional>] ?clipGradient : float) = 
        let operatorArguments = 
            [
                "weight", Input weight
                "grad", Input grad
                "mom", Input mom
                "weight32", Input weight32
                "lr", Parameter(Some(box lr))
                "momentum", momentum |> Option.map box |> Parameter
                "wd", wd |> Option.map box |> Parameter
                "rescale_grad", rescaleGrad |> Option.map box |> Parameter
                "clip_gradient", clipGradient |> Option.map box |> Parameter
            ]
        new MpNagMomUpdate(Arguments<Symbol>(operatorArguments))
    /// <summary>Update function for multi-precision Nesterov Accelerated Gradient( NAG) optimizer.
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\optimizer_op.cc:L743</summary>
    /// <param name="lr">Learning rate</param>
    /// <param name="weight">Weight</param>
    /// <param name="grad">Gradient</param>
    /// <param name="mom">Momentum</param>
    /// <param name="weight32">Weight32</param>
    /// <param name="momentum">The decay rate of momentum estimates at each epoch.</param>
    /// <param name="wd">Weight decay augments the objective function with a regularization term that penalizes large weights. The penalty scales with the square of the magnitude of each weight.</param>
    /// <param name="rescaleGrad">Rescale gradient to grad = rescale_grad*grad.</param>
    /// <param name="clipGradient">Clip gradient to the range of [-clip_gradient, clip_gradient] If clip_gradient &lt;= 0, gradient clipping is turned off. grad = max(min(grad, clip_gradient), -clip_gradient).</param>
    new(lr : float,
        [<Optional>] ?weight : Symbol,
        [<Optional>] ?grad : Symbol,
        [<Optional>] ?mom : Symbol,
        [<Optional>] ?weight32 : Symbol,
        [<Optional>] ?momentum : float,
        [<Optional>] ?wd : float,
        [<Optional>] ?rescaleGrad : float,
        [<Optional>] ?clipGradient : float) = 
        let weight = defaultArg weight (new ImplicitVariable() :> Symbol)
        let grad = defaultArg grad (new ImplicitVariable() :> Symbol)
        let mom = defaultArg mom (new ImplicitVariable() :> Symbol)
        let weight32 = defaultArg weight32 (new ImplicitVariable() :> Symbol)
        let operatorArguments = 
            [
                "weight", Input weight
                "grad", Input grad
                "mom", Input mom
                "weight32", Input weight32
                "lr", Parameter(Some(box lr))
                "momentum", momentum |> Option.map box |> Parameter
                "wd", wd |> Option.map box |> Parameter
                "rescale_grad", rescaleGrad |> Option.map box |> Parameter
                "clip_gradient", clipGradient |> Option.map box |> Parameter
            ]
        new MpNagMomUpdate(Arguments<Symbol>(operatorArguments))
    /// Default value for Momentum
    /// The decay rate of momentum estimates at each epoch.
    static member MomentumDefault : double = 0.0
    /// Default value for Wd
    /// Weight decay augments the objective function with a regularization term that penalizes large weights. The penalty scales with the square of the magnitude of each weight.
    static member WdDefault : double = 0.0
    /// Default value for RescaleGrad
    /// Rescale gradient to grad = rescale_grad*grad.
    static member RescaleGradDefault : double = 1.0
    /// Default value for ClipGradient
    /// Clip gradient to the range of [-clip_gradient, clip_gradient] If clip_gradient &lt;= 0, gradient clipping is turned off. grad = max(min(grad, clip_gradient), -clip_gradient).
    static member ClipGradientDefault : double = -1.0
    /// Weight
    member __.Weight = operatorArguments.GetInput "weight"
    /// Gradient
    member __.Grad = operatorArguments.GetInput "grad"
    /// Momentum
    member __.Mom = operatorArguments.GetInput "mom"
    /// Weight32
    member __.Weight32 = operatorArguments.GetInput "weight32"
    /// Learning rate
    member __.Lr : float = match operatorArguments.GetParameter "lr" with Some(v) -> unbox v | None -> failwithf "Required parameter lr is missing"
    /// The decay rate of momentum estimates at each epoch.
    member __.Momentum = operatorArguments.GetParameter("momentum", MpNagMomUpdate.MomentumDefault)
    /// Weight decay augments the objective function with a regularization term that penalizes large weights. The penalty scales with the square of the magnitude of each weight.
    member __.Wd = operatorArguments.GetParameter("wd", MpNagMomUpdate.WdDefault)
    /// Rescale gradient to grad = rescale_grad*grad.
    member __.RescaleGrad = operatorArguments.GetParameter("rescale_grad", MpNagMomUpdate.RescaleGradDefault)
    /// Clip gradient to the range of [-clip_gradient, clip_gradient] If clip_gradient &lt;= 0, gradient clipping is turned off. grad = max(min(grad, clip_gradient), -clip_gradient).
    member __.ClipGradient = operatorArguments.GetParameter("clip_gradient", MpNagMomUpdate.ClipGradientDefault)
    /// <summary>Copy MpNagMomUpdate instance with updated inputs/parameters.</summary>
    /// <param name="weight">Weight</param>
    /// <param name="grad">Gradient</param>
    /// <param name="mom">Momentum</param>
    /// <param name="weight32">Weight32</param>
    /// <param name="lr">Learning rate</param>
    /// <param name="momentum">The decay rate of momentum estimates at each epoch.</param>
    /// <param name="wd">Weight decay augments the objective function with a regularization term that penalizes large weights. The penalty scales with the square of the magnitude of each weight.</param>
    /// <param name="rescaleGrad">Rescale gradient to grad = rescale_grad*grad.</param>
    /// <param name="clipGradient">Clip gradient to the range of [-clip_gradient, clip_gradient] If clip_gradient &lt;= 0, gradient clipping is turned off. grad = max(min(grad, clip_gradient), -clip_gradient).</param>
    member this.With([<Optional>] ?weight : Symbol,
        [<Optional>] ?grad : Symbol,
        [<Optional>] ?mom : Symbol,
        [<Optional>] ?weight32 : Symbol,
        [<Optional>] ?lr : float,
        [<Optional>] ?momentum : float,
        [<Optional>] ?wd : float,
        [<Optional>] ?rescaleGrad : float,
        [<Optional>] ?clipGradient : float) = 
        let operatorArguments = 
            [
                weight |> Option.map (fun x -> "weight", Input x)
                grad |> Option.map (fun x -> "grad", Input x)
                mom |> Option.map (fun x -> "mom", Input x)
                weight32 |> Option.map (fun x -> "weight32", Input x)
                lr |> Option.map (fun x -> "lr", Parameter(Some (box x)))
                momentum |> Option.map (fun x -> "momentum", Parameter(Some (box x)))
                wd |> Option.map (fun x -> "wd", Parameter(Some (box x)))
                rescaleGrad |> Option.map (fun x -> "rescale_grad", Parameter(Some (box x)))
                clipGradient |> Option.map (fun x -> "clip_gradient", Parameter(Some (box x)))
            ] |> List.choose id
        new MpNagMomUpdate(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type RmspropUpdate private (operatorArguments) = 
    inherit SymbolOperator("rmsprop_update", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new RmspropUpdate(args)
    override this.WithArguments(args : Arguments<Symbol>) = new RmspropUpdate(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <summary>Update function for `RMSProp` optimizer.
    /// 
    /// `RMSprop` is a variant of stochastic gradient descent where the gradients are
    /// divided by a cache which grows with the sum of squares of recent gradients?
    /// 
    /// `RMSProp` is similar to `AdaGrad`, a popular variant of `SGD` which adaptively
    /// tunes the learning rate of each parameter. `AdaGrad` lowers the learning rate for
    /// each parameter monotonically over the course of training.
    /// While this is analytically motivated for convex optimizations, it may not be ideal
    /// for non-convex problems. `RMSProp` deals with this heuristically by allowing the
    /// learning rates to rebound as the denominator decays over time.
    /// 
    /// Define the Root Mean Square (RMS) error criterion of the gradient as
    /// :math:`RMS[g]_t = \sqrt{E[g^2]_t + \epsilon}`, where :math:`g` represents
    /// gradient and :math:`E[g^2]_t` is the decaying average over past squared gradient.
    /// 
    /// The :math:`E[g^2]_t` is given by:
    /// 
    /// .. math::
    ///   E[g^2]_t = \gamma * E[g^2]_{t-1} + (1-\gamma) * g_t^2
    /// 
    /// The update step is
    /// 
    /// .. math::
    ///   \theta_{t+1} = \theta_t - \frac{\eta}{RMS[g]_t} g_t
    /// 
    /// The RMSProp code follows the version in
    /// http://www.cs.toronto.edu/~tijmen/csc321/slides/lecture_slides_lec6.pdf
    /// Tieleman &amp; Hinton, 2012.
    /// 
    /// Hinton suggests the momentum term :math:`\gamma` to be 0.9 and the learning rate
    /// :math:`\eta` to be 0.001.
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\optimizer_op.cc:L795</summary>
    /// <param name="weight">Weight</param>
    /// <param name="grad">Gradient</param>
    /// <param name="n">n</param>
    /// <param name="lr">Learning rate</param>
    /// <param name="gamma1">The decay rate of momentum estimates.</param>
    /// <param name="epsilon">A small constant for numerical stability.</param>
    /// <param name="wd">Weight decay augments the objective function with a regularization term that penalizes large weights. The penalty scales with the square of the magnitude of each weight.</param>
    /// <param name="rescaleGrad">Rescale gradient to grad = rescale_grad*grad.</param>
    /// <param name="clipGradient">Clip gradient to the range of [-clip_gradient, clip_gradient] If clip_gradient &lt;= 0, gradient clipping is turned off. grad = max(min(grad, clip_gradient), -clip_gradient).</param>
    /// <param name="clipWeights">Clip weights to the range of [-clip_weights, clip_weights] If clip_weights &lt;= 0, weight clipping is turned off. weights = max(min(weights, clip_weights), -clip_weights).</param>
    new(weight : Symbol,
        grad : Symbol,
        n : Symbol,
        lr : float,
        [<Optional>] ?gamma1 : float,
        [<Optional>] ?epsilon : float,
        [<Optional>] ?wd : float,
        [<Optional>] ?rescaleGrad : float,
        [<Optional>] ?clipGradient : float,
        [<Optional>] ?clipWeights : float) = 
        let operatorArguments = 
            [
                "weight", Input weight
                "grad", Input grad
                "n", Input n
                "lr", Parameter(Some(box lr))
                "gamma1", gamma1 |> Option.map box |> Parameter
                "epsilon", epsilon |> Option.map box |> Parameter
                "wd", wd |> Option.map box |> Parameter
                "rescale_grad", rescaleGrad |> Option.map box |> Parameter
                "clip_gradient", clipGradient |> Option.map box |> Parameter
                "clip_weights", clipWeights |> Option.map box |> Parameter
            ]
        new RmspropUpdate(Arguments<Symbol>(operatorArguments))
    /// <summary>Update function for `RMSProp` optimizer.
    /// 
    /// `RMSprop` is a variant of stochastic gradient descent where the gradients are
    /// divided by a cache which grows with the sum of squares of recent gradients?
    /// 
    /// `RMSProp` is similar to `AdaGrad`, a popular variant of `SGD` which adaptively
    /// tunes the learning rate of each parameter. `AdaGrad` lowers the learning rate for
    /// each parameter monotonically over the course of training.
    /// While this is analytically motivated for convex optimizations, it may not be ideal
    /// for non-convex problems. `RMSProp` deals with this heuristically by allowing the
    /// learning rates to rebound as the denominator decays over time.
    /// 
    /// Define the Root Mean Square (RMS) error criterion of the gradient as
    /// :math:`RMS[g]_t = \sqrt{E[g^2]_t + \epsilon}`, where :math:`g` represents
    /// gradient and :math:`E[g^2]_t` is the decaying average over past squared gradient.
    /// 
    /// The :math:`E[g^2]_t` is given by:
    /// 
    /// .. math::
    ///   E[g^2]_t = \gamma * E[g^2]_{t-1} + (1-\gamma) * g_t^2
    /// 
    /// The update step is
    /// 
    /// .. math::
    ///   \theta_{t+1} = \theta_t - \frac{\eta}{RMS[g]_t} g_t
    /// 
    /// The RMSProp code follows the version in
    /// http://www.cs.toronto.edu/~tijmen/csc321/slides/lecture_slides_lec6.pdf
    /// Tieleman &amp; Hinton, 2012.
    /// 
    /// Hinton suggests the momentum term :math:`\gamma` to be 0.9 and the learning rate
    /// :math:`\eta` to be 0.001.
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\optimizer_op.cc:L795</summary>
    /// <param name="lr">Learning rate</param>
    /// <param name="weight">Weight</param>
    /// <param name="grad">Gradient</param>
    /// <param name="n">n</param>
    /// <param name="gamma1">The decay rate of momentum estimates.</param>
    /// <param name="epsilon">A small constant for numerical stability.</param>
    /// <param name="wd">Weight decay augments the objective function with a regularization term that penalizes large weights. The penalty scales with the square of the magnitude of each weight.</param>
    /// <param name="rescaleGrad">Rescale gradient to grad = rescale_grad*grad.</param>
    /// <param name="clipGradient">Clip gradient to the range of [-clip_gradient, clip_gradient] If clip_gradient &lt;= 0, gradient clipping is turned off. grad = max(min(grad, clip_gradient), -clip_gradient).</param>
    /// <param name="clipWeights">Clip weights to the range of [-clip_weights, clip_weights] If clip_weights &lt;= 0, weight clipping is turned off. weights = max(min(weights, clip_weights), -clip_weights).</param>
    new(lr : float,
        [<Optional>] ?weight : Symbol,
        [<Optional>] ?grad : Symbol,
        [<Optional>] ?n : Symbol,
        [<Optional>] ?gamma1 : float,
        [<Optional>] ?epsilon : float,
        [<Optional>] ?wd : float,
        [<Optional>] ?rescaleGrad : float,
        [<Optional>] ?clipGradient : float,
        [<Optional>] ?clipWeights : float) = 
        let weight = defaultArg weight (new ImplicitVariable() :> Symbol)
        let grad = defaultArg grad (new ImplicitVariable() :> Symbol)
        let n = defaultArg n (new ImplicitVariable() :> Symbol)
        let operatorArguments = 
            [
                "weight", Input weight
                "grad", Input grad
                "n", Input n
                "lr", Parameter(Some(box lr))
                "gamma1", gamma1 |> Option.map box |> Parameter
                "epsilon", epsilon |> Option.map box |> Parameter
                "wd", wd |> Option.map box |> Parameter
                "rescale_grad", rescaleGrad |> Option.map box |> Parameter
                "clip_gradient", clipGradient |> Option.map box |> Parameter
                "clip_weights", clipWeights |> Option.map box |> Parameter
            ]
        new RmspropUpdate(Arguments<Symbol>(operatorArguments))
    /// Default value for Gamma1
    /// The decay rate of momentum estimates.
    static member Gamma1Default : double = 0.949999988
    /// Default value for Epsilon
    /// A small constant for numerical stability.
    static member EpsilonDefault : double = 0.0000000099999999
    /// Default value for Wd
    /// Weight decay augments the objective function with a regularization term that penalizes large weights. The penalty scales with the square of the magnitude of each weight.
    static member WdDefault : double = 0.0
    /// Default value for RescaleGrad
    /// Rescale gradient to grad = rescale_grad*grad.
    static member RescaleGradDefault : double = 1.0
    /// Default value for ClipGradient
    /// Clip gradient to the range of [-clip_gradient, clip_gradient] If clip_gradient &lt;= 0, gradient clipping is turned off. grad = max(min(grad, clip_gradient), -clip_gradient).
    static member ClipGradientDefault : double = -1.0
    /// Default value for ClipWeights
    /// Clip weights to the range of [-clip_weights, clip_weights] If clip_weights &lt;= 0, weight clipping is turned off. weights = max(min(weights, clip_weights), -clip_weights).
    static member ClipWeightsDefault : double = -1.0
    /// Weight
    member __.Weight = operatorArguments.GetInput "weight"
    /// Gradient
    member __.Grad = operatorArguments.GetInput "grad"
    /// n
    member __.N = operatorArguments.GetInput "n"
    /// Learning rate
    member __.Lr : float = match operatorArguments.GetParameter "lr" with Some(v) -> unbox v | None -> failwithf "Required parameter lr is missing"
    /// The decay rate of momentum estimates.
    member __.Gamma1 = operatorArguments.GetParameter("gamma1", RmspropUpdate.Gamma1Default)
    /// A small constant for numerical stability.
    member __.Epsilon = operatorArguments.GetParameter("epsilon", RmspropUpdate.EpsilonDefault)
    /// Weight decay augments the objective function with a regularization term that penalizes large weights. The penalty scales with the square of the magnitude of each weight.
    member __.Wd = operatorArguments.GetParameter("wd", RmspropUpdate.WdDefault)
    /// Rescale gradient to grad = rescale_grad*grad.
    member __.RescaleGrad = operatorArguments.GetParameter("rescale_grad", RmspropUpdate.RescaleGradDefault)
    /// Clip gradient to the range of [-clip_gradient, clip_gradient] If clip_gradient &lt;= 0, gradient clipping is turned off. grad = max(min(grad, clip_gradient), -clip_gradient).
    member __.ClipGradient = operatorArguments.GetParameter("clip_gradient", RmspropUpdate.ClipGradientDefault)
    /// Clip weights to the range of [-clip_weights, clip_weights] If clip_weights &lt;= 0, weight clipping is turned off. weights = max(min(weights, clip_weights), -clip_weights).
    member __.ClipWeights = operatorArguments.GetParameter("clip_weights", RmspropUpdate.ClipWeightsDefault)
    /// <summary>Copy RmspropUpdate instance with updated inputs/parameters.</summary>
    /// <param name="weight">Weight</param>
    /// <param name="grad">Gradient</param>
    /// <param name="n">n</param>
    /// <param name="lr">Learning rate</param>
    /// <param name="gamma1">The decay rate of momentum estimates.</param>
    /// <param name="epsilon">A small constant for numerical stability.</param>
    /// <param name="wd">Weight decay augments the objective function with a regularization term that penalizes large weights. The penalty scales with the square of the magnitude of each weight.</param>
    /// <param name="rescaleGrad">Rescale gradient to grad = rescale_grad*grad.</param>
    /// <param name="clipGradient">Clip gradient to the range of [-clip_gradient, clip_gradient] If clip_gradient &lt;= 0, gradient clipping is turned off. grad = max(min(grad, clip_gradient), -clip_gradient).</param>
    /// <param name="clipWeights">Clip weights to the range of [-clip_weights, clip_weights] If clip_weights &lt;= 0, weight clipping is turned off. weights = max(min(weights, clip_weights), -clip_weights).</param>
    member this.With([<Optional>] ?weight : Symbol,
        [<Optional>] ?grad : Symbol,
        [<Optional>] ?n : Symbol,
        [<Optional>] ?lr : float,
        [<Optional>] ?gamma1 : float,
        [<Optional>] ?epsilon : float,
        [<Optional>] ?wd : float,
        [<Optional>] ?rescaleGrad : float,
        [<Optional>] ?clipGradient : float,
        [<Optional>] ?clipWeights : float) = 
        let operatorArguments = 
            [
                weight |> Option.map (fun x -> "weight", Input x)
                grad |> Option.map (fun x -> "grad", Input x)
                n |> Option.map (fun x -> "n", Input x)
                lr |> Option.map (fun x -> "lr", Parameter(Some (box x)))
                gamma1 |> Option.map (fun x -> "gamma1", Parameter(Some (box x)))
                epsilon |> Option.map (fun x -> "epsilon", Parameter(Some (box x)))
                wd |> Option.map (fun x -> "wd", Parameter(Some (box x)))
                rescaleGrad |> Option.map (fun x -> "rescale_grad", Parameter(Some (box x)))
                clipGradient |> Option.map (fun x -> "clip_gradient", Parameter(Some (box x)))
                clipWeights |> Option.map (fun x -> "clip_weights", Parameter(Some (box x)))
            ] |> List.choose id
        new RmspropUpdate(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type RmspropalexUpdate private (operatorArguments) = 
    inherit SymbolOperator("rmspropalex_update", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new RmspropalexUpdate(args)
    override this.WithArguments(args : Arguments<Symbol>) = new RmspropalexUpdate(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <summary>Update function for RMSPropAlex optimizer.
    /// 
    /// `RMSPropAlex` is non-centered version of `RMSProp`.
    /// 
    /// Define :math:`E[g^2]_t` is the decaying average over past squared gradient and
    /// :math:`E[g]_t` is the decaying average over past gradient.
    /// 
    /// .. math::
    ///   E[g^2]_t = \gamma_1 * E[g^2]_{t-1} + (1 - \gamma_1) * g_t^2\\
    ///   E[g]_t = \gamma_1 * E[g]_{t-1} + (1 - \gamma_1) * g_t\\
    ///   \Delta_t = \gamma_2 * \Delta_{t-1} - \frac{\eta}{\sqrt{E[g^2]_t - E[g]_t^2 + \epsilon}} g_t\\
    /// 
    /// The update step is
    /// 
    /// .. math::
    ///   \theta_{t+1} = \theta_t + \Delta_t
    /// 
    /// The RMSPropAlex code follows the version in
    /// http://arxiv.org/pdf/1308.0850v5.pdf Eq(38) - Eq(45) by Alex Graves, 2013.
    /// 
    /// Graves suggests the momentum term :math:`\gamma_1` to be 0.95, :math:`\gamma_2`
    /// to be 0.9 and the learning rate :math:`\eta` to be 0.0001.
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\optimizer_op.cc:L834</summary>
    /// <param name="weight">Weight</param>
    /// <param name="grad">Gradient</param>
    /// <param name="n">n</param>
    /// <param name="g">g</param>
    /// <param name="delta">delta</param>
    /// <param name="lr">Learning rate</param>
    /// <param name="gamma1">Decay rate.</param>
    /// <param name="gamma2">Decay rate.</param>
    /// <param name="epsilon">A small constant for numerical stability.</param>
    /// <param name="wd">Weight decay augments the objective function with a regularization term that penalizes large weights. The penalty scales with the square of the magnitude of each weight.</param>
    /// <param name="rescaleGrad">Rescale gradient to grad = rescale_grad*grad.</param>
    /// <param name="clipGradient">Clip gradient to the range of [-clip_gradient, clip_gradient] If clip_gradient &lt;= 0, gradient clipping is turned off. grad = max(min(grad, clip_gradient), -clip_gradient).</param>
    /// <param name="clipWeights">Clip weights to the range of [-clip_weights, clip_weights] If clip_weights &lt;= 0, weight clipping is turned off. weights = max(min(weights, clip_weights), -clip_weights).</param>
    new(weight : Symbol,
        grad : Symbol,
        n : Symbol,
        g : Symbol,
        delta : Symbol,
        lr : float,
        [<Optional>] ?gamma1 : float,
        [<Optional>] ?gamma2 : float,
        [<Optional>] ?epsilon : float,
        [<Optional>] ?wd : float,
        [<Optional>] ?rescaleGrad : float,
        [<Optional>] ?clipGradient : float,
        [<Optional>] ?clipWeights : float) = 
        let operatorArguments = 
            [
                "weight", Input weight
                "grad", Input grad
                "n", Input n
                "g", Input g
                "delta", Input delta
                "lr", Parameter(Some(box lr))
                "gamma1", gamma1 |> Option.map box |> Parameter
                "gamma2", gamma2 |> Option.map box |> Parameter
                "epsilon", epsilon |> Option.map box |> Parameter
                "wd", wd |> Option.map box |> Parameter
                "rescale_grad", rescaleGrad |> Option.map box |> Parameter
                "clip_gradient", clipGradient |> Option.map box |> Parameter
                "clip_weights", clipWeights |> Option.map box |> Parameter
            ]
        new RmspropalexUpdate(Arguments<Symbol>(operatorArguments))
    /// <summary>Update function for RMSPropAlex optimizer.
    /// 
    /// `RMSPropAlex` is non-centered version of `RMSProp`.
    /// 
    /// Define :math:`E[g^2]_t` is the decaying average over past squared gradient and
    /// :math:`E[g]_t` is the decaying average over past gradient.
    /// 
    /// .. math::
    ///   E[g^2]_t = \gamma_1 * E[g^2]_{t-1} + (1 - \gamma_1) * g_t^2\\
    ///   E[g]_t = \gamma_1 * E[g]_{t-1} + (1 - \gamma_1) * g_t\\
    ///   \Delta_t = \gamma_2 * \Delta_{t-1} - \frac{\eta}{\sqrt{E[g^2]_t - E[g]_t^2 + \epsilon}} g_t\\
    /// 
    /// The update step is
    /// 
    /// .. math::
    ///   \theta_{t+1} = \theta_t + \Delta_t
    /// 
    /// The RMSPropAlex code follows the version in
    /// http://arxiv.org/pdf/1308.0850v5.pdf Eq(38) - Eq(45) by Alex Graves, 2013.
    /// 
    /// Graves suggests the momentum term :math:`\gamma_1` to be 0.95, :math:`\gamma_2`
    /// to be 0.9 and the learning rate :math:`\eta` to be 0.0001.
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\optimizer_op.cc:L834</summary>
    /// <param name="lr">Learning rate</param>
    /// <param name="weight">Weight</param>
    /// <param name="grad">Gradient</param>
    /// <param name="n">n</param>
    /// <param name="g">g</param>
    /// <param name="delta">delta</param>
    /// <param name="gamma1">Decay rate.</param>
    /// <param name="gamma2">Decay rate.</param>
    /// <param name="epsilon">A small constant for numerical stability.</param>
    /// <param name="wd">Weight decay augments the objective function with a regularization term that penalizes large weights. The penalty scales with the square of the magnitude of each weight.</param>
    /// <param name="rescaleGrad">Rescale gradient to grad = rescale_grad*grad.</param>
    /// <param name="clipGradient">Clip gradient to the range of [-clip_gradient, clip_gradient] If clip_gradient &lt;= 0, gradient clipping is turned off. grad = max(min(grad, clip_gradient), -clip_gradient).</param>
    /// <param name="clipWeights">Clip weights to the range of [-clip_weights, clip_weights] If clip_weights &lt;= 0, weight clipping is turned off. weights = max(min(weights, clip_weights), -clip_weights).</param>
    new(lr : float,
        [<Optional>] ?weight : Symbol,
        [<Optional>] ?grad : Symbol,
        [<Optional>] ?n : Symbol,
        [<Optional>] ?g : Symbol,
        [<Optional>] ?delta : Symbol,
        [<Optional>] ?gamma1 : float,
        [<Optional>] ?gamma2 : float,
        [<Optional>] ?epsilon : float,
        [<Optional>] ?wd : float,
        [<Optional>] ?rescaleGrad : float,
        [<Optional>] ?clipGradient : float,
        [<Optional>] ?clipWeights : float) = 
        let weight = defaultArg weight (new ImplicitVariable() :> Symbol)
        let grad = defaultArg grad (new ImplicitVariable() :> Symbol)
        let n = defaultArg n (new ImplicitVariable() :> Symbol)
        let g = defaultArg g (new ImplicitVariable() :> Symbol)
        let delta = defaultArg delta (new ImplicitVariable() :> Symbol)
        let operatorArguments = 
            [
                "weight", Input weight
                "grad", Input grad
                "n", Input n
                "g", Input g
                "delta", Input delta
                "lr", Parameter(Some(box lr))
                "gamma1", gamma1 |> Option.map box |> Parameter
                "gamma2", gamma2 |> Option.map box |> Parameter
                "epsilon", epsilon |> Option.map box |> Parameter
                "wd", wd |> Option.map box |> Parameter
                "rescale_grad", rescaleGrad |> Option.map box |> Parameter
                "clip_gradient", clipGradient |> Option.map box |> Parameter
                "clip_weights", clipWeights |> Option.map box |> Parameter
            ]
        new RmspropalexUpdate(Arguments<Symbol>(operatorArguments))
    /// Default value for Gamma1
    /// Decay rate.
    static member Gamma1Default : double = 0.949999988
    /// Default value for Gamma2
    /// Decay rate.
    static member Gamma2Default : double = 0.899999976
    /// Default value for Epsilon
    /// A small constant for numerical stability.
    static member EpsilonDefault : double = 0.0000000099999999
    /// Default value for Wd
    /// Weight decay augments the objective function with a regularization term that penalizes large weights. The penalty scales with the square of the magnitude of each weight.
    static member WdDefault : double = 0.0
    /// Default value for RescaleGrad
    /// Rescale gradient to grad = rescale_grad*grad.
    static member RescaleGradDefault : double = 1.0
    /// Default value for ClipGradient
    /// Clip gradient to the range of [-clip_gradient, clip_gradient] If clip_gradient &lt;= 0, gradient clipping is turned off. grad = max(min(grad, clip_gradient), -clip_gradient).
    static member ClipGradientDefault : double = -1.0
    /// Default value for ClipWeights
    /// Clip weights to the range of [-clip_weights, clip_weights] If clip_weights &lt;= 0, weight clipping is turned off. weights = max(min(weights, clip_weights), -clip_weights).
    static member ClipWeightsDefault : double = -1.0
    /// Weight
    member __.Weight = operatorArguments.GetInput "weight"
    /// Gradient
    member __.Grad = operatorArguments.GetInput "grad"
    /// n
    member __.N = operatorArguments.GetInput "n"
    /// g
    member __.G = operatorArguments.GetInput "g"
    /// delta
    member __.Delta = operatorArguments.GetInput "delta"
    /// Learning rate
    member __.Lr : float = match operatorArguments.GetParameter "lr" with Some(v) -> unbox v | None -> failwithf "Required parameter lr is missing"
    /// Decay rate.
    member __.Gamma1 = operatorArguments.GetParameter("gamma1", RmspropalexUpdate.Gamma1Default)
    /// Decay rate.
    member __.Gamma2 = operatorArguments.GetParameter("gamma2", RmspropalexUpdate.Gamma2Default)
    /// A small constant for numerical stability.
    member __.Epsilon = operatorArguments.GetParameter("epsilon", RmspropalexUpdate.EpsilonDefault)
    /// Weight decay augments the objective function with a regularization term that penalizes large weights. The penalty scales with the square of the magnitude of each weight.
    member __.Wd = operatorArguments.GetParameter("wd", RmspropalexUpdate.WdDefault)
    /// Rescale gradient to grad = rescale_grad*grad.
    member __.RescaleGrad = operatorArguments.GetParameter("rescale_grad", RmspropalexUpdate.RescaleGradDefault)
    /// Clip gradient to the range of [-clip_gradient, clip_gradient] If clip_gradient &lt;= 0, gradient clipping is turned off. grad = max(min(grad, clip_gradient), -clip_gradient).
    member __.ClipGradient = operatorArguments.GetParameter("clip_gradient", RmspropalexUpdate.ClipGradientDefault)
    /// Clip weights to the range of [-clip_weights, clip_weights] If clip_weights &lt;= 0, weight clipping is turned off. weights = max(min(weights, clip_weights), -clip_weights).
    member __.ClipWeights = operatorArguments.GetParameter("clip_weights", RmspropalexUpdate.ClipWeightsDefault)
    /// <summary>Copy RmspropalexUpdate instance with updated inputs/parameters.</summary>
    /// <param name="weight">Weight</param>
    /// <param name="grad">Gradient</param>
    /// <param name="n">n</param>
    /// <param name="g">g</param>
    /// <param name="delta">delta</param>
    /// <param name="lr">Learning rate</param>
    /// <param name="gamma1">Decay rate.</param>
    /// <param name="gamma2">Decay rate.</param>
    /// <param name="epsilon">A small constant for numerical stability.</param>
    /// <param name="wd">Weight decay augments the objective function with a regularization term that penalizes large weights. The penalty scales with the square of the magnitude of each weight.</param>
    /// <param name="rescaleGrad">Rescale gradient to grad = rescale_grad*grad.</param>
    /// <param name="clipGradient">Clip gradient to the range of [-clip_gradient, clip_gradient] If clip_gradient &lt;= 0, gradient clipping is turned off. grad = max(min(grad, clip_gradient), -clip_gradient).</param>
    /// <param name="clipWeights">Clip weights to the range of [-clip_weights, clip_weights] If clip_weights &lt;= 0, weight clipping is turned off. weights = max(min(weights, clip_weights), -clip_weights).</param>
    member this.With([<Optional>] ?weight : Symbol,
        [<Optional>] ?grad : Symbol,
        [<Optional>] ?n : Symbol,
        [<Optional>] ?g : Symbol,
        [<Optional>] ?delta : Symbol,
        [<Optional>] ?lr : float,
        [<Optional>] ?gamma1 : float,
        [<Optional>] ?gamma2 : float,
        [<Optional>] ?epsilon : float,
        [<Optional>] ?wd : float,
        [<Optional>] ?rescaleGrad : float,
        [<Optional>] ?clipGradient : float,
        [<Optional>] ?clipWeights : float) = 
        let operatorArguments = 
            [
                weight |> Option.map (fun x -> "weight", Input x)
                grad |> Option.map (fun x -> "grad", Input x)
                n |> Option.map (fun x -> "n", Input x)
                g |> Option.map (fun x -> "g", Input x)
                delta |> Option.map (fun x -> "delta", Input x)
                lr |> Option.map (fun x -> "lr", Parameter(Some (box x)))
                gamma1 |> Option.map (fun x -> "gamma1", Parameter(Some (box x)))
                gamma2 |> Option.map (fun x -> "gamma2", Parameter(Some (box x)))
                epsilon |> Option.map (fun x -> "epsilon", Parameter(Some (box x)))
                wd |> Option.map (fun x -> "wd", Parameter(Some (box x)))
                rescaleGrad |> Option.map (fun x -> "rescale_grad", Parameter(Some (box x)))
                clipGradient |> Option.map (fun x -> "clip_gradient", Parameter(Some (box x)))
                clipWeights |> Option.map (fun x -> "clip_weights", Parameter(Some (box x)))
            ] |> List.choose id
        new RmspropalexUpdate(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type FtrlUpdate private (operatorArguments) = 
    inherit SymbolOperator("ftrl_update", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new FtrlUpdate(args)
    override this.WithArguments(args : Arguments<Symbol>) = new FtrlUpdate(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <summary>Update function for Ftrl optimizer.
    /// Referenced from *Ad Click Prediction: a View from the Trenches*, available at
    /// http://dl.acm.org/citation.cfm?id=2488200.
    /// 
    /// It updates the weights using::
    /// 
    ///  rescaled_grad = clip(grad * rescale_grad, clip_gradient)
    ///  z += rescaled_grad - (sqrt(n + rescaled_grad**2) - sqrt(n)) * weight / learning_rate
    ///  n += rescaled_grad**2
    ///  w = (sign(z) * lamda1 - z) / ((beta + sqrt(n)) / learning_rate + wd) * (abs(z) &gt; lamda1)
    /// 
    /// If w, z and n are all of ``row_sparse`` storage type,
    /// only the row slices whose indices appear in grad.indices are updated (for w, z and n)::
    /// 
    ///  for row in grad.indices:
    ///      rescaled_grad[row] = clip(grad[row] * rescale_grad, clip_gradient)
    ///      z[row] += rescaled_grad[row] - (sqrt(n[row] + rescaled_grad[row]**2) - sqrt(n[row])) * weight[row] / learning_rate
    ///      n[row] += rescaled_grad[row]**2
    ///      w[row] = (sign(z[row]) * lamda1 - z[row]) / ((beta + sqrt(n[row])) / learning_rate + wd) * (abs(z[row]) &gt; lamda1)
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\optimizer_op.cc:L874</summary>
    /// <param name="weight">Weight</param>
    /// <param name="grad">Gradient</param>
    /// <param name="z">z</param>
    /// <param name="n">Square of grad</param>
    /// <param name="lr">Learning rate</param>
    /// <param name="lamda1">The L1 regularization coefficient.</param>
    /// <param name="beta">Per-Coordinate Learning Rate beta.</param>
    /// <param name="wd">Weight decay augments the objective function with a regularization term that penalizes large weights. The penalty scales with the square of the magnitude of each weight.</param>
    /// <param name="rescaleGrad">Rescale gradient to grad = rescale_grad*grad.</param>
    /// <param name="clipGradient">Clip gradient to the range of [-clip_gradient, clip_gradient] If clip_gradient &lt;= 0, gradient clipping is turned off. grad = max(min(grad, clip_gradient), -clip_gradient).</param>
    new(weight : Symbol,
        grad : Symbol,
        z : Symbol,
        n : Symbol,
        lr : float,
        [<Optional>] ?lamda1 : float,
        [<Optional>] ?beta : float,
        [<Optional>] ?wd : float,
        [<Optional>] ?rescaleGrad : float,
        [<Optional>] ?clipGradient : float) = 
        let operatorArguments = 
            [
                "weight", Input weight
                "grad", Input grad
                "z", Input z
                "n", Input n
                "lr", Parameter(Some(box lr))
                "lamda1", lamda1 |> Option.map box |> Parameter
                "beta", beta |> Option.map box |> Parameter
                "wd", wd |> Option.map box |> Parameter
                "rescale_grad", rescaleGrad |> Option.map box |> Parameter
                "clip_gradient", clipGradient |> Option.map box |> Parameter
            ]
        new FtrlUpdate(Arguments<Symbol>(operatorArguments))
    /// <summary>Update function for Ftrl optimizer.
    /// Referenced from *Ad Click Prediction: a View from the Trenches*, available at
    /// http://dl.acm.org/citation.cfm?id=2488200.
    /// 
    /// It updates the weights using::
    /// 
    ///  rescaled_grad = clip(grad * rescale_grad, clip_gradient)
    ///  z += rescaled_grad - (sqrt(n + rescaled_grad**2) - sqrt(n)) * weight / learning_rate
    ///  n += rescaled_grad**2
    ///  w = (sign(z) * lamda1 - z) / ((beta + sqrt(n)) / learning_rate + wd) * (abs(z) &gt; lamda1)
    /// 
    /// If w, z and n are all of ``row_sparse`` storage type,
    /// only the row slices whose indices appear in grad.indices are updated (for w, z and n)::
    /// 
    ///  for row in grad.indices:
    ///      rescaled_grad[row] = clip(grad[row] * rescale_grad, clip_gradient)
    ///      z[row] += rescaled_grad[row] - (sqrt(n[row] + rescaled_grad[row]**2) - sqrt(n[row])) * weight[row] / learning_rate
    ///      n[row] += rescaled_grad[row]**2
    ///      w[row] = (sign(z[row]) * lamda1 - z[row]) / ((beta + sqrt(n[row])) / learning_rate + wd) * (abs(z[row]) &gt; lamda1)
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\optimizer_op.cc:L874</summary>
    /// <param name="lr">Learning rate</param>
    /// <param name="weight">Weight</param>
    /// <param name="grad">Gradient</param>
    /// <param name="z">z</param>
    /// <param name="n">Square of grad</param>
    /// <param name="lamda1">The L1 regularization coefficient.</param>
    /// <param name="beta">Per-Coordinate Learning Rate beta.</param>
    /// <param name="wd">Weight decay augments the objective function with a regularization term that penalizes large weights. The penalty scales with the square of the magnitude of each weight.</param>
    /// <param name="rescaleGrad">Rescale gradient to grad = rescale_grad*grad.</param>
    /// <param name="clipGradient">Clip gradient to the range of [-clip_gradient, clip_gradient] If clip_gradient &lt;= 0, gradient clipping is turned off. grad = max(min(grad, clip_gradient), -clip_gradient).</param>
    new(lr : float,
        [<Optional>] ?weight : Symbol,
        [<Optional>] ?grad : Symbol,
        [<Optional>] ?z : Symbol,
        [<Optional>] ?n : Symbol,
        [<Optional>] ?lamda1 : float,
        [<Optional>] ?beta : float,
        [<Optional>] ?wd : float,
        [<Optional>] ?rescaleGrad : float,
        [<Optional>] ?clipGradient : float) = 
        let weight = defaultArg weight (new ImplicitVariable() :> Symbol)
        let grad = defaultArg grad (new ImplicitVariable() :> Symbol)
        let z = defaultArg z (new ImplicitVariable() :> Symbol)
        let n = defaultArg n (new ImplicitVariable() :> Symbol)
        let operatorArguments = 
            [
                "weight", Input weight
                "grad", Input grad
                "z", Input z
                "n", Input n
                "lr", Parameter(Some(box lr))
                "lamda1", lamda1 |> Option.map box |> Parameter
                "beta", beta |> Option.map box |> Parameter
                "wd", wd |> Option.map box |> Parameter
                "rescale_grad", rescaleGrad |> Option.map box |> Parameter
                "clip_gradient", clipGradient |> Option.map box |> Parameter
            ]
        new FtrlUpdate(Arguments<Symbol>(operatorArguments))
    /// Default value for Lamda1
    /// The L1 regularization coefficient.
    static member Lamda1Default : double = 0.00999999978
    /// Default value for Beta
    /// Per-Coordinate Learning Rate beta.
    static member BetaDefault : double = 1.0
    /// Default value for Wd
    /// Weight decay augments the objective function with a regularization term that penalizes large weights. The penalty scales with the square of the magnitude of each weight.
    static member WdDefault : double = 0.0
    /// Default value for RescaleGrad
    /// Rescale gradient to grad = rescale_grad*grad.
    static member RescaleGradDefault : double = 1.0
    /// Default value for ClipGradient
    /// Clip gradient to the range of [-clip_gradient, clip_gradient] If clip_gradient &lt;= 0, gradient clipping is turned off. grad = max(min(grad, clip_gradient), -clip_gradient).
    static member ClipGradientDefault : double = -1.0
    /// Weight
    member __.Weight = operatorArguments.GetInput "weight"
    /// Gradient
    member __.Grad = operatorArguments.GetInput "grad"
    /// z
    member __.Z = operatorArguments.GetInput "z"
    /// Square of grad
    member __.N = operatorArguments.GetInput "n"
    /// Learning rate
    member __.Lr : float = match operatorArguments.GetParameter "lr" with Some(v) -> unbox v | None -> failwithf "Required parameter lr is missing"
    /// The L1 regularization coefficient.
    member __.Lamda1 = operatorArguments.GetParameter("lamda1", FtrlUpdate.Lamda1Default)
    /// Per-Coordinate Learning Rate beta.
    member __.Beta = operatorArguments.GetParameter("beta", FtrlUpdate.BetaDefault)
    /// Weight decay augments the objective function with a regularization term that penalizes large weights. The penalty scales with the square of the magnitude of each weight.
    member __.Wd = operatorArguments.GetParameter("wd", FtrlUpdate.WdDefault)
    /// Rescale gradient to grad = rescale_grad*grad.
    member __.RescaleGrad = operatorArguments.GetParameter("rescale_grad", FtrlUpdate.RescaleGradDefault)
    /// Clip gradient to the range of [-clip_gradient, clip_gradient] If clip_gradient &lt;= 0, gradient clipping is turned off. grad = max(min(grad, clip_gradient), -clip_gradient).
    member __.ClipGradient = operatorArguments.GetParameter("clip_gradient", FtrlUpdate.ClipGradientDefault)
    /// <summary>Copy FtrlUpdate instance with updated inputs/parameters.</summary>
    /// <param name="weight">Weight</param>
    /// <param name="grad">Gradient</param>
    /// <param name="z">z</param>
    /// <param name="n">Square of grad</param>
    /// <param name="lr">Learning rate</param>
    /// <param name="lamda1">The L1 regularization coefficient.</param>
    /// <param name="beta">Per-Coordinate Learning Rate beta.</param>
    /// <param name="wd">Weight decay augments the objective function with a regularization term that penalizes large weights. The penalty scales with the square of the magnitude of each weight.</param>
    /// <param name="rescaleGrad">Rescale gradient to grad = rescale_grad*grad.</param>
    /// <param name="clipGradient">Clip gradient to the range of [-clip_gradient, clip_gradient] If clip_gradient &lt;= 0, gradient clipping is turned off. grad = max(min(grad, clip_gradient), -clip_gradient).</param>
    member this.With([<Optional>] ?weight : Symbol,
        [<Optional>] ?grad : Symbol,
        [<Optional>] ?z : Symbol,
        [<Optional>] ?n : Symbol,
        [<Optional>] ?lr : float,
        [<Optional>] ?lamda1 : float,
        [<Optional>] ?beta : float,
        [<Optional>] ?wd : float,
        [<Optional>] ?rescaleGrad : float,
        [<Optional>] ?clipGradient : float) = 
        let operatorArguments = 
            [
                weight |> Option.map (fun x -> "weight", Input x)
                grad |> Option.map (fun x -> "grad", Input x)
                z |> Option.map (fun x -> "z", Input x)
                n |> Option.map (fun x -> "n", Input x)
                lr |> Option.map (fun x -> "lr", Parameter(Some (box x)))
                lamda1 |> Option.map (fun x -> "lamda1", Parameter(Some (box x)))
                beta |> Option.map (fun x -> "beta", Parameter(Some (box x)))
                wd |> Option.map (fun x -> "wd", Parameter(Some (box x)))
                rescaleGrad |> Option.map (fun x -> "rescale_grad", Parameter(Some (box x)))
                clipGradient |> Option.map (fun x -> "clip_gradient", Parameter(Some (box x)))
            ] |> List.choose id
        new FtrlUpdate(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type SparseAdagradUpdate private (operatorArguments) = 
    inherit SymbolOperator("_sparse_adagrad_update", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new SparseAdagradUpdate(args)
    override this.WithArguments(args : Arguments<Symbol>) = new SparseAdagradUpdate(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <summary>Update function for AdaGrad optimizer.
    /// 
    /// Referenced from *Adaptive Subgradient Methods for Online Learning and Stochastic Optimization*,
    /// and available at http://www.jmlr.org/papers/volume12/duchi11a/duchi11a.pdf.
    /// 
    /// Updates are applied by::
    /// 
    ///     rescaled_grad = clip(grad * rescale_grad, clip_gradient)
    ///     history = history + square(rescaled_grad)
    ///     w = w - learning_rate * rescaled_grad / sqrt(history + epsilon)
    /// 
    /// Note that non-zero values for the weight decay option are not supported.
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\optimizer_op.cc:L907</summary>
    /// <param name="weight">Weight</param>
    /// <param name="grad">Gradient</param>
    /// <param name="history">History</param>
    /// <param name="lr">Learning rate</param>
    /// <param name="epsilon">epsilon</param>
    /// <param name="wd">weight decay</param>
    /// <param name="rescaleGrad">Rescale gradient to grad = rescale_grad*grad.</param>
    /// <param name="clipGradient">Clip gradient to the range of [-clip_gradient, clip_gradient] If clip_gradient &lt;= 0, gradient clipping is turned off. grad = max(min(grad, clip_gradient), -clip_gradient).</param>
    new(weight : Symbol,
        grad : Symbol,
        history : Symbol,
        lr : float,
        [<Optional>] ?epsilon : float,
        [<Optional>] ?wd : float,
        [<Optional>] ?rescaleGrad : float,
        [<Optional>] ?clipGradient : float) = 
        let operatorArguments = 
            [
                "weight", Input weight
                "grad", Input grad
                "history", Input history
                "lr", Parameter(Some(box lr))
                "epsilon", epsilon |> Option.map box |> Parameter
                "wd", wd |> Option.map box |> Parameter
                "rescale_grad", rescaleGrad |> Option.map box |> Parameter
                "clip_gradient", clipGradient |> Option.map box |> Parameter
            ]
        new SparseAdagradUpdate(Arguments<Symbol>(operatorArguments))
    /// <summary>Update function for AdaGrad optimizer.
    /// 
    /// Referenced from *Adaptive Subgradient Methods for Online Learning and Stochastic Optimization*,
    /// and available at http://www.jmlr.org/papers/volume12/duchi11a/duchi11a.pdf.
    /// 
    /// Updates are applied by::
    /// 
    ///     rescaled_grad = clip(grad * rescale_grad, clip_gradient)
    ///     history = history + square(rescaled_grad)
    ///     w = w - learning_rate * rescaled_grad / sqrt(history + epsilon)
    /// 
    /// Note that non-zero values for the weight decay option are not supported.
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\optimizer_op.cc:L907</summary>
    /// <param name="lr">Learning rate</param>
    /// <param name="weight">Weight</param>
    /// <param name="grad">Gradient</param>
    /// <param name="history">History</param>
    /// <param name="epsilon">epsilon</param>
    /// <param name="wd">weight decay</param>
    /// <param name="rescaleGrad">Rescale gradient to grad = rescale_grad*grad.</param>
    /// <param name="clipGradient">Clip gradient to the range of [-clip_gradient, clip_gradient] If clip_gradient &lt;= 0, gradient clipping is turned off. grad = max(min(grad, clip_gradient), -clip_gradient).</param>
    new(lr : float,
        [<Optional>] ?weight : Symbol,
        [<Optional>] ?grad : Symbol,
        [<Optional>] ?history : Symbol,
        [<Optional>] ?epsilon : float,
        [<Optional>] ?wd : float,
        [<Optional>] ?rescaleGrad : float,
        [<Optional>] ?clipGradient : float) = 
        let weight = defaultArg weight (new ImplicitVariable() :> Symbol)
        let grad = defaultArg grad (new ImplicitVariable() :> Symbol)
        let history = defaultArg history (new ImplicitVariable() :> Symbol)
        let operatorArguments = 
            [
                "weight", Input weight
                "grad", Input grad
                "history", Input history
                "lr", Parameter(Some(box lr))
                "epsilon", epsilon |> Option.map box |> Parameter
                "wd", wd |> Option.map box |> Parameter
                "rescale_grad", rescaleGrad |> Option.map box |> Parameter
                "clip_gradient", clipGradient |> Option.map box |> Parameter
            ]
        new SparseAdagradUpdate(Arguments<Symbol>(operatorArguments))
    /// Default value for Epsilon
    /// epsilon
    static member EpsilonDefault : double = 0.000000100000001
    /// Default value for Wd
    /// weight decay
    static member WdDefault : double = 0.0
    /// Default value for RescaleGrad
    /// Rescale gradient to grad = rescale_grad*grad.
    static member RescaleGradDefault : double = 1.0
    /// Default value for ClipGradient
    /// Clip gradient to the range of [-clip_gradient, clip_gradient] If clip_gradient &lt;= 0, gradient clipping is turned off. grad = max(min(grad, clip_gradient), -clip_gradient).
    static member ClipGradientDefault : double = -1.0
    /// Weight
    member __.Weight = operatorArguments.GetInput "weight"
    /// Gradient
    member __.Grad = operatorArguments.GetInput "grad"
    /// History
    member __.History = operatorArguments.GetInput "history"
    /// Learning rate
    member __.Lr : float = match operatorArguments.GetParameter "lr" with Some(v) -> unbox v | None -> failwithf "Required parameter lr is missing"
    /// epsilon
    member __.Epsilon = operatorArguments.GetParameter("epsilon", SparseAdagradUpdate.EpsilonDefault)
    /// weight decay
    member __.Wd = operatorArguments.GetParameter("wd", SparseAdagradUpdate.WdDefault)
    /// Rescale gradient to grad = rescale_grad*grad.
    member __.RescaleGrad = operatorArguments.GetParameter("rescale_grad", SparseAdagradUpdate.RescaleGradDefault)
    /// Clip gradient to the range of [-clip_gradient, clip_gradient] If clip_gradient &lt;= 0, gradient clipping is turned off. grad = max(min(grad, clip_gradient), -clip_gradient).
    member __.ClipGradient = operatorArguments.GetParameter("clip_gradient", SparseAdagradUpdate.ClipGradientDefault)
    /// <summary>Copy SparseAdagradUpdate instance with updated inputs/parameters.</summary>
    /// <param name="weight">Weight</param>
    /// <param name="grad">Gradient</param>
    /// <param name="history">History</param>
    /// <param name="lr">Learning rate</param>
    /// <param name="epsilon">epsilon</param>
    /// <param name="wd">weight decay</param>
    /// <param name="rescaleGrad">Rescale gradient to grad = rescale_grad*grad.</param>
    /// <param name="clipGradient">Clip gradient to the range of [-clip_gradient, clip_gradient] If clip_gradient &lt;= 0, gradient clipping is turned off. grad = max(min(grad, clip_gradient), -clip_gradient).</param>
    member this.With([<Optional>] ?weight : Symbol,
        [<Optional>] ?grad : Symbol,
        [<Optional>] ?history : Symbol,
        [<Optional>] ?lr : float,
        [<Optional>] ?epsilon : float,
        [<Optional>] ?wd : float,
        [<Optional>] ?rescaleGrad : float,
        [<Optional>] ?clipGradient : float) = 
        let operatorArguments = 
            [
                weight |> Option.map (fun x -> "weight", Input x)
                grad |> Option.map (fun x -> "grad", Input x)
                history |> Option.map (fun x -> "history", Input x)
                lr |> Option.map (fun x -> "lr", Parameter(Some (box x)))
                epsilon |> Option.map (fun x -> "epsilon", Parameter(Some (box x)))
                wd |> Option.map (fun x -> "wd", Parameter(Some (box x)))
                rescaleGrad |> Option.map (fun x -> "rescale_grad", Parameter(Some (box x)))
                clipGradient |> Option.map (fun x -> "clip_gradient", Parameter(Some (box x)))
            ] |> List.choose id
        new SparseAdagradUpdate(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type Pad private (operatorArguments) = 
    inherit SymbolOperator("Pad", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new Pad(args)
    override this.WithArguments(args : Arguments<Symbol>) = new Pad(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <summary>Pads an input array with a constant or edge values of the array.
    /// 
    /// .. note:: `Pad` is deprecated. Use `pad` instead.
    /// 
    /// .. note:: Current implementation only supports 4D and 5D input arrays with padding applied
    ///    only on axes 1, 2 and 3. Expects axes 4 and 5 in `pad_width` to be zero.
    /// 
    /// This operation pads an input array with either a `constant_value` or edge values
    /// along each axis of the input array. The amount of padding is specified by `pad_width`.
    /// 
    /// `pad_width` is a tuple of integer padding widths for each axis of the format
    /// ``(before_1, after_1, ... , before_N, after_N)``. The `pad_width` should be of length ``2*N``
    /// where ``N`` is the number of dimensions of the array.
    /// 
    /// For dimension ``N`` of the input array, ``before_N`` and ``after_N`` indicates how many values
    /// to add before and after the elements of the array along dimension ``N``.
    /// The widths of the higher two dimensions ``before_1``, ``after_1``, ``before_2``,
    /// ``after_2`` must be 0.
    /// 
    /// Example::
    /// 
    ///    x = [[[[  1.   2.   3.]
    ///           [  4.   5.   6.]]
    /// 
    ///          [[  7.   8.   9.]
    ///           [ 10.  11.  12.]]]
    /// 
    /// 
    ///         [[[ 11.  12.  13.]
    ///           [ 14.  15.  16.]]
    /// 
    ///          [[ 17.  18.  19.]
    ///           [ 20.  21.  22.]]]]
    /// 
    ///    pad(x,mode=&quot;edge&quot;, pad_width=(0,0,0,0,1,1,1,1)) =
    /// 
    ///          [[[[  1.   1.   2.   3.   3.]
    ///             [  1.   1.   2.   3.   3.]
    ///             [  4.   4.   5.   6.   6.]
    ///             [  4.   4.   5.   6.   6.]]
    /// 
    ///            [[  7.   7.   8.   9.   9.]
    ///             [  7.   7.   8.   9.   9.]
    ///             [ 10.  10.  11.  12.  12.]
    ///             [ 10.  10.  11.  12.  12.]]]
    /// 
    /// 
    ///           [[[ 11.  11.  12.  13.  13.]
    ///             [ 11.  11.  12.  13.  13.]
    ///             [ 14.  14.  15.  16.  16.]
    ///             [ 14.  14.  15.  16.  16.]]
    /// 
    ///            [[ 17.  17.  18.  19.  19.]
    ///             [ 17.  17.  18.  19.  19.]
    ///             [ 20.  20.  21.  22.  22.]
    ///             [ 20.  20.  21.  22.  22.]]]]
    /// 
    ///    pad(x, mode=&quot;constant&quot;, constant_value=0, pad_width=(0,0,0,0,1,1,1,1)) =
    /// 
    ///          [[[[  0.   0.   0.   0.   0.]
    ///             [  0.   1.   2.   3.   0.]
    ///             [  0.   4.   5.   6.   0.]
    ///             [  0.   0.   0.   0.   0.]]
    /// 
    ///            [[  0.   0.   0.   0.   0.]
    ///             [  0.   7.   8.   9.   0.]
    ///             [  0.  10.  11.  12.   0.]
    ///             [  0.   0.   0.   0.   0.]]]
    /// 
    /// 
    ///           [[[  0.   0.   0.   0.   0.]
    ///             [  0.  11.  12.  13.   0.]
    ///             [  0.  14.  15.  16.   0.]
    ///             [  0.   0.   0.   0.   0.]]
    /// 
    ///            [[  0.   0.   0.   0.   0.]
    ///             [  0.  17.  18.  19.   0.]
    ///             [  0.  20.  21.  22.   0.]
    ///             [  0.   0.   0.   0.   0.]]]]
    /// 
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\pad.cc:L766</summary>
    /// <param name="data">An n-dimensional input array.</param>
    /// <param name="mode">Padding type to use. &quot;constant&quot; pads with `constant_value` &quot;edge&quot; pads using the edge values of the input array &quot;reflect&quot; pads by reflecting values with respect to the edges.</param>
    /// <param name="padWidth">Widths of the padding regions applied to the edges of each axis. It is a tuple of integer padding widths for each axis of the format ``(before_1, after_1, ... , before_N, after_N)``. It should be of length ``2*N`` where ``N`` is the number of dimensions of the array.This is equivalent to pad_width in numpy.pad, but flattened.</param>
    /// <param name="constantValue">The value used for padding when `mode` is &quot;constant&quot;.</param>
    new(data : Symbol,
        mode : PadMode,
        padWidth : int seq,
        [<Optional>] ?constantValue : double) = 
        let operatorArguments = 
            [
                "data", Input data
                "mode", Parameter(Some(box mode))
                "pad_width", Parameter(Some(box padWidth))
                "constant_value", constantValue |> Option.map box |> Parameter
            ]
        new Pad(Arguments<Symbol>(operatorArguments))
    /// <summary>Pads an input array with a constant or edge values of the array.
    /// 
    /// .. note:: `Pad` is deprecated. Use `pad` instead.
    /// 
    /// .. note:: Current implementation only supports 4D and 5D input arrays with padding applied
    ///    only on axes 1, 2 and 3. Expects axes 4 and 5 in `pad_width` to be zero.
    /// 
    /// This operation pads an input array with either a `constant_value` or edge values
    /// along each axis of the input array. The amount of padding is specified by `pad_width`.
    /// 
    /// `pad_width` is a tuple of integer padding widths for each axis of the format
    /// ``(before_1, after_1, ... , before_N, after_N)``. The `pad_width` should be of length ``2*N``
    /// where ``N`` is the number of dimensions of the array.
    /// 
    /// For dimension ``N`` of the input array, ``before_N`` and ``after_N`` indicates how many values
    /// to add before and after the elements of the array along dimension ``N``.
    /// The widths of the higher two dimensions ``before_1``, ``after_1``, ``before_2``,
    /// ``after_2`` must be 0.
    /// 
    /// Example::
    /// 
    ///    x = [[[[  1.   2.   3.]
    ///           [  4.   5.   6.]]
    /// 
    ///          [[  7.   8.   9.]
    ///           [ 10.  11.  12.]]]
    /// 
    /// 
    ///         [[[ 11.  12.  13.]
    ///           [ 14.  15.  16.]]
    /// 
    ///          [[ 17.  18.  19.]
    ///           [ 20.  21.  22.]]]]
    /// 
    ///    pad(x,mode=&quot;edge&quot;, pad_width=(0,0,0,0,1,1,1,1)) =
    /// 
    ///          [[[[  1.   1.   2.   3.   3.]
    ///             [  1.   1.   2.   3.   3.]
    ///             [  4.   4.   5.   6.   6.]
    ///             [  4.   4.   5.   6.   6.]]
    /// 
    ///            [[  7.   7.   8.   9.   9.]
    ///             [  7.   7.   8.   9.   9.]
    ///             [ 10.  10.  11.  12.  12.]
    ///             [ 10.  10.  11.  12.  12.]]]
    /// 
    /// 
    ///           [[[ 11.  11.  12.  13.  13.]
    ///             [ 11.  11.  12.  13.  13.]
    ///             [ 14.  14.  15.  16.  16.]
    ///             [ 14.  14.  15.  16.  16.]]
    /// 
    ///            [[ 17.  17.  18.  19.  19.]
    ///             [ 17.  17.  18.  19.  19.]
    ///             [ 20.  20.  21.  22.  22.]
    ///             [ 20.  20.  21.  22.  22.]]]]
    /// 
    ///    pad(x, mode=&quot;constant&quot;, constant_value=0, pad_width=(0,0,0,0,1,1,1,1)) =
    /// 
    ///          [[[[  0.   0.   0.   0.   0.]
    ///             [  0.   1.   2.   3.   0.]
    ///             [  0.   4.   5.   6.   0.]
    ///             [  0.   0.   0.   0.   0.]]
    /// 
    ///            [[  0.   0.   0.   0.   0.]
    ///             [  0.   7.   8.   9.   0.]
    ///             [  0.  10.  11.  12.   0.]
    ///             [  0.   0.   0.   0.   0.]]]
    /// 
    /// 
    ///           [[[  0.   0.   0.   0.   0.]
    ///             [  0.  11.  12.  13.   0.]
    ///             [  0.  14.  15.  16.   0.]
    ///             [  0.   0.   0.   0.   0.]]
    /// 
    ///            [[  0.   0.   0.   0.   0.]
    ///             [  0.  17.  18.  19.   0.]
    ///             [  0.  20.  21.  22.   0.]
    ///             [  0.   0.   0.   0.   0.]]]]
    /// 
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\pad.cc:L766</summary>
    /// <param name="mode">Padding type to use. &quot;constant&quot; pads with `constant_value` &quot;edge&quot; pads using the edge values of the input array &quot;reflect&quot; pads by reflecting values with respect to the edges.</param>
    /// <param name="padWidth">Widths of the padding regions applied to the edges of each axis. It is a tuple of integer padding widths for each axis of the format ``(before_1, after_1, ... , before_N, after_N)``. It should be of length ``2*N`` where ``N`` is the number of dimensions of the array.This is equivalent to pad_width in numpy.pad, but flattened.</param>
    /// <param name="data">An n-dimensional input array.</param>
    /// <param name="constantValue">The value used for padding when `mode` is &quot;constant&quot;.</param>
    new(mode : PadMode,
        padWidth : int seq,
        [<Optional>] ?data : Symbol,
        [<Optional>] ?constantValue : double) = 
        let data = defaultArg data (new ImplicitVariable() :> Symbol)
        let operatorArguments = 
            [
                "data", Input data
                "mode", Parameter(Some(box mode))
                "pad_width", Parameter(Some(box padWidth))
                "constant_value", constantValue |> Option.map box |> Parameter
            ]
        new Pad(Arguments<Symbol>(operatorArguments))
    /// Default value for ConstantValue
    /// The value used for padding when `mode` is &quot;constant&quot;.
    static member ConstantValueDefault : double = 0.0
    /// An n-dimensional input array.
    member __.Data = operatorArguments.GetInput "data"
    /// Padding type to use. &quot;constant&quot; pads with `constant_value` &quot;edge&quot; pads using the edge values of the input array &quot;reflect&quot; pads by reflecting values with respect to the edges.
    member __.Mode : PadMode = match operatorArguments.GetParameter "mode" with Some(v) -> unbox v | None -> failwithf "Required parameter mode is missing"
    /// Widths of the padding regions applied to the edges of each axis. It is a tuple of integer padding widths for each axis of the format ``(before_1, after_1, ... , before_N, after_N)``. It should be of length ``2*N`` where ``N`` is the number of dimensions of the array.This is equivalent to pad_width in numpy.pad, but flattened.
    member __.PadWidth : int seq = match operatorArguments.GetParameter "pad_width" with Some(v) -> unbox v | None -> failwithf "Required parameter pad_width is missing"
    /// The value used for padding when `mode` is &quot;constant&quot;.
    member __.ConstantValue = operatorArguments.GetParameter("constant_value", Pad.ConstantValueDefault)
    /// <summary>Copy Pad instance with updated inputs/parameters.</summary>
    /// <param name="data">An n-dimensional input array.</param>
    /// <param name="mode">Padding type to use. &quot;constant&quot; pads with `constant_value` &quot;edge&quot; pads using the edge values of the input array &quot;reflect&quot; pads by reflecting values with respect to the edges.</param>
    /// <param name="padWidth">Widths of the padding regions applied to the edges of each axis. It is a tuple of integer padding widths for each axis of the format ``(before_1, after_1, ... , before_N, after_N)``. It should be of length ``2*N`` where ``N`` is the number of dimensions of the array.This is equivalent to pad_width in numpy.pad, but flattened.</param>
    /// <param name="constantValue">The value used for padding when `mode` is &quot;constant&quot;.</param>
    member this.With([<Optional>] ?data : Symbol,
        [<Optional>] ?mode : PadMode,
        [<Optional>] ?padWidth : int seq,
        [<Optional>] ?constantValue : double) = 
        let operatorArguments = 
            [
                data |> Option.map (fun x -> "data", Input x)
                mode |> Option.map (fun x -> "mode", Parameter(Some (box x)))
                padWidth |> Option.map (fun x -> "pad_width", Parameter(Some (box x)))
                constantValue |> Option.map (fun x -> "constant_value", Parameter(Some (box x)))
            ] |> List.choose id
        new Pad(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type ContribCalibrateEntropy private (operatorArguments) = 
    inherit SymbolOperator("_contrib_calibrate_entropy", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new ContribCalibrateEntropy(args)
    override this.WithArguments(args : Arguments<Symbol>) = new ContribCalibrateEntropy(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <summary>Provide calibrated min/max for input histogram.
    /// 
    /// .. Note::
    ///     This operator only supports forward propagation. DO NOT use it in training.
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\quantization\calibrate.cc:L197</summary>
    /// <param name="hist">A ndarray/symbol of type `float32`</param>
    /// <param name="histEdges">A ndarray/symbol of type `float32`</param>
    /// <param name="numQuantizedBins">The number of quantized bins.</param>
    new([<Optional>] ?hist : Symbol,
        [<Optional>] ?histEdges : Symbol,
        [<Optional>] ?numQuantizedBins : int) = 
        let hist = defaultArg hist (new ImplicitVariable() :> Symbol)
        let histEdges = defaultArg histEdges (new ImplicitVariable() :> Symbol)
        let operatorArguments = 
            [
                "hist", Input hist
                "hist_edges", Input histEdges
                "num_quantized_bins", numQuantizedBins |> Option.map box |> Parameter
            ]
        new ContribCalibrateEntropy(Arguments<Symbol>(operatorArguments))
    /// Default value for NumQuantizedBins
    /// The number of quantized bins.
    static member NumQuantizedBinsDefault : int = 255
    /// A ndarray/symbol of type `float32`
    member __.Hist = operatorArguments.GetInput "hist"
    /// A ndarray/symbol of type `float32`
    member __.HistEdges = operatorArguments.GetInput "hist_edges"
    /// The number of quantized bins.
    member __.NumQuantizedBins = operatorArguments.GetParameter("num_quantized_bins", ContribCalibrateEntropy.NumQuantizedBinsDefault)
    /// <summary>Copy ContribCalibrateEntropy instance with updated inputs/parameters.</summary>
    /// <param name="hist">A ndarray/symbol of type `float32`</param>
    /// <param name="histEdges">A ndarray/symbol of type `float32`</param>
    /// <param name="numQuantizedBins">The number of quantized bins.</param>
    member this.With([<Optional>] ?hist : Symbol,
        [<Optional>] ?histEdges : Symbol,
        [<Optional>] ?numQuantizedBins : int) = 
        let operatorArguments = 
            [
                hist |> Option.map (fun x -> "hist", Input x)
                histEdges |> Option.map (fun x -> "hist_edges", Input x)
                numQuantizedBins |> Option.map (fun x -> "num_quantized_bins", Parameter(Some (box x)))
            ] |> List.choose id
        new ContribCalibrateEntropy(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type ContribDequantize private (operatorArguments) = 
    inherit SymbolOperator("_contrib_dequantize", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new ContribDequantize(args)
    override this.WithArguments(args : Arguments<Symbol>) = new ContribDequantize(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <summary>Dequantize the input tensor into a float tensor.
    /// min_range and max_range are scalar floats that specify the range for
    /// the output data.
    /// 
    /// When input data type is `uint8`, the output is calculated using the following equation:
    /// 
    /// `out[i] = in[i] * (max_range - min_range) / 255.0`,
    /// 
    /// When input data type is `int8`, the output is calculate using the following equation
    /// by keep zero centered for the quantized value:
    /// 
    /// `out[i] = in[i] * MaxAbs(min_range, max_range) / 127.0`,
    /// 
    /// .. Note::
    ///     This operator only supports forward propogation. DO NOT use it in training.
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\quantization\dequantize.cc:L83</summary>
    /// <param name="data">A ndarray/symbol of type `uint8`</param>
    /// <param name="minRange">The minimum scalar value possibly produced for the input in float32</param>
    /// <param name="maxRange">The maximum scalar value possibly produced for the input in float32</param>
    /// <param name="outType">Output data type.</param>
    new([<Optional>] ?data : Symbol,
        [<Optional>] ?minRange : Symbol,
        [<Optional>] ?maxRange : Symbol,
        [<Optional>] ?outType : ContribDequantizeOutType) = 
        let data = defaultArg data (new ImplicitVariable() :> Symbol)
        let minRange = defaultArg minRange (new ImplicitVariable() :> Symbol)
        let maxRange = defaultArg maxRange (new ImplicitVariable() :> Symbol)
        let operatorArguments = 
            [
                "data", Input data
                "min_range", Input minRange
                "max_range", Input maxRange
                "out_type", outType |> Option.map box |> Parameter
            ]
        new ContribDequantize(Arguments<Symbol>(operatorArguments))
    /// Default value for OutType
    /// Output data type.
    static member OutTypeDefault : ContribDequantizeOutType = ContribDequantizeOutType.Float32
    /// A ndarray/symbol of type `uint8`
    member __.Data = operatorArguments.GetInput "data"
    /// The minimum scalar value possibly produced for the input in float32
    member __.MinRange = operatorArguments.GetInput "min_range"
    /// The maximum scalar value possibly produced for the input in float32
    member __.MaxRange = operatorArguments.GetInput "max_range"
    /// Output data type.
    member __.OutType = operatorArguments.GetParameter("out_type", ContribDequantize.OutTypeDefault)
    /// <summary>Copy ContribDequantize instance with updated inputs/parameters.</summary>
    /// <param name="data">A ndarray/symbol of type `uint8`</param>
    /// <param name="minRange">The minimum scalar value possibly produced for the input in float32</param>
    /// <param name="maxRange">The maximum scalar value possibly produced for the input in float32</param>
    /// <param name="outType">Output data type.</param>
    member this.With([<Optional>] ?data : Symbol,
        [<Optional>] ?minRange : Symbol,
        [<Optional>] ?maxRange : Symbol,
        [<Optional>] ?outType : ContribDequantizeOutType) = 
        let operatorArguments = 
            [
                data |> Option.map (fun x -> "data", Input x)
                minRange |> Option.map (fun x -> "min_range", Input x)
                maxRange |> Option.map (fun x -> "max_range", Input x)
                outType |> Option.map (fun x -> "out_type", Parameter(Some (box x)))
            ] |> List.choose id
        new ContribDequantize(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type ContribQuantize private (operatorArguments) = 
    inherit SymbolOperator("_contrib_quantize", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new ContribQuantize(args)
    override this.WithArguments(args : Arguments<Symbol>) = new ContribQuantize(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <summary>Quantize a input tensor from float to `out_type`,
    /// with user-specified `min_range` and `max_range`.
    /// 
    /// min_range and max_range are scalar floats that specify the range for
    /// the input data.
    /// 
    /// When out_type is `uint8`, the output is calculated using the following equation:
    /// 
    /// `out[i] = (in[i] - min_range) * range(OUTPUT_TYPE) / (max_range - min_range) + 0.5`,
    /// 
    /// where `range(T) = numeric_limits&lt;T&gt;::max() - numeric_limits&lt;T&gt;::min()`.
    /// 
    /// When out_type is `int8`, the output is calculate using the following equation
    /// by keep zero centered for the quantized value:
    /// 
    /// `out[i] = sign(in[i]) * min(abs(in[i] * scale + 0.5f, quantized_range)`,
    /// 
    /// where
    /// `quantized_range = MinAbs(max(int8), min(int8))` and
    /// `scale = quantized_range / MaxAbs(min_range, max_range).`
    /// 
    /// .. Note::
    ///     This operator only supports forward propagation. DO NOT use it in training.
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\quantization\quantize.cc:L74</summary>
    /// <param name="data">A ndarray/symbol of type `float32`</param>
    /// <param name="minRange">The minimum scalar value possibly produced for the input</param>
    /// <param name="maxRange">The maximum scalar value possibly produced for the input</param>
    /// <param name="outType">Output data type.</param>
    new([<Optional>] ?data : Symbol,
        [<Optional>] ?minRange : Symbol,
        [<Optional>] ?maxRange : Symbol,
        [<Optional>] ?outType : ContribQuantizeOutType) = 
        let data = defaultArg data (new ImplicitVariable() :> Symbol)
        let minRange = defaultArg minRange (new ImplicitVariable() :> Symbol)
        let maxRange = defaultArg maxRange (new ImplicitVariable() :> Symbol)
        let operatorArguments = 
            [
                "data", Input data
                "min_range", Input minRange
                "max_range", Input maxRange
                "out_type", outType |> Option.map box |> Parameter
            ]
        new ContribQuantize(Arguments<Symbol>(operatorArguments))
    /// Default value for OutType
    /// Output data type.
    static member OutTypeDefault : ContribQuantizeOutType = ContribQuantizeOutType.Uint8
    /// A ndarray/symbol of type `float32`
    member __.Data = operatorArguments.GetInput "data"
    /// The minimum scalar value possibly produced for the input
    member __.MinRange = operatorArguments.GetInput "min_range"
    /// The maximum scalar value possibly produced for the input
    member __.MaxRange = operatorArguments.GetInput "max_range"
    /// Output data type.
    member __.OutType = operatorArguments.GetParameter("out_type", ContribQuantize.OutTypeDefault)
    /// <summary>Copy ContribQuantize instance with updated inputs/parameters.</summary>
    /// <param name="data">A ndarray/symbol of type `float32`</param>
    /// <param name="minRange">The minimum scalar value possibly produced for the input</param>
    /// <param name="maxRange">The maximum scalar value possibly produced for the input</param>
    /// <param name="outType">Output data type.</param>
    member this.With([<Optional>] ?data : Symbol,
        [<Optional>] ?minRange : Symbol,
        [<Optional>] ?maxRange : Symbol,
        [<Optional>] ?outType : ContribQuantizeOutType) = 
        let operatorArguments = 
            [
                data |> Option.map (fun x -> "data", Input x)
                minRange |> Option.map (fun x -> "min_range", Input x)
                maxRange |> Option.map (fun x -> "max_range", Input x)
                outType |> Option.map (fun x -> "out_type", Parameter(Some (box x)))
            ] |> List.choose id
        new ContribQuantize(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type ContribQuantizeV2 private (operatorArguments) = 
    inherit SymbolOperator("_contrib_quantize_v2", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new ContribQuantizeV2(args)
    override this.WithArguments(args : Arguments<Symbol>) = new ContribQuantizeV2(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <summary>Quantize a input tensor from float to `out_type`,
    /// with user-specified `min_calib_range` and `max_calib_range` or the input range collected at runtime.
    /// 
    /// Output `min_range` and `max_range` are scalar floats that specify the range for the input data.
    /// 
    /// When out_type is `uint8`, the output is calculated using the following equation:
    /// 
    /// `out[i] = (in[i] - min_range) * range(OUTPUT_TYPE) / (max_range - min_range) + 0.5`,
    /// 
    /// where `range(T) = numeric_limits&lt;T&gt;::max() - numeric_limits&lt;T&gt;::min()`.
    /// 
    /// When out_type is `int8`, the output is calculate using the following equation
    /// by keep zero centered for the quantized value:
    /// 
    /// `out[i] = sign(in[i]) * min(abs(in[i] * scale + 0.5f, quantized_range)`,
    /// 
    /// where
    /// `quantized_range = MinAbs(max(int8), min(int8))` and
    /// `scale = quantized_range / MaxAbs(min_range, max_range).`
    /// 
    /// When out_type is `auto`, the output type is automatically determined by min_calib_range if presented.
    /// If min_calib_range &lt; 0.0f, the output type will be int8, otherwise will be uint8.
    /// If min_calib_range isn&#39;t presented, the output type will be int8.
    /// 
    /// .. Note::
    ///     This operator only supports forward propagation. DO NOT use it in training.
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\quantization\quantize_v2.cc:L92</summary>
    /// <param name="data">A ndarray/symbol of type `float32`</param>
    /// <param name="outType">Output data type. `auto` can be specified to automatically determine output type according to min_calib_range.</param>
    /// <param name="minCalibRange">The minimum scalar value in the form of float32. If present, it will be used to quantize the fp32 data into int8 or uint8.</param>
    /// <param name="maxCalibRange">The maximum scalar value in the form of float32. If present, it will be used to quantize the fp32 data into int8 or uint8.</param>
    new([<Optional>] ?data : Symbol,
        [<Optional>] ?outType : ContribQuantizeV2OutType,
        [<Optional>] ?minCalibRange : float,
        [<Optional>] ?maxCalibRange : float) = 
        let data = defaultArg data (new ImplicitVariable() :> Symbol)
        let operatorArguments = 
            [
                "data", Input data
                "out_type", outType |> Option.map box |> Parameter
                "min_calib_range", minCalibRange |> Option.map box |> Parameter
                "max_calib_range", maxCalibRange |> Option.map box |> Parameter
            ]
        new ContribQuantizeV2(Arguments<Symbol>(operatorArguments))
    /// Default value for OutType
    /// Output data type. `auto` can be specified to automatically determine output type according to min_calib_range.
    static member OutTypeDefault : ContribQuantizeV2OutType = ContribQuantizeV2OutType.Int8
    /// Default value for MinCalibRange
    /// The minimum scalar value in the form of float32. If present, it will be used to quantize the fp32 data into int8 or uint8.
    static member MinCalibRangeDefault : double option = None
    /// Default value for MaxCalibRange
    /// The maximum scalar value in the form of float32. If present, it will be used to quantize the fp32 data into int8 or uint8.
    static member MaxCalibRangeDefault : double option = None
    /// A ndarray/symbol of type `float32`
    member __.Data = operatorArguments.GetInput "data"
    /// Output data type. `auto` can be specified to automatically determine output type according to min_calib_range.
    member __.OutType = operatorArguments.GetParameter("out_type", ContribQuantizeV2.OutTypeDefault)
    /// The minimum scalar value in the form of float32. If present, it will be used to quantize the fp32 data into int8 or uint8.
    member __.MinCalibRange = operatorArguments.GetParameter("min_calib_range", ContribQuantizeV2.MinCalibRangeDefault)
    /// The maximum scalar value in the form of float32. If present, it will be used to quantize the fp32 data into int8 or uint8.
    member __.MaxCalibRange = operatorArguments.GetParameter("max_calib_range", ContribQuantizeV2.MaxCalibRangeDefault)
    /// <summary>Copy ContribQuantizeV2 instance with updated inputs/parameters.</summary>
    /// <param name="data">A ndarray/symbol of type `float32`</param>
    /// <param name="outType">Output data type. `auto` can be specified to automatically determine output type according to min_calib_range.</param>
    /// <param name="minCalibRange">The minimum scalar value in the form of float32. If present, it will be used to quantize the fp32 data into int8 or uint8.</param>
    /// <param name="maxCalibRange">The maximum scalar value in the form of float32. If present, it will be used to quantize the fp32 data into int8 or uint8.</param>
    member this.With([<Optional>] ?data : Symbol,
        [<Optional>] ?outType : ContribQuantizeV2OutType,
        [<Optional>] ?minCalibRange : float,
        [<Optional>] ?maxCalibRange : float) = 
        let operatorArguments = 
            [
                data |> Option.map (fun x -> "data", Input x)
                outType |> Option.map (fun x -> "out_type", Parameter(Some (box x)))
                minCalibRange |> Option.map (fun x -> "min_calib_range", Parameter(Some (box x)))
                maxCalibRange |> Option.map (fun x -> "max_calib_range", Parameter(Some (box x)))
            ] |> List.choose id
        new ContribQuantizeV2(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type ContribQuantizedAct private (operatorArguments) = 
    inherit SymbolOperator("_contrib_quantized_act", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new ContribQuantizedAct(args)
    override this.WithArguments(args : Arguments<Symbol>) = new ContribQuantizedAct(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <summary>Activation operator for input and output data type of int8.
    /// The input and output data comes with min and max thresholds for quantizing
    /// the float32 data into int8.
    /// 
    /// .. Note::
    ///      This operator only supports forward propogation. DO NOT use it in training.
    ///      This operator only supports `relu`
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\quantization\quantized_activation.cc:L91</summary>
    /// <param name="data">Input data.</param>
    /// <param name="minData">Minimum value of data.</param>
    /// <param name="maxData">Maximum value of data.</param>
    /// <param name="actType">Activation function to be applied.</param>
    new(data : Symbol,
        minData : Symbol,
        maxData : Symbol,
        actType : ActType) = 
        let operatorArguments = 
            [
                "data", Input data
                "min_data", Input minData
                "max_data", Input maxData
                "act_type", Parameter(Some(box actType))
            ]
        new ContribQuantizedAct(Arguments<Symbol>(operatorArguments))
    /// <summary>Activation operator for input and output data type of int8.
    /// The input and output data comes with min and max thresholds for quantizing
    /// the float32 data into int8.
    /// 
    /// .. Note::
    ///      This operator only supports forward propogation. DO NOT use it in training.
    ///      This operator only supports `relu`
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\quantization\quantized_activation.cc:L91</summary>
    /// <param name="actType">Activation function to be applied.</param>
    /// <param name="data">Input data.</param>
    /// <param name="minData">Minimum value of data.</param>
    /// <param name="maxData">Maximum value of data.</param>
    new(actType : ActType,
        [<Optional>] ?data : Symbol,
        [<Optional>] ?minData : Symbol,
        [<Optional>] ?maxData : Symbol) = 
        let data = defaultArg data (new ImplicitVariable() :> Symbol)
        let minData = defaultArg minData (new ImplicitVariable() :> Symbol)
        let maxData = defaultArg maxData (new ImplicitVariable() :> Symbol)
        let operatorArguments = 
            [
                "data", Input data
                "min_data", Input minData
                "max_data", Input maxData
                "act_type", Parameter(Some(box actType))
            ]
        new ContribQuantizedAct(Arguments<Symbol>(operatorArguments))
    /// Input data.
    member __.Data = operatorArguments.GetInput "data"
    /// Minimum value of data.
    member __.MinData = operatorArguments.GetInput "min_data"
    /// Maximum value of data.
    member __.MaxData = operatorArguments.GetInput "max_data"
    /// Activation function to be applied.
    member __.ActType : ActType = match operatorArguments.GetParameter "act_type" with Some(v) -> unbox v | None -> failwithf "Required parameter act_type is missing"
    /// <summary>Copy ContribQuantizedAct instance with updated inputs/parameters.</summary>
    /// <param name="data">Input data.</param>
    /// <param name="minData">Minimum value of data.</param>
    /// <param name="maxData">Maximum value of data.</param>
    /// <param name="actType">Activation function to be applied.</param>
    member this.With([<Optional>] ?data : Symbol,
        [<Optional>] ?minData : Symbol,
        [<Optional>] ?maxData : Symbol,
        [<Optional>] ?actType : ActType) = 
        let operatorArguments = 
            [
                data |> Option.map (fun x -> "data", Input x)
                minData |> Option.map (fun x -> "min_data", Input x)
                maxData |> Option.map (fun x -> "max_data", Input x)
                actType |> Option.map (fun x -> "act_type", Parameter(Some (box x)))
            ] |> List.choose id
        new ContribQuantizedAct(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type ContribQuantizedBatchNorm private (operatorArguments) = 
    inherit SymbolOperator("_contrib_quantized_batch_norm", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new ContribQuantizedBatchNorm(args)
    override this.WithArguments(args : Arguments<Symbol>) = new ContribQuantizedBatchNorm(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <summary>BatchNorm operator for input and output data type of int8.
    /// The input and output data comes with min and max thresholds for quantizing
    /// the float32 data into int8.
    /// 
    /// .. Note::
    ///     This operator only supports forward propogation. DO NOT use it in training.
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\quantization\quantized_batch_norm.cc:L95</summary>
    /// <param name="data">Input data.</param>
    /// <param name="gamma">gamma.</param>
    /// <param name="beta">beta.</param>
    /// <param name="movingMean">moving_mean.</param>
    /// <param name="movingVar">moving_var.</param>
    /// <param name="minData">Minimum value of data.</param>
    /// <param name="maxData">Maximum value of data.</param>
    /// <param name="eps">Epsilon to prevent div 0. Must be no less than CUDNN_BN_MIN_EPSILON defined in cudnn.h when using cudnn (usually 1e-5)</param>
    /// <param name="momentum">Momentum for moving average</param>
    /// <param name="fixGamma">Fix gamma while training</param>
    /// <param name="useGlobalStats">Whether use global moving statistics instead of local batch-norm. This will force change batch-norm into a scale shift operator.</param>
    /// <param name="outputMeanVar">Output the mean and inverse std </param>
    /// <param name="axis">Specify which shape axis the channel is specified</param>
    /// <param name="cudnnOff">Do not select CUDNN operator, if available</param>
    /// <param name="minCalibRange">The minimum scalar value in the form of float32 obtained through calibration. If present, it will be used to by quantized batch norm op to calculate primitive scale.Note: this calib_range is to calib bn output.</param>
    /// <param name="maxCalibRange">The maximum scalar value in the form of float32 obtained through calibration. If present, it will be used to by quantized batch norm op to calculate primitive scale.Note: this calib_range is to calib bn output.</param>
    new([<Optional>] ?data : Symbol,
        [<Optional>] ?gamma : Symbol,
        [<Optional>] ?beta : Symbol,
        [<Optional>] ?movingMean : Symbol,
        [<Optional>] ?movingVar : Symbol,
        [<Optional>] ?minData : Symbol,
        [<Optional>] ?maxData : Symbol,
        [<Optional>] ?eps : double,
        [<Optional>] ?momentum : float,
        [<Optional>] ?fixGamma : bool,
        [<Optional>] ?useGlobalStats : bool,
        [<Optional>] ?outputMeanVar : bool,
        [<Optional>] ?axis : int,
        [<Optional>] ?cudnnOff : bool,
        [<Optional>] ?minCalibRange : float,
        [<Optional>] ?maxCalibRange : float) = 
        let data = defaultArg data (new ImplicitVariable() :> Symbol)
        let gamma = defaultArg gamma (new ImplicitVariable() :> Symbol)
        let beta = defaultArg beta (new ImplicitVariable() :> Symbol)
        let movingMean = defaultArg movingMean (new ImplicitVariable() :> Symbol)
        let movingVar = defaultArg movingVar (new ImplicitVariable() :> Symbol)
        let minData = defaultArg minData (new ImplicitVariable() :> Symbol)
        let maxData = defaultArg maxData (new ImplicitVariable() :> Symbol)
        let operatorArguments = 
            [
                "data", Input data
                "gamma", Input gamma
                "beta", Input beta
                "moving_mean", Input movingMean
                "moving_var", Input movingVar
                "min_data", Input minData
                "max_data", Input maxData
                "eps", eps |> Option.map box |> Parameter
                "momentum", momentum |> Option.map box |> Parameter
                "fix_gamma", fixGamma |> Option.map box |> Parameter
                "use_global_stats", useGlobalStats |> Option.map box |> Parameter
                "output_mean_var", outputMeanVar |> Option.map box |> Parameter
                "axis", axis |> Option.map box |> Parameter
                "cudnn_off", cudnnOff |> Option.map box |> Parameter
                "min_calib_range", minCalibRange |> Option.map box |> Parameter
                "max_calib_range", maxCalibRange |> Option.map box |> Parameter
            ]
        new ContribQuantizedBatchNorm(Arguments<Symbol>(operatorArguments))
    /// Default value for Eps
    /// Epsilon to prevent div 0. Must be no less than CUDNN_BN_MIN_EPSILON defined in cudnn.h when using cudnn (usually 1e-5)
    static member EpsDefault : double = 0.0010000000474975
    /// Default value for Momentum
    /// Momentum for moving average
    static member MomentumDefault : double = 0.899999976
    /// Default value for FixGamma
    /// Fix gamma while training
    static member FixGammaDefault : bool = true
    /// Default value for UseGlobalStats
    /// Whether use global moving statistics instead of local batch-norm. This will force change batch-norm into a scale shift operator.
    static member UseGlobalStatsDefault : bool = false
    /// Default value for OutputMeanVar
    /// Output the mean and inverse std 
    static member OutputMeanVarDefault : bool = false
    /// Default value for Axis
    /// Specify which shape axis the channel is specified
    static member AxisDefault : int = 1
    /// Default value for CudnnOff
    /// Do not select CUDNN operator, if available
    static member CudnnOffDefault : bool = false
    /// Default value for MinCalibRange
    /// The minimum scalar value in the form of float32 obtained through calibration. If present, it will be used to by quantized batch norm op to calculate primitive scale.Note: this calib_range is to calib bn output.
    static member MinCalibRangeDefault : double option = None
    /// Default value for MaxCalibRange
    /// The maximum scalar value in the form of float32 obtained through calibration. If present, it will be used to by quantized batch norm op to calculate primitive scale.Note: this calib_range is to calib bn output.
    static member MaxCalibRangeDefault : double option = None
    /// Input data.
    member __.Data = operatorArguments.GetInput "data"
    /// gamma.
    member __.Gamma = operatorArguments.GetInput "gamma"
    /// beta.
    member __.Beta = operatorArguments.GetInput "beta"
    /// moving_mean.
    member __.MovingMean = operatorArguments.GetInput "moving_mean"
    /// moving_var.
    member __.MovingVar = operatorArguments.GetInput "moving_var"
    /// Minimum value of data.
    member __.MinData = operatorArguments.GetInput "min_data"
    /// Maximum value of data.
    member __.MaxData = operatorArguments.GetInput "max_data"
    /// Epsilon to prevent div 0. Must be no less than CUDNN_BN_MIN_EPSILON defined in cudnn.h when using cudnn (usually 1e-5)
    member __.Eps = operatorArguments.GetParameter("eps", ContribQuantizedBatchNorm.EpsDefault)
    /// Momentum for moving average
    member __.Momentum = operatorArguments.GetParameter("momentum", ContribQuantizedBatchNorm.MomentumDefault)
    /// Fix gamma while training
    member __.FixGamma = operatorArguments.GetParameter("fix_gamma", ContribQuantizedBatchNorm.FixGammaDefault)
    /// Whether use global moving statistics instead of local batch-norm. This will force change batch-norm into a scale shift operator.
    member __.UseGlobalStats = operatorArguments.GetParameter("use_global_stats", ContribQuantizedBatchNorm.UseGlobalStatsDefault)
    /// Output the mean and inverse std 
    member __.OutputMeanVar = operatorArguments.GetParameter("output_mean_var", ContribQuantizedBatchNorm.OutputMeanVarDefault)
    /// Specify which shape axis the channel is specified
    member __.Axis = operatorArguments.GetParameter("axis", ContribQuantizedBatchNorm.AxisDefault)
    /// Do not select CUDNN operator, if available
    member __.CudnnOff = operatorArguments.GetParameter("cudnn_off", ContribQuantizedBatchNorm.CudnnOffDefault)
    /// The minimum scalar value in the form of float32 obtained through calibration. If present, it will be used to by quantized batch norm op to calculate primitive scale.Note: this calib_range is to calib bn output.
    member __.MinCalibRange = operatorArguments.GetParameter("min_calib_range", ContribQuantizedBatchNorm.MinCalibRangeDefault)
    /// The maximum scalar value in the form of float32 obtained through calibration. If present, it will be used to by quantized batch norm op to calculate primitive scale.Note: this calib_range is to calib bn output.
    member __.MaxCalibRange = operatorArguments.GetParameter("max_calib_range", ContribQuantizedBatchNorm.MaxCalibRangeDefault)
    /// <summary>Copy ContribQuantizedBatchNorm instance with updated inputs/parameters.</summary>
    /// <param name="data">Input data.</param>
    /// <param name="gamma">gamma.</param>
    /// <param name="beta">beta.</param>
    /// <param name="movingMean">moving_mean.</param>
    /// <param name="movingVar">moving_var.</param>
    /// <param name="minData">Minimum value of data.</param>
    /// <param name="maxData">Maximum value of data.</param>
    /// <param name="eps">Epsilon to prevent div 0. Must be no less than CUDNN_BN_MIN_EPSILON defined in cudnn.h when using cudnn (usually 1e-5)</param>
    /// <param name="momentum">Momentum for moving average</param>
    /// <param name="fixGamma">Fix gamma while training</param>
    /// <param name="useGlobalStats">Whether use global moving statistics instead of local batch-norm. This will force change batch-norm into a scale shift operator.</param>
    /// <param name="outputMeanVar">Output the mean and inverse std </param>
    /// <param name="axis">Specify which shape axis the channel is specified</param>
    /// <param name="cudnnOff">Do not select CUDNN operator, if available</param>
    /// <param name="minCalibRange">The minimum scalar value in the form of float32 obtained through calibration. If present, it will be used to by quantized batch norm op to calculate primitive scale.Note: this calib_range is to calib bn output.</param>
    /// <param name="maxCalibRange">The maximum scalar value in the form of float32 obtained through calibration. If present, it will be used to by quantized batch norm op to calculate primitive scale.Note: this calib_range is to calib bn output.</param>
    member this.With([<Optional>] ?data : Symbol,
        [<Optional>] ?gamma : Symbol,
        [<Optional>] ?beta : Symbol,
        [<Optional>] ?movingMean : Symbol,
        [<Optional>] ?movingVar : Symbol,
        [<Optional>] ?minData : Symbol,
        [<Optional>] ?maxData : Symbol,
        [<Optional>] ?eps : double,
        [<Optional>] ?momentum : float,
        [<Optional>] ?fixGamma : bool,
        [<Optional>] ?useGlobalStats : bool,
        [<Optional>] ?outputMeanVar : bool,
        [<Optional>] ?axis : int,
        [<Optional>] ?cudnnOff : bool,
        [<Optional>] ?minCalibRange : float,
        [<Optional>] ?maxCalibRange : float) = 
        let operatorArguments = 
            [
                data |> Option.map (fun x -> "data", Input x)
                gamma |> Option.map (fun x -> "gamma", Input x)
                beta |> Option.map (fun x -> "beta", Input x)
                movingMean |> Option.map (fun x -> "moving_mean", Input x)
                movingVar |> Option.map (fun x -> "moving_var", Input x)
                minData |> Option.map (fun x -> "min_data", Input x)
                maxData |> Option.map (fun x -> "max_data", Input x)
                eps |> Option.map (fun x -> "eps", Parameter(Some (box x)))
                momentum |> Option.map (fun x -> "momentum", Parameter(Some (box x)))
                fixGamma |> Option.map (fun x -> "fix_gamma", Parameter(Some (box x)))
                useGlobalStats |> Option.map (fun x -> "use_global_stats", Parameter(Some (box x)))
                outputMeanVar |> Option.map (fun x -> "output_mean_var", Parameter(Some (box x)))
                axis |> Option.map (fun x -> "axis", Parameter(Some (box x)))
                cudnnOff |> Option.map (fun x -> "cudnn_off", Parameter(Some (box x)))
                minCalibRange |> Option.map (fun x -> "min_calib_range", Parameter(Some (box x)))
                maxCalibRange |> Option.map (fun x -> "max_calib_range", Parameter(Some (box x)))
            ] |> List.choose id
        new ContribQuantizedBatchNorm(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type ContribQuantizedConcat private (operatorArguments) = 
    inherit SymbolOperator("_contrib_quantized_concat", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new ContribQuantizedConcat(args)
    override this.WithArguments(args : Arguments<Symbol>) = new ContribQuantizedConcat(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <summary>Joins input arrays along a given axis.
    /// 
    /// The dimensions of the input arrays should be the same except the axis along
    /// which they will be concatenated.
    /// The dimension of the output array along the concatenated axis will be equal
    /// to the sum of the corresponding dimensions of the input arrays.
    /// All inputs with different min/max will be rescaled by using largest [min, max] pairs.
    /// If any input holds int8, then the output will be int8. Otherwise output will be uint8.
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\quantization\quantized_concat.cc:L108</summary>
    /// <param name="data">List of arrays to concatenate</param>
    /// <param name="dim">the dimension to be concated.</param>
    new([<Optional>] ?data : Symbol seq,
        [<Optional>] ?dim : int) = 
        let data = defaultArg (data |> Option.map Seq.toArray) Array.empty
        let operatorArguments = 
            [
                "data", VarArg("num_args", data)
                "dim", dim |> Option.map box |> Parameter
            ]
        new ContribQuantizedConcat(Arguments<Symbol>(operatorArguments))
    /// Default value for Dim
    /// the dimension to be concated.
    static member DimDefault : int = 1
    /// List of arrays to concatenate
    member __.Data = operatorArguments.GetVarArg "data"
    /// the dimension to be concated.
    member __.Dim = operatorArguments.GetParameter("dim", ContribQuantizedConcat.DimDefault)
    /// <summary>Copy ContribQuantizedConcat instance with updated inputs/parameters.</summary>
    /// <param name="data">List of arrays to concatenate</param>
    /// <param name="dim">the dimension to be concated.</param>
    member this.With([<Optional>] ?data : Symbol seq,
        [<Optional>] ?dim : int) = 
        let operatorArguments = 
            [
                data |> Option.map (fun x -> "data", VarArg("num_args", Seq.toArray x))
                dim |> Option.map (fun x -> "dim", Parameter(Some (box x)))
            ] |> List.choose id
        new ContribQuantizedConcat(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type ContribQuantizedConv private (operatorArguments) = 
    inherit SymbolOperator("_contrib_quantized_conv", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new ContribQuantizedConv(args)
    override this.WithArguments(args : Arguments<Symbol>) = new ContribQuantizedConv(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <summary>Convolution operator for input, weight and bias data type of int8,
    /// and accumulates in type int32 for the output. For each argument, two more arguments of type
    /// float32 must be provided representing the thresholds of quantizing argument from data
    /// type float32 to int8. The final outputs contain the convolution result in int32, and min
    /// and max thresholds representing the threholds for quantizing the float32 output into int32.
    /// 
    /// .. Note::
    ///     This operator only supports forward propogation. DO NOT use it in training.
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\quantization\quantized_conv.cc:L137</summary>
    /// <param name="data">Input data.</param>
    /// <param name="weight">weight.</param>
    /// <param name="bias">bias.</param>
    /// <param name="minData">Minimum value of data.</param>
    /// <param name="maxData">Maximum value of data.</param>
    /// <param name="minWeight">Minimum value of weight.</param>
    /// <param name="maxWeight">Maximum value of weight.</param>
    /// <param name="minBias">Minimum value of bias.</param>
    /// <param name="maxBias">Maximum value of bias.</param>
    /// <param name="kernel">Convolution kernel size: (w,), (h, w) or (d, h, w)</param>
    /// <param name="numFilter">Convolution filter(channel) number</param>
    /// <param name="stride">Convolution stride: (w,), (h, w) or (d, h, w). Defaults to 1 for each dimension.</param>
    /// <param name="dilate">Convolution dilate: (w,), (h, w) or (d, h, w). Defaults to 1 for each dimension.</param>
    /// <param name="pad">Zero pad for convolution: (w,), (h, w) or (d, h, w). Defaults to no padding.</param>
    /// <param name="numGroup">Number of group partitions.</param>
    /// <param name="workspace">Maximum temporary workspace allowed (MB) in convolution.This parameter has two usages. When CUDNN is not used, it determines the effective batch size of the convolution kernel. When CUDNN is used, it controls the maximum temporary storage used for tuning the best CUDNN kernel when `limited_workspace` strategy is used.</param>
    /// <param name="noBias">Whether to disable bias parameter.</param>
    /// <param name="cudnnTune">Whether to pick convolution algo by running performance test.</param>
    /// <param name="cudnnOff">Turn off cudnn for this layer.</param>
    /// <param name="layout">Set layout for input, output and weight. Empty for
    ///     default layout: NCW for 1d, NCHW for 2d and NCDHW for 3d.NHWC and NDHWC are only supported on GPU.</param>
    new(data : Symbol,
        weight : Symbol,
        bias : Symbol,
        minData : Symbol,
        maxData : Symbol,
        minWeight : Symbol,
        maxWeight : Symbol,
        minBias : Symbol,
        maxBias : Symbol,
        kernel : int seq,
        numFilter : int,
        [<Optional>] ?stride : int seq,
        [<Optional>] ?dilate : int seq,
        [<Optional>] ?pad : int seq,
        [<Optional>] ?numGroup : int,
        [<Optional>] ?workspace : int64,
        [<Optional>] ?noBias : bool,
        [<Optional>] ?cudnnTune : CudnnTune,
        [<Optional>] ?cudnnOff : bool,
        [<Optional>] ?layout : ContribQuantizedConvLayout) = 
        let operatorArguments = 
            [
                "data", Input data
                "weight", Input weight
                "bias", Input bias
                "min_data", Input minData
                "max_data", Input maxData
                "min_weight", Input minWeight
                "max_weight", Input maxWeight
                "min_bias", Input minBias
                "max_bias", Input maxBias
                "kernel", Parameter(Some(box kernel))
                "num_filter", Parameter(Some(box numFilter))
                "stride", stride |> Option.map box |> Parameter
                "dilate", dilate |> Option.map box |> Parameter
                "pad", pad |> Option.map box |> Parameter
                "num_group", numGroup |> Option.map box |> Parameter
                "workspace", workspace |> Option.map box |> Parameter
                "no_bias", noBias |> Option.map box |> Parameter
                "cudnn_tune", cudnnTune |> Option.map box |> Parameter
                "cudnn_off", cudnnOff |> Option.map box |> Parameter
                "layout", layout |> Option.map box |> Parameter
            ]
        new ContribQuantizedConv(Arguments<Symbol>(operatorArguments))
    /// <summary>Convolution operator for input, weight and bias data type of int8,
    /// and accumulates in type int32 for the output. For each argument, two more arguments of type
    /// float32 must be provided representing the thresholds of quantizing argument from data
    /// type float32 to int8. The final outputs contain the convolution result in int32, and min
    /// and max thresholds representing the threholds for quantizing the float32 output into int32.
    /// 
    /// .. Note::
    ///     This operator only supports forward propogation. DO NOT use it in training.
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\quantization\quantized_conv.cc:L137</summary>
    /// <param name="kernel">Convolution kernel size: (w,), (h, w) or (d, h, w)</param>
    /// <param name="numFilter">Convolution filter(channel) number</param>
    /// <param name="data">Input data.</param>
    /// <param name="weight">weight.</param>
    /// <param name="bias">bias.</param>
    /// <param name="minData">Minimum value of data.</param>
    /// <param name="maxData">Maximum value of data.</param>
    /// <param name="minWeight">Minimum value of weight.</param>
    /// <param name="maxWeight">Maximum value of weight.</param>
    /// <param name="minBias">Minimum value of bias.</param>
    /// <param name="maxBias">Maximum value of bias.</param>
    /// <param name="stride">Convolution stride: (w,), (h, w) or (d, h, w). Defaults to 1 for each dimension.</param>
    /// <param name="dilate">Convolution dilate: (w,), (h, w) or (d, h, w). Defaults to 1 for each dimension.</param>
    /// <param name="pad">Zero pad for convolution: (w,), (h, w) or (d, h, w). Defaults to no padding.</param>
    /// <param name="numGroup">Number of group partitions.</param>
    /// <param name="workspace">Maximum temporary workspace allowed (MB) in convolution.This parameter has two usages. When CUDNN is not used, it determines the effective batch size of the convolution kernel. When CUDNN is used, it controls the maximum temporary storage used for tuning the best CUDNN kernel when `limited_workspace` strategy is used.</param>
    /// <param name="noBias">Whether to disable bias parameter.</param>
    /// <param name="cudnnTune">Whether to pick convolution algo by running performance test.</param>
    /// <param name="cudnnOff">Turn off cudnn for this layer.</param>
    /// <param name="layout">Set layout for input, output and weight. Empty for
    ///     default layout: NCW for 1d, NCHW for 2d and NCDHW for 3d.NHWC and NDHWC are only supported on GPU.</param>
    new(kernel : int seq,
        numFilter : int,
        [<Optional>] ?data : Symbol,
        [<Optional>] ?weight : Symbol,
        [<Optional>] ?bias : Symbol,
        [<Optional>] ?minData : Symbol,
        [<Optional>] ?maxData : Symbol,
        [<Optional>] ?minWeight : Symbol,
        [<Optional>] ?maxWeight : Symbol,
        [<Optional>] ?minBias : Symbol,
        [<Optional>] ?maxBias : Symbol,
        [<Optional>] ?stride : int seq,
        [<Optional>] ?dilate : int seq,
        [<Optional>] ?pad : int seq,
        [<Optional>] ?numGroup : int,
        [<Optional>] ?workspace : int64,
        [<Optional>] ?noBias : bool,
        [<Optional>] ?cudnnTune : CudnnTune,
        [<Optional>] ?cudnnOff : bool,
        [<Optional>] ?layout : ContribQuantizedConvLayout) = 
        let data = defaultArg data (new ImplicitVariable() :> Symbol)
        let weight = defaultArg weight (new ImplicitVariable() :> Symbol)
        let bias = defaultArg bias (new ImplicitVariable() :> Symbol)
        let minData = defaultArg minData (new ImplicitVariable() :> Symbol)
        let maxData = defaultArg maxData (new ImplicitVariable() :> Symbol)
        let minWeight = defaultArg minWeight (new ImplicitVariable() :> Symbol)
        let maxWeight = defaultArg maxWeight (new ImplicitVariable() :> Symbol)
        let minBias = defaultArg minBias (new ImplicitVariable() :> Symbol)
        let maxBias = defaultArg maxBias (new ImplicitVariable() :> Symbol)
        let operatorArguments = 
            [
                "data", Input data
                "weight", Input weight
                "bias", Input bias
                "min_data", Input minData
                "max_data", Input maxData
                "min_weight", Input minWeight
                "max_weight", Input maxWeight
                "min_bias", Input minBias
                "max_bias", Input maxBias
                "kernel", Parameter(Some(box kernel))
                "num_filter", Parameter(Some(box numFilter))
                "stride", stride |> Option.map box |> Parameter
                "dilate", dilate |> Option.map box |> Parameter
                "pad", pad |> Option.map box |> Parameter
                "num_group", numGroup |> Option.map box |> Parameter
                "workspace", workspace |> Option.map box |> Parameter
                "no_bias", noBias |> Option.map box |> Parameter
                "cudnn_tune", cudnnTune |> Option.map box |> Parameter
                "cudnn_off", cudnnOff |> Option.map box |> Parameter
                "layout", layout |> Option.map box |> Parameter
            ]
        new ContribQuantizedConv(Arguments<Symbol>(operatorArguments))
    /// Default value for Stride
    /// Convolution stride: (w,), (h, w) or (d, h, w). Defaults to 1 for each dimension.
    static member StrideDefault : int [] = [||]
    /// Default value for Dilate
    /// Convolution dilate: (w,), (h, w) or (d, h, w). Defaults to 1 for each dimension.
    static member DilateDefault : int [] = [||]
    /// Default value for Pad
    /// Zero pad for convolution: (w,), (h, w) or (d, h, w). Defaults to no padding.
    static member PadDefault : int [] = [||]
    /// Default value for NumGroup
    /// Number of group partitions.
    static member NumGroupDefault : int = 1
    /// Default value for Workspace
    /// Maximum temporary workspace allowed (MB) in convolution.This parameter has two usages. When CUDNN is not used, it determines the effective batch size of the convolution kernel. When CUDNN is used, it controls the maximum temporary storage used for tuning the best CUDNN kernel when `limited_workspace` strategy is used.
    static member WorkspaceDefault : int64 = 1024L
    /// Default value for NoBias
    /// Whether to disable bias parameter.
    static member NoBiasDefault : bool = false
    /// Default value for CudnnTune
    /// Whether to pick convolution algo by running performance test.
    static member CudnnTuneDefault : CudnnTune option = None
    /// Default value for CudnnOff
    /// Turn off cudnn for this layer.
    static member CudnnOffDefault : bool = false
    /// Default value for Layout
    /// Set layout for input, output and weight. Empty for
    ///     default layout: NCW for 1d, NCHW for 2d and NCDHW for 3d.NHWC and NDHWC are only supported on GPU.
    static member LayoutDefault : ContribQuantizedConvLayout option = None
    /// Input data.
    member __.Data = operatorArguments.GetInput "data"
    /// weight.
    member __.Weight = operatorArguments.GetInput "weight"
    /// bias.
    member __.Bias = operatorArguments.GetInput "bias"
    /// Minimum value of data.
    member __.MinData = operatorArguments.GetInput "min_data"
    /// Maximum value of data.
    member __.MaxData = operatorArguments.GetInput "max_data"
    /// Minimum value of weight.
    member __.MinWeight = operatorArguments.GetInput "min_weight"
    /// Maximum value of weight.
    member __.MaxWeight = operatorArguments.GetInput "max_weight"
    /// Minimum value of bias.
    member __.MinBias = operatorArguments.GetInput "min_bias"
    /// Maximum value of bias.
    member __.MaxBias = operatorArguments.GetInput "max_bias"
    /// Convolution kernel size: (w,), (h, w) or (d, h, w)
    member __.Kernel : int seq = match operatorArguments.GetParameter "kernel" with Some(v) -> unbox v | None -> failwithf "Required parameter kernel is missing"
    /// Convolution filter(channel) number
    member __.NumFilter : int = match operatorArguments.GetParameter "num_filter" with Some(v) -> unbox v | None -> failwithf "Required parameter num_filter is missing"
    /// Convolution stride: (w,), (h, w) or (d, h, w). Defaults to 1 for each dimension.
    member __.Stride = operatorArguments.GetParameter("stride", ContribQuantizedConv.StrideDefault)
    /// Convolution dilate: (w,), (h, w) or (d, h, w). Defaults to 1 for each dimension.
    member __.Dilate = operatorArguments.GetParameter("dilate", ContribQuantizedConv.DilateDefault)
    /// Zero pad for convolution: (w,), (h, w) or (d, h, w). Defaults to no padding.
    member __.Pad = operatorArguments.GetParameter("pad", ContribQuantizedConv.PadDefault)
    /// Number of group partitions.
    member __.NumGroup = operatorArguments.GetParameter("num_group", ContribQuantizedConv.NumGroupDefault)
    /// Maximum temporary workspace allowed (MB) in convolution.This parameter has two usages. When CUDNN is not used, it determines the effective batch size of the convolution kernel. When CUDNN is used, it controls the maximum temporary storage used for tuning the best CUDNN kernel when `limited_workspace` strategy is used.
    member __.Workspace = operatorArguments.GetParameter("workspace", ContribQuantizedConv.WorkspaceDefault)
    /// Whether to disable bias parameter.
    member __.NoBias = operatorArguments.GetParameter("no_bias", ContribQuantizedConv.NoBiasDefault)
    /// Whether to pick convolution algo by running performance test.
    member __.CudnnTune = operatorArguments.GetParameter("cudnn_tune", ContribQuantizedConv.CudnnTuneDefault)
    /// Turn off cudnn for this layer.
    member __.CudnnOff = operatorArguments.GetParameter("cudnn_off", ContribQuantizedConv.CudnnOffDefault)
    /// Set layout for input, output and weight. Empty for
    ///     default layout: NCW for 1d, NCHW for 2d and NCDHW for 3d.NHWC and NDHWC are only supported on GPU.
    member __.Layout = operatorArguments.GetParameter("layout", ContribQuantizedConv.LayoutDefault)
    /// <summary>Copy ContribQuantizedConv instance with updated inputs/parameters.</summary>
    /// <param name="data">Input data.</param>
    /// <param name="weight">weight.</param>
    /// <param name="bias">bias.</param>
    /// <param name="minData">Minimum value of data.</param>
    /// <param name="maxData">Maximum value of data.</param>
    /// <param name="minWeight">Minimum value of weight.</param>
    /// <param name="maxWeight">Maximum value of weight.</param>
    /// <param name="minBias">Minimum value of bias.</param>
    /// <param name="maxBias">Maximum value of bias.</param>
    /// <param name="kernel">Convolution kernel size: (w,), (h, w) or (d, h, w)</param>
    /// <param name="numFilter">Convolution filter(channel) number</param>
    /// <param name="stride">Convolution stride: (w,), (h, w) or (d, h, w). Defaults to 1 for each dimension.</param>
    /// <param name="dilate">Convolution dilate: (w,), (h, w) or (d, h, w). Defaults to 1 for each dimension.</param>
    /// <param name="pad">Zero pad for convolution: (w,), (h, w) or (d, h, w). Defaults to no padding.</param>
    /// <param name="numGroup">Number of group partitions.</param>
    /// <param name="workspace">Maximum temporary workspace allowed (MB) in convolution.This parameter has two usages. When CUDNN is not used, it determines the effective batch size of the convolution kernel. When CUDNN is used, it controls the maximum temporary storage used for tuning the best CUDNN kernel when `limited_workspace` strategy is used.</param>
    /// <param name="noBias">Whether to disable bias parameter.</param>
    /// <param name="cudnnTune">Whether to pick convolution algo by running performance test.</param>
    /// <param name="cudnnOff">Turn off cudnn for this layer.</param>
    /// <param name="layout">Set layout for input, output and weight. Empty for
    ///     default layout: NCW for 1d, NCHW for 2d and NCDHW for 3d.NHWC and NDHWC are only supported on GPU.</param>
    member this.With([<Optional>] ?data : Symbol,
        [<Optional>] ?weight : Symbol,
        [<Optional>] ?bias : Symbol,
        [<Optional>] ?minData : Symbol,
        [<Optional>] ?maxData : Symbol,
        [<Optional>] ?minWeight : Symbol,
        [<Optional>] ?maxWeight : Symbol,
        [<Optional>] ?minBias : Symbol,
        [<Optional>] ?maxBias : Symbol,
        [<Optional>] ?kernel : int seq,
        [<Optional>] ?numFilter : int,
        [<Optional>] ?stride : int seq,
        [<Optional>] ?dilate : int seq,
        [<Optional>] ?pad : int seq,
        [<Optional>] ?numGroup : int,
        [<Optional>] ?workspace : int64,
        [<Optional>] ?noBias : bool,
        [<Optional>] ?cudnnTune : CudnnTune,
        [<Optional>] ?cudnnOff : bool,
        [<Optional>] ?layout : ContribQuantizedConvLayout) = 
        let operatorArguments = 
            [
                data |> Option.map (fun x -> "data", Input x)
                weight |> Option.map (fun x -> "weight", Input x)
                bias |> Option.map (fun x -> "bias", Input x)
                minData |> Option.map (fun x -> "min_data", Input x)
                maxData |> Option.map (fun x -> "max_data", Input x)
                minWeight |> Option.map (fun x -> "min_weight", Input x)
                maxWeight |> Option.map (fun x -> "max_weight", Input x)
                minBias |> Option.map (fun x -> "min_bias", Input x)
                maxBias |> Option.map (fun x -> "max_bias", Input x)
                kernel |> Option.map (fun x -> "kernel", Parameter(Some (box x)))
                numFilter |> Option.map (fun x -> "num_filter", Parameter(Some (box x)))
                stride |> Option.map (fun x -> "stride", Parameter(Some (box x)))
                dilate |> Option.map (fun x -> "dilate", Parameter(Some (box x)))
                pad |> Option.map (fun x -> "pad", Parameter(Some (box x)))
                numGroup |> Option.map (fun x -> "num_group", Parameter(Some (box x)))
                workspace |> Option.map (fun x -> "workspace", Parameter(Some (box x)))
                noBias |> Option.map (fun x -> "no_bias", Parameter(Some (box x)))
                cudnnTune |> Option.map (fun x -> "cudnn_tune", Parameter(Some (box x)))
                cudnnOff |> Option.map (fun x -> "cudnn_off", Parameter(Some (box x)))
                layout |> Option.map (fun x -> "layout", Parameter(Some (box x)))
            ] |> List.choose id
        new ContribQuantizedConv(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type ContribQuantizedElemwiseAdd private (operatorArguments) = 
    inherit SymbolOperator("_contrib_quantized_elemwise_add", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new ContribQuantizedElemwiseAdd(args)
    override this.WithArguments(args : Arguments<Symbol>) = new ContribQuantizedElemwiseAdd(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <summary>elemwise_add operator for input dataA and input dataB data type of int8,
    /// and accumulates in type int32 for the output. For each argument, two more arguments of type
    /// float32 must be provided representing the thresholds of quantizing argument from data
    /// type float32 to int8. The final outputs contain result in int32, and min
    /// and max thresholds representing the threholds for quantizing the float32 output into int32.
    /// 
    /// .. Note::
    ///     This operator only supports forward propogation. DO NOT use it in training.
    /// 
    /// </summary>
    /// <param name="lhs">first input</param>
    /// <param name="rhs">second input</param>
    /// <param name="lhsMin">3rd input</param>
    /// <param name="lhsMax">4th input</param>
    /// <param name="rhsMin">5th input</param>
    /// <param name="rhsMax">6th input</param>
    new([<Optional>] ?lhs : Symbol,
        [<Optional>] ?rhs : Symbol,
        [<Optional>] ?lhsMin : Symbol,
        [<Optional>] ?lhsMax : Symbol,
        [<Optional>] ?rhsMin : Symbol,
        [<Optional>] ?rhsMax : Symbol) = 
        let lhs = defaultArg lhs (new ImplicitVariable() :> Symbol)
        let rhs = defaultArg rhs (new ImplicitVariable() :> Symbol)
        let lhsMin = defaultArg lhsMin (new ImplicitVariable() :> Symbol)
        let lhsMax = defaultArg lhsMax (new ImplicitVariable() :> Symbol)
        let rhsMin = defaultArg rhsMin (new ImplicitVariable() :> Symbol)
        let rhsMax = defaultArg rhsMax (new ImplicitVariable() :> Symbol)
        let operatorArguments = 
            [
                "lhs", Input lhs
                "rhs", Input rhs
                "lhs_min", Input lhsMin
                "lhs_max", Input lhsMax
                "rhs_min", Input rhsMin
                "rhs_max", Input rhsMax
            ]
        new ContribQuantizedElemwiseAdd(Arguments<Symbol>(operatorArguments))
    /// first input
    member __.Lhs = operatorArguments.GetInput "lhs"
    /// second input
    member __.Rhs = operatorArguments.GetInput "rhs"
    /// 3rd input
    member __.LhsMin = operatorArguments.GetInput "lhs_min"
    /// 4th input
    member __.LhsMax = operatorArguments.GetInput "lhs_max"
    /// 5th input
    member __.RhsMin = operatorArguments.GetInput "rhs_min"
    /// 6th input
    member __.RhsMax = operatorArguments.GetInput "rhs_max"
    /// <summary>Copy ContribQuantizedElemwiseAdd instance with updated inputs/parameters.</summary>
    /// <param name="lhs">first input</param>
    /// <param name="rhs">second input</param>
    /// <param name="lhsMin">3rd input</param>
    /// <param name="lhsMax">4th input</param>
    /// <param name="rhsMin">5th input</param>
    /// <param name="rhsMax">6th input</param>
    member this.With([<Optional>] ?lhs : Symbol,
        [<Optional>] ?rhs : Symbol,
        [<Optional>] ?lhsMin : Symbol,
        [<Optional>] ?lhsMax : Symbol,
        [<Optional>] ?rhsMin : Symbol,
        [<Optional>] ?rhsMax : Symbol) = 
        let operatorArguments = 
            [
                lhs |> Option.map (fun x -> "lhs", Input x)
                rhs |> Option.map (fun x -> "rhs", Input x)
                lhsMin |> Option.map (fun x -> "lhs_min", Input x)
                lhsMax |> Option.map (fun x -> "lhs_max", Input x)
                rhsMin |> Option.map (fun x -> "rhs_min", Input x)
                rhsMax |> Option.map (fun x -> "rhs_max", Input x)
            ] |> List.choose id
        new ContribQuantizedElemwiseAdd(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type ContribQuantizedFlatten private (operatorArguments) = 
    inherit SymbolOperator("_contrib_quantized_flatten", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new ContribQuantizedFlatten(args)
    override this.WithArguments(args : Arguments<Symbol>) = new ContribQuantizedFlatten(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <param name="data">A ndarray/symbol of type `float32`</param>
    /// <param name="minData">The minimum scalar value possibly produced for the data</param>
    /// <param name="maxData">The maximum scalar value possibly produced for the data</param>
    new([<Optional>] ?data : Symbol,
        [<Optional>] ?minData : Symbol,
        [<Optional>] ?maxData : Symbol) = 
        let data = defaultArg data (new ImplicitVariable() :> Symbol)
        let minData = defaultArg minData (new ImplicitVariable() :> Symbol)
        let maxData = defaultArg maxData (new ImplicitVariable() :> Symbol)
        let operatorArguments = 
            [
                "data", Input data
                "min_data", Input minData
                "max_data", Input maxData
            ]
        new ContribQuantizedFlatten(Arguments<Symbol>(operatorArguments))
    /// A ndarray/symbol of type `float32`
    member __.Data = operatorArguments.GetInput "data"
    /// The minimum scalar value possibly produced for the data
    member __.MinData = operatorArguments.GetInput "min_data"
    /// The maximum scalar value possibly produced for the data
    member __.MaxData = operatorArguments.GetInput "max_data"
    /// <summary>Copy ContribQuantizedFlatten instance with updated inputs/parameters.</summary>
    /// <param name="data">A ndarray/symbol of type `float32`</param>
    /// <param name="minData">The minimum scalar value possibly produced for the data</param>
    /// <param name="maxData">The maximum scalar value possibly produced for the data</param>
    member this.With([<Optional>] ?data : Symbol,
        [<Optional>] ?minData : Symbol,
        [<Optional>] ?maxData : Symbol) = 
        let operatorArguments = 
            [
                data |> Option.map (fun x -> "data", Input x)
                minData |> Option.map (fun x -> "min_data", Input x)
                maxData |> Option.map (fun x -> "max_data", Input x)
            ] |> List.choose id
        new ContribQuantizedFlatten(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type Flatten private (operatorArguments) = 
    inherit SymbolOperator("Flatten", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new Flatten(args)
    override this.WithArguments(args : Arguments<Symbol>) = new Flatten(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <summary>Flattens the input array into a 2-D array by collapsing the higher dimensions.
    /// 
    /// .. note:: `Flatten` is deprecated. Use `flatten` instead.
    /// 
    /// For an input array with shape ``(d1, d2, ..., dk)``, `flatten` operation reshapes
    /// the input array into an output array of shape ``(d1, d2*...*dk)``.
    /// 
    /// Note that the behavior of this function is different from numpy.ndarray.flatten,
    /// which behaves similar to mxnet.ndarray.reshape((-1,)).
    /// 
    /// Example::
    /// 
    ///     x = [[
    ///         [1,2,3],
    ///         [4,5,6],
    ///         [7,8,9]
    ///     ],
    ///     [    [1,2,3],
    ///         [4,5,6],
    ///         [7,8,9]
    ///     ]],
    /// 
    ///     flatten(x) = [[ 1.,  2.,  3.,  4.,  5.,  6.,  7.,  8.,  9.],
    ///        [ 1.,  2.,  3.,  4.,  5.,  6.,  7.,  8.,  9.]]
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\matrix_op.cc:L292</summary>
    /// <param name="data">Input array.</param>
    new([<Optional>] ?data : Symbol) =
        let data = defaultArg data (new ImplicitVariable() :> Symbol)
        let operatorArguments = 
            [
                "data", Input data
            ]
        new Flatten(Arguments<Symbol>(operatorArguments))
    /// Input array.
    member __.Data = operatorArguments.GetInput "data"
    /// <summary>Copy Flatten instance with updated inputs/parameters.</summary>
    /// <param name="data">Input array.</param>
    member this.With([<Optional>] ?data : Symbol) =
        let operatorArguments = 
            [
                data |> Option.map (fun x -> "data", Input x)
            ] |> List.choose id
        new Flatten(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type ContribQuantizedFullyConnected private (operatorArguments) = 
    inherit SymbolOperator("_contrib_quantized_fully_connected", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new ContribQuantizedFullyConnected(args)
    override this.WithArguments(args : Arguments<Symbol>) = new ContribQuantizedFullyConnected(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <summary>Fully Connected operator for input, weight and bias data type of int8,
    /// and accumulates in type int32 for the output. For each argument, two more arguments of type
    /// float32 must be provided representing the thresholds of quantizing argument from data
    /// type float32 to int8. The final outputs contain the convolution result in int32, and min
    /// and max thresholds representing the threholds for quantizing the float32 output into int32.
    /// 
    /// .. Note::
    ///     This operator only supports forward propogation. DO NOT use it in training.
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\quantization\quantized_fully_connected.cc:L313</summary>
    /// <param name="data">Input data.</param>
    /// <param name="weight">weight.</param>
    /// <param name="bias">bias.</param>
    /// <param name="minData">Minimum value of data.</param>
    /// <param name="maxData">Maximum value of data.</param>
    /// <param name="minWeight">Minimum value of weight.</param>
    /// <param name="maxWeight">Maximum value of weight.</param>
    /// <param name="minBias">Minimum value of bias.</param>
    /// <param name="maxBias">Maximum value of bias.</param>
    /// <param name="numHidden">Number of hidden nodes of the output.</param>
    /// <param name="noBias">Whether to disable bias parameter.</param>
    /// <param name="flatten">Whether to collapse all but the first axis of the input data tensor.</param>
    new(data : Symbol,
        weight : Symbol,
        bias : Symbol,
        minData : Symbol,
        maxData : Symbol,
        minWeight : Symbol,
        maxWeight : Symbol,
        minBias : Symbol,
        maxBias : Symbol,
        numHidden : int,
        [<Optional>] ?noBias : bool,
        [<Optional>] ?flatten : bool) = 
        let operatorArguments = 
            [
                "data", Input data
                "weight", Input weight
                "bias", Input bias
                "min_data", Input minData
                "max_data", Input maxData
                "min_weight", Input minWeight
                "max_weight", Input maxWeight
                "min_bias", Input minBias
                "max_bias", Input maxBias
                "num_hidden", Parameter(Some(box numHidden))
                "no_bias", noBias |> Option.map box |> Parameter
                "flatten", flatten |> Option.map box |> Parameter
            ]
        new ContribQuantizedFullyConnected(Arguments<Symbol>(operatorArguments))
    /// <summary>Fully Connected operator for input, weight and bias data type of int8,
    /// and accumulates in type int32 for the output. For each argument, two more arguments of type
    /// float32 must be provided representing the thresholds of quantizing argument from data
    /// type float32 to int8. The final outputs contain the convolution result in int32, and min
    /// and max thresholds representing the threholds for quantizing the float32 output into int32.
    /// 
    /// .. Note::
    ///     This operator only supports forward propogation. DO NOT use it in training.
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\quantization\quantized_fully_connected.cc:L313</summary>
    /// <param name="numHidden">Number of hidden nodes of the output.</param>
    /// <param name="data">Input data.</param>
    /// <param name="weight">weight.</param>
    /// <param name="bias">bias.</param>
    /// <param name="minData">Minimum value of data.</param>
    /// <param name="maxData">Maximum value of data.</param>
    /// <param name="minWeight">Minimum value of weight.</param>
    /// <param name="maxWeight">Maximum value of weight.</param>
    /// <param name="minBias">Minimum value of bias.</param>
    /// <param name="maxBias">Maximum value of bias.</param>
    /// <param name="noBias">Whether to disable bias parameter.</param>
    /// <param name="flatten">Whether to collapse all but the first axis of the input data tensor.</param>
    new(numHidden : int,
        [<Optional>] ?data : Symbol,
        [<Optional>] ?weight : Symbol,
        [<Optional>] ?bias : Symbol,
        [<Optional>] ?minData : Symbol,
        [<Optional>] ?maxData : Symbol,
        [<Optional>] ?minWeight : Symbol,
        [<Optional>] ?maxWeight : Symbol,
        [<Optional>] ?minBias : Symbol,
        [<Optional>] ?maxBias : Symbol,
        [<Optional>] ?noBias : bool,
        [<Optional>] ?flatten : bool) = 
        let data = defaultArg data (new ImplicitVariable() :> Symbol)
        let weight = defaultArg weight (new ImplicitVariable() :> Symbol)
        let bias = defaultArg bias (new ImplicitVariable() :> Symbol)
        let minData = defaultArg minData (new ImplicitVariable() :> Symbol)
        let maxData = defaultArg maxData (new ImplicitVariable() :> Symbol)
        let minWeight = defaultArg minWeight (new ImplicitVariable() :> Symbol)
        let maxWeight = defaultArg maxWeight (new ImplicitVariable() :> Symbol)
        let minBias = defaultArg minBias (new ImplicitVariable() :> Symbol)
        let maxBias = defaultArg maxBias (new ImplicitVariable() :> Symbol)
        let operatorArguments = 
            [
                "data", Input data
                "weight", Input weight
                "bias", Input bias
                "min_data", Input minData
                "max_data", Input maxData
                "min_weight", Input minWeight
                "max_weight", Input maxWeight
                "min_bias", Input minBias
                "max_bias", Input maxBias
                "num_hidden", Parameter(Some(box numHidden))
                "no_bias", noBias |> Option.map box |> Parameter
                "flatten", flatten |> Option.map box |> Parameter
            ]
        new ContribQuantizedFullyConnected(Arguments<Symbol>(operatorArguments))
    /// Default value for NoBias
    /// Whether to disable bias parameter.
    static member NoBiasDefault : bool = false
    /// Default value for Flatten
    /// Whether to collapse all but the first axis of the input data tensor.
    static member FlattenDefault : bool = true
    /// Input data.
    member __.Data = operatorArguments.GetInput "data"
    /// weight.
    member __.Weight = operatorArguments.GetInput "weight"
    /// bias.
    member __.Bias = operatorArguments.GetInput "bias"
    /// Minimum value of data.
    member __.MinData = operatorArguments.GetInput "min_data"
    /// Maximum value of data.
    member __.MaxData = operatorArguments.GetInput "max_data"
    /// Minimum value of weight.
    member __.MinWeight = operatorArguments.GetInput "min_weight"
    /// Maximum value of weight.
    member __.MaxWeight = operatorArguments.GetInput "max_weight"
    /// Minimum value of bias.
    member __.MinBias = operatorArguments.GetInput "min_bias"
    /// Maximum value of bias.
    member __.MaxBias = operatorArguments.GetInput "max_bias"
    /// Number of hidden nodes of the output.
    member __.NumHidden : int = match operatorArguments.GetParameter "num_hidden" with Some(v) -> unbox v | None -> failwithf "Required parameter num_hidden is missing"
    /// Whether to disable bias parameter.
    member __.NoBias = operatorArguments.GetParameter("no_bias", ContribQuantizedFullyConnected.NoBiasDefault)
    /// Whether to collapse all but the first axis of the input data tensor.
    member __.Flatten = operatorArguments.GetParameter("flatten", ContribQuantizedFullyConnected.FlattenDefault)
    /// <summary>Copy ContribQuantizedFullyConnected instance with updated inputs/parameters.</summary>
    /// <param name="data">Input data.</param>
    /// <param name="weight">weight.</param>
    /// <param name="bias">bias.</param>
    /// <param name="minData">Minimum value of data.</param>
    /// <param name="maxData">Maximum value of data.</param>
    /// <param name="minWeight">Minimum value of weight.</param>
    /// <param name="maxWeight">Maximum value of weight.</param>
    /// <param name="minBias">Minimum value of bias.</param>
    /// <param name="maxBias">Maximum value of bias.</param>
    /// <param name="numHidden">Number of hidden nodes of the output.</param>
    /// <param name="noBias">Whether to disable bias parameter.</param>
    /// <param name="flatten">Whether to collapse all but the first axis of the input data tensor.</param>
    member this.With([<Optional>] ?data : Symbol,
        [<Optional>] ?weight : Symbol,
        [<Optional>] ?bias : Symbol,
        [<Optional>] ?minData : Symbol,
        [<Optional>] ?maxData : Symbol,
        [<Optional>] ?minWeight : Symbol,
        [<Optional>] ?maxWeight : Symbol,
        [<Optional>] ?minBias : Symbol,
        [<Optional>] ?maxBias : Symbol,
        [<Optional>] ?numHidden : int,
        [<Optional>] ?noBias : bool,
        [<Optional>] ?flatten : bool) = 
        let operatorArguments = 
            [
                data |> Option.map (fun x -> "data", Input x)
                weight |> Option.map (fun x -> "weight", Input x)
                bias |> Option.map (fun x -> "bias", Input x)
                minData |> Option.map (fun x -> "min_data", Input x)
                maxData |> Option.map (fun x -> "max_data", Input x)
                minWeight |> Option.map (fun x -> "min_weight", Input x)
                maxWeight |> Option.map (fun x -> "max_weight", Input x)
                minBias |> Option.map (fun x -> "min_bias", Input x)
                maxBias |> Option.map (fun x -> "max_bias", Input x)
                numHidden |> Option.map (fun x -> "num_hidden", Parameter(Some (box x)))
                noBias |> Option.map (fun x -> "no_bias", Parameter(Some (box x)))
                flatten |> Option.map (fun x -> "flatten", Parameter(Some (box x)))
            ] |> List.choose id
        new ContribQuantizedFullyConnected(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type ContribQuantizedPooling private (operatorArguments) = 
    inherit SymbolOperator("_contrib_quantized_pooling", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new ContribQuantizedPooling(args)
    override this.WithArguments(args : Arguments<Symbol>) = new ContribQuantizedPooling(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <summary>Pooling operator for input and output data type of int8.
    /// The input and output data comes with min and max thresholds for quantizing
    /// the float32 data into int8.
    /// 
    /// .. Note::
    ///     This operator only supports forward propogation. DO NOT use it in training.
    ///     This operator only supports `pool_type` of `avg` or `max`.
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\quantization\quantized_pooling.cc:L145</summary>
    /// <param name="data">Input data.</param>
    /// <param name="minData">Minimum value of data.</param>
    /// <param name="maxData">Maximum value of data.</param>
    /// <param name="kernel">Pooling kernel size: (y, x) or (d, y, x)</param>
    /// <param name="poolType">Pooling type to be applied.</param>
    /// <param name="globalPool">Ignore kernel size, do global pooling based on current input feature map. </param>
    /// <param name="cudnnOff">Turn off cudnn pooling and use MXNet pooling operator. </param>
    /// <param name="poolingConvention">Pooling convention to be applied.</param>
    /// <param name="stride">Stride: for pooling (y, x) or (d, y, x). Defaults to 1 for each dimension.</param>
    /// <param name="pad">Pad for pooling: (y, x) or (d, y, x). Defaults to no padding.</param>
    /// <param name="pValue">Value of p for Lp pooling, can be 1 or 2, required for Lp Pooling.</param>
    /// <param name="countIncludePad">Only used for AvgPool, specify whether to count padding elements for averagecalculation. For example, with a 5*5 kernel on a 3*3 corner of a image,the sum of the 9 valid elements will be divided by 25 if this is set to true,or it will be divided by 9 if this is set to false. Defaults to true.</param>
    /// <param name="layout">Set layout for input and output. Empty for
    ///     default layout: NCW for 1d, NCHW for 2d and NCDHW for 3d.</param>
    new([<Optional>] ?data : Symbol,
        [<Optional>] ?minData : Symbol,
        [<Optional>] ?maxData : Symbol,
        [<Optional>] ?kernel : int seq,
        [<Optional>] ?poolType : PoolType,
        [<Optional>] ?globalPool : bool,
        [<Optional>] ?cudnnOff : bool,
        [<Optional>] ?poolingConvention : PoolingConvention,
        [<Optional>] ?stride : int seq,
        [<Optional>] ?pad : int seq,
        [<Optional>] ?pValue : int,
        [<Optional>] ?countIncludePad : bool,
        [<Optional>] ?layout : ContribQuantizedPoolingLayout) = 
        let data = defaultArg data (new ImplicitVariable() :> Symbol)
        let minData = defaultArg minData (new ImplicitVariable() :> Symbol)
        let maxData = defaultArg maxData (new ImplicitVariable() :> Symbol)
        let operatorArguments = 
            [
                "data", Input data
                "min_data", Input minData
                "max_data", Input maxData
                "kernel", kernel |> Option.map box |> Parameter
                "pool_type", poolType |> Option.map box |> Parameter
                "global_pool", globalPool |> Option.map box |> Parameter
                "cudnn_off", cudnnOff |> Option.map box |> Parameter
                "pooling_convention", poolingConvention |> Option.map box |> Parameter
                "stride", stride |> Option.map box |> Parameter
                "pad", pad |> Option.map box |> Parameter
                "p_value", pValue |> Option.map box |> Parameter
                "count_include_pad", countIncludePad |> Option.map box |> Parameter
                "layout", layout |> Option.map box |> Parameter
            ]
        new ContribQuantizedPooling(Arguments<Symbol>(operatorArguments))
    /// Default value for Kernel
    /// Pooling kernel size: (y, x) or (d, y, x)
    static member KernelDefault : int [] = [||]
    /// Default value for PoolType
    /// Pooling type to be applied.
    static member PoolTypeDefault : PoolType = PoolType.Max
    /// Default value for GlobalPool
    /// Ignore kernel size, do global pooling based on current input feature map. 
    static member GlobalPoolDefault : bool = false
    /// Default value for CudnnOff
    /// Turn off cudnn pooling and use MXNet pooling operator. 
    static member CudnnOffDefault : bool = false
    /// Default value for PoolingConvention
    /// Pooling convention to be applied.
    static member PoolingConventionDefault : PoolingConvention = PoolingConvention.Valid
    /// Default value for Stride
    /// Stride: for pooling (y, x) or (d, y, x). Defaults to 1 for each dimension.
    static member StrideDefault : int [] = [||]
    /// Default value for Pad
    /// Pad for pooling: (y, x) or (d, y, x). Defaults to no padding.
    static member PadDefault : int [] = [||]
    /// Default value for PValue
    /// Value of p for Lp pooling, can be 1 or 2, required for Lp Pooling.
    static member PValueDefault : int option = None
    /// Default value for CountIncludePad
    /// Only used for AvgPool, specify whether to count padding elements for averagecalculation. For example, with a 5*5 kernel on a 3*3 corner of a image,the sum of the 9 valid elements will be divided by 25 if this is set to true,or it will be divided by 9 if this is set to false. Defaults to true.
    static member CountIncludePadDefault : bool option = None
    /// Default value for Layout
    /// Set layout for input and output. Empty for
    ///     default layout: NCW for 1d, NCHW for 2d and NCDHW for 3d.
    static member LayoutDefault : ContribQuantizedPoolingLayout option = None
    /// Input data.
    member __.Data = operatorArguments.GetInput "data"
    /// Minimum value of data.
    member __.MinData = operatorArguments.GetInput "min_data"
    /// Maximum value of data.
    member __.MaxData = operatorArguments.GetInput "max_data"
    /// Pooling kernel size: (y, x) or (d, y, x)
    member __.Kernel = operatorArguments.GetParameter("kernel", ContribQuantizedPooling.KernelDefault)
    /// Pooling type to be applied.
    member __.PoolType = operatorArguments.GetParameter("pool_type", ContribQuantizedPooling.PoolTypeDefault)
    /// Ignore kernel size, do global pooling based on current input feature map. 
    member __.GlobalPool = operatorArguments.GetParameter("global_pool", ContribQuantizedPooling.GlobalPoolDefault)
    /// Turn off cudnn pooling and use MXNet pooling operator. 
    member __.CudnnOff = operatorArguments.GetParameter("cudnn_off", ContribQuantizedPooling.CudnnOffDefault)
    /// Pooling convention to be applied.
    member __.PoolingConvention = operatorArguments.GetParameter("pooling_convention", ContribQuantizedPooling.PoolingConventionDefault)
    /// Stride: for pooling (y, x) or (d, y, x). Defaults to 1 for each dimension.
    member __.Stride = operatorArguments.GetParameter("stride", ContribQuantizedPooling.StrideDefault)
    /// Pad for pooling: (y, x) or (d, y, x). Defaults to no padding.
    member __.Pad = operatorArguments.GetParameter("pad", ContribQuantizedPooling.PadDefault)
    /// Value of p for Lp pooling, can be 1 or 2, required for Lp Pooling.
    member __.PValue = operatorArguments.GetParameter("p_value", ContribQuantizedPooling.PValueDefault)
    /// Only used for AvgPool, specify whether to count padding elements for averagecalculation. For example, with a 5*5 kernel on a 3*3 corner of a image,the sum of the 9 valid elements will be divided by 25 if this is set to true,or it will be divided by 9 if this is set to false. Defaults to true.
    member __.CountIncludePad = operatorArguments.GetParameter("count_include_pad", ContribQuantizedPooling.CountIncludePadDefault)
    /// Set layout for input and output. Empty for
    ///     default layout: NCW for 1d, NCHW for 2d and NCDHW for 3d.
    member __.Layout = operatorArguments.GetParameter("layout", ContribQuantizedPooling.LayoutDefault)
    /// <summary>Copy ContribQuantizedPooling instance with updated inputs/parameters.</summary>
    /// <param name="data">Input data.</param>
    /// <param name="minData">Minimum value of data.</param>
    /// <param name="maxData">Maximum value of data.</param>
    /// <param name="kernel">Pooling kernel size: (y, x) or (d, y, x)</param>
    /// <param name="poolType">Pooling type to be applied.</param>
    /// <param name="globalPool">Ignore kernel size, do global pooling based on current input feature map. </param>
    /// <param name="cudnnOff">Turn off cudnn pooling and use MXNet pooling operator. </param>
    /// <param name="poolingConvention">Pooling convention to be applied.</param>
    /// <param name="stride">Stride: for pooling (y, x) or (d, y, x). Defaults to 1 for each dimension.</param>
    /// <param name="pad">Pad for pooling: (y, x) or (d, y, x). Defaults to no padding.</param>
    /// <param name="pValue">Value of p for Lp pooling, can be 1 or 2, required for Lp Pooling.</param>
    /// <param name="countIncludePad">Only used for AvgPool, specify whether to count padding elements for averagecalculation. For example, with a 5*5 kernel on a 3*3 corner of a image,the sum of the 9 valid elements will be divided by 25 if this is set to true,or it will be divided by 9 if this is set to false. Defaults to true.</param>
    /// <param name="layout">Set layout for input and output. Empty for
    ///     default layout: NCW for 1d, NCHW for 2d and NCDHW for 3d.</param>
    member this.With([<Optional>] ?data : Symbol,
        [<Optional>] ?minData : Symbol,
        [<Optional>] ?maxData : Symbol,
        [<Optional>] ?kernel : int seq,
        [<Optional>] ?poolType : PoolType,
        [<Optional>] ?globalPool : bool,
        [<Optional>] ?cudnnOff : bool,
        [<Optional>] ?poolingConvention : PoolingConvention,
        [<Optional>] ?stride : int seq,
        [<Optional>] ?pad : int seq,
        [<Optional>] ?pValue : int,
        [<Optional>] ?countIncludePad : bool,
        [<Optional>] ?layout : ContribQuantizedPoolingLayout) = 
        let operatorArguments = 
            [
                data |> Option.map (fun x -> "data", Input x)
                minData |> Option.map (fun x -> "min_data", Input x)
                maxData |> Option.map (fun x -> "max_data", Input x)
                kernel |> Option.map (fun x -> "kernel", Parameter(Some (box x)))
                poolType |> Option.map (fun x -> "pool_type", Parameter(Some (box x)))
                globalPool |> Option.map (fun x -> "global_pool", Parameter(Some (box x)))
                cudnnOff |> Option.map (fun x -> "cudnn_off", Parameter(Some (box x)))
                poolingConvention |> Option.map (fun x -> "pooling_convention", Parameter(Some (box x)))
                stride |> Option.map (fun x -> "stride", Parameter(Some (box x)))
                pad |> Option.map (fun x -> "pad", Parameter(Some (box x)))
                pValue |> Option.map (fun x -> "p_value", Parameter(Some (box x)))
                countIncludePad |> Option.map (fun x -> "count_include_pad", Parameter(Some (box x)))
                layout |> Option.map (fun x -> "layout", Parameter(Some (box x)))
            ] |> List.choose id
        new ContribQuantizedPooling(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type ContribRequantize private (operatorArguments) = 
    inherit SymbolOperator("_contrib_requantize", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new ContribRequantize(args)
    override this.WithArguments(args : Arguments<Symbol>) = new ContribRequantize(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <summary>Given data that is quantized in int32 and the corresponding thresholds,
    /// requantize the data into int8 using min and max thresholds either calculated at runtime
    /// or from calibration. It&#39;s highly recommended to pre-calucate the min and max thresholds
    /// through calibration since it is able to save the runtime of the operator and improve the
    /// inference accuracy.
    /// 
    /// .. Note::
    ///     This operator only supports forward propogation. DO NOT use it in training.
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\quantization\requantize.cc:L60</summary>
    /// <param name="data">A ndarray/symbol of type `int32`</param>
    /// <param name="minRange">The original minimum scalar value in the form of float32 used for quantizing data into int32.</param>
    /// <param name="maxRange">The original maximum scalar value in the form of float32 used for quantizing data into int32.</param>
    /// <param name="outType">Output data type. `auto` can be specified to automatically determine output type according to min_calib_range.</param>
    /// <param name="minCalibRange">The minimum scalar value in the form of float32 obtained through calibration. If present, it will be used to requantize the int32 data into int8.</param>
    /// <param name="maxCalibRange">The maximum scalar value in the form of float32 obtained through calibration. If present, it will be used to requantize the int32 data into int8.</param>
    new([<Optional>] ?data : Symbol,
        [<Optional>] ?minRange : Symbol,
        [<Optional>] ?maxRange : Symbol,
        [<Optional>] ?outType : ContribRequantizeOutType,
        [<Optional>] ?minCalibRange : float,
        [<Optional>] ?maxCalibRange : float) = 
        let data = defaultArg data (new ImplicitVariable() :> Symbol)
        let minRange = defaultArg minRange (new ImplicitVariable() :> Symbol)
        let maxRange = defaultArg maxRange (new ImplicitVariable() :> Symbol)
        let operatorArguments = 
            [
                "data", Input data
                "min_range", Input minRange
                "max_range", Input maxRange
                "out_type", outType |> Option.map box |> Parameter
                "min_calib_range", minCalibRange |> Option.map box |> Parameter
                "max_calib_range", maxCalibRange |> Option.map box |> Parameter
            ]
        new ContribRequantize(Arguments<Symbol>(operatorArguments))
    /// Default value for OutType
    /// Output data type. `auto` can be specified to automatically determine output type according to min_calib_range.
    static member OutTypeDefault : ContribRequantizeOutType = ContribRequantizeOutType.Int8
    /// Default value for MinCalibRange
    /// The minimum scalar value in the form of float32 obtained through calibration. If present, it will be used to requantize the int32 data into int8.
    static member MinCalibRangeDefault : double option = None
    /// Default value for MaxCalibRange
    /// The maximum scalar value in the form of float32 obtained through calibration. If present, it will be used to requantize the int32 data into int8.
    static member MaxCalibRangeDefault : double option = None
    /// A ndarray/symbol of type `int32`
    member __.Data = operatorArguments.GetInput "data"
    /// The original minimum scalar value in the form of float32 used for quantizing data into int32.
    member __.MinRange = operatorArguments.GetInput "min_range"
    /// The original maximum scalar value in the form of float32 used for quantizing data into int32.
    member __.MaxRange = operatorArguments.GetInput "max_range"
    /// Output data type. `auto` can be specified to automatically determine output type according to min_calib_range.
    member __.OutType = operatorArguments.GetParameter("out_type", ContribRequantize.OutTypeDefault)
    /// The minimum scalar value in the form of float32 obtained through calibration. If present, it will be used to requantize the int32 data into int8.
    member __.MinCalibRange = operatorArguments.GetParameter("min_calib_range", ContribRequantize.MinCalibRangeDefault)
    /// The maximum scalar value in the form of float32 obtained through calibration. If present, it will be used to requantize the int32 data into int8.
    member __.MaxCalibRange = operatorArguments.GetParameter("max_calib_range", ContribRequantize.MaxCalibRangeDefault)
    /// <summary>Copy ContribRequantize instance with updated inputs/parameters.</summary>
    /// <param name="data">A ndarray/symbol of type `int32`</param>
    /// <param name="minRange">The original minimum scalar value in the form of float32 used for quantizing data into int32.</param>
    /// <param name="maxRange">The original maximum scalar value in the form of float32 used for quantizing data into int32.</param>
    /// <param name="outType">Output data type. `auto` can be specified to automatically determine output type according to min_calib_range.</param>
    /// <param name="minCalibRange">The minimum scalar value in the form of float32 obtained through calibration. If present, it will be used to requantize the int32 data into int8.</param>
    /// <param name="maxCalibRange">The maximum scalar value in the form of float32 obtained through calibration. If present, it will be used to requantize the int32 data into int8.</param>
    member this.With([<Optional>] ?data : Symbol,
        [<Optional>] ?minRange : Symbol,
        [<Optional>] ?maxRange : Symbol,
        [<Optional>] ?outType : ContribRequantizeOutType,
        [<Optional>] ?minCalibRange : float,
        [<Optional>] ?maxCalibRange : float) = 
        let operatorArguments = 
            [
                data |> Option.map (fun x -> "data", Input x)
                minRange |> Option.map (fun x -> "min_range", Input x)
                maxRange |> Option.map (fun x -> "max_range", Input x)
                outType |> Option.map (fun x -> "out_type", Parameter(Some (box x)))
                minCalibRange |> Option.map (fun x -> "min_calib_range", Parameter(Some (box x)))
                maxCalibRange |> Option.map (fun x -> "max_calib_range", Parameter(Some (box x)))
            ] |> List.choose id
        new ContribRequantize(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type SampleUniform private (operatorArguments) = 
    inherit SymbolOperator("_sample_uniform", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new SampleUniform(args)
    override this.WithArguments(args : Arguments<Symbol>) = new SampleUniform(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <summary>Concurrent sampling from multiple
    /// uniform distributions on the intervals given by *[low,high)*.
    /// 
    /// The parameters of the distributions are provided as input arrays.
    /// Let *[s]* be the shape of the input arrays, *n* be the dimension of *[s]*, *[t]*
    /// be the shape specified as the parameter of the operator, and *m* be the dimension
    /// of *[t]*. Then the output will be a *(n+m)*-dimensional array with shape *[s]x[t]*.
    /// 
    /// For any valid *n*-dimensional index *i* with respect to the input arrays, *output[i]*
    /// will be an *m*-dimensional array that holds randomly drawn samples from the distribution
    /// which is parameterized by the input values at index *i*. If the shape parameter of the
    /// operator is not set, then one sample will be drawn per distribution and the output array
    /// has the same shape as the input arrays.
    /// 
    /// Examples::
    /// 
    ///    low = [ 0.0, 2.5 ]
    ///    high = [ 1.0, 3.7 ]
    /// 
    ///    // Draw a single sample for each distribution
    ///    sample_uniform(low, high) = [ 0.40451524,  3.18687344]
    /// 
    ///    // Draw a vector containing two samples for each distribution
    ///    sample_uniform(low, high, shape=(2)) = [[ 0.40451524,  0.18017688],
    ///                                            [ 3.18687344,  3.68352246]]
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\random\multisample_op.cc:L277</summary>
    /// <param name="low">Lower bounds of the distributions.</param>
    /// <param name="high">Upper bounds of the distributions.</param>
    /// <param name="shape">Shape to be sampled from each random distribution.</param>
    /// <param name="dtype">DType of the output in case this can&#39;t be inferred. Defaults to float32 if not defined (dtype=None).</param>
    new([<Optional>] ?low : Symbol,
        [<Optional>] ?high : Symbol,
        [<Optional>] ?shape : int seq,
        [<Optional>] ?dtype : FloatDType) = 
        let low = defaultArg low (new ImplicitVariable() :> Symbol)
        let high = defaultArg high (new ImplicitVariable() :> Symbol)
        let operatorArguments = 
            [
                "low", Input low
                "high", Input high
                "shape", shape |> Option.map box |> Parameter
                "dtype", dtype |> Option.map box |> Parameter
            ]
        new SampleUniform(Arguments<Symbol>(operatorArguments))
    /// Default value for Shape
    /// Shape to be sampled from each random distribution.
    static member ShapeDefault : int [] = [||]
    /// Default value for Dtype
    /// DType of the output in case this can&#39;t be inferred. Defaults to float32 if not defined (dtype=None).
    static member DtypeDefault : FloatDType option = None
    /// Lower bounds of the distributions.
    member __.Low = operatorArguments.GetInput "low"
    /// Upper bounds of the distributions.
    member __.High = operatorArguments.GetInput "high"
    /// Shape to be sampled from each random distribution.
    member __.Shape = operatorArguments.GetParameter("shape", SampleUniform.ShapeDefault)
    /// DType of the output in case this can&#39;t be inferred. Defaults to float32 if not defined (dtype=None).
    member __.Dtype = operatorArguments.GetParameter("dtype", SampleUniform.DtypeDefault)
    /// <summary>Copy SampleUniform instance with updated inputs/parameters.</summary>
    /// <param name="low">Lower bounds of the distributions.</param>
    /// <param name="high">Upper bounds of the distributions.</param>
    /// <param name="shape">Shape to be sampled from each random distribution.</param>
    /// <param name="dtype">DType of the output in case this can&#39;t be inferred. Defaults to float32 if not defined (dtype=None).</param>
    member this.With([<Optional>] ?low : Symbol,
        [<Optional>] ?high : Symbol,
        [<Optional>] ?shape : int seq,
        [<Optional>] ?dtype : FloatDType) = 
        let operatorArguments = 
            [
                low |> Option.map (fun x -> "low", Input x)
                high |> Option.map (fun x -> "high", Input x)
                shape |> Option.map (fun x -> "shape", Parameter(Some (box x)))
                dtype |> Option.map (fun x -> "dtype", Parameter(Some (box x)))
            ] |> List.choose id
        new SampleUniform(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type SampleNormal private (operatorArguments) = 
    inherit SymbolOperator("_sample_normal", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new SampleNormal(args)
    override this.WithArguments(args : Arguments<Symbol>) = new SampleNormal(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <summary>Concurrent sampling from multiple
    /// normal distributions with parameters *mu* (mean) and *sigma* (standard deviation).
    /// 
    /// The parameters of the distributions are provided as input arrays.
    /// Let *[s]* be the shape of the input arrays, *n* be the dimension of *[s]*, *[t]*
    /// be the shape specified as the parameter of the operator, and *m* be the dimension
    /// of *[t]*. Then the output will be a *(n+m)*-dimensional array with shape *[s]x[t]*.
    /// 
    /// For any valid *n*-dimensional index *i* with respect to the input arrays, *output[i]*
    /// will be an *m*-dimensional array that holds randomly drawn samples from the distribution
    /// which is parameterized by the input values at index *i*. If the shape parameter of the
    /// operator is not set, then one sample will be drawn per distribution and the output array
    /// has the same shape as the input arrays.
    /// 
    /// Examples::
    /// 
    ///    mu = [ 0.0, 2.5 ]
    ///    sigma = [ 1.0, 3.7 ]
    /// 
    ///    // Draw a single sample for each distribution
    ///    sample_normal(mu, sigma) = [-0.56410581,  0.95934606]
    /// 
    ///    // Draw a vector containing two samples for each distribution
    ///    sample_normal(mu, sigma, shape=(2)) = [[-0.56410581,  0.2928229 ],
    ///                                           [ 0.95934606,  4.48287058]]
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\random\multisample_op.cc:L279</summary>
    /// <param name="mu">Means of the distributions.</param>
    /// <param name="sigma">Standard deviations of the distributions.</param>
    /// <param name="shape">Shape to be sampled from each random distribution.</param>
    /// <param name="dtype">DType of the output in case this can&#39;t be inferred. Defaults to float32 if not defined (dtype=None).</param>
    new([<Optional>] ?mu : Symbol,
        [<Optional>] ?sigma : Symbol,
        [<Optional>] ?shape : int seq,
        [<Optional>] ?dtype : FloatDType) = 
        let mu = defaultArg mu (new ImplicitVariable() :> Symbol)
        let sigma = defaultArg sigma (new ImplicitVariable() :> Symbol)
        let operatorArguments = 
            [
                "mu", Input mu
                "sigma", Input sigma
                "shape", shape |> Option.map box |> Parameter
                "dtype", dtype |> Option.map box |> Parameter
            ]
        new SampleNormal(Arguments<Symbol>(operatorArguments))
    /// Default value for Shape
    /// Shape to be sampled from each random distribution.
    static member ShapeDefault : int [] = [||]
    /// Default value for Dtype
    /// DType of the output in case this can&#39;t be inferred. Defaults to float32 if not defined (dtype=None).
    static member DtypeDefault : FloatDType option = None
    /// Means of the distributions.
    member __.Mu = operatorArguments.GetInput "mu"
    /// Standard deviations of the distributions.
    member __.Sigma = operatorArguments.GetInput "sigma"
    /// Shape to be sampled from each random distribution.
    member __.Shape = operatorArguments.GetParameter("shape", SampleNormal.ShapeDefault)
    /// DType of the output in case this can&#39;t be inferred. Defaults to float32 if not defined (dtype=None).
    member __.Dtype = operatorArguments.GetParameter("dtype", SampleNormal.DtypeDefault)
    /// <summary>Copy SampleNormal instance with updated inputs/parameters.</summary>
    /// <param name="mu">Means of the distributions.</param>
    /// <param name="sigma">Standard deviations of the distributions.</param>
    /// <param name="shape">Shape to be sampled from each random distribution.</param>
    /// <param name="dtype">DType of the output in case this can&#39;t be inferred. Defaults to float32 if not defined (dtype=None).</param>
    member this.With([<Optional>] ?mu : Symbol,
        [<Optional>] ?sigma : Symbol,
        [<Optional>] ?shape : int seq,
        [<Optional>] ?dtype : FloatDType) = 
        let operatorArguments = 
            [
                mu |> Option.map (fun x -> "mu", Input x)
                sigma |> Option.map (fun x -> "sigma", Input x)
                shape |> Option.map (fun x -> "shape", Parameter(Some (box x)))
                dtype |> Option.map (fun x -> "dtype", Parameter(Some (box x)))
            ] |> List.choose id
        new SampleNormal(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type SampleGamma private (operatorArguments) = 
    inherit SymbolOperator("_sample_gamma", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new SampleGamma(args)
    override this.WithArguments(args : Arguments<Symbol>) = new SampleGamma(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <summary>Concurrent sampling from multiple
    /// gamma distributions with parameters *alpha* (shape) and *beta* (scale).
    /// 
    /// The parameters of the distributions are provided as input arrays.
    /// Let *[s]* be the shape of the input arrays, *n* be the dimension of *[s]*, *[t]*
    /// be the shape specified as the parameter of the operator, and *m* be the dimension
    /// of *[t]*. Then the output will be a *(n+m)*-dimensional array with shape *[s]x[t]*.
    /// 
    /// For any valid *n*-dimensional index *i* with respect to the input arrays, *output[i]*
    /// will be an *m*-dimensional array that holds randomly drawn samples from the distribution
    /// which is parameterized by the input values at index *i*. If the shape parameter of the
    /// operator is not set, then one sample will be drawn per distribution and the output array
    /// has the same shape as the input arrays.
    /// 
    /// Examples::
    /// 
    ///    alpha = [ 0.0, 2.5 ]
    ///    beta = [ 1.0, 0.7 ]
    /// 
    ///    // Draw a single sample for each distribution
    ///    sample_gamma(alpha, beta) = [ 0.        ,  2.25797319]
    /// 
    ///    // Draw a vector containing two samples for each distribution
    ///    sample_gamma(alpha, beta, shape=(2)) = [[ 0.        ,  0.        ],
    ///                                            [ 2.25797319,  1.70734084]]
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\random\multisample_op.cc:L282</summary>
    /// <param name="alpha">Alpha (shape) parameters of the distributions.</param>
    /// <param name="beta">Beta (scale) parameters of the distributions.</param>
    /// <param name="shape">Shape to be sampled from each random distribution.</param>
    /// <param name="dtype">DType of the output in case this can&#39;t be inferred. Defaults to float32 if not defined (dtype=None).</param>
    new([<Optional>] ?alpha : Symbol,
        [<Optional>] ?beta : Symbol,
        [<Optional>] ?shape : int seq,
        [<Optional>] ?dtype : FloatDType) = 
        let alpha = defaultArg alpha (new ImplicitVariable() :> Symbol)
        let beta = defaultArg beta (new ImplicitVariable() :> Symbol)
        let operatorArguments = 
            [
                "alpha", Input alpha
                "beta", Input beta
                "shape", shape |> Option.map box |> Parameter
                "dtype", dtype |> Option.map box |> Parameter
            ]
        new SampleGamma(Arguments<Symbol>(operatorArguments))
    /// Default value for Shape
    /// Shape to be sampled from each random distribution.
    static member ShapeDefault : int [] = [||]
    /// Default value for Dtype
    /// DType of the output in case this can&#39;t be inferred. Defaults to float32 if not defined (dtype=None).
    static member DtypeDefault : FloatDType option = None
    /// Alpha (shape) parameters of the distributions.
    member __.Alpha = operatorArguments.GetInput "alpha"
    /// Beta (scale) parameters of the distributions.
    member __.Beta = operatorArguments.GetInput "beta"
    /// Shape to be sampled from each random distribution.
    member __.Shape = operatorArguments.GetParameter("shape", SampleGamma.ShapeDefault)
    /// DType of the output in case this can&#39;t be inferred. Defaults to float32 if not defined (dtype=None).
    member __.Dtype = operatorArguments.GetParameter("dtype", SampleGamma.DtypeDefault)
    /// <summary>Copy SampleGamma instance with updated inputs/parameters.</summary>
    /// <param name="alpha">Alpha (shape) parameters of the distributions.</param>
    /// <param name="beta">Beta (scale) parameters of the distributions.</param>
    /// <param name="shape">Shape to be sampled from each random distribution.</param>
    /// <param name="dtype">DType of the output in case this can&#39;t be inferred. Defaults to float32 if not defined (dtype=None).</param>
    member this.With([<Optional>] ?alpha : Symbol,
        [<Optional>] ?beta : Symbol,
        [<Optional>] ?shape : int seq,
        [<Optional>] ?dtype : FloatDType) = 
        let operatorArguments = 
            [
                alpha |> Option.map (fun x -> "alpha", Input x)
                beta |> Option.map (fun x -> "beta", Input x)
                shape |> Option.map (fun x -> "shape", Parameter(Some (box x)))
                dtype |> Option.map (fun x -> "dtype", Parameter(Some (box x)))
            ] |> List.choose id
        new SampleGamma(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type SampleExponential private (operatorArguments) = 
    inherit SymbolOperator("_sample_exponential", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new SampleExponential(args)
    override this.WithArguments(args : Arguments<Symbol>) = new SampleExponential(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <summary>Concurrent sampling from multiple
    /// exponential distributions with parameters lambda (rate).
    /// 
    /// The parameters of the distributions are provided as an input array.
    /// Let *[s]* be the shape of the input array, *n* be the dimension of *[s]*, *[t]*
    /// be the shape specified as the parameter of the operator, and *m* be the dimension
    /// of *[t]*. Then the output will be a *(n+m)*-dimensional array with shape *[s]x[t]*.
    /// 
    /// For any valid *n*-dimensional index *i* with respect to the input array, *output[i]*
    /// will be an *m*-dimensional array that holds randomly drawn samples from the distribution
    /// which is parameterized by the input value at index *i*. If the shape parameter of the
    /// operator is not set, then one sample will be drawn per distribution and the output array
    /// has the same shape as the input array.
    /// 
    /// Examples::
    /// 
    ///    lam = [ 1.0, 8.5 ]
    /// 
    ///    // Draw a single sample for each distribution
    ///    sample_exponential(lam) = [ 0.51837951,  0.09994757]
    /// 
    ///    // Draw a vector containing two samples for each distribution
    ///    sample_exponential(lam, shape=(2)) = [[ 0.51837951,  0.19866663],
    ///                                          [ 0.09994757,  0.50447971]]
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\random\multisample_op.cc:L284</summary>
    /// <param name="lam">Lambda (rate) parameters of the distributions.</param>
    /// <param name="shape">Shape to be sampled from each random distribution.</param>
    /// <param name="dtype">DType of the output in case this can&#39;t be inferred. Defaults to float32 if not defined (dtype=None).</param>
    new([<Optional>] ?lam : Symbol,
        [<Optional>] ?shape : int seq,
        [<Optional>] ?dtype : FloatDType) = 
        let lam = defaultArg lam (new ImplicitVariable() :> Symbol)
        let operatorArguments = 
            [
                "lam", Input lam
                "shape", shape |> Option.map box |> Parameter
                "dtype", dtype |> Option.map box |> Parameter
            ]
        new SampleExponential(Arguments<Symbol>(operatorArguments))
    /// Default value for Shape
    /// Shape to be sampled from each random distribution.
    static member ShapeDefault : int [] = [||]
    /// Default value for Dtype
    /// DType of the output in case this can&#39;t be inferred. Defaults to float32 if not defined (dtype=None).
    static member DtypeDefault : FloatDType option = None
    /// Lambda (rate) parameters of the distributions.
    member __.Lam = operatorArguments.GetInput "lam"
    /// Shape to be sampled from each random distribution.
    member __.Shape = operatorArguments.GetParameter("shape", SampleExponential.ShapeDefault)
    /// DType of the output in case this can&#39;t be inferred. Defaults to float32 if not defined (dtype=None).
    member __.Dtype = operatorArguments.GetParameter("dtype", SampleExponential.DtypeDefault)
    /// <summary>Copy SampleExponential instance with updated inputs/parameters.</summary>
    /// <param name="lam">Lambda (rate) parameters of the distributions.</param>
    /// <param name="shape">Shape to be sampled from each random distribution.</param>
    /// <param name="dtype">DType of the output in case this can&#39;t be inferred. Defaults to float32 if not defined (dtype=None).</param>
    member this.With([<Optional>] ?lam : Symbol,
        [<Optional>] ?shape : int seq,
        [<Optional>] ?dtype : FloatDType) = 
        let operatorArguments = 
            [
                lam |> Option.map (fun x -> "lam", Input x)
                shape |> Option.map (fun x -> "shape", Parameter(Some (box x)))
                dtype |> Option.map (fun x -> "dtype", Parameter(Some (box x)))
            ] |> List.choose id
        new SampleExponential(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type SamplePoisson private (operatorArguments) = 
    inherit SymbolOperator("_sample_poisson", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new SamplePoisson(args)
    override this.WithArguments(args : Arguments<Symbol>) = new SamplePoisson(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <summary>Concurrent sampling from multiple
    /// Poisson distributions with parameters lambda (rate).
    /// 
    /// The parameters of the distributions are provided as an input array.
    /// Let *[s]* be the shape of the input array, *n* be the dimension of *[s]*, *[t]*
    /// be the shape specified as the parameter of the operator, and *m* be the dimension
    /// of *[t]*. Then the output will be a *(n+m)*-dimensional array with shape *[s]x[t]*.
    /// 
    /// For any valid *n*-dimensional index *i* with respect to the input array, *output[i]*
    /// will be an *m*-dimensional array that holds randomly drawn samples from the distribution
    /// which is parameterized by the input value at index *i*. If the shape parameter of the
    /// operator is not set, then one sample will be drawn per distribution and the output array
    /// has the same shape as the input array.
    /// 
    /// Samples will always be returned as a floating point data type.
    /// 
    /// Examples::
    /// 
    ///    lam = [ 1.0, 8.5 ]
    /// 
    ///    // Draw a single sample for each distribution
    ///    sample_poisson(lam) = [  0.,  13.]
    /// 
    ///    // Draw a vector containing two samples for each distribution
    ///    sample_poisson(lam, shape=(2)) = [[  0.,   4.],
    ///                                      [ 13.,   8.]]
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\random\multisample_op.cc:L286</summary>
    /// <param name="lam">Lambda (rate) parameters of the distributions.</param>
    /// <param name="shape">Shape to be sampled from each random distribution.</param>
    /// <param name="dtype">DType of the output in case this can&#39;t be inferred. Defaults to float32 if not defined (dtype=None).</param>
    new([<Optional>] ?lam : Symbol,
        [<Optional>] ?shape : int seq,
        [<Optional>] ?dtype : FloatDType) = 
        let lam = defaultArg lam (new ImplicitVariable() :> Symbol)
        let operatorArguments = 
            [
                "lam", Input lam
                "shape", shape |> Option.map box |> Parameter
                "dtype", dtype |> Option.map box |> Parameter
            ]
        new SamplePoisson(Arguments<Symbol>(operatorArguments))
    /// Default value for Shape
    /// Shape to be sampled from each random distribution.
    static member ShapeDefault : int [] = [||]
    /// Default value for Dtype
    /// DType of the output in case this can&#39;t be inferred. Defaults to float32 if not defined (dtype=None).
    static member DtypeDefault : FloatDType option = None
    /// Lambda (rate) parameters of the distributions.
    member __.Lam = operatorArguments.GetInput "lam"
    /// Shape to be sampled from each random distribution.
    member __.Shape = operatorArguments.GetParameter("shape", SamplePoisson.ShapeDefault)
    /// DType of the output in case this can&#39;t be inferred. Defaults to float32 if not defined (dtype=None).
    member __.Dtype = operatorArguments.GetParameter("dtype", SamplePoisson.DtypeDefault)
    /// <summary>Copy SamplePoisson instance with updated inputs/parameters.</summary>
    /// <param name="lam">Lambda (rate) parameters of the distributions.</param>
    /// <param name="shape">Shape to be sampled from each random distribution.</param>
    /// <param name="dtype">DType of the output in case this can&#39;t be inferred. Defaults to float32 if not defined (dtype=None).</param>
    member this.With([<Optional>] ?lam : Symbol,
        [<Optional>] ?shape : int seq,
        [<Optional>] ?dtype : FloatDType) = 
        let operatorArguments = 
            [
                lam |> Option.map (fun x -> "lam", Input x)
                shape |> Option.map (fun x -> "shape", Parameter(Some (box x)))
                dtype |> Option.map (fun x -> "dtype", Parameter(Some (box x)))
            ] |> List.choose id
        new SamplePoisson(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type SampleNegativeBinomial private (operatorArguments) = 
    inherit SymbolOperator("_sample_negative_binomial", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new SampleNegativeBinomial(args)
    override this.WithArguments(args : Arguments<Symbol>) = new SampleNegativeBinomial(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <summary>Concurrent sampling from multiple
    /// negative binomial distributions with parameters *k* (failure limit) and *p* (failure probability).
    /// 
    /// The parameters of the distributions are provided as input arrays.
    /// Let *[s]* be the shape of the input arrays, *n* be the dimension of *[s]*, *[t]*
    /// be the shape specified as the parameter of the operator, and *m* be the dimension
    /// of *[t]*. Then the output will be a *(n+m)*-dimensional array with shape *[s]x[t]*.
    /// 
    /// For any valid *n*-dimensional index *i* with respect to the input arrays, *output[i]*
    /// will be an *m*-dimensional array that holds randomly drawn samples from the distribution
    /// which is parameterized by the input values at index *i*. If the shape parameter of the
    /// operator is not set, then one sample will be drawn per distribution and the output array
    /// has the same shape as the input arrays.
    /// 
    /// Samples will always be returned as a floating point data type.
    /// 
    /// Examples::
    /// 
    ///    k = [ 20, 49 ]
    ///    p = [ 0.4 , 0.77 ]
    /// 
    ///    // Draw a single sample for each distribution
    ///    sample_negative_binomial(k, p) = [ 15.,  16.]
    /// 
    ///    // Draw a vector containing two samples for each distribution
    ///    sample_negative_binomial(k, p, shape=(2)) = [[ 15.,  50.],
    ///                                                 [ 16.,  12.]]
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\random\multisample_op.cc:L289</summary>
    /// <param name="k">Limits of unsuccessful experiments.</param>
    /// <param name="p">Failure probabilities in each experiment.</param>
    /// <param name="shape">Shape to be sampled from each random distribution.</param>
    /// <param name="dtype">DType of the output in case this can&#39;t be inferred. Defaults to float32 if not defined (dtype=None).</param>
    new([<Optional>] ?k : Symbol,
        [<Optional>] ?p : Symbol,
        [<Optional>] ?shape : int seq,
        [<Optional>] ?dtype : FloatDType) = 
        let k = defaultArg k (new ImplicitVariable() :> Symbol)
        let p = defaultArg p (new ImplicitVariable() :> Symbol)
        let operatorArguments = 
            [
                "k", Input k
                "p", Input p
                "shape", shape |> Option.map box |> Parameter
                "dtype", dtype |> Option.map box |> Parameter
            ]
        new SampleNegativeBinomial(Arguments<Symbol>(operatorArguments))
    /// Default value for Shape
    /// Shape to be sampled from each random distribution.
    static member ShapeDefault : int [] = [||]
    /// Default value for Dtype
    /// DType of the output in case this can&#39;t be inferred. Defaults to float32 if not defined (dtype=None).
    static member DtypeDefault : FloatDType option = None
    /// Limits of unsuccessful experiments.
    member __.K = operatorArguments.GetInput "k"
    /// Failure probabilities in each experiment.
    member __.P = operatorArguments.GetInput "p"
    /// Shape to be sampled from each random distribution.
    member __.Shape = operatorArguments.GetParameter("shape", SampleNegativeBinomial.ShapeDefault)
    /// DType of the output in case this can&#39;t be inferred. Defaults to float32 if not defined (dtype=None).
    member __.Dtype = operatorArguments.GetParameter("dtype", SampleNegativeBinomial.DtypeDefault)
    /// <summary>Copy SampleNegativeBinomial instance with updated inputs/parameters.</summary>
    /// <param name="k">Limits of unsuccessful experiments.</param>
    /// <param name="p">Failure probabilities in each experiment.</param>
    /// <param name="shape">Shape to be sampled from each random distribution.</param>
    /// <param name="dtype">DType of the output in case this can&#39;t be inferred. Defaults to float32 if not defined (dtype=None).</param>
    member this.With([<Optional>] ?k : Symbol,
        [<Optional>] ?p : Symbol,
        [<Optional>] ?shape : int seq,
        [<Optional>] ?dtype : FloatDType) = 
        let operatorArguments = 
            [
                k |> Option.map (fun x -> "k", Input x)
                p |> Option.map (fun x -> "p", Input x)
                shape |> Option.map (fun x -> "shape", Parameter(Some (box x)))
                dtype |> Option.map (fun x -> "dtype", Parameter(Some (box x)))
            ] |> List.choose id
        new SampleNegativeBinomial(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type SampleGeneralizedNegativeBinomial private (operatorArguments) = 
    inherit SymbolOperator("_sample_generalized_negative_binomial", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new SampleGeneralizedNegativeBinomial(args)
    override this.WithArguments(args : Arguments<Symbol>) = new SampleGeneralizedNegativeBinomial(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <summary>Concurrent sampling from multiple
    /// generalized negative binomial distributions with parameters *mu* (mean) and *alpha* (dispersion).
    /// 
    /// The parameters of the distributions are provided as input arrays.
    /// Let *[s]* be the shape of the input arrays, *n* be the dimension of *[s]*, *[t]*
    /// be the shape specified as the parameter of the operator, and *m* be the dimension
    /// of *[t]*. Then the output will be a *(n+m)*-dimensional array with shape *[s]x[t]*.
    /// 
    /// For any valid *n*-dimensional index *i* with respect to the input arrays, *output[i]*
    /// will be an *m*-dimensional array that holds randomly drawn samples from the distribution
    /// which is parameterized by the input values at index *i*. If the shape parameter of the
    /// operator is not set, then one sample will be drawn per distribution and the output array
    /// has the same shape as the input arrays.
    /// 
    /// Samples will always be returned as a floating point data type.
    /// 
    /// Examples::
    /// 
    ///    mu = [ 2.0, 2.5 ]
    ///    alpha = [ 1.0, 0.1 ]
    /// 
    ///    // Draw a single sample for each distribution
    ///    sample_generalized_negative_binomial(mu, alpha) = [ 0.,  3.]
    /// 
    ///    // Draw a vector containing two samples for each distribution
    ///    sample_generalized_negative_binomial(mu, alpha, shape=(2)) = [[ 0.,  3.],
    ///                                                                  [ 3.,  1.]]
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\random\multisample_op.cc:L293</summary>
    /// <param name="mu">Means of the distributions.</param>
    /// <param name="alpha">Alpha (dispersion) parameters of the distributions.</param>
    /// <param name="shape">Shape to be sampled from each random distribution.</param>
    /// <param name="dtype">DType of the output in case this can&#39;t be inferred. Defaults to float32 if not defined (dtype=None).</param>
    new([<Optional>] ?mu : Symbol,
        [<Optional>] ?alpha : Symbol,
        [<Optional>] ?shape : int seq,
        [<Optional>] ?dtype : FloatDType) = 
        let mu = defaultArg mu (new ImplicitVariable() :> Symbol)
        let alpha = defaultArg alpha (new ImplicitVariable() :> Symbol)
        let operatorArguments = 
            [
                "mu", Input mu
                "alpha", Input alpha
                "shape", shape |> Option.map box |> Parameter
                "dtype", dtype |> Option.map box |> Parameter
            ]
        new SampleGeneralizedNegativeBinomial(Arguments<Symbol>(operatorArguments))
    /// Default value for Shape
    /// Shape to be sampled from each random distribution.
    static member ShapeDefault : int [] = [||]
    /// Default value for Dtype
    /// DType of the output in case this can&#39;t be inferred. Defaults to float32 if not defined (dtype=None).
    static member DtypeDefault : FloatDType option = None
    /// Means of the distributions.
    member __.Mu = operatorArguments.GetInput "mu"
    /// Alpha (dispersion) parameters of the distributions.
    member __.Alpha = operatorArguments.GetInput "alpha"
    /// Shape to be sampled from each random distribution.
    member __.Shape = operatorArguments.GetParameter("shape", SampleGeneralizedNegativeBinomial.ShapeDefault)
    /// DType of the output in case this can&#39;t be inferred. Defaults to float32 if not defined (dtype=None).
    member __.Dtype = operatorArguments.GetParameter("dtype", SampleGeneralizedNegativeBinomial.DtypeDefault)
    /// <summary>Copy SampleGeneralizedNegativeBinomial instance with updated inputs/parameters.</summary>
    /// <param name="mu">Means of the distributions.</param>
    /// <param name="alpha">Alpha (dispersion) parameters of the distributions.</param>
    /// <param name="shape">Shape to be sampled from each random distribution.</param>
    /// <param name="dtype">DType of the output in case this can&#39;t be inferred. Defaults to float32 if not defined (dtype=None).</param>
    member this.With([<Optional>] ?mu : Symbol,
        [<Optional>] ?alpha : Symbol,
        [<Optional>] ?shape : int seq,
        [<Optional>] ?dtype : FloatDType) = 
        let operatorArguments = 
            [
                mu |> Option.map (fun x -> "mu", Input x)
                alpha |> Option.map (fun x -> "alpha", Input x)
                shape |> Option.map (fun x -> "shape", Parameter(Some (box x)))
                dtype |> Option.map (fun x -> "dtype", Parameter(Some (box x)))
            ] |> List.choose id
        new SampleGeneralizedNegativeBinomial(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type RandomPdfUniform private (operatorArguments) = 
    inherit SymbolOperator("_random_pdf_uniform", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new RandomPdfUniform(args)
    override this.WithArguments(args : Arguments<Symbol>) = new RandomPdfUniform(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <summary>Computes the value of the PDF of *sample* of
    /// uniform distributions on the intervals given by *[low,high)*.
    /// 
    /// *low* and *high* must have the same shape, which must match the leftmost subshape
    /// of *sample*.  That is, *sample* can have the same shape as *low* and *high*, in which
    /// case the output contains one density per distribution, or *sample* can be a tensor
    /// of tensors with that shape, in which case the output is a tensor of densities such that
    /// the densities at index *i* in the output are given by the samples at index *i* in *sample*
    /// parameterized by the values of *low* and *high* at index *i*.
    /// 
    /// Examples::
    /// 
    ///     random_pdf_uniform(sample=[[1,2,3,4]], low=[0], high=[10]) = [0.1, 0.1, 0.1, 0.1]
    /// 
    ///     sample = [[[1, 2, 3],
    ///                [1, 2, 3]],
    ///               [[1, 2, 3],
    ///                [1, 2, 3]]]
    ///     low  = [[0, 0],
    ///             [0, 0]]
    ///     high = [[ 5, 10],
    ///             [15, 20]]
    ///     random_pdf_uniform(sample=sample, low=low, high=high) =
    ///         [[[0.2,        0.2,        0.2    ],
    ///           [0.1,        0.1,        0.1    ]],
    ///          [[0.06667,    0.06667,    0.06667],
    ///           [0.05,       0.05,       0.05   ]]]
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\random\pdf_op.cc:L298</summary>
    /// <param name="sample">Samples from the distributions.</param>
    /// <param name="low">Lower bounds of the distributions.</param>
    /// <param name="high">Upper bounds of the distributions.</param>
    /// <param name="isLog">If set, compute the density of the log-probability instead of the probability.</param>
    new([<Optional>] ?sample : Symbol,
        [<Optional>] ?low : Symbol,
        [<Optional>] ?high : Symbol,
        [<Optional>] ?isLog : bool) = 
        let sample = defaultArg sample (new ImplicitVariable() :> Symbol)
        let low = defaultArg low (new ImplicitVariable() :> Symbol)
        let high = defaultArg high (new ImplicitVariable() :> Symbol)
        let operatorArguments = 
            [
                "sample", Input sample
                "low", Input low
                "high", Input high
                "is_log", isLog |> Option.map box |> Parameter
            ]
        new RandomPdfUniform(Arguments<Symbol>(operatorArguments))
    /// Default value for IsLog
    /// If set, compute the density of the log-probability instead of the probability.
    static member IsLogDefault : bool = false
    /// Samples from the distributions.
    member __.Sample = operatorArguments.GetInput "sample"
    /// Lower bounds of the distributions.
    member __.Low = operatorArguments.GetInput "low"
    /// Upper bounds of the distributions.
    member __.High = operatorArguments.GetInput "high"
    /// If set, compute the density of the log-probability instead of the probability.
    member __.IsLog = operatorArguments.GetParameter("is_log", RandomPdfUniform.IsLogDefault)
    /// <summary>Copy RandomPdfUniform instance with updated inputs/parameters.</summary>
    /// <param name="sample">Samples from the distributions.</param>
    /// <param name="low">Lower bounds of the distributions.</param>
    /// <param name="high">Upper bounds of the distributions.</param>
    /// <param name="isLog">If set, compute the density of the log-probability instead of the probability.</param>
    member this.With([<Optional>] ?sample : Symbol,
        [<Optional>] ?low : Symbol,
        [<Optional>] ?high : Symbol,
        [<Optional>] ?isLog : bool) = 
        let operatorArguments = 
            [
                sample |> Option.map (fun x -> "sample", Input x)
                low |> Option.map (fun x -> "low", Input x)
                high |> Option.map (fun x -> "high", Input x)
                isLog |> Option.map (fun x -> "is_log", Parameter(Some (box x)))
            ] |> List.choose id
        new RandomPdfUniform(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type RandomPdfNormal private (operatorArguments) = 
    inherit SymbolOperator("_random_pdf_normal", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new RandomPdfNormal(args)
    override this.WithArguments(args : Arguments<Symbol>) = new RandomPdfNormal(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <summary>Computes the value of the PDF of *sample* of
    /// normal distributions with parameters *mu* (mean) and *sigma* (standard deviation).
    /// 
    /// *mu* and *sigma* must have the same shape, which must match the leftmost subshape
    /// of *sample*.  That is, *sample* can have the same shape as *mu* and *sigma*, in which
    /// case the output contains one density per distribution, or *sample* can be a tensor
    /// of tensors with that shape, in which case the output is a tensor of densities such that
    /// the densities at index *i* in the output are given by the samples at index *i* in *sample*
    /// parameterized by the values of *mu* and *sigma* at index *i*.
    /// 
    /// Examples::
    /// 
    ///     sample = [[-2, -1, 0, 1, 2]]
    ///     random_pdf_normal(sample=sample, mu=[0], sigma=[1]) =
    ///         [[0.05399097, 0.24197073, 0.3989423, 0.24197073, 0.05399097]]
    /// 
    ///     random_pdf_normal(sample=sample*2, mu=[0,0], sigma=[1,2]) =
    ///         [[0.05399097, 0.24197073, 0.3989423,  0.24197073, 0.05399097],
    ///          [0.12098537, 0.17603266, 0.19947115, 0.17603266, 0.12098537]]
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\random\pdf_op.cc:L300</summary>
    /// <param name="sample">Samples from the distributions.</param>
    /// <param name="mu">Means of the distributions.</param>
    /// <param name="sigma">Standard deviations of the distributions.</param>
    /// <param name="isLog">If set, compute the density of the log-probability instead of the probability.</param>
    new([<Optional>] ?sample : Symbol,
        [<Optional>] ?mu : Symbol,
        [<Optional>] ?sigma : Symbol,
        [<Optional>] ?isLog : bool) = 
        let sample = defaultArg sample (new ImplicitVariable() :> Symbol)
        let mu = defaultArg mu (new ImplicitVariable() :> Symbol)
        let sigma = defaultArg sigma (new ImplicitVariable() :> Symbol)
        let operatorArguments = 
            [
                "sample", Input sample
                "mu", Input mu
                "sigma", Input sigma
                "is_log", isLog |> Option.map box |> Parameter
            ]
        new RandomPdfNormal(Arguments<Symbol>(operatorArguments))
    /// Default value for IsLog
    /// If set, compute the density of the log-probability instead of the probability.
    static member IsLogDefault : bool = false
    /// Samples from the distributions.
    member __.Sample = operatorArguments.GetInput "sample"
    /// Means of the distributions.
    member __.Mu = operatorArguments.GetInput "mu"
    /// Standard deviations of the distributions.
    member __.Sigma = operatorArguments.GetInput "sigma"
    /// If set, compute the density of the log-probability instead of the probability.
    member __.IsLog = operatorArguments.GetParameter("is_log", RandomPdfNormal.IsLogDefault)
    /// <summary>Copy RandomPdfNormal instance with updated inputs/parameters.</summary>
    /// <param name="sample">Samples from the distributions.</param>
    /// <param name="mu">Means of the distributions.</param>
    /// <param name="sigma">Standard deviations of the distributions.</param>
    /// <param name="isLog">If set, compute the density of the log-probability instead of the probability.</param>
    member this.With([<Optional>] ?sample : Symbol,
        [<Optional>] ?mu : Symbol,
        [<Optional>] ?sigma : Symbol,
        [<Optional>] ?isLog : bool) = 
        let operatorArguments = 
            [
                sample |> Option.map (fun x -> "sample", Input x)
                mu |> Option.map (fun x -> "mu", Input x)
                sigma |> Option.map (fun x -> "sigma", Input x)
                isLog |> Option.map (fun x -> "is_log", Parameter(Some (box x)))
            ] |> List.choose id
        new RandomPdfNormal(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type RandomPdfGamma private (operatorArguments) = 
    inherit SymbolOperator("_random_pdf_gamma", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new RandomPdfGamma(args)
    override this.WithArguments(args : Arguments<Symbol>) = new RandomPdfGamma(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <summary>Computes the value of the PDF of *sample* of
    /// gamma distributions with parameters *alpha* (shape) and *beta* (rate).
    /// 
    /// *alpha* and *beta* must have the same shape, which must match the leftmost subshape
    /// of *sample*.  That is, *sample* can have the same shape as *alpha* and *beta*, in which
    /// case the output contains one density per distribution, or *sample* can be a tensor
    /// of tensors with that shape, in which case the output is a tensor of densities such that
    /// the densities at index *i* in the output are given by the samples at index *i* in *sample*
    /// parameterized by the values of *alpha* and *beta* at index *i*.
    /// 
    /// Examples::
    /// 
    ///   random_pdf_gamma(sample=[[1,2,3,4,5]], alpha=[5], beta=[1]) =
    ///       [[0.01532831, 0.09022352, 0.16803136, 0.19536681, 0.17546739]]
    /// 
    ///   sample = [[1, 2, 3, 4, 5],
    ///             [2, 3, 4, 5, 6],
    ///             [3, 4, 5, 6, 7]]
    /// 
    ///   random_pdf_gamma(sample=sample, alpha=[5,6,7], beta=[1,1,1]) =
    ///       [[0.01532831, 0.09022352, 0.16803136, 0.19536681, 0.17546739],
    ///        [0.03608941, 0.10081882, 0.15629345, 0.17546739, 0.16062315],
    ///        [0.05040941, 0.10419563, 0.14622283, 0.16062315, 0.14900276]]
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\random\pdf_op.cc:L303</summary>
    /// <param name="sample">Samples from the distributions.</param>
    /// <param name="alpha">Alpha (shape) parameters of the distributions.</param>
    /// <param name="beta">Beta (scale) parameters of the distributions.</param>
    /// <param name="isLog">If set, compute the density of the log-probability instead of the probability.</param>
    new([<Optional>] ?sample : Symbol,
        [<Optional>] ?alpha : Symbol,
        [<Optional>] ?beta : Symbol,
        [<Optional>] ?isLog : bool) = 
        let sample = defaultArg sample (new ImplicitVariable() :> Symbol)
        let alpha = defaultArg alpha (new ImplicitVariable() :> Symbol)
        let beta = defaultArg beta (new ImplicitVariable() :> Symbol)
        let operatorArguments = 
            [
                "sample", Input sample
                "alpha", Input alpha
                "beta", Input beta
                "is_log", isLog |> Option.map box |> Parameter
            ]
        new RandomPdfGamma(Arguments<Symbol>(operatorArguments))
    /// Default value for IsLog
    /// If set, compute the density of the log-probability instead of the probability.
    static member IsLogDefault : bool = false
    /// Samples from the distributions.
    member __.Sample = operatorArguments.GetInput "sample"
    /// Alpha (shape) parameters of the distributions.
    member __.Alpha = operatorArguments.GetInput "alpha"
    /// Beta (scale) parameters of the distributions.
    member __.Beta = operatorArguments.GetInput "beta"
    /// If set, compute the density of the log-probability instead of the probability.
    member __.IsLog = operatorArguments.GetParameter("is_log", RandomPdfGamma.IsLogDefault)
    /// <summary>Copy RandomPdfGamma instance with updated inputs/parameters.</summary>
    /// <param name="sample">Samples from the distributions.</param>
    /// <param name="alpha">Alpha (shape) parameters of the distributions.</param>
    /// <param name="beta">Beta (scale) parameters of the distributions.</param>
    /// <param name="isLog">If set, compute the density of the log-probability instead of the probability.</param>
    member this.With([<Optional>] ?sample : Symbol,
        [<Optional>] ?alpha : Symbol,
        [<Optional>] ?beta : Symbol,
        [<Optional>] ?isLog : bool) = 
        let operatorArguments = 
            [
                sample |> Option.map (fun x -> "sample", Input x)
                alpha |> Option.map (fun x -> "alpha", Input x)
                beta |> Option.map (fun x -> "beta", Input x)
                isLog |> Option.map (fun x -> "is_log", Parameter(Some (box x)))
            ] |> List.choose id
        new RandomPdfGamma(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type RandomPdfExponential private (operatorArguments) = 
    inherit SymbolOperator("_random_pdf_exponential", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new RandomPdfExponential(args)
    override this.WithArguments(args : Arguments<Symbol>) = new RandomPdfExponential(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <summary>Computes the value of the PDF of *sample* of
    /// exponential distributions with parameters *lam* (rate).
    /// 
    /// The shape of *lam* must match the leftmost subshape of *sample*.  That is, *sample*
    /// can have the same shape as *lam*, in which case the output contains one density per
    /// distribution, or *sample* can be a tensor of tensors with that shape, in which case
    /// the output is a tensor of densities such that the densities at index *i* in the output
    /// are given by the samples at index *i* in *sample* parameterized by the value of *lam*
    /// at index *i*.
    /// 
    /// Examples::
    /// 
    ///   random_pdf_exponential(sample=[[1, 2, 3]], lam=[1]) =
    ///       [[0.36787945, 0.13533528, 0.04978707]]
    /// 
    ///   sample = [[1,2,3],
    ///             [1,2,3],
    ///             [1,2,3]]
    /// 
    ///   random_pdf_exponential(sample=sample, lam=[1,0.5,0.25]) =
    ///       [[0.36787945, 0.13533528, 0.04978707],
    ///        [0.30326533, 0.18393973, 0.11156508],
    ///        [0.1947002,  0.15163267, 0.11809164]]
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\random\pdf_op.cc:L305</summary>
    /// <param name="sample">Samples from the distributions.</param>
    /// <param name="lam">Lambda (rate) parameters of the distributions.</param>
    /// <param name="isLog">If set, compute the density of the log-probability instead of the probability.</param>
    new([<Optional>] ?sample : Symbol,
        [<Optional>] ?lam : Symbol,
        [<Optional>] ?isLog : bool) = 
        let sample = defaultArg sample (new ImplicitVariable() :> Symbol)
        let lam = defaultArg lam (new ImplicitVariable() :> Symbol)
        let operatorArguments = 
            [
                "sample", Input sample
                "lam", Input lam
                "is_log", isLog |> Option.map box |> Parameter
            ]
        new RandomPdfExponential(Arguments<Symbol>(operatorArguments))
    /// Default value for IsLog
    /// If set, compute the density of the log-probability instead of the probability.
    static member IsLogDefault : bool = false
    /// Samples from the distributions.
    member __.Sample = operatorArguments.GetInput "sample"
    /// Lambda (rate) parameters of the distributions.
    member __.Lam = operatorArguments.GetInput "lam"
    /// If set, compute the density of the log-probability instead of the probability.
    member __.IsLog = operatorArguments.GetParameter("is_log", RandomPdfExponential.IsLogDefault)
    /// <summary>Copy RandomPdfExponential instance with updated inputs/parameters.</summary>
    /// <param name="sample">Samples from the distributions.</param>
    /// <param name="lam">Lambda (rate) parameters of the distributions.</param>
    /// <param name="isLog">If set, compute the density of the log-probability instead of the probability.</param>
    member this.With([<Optional>] ?sample : Symbol,
        [<Optional>] ?lam : Symbol,
        [<Optional>] ?isLog : bool) = 
        let operatorArguments = 
            [
                sample |> Option.map (fun x -> "sample", Input x)
                lam |> Option.map (fun x -> "lam", Input x)
                isLog |> Option.map (fun x -> "is_log", Parameter(Some (box x)))
            ] |> List.choose id
        new RandomPdfExponential(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type RandomPdfPoisson private (operatorArguments) = 
    inherit SymbolOperator("_random_pdf_poisson", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new RandomPdfPoisson(args)
    override this.WithArguments(args : Arguments<Symbol>) = new RandomPdfPoisson(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <summary>Computes the value of the PDF of *sample* of
    /// Poisson distributions with parameters *lam* (rate).
    /// 
    /// The shape of *lam* must match the leftmost subshape of *sample*.  That is, *sample*
    /// can have the same shape as *lam*, in which case the output contains one density per
    /// distribution, or *sample* can be a tensor of tensors with that shape, in which case
    /// the output is a tensor of densities such that the densities at index *i* in the output
    /// are given by the samples at index *i* in *sample* parameterized by the value of *lam*
    /// at index *i*.
    /// 
    /// Examples::
    /// 
    ///     random_pdf_poisson(sample=[[0,1,2,3]], lam=[1]) =
    ///         [[0.36787945, 0.36787945, 0.18393973, 0.06131324]]
    /// 
    ///     sample = [[0,1,2,3],
    ///               [0,1,2,3],
    ///               [0,1,2,3]]
    /// 
    ///     random_pdf_poisson(sample=sample, lam=[1,2,3]) =
    ///         [[0.36787945, 0.36787945, 0.18393973, 0.06131324],
    ///          [0.13533528, 0.27067056, 0.27067056, 0.18044704],
    ///          [0.04978707, 0.14936121, 0.22404182, 0.22404182]]
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\random\pdf_op.cc:L307</summary>
    /// <param name="sample">Samples from the distributions.</param>
    /// <param name="lam">Lambda (rate) parameters of the distributions.</param>
    /// <param name="isLog">If set, compute the density of the log-probability instead of the probability.</param>
    new([<Optional>] ?sample : Symbol,
        [<Optional>] ?lam : Symbol,
        [<Optional>] ?isLog : bool) = 
        let sample = defaultArg sample (new ImplicitVariable() :> Symbol)
        let lam = defaultArg lam (new ImplicitVariable() :> Symbol)
        let operatorArguments = 
            [
                "sample", Input sample
                "lam", Input lam
                "is_log", isLog |> Option.map box |> Parameter
            ]
        new RandomPdfPoisson(Arguments<Symbol>(operatorArguments))
    /// Default value for IsLog
    /// If set, compute the density of the log-probability instead of the probability.
    static member IsLogDefault : bool = false
    /// Samples from the distributions.
    member __.Sample = operatorArguments.GetInput "sample"
    /// Lambda (rate) parameters of the distributions.
    member __.Lam = operatorArguments.GetInput "lam"
    /// If set, compute the density of the log-probability instead of the probability.
    member __.IsLog = operatorArguments.GetParameter("is_log", RandomPdfPoisson.IsLogDefault)
    /// <summary>Copy RandomPdfPoisson instance with updated inputs/parameters.</summary>
    /// <param name="sample">Samples from the distributions.</param>
    /// <param name="lam">Lambda (rate) parameters of the distributions.</param>
    /// <param name="isLog">If set, compute the density of the log-probability instead of the probability.</param>
    member this.With([<Optional>] ?sample : Symbol,
        [<Optional>] ?lam : Symbol,
        [<Optional>] ?isLog : bool) = 
        let operatorArguments = 
            [
                sample |> Option.map (fun x -> "sample", Input x)
                lam |> Option.map (fun x -> "lam", Input x)
                isLog |> Option.map (fun x -> "is_log", Parameter(Some (box x)))
            ] |> List.choose id
        new RandomPdfPoisson(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type RandomPdfNegativeBinomial private (operatorArguments) = 
    inherit SymbolOperator("_random_pdf_negative_binomial", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new RandomPdfNegativeBinomial(args)
    override this.WithArguments(args : Arguments<Symbol>) = new RandomPdfNegativeBinomial(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <summary>Computes the value of the PDF of samples of
    /// negative binomial distributions with parameters *k* (failure limit) and *p* (failure probability).
    /// 
    /// *k* and *p* must have the same shape, which must match the leftmost subshape
    /// of *sample*.  That is, *sample* can have the same shape as *k* and *p*, in which
    /// case the output contains one density per distribution, or *sample* can be a tensor
    /// of tensors with that shape, in which case the output is a tensor of densities such that
    /// the densities at index *i* in the output are given by the samples at index *i* in *sample*
    /// parameterized by the values of *k* and *p* at index *i*.
    /// 
    /// Examples::
    /// 
    ///     random_pdf_negative_binomial(sample=[[1,2,3,4]], k=[1], p=a[0.5]) =
    ///         [[0.25, 0.125, 0.0625, 0.03125]]
    /// 
    ///     # Note that k may be real-valued
    ///     sample = [[1,2,3,4],
    ///               [1,2,3,4]]
    ///     random_pdf_negative_binomial(sample=sample, k=[1, 1.5], p=[0.5, 0.5]) =
    ///         [[0.25,       0.125,      0.0625,     0.03125   ],
    ///          [0.26516506, 0.16572815, 0.09667476, 0.05437956]]
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\random\pdf_op.cc:L310</summary>
    /// <param name="sample">Samples from the distributions.</param>
    /// <param name="k">Limits of unsuccessful experiments.</param>
    /// <param name="p">Failure probabilities in each experiment.</param>
    /// <param name="isLog">If set, compute the density of the log-probability instead of the probability.</param>
    new([<Optional>] ?sample : Symbol,
        [<Optional>] ?k : Symbol,
        [<Optional>] ?p : Symbol,
        [<Optional>] ?isLog : bool) = 
        let sample = defaultArg sample (new ImplicitVariable() :> Symbol)
        let k = defaultArg k (new ImplicitVariable() :> Symbol)
        let p = defaultArg p (new ImplicitVariable() :> Symbol)
        let operatorArguments = 
            [
                "sample", Input sample
                "k", Input k
                "p", Input p
                "is_log", isLog |> Option.map box |> Parameter
            ]
        new RandomPdfNegativeBinomial(Arguments<Symbol>(operatorArguments))
    /// Default value for IsLog
    /// If set, compute the density of the log-probability instead of the probability.
    static member IsLogDefault : bool = false
    /// Samples from the distributions.
    member __.Sample = operatorArguments.GetInput "sample"
    /// Limits of unsuccessful experiments.
    member __.K = operatorArguments.GetInput "k"
    /// Failure probabilities in each experiment.
    member __.P = operatorArguments.GetInput "p"
    /// If set, compute the density of the log-probability instead of the probability.
    member __.IsLog = operatorArguments.GetParameter("is_log", RandomPdfNegativeBinomial.IsLogDefault)
    /// <summary>Copy RandomPdfNegativeBinomial instance with updated inputs/parameters.</summary>
    /// <param name="sample">Samples from the distributions.</param>
    /// <param name="k">Limits of unsuccessful experiments.</param>
    /// <param name="p">Failure probabilities in each experiment.</param>
    /// <param name="isLog">If set, compute the density of the log-probability instead of the probability.</param>
    member this.With([<Optional>] ?sample : Symbol,
        [<Optional>] ?k : Symbol,
        [<Optional>] ?p : Symbol,
        [<Optional>] ?isLog : bool) = 
        let operatorArguments = 
            [
                sample |> Option.map (fun x -> "sample", Input x)
                k |> Option.map (fun x -> "k", Input x)
                p |> Option.map (fun x -> "p", Input x)
                isLog |> Option.map (fun x -> "is_log", Parameter(Some (box x)))
            ] |> List.choose id
        new RandomPdfNegativeBinomial(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type RandomPdfGeneralizedNegativeBinomial private (operatorArguments) = 
    inherit SymbolOperator("_random_pdf_generalized_negative_binomial", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new RandomPdfGeneralizedNegativeBinomial(args)
    override this.WithArguments(args : Arguments<Symbol>) = new RandomPdfGeneralizedNegativeBinomial(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <summary>Computes the value of the PDF of *sample* of
    /// generalized negative binomial distributions with parameters *mu* (mean)
    /// and *alpha* (dispersion).  This can be understood as a reparameterization of
    /// the negative binomial, where *k* = *1 / alpha* and *p* = *1 / (mu \* alpha + 1)*.
    /// 
    /// *mu* and *alpha* must have the same shape, which must match the leftmost subshape
    /// of *sample*.  That is, *sample* can have the same shape as *mu* and *alpha*, in which
    /// case the output contains one density per distribution, or *sample* can be a tensor
    /// of tensors with that shape, in which case the output is a tensor of densities such that
    /// the densities at index *i* in the output are given by the samples at index *i* in *sample*
    /// parameterized by the values of *mu* and *alpha* at index *i*.
    /// 
    /// Examples::
    /// 
    ///     random_pdf_generalized_negative_binomial(sample=[[1, 2, 3, 4]], alpha=[1], mu=[1]) =
    ///         [[0.25, 0.125, 0.0625, 0.03125]]
    /// 
    ///     sample = [[1,2,3,4],
    ///               [1,2,3,4]]
    ///     random_pdf_generalized_negative_binomial(sample=sample, alpha=[1, 0.6666], mu=[1, 1.5]) =
    ///         [[0.25,       0.125,      0.0625,     0.03125   ],
    ///          [0.26517063, 0.16573331, 0.09667706, 0.05437994]]
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\random\pdf_op.cc:L314</summary>
    /// <param name="sample">Samples from the distributions.</param>
    /// <param name="mu">Means of the distributions.</param>
    /// <param name="alpha">Alpha (dispersion) parameters of the distributions.</param>
    /// <param name="isLog">If set, compute the density of the log-probability instead of the probability.</param>
    new([<Optional>] ?sample : Symbol,
        [<Optional>] ?mu : Symbol,
        [<Optional>] ?alpha : Symbol,
        [<Optional>] ?isLog : bool) = 
        let sample = defaultArg sample (new ImplicitVariable() :> Symbol)
        let mu = defaultArg mu (new ImplicitVariable() :> Symbol)
        let alpha = defaultArg alpha (new ImplicitVariable() :> Symbol)
        let operatorArguments = 
            [
                "sample", Input sample
                "mu", Input mu
                "alpha", Input alpha
                "is_log", isLog |> Option.map box |> Parameter
            ]
        new RandomPdfGeneralizedNegativeBinomial(Arguments<Symbol>(operatorArguments))
    /// Default value for IsLog
    /// If set, compute the density of the log-probability instead of the probability.
    static member IsLogDefault : bool = false
    /// Samples from the distributions.
    member __.Sample = operatorArguments.GetInput "sample"
    /// Means of the distributions.
    member __.Mu = operatorArguments.GetInput "mu"
    /// Alpha (dispersion) parameters of the distributions.
    member __.Alpha = operatorArguments.GetInput "alpha"
    /// If set, compute the density of the log-probability instead of the probability.
    member __.IsLog = operatorArguments.GetParameter("is_log", RandomPdfGeneralizedNegativeBinomial.IsLogDefault)
    /// <summary>Copy RandomPdfGeneralizedNegativeBinomial instance with updated inputs/parameters.</summary>
    /// <param name="sample">Samples from the distributions.</param>
    /// <param name="mu">Means of the distributions.</param>
    /// <param name="alpha">Alpha (dispersion) parameters of the distributions.</param>
    /// <param name="isLog">If set, compute the density of the log-probability instead of the probability.</param>
    member this.With([<Optional>] ?sample : Symbol,
        [<Optional>] ?mu : Symbol,
        [<Optional>] ?alpha : Symbol,
        [<Optional>] ?isLog : bool) = 
        let operatorArguments = 
            [
                sample |> Option.map (fun x -> "sample", Input x)
                mu |> Option.map (fun x -> "mu", Input x)
                alpha |> Option.map (fun x -> "alpha", Input x)
                isLog |> Option.map (fun x -> "is_log", Parameter(Some (box x)))
            ] |> List.choose id
        new RandomPdfGeneralizedNegativeBinomial(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type RandomPdfDirichlet private (operatorArguments) = 
    inherit SymbolOperator("_random_pdf_dirichlet", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new RandomPdfDirichlet(args)
    override this.WithArguments(args : Arguments<Symbol>) = new RandomPdfDirichlet(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <summary>Computes the value of the PDF of *sample* of
    /// Dirichlet distributions with parameter *alpha*.
    /// 
    /// The shape of *alpha* must match the leftmost subshape of *sample*.  That is, *sample*
    /// can have the same shape as *alpha*, in which case the output contains one density per
    /// distribution, or *sample* can be a tensor of tensors with that shape, in which case
    /// the output is a tensor of densities such that the densities at index *i* in the output
    /// are given by the samples at index *i* in *sample* parameterized by the value of *alpha*
    /// at index *i*.
    /// 
    /// Examples::
    /// 
    ///     random_pdf_dirichlet(sample=[[1,2],[2,3],[3,4]], alpha=[2.5, 2.5]) =
    ///         [38.413498, 199.60245, 564.56085]
    /// 
    ///     sample = [[[1, 2, 3], [10, 20, 30], [100, 200, 300]],
    ///               [[0.1, 0.2, 0.3], [0.01, 0.02, 0.03], [0.001, 0.002, 0.003]]]
    /// 
    ///     random_pdf_dirichlet(sample=sample, alpha=[0.1, 0.4, 0.9]) =
    ///         [[2.3257459e-02, 5.8420084e-04, 1.4674458e-05],
    ///          [9.2589635e-01, 3.6860607e+01, 1.4674468e+03]]
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\random\pdf_op.cc:L316</summary>
    /// <param name="sample">Samples from the distributions.</param>
    /// <param name="alpha">Concentration parameters of the distributions.</param>
    /// <param name="isLog">If set, compute the density of the log-probability instead of the probability.</param>
    new([<Optional>] ?sample : Symbol,
        [<Optional>] ?alpha : Symbol,
        [<Optional>] ?isLog : bool) = 
        let sample = defaultArg sample (new ImplicitVariable() :> Symbol)
        let alpha = defaultArg alpha (new ImplicitVariable() :> Symbol)
        let operatorArguments = 
            [
                "sample", Input sample
                "alpha", Input alpha
                "is_log", isLog |> Option.map box |> Parameter
            ]
        new RandomPdfDirichlet(Arguments<Symbol>(operatorArguments))
    /// Default value for IsLog
    /// If set, compute the density of the log-probability instead of the probability.
    static member IsLogDefault : bool = false
    /// Samples from the distributions.
    member __.Sample = operatorArguments.GetInput "sample"
    /// Concentration parameters of the distributions.
    member __.Alpha = operatorArguments.GetInput "alpha"
    /// If set, compute the density of the log-probability instead of the probability.
    member __.IsLog = operatorArguments.GetParameter("is_log", RandomPdfDirichlet.IsLogDefault)
    /// <summary>Copy RandomPdfDirichlet instance with updated inputs/parameters.</summary>
    /// <param name="sample">Samples from the distributions.</param>
    /// <param name="alpha">Concentration parameters of the distributions.</param>
    /// <param name="isLog">If set, compute the density of the log-probability instead of the probability.</param>
    member this.With([<Optional>] ?sample : Symbol,
        [<Optional>] ?alpha : Symbol,
        [<Optional>] ?isLog : bool) = 
        let operatorArguments = 
            [
                sample |> Option.map (fun x -> "sample", Input x)
                alpha |> Option.map (fun x -> "alpha", Input x)
                isLog |> Option.map (fun x -> "is_log", Parameter(Some (box x)))
            ] |> List.choose id
        new RandomPdfDirichlet(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type SampleMultinomial private (operatorArguments) = 
    inherit SymbolOperator("_sample_multinomial", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new SampleMultinomial(args)
    override this.WithArguments(args : Arguments<Symbol>) = new SampleMultinomial(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <summary>Concurrent sampling from multiple multinomial distributions.
    /// 
    /// *data* is an *n* dimensional array whose last dimension has length *k*, where
    /// *k* is the number of possible outcomes of each multinomial distribution. This
    /// operator will draw *shape* samples from each distribution. If shape is empty
    /// one sample will be drawn from each distribution.
    /// 
    /// If *get_prob* is true, a second array containing log likelihood of the drawn
    /// samples will also be returned. This is usually used for reinforcement learning
    /// where you can provide reward as head gradient for this array to estimate
    /// gradient.
    /// 
    /// Note that the input distribution must be normalized, i.e. *data* must sum to
    /// 1 along its last axis.
    /// 
    /// Examples::
    /// 
    ///    probs = [[0, 0.1, 0.2, 0.3, 0.4], [0.4, 0.3, 0.2, 0.1, 0]]
    /// 
    ///    // Draw a single sample for each distribution
    ///    sample_multinomial(probs) = [3, 0]
    /// 
    ///    // Draw a vector containing two samples for each distribution
    ///    sample_multinomial(probs, shape=(2)) = [[4, 2],
    ///                                            [0, 0]]
    /// 
    ///    // requests log likelihood
    ///    sample_multinomial(probs, get_prob=True) = [2, 1], [0.2, 0.3]
    /// </summary>
    /// <param name="data">Distribution probabilities. Must sum to one on the last axis.</param>
    /// <param name="shape">Shape to be sampled from each random distribution.</param>
    /// <param name="getProb">Whether to also return the log probability of sampled result. This is usually used for differentiating through stochastic variables, e.g. in reinforcement learning.</param>
    /// <param name="dtype">DType of the output in case this can&#39;t be inferred.</param>
    new([<Optional>] ?data : Symbol,
        [<Optional>] ?shape : int seq,
        [<Optional>] ?getProb : bool,
        [<Optional>] ?dtype : SampleMultinomialDtype) = 
        let data = defaultArg data (new ImplicitVariable() :> Symbol)
        let operatorArguments = 
            [
                "data", Input data
                "shape", shape |> Option.map box |> Parameter
                "get_prob", getProb |> Option.map box |> Parameter
                "dtype", dtype |> Option.map box |> Parameter
            ]
        new SampleMultinomial(Arguments<Symbol>(operatorArguments))
    /// Default value for Shape
    /// Shape to be sampled from each random distribution.
    static member ShapeDefault : int [] = [||]
    /// Default value for GetProb
    /// Whether to also return the log probability of sampled result. This is usually used for differentiating through stochastic variables, e.g. in reinforcement learning.
    static member GetProbDefault : bool = false
    /// Default value for Dtype
    /// DType of the output in case this can&#39;t be inferred.
    static member DtypeDefault : SampleMultinomialDtype = SampleMultinomialDtype.Int32
    /// Distribution probabilities. Must sum to one on the last axis.
    member __.Data = operatorArguments.GetInput "data"
    /// Shape to be sampled from each random distribution.
    member __.Shape = operatorArguments.GetParameter("shape", SampleMultinomial.ShapeDefault)
    /// Whether to also return the log probability of sampled result. This is usually used for differentiating through stochastic variables, e.g. in reinforcement learning.
    member __.GetProb = operatorArguments.GetParameter("get_prob", SampleMultinomial.GetProbDefault)
    /// DType of the output in case this can&#39;t be inferred.
    member __.Dtype = operatorArguments.GetParameter("dtype", SampleMultinomial.DtypeDefault)
    /// <summary>Copy SampleMultinomial instance with updated inputs/parameters.</summary>
    /// <param name="data">Distribution probabilities. Must sum to one on the last axis.</param>
    /// <param name="shape">Shape to be sampled from each random distribution.</param>
    /// <param name="getProb">Whether to also return the log probability of sampled result. This is usually used for differentiating through stochastic variables, e.g. in reinforcement learning.</param>
    /// <param name="dtype">DType of the output in case this can&#39;t be inferred.</param>
    member this.With([<Optional>] ?data : Symbol,
        [<Optional>] ?shape : int seq,
        [<Optional>] ?getProb : bool,
        [<Optional>] ?dtype : SampleMultinomialDtype) = 
        let operatorArguments = 
            [
                data |> Option.map (fun x -> "data", Input x)
                shape |> Option.map (fun x -> "shape", Parameter(Some (box x)))
                getProb |> Option.map (fun x -> "get_prob", Parameter(Some (box x)))
                dtype |> Option.map (fun x -> "dtype", Parameter(Some (box x)))
            ] |> List.choose id
        new SampleMultinomial(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type RandomUniform private (operatorArguments) = 
    inherit SymbolOperator("_random_uniform", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new RandomUniform(args)
    override this.WithArguments(args : Arguments<Symbol>) = new RandomUniform(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <summary>Draw random samples from a uniform distribution.
    /// 
    /// .. note:: The existing alias ``uniform`` is deprecated.
    /// 
    /// Samples are uniformly distributed over the half-open interval *[low, high)*
    /// (includes *low*, but excludes *high*).
    /// 
    /// Example::
    /// 
    ///    uniform(low=0, high=1, shape=(2,2)) = [[ 0.60276335,  0.85794562],
    ///                                           [ 0.54488319,  0.84725171]]
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\random\sample_op.cc:L97</summary>
    /// <param name="low">Lower bound of the distribution.</param>
    /// <param name="high">Upper bound of the distribution.</param>
    /// <param name="shape">Shape of the output.</param>
    /// <param name="dtype">DType of the output in case this can&#39;t be inferred. Defaults to float32 if not defined (dtype=None).</param>
    new([<Optional>] ?low : float,
        [<Optional>] ?high : float,
        [<Optional>] ?shape : int seq,
        [<Optional>] ?dtype : FloatDType) = 
        let operatorArguments = 
            [
                "low", low |> Option.map box |> Parameter
                "high", high |> Option.map box |> Parameter
                "shape", shape |> Option.map box |> Parameter
                "dtype", dtype |> Option.map box |> Parameter
            ]
        new RandomUniform(Arguments<Symbol>(operatorArguments))
    /// Default value for Low
    /// Lower bound of the distribution.
    static member LowDefault : double = 0.0
    /// Default value for High
    /// Upper bound of the distribution.
    static member HighDefault : double = 1.0
    /// Default value for Shape
    /// Shape of the output.
    static member ShapeDefault : int [] option = None
    /// Default value for Dtype
    /// DType of the output in case this can&#39;t be inferred. Defaults to float32 if not defined (dtype=None).
    static member DtypeDefault : FloatDType option = None
    /// Lower bound of the distribution.
    member __.Low = operatorArguments.GetParameter("low", RandomUniform.LowDefault)
    /// Upper bound of the distribution.
    member __.High = operatorArguments.GetParameter("high", RandomUniform.HighDefault)
    /// Shape of the output.
    member __.Shape = operatorArguments.GetParameter("shape", RandomUniform.ShapeDefault)
    /// DType of the output in case this can&#39;t be inferred. Defaults to float32 if not defined (dtype=None).
    member __.Dtype = operatorArguments.GetParameter("dtype", RandomUniform.DtypeDefault)
    /// <summary>Copy RandomUniform instance with updated inputs/parameters.</summary>
    /// <param name="low">Lower bound of the distribution.</param>
    /// <param name="high">Upper bound of the distribution.</param>
    /// <param name="shape">Shape of the output.</param>
    /// <param name="dtype">DType of the output in case this can&#39;t be inferred. Defaults to float32 if not defined (dtype=None).</param>
    member this.With([<Optional>] ?low : float,
        [<Optional>] ?high : float,
        [<Optional>] ?shape : int seq,
        [<Optional>] ?dtype : FloatDType) = 
        let operatorArguments = 
            [
                low |> Option.map (fun x -> "low", Parameter(Some (box x)))
                high |> Option.map (fun x -> "high", Parameter(Some (box x)))
                shape |> Option.map (fun x -> "shape", Parameter(Some (box x)))
                dtype |> Option.map (fun x -> "dtype", Parameter(Some (box x)))
            ] |> List.choose id
        new RandomUniform(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type RandomNormal private (operatorArguments) = 
    inherit SymbolOperator("_random_normal", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new RandomNormal(args)
    override this.WithArguments(args : Arguments<Symbol>) = new RandomNormal(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <summary>Draw random samples from a normal (Gaussian) distribution.
    /// 
    /// .. note:: The existing alias ``normal`` is deprecated.
    /// 
    /// Samples are distributed according to a normal distribution parametrized by *loc* (mean) and *scale*
    /// (standard deviation).
    /// 
    /// Example::
    /// 
    ///    normal(loc=0, scale=1, shape=(2,2)) = [[ 1.89171135, -1.16881478],
    ///                                           [-1.23474145,  1.55807114]]
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\random\sample_op.cc:L115</summary>
    /// <param name="loc">Mean of the distribution.</param>
    /// <param name="scale">Standard deviation of the distribution.</param>
    /// <param name="shape">Shape of the output.</param>
    /// <param name="dtype">DType of the output in case this can&#39;t be inferred. Defaults to float32 if not defined (dtype=None).</param>
    new([<Optional>] ?loc : float,
        [<Optional>] ?scale : float,
        [<Optional>] ?shape : int seq,
        [<Optional>] ?dtype : FloatDType) = 
        let operatorArguments = 
            [
                "loc", loc |> Option.map box |> Parameter
                "scale", scale |> Option.map box |> Parameter
                "shape", shape |> Option.map box |> Parameter
                "dtype", dtype |> Option.map box |> Parameter
            ]
        new RandomNormal(Arguments<Symbol>(operatorArguments))
    /// Default value for Loc
    /// Mean of the distribution.
    static member LocDefault : double = 0.0
    /// Default value for Scale
    /// Standard deviation of the distribution.
    static member ScaleDefault : double = 1.0
    /// Default value for Shape
    /// Shape of the output.
    static member ShapeDefault : int [] option = None
    /// Default value for Dtype
    /// DType of the output in case this can&#39;t be inferred. Defaults to float32 if not defined (dtype=None).
    static member DtypeDefault : FloatDType option = None
    /// Mean of the distribution.
    member __.Loc = operatorArguments.GetParameter("loc", RandomNormal.LocDefault)
    /// Standard deviation of the distribution.
    member __.Scale = operatorArguments.GetParameter("scale", RandomNormal.ScaleDefault)
    /// Shape of the output.
    member __.Shape = operatorArguments.GetParameter("shape", RandomNormal.ShapeDefault)
    /// DType of the output in case this can&#39;t be inferred. Defaults to float32 if not defined (dtype=None).
    member __.Dtype = operatorArguments.GetParameter("dtype", RandomNormal.DtypeDefault)
    /// <summary>Copy RandomNormal instance with updated inputs/parameters.</summary>
    /// <param name="loc">Mean of the distribution.</param>
    /// <param name="scale">Standard deviation of the distribution.</param>
    /// <param name="shape">Shape of the output.</param>
    /// <param name="dtype">DType of the output in case this can&#39;t be inferred. Defaults to float32 if not defined (dtype=None).</param>
    member this.With([<Optional>] ?loc : float,
        [<Optional>] ?scale : float,
        [<Optional>] ?shape : int seq,
        [<Optional>] ?dtype : FloatDType) = 
        let operatorArguments = 
            [
                loc |> Option.map (fun x -> "loc", Parameter(Some (box x)))
                scale |> Option.map (fun x -> "scale", Parameter(Some (box x)))
                shape |> Option.map (fun x -> "shape", Parameter(Some (box x)))
                dtype |> Option.map (fun x -> "dtype", Parameter(Some (box x)))
            ] |> List.choose id
        new RandomNormal(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type RandomGamma private (operatorArguments) = 
    inherit SymbolOperator("_random_gamma", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new RandomGamma(args)
    override this.WithArguments(args : Arguments<Symbol>) = new RandomGamma(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <summary>Draw random samples from a gamma distribution.
    /// 
    /// Samples are distributed according to a gamma distribution parametrized by *alpha* (shape) and *beta* (scale).
    /// 
    /// Example::
    /// 
    ///    gamma(alpha=9, beta=0.5, shape=(2,2)) = [[ 7.10486984,  3.37695289],
    ///                                             [ 3.91697288,  3.65933681]]
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\random\sample_op.cc:L127</summary>
    /// <param name="alpha">Alpha parameter (shape) of the gamma distribution.</param>
    /// <param name="beta">Beta parameter (scale) of the gamma distribution.</param>
    /// <param name="shape">Shape of the output.</param>
    /// <param name="dtype">DType of the output in case this can&#39;t be inferred. Defaults to float32 if not defined (dtype=None).</param>
    new([<Optional>] ?alpha : float,
        [<Optional>] ?beta : float,
        [<Optional>] ?shape : int seq,
        [<Optional>] ?dtype : FloatDType) = 
        let operatorArguments = 
            [
                "alpha", alpha |> Option.map box |> Parameter
                "beta", beta |> Option.map box |> Parameter
                "shape", shape |> Option.map box |> Parameter
                "dtype", dtype |> Option.map box |> Parameter
            ]
        new RandomGamma(Arguments<Symbol>(operatorArguments))
    /// Default value for Alpha
    /// Alpha parameter (shape) of the gamma distribution.
    static member AlphaDefault : double = 1.0
    /// Default value for Beta
    /// Beta parameter (scale) of the gamma distribution.
    static member BetaDefault : double = 1.0
    /// Default value for Shape
    /// Shape of the output.
    static member ShapeDefault : int [] option = None
    /// Default value for Dtype
    /// DType of the output in case this can&#39;t be inferred. Defaults to float32 if not defined (dtype=None).
    static member DtypeDefault : FloatDType option = None
    /// Alpha parameter (shape) of the gamma distribution.
    member __.Alpha = operatorArguments.GetParameter("alpha", RandomGamma.AlphaDefault)
    /// Beta parameter (scale) of the gamma distribution.
    member __.Beta = operatorArguments.GetParameter("beta", RandomGamma.BetaDefault)
    /// Shape of the output.
    member __.Shape = operatorArguments.GetParameter("shape", RandomGamma.ShapeDefault)
    /// DType of the output in case this can&#39;t be inferred. Defaults to float32 if not defined (dtype=None).
    member __.Dtype = operatorArguments.GetParameter("dtype", RandomGamma.DtypeDefault)
    /// <summary>Copy RandomGamma instance with updated inputs/parameters.</summary>
    /// <param name="alpha">Alpha parameter (shape) of the gamma distribution.</param>
    /// <param name="beta">Beta parameter (scale) of the gamma distribution.</param>
    /// <param name="shape">Shape of the output.</param>
    /// <param name="dtype">DType of the output in case this can&#39;t be inferred. Defaults to float32 if not defined (dtype=None).</param>
    member this.With([<Optional>] ?alpha : float,
        [<Optional>] ?beta : float,
        [<Optional>] ?shape : int seq,
        [<Optional>] ?dtype : FloatDType) = 
        let operatorArguments = 
            [
                alpha |> Option.map (fun x -> "alpha", Parameter(Some (box x)))
                beta |> Option.map (fun x -> "beta", Parameter(Some (box x)))
                shape |> Option.map (fun x -> "shape", Parameter(Some (box x)))
                dtype |> Option.map (fun x -> "dtype", Parameter(Some (box x)))
            ] |> List.choose id
        new RandomGamma(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type RandomExponential private (operatorArguments) = 
    inherit SymbolOperator("_random_exponential", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new RandomExponential(args)
    override this.WithArguments(args : Arguments<Symbol>) = new RandomExponential(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <summary>Draw random samples from an exponential distribution.
    /// 
    /// Samples are distributed according to an exponential distribution parametrized by *lambda* (rate).
    /// 
    /// Example::
    /// 
    ///    exponential(lam=4, shape=(2,2)) = [[ 0.0097189 ,  0.08999364],
    ///                                       [ 0.04146638,  0.31715935]]
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\random\sample_op.cc:L139</summary>
    /// <param name="lam">Lambda parameter (rate) of the exponential distribution.</param>
    /// <param name="shape">Shape of the output.</param>
    /// <param name="dtype">DType of the output in case this can&#39;t be inferred. Defaults to float32 if not defined (dtype=None).</param>
    new([<Optional>] ?lam : float,
        [<Optional>] ?shape : int seq,
        [<Optional>] ?dtype : FloatDType) = 
        let operatorArguments = 
            [
                "lam", lam |> Option.map box |> Parameter
                "shape", shape |> Option.map box |> Parameter
                "dtype", dtype |> Option.map box |> Parameter
            ]
        new RandomExponential(Arguments<Symbol>(operatorArguments))
    /// Default value for Lam
    /// Lambda parameter (rate) of the exponential distribution.
    static member LamDefault : double = 1.0
    /// Default value for Shape
    /// Shape of the output.
    static member ShapeDefault : int [] option = None
    /// Default value for Dtype
    /// DType of the output in case this can&#39;t be inferred. Defaults to float32 if not defined (dtype=None).
    static member DtypeDefault : FloatDType option = None
    /// Lambda parameter (rate) of the exponential distribution.
    member __.Lam = operatorArguments.GetParameter("lam", RandomExponential.LamDefault)
    /// Shape of the output.
    member __.Shape = operatorArguments.GetParameter("shape", RandomExponential.ShapeDefault)
    /// DType of the output in case this can&#39;t be inferred. Defaults to float32 if not defined (dtype=None).
    member __.Dtype = operatorArguments.GetParameter("dtype", RandomExponential.DtypeDefault)
    /// <summary>Copy RandomExponential instance with updated inputs/parameters.</summary>
    /// <param name="lam">Lambda parameter (rate) of the exponential distribution.</param>
    /// <param name="shape">Shape of the output.</param>
    /// <param name="dtype">DType of the output in case this can&#39;t be inferred. Defaults to float32 if not defined (dtype=None).</param>
    member this.With([<Optional>] ?lam : float,
        [<Optional>] ?shape : int seq,
        [<Optional>] ?dtype : FloatDType) = 
        let operatorArguments = 
            [
                lam |> Option.map (fun x -> "lam", Parameter(Some (box x)))
                shape |> Option.map (fun x -> "shape", Parameter(Some (box x)))
                dtype |> Option.map (fun x -> "dtype", Parameter(Some (box x)))
            ] |> List.choose id
        new RandomExponential(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type RandomPoisson private (operatorArguments) = 
    inherit SymbolOperator("_random_poisson", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new RandomPoisson(args)
    override this.WithArguments(args : Arguments<Symbol>) = new RandomPoisson(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <summary>Draw random samples from a Poisson distribution.
    /// 
    /// Samples are distributed according to a Poisson distribution parametrized by *lambda* (rate).
    /// Samples will always be returned as a floating point data type.
    /// 
    /// Example::
    /// 
    ///    poisson(lam=4, shape=(2,2)) = [[ 5.,  2.],
    ///                                   [ 4.,  6.]]
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\random\sample_op.cc:L152</summary>
    /// <param name="lam">Lambda parameter (rate) of the Poisson distribution.</param>
    /// <param name="shape">Shape of the output.</param>
    /// <param name="dtype">DType of the output in case this can&#39;t be inferred. Defaults to float32 if not defined (dtype=None).</param>
    new([<Optional>] ?lam : float,
        [<Optional>] ?shape : int seq,
        [<Optional>] ?dtype : FloatDType) = 
        let operatorArguments = 
            [
                "lam", lam |> Option.map box |> Parameter
                "shape", shape |> Option.map box |> Parameter
                "dtype", dtype |> Option.map box |> Parameter
            ]
        new RandomPoisson(Arguments<Symbol>(operatorArguments))
    /// Default value for Lam
    /// Lambda parameter (rate) of the Poisson distribution.
    static member LamDefault : double = 1.0
    /// Default value for Shape
    /// Shape of the output.
    static member ShapeDefault : int [] option = None
    /// Default value for Dtype
    /// DType of the output in case this can&#39;t be inferred. Defaults to float32 if not defined (dtype=None).
    static member DtypeDefault : FloatDType option = None
    /// Lambda parameter (rate) of the Poisson distribution.
    member __.Lam = operatorArguments.GetParameter("lam", RandomPoisson.LamDefault)
    /// Shape of the output.
    member __.Shape = operatorArguments.GetParameter("shape", RandomPoisson.ShapeDefault)
    /// DType of the output in case this can&#39;t be inferred. Defaults to float32 if not defined (dtype=None).
    member __.Dtype = operatorArguments.GetParameter("dtype", RandomPoisson.DtypeDefault)
    /// <summary>Copy RandomPoisson instance with updated inputs/parameters.</summary>
    /// <param name="lam">Lambda parameter (rate) of the Poisson distribution.</param>
    /// <param name="shape">Shape of the output.</param>
    /// <param name="dtype">DType of the output in case this can&#39;t be inferred. Defaults to float32 if not defined (dtype=None).</param>
    member this.With([<Optional>] ?lam : float,
        [<Optional>] ?shape : int seq,
        [<Optional>] ?dtype : FloatDType) = 
        let operatorArguments = 
            [
                lam |> Option.map (fun x -> "lam", Parameter(Some (box x)))
                shape |> Option.map (fun x -> "shape", Parameter(Some (box x)))
                dtype |> Option.map (fun x -> "dtype", Parameter(Some (box x)))
            ] |> List.choose id
        new RandomPoisson(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type RandomNegativeBinomial private (operatorArguments) = 
    inherit SymbolOperator("_random_negative_binomial", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new RandomNegativeBinomial(args)
    override this.WithArguments(args : Arguments<Symbol>) = new RandomNegativeBinomial(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <summary>Draw random samples from a negative binomial distribution.
    /// 
    /// Samples are distributed according to a negative binomial distribution parametrized by
    /// *k* (limit of unsuccessful experiments) and *p* (failure probability in each experiment).
    /// Samples will always be returned as a floating point data type.
    /// 
    /// Example::
    /// 
    ///    negative_binomial(k=3, p=0.4, shape=(2,2)) = [[ 4.,  7.],
    ///                                                  [ 2.,  5.]]
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\random\sample_op.cc:L166</summary>
    /// <param name="k">Limit of unsuccessful experiments.</param>
    /// <param name="p">Failure probability in each experiment.</param>
    /// <param name="shape">Shape of the output.</param>
    /// <param name="dtype">DType of the output in case this can&#39;t be inferred. Defaults to float32 if not defined (dtype=None).</param>
    new([<Optional>] ?k : int,
        [<Optional>] ?p : float,
        [<Optional>] ?shape : int seq,
        [<Optional>] ?dtype : FloatDType) = 
        let operatorArguments = 
            [
                "k", k |> Option.map box |> Parameter
                "p", p |> Option.map box |> Parameter
                "shape", shape |> Option.map box |> Parameter
                "dtype", dtype |> Option.map box |> Parameter
            ]
        new RandomNegativeBinomial(Arguments<Symbol>(operatorArguments))
    /// Default value for K
    /// Limit of unsuccessful experiments.
    static member KDefault : int = 1
    /// Default value for P
    /// Failure probability in each experiment.
    static member PDefault : double = 1.0
    /// Default value for Shape
    /// Shape of the output.
    static member ShapeDefault : int [] option = None
    /// Default value for Dtype
    /// DType of the output in case this can&#39;t be inferred. Defaults to float32 if not defined (dtype=None).
    static member DtypeDefault : FloatDType option = None
    /// Limit of unsuccessful experiments.
    member __.K = operatorArguments.GetParameter("k", RandomNegativeBinomial.KDefault)
    /// Failure probability in each experiment.
    member __.P = operatorArguments.GetParameter("p", RandomNegativeBinomial.PDefault)
    /// Shape of the output.
    member __.Shape = operatorArguments.GetParameter("shape", RandomNegativeBinomial.ShapeDefault)
    /// DType of the output in case this can&#39;t be inferred. Defaults to float32 if not defined (dtype=None).
    member __.Dtype = operatorArguments.GetParameter("dtype", RandomNegativeBinomial.DtypeDefault)
    /// <summary>Copy RandomNegativeBinomial instance with updated inputs/parameters.</summary>
    /// <param name="k">Limit of unsuccessful experiments.</param>
    /// <param name="p">Failure probability in each experiment.</param>
    /// <param name="shape">Shape of the output.</param>
    /// <param name="dtype">DType of the output in case this can&#39;t be inferred. Defaults to float32 if not defined (dtype=None).</param>
    member this.With([<Optional>] ?k : int,
        [<Optional>] ?p : float,
        [<Optional>] ?shape : int seq,
        [<Optional>] ?dtype : FloatDType) = 
        let operatorArguments = 
            [
                k |> Option.map (fun x -> "k", Parameter(Some (box x)))
                p |> Option.map (fun x -> "p", Parameter(Some (box x)))
                shape |> Option.map (fun x -> "shape", Parameter(Some (box x)))
                dtype |> Option.map (fun x -> "dtype", Parameter(Some (box x)))
            ] |> List.choose id
        new RandomNegativeBinomial(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type RandomGeneralizedNegativeBinomial private (operatorArguments) = 
    inherit SymbolOperator("_random_generalized_negative_binomial", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new RandomGeneralizedNegativeBinomial(args)
    override this.WithArguments(args : Arguments<Symbol>) = new RandomGeneralizedNegativeBinomial(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <summary>Draw random samples from a generalized negative binomial distribution.
    /// 
    /// Samples are distributed according to a generalized negative binomial distribution parametrized by
    /// *mu* (mean) and *alpha* (dispersion). *alpha* is defined as *1/k* where *k* is the failure limit of the
    /// number of unsuccessful experiments (generalized to real numbers).
    /// Samples will always be returned as a floating point data type.
    /// 
    /// Example::
    /// 
    ///    generalized_negative_binomial(mu=2.0, alpha=0.3, shape=(2,2)) = [[ 2.,  1.],
    ///                                                                     [ 6.,  4.]]
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\random\sample_op.cc:L181</summary>
    /// <param name="mu">Mean of the negative binomial distribution.</param>
    /// <param name="alpha">Alpha (dispersion) parameter of the negative binomial distribution.</param>
    /// <param name="shape">Shape of the output.</param>
    /// <param name="dtype">DType of the output in case this can&#39;t be inferred. Defaults to float32 if not defined (dtype=None).</param>
    new([<Optional>] ?mu : float,
        [<Optional>] ?alpha : float,
        [<Optional>] ?shape : int seq,
        [<Optional>] ?dtype : FloatDType) = 
        let operatorArguments = 
            [
                "mu", mu |> Option.map box |> Parameter
                "alpha", alpha |> Option.map box |> Parameter
                "shape", shape |> Option.map box |> Parameter
                "dtype", dtype |> Option.map box |> Parameter
            ]
        new RandomGeneralizedNegativeBinomial(Arguments<Symbol>(operatorArguments))
    /// Default value for Mu
    /// Mean of the negative binomial distribution.
    static member MuDefault : double = 1.0
    /// Default value for Alpha
    /// Alpha (dispersion) parameter of the negative binomial distribution.
    static member AlphaDefault : double = 1.0
    /// Default value for Shape
    /// Shape of the output.
    static member ShapeDefault : int [] option = None
    /// Default value for Dtype
    /// DType of the output in case this can&#39;t be inferred. Defaults to float32 if not defined (dtype=None).
    static member DtypeDefault : FloatDType option = None
    /// Mean of the negative binomial distribution.
    member __.Mu = operatorArguments.GetParameter("mu", RandomGeneralizedNegativeBinomial.MuDefault)
    /// Alpha (dispersion) parameter of the negative binomial distribution.
    member __.Alpha = operatorArguments.GetParameter("alpha", RandomGeneralizedNegativeBinomial.AlphaDefault)
    /// Shape of the output.
    member __.Shape = operatorArguments.GetParameter("shape", RandomGeneralizedNegativeBinomial.ShapeDefault)
    /// DType of the output in case this can&#39;t be inferred. Defaults to float32 if not defined (dtype=None).
    member __.Dtype = operatorArguments.GetParameter("dtype", RandomGeneralizedNegativeBinomial.DtypeDefault)
    /// <summary>Copy RandomGeneralizedNegativeBinomial instance with updated inputs/parameters.</summary>
    /// <param name="mu">Mean of the negative binomial distribution.</param>
    /// <param name="alpha">Alpha (dispersion) parameter of the negative binomial distribution.</param>
    /// <param name="shape">Shape of the output.</param>
    /// <param name="dtype">DType of the output in case this can&#39;t be inferred. Defaults to float32 if not defined (dtype=None).</param>
    member this.With([<Optional>] ?mu : float,
        [<Optional>] ?alpha : float,
        [<Optional>] ?shape : int seq,
        [<Optional>] ?dtype : FloatDType) = 
        let operatorArguments = 
            [
                mu |> Option.map (fun x -> "mu", Parameter(Some (box x)))
                alpha |> Option.map (fun x -> "alpha", Parameter(Some (box x)))
                shape |> Option.map (fun x -> "shape", Parameter(Some (box x)))
                dtype |> Option.map (fun x -> "dtype", Parameter(Some (box x)))
            ] |> List.choose id
        new RandomGeneralizedNegativeBinomial(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type RandomRandint private (operatorArguments) = 
    inherit SymbolOperator("_random_randint", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new RandomRandint(args)
    override this.WithArguments(args : Arguments<Symbol>) = new RandomRandint(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <summary>Draw random samples from a discrete uniform distribution.
    /// 
    /// Samples are uniformly distributed over the half-open interval *[low, high)*
    /// (includes *low*, but excludes *high*).
    /// 
    /// Example::
    /// 
    ///    randint(low=0, high=5, shape=(2,2)) = [[ 0,  2],
    ///                                           [ 3,  1]]
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\random\sample_op.cc:L196</summary>
    /// <param name="low">Lower bound of the distribution.</param>
    /// <param name="high">Upper bound of the distribution.</param>
    /// <param name="shape">Shape of the output.</param>
    /// <param name="dtype">DType of the output in case this can&#39;t be inferred. Defaults to int32 if not defined (dtype=None).</param>
    new(low : int64,
        high : int64,
        [<Optional>] ?shape : int seq,
        [<Optional>] ?dtype : RandomRandintDtype) = 
        let operatorArguments = 
            [
                "low", Parameter(Some(box low))
                "high", Parameter(Some(box high))
                "shape", shape |> Option.map box |> Parameter
                "dtype", dtype |> Option.map box |> Parameter
            ]
        new RandomRandint(Arguments<Symbol>(operatorArguments))
    /// Default value for Shape
    /// Shape of the output.
    static member ShapeDefault : int [] option = None
    /// Default value for Dtype
    /// DType of the output in case this can&#39;t be inferred. Defaults to int32 if not defined (dtype=None).
    static member DtypeDefault : RandomRandintDtype option = None
    /// Lower bound of the distribution.
    member __.Low : int64 = match operatorArguments.GetParameter "low" with Some(v) -> unbox v | None -> failwithf "Required parameter low is missing"
    /// Upper bound of the distribution.
    member __.High : int64 = match operatorArguments.GetParameter "high" with Some(v) -> unbox v | None -> failwithf "Required parameter high is missing"
    /// Shape of the output.
    member __.Shape = operatorArguments.GetParameter("shape", RandomRandint.ShapeDefault)
    /// DType of the output in case this can&#39;t be inferred. Defaults to int32 if not defined (dtype=None).
    member __.Dtype = operatorArguments.GetParameter("dtype", RandomRandint.DtypeDefault)
    /// <summary>Copy RandomRandint instance with updated inputs/parameters.</summary>
    /// <param name="low">Lower bound of the distribution.</param>
    /// <param name="high">Upper bound of the distribution.</param>
    /// <param name="shape">Shape of the output.</param>
    /// <param name="dtype">DType of the output in case this can&#39;t be inferred. Defaults to int32 if not defined (dtype=None).</param>
    member this.With([<Optional>] ?low : int64,
        [<Optional>] ?high : int64,
        [<Optional>] ?shape : int seq,
        [<Optional>] ?dtype : RandomRandintDtype) = 
        let operatorArguments = 
            [
                low |> Option.map (fun x -> "low", Parameter(Some (box x)))
                high |> Option.map (fun x -> "high", Parameter(Some (box x)))
                shape |> Option.map (fun x -> "shape", Parameter(Some (box x)))
                dtype |> Option.map (fun x -> "dtype", Parameter(Some (box x)))
            ] |> List.choose id
        new RandomRandint(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type RandomUniformLike private (operatorArguments) = 
    inherit SymbolOperator("_random_uniform_like", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new RandomUniformLike(args)
    override this.WithArguments(args : Arguments<Symbol>) = new RandomUniformLike(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <summary>Draw random samples from a uniform distribution according to the input array shape.
    /// 
    /// Samples are uniformly distributed over the half-open interval *[low, high)*
    /// (includes *low*, but excludes *high*).
    /// 
    /// Example::
    /// 
    ///    uniform(low=0, high=1, data=ones(2,2)) = [[ 0.60276335,  0.85794562],
    ///                                              [ 0.54488319,  0.84725171]]
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\random\sample_op.cc:L211</summary>
    /// <param name="data">The input</param>
    /// <param name="low">Lower bound of the distribution.</param>
    /// <param name="high">Upper bound of the distribution.</param>
    new([<Optional>] ?data : Symbol,
        [<Optional>] ?low : float,
        [<Optional>] ?high : float) = 
        let data = defaultArg data (new ImplicitVariable() :> Symbol)
        let operatorArguments = 
            [
                "data", Input data
                "low", low |> Option.map box |> Parameter
                "high", high |> Option.map box |> Parameter
            ]
        new RandomUniformLike(Arguments<Symbol>(operatorArguments))
    /// Default value for Low
    /// Lower bound of the distribution.
    static member LowDefault : double = 0.0
    /// Default value for High
    /// Upper bound of the distribution.
    static member HighDefault : double = 1.0
    /// The input
    member __.Data = operatorArguments.GetInput "data"
    /// Lower bound of the distribution.
    member __.Low = operatorArguments.GetParameter("low", RandomUniformLike.LowDefault)
    /// Upper bound of the distribution.
    member __.High = operatorArguments.GetParameter("high", RandomUniformLike.HighDefault)
    /// <summary>Copy RandomUniformLike instance with updated inputs/parameters.</summary>
    /// <param name="data">The input</param>
    /// <param name="low">Lower bound of the distribution.</param>
    /// <param name="high">Upper bound of the distribution.</param>
    member this.With([<Optional>] ?data : Symbol,
        [<Optional>] ?low : float,
        [<Optional>] ?high : float) = 
        let operatorArguments = 
            [
                data |> Option.map (fun x -> "data", Input x)
                low |> Option.map (fun x -> "low", Parameter(Some (box x)))
                high |> Option.map (fun x -> "high", Parameter(Some (box x)))
            ] |> List.choose id
        new RandomUniformLike(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type RandomNormalLike private (operatorArguments) = 
    inherit SymbolOperator("_random_normal_like", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new RandomNormalLike(args)
    override this.WithArguments(args : Arguments<Symbol>) = new RandomNormalLike(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <summary>Draw random samples from a normal (Gaussian) distribution according to the input array shape.
    /// 
    /// Samples are distributed according to a normal distribution parametrized by *loc* (mean) and *scale*
    /// (standard deviation).
    /// 
    /// Example::
    /// 
    ///    normal(loc=0, scale=1, data=ones(2,2)) = [[ 1.89171135, -1.16881478],
    ///                                              [-1.23474145,  1.55807114]]
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\random\sample_op.cc:L223</summary>
    /// <param name="data">The input</param>
    /// <param name="loc">Mean of the distribution.</param>
    /// <param name="scale">Standard deviation of the distribution.</param>
    new([<Optional>] ?data : Symbol,
        [<Optional>] ?loc : float,
        [<Optional>] ?scale : float) = 
        let data = defaultArg data (new ImplicitVariable() :> Symbol)
        let operatorArguments = 
            [
                "data", Input data
                "loc", loc |> Option.map box |> Parameter
                "scale", scale |> Option.map box |> Parameter
            ]
        new RandomNormalLike(Arguments<Symbol>(operatorArguments))
    /// Default value for Loc
    /// Mean of the distribution.
    static member LocDefault : double = 0.0
    /// Default value for Scale
    /// Standard deviation of the distribution.
    static member ScaleDefault : double = 1.0
    /// The input
    member __.Data = operatorArguments.GetInput "data"
    /// Mean of the distribution.
    member __.Loc = operatorArguments.GetParameter("loc", RandomNormalLike.LocDefault)
    /// Standard deviation of the distribution.
    member __.Scale = operatorArguments.GetParameter("scale", RandomNormalLike.ScaleDefault)
    /// <summary>Copy RandomNormalLike instance with updated inputs/parameters.</summary>
    /// <param name="data">The input</param>
    /// <param name="loc">Mean of the distribution.</param>
    /// <param name="scale">Standard deviation of the distribution.</param>
    member this.With([<Optional>] ?data : Symbol,
        [<Optional>] ?loc : float,
        [<Optional>] ?scale : float) = 
        let operatorArguments = 
            [
                data |> Option.map (fun x -> "data", Input x)
                loc |> Option.map (fun x -> "loc", Parameter(Some (box x)))
                scale |> Option.map (fun x -> "scale", Parameter(Some (box x)))
            ] |> List.choose id
        new RandomNormalLike(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type RandomGammaLike private (operatorArguments) = 
    inherit SymbolOperator("_random_gamma_like", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new RandomGammaLike(args)
    override this.WithArguments(args : Arguments<Symbol>) = new RandomGammaLike(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <summary>Draw random samples from a gamma distribution according to the input array shape.
    /// 
    /// Samples are distributed according to a gamma distribution parametrized by *alpha* (shape) and *beta* (scale).
    /// 
    /// Example::
    /// 
    ///    gamma(alpha=9, beta=0.5, data=ones(2,2)) = [[ 7.10486984,  3.37695289],
    ///                                                [ 3.91697288,  3.65933681]]
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\random\sample_op.cc:L234</summary>
    /// <param name="data">The input</param>
    /// <param name="alpha">Alpha parameter (shape) of the gamma distribution.</param>
    /// <param name="beta">Beta parameter (scale) of the gamma distribution.</param>
    new([<Optional>] ?data : Symbol,
        [<Optional>] ?alpha : float,
        [<Optional>] ?beta : float) = 
        let data = defaultArg data (new ImplicitVariable() :> Symbol)
        let operatorArguments = 
            [
                "data", Input data
                "alpha", alpha |> Option.map box |> Parameter
                "beta", beta |> Option.map box |> Parameter
            ]
        new RandomGammaLike(Arguments<Symbol>(operatorArguments))
    /// Default value for Alpha
    /// Alpha parameter (shape) of the gamma distribution.
    static member AlphaDefault : double = 1.0
    /// Default value for Beta
    /// Beta parameter (scale) of the gamma distribution.
    static member BetaDefault : double = 1.0
    /// The input
    member __.Data = operatorArguments.GetInput "data"
    /// Alpha parameter (shape) of the gamma distribution.
    member __.Alpha = operatorArguments.GetParameter("alpha", RandomGammaLike.AlphaDefault)
    /// Beta parameter (scale) of the gamma distribution.
    member __.Beta = operatorArguments.GetParameter("beta", RandomGammaLike.BetaDefault)
    /// <summary>Copy RandomGammaLike instance with updated inputs/parameters.</summary>
    /// <param name="data">The input</param>
    /// <param name="alpha">Alpha parameter (shape) of the gamma distribution.</param>
    /// <param name="beta">Beta parameter (scale) of the gamma distribution.</param>
    member this.With([<Optional>] ?data : Symbol,
        [<Optional>] ?alpha : float,
        [<Optional>] ?beta : float) = 
        let operatorArguments = 
            [
                data |> Option.map (fun x -> "data", Input x)
                alpha |> Option.map (fun x -> "alpha", Parameter(Some (box x)))
                beta |> Option.map (fun x -> "beta", Parameter(Some (box x)))
            ] |> List.choose id
        new RandomGammaLike(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type RandomExponentialLike private (operatorArguments) = 
    inherit SymbolOperator("_random_exponential_like", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new RandomExponentialLike(args)
    override this.WithArguments(args : Arguments<Symbol>) = new RandomExponentialLike(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <summary>Draw random samples from an exponential distribution according to the input array shape.
    /// 
    /// Samples are distributed according to an exponential distribution parametrized by *lambda* (rate).
    /// 
    /// Example::
    /// 
    ///    exponential(lam=4, data=ones(2,2)) = [[ 0.0097189 ,  0.08999364],
    ///                                          [ 0.04146638,  0.31715935]]
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\random\sample_op.cc:L245</summary>
    /// <param name="data">The input</param>
    /// <param name="lam">Lambda parameter (rate) of the exponential distribution.</param>
    new([<Optional>] ?data : Symbol,
        [<Optional>] ?lam : float) = 
        let data = defaultArg data (new ImplicitVariable() :> Symbol)
        let operatorArguments = 
            [
                "data", Input data
                "lam", lam |> Option.map box |> Parameter
            ]
        new RandomExponentialLike(Arguments<Symbol>(operatorArguments))
    /// Default value for Lam
    /// Lambda parameter (rate) of the exponential distribution.
    static member LamDefault : double = 1.0
    /// The input
    member __.Data = operatorArguments.GetInput "data"
    /// Lambda parameter (rate) of the exponential distribution.
    member __.Lam = operatorArguments.GetParameter("lam", RandomExponentialLike.LamDefault)
    /// <summary>Copy RandomExponentialLike instance with updated inputs/parameters.</summary>
    /// <param name="data">The input</param>
    /// <param name="lam">Lambda parameter (rate) of the exponential distribution.</param>
    member this.With([<Optional>] ?data : Symbol,
        [<Optional>] ?lam : float) = 
        let operatorArguments = 
            [
                data |> Option.map (fun x -> "data", Input x)
                lam |> Option.map (fun x -> "lam", Parameter(Some (box x)))
            ] |> List.choose id
        new RandomExponentialLike(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type RandomPoissonLike private (operatorArguments) = 
    inherit SymbolOperator("_random_poisson_like", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new RandomPoissonLike(args)
    override this.WithArguments(args : Arguments<Symbol>) = new RandomPoissonLike(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <summary>Draw random samples from a Poisson distribution according to the input array shape.
    /// 
    /// Samples are distributed according to a Poisson distribution parametrized by *lambda* (rate).
    /// Samples will always be returned as a floating point data type.
    /// 
    /// Example::
    /// 
    ///    poisson(lam=4, data=ones(2,2)) = [[ 5.,  2.],
    ///                                      [ 4.,  6.]]
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\random\sample_op.cc:L257</summary>
    /// <param name="data">The input</param>
    /// <param name="lam">Lambda parameter (rate) of the Poisson distribution.</param>
    new([<Optional>] ?data : Symbol,
        [<Optional>] ?lam : float) = 
        let data = defaultArg data (new ImplicitVariable() :> Symbol)
        let operatorArguments = 
            [
                "data", Input data
                "lam", lam |> Option.map box |> Parameter
            ]
        new RandomPoissonLike(Arguments<Symbol>(operatorArguments))
    /// Default value for Lam
    /// Lambda parameter (rate) of the Poisson distribution.
    static member LamDefault : double = 1.0
    /// The input
    member __.Data = operatorArguments.GetInput "data"
    /// Lambda parameter (rate) of the Poisson distribution.
    member __.Lam = operatorArguments.GetParameter("lam", RandomPoissonLike.LamDefault)
    /// <summary>Copy RandomPoissonLike instance with updated inputs/parameters.</summary>
    /// <param name="data">The input</param>
    /// <param name="lam">Lambda parameter (rate) of the Poisson distribution.</param>
    member this.With([<Optional>] ?data : Symbol,
        [<Optional>] ?lam : float) = 
        let operatorArguments = 
            [
                data |> Option.map (fun x -> "data", Input x)
                lam |> Option.map (fun x -> "lam", Parameter(Some (box x)))
            ] |> List.choose id
        new RandomPoissonLike(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type RandomNegativeBinomialLike private (operatorArguments) = 
    inherit SymbolOperator("_random_negative_binomial_like", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new RandomNegativeBinomialLike(args)
    override this.WithArguments(args : Arguments<Symbol>) = new RandomNegativeBinomialLike(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <summary>Draw random samples from a negative binomial distribution according to the input array shape.
    /// 
    /// Samples are distributed according to a negative binomial distribution parametrized by
    /// *k* (limit of unsuccessful experiments) and *p* (failure probability in each experiment).
    /// Samples will always be returned as a floating point data type.
    /// 
    /// Example::
    /// 
    ///    negative_binomial(k=3, p=0.4, data=ones(2,2)) = [[ 4.,  7.],
    ///                                                     [ 2.,  5.]]
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\random\sample_op.cc:L270</summary>
    /// <param name="data">The input</param>
    /// <param name="k">Limit of unsuccessful experiments.</param>
    /// <param name="p">Failure probability in each experiment.</param>
    new([<Optional>] ?data : Symbol,
        [<Optional>] ?k : int,
        [<Optional>] ?p : float) = 
        let data = defaultArg data (new ImplicitVariable() :> Symbol)
        let operatorArguments = 
            [
                "data", Input data
                "k", k |> Option.map box |> Parameter
                "p", p |> Option.map box |> Parameter
            ]
        new RandomNegativeBinomialLike(Arguments<Symbol>(operatorArguments))
    /// Default value for K
    /// Limit of unsuccessful experiments.
    static member KDefault : int = 1
    /// Default value for P
    /// Failure probability in each experiment.
    static member PDefault : double = 1.0
    /// The input
    member __.Data = operatorArguments.GetInput "data"
    /// Limit of unsuccessful experiments.
    member __.K = operatorArguments.GetParameter("k", RandomNegativeBinomialLike.KDefault)
    /// Failure probability in each experiment.
    member __.P = operatorArguments.GetParameter("p", RandomNegativeBinomialLike.PDefault)
    /// <summary>Copy RandomNegativeBinomialLike instance with updated inputs/parameters.</summary>
    /// <param name="data">The input</param>
    /// <param name="k">Limit of unsuccessful experiments.</param>
    /// <param name="p">Failure probability in each experiment.</param>
    member this.With([<Optional>] ?data : Symbol,
        [<Optional>] ?k : int,
        [<Optional>] ?p : float) = 
        let operatorArguments = 
            [
                data |> Option.map (fun x -> "data", Input x)
                k |> Option.map (fun x -> "k", Parameter(Some (box x)))
                p |> Option.map (fun x -> "p", Parameter(Some (box x)))
            ] |> List.choose id
        new RandomNegativeBinomialLike(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type RandomGeneralizedNegativeBinomialLike private (operatorArguments) = 
    inherit SymbolOperator("_random_generalized_negative_binomial_like", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new RandomGeneralizedNegativeBinomialLike(args)
    override this.WithArguments(args : Arguments<Symbol>) = new RandomGeneralizedNegativeBinomialLike(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <summary>Draw random samples from a generalized negative binomial distribution according to the
    /// input array shape.
    /// 
    /// Samples are distributed according to a generalized negative binomial distribution parametrized by
    /// *mu* (mean) and *alpha* (dispersion). *alpha* is defined as *1/k* where *k* is the failure limit of the
    /// number of unsuccessful experiments (generalized to real numbers).
    /// Samples will always be returned as a floating point data type.
    /// 
    /// Example::
    /// 
    ///    generalized_negative_binomial(mu=2.0, alpha=0.3, data=ones(2,2)) = [[ 2.,  1.],
    ///                                                                        [ 6.,  4.]]
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\random\sample_op.cc:L286</summary>
    /// <param name="data">The input</param>
    /// <param name="mu">Mean of the negative binomial distribution.</param>
    /// <param name="alpha">Alpha (dispersion) parameter of the negative binomial distribution.</param>
    new([<Optional>] ?data : Symbol,
        [<Optional>] ?mu : float,
        [<Optional>] ?alpha : float) = 
        let data = defaultArg data (new ImplicitVariable() :> Symbol)
        let operatorArguments = 
            [
                "data", Input data
                "mu", mu |> Option.map box |> Parameter
                "alpha", alpha |> Option.map box |> Parameter
            ]
        new RandomGeneralizedNegativeBinomialLike(Arguments<Symbol>(operatorArguments))
    /// Default value for Mu
    /// Mean of the negative binomial distribution.
    static member MuDefault : double = 1.0
    /// Default value for Alpha
    /// Alpha (dispersion) parameter of the negative binomial distribution.
    static member AlphaDefault : double = 1.0
    /// The input
    member __.Data = operatorArguments.GetInput "data"
    /// Mean of the negative binomial distribution.
    member __.Mu = operatorArguments.GetParameter("mu", RandomGeneralizedNegativeBinomialLike.MuDefault)
    /// Alpha (dispersion) parameter of the negative binomial distribution.
    member __.Alpha = operatorArguments.GetParameter("alpha", RandomGeneralizedNegativeBinomialLike.AlphaDefault)
    /// <summary>Copy RandomGeneralizedNegativeBinomialLike instance with updated inputs/parameters.</summary>
    /// <param name="data">The input</param>
    /// <param name="mu">Mean of the negative binomial distribution.</param>
    /// <param name="alpha">Alpha (dispersion) parameter of the negative binomial distribution.</param>
    member this.With([<Optional>] ?data : Symbol,
        [<Optional>] ?mu : float,
        [<Optional>] ?alpha : float) = 
        let operatorArguments = 
            [
                data |> Option.map (fun x -> "data", Input x)
                mu |> Option.map (fun x -> "mu", Parameter(Some (box x)))
                alpha |> Option.map (fun x -> "alpha", Parameter(Some (box x)))
            ] |> List.choose id
        new RandomGeneralizedNegativeBinomialLike(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type Shuffle private (operatorArguments) = 
    inherit SymbolOperator("_shuffle", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new Shuffle(args)
    override this.WithArguments(args : Arguments<Symbol>) = new Shuffle(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <summary>Randomly shuffle the elements.
    /// 
    /// This shuffles the array along the first axis.
    /// The order of the elements in each subarray does not change.
    /// For example, if a 2D array is given, the order of the rows randomly changes,
    /// but the order of the elements in each row does not change.
    /// </summary>
    /// <param name="data">Data to be shuffled.</param>
    new([<Optional>] ?data : Symbol) =
        let data = defaultArg data (new ImplicitVariable() :> Symbol)
        let operatorArguments = 
            [
                "data", Input data
            ]
        new Shuffle(Arguments<Symbol>(operatorArguments))
    /// Data to be shuffled.
    member __.Data = operatorArguments.GetInput "data"
    /// <summary>Copy Shuffle instance with updated inputs/parameters.</summary>
    /// <param name="data">Data to be shuffled.</param>
    member this.With([<Optional>] ?data : Symbol) =
        let operatorArguments = 
            [
                data |> Option.map (fun x -> "data", Input x)
            ] |> List.choose id
        new Shuffle(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type SampleUniqueZipfian private (operatorArguments) = 
    inherit SymbolOperator("_sample_unique_zipfian", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new SampleUniqueZipfian(args)
    override this.WithArguments(args : Arguments<Symbol>) = new SampleUniqueZipfian(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <summary>Draw random samples from an an approximately log-uniform
    /// or Zipfian distribution without replacement.
    /// 
    /// This operation takes a 2-D shape `(batch_size, num_sampled)`,
    /// and randomly generates *num_sampled* samples from the range of integers [0, range_max)
    /// for each instance in the batch.
    /// 
    /// The elements in each instance are drawn without replacement from the base distribution.
    /// The base distribution for this operator is an approximately log-uniform or Zipfian distribution:
    /// 
    ///   P(class) = (log(class + 2) - log(class + 1)) / log(range_max + 1)
    /// 
    /// Additionaly, it also returns the number of trials used to obtain `num_sampled` samples for
    /// each instance in the batch.
    /// 
    /// Example::
    /// 
    ///    samples, trials = _sample_unique_zipfian(750000, shape=(4, 8192))
    ///    unique(samples[0]) = 8192
    ///    unique(samples[3]) = 8192
    ///    trials[0] = 16435
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\random\unique_sample_op.cc:L66</summary>
    /// <param name="rangeMax">The number of possible classes.</param>
    /// <param name="shape">2-D shape of the output, where shape[0] is the batch size, and shape[1] is the number of candidates to sample for each batch.</param>
    new(rangeMax : int,
        [<Optional>] ?shape : int seq) = 
        let operatorArguments = 
            [
                "range_max", Parameter(Some(box rangeMax))
                "shape", shape |> Option.map box |> Parameter
            ]
        new SampleUniqueZipfian(Arguments<Symbol>(operatorArguments))
    /// Default value for Shape
    /// 2-D shape of the output, where shape[0] is the batch size, and shape[1] is the number of candidates to sample for each batch.
    static member ShapeDefault : int [] option = None
    /// The number of possible classes.
    member __.RangeMax : int = match operatorArguments.GetParameter "range_max" with Some(v) -> unbox v | None -> failwithf "Required parameter range_max is missing"
    /// 2-D shape of the output, where shape[0] is the batch size, and shape[1] is the number of candidates to sample for each batch.
    member __.Shape = operatorArguments.GetParameter("shape", SampleUniqueZipfian.ShapeDefault)
    /// <summary>Copy SampleUniqueZipfian instance with updated inputs/parameters.</summary>
    /// <param name="rangeMax">The number of possible classes.</param>
    /// <param name="shape">2-D shape of the output, where shape[0] is the batch size, and shape[1] is the number of candidates to sample for each batch.</param>
    member this.With([<Optional>] ?rangeMax : int,
        [<Optional>] ?shape : int seq) = 
        let operatorArguments = 
            [
                rangeMax |> Option.map (fun x -> "range_max", Parameter(Some (box x)))
                shape |> Option.map (fun x -> "shape", Parameter(Some (box x)))
            ] |> List.choose id
        new SampleUniqueZipfian(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type LinearRegressionOutput private (operatorArguments) = 
    inherit SymbolOperator("LinearRegressionOutput", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new LinearRegressionOutput(args)
    override this.WithArguments(args : Arguments<Symbol>) = new LinearRegressionOutput(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <summary>Computes and optimizes for squared loss during backward propagation.
    /// Just outputs ``data`` during forward propagation.
    /// 
    /// If :math:`\hat{y}_i` is the predicted value of the i-th sample, and :math:`y_i` is the corresponding target value,
    /// then the squared loss estimated over :math:`n` samples is defined as
    /// 
    /// :math:`\text{SquaredLoss}(\textbf{Y}, \hat{\textbf{Y}} ) = \frac{1}{n} \sum_{i=0}^{n-1} \lVert  \textbf{y}_i - \hat{\textbf{y}}_i  \rVert_2`
    /// 
    /// .. note::
    ///    Use the LinearRegressionOutput as the final output layer of a net.
    /// 
    /// The storage type of ``label`` can be ``default`` or ``csr``
    /// 
    /// - LinearRegressionOutput(default, default) = default
    /// - LinearRegressionOutput(default, csr) = default
    /// 
    /// By default, gradients of this loss function are scaled by factor `1/m`, where m is the number of regression outputs of a training example.
    /// The parameter `grad_scale` can be used to change this scale to `grad_scale/m`.
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\regression_output.cc:L92</summary>
    /// <param name="data">Input data to the function.</param>
    /// <param name="label">Input label to the function.</param>
    /// <param name="gradScale">Scale the gradient by a float factor</param>
    new([<Optional>] ?data : Symbol,
        [<Optional>] ?label : Symbol,
        [<Optional>] ?gradScale : float) = 
        let data = defaultArg data (new ImplicitVariable() :> Symbol)
        let label = defaultArg label (new ImplicitVariable() :> Symbol)
        let operatorArguments = 
            [
                "data", Input data
                "label", Input label
                "grad_scale", gradScale |> Option.map box |> Parameter
            ]
        new LinearRegressionOutput(Arguments<Symbol>(operatorArguments))
    /// Default value for GradScale
    /// Scale the gradient by a float factor
    static member GradScaleDefault : double = 1.0
    /// Input data to the function.
    member __.Data = operatorArguments.GetInput "data"
    /// Input label to the function.
    member __.Label = operatorArguments.GetInput "label"
    /// Scale the gradient by a float factor
    member __.GradScale = operatorArguments.GetParameter("grad_scale", LinearRegressionOutput.GradScaleDefault)
    /// <summary>Copy LinearRegressionOutput instance with updated inputs/parameters.</summary>
    /// <param name="data">Input data to the function.</param>
    /// <param name="label">Input label to the function.</param>
    /// <param name="gradScale">Scale the gradient by a float factor</param>
    member this.With([<Optional>] ?data : Symbol,
        [<Optional>] ?label : Symbol,
        [<Optional>] ?gradScale : float) = 
        let operatorArguments = 
            [
                data |> Option.map (fun x -> "data", Input x)
                label |> Option.map (fun x -> "label", Input x)
                gradScale |> Option.map (fun x -> "grad_scale", Parameter(Some (box x)))
            ] |> List.choose id
        new LinearRegressionOutput(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type MAERegressionOutput private (operatorArguments) = 
    inherit SymbolOperator("MAERegressionOutput", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new MAERegressionOutput(args)
    override this.WithArguments(args : Arguments<Symbol>) = new MAERegressionOutput(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <summary>Computes mean absolute error of the input.
    /// 
    /// MAE is a risk metric corresponding to the expected value of the absolute error.
    /// 
    /// If :math:`\hat{y}_i` is the predicted value of the i-th sample, and :math:`y_i` is the corresponding target value,
    /// then the mean absolute error (MAE) estimated over :math:`n` samples is defined as
    /// 
    /// :math:`\text{MAE}(\textbf{Y}, \hat{\textbf{Y}} ) = \frac{1}{n} \sum_{i=0}^{n-1} \lVert \textbf{y}_i - \hat{\textbf{y}}_i \rVert_1`
    /// 
    /// .. note::
    ///    Use the MAERegressionOutput as the final output layer of a net.
    /// 
    /// The storage type of ``label`` can be ``default`` or ``csr``
    /// 
    /// - MAERegressionOutput(default, default) = default
    /// - MAERegressionOutput(default, csr) = default
    /// 
    /// By default, gradients of this loss function are scaled by factor `1/m`, where m is the number of regression outputs of a training example.
    /// The parameter `grad_scale` can be used to change this scale to `grad_scale/m`.
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\regression_output.cc:L120</summary>
    /// <param name="data">Input data to the function.</param>
    /// <param name="label">Input label to the function.</param>
    /// <param name="gradScale">Scale the gradient by a float factor</param>
    new([<Optional>] ?data : Symbol,
        [<Optional>] ?label : Symbol,
        [<Optional>] ?gradScale : float) = 
        let data = defaultArg data (new ImplicitVariable() :> Symbol)
        let label = defaultArg label (new ImplicitVariable() :> Symbol)
        let operatorArguments = 
            [
                "data", Input data
                "label", Input label
                "grad_scale", gradScale |> Option.map box |> Parameter
            ]
        new MAERegressionOutput(Arguments<Symbol>(operatorArguments))
    /// Default value for GradScale
    /// Scale the gradient by a float factor
    static member GradScaleDefault : double = 1.0
    /// Input data to the function.
    member __.Data = operatorArguments.GetInput "data"
    /// Input label to the function.
    member __.Label = operatorArguments.GetInput "label"
    /// Scale the gradient by a float factor
    member __.GradScale = operatorArguments.GetParameter("grad_scale", MAERegressionOutput.GradScaleDefault)
    /// <summary>Copy MAERegressionOutput instance with updated inputs/parameters.</summary>
    /// <param name="data">Input data to the function.</param>
    /// <param name="label">Input label to the function.</param>
    /// <param name="gradScale">Scale the gradient by a float factor</param>
    member this.With([<Optional>] ?data : Symbol,
        [<Optional>] ?label : Symbol,
        [<Optional>] ?gradScale : float) = 
        let operatorArguments = 
            [
                data |> Option.map (fun x -> "data", Input x)
                label |> Option.map (fun x -> "label", Input x)
                gradScale |> Option.map (fun x -> "grad_scale", Parameter(Some (box x)))
            ] |> List.choose id
        new MAERegressionOutput(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type LogisticRegressionOutput private (operatorArguments) = 
    inherit SymbolOperator("LogisticRegressionOutput", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new LogisticRegressionOutput(args)
    override this.WithArguments(args : Arguments<Symbol>) = new LogisticRegressionOutput(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <summary>Applies a logistic function to the input.
    /// 
    /// The logistic function, also known as the sigmoid function, is computed as
    /// :math:`\frac{1}{1+exp(-\textbf{x})}`.
    /// 
    /// Commonly, the sigmoid is used to squash the real-valued output of a linear model
    /// :math:`wTx+b` into the [0,1] range so that it can be interpreted as a probability.
    /// It is suitable for binary classification or probability prediction tasks.
    /// 
    /// .. note::
    ///    Use the LogisticRegressionOutput as the final output layer of a net.
    /// 
    /// The storage type of ``label`` can be ``default`` or ``csr``
    /// 
    /// - LogisticRegressionOutput(default, default) = default
    /// - LogisticRegressionOutput(default, csr) = default
    /// 
    /// The loss function used is the Binary Cross Entropy Loss:
    /// 
    /// :math:`-{(y\log(p) + (1 - y)\log(1 - p))}`
    /// 
    /// Where `y` is the ground truth probability of positive outcome for a given example, and `p` the probability predicted by the model. By default, gradients of this loss function are scaled by factor `1/m`, where m is the number of regression outputs of a training example.
    /// The parameter `grad_scale` can be used to change this scale to `grad_scale/m`.
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\regression_output.cc:L152</summary>
    /// <param name="data">Input data to the function.</param>
    /// <param name="label">Input label to the function.</param>
    /// <param name="gradScale">Scale the gradient by a float factor</param>
    new([<Optional>] ?data : Symbol,
        [<Optional>] ?label : Symbol,
        [<Optional>] ?gradScale : float) = 
        let data = defaultArg data (new ImplicitVariable() :> Symbol)
        let label = defaultArg label (new ImplicitVariable() :> Symbol)
        let operatorArguments = 
            [
                "data", Input data
                "label", Input label
                "grad_scale", gradScale |> Option.map box |> Parameter
            ]
        new LogisticRegressionOutput(Arguments<Symbol>(operatorArguments))
    /// Default value for GradScale
    /// Scale the gradient by a float factor
    static member GradScaleDefault : double = 1.0
    /// Input data to the function.
    member __.Data = operatorArguments.GetInput "data"
    /// Input label to the function.
    member __.Label = operatorArguments.GetInput "label"
    /// Scale the gradient by a float factor
    member __.GradScale = operatorArguments.GetParameter("grad_scale", LogisticRegressionOutput.GradScaleDefault)
    /// <summary>Copy LogisticRegressionOutput instance with updated inputs/parameters.</summary>
    /// <param name="data">Input data to the function.</param>
    /// <param name="label">Input label to the function.</param>
    /// <param name="gradScale">Scale the gradient by a float factor</param>
    member this.With([<Optional>] ?data : Symbol,
        [<Optional>] ?label : Symbol,
        [<Optional>] ?gradScale : float) = 
        let operatorArguments = 
            [
                data |> Option.map (fun x -> "data", Input x)
                label |> Option.map (fun x -> "label", Input x)
                gradScale |> Option.map (fun x -> "grad_scale", Parameter(Some (box x)))
            ] |> List.choose id
        new LogisticRegressionOutput(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type RNN private (operatorArguments) = 
    inherit SymbolOperator("RNN", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new RNN(args)
    override this.WithArguments(args : Arguments<Symbol>) = new RNN(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <summary>Applies recurrent layers to input data. Currently, vanilla RNN, LSTM and GRU are
    /// implemented, with both multi-layer and bidirectional support.
    /// 
    /// When the input data is of type float32 and the environment variables MXNET_CUDA_ALLOW_TENSOR_CORE
    /// and MXNET_CUDA_TENSOR_OP_MATH_ALLOW_CONVERSION are set to 1, this operator will try to use
    /// pseudo-float16 precision (float32 math with float16 I/O) precision in order to use
    /// Tensor Cores on suitable NVIDIA GPUs. This can sometimes give significant speedups.
    /// 
    /// **Vanilla RNN**
    /// 
    /// Applies a single-gate recurrent layer to input X. Two kinds of activation function are supported:
    /// ReLU and Tanh.
    /// 
    /// With ReLU activation function:
    /// 
    /// .. math::
    ///     h_t = relu(W_{ih} * x_t + b_{ih}  +  W_{hh} * h_{(t-1)} + b_{hh})
    /// 
    /// With Tanh activtion function:
    /// 
    /// .. math::
    ///     h_t = \tanh(W_{ih} * x_t + b_{ih}  +  W_{hh} * h_{(t-1)} + b_{hh})
    /// 
    /// Reference paper: Finding structure in time - Elman, 1988.
    /// https://crl.ucsd.edu/~elman/Papers/fsit.pdf
    /// 
    /// **LSTM**
    /// 
    /// Long Short-Term Memory - Hochreiter, 1997. http://www.bioinf.jku.at/publications/older/2604.pdf
    /// 
    /// .. math::
    ///   \begin{array}{ll}
    ///             i_t = \mathrm{sigmoid}(W_{ii} x_t + b_{ii} + W_{hi} h_{(t-1)} + b_{hi}) \\
    ///             f_t = \mathrm{sigmoid}(W_{if} x_t + b_{if} + W_{hf} h_{(t-1)} + b_{hf}) \\
    ///             g_t = \tanh(W_{ig} x_t + b_{ig} + W_{hc} h_{(t-1)} + b_{hg}) \\
    ///             o_t = \mathrm{sigmoid}(W_{io} x_t + b_{io} + W_{ho} h_{(t-1)} + b_{ho}) \\
    ///             c_t = f_t * c_{(t-1)} + i_t * g_t \\
    ///             h_t = o_t * \tanh(c_t)
    ///             \end{array}
    /// 
    /// **GRU**
    /// 
    /// Gated Recurrent Unit - Cho et al. 2014. http://arxiv.org/abs/1406.1078
    /// 
    /// The definition of GRU here is slightly different from paper but compatible with CUDNN.
    /// 
    /// .. math::
    ///   \begin{array}{ll}
    ///             r_t = \mathrm{sigmoid}(W_{ir} x_t + b_{ir} + W_{hr} h_{(t-1)} + b_{hr}) \\
    ///             z_t = \mathrm{sigmoid}(W_{iz} x_t + b_{iz} + W_{hz} h_{(t-1)} + b_{hz}) \\
    ///             n_t = \tanh(W_{in} x_t + b_{in} + r_t * (W_{hn} h_{(t-1)}+ b_{hn})) \\
    ///             h_t = (1 - z_t) * n_t + z_t * h_{(t-1)} \\
    ///             \end{array}
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\rnn.cc:L707</summary>
    /// <param name="data">Input data to RNN</param>
    /// <param name="parameters">Vector of all RNN trainable parameters concatenated</param>
    /// <param name="state">initial hidden state of the RNN</param>
    /// <param name="stateCell">initial cell state for LSTM networks (only for LSTM)</param>
    /// <param name="sequenceLength">Vector of valid sequence lengths for each element in batch. (Only used if use_sequence_length kwarg is True)</param>
    /// <param name="stateSize">size of the state for each layer</param>
    /// <param name="numLayers">number of stacked layers</param>
    /// <param name="mode">the type of RNN to compute</param>
    /// <param name="bidirectional">whether to use bidirectional recurrent layers</param>
    /// <param name="p">drop rate of the dropout on the outputs of each RNN layer, except the last layer.</param>
    /// <param name="stateOutputs">Whether to have the states as symbol outputs.</param>
    /// <param name="projectionSize">size of project size</param>
    /// <param name="lstmStateClipMin">Minimum clip value of LSTM states. This option must be used together with lstm_state_clip_max.</param>
    /// <param name="lstmStateClipMax">Maximum clip value of LSTM states. This option must be used together with lstm_state_clip_min.</param>
    /// <param name="lstmStateClipNan">Whether to stop NaN from propagating in state by clipping it to min/max. If clipping range is not specified, this option is ignored.</param>
    /// <param name="useSequenceLength">If set to true, this layer takes in an extra input parameter `sequence_length` to specify variable length sequence</param>
    new(data : Symbol,
        parameters : Symbol,
        state : Symbol,
        stateCell : Symbol,
        sequenceLength : Symbol,
        stateSize : int,
        numLayers : int,
        mode : RNNMode,
        [<Optional>] ?bidirectional : bool,
        [<Optional>] ?p : float,
        [<Optional>] ?stateOutputs : bool,
        [<Optional>] ?projectionSize : int,
        [<Optional>] ?lstmStateClipMin : float,
        [<Optional>] ?lstmStateClipMax : float,
        [<Optional>] ?lstmStateClipNan : bool,
        [<Optional>] ?useSequenceLength : bool) = 
        let operatorArguments = 
            [
                "data", Input data
                "parameters", Input parameters
                "state", Input state
                "state_cell", Input stateCell
                "sequence_length", Input sequenceLength
                "state_size", Parameter(Some(box stateSize))
                "num_layers", Parameter(Some(box numLayers))
                "mode", Parameter(Some(box mode))
                "bidirectional", bidirectional |> Option.map box |> Parameter
                "p", p |> Option.map box |> Parameter
                "state_outputs", stateOutputs |> Option.map box |> Parameter
                "projection_size", projectionSize |> Option.map box |> Parameter
                "lstm_state_clip_min", lstmStateClipMin |> Option.map box |> Parameter
                "lstm_state_clip_max", lstmStateClipMax |> Option.map box |> Parameter
                "lstm_state_clip_nan", lstmStateClipNan |> Option.map box |> Parameter
                "use_sequence_length", useSequenceLength |> Option.map box |> Parameter
            ]
        new RNN(Arguments<Symbol>(operatorArguments))
    /// <summary>Applies recurrent layers to input data. Currently, vanilla RNN, LSTM and GRU are
    /// implemented, with both multi-layer and bidirectional support.
    /// 
    /// When the input data is of type float32 and the environment variables MXNET_CUDA_ALLOW_TENSOR_CORE
    /// and MXNET_CUDA_TENSOR_OP_MATH_ALLOW_CONVERSION are set to 1, this operator will try to use
    /// pseudo-float16 precision (float32 math with float16 I/O) precision in order to use
    /// Tensor Cores on suitable NVIDIA GPUs. This can sometimes give significant speedups.
    /// 
    /// **Vanilla RNN**
    /// 
    /// Applies a single-gate recurrent layer to input X. Two kinds of activation function are supported:
    /// ReLU and Tanh.
    /// 
    /// With ReLU activation function:
    /// 
    /// .. math::
    ///     h_t = relu(W_{ih} * x_t + b_{ih}  +  W_{hh} * h_{(t-1)} + b_{hh})
    /// 
    /// With Tanh activtion function:
    /// 
    /// .. math::
    ///     h_t = \tanh(W_{ih} * x_t + b_{ih}  +  W_{hh} * h_{(t-1)} + b_{hh})
    /// 
    /// Reference paper: Finding structure in time - Elman, 1988.
    /// https://crl.ucsd.edu/~elman/Papers/fsit.pdf
    /// 
    /// **LSTM**
    /// 
    /// Long Short-Term Memory - Hochreiter, 1997. http://www.bioinf.jku.at/publications/older/2604.pdf
    /// 
    /// .. math::
    ///   \begin{array}{ll}
    ///             i_t = \mathrm{sigmoid}(W_{ii} x_t + b_{ii} + W_{hi} h_{(t-1)} + b_{hi}) \\
    ///             f_t = \mathrm{sigmoid}(W_{if} x_t + b_{if} + W_{hf} h_{(t-1)} + b_{hf}) \\
    ///             g_t = \tanh(W_{ig} x_t + b_{ig} + W_{hc} h_{(t-1)} + b_{hg}) \\
    ///             o_t = \mathrm{sigmoid}(W_{io} x_t + b_{io} + W_{ho} h_{(t-1)} + b_{ho}) \\
    ///             c_t = f_t * c_{(t-1)} + i_t * g_t \\
    ///             h_t = o_t * \tanh(c_t)
    ///             \end{array}
    /// 
    /// **GRU**
    /// 
    /// Gated Recurrent Unit - Cho et al. 2014. http://arxiv.org/abs/1406.1078
    /// 
    /// The definition of GRU here is slightly different from paper but compatible with CUDNN.
    /// 
    /// .. math::
    ///   \begin{array}{ll}
    ///             r_t = \mathrm{sigmoid}(W_{ir} x_t + b_{ir} + W_{hr} h_{(t-1)} + b_{hr}) \\
    ///             z_t = \mathrm{sigmoid}(W_{iz} x_t + b_{iz} + W_{hz} h_{(t-1)} + b_{hz}) \\
    ///             n_t = \tanh(W_{in} x_t + b_{in} + r_t * (W_{hn} h_{(t-1)}+ b_{hn})) \\
    ///             h_t = (1 - z_t) * n_t + z_t * h_{(t-1)} \\
    ///             \end{array}
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\rnn.cc:L707</summary>
    /// <param name="stateSize">size of the state for each layer</param>
    /// <param name="numLayers">number of stacked layers</param>
    /// <param name="mode">the type of RNN to compute</param>
    /// <param name="data">Input data to RNN</param>
    /// <param name="parameters">Vector of all RNN trainable parameters concatenated</param>
    /// <param name="state">initial hidden state of the RNN</param>
    /// <param name="stateCell">initial cell state for LSTM networks (only for LSTM)</param>
    /// <param name="sequenceLength">Vector of valid sequence lengths for each element in batch. (Only used if use_sequence_length kwarg is True)</param>
    /// <param name="bidirectional">whether to use bidirectional recurrent layers</param>
    /// <param name="p">drop rate of the dropout on the outputs of each RNN layer, except the last layer.</param>
    /// <param name="stateOutputs">Whether to have the states as symbol outputs.</param>
    /// <param name="projectionSize">size of project size</param>
    /// <param name="lstmStateClipMin">Minimum clip value of LSTM states. This option must be used together with lstm_state_clip_max.</param>
    /// <param name="lstmStateClipMax">Maximum clip value of LSTM states. This option must be used together with lstm_state_clip_min.</param>
    /// <param name="lstmStateClipNan">Whether to stop NaN from propagating in state by clipping it to min/max. If clipping range is not specified, this option is ignored.</param>
    /// <param name="useSequenceLength">If set to true, this layer takes in an extra input parameter `sequence_length` to specify variable length sequence</param>
    new(stateSize : int,
        numLayers : int,
        mode : RNNMode,
        [<Optional>] ?data : Symbol,
        [<Optional>] ?parameters : Symbol,
        [<Optional>] ?state : Symbol,
        [<Optional>] ?stateCell : Symbol,
        [<Optional>] ?sequenceLength : Symbol,
        [<Optional>] ?bidirectional : bool,
        [<Optional>] ?p : float,
        [<Optional>] ?stateOutputs : bool,
        [<Optional>] ?projectionSize : int,
        [<Optional>] ?lstmStateClipMin : float,
        [<Optional>] ?lstmStateClipMax : float,
        [<Optional>] ?lstmStateClipNan : bool,
        [<Optional>] ?useSequenceLength : bool) = 
        let data = defaultArg data (new ImplicitVariable() :> Symbol)
        let parameters = defaultArg parameters (new ImplicitVariable() :> Symbol)
        let state = defaultArg state (new ImplicitVariable() :> Symbol)
        let stateCell = defaultArg stateCell (new ImplicitVariable() :> Symbol)
        let sequenceLength = defaultArg sequenceLength (new ImplicitVariable() :> Symbol)
        let operatorArguments = 
            [
                "data", Input data
                "parameters", Input parameters
                "state", Input state
                "state_cell", Input stateCell
                "sequence_length", Input sequenceLength
                "state_size", Parameter(Some(box stateSize))
                "num_layers", Parameter(Some(box numLayers))
                "mode", Parameter(Some(box mode))
                "bidirectional", bidirectional |> Option.map box |> Parameter
                "p", p |> Option.map box |> Parameter
                "state_outputs", stateOutputs |> Option.map box |> Parameter
                "projection_size", projectionSize |> Option.map box |> Parameter
                "lstm_state_clip_min", lstmStateClipMin |> Option.map box |> Parameter
                "lstm_state_clip_max", lstmStateClipMax |> Option.map box |> Parameter
                "lstm_state_clip_nan", lstmStateClipNan |> Option.map box |> Parameter
                "use_sequence_length", useSequenceLength |> Option.map box |> Parameter
            ]
        new RNN(Arguments<Symbol>(operatorArguments))
    /// Default value for Bidirectional
    /// whether to use bidirectional recurrent layers
    static member BidirectionalDefault : bool = false
    /// Default value for P
    /// drop rate of the dropout on the outputs of each RNN layer, except the last layer.
    static member PDefault : double = 0.0
    /// Default value for StateOutputs
    /// Whether to have the states as symbol outputs.
    static member StateOutputsDefault : bool = false
    /// Default value for ProjectionSize
    /// size of project size
    static member ProjectionSizeDefault : int option = None
    /// Default value for LstmStateClipMin
    /// Minimum clip value of LSTM states. This option must be used together with lstm_state_clip_max.
    static member LstmStateClipMinDefault : double option = None
    /// Default value for LstmStateClipMax
    /// Maximum clip value of LSTM states. This option must be used together with lstm_state_clip_min.
    static member LstmStateClipMaxDefault : double option = None
    /// Default value for LstmStateClipNan
    /// Whether to stop NaN from propagating in state by clipping it to min/max. If clipping range is not specified, this option is ignored.
    static member LstmStateClipNanDefault : bool = false
    /// Default value for UseSequenceLength
    /// If set to true, this layer takes in an extra input parameter `sequence_length` to specify variable length sequence
    static member UseSequenceLengthDefault : bool = false
    /// Input data to RNN
    member __.Data = operatorArguments.GetInput "data"
    /// Vector of all RNN trainable parameters concatenated
    member __.Parameters = operatorArguments.GetInput "parameters"
    /// initial hidden state of the RNN
    member __.State = operatorArguments.GetInput "state"
    /// initial cell state for LSTM networks (only for LSTM)
    member __.StateCell = operatorArguments.GetInput "state_cell"
    /// Vector of valid sequence lengths for each element in batch. (Only used if use_sequence_length kwarg is True)
    member __.SequenceLength = operatorArguments.GetInput "sequence_length"
    /// size of the state for each layer
    member __.StateSize : int = match operatorArguments.GetParameter "state_size" with Some(v) -> unbox v | None -> failwithf "Required parameter state_size is missing"
    /// number of stacked layers
    member __.NumLayers : int = match operatorArguments.GetParameter "num_layers" with Some(v) -> unbox v | None -> failwithf "Required parameter num_layers is missing"
    /// the type of RNN to compute
    member __.Mode : RNNMode = match operatorArguments.GetParameter "mode" with Some(v) -> unbox v | None -> failwithf "Required parameter mode is missing"
    /// whether to use bidirectional recurrent layers
    member __.Bidirectional = operatorArguments.GetParameter("bidirectional", RNN.BidirectionalDefault)
    /// drop rate of the dropout on the outputs of each RNN layer, except the last layer.
    member __.P = operatorArguments.GetParameter("p", RNN.PDefault)
    /// Whether to have the states as symbol outputs.
    member __.StateOutputs = operatorArguments.GetParameter("state_outputs", RNN.StateOutputsDefault)
    /// size of project size
    member __.ProjectionSize = operatorArguments.GetParameter("projection_size", RNN.ProjectionSizeDefault)
    /// Minimum clip value of LSTM states. This option must be used together with lstm_state_clip_max.
    member __.LstmStateClipMin = operatorArguments.GetParameter("lstm_state_clip_min", RNN.LstmStateClipMinDefault)
    /// Maximum clip value of LSTM states. This option must be used together with lstm_state_clip_min.
    member __.LstmStateClipMax = operatorArguments.GetParameter("lstm_state_clip_max", RNN.LstmStateClipMaxDefault)
    /// Whether to stop NaN from propagating in state by clipping it to min/max. If clipping range is not specified, this option is ignored.
    member __.LstmStateClipNan = operatorArguments.GetParameter("lstm_state_clip_nan", RNN.LstmStateClipNanDefault)
    /// If set to true, this layer takes in an extra input parameter `sequence_length` to specify variable length sequence
    member __.UseSequenceLength = operatorArguments.GetParameter("use_sequence_length", RNN.UseSequenceLengthDefault)
    /// <summary>Copy RNN instance with updated inputs/parameters.</summary>
    /// <param name="data">Input data to RNN</param>
    /// <param name="parameters">Vector of all RNN trainable parameters concatenated</param>
    /// <param name="state">initial hidden state of the RNN</param>
    /// <param name="stateCell">initial cell state for LSTM networks (only for LSTM)</param>
    /// <param name="sequenceLength">Vector of valid sequence lengths for each element in batch. (Only used if use_sequence_length kwarg is True)</param>
    /// <param name="stateSize">size of the state for each layer</param>
    /// <param name="numLayers">number of stacked layers</param>
    /// <param name="mode">the type of RNN to compute</param>
    /// <param name="bidirectional">whether to use bidirectional recurrent layers</param>
    /// <param name="p">drop rate of the dropout on the outputs of each RNN layer, except the last layer.</param>
    /// <param name="stateOutputs">Whether to have the states as symbol outputs.</param>
    /// <param name="projectionSize">size of project size</param>
    /// <param name="lstmStateClipMin">Minimum clip value of LSTM states. This option must be used together with lstm_state_clip_max.</param>
    /// <param name="lstmStateClipMax">Maximum clip value of LSTM states. This option must be used together with lstm_state_clip_min.</param>
    /// <param name="lstmStateClipNan">Whether to stop NaN from propagating in state by clipping it to min/max. If clipping range is not specified, this option is ignored.</param>
    /// <param name="useSequenceLength">If set to true, this layer takes in an extra input parameter `sequence_length` to specify variable length sequence</param>
    member this.With([<Optional>] ?data : Symbol,
        [<Optional>] ?parameters : Symbol,
        [<Optional>] ?state : Symbol,
        [<Optional>] ?stateCell : Symbol,
        [<Optional>] ?sequenceLength : Symbol,
        [<Optional>] ?stateSize : int,
        [<Optional>] ?numLayers : int,
        [<Optional>] ?mode : RNNMode,
        [<Optional>] ?bidirectional : bool,
        [<Optional>] ?p : float,
        [<Optional>] ?stateOutputs : bool,
        [<Optional>] ?projectionSize : int,
        [<Optional>] ?lstmStateClipMin : float,
        [<Optional>] ?lstmStateClipMax : float,
        [<Optional>] ?lstmStateClipNan : bool,
        [<Optional>] ?useSequenceLength : bool) = 
        let operatorArguments = 
            [
                data |> Option.map (fun x -> "data", Input x)
                parameters |> Option.map (fun x -> "parameters", Input x)
                state |> Option.map (fun x -> "state", Input x)
                stateCell |> Option.map (fun x -> "state_cell", Input x)
                sequenceLength |> Option.map (fun x -> "sequence_length", Input x)
                stateSize |> Option.map (fun x -> "state_size", Parameter(Some (box x)))
                numLayers |> Option.map (fun x -> "num_layers", Parameter(Some (box x)))
                mode |> Option.map (fun x -> "mode", Parameter(Some (box x)))
                bidirectional |> Option.map (fun x -> "bidirectional", Parameter(Some (box x)))
                p |> Option.map (fun x -> "p", Parameter(Some (box x)))
                stateOutputs |> Option.map (fun x -> "state_outputs", Parameter(Some (box x)))
                projectionSize |> Option.map (fun x -> "projection_size", Parameter(Some (box x)))
                lstmStateClipMin |> Option.map (fun x -> "lstm_state_clip_min", Parameter(Some (box x)))
                lstmStateClipMax |> Option.map (fun x -> "lstm_state_clip_max", Parameter(Some (box x)))
                lstmStateClipNan |> Option.map (fun x -> "lstm_state_clip_nan", Parameter(Some (box x)))
                useSequenceLength |> Option.map (fun x -> "use_sequence_length", Parameter(Some (box x)))
            ] |> List.choose id
        new RNN(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type ROIPooling private (operatorArguments) = 
    inherit SymbolOperator("ROIPooling", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new ROIPooling(args)
    override this.WithArguments(args : Arguments<Symbol>) = new ROIPooling(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <summary>Performs region of interest(ROI) pooling on the input array.
    /// 
    /// ROI pooling is a variant of a max pooling layer, in which the output size is fixed and
    /// region of interest is a parameter. Its purpose is to perform max pooling on the inputs
    /// of non-uniform sizes to obtain fixed-size feature maps. ROI pooling is a neural-net
    /// layer mostly used in training a `Fast R-CNN` network for object detection.
    /// 
    /// This operator takes a 4D feature map as an input array and region proposals as `rois`,
    /// then it pools over sub-regions of input and produces a fixed-sized output array
    /// regardless of the ROI size.
    /// 
    /// To crop the feature map accordingly, you can resize the bounding box coordinates
    /// by changing the parameters `rois` and `spatial_scale`.
    /// 
    /// The cropped feature maps are pooled by standard max pooling operation to a fixed size output
    /// indicated by a `pooled_size` parameter. batch_size will change to the number of region
    /// bounding boxes after `ROIPooling`.
    /// 
    /// The size of each region of interest doesn&#39;t have to be perfectly divisible by
    /// the number of pooling sections(`pooled_size`).
    /// 
    /// Example::
    /// 
    ///   x = [[[[  0.,   1.,   2.,   3.,   4.,   5.],
    ///          [  6.,   7.,   8.,   9.,  10.,  11.],
    ///          [ 12.,  13.,  14.,  15.,  16.,  17.],
    ///          [ 18.,  19.,  20.,  21.,  22.,  23.],
    ///          [ 24.,  25.,  26.,  27.,  28.,  29.],
    ///          [ 30.,  31.,  32.,  33.,  34.,  35.],
    ///          [ 36.,  37.,  38.,  39.,  40.,  41.],
    ///          [ 42.,  43.,  44.,  45.,  46.,  47.]]]]
    /// 
    ///   // region of interest i.e. bounding box coordinates.
    ///   y = [[0,0,0,4,4]]
    /// 
    ///   // returns array of shape (2,2) according to the given roi with max pooling.
    ///   ROIPooling(x, y, (2,2), 1.0) = [[[[ 14.,  16.],
    ///                                     [ 26.,  28.]]]]
    /// 
    ///   // region of interest is changed due to the change in `spacial_scale` parameter.
    ///   ROIPooling(x, y, (2,2), 0.7) = [[[[  7.,   9.],
    ///                                     [ 19.,  21.]]]]
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\roi_pooling.cc:L225</summary>
    /// <param name="data">The input array to the pooling operator,  a 4D Feature maps </param>
    /// <param name="rois">Bounding box coordinates, a 2D array of [[batch_index, x1, y1, x2, y2]], where (x1, y1) and (x2, y2) are top left and bottom right corners of designated region of interest. `batch_index` indicates the index of corresponding image in the input array</param>
    /// <param name="pooledSize">ROI pooling output shape (h,w) </param>
    /// <param name="spatialScale">Ratio of input feature map height (or w) to raw image height (or w). Equals the reciprocal of total stride in convolutional layers</param>
    new(data : Symbol,
        rois : Symbol,
        pooledSize : int seq,
        spatialScale : float) = 
        let operatorArguments = 
            [
                "data", Input data
                "rois", Input rois
                "pooled_size", Parameter(Some(box pooledSize))
                "spatial_scale", Parameter(Some(box spatialScale))
            ]
        new ROIPooling(Arguments<Symbol>(operatorArguments))
    /// <summary>Performs region of interest(ROI) pooling on the input array.
    /// 
    /// ROI pooling is a variant of a max pooling layer, in which the output size is fixed and
    /// region of interest is a parameter. Its purpose is to perform max pooling on the inputs
    /// of non-uniform sizes to obtain fixed-size feature maps. ROI pooling is a neural-net
    /// layer mostly used in training a `Fast R-CNN` network for object detection.
    /// 
    /// This operator takes a 4D feature map as an input array and region proposals as `rois`,
    /// then it pools over sub-regions of input and produces a fixed-sized output array
    /// regardless of the ROI size.
    /// 
    /// To crop the feature map accordingly, you can resize the bounding box coordinates
    /// by changing the parameters `rois` and `spatial_scale`.
    /// 
    /// The cropped feature maps are pooled by standard max pooling operation to a fixed size output
    /// indicated by a `pooled_size` parameter. batch_size will change to the number of region
    /// bounding boxes after `ROIPooling`.
    /// 
    /// The size of each region of interest doesn&#39;t have to be perfectly divisible by
    /// the number of pooling sections(`pooled_size`).
    /// 
    /// Example::
    /// 
    ///   x = [[[[  0.,   1.,   2.,   3.,   4.,   5.],
    ///          [  6.,   7.,   8.,   9.,  10.,  11.],
    ///          [ 12.,  13.,  14.,  15.,  16.,  17.],
    ///          [ 18.,  19.,  20.,  21.,  22.,  23.],
    ///          [ 24.,  25.,  26.,  27.,  28.,  29.],
    ///          [ 30.,  31.,  32.,  33.,  34.,  35.],
    ///          [ 36.,  37.,  38.,  39.,  40.,  41.],
    ///          [ 42.,  43.,  44.,  45.,  46.,  47.]]]]
    /// 
    ///   // region of interest i.e. bounding box coordinates.
    ///   y = [[0,0,0,4,4]]
    /// 
    ///   // returns array of shape (2,2) according to the given roi with max pooling.
    ///   ROIPooling(x, y, (2,2), 1.0) = [[[[ 14.,  16.],
    ///                                     [ 26.,  28.]]]]
    /// 
    ///   // region of interest is changed due to the change in `spacial_scale` parameter.
    ///   ROIPooling(x, y, (2,2), 0.7) = [[[[  7.,   9.],
    ///                                     [ 19.,  21.]]]]
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\roi_pooling.cc:L225</summary>
    /// <param name="pooledSize">ROI pooling output shape (h,w) </param>
    /// <param name="spatialScale">Ratio of input feature map height (or w) to raw image height (or w). Equals the reciprocal of total stride in convolutional layers</param>
    /// <param name="data">The input array to the pooling operator,  a 4D Feature maps </param>
    /// <param name="rois">Bounding box coordinates, a 2D array of [[batch_index, x1, y1, x2, y2]], where (x1, y1) and (x2, y2) are top left and bottom right corners of designated region of interest. `batch_index` indicates the index of corresponding image in the input array</param>
    new(pooledSize : int seq,
        spatialScale : float,
        [<Optional>] ?data : Symbol,
        [<Optional>] ?rois : Symbol) = 
        let data = defaultArg data (new ImplicitVariable() :> Symbol)
        let rois = defaultArg rois (new ImplicitVariable() :> Symbol)
        let operatorArguments = 
            [
                "data", Input data
                "rois", Input rois
                "pooled_size", Parameter(Some(box pooledSize))
                "spatial_scale", Parameter(Some(box spatialScale))
            ]
        new ROIPooling(Arguments<Symbol>(operatorArguments))
    /// The input array to the pooling operator,  a 4D Feature maps 
    member __.Data = operatorArguments.GetInput "data"
    /// Bounding box coordinates, a 2D array of [[batch_index, x1, y1, x2, y2]], where (x1, y1) and (x2, y2) are top left and bottom right corners of designated region of interest. `batch_index` indicates the index of corresponding image in the input array
    member __.Rois = operatorArguments.GetInput "rois"
    /// ROI pooling output shape (h,w) 
    member __.PooledSize : int seq = match operatorArguments.GetParameter "pooled_size" with Some(v) -> unbox v | None -> failwithf "Required parameter pooled_size is missing"
    /// Ratio of input feature map height (or w) to raw image height (or w). Equals the reciprocal of total stride in convolutional layers
    member __.SpatialScale : float = match operatorArguments.GetParameter "spatial_scale" with Some(v) -> unbox v | None -> failwithf "Required parameter spatial_scale is missing"
    /// <summary>Copy ROIPooling instance with updated inputs/parameters.</summary>
    /// <param name="data">The input array to the pooling operator,  a 4D Feature maps </param>
    /// <param name="rois">Bounding box coordinates, a 2D array of [[batch_index, x1, y1, x2, y2]], where (x1, y1) and (x2, y2) are top left and bottom right corners of designated region of interest. `batch_index` indicates the index of corresponding image in the input array</param>
    /// <param name="pooledSize">ROI pooling output shape (h,w) </param>
    /// <param name="spatialScale">Ratio of input feature map height (or w) to raw image height (or w). Equals the reciprocal of total stride in convolutional layers</param>
    member this.With([<Optional>] ?data : Symbol,
        [<Optional>] ?rois : Symbol,
        [<Optional>] ?pooledSize : int seq,
        [<Optional>] ?spatialScale : float) = 
        let operatorArguments = 
            [
                data |> Option.map (fun x -> "data", Input x)
                rois |> Option.map (fun x -> "rois", Input x)
                pooledSize |> Option.map (fun x -> "pooled_size", Parameter(Some (box x)))
                spatialScale |> Option.map (fun x -> "spatial_scale", Parameter(Some (box x)))
            ] |> List.choose id
        new ROIPooling(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type SequenceMask private (operatorArguments) = 
    inherit SymbolOperator("SequenceMask", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new SequenceMask(args)
    override this.WithArguments(args : Arguments<Symbol>) = new SequenceMask(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <summary>Sets all elements outside the sequence to a constant value.
    /// 
    /// This function takes an n-dimensional input array of the form
    /// [max_sequence_length, batch_size, other_feature_dims] and returns an array of the same shape.
    /// 
    /// Parameter `sequence_length` is used to handle variable-length sequences. `sequence_length`
    /// should be an input array of positive ints of dimension [batch_size].
    /// To use this parameter, set `use_sequence_length` to `True`,
    /// otherwise each example in the batch is assumed to have the max sequence length and
    /// this operator works as the `identity` operator.
    /// 
    /// Example::
    /// 
    ///    x = [[[  1.,   2.,   3.],
    ///          [  4.,   5.,   6.]],
    /// 
    ///         [[  7.,   8.,   9.],
    ///          [ 10.,  11.,  12.]],
    /// 
    ///         [[ 13.,  14.,   15.],
    ///          [ 16.,  17.,   18.]]]
    /// 
    ///    // Batch 1
    ///    B1 = [[  1.,   2.,   3.],
    ///          [  7.,   8.,   9.],
    ///          [ 13.,  14.,  15.]]
    /// 
    ///    // Batch 2
    ///    B2 = [[  4.,   5.,   6.],
    ///          [ 10.,  11.,  12.],
    ///          [ 16.,  17.,  18.]]
    /// 
    ///    // works as identity operator when sequence_length parameter is not used
    ///    SequenceMask(x) = [[[  1.,   2.,   3.],
    ///                        [  4.,   5.,   6.]],
    /// 
    ///                       [[  7.,   8.,   9.],
    ///                        [ 10.,  11.,  12.]],
    /// 
    ///                       [[ 13.,  14.,   15.],
    ///                        [ 16.,  17.,   18.]]]
    /// 
    ///    // sequence_length [1,1] means 1 of each batch will be kept
    ///    // and other rows are masked with default mask value = 0
    ///    SequenceMask(x, sequence_length=[1,1], use_sequence_length=True) =
    ///                 [[[  1.,   2.,   3.],
    ///                   [  4.,   5.,   6.]],
    /// 
    ///                  [[  0.,   0.,   0.],
    ///                   [  0.,   0.,   0.]],
    /// 
    ///                  [[  0.,   0.,   0.],
    ///                   [  0.,   0.,   0.]]]
    /// 
    ///    // sequence_length [2,3] means 2 of batch B1 and 3 of batch B2 will be kept
    ///    // and other rows are masked with value = 1
    ///    SequenceMask(x, sequence_length=[2,3], use_sequence_length=True, value=1) =
    ///                 [[[  1.,   2.,   3.],
    ///                   [  4.,   5.,   6.]],
    /// 
    ///                  [[  7.,   8.,   9.],
    ///                   [  10.,  11.,  12.]],
    /// 
    ///                  [[   1.,   1.,   1.],
    ///                   [  16.,  17.,  18.]]]
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\sequence_mask.cc:L186</summary>
    /// <param name="data">n-dimensional input array of the form [max_sequence_length, batch_size, other_feature_dims] where n&gt;2</param>
    /// <param name="sequenceLength">vector of sequence lengths of the form [batch_size]</param>
    /// <param name="useSequenceLength">If set to true, this layer takes in an extra input parameter `sequence_length` to specify variable length sequence</param>
    /// <param name="value">The value to be used as a mask.</param>
    /// <param name="axis">The sequence axis. Only values of 0 and 1 are currently supported.</param>
    new([<Optional>] ?data : Symbol,
        [<Optional>] ?sequenceLength : Symbol,
        [<Optional>] ?useSequenceLength : bool,
        [<Optional>] ?value : float,
        [<Optional>] ?axis : int) = 
        let data = defaultArg data (new ImplicitVariable() :> Symbol)
        let sequenceLength = defaultArg sequenceLength (new ImplicitVariable() :> Symbol)
        let operatorArguments = 
            [
                "data", Input data
                "sequence_length", Input sequenceLength
                "use_sequence_length", useSequenceLength |> Option.map box |> Parameter
                "value", value |> Option.map box |> Parameter
                "axis", axis |> Option.map box |> Parameter
            ]
        new SequenceMask(Arguments<Symbol>(operatorArguments))
    /// Default value for UseSequenceLength
    /// If set to true, this layer takes in an extra input parameter `sequence_length` to specify variable length sequence
    static member UseSequenceLengthDefault : bool = false
    /// Default value for Value
    /// The value to be used as a mask.
    static member ValueDefault : double = 0.0
    /// Default value for Axis
    /// The sequence axis. Only values of 0 and 1 are currently supported.
    static member AxisDefault : int = 0
    /// n-dimensional input array of the form [max_sequence_length, batch_size, other_feature_dims] where n&gt;2
    member __.Data = operatorArguments.GetInput "data"
    /// vector of sequence lengths of the form [batch_size]
    member __.SequenceLength = operatorArguments.GetInput "sequence_length"
    /// If set to true, this layer takes in an extra input parameter `sequence_length` to specify variable length sequence
    member __.UseSequenceLength = operatorArguments.GetParameter("use_sequence_length", SequenceMask.UseSequenceLengthDefault)
    /// The value to be used as a mask.
    member __.Value = operatorArguments.GetParameter("value", SequenceMask.ValueDefault)
    /// The sequence axis. Only values of 0 and 1 are currently supported.
    member __.Axis = operatorArguments.GetParameter("axis", SequenceMask.AxisDefault)
    /// <summary>Copy SequenceMask instance with updated inputs/parameters.</summary>
    /// <param name="data">n-dimensional input array of the form [max_sequence_length, batch_size, other_feature_dims] where n&gt;2</param>
    /// <param name="sequenceLength">vector of sequence lengths of the form [batch_size]</param>
    /// <param name="useSequenceLength">If set to true, this layer takes in an extra input parameter `sequence_length` to specify variable length sequence</param>
    /// <param name="value">The value to be used as a mask.</param>
    /// <param name="axis">The sequence axis. Only values of 0 and 1 are currently supported.</param>
    member this.With([<Optional>] ?data : Symbol,
        [<Optional>] ?sequenceLength : Symbol,
        [<Optional>] ?useSequenceLength : bool,
        [<Optional>] ?value : float,
        [<Optional>] ?axis : int) = 
        let operatorArguments = 
            [
                data |> Option.map (fun x -> "data", Input x)
                sequenceLength |> Option.map (fun x -> "sequence_length", Input x)
                useSequenceLength |> Option.map (fun x -> "use_sequence_length", Parameter(Some (box x)))
                value |> Option.map (fun x -> "value", Parameter(Some (box x)))
                axis |> Option.map (fun x -> "axis", Parameter(Some (box x)))
            ] |> List.choose id
        new SequenceMask(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type SliceChannel private (operatorArguments) = 
    inherit SymbolOperator("SliceChannel", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new SliceChannel(args)
    override this.WithArguments(args : Arguments<Symbol>) = new SliceChannel(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <summary>Splits an array along a particular axis into multiple sub-arrays.
    /// 
    /// .. note:: ``SliceChannel`` is deprecated. Use ``split`` instead.
    /// 
    /// **Note** that `num_outputs` should evenly divide the length of the axis
    /// along which to split the array.
    /// 
    /// Example::
    /// 
    ///    x  = [[[ 1.]
    ///           [ 2.]]
    ///          [[ 3.]
    ///           [ 4.]]
    ///          [[ 5.]
    ///           [ 6.]]]
    ///    x.shape = (3, 2, 1)
    /// 
    ///    y = split(x, axis=1, num_outputs=2) // a list of 2 arrays with shape (3, 1, 1)
    ///    y = [[[ 1.]]
    ///         [[ 3.]]
    ///         [[ 5.]]]
    /// 
    ///        [[[ 2.]]
    ///         [[ 4.]]
    ///         [[ 6.]]]
    /// 
    ///    y[0].shape = (3, 1, 1)
    /// 
    ///    z = split(x, axis=0, num_outputs=3) // a list of 3 arrays with shape (1, 2, 1)
    ///    z = [[[ 1.]
    ///          [ 2.]]]
    /// 
    ///        [[[ 3.]
    ///          [ 4.]]]
    /// 
    ///        [[[ 5.]
    ///          [ 6.]]]
    /// 
    ///    z[0].shape = (1, 2, 1)
    /// 
    /// `squeeze_axis=1` removes the axis with length 1 from the shapes of the output arrays.
    /// **Note** that setting `squeeze_axis` to ``1`` removes axis with length 1 only
    /// along the `axis` which it is split.
    /// Also `squeeze_axis` can be set to true only if ``input.shape[axis] == num_outputs``.
    /// 
    /// Example::
    /// 
    ///    z = split(x, axis=0, num_outputs=3, squeeze_axis=1) // a list of 3 arrays with shape (2, 1)
    ///    z = [[ 1.]
    ///         [ 2.]]
    /// 
    ///        [[ 3.]
    ///         [ 4.]]
    /// 
    ///        [[ 5.]
    ///         [ 6.]]
    ///    z[0].shape = (2 ,1 )
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\slice_channel.cc:L107</summary>
    /// <param name="data">The input</param>
    /// <param name="numOutputs">Number of splits. Note that this should evenly divide the length of the `axis`.</param>
    /// <param name="axis">Axis along which to split.</param>
    /// <param name="squeezeAxis">If true, Removes the axis with length 1 from the shapes of the output arrays. **Note** that setting `squeeze_axis` to ``true`` removes axis with length 1 only along the `axis` which it is split. Also `squeeze_axis` can be set to ``true`` only if ``input.shape[axis] == num_outputs``.</param>
    new(data : Symbol,
        numOutputs : int,
        [<Optional>] ?axis : int,
        [<Optional>] ?squeezeAxis : bool) = 
        let operatorArguments = 
            [
                "data", Input data
                "num_outputs", Parameter(Some(box numOutputs))
                "axis", axis |> Option.map box |> Parameter
                "squeeze_axis", squeezeAxis |> Option.map box |> Parameter
            ]
        new SliceChannel(Arguments<Symbol>(operatorArguments))
    /// <summary>Splits an array along a particular axis into multiple sub-arrays.
    /// 
    /// .. note:: ``SliceChannel`` is deprecated. Use ``split`` instead.
    /// 
    /// **Note** that `num_outputs` should evenly divide the length of the axis
    /// along which to split the array.
    /// 
    /// Example::
    /// 
    ///    x  = [[[ 1.]
    ///           [ 2.]]
    ///          [[ 3.]
    ///           [ 4.]]
    ///          [[ 5.]
    ///           [ 6.]]]
    ///    x.shape = (3, 2, 1)
    /// 
    ///    y = split(x, axis=1, num_outputs=2) // a list of 2 arrays with shape (3, 1, 1)
    ///    y = [[[ 1.]]
    ///         [[ 3.]]
    ///         [[ 5.]]]
    /// 
    ///        [[[ 2.]]
    ///         [[ 4.]]
    ///         [[ 6.]]]
    /// 
    ///    y[0].shape = (3, 1, 1)
    /// 
    ///    z = split(x, axis=0, num_outputs=3) // a list of 3 arrays with shape (1, 2, 1)
    ///    z = [[[ 1.]
    ///          [ 2.]]]
    /// 
    ///        [[[ 3.]
    ///          [ 4.]]]
    /// 
    ///        [[[ 5.]
    ///          [ 6.]]]
    /// 
    ///    z[0].shape = (1, 2, 1)
    /// 
    /// `squeeze_axis=1` removes the axis with length 1 from the shapes of the output arrays.
    /// **Note** that setting `squeeze_axis` to ``1`` removes axis with length 1 only
    /// along the `axis` which it is split.
    /// Also `squeeze_axis` can be set to true only if ``input.shape[axis] == num_outputs``.
    /// 
    /// Example::
    /// 
    ///    z = split(x, axis=0, num_outputs=3, squeeze_axis=1) // a list of 3 arrays with shape (2, 1)
    ///    z = [[ 1.]
    ///         [ 2.]]
    /// 
    ///        [[ 3.]
    ///         [ 4.]]
    /// 
    ///        [[ 5.]
    ///         [ 6.]]
    ///    z[0].shape = (2 ,1 )
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\slice_channel.cc:L107</summary>
    /// <param name="numOutputs">Number of splits. Note that this should evenly divide the length of the `axis`.</param>
    /// <param name="data">The input</param>
    /// <param name="axis">Axis along which to split.</param>
    /// <param name="squeezeAxis">If true, Removes the axis with length 1 from the shapes of the output arrays. **Note** that setting `squeeze_axis` to ``true`` removes axis with length 1 only along the `axis` which it is split. Also `squeeze_axis` can be set to ``true`` only if ``input.shape[axis] == num_outputs``.</param>
    new(numOutputs : int,
        [<Optional>] ?data : Symbol,
        [<Optional>] ?axis : int,
        [<Optional>] ?squeezeAxis : bool) = 
        let data = defaultArg data (new ImplicitVariable() :> Symbol)
        let operatorArguments = 
            [
                "data", Input data
                "num_outputs", Parameter(Some(box numOutputs))
                "axis", axis |> Option.map box |> Parameter
                "squeeze_axis", squeezeAxis |> Option.map box |> Parameter
            ]
        new SliceChannel(Arguments<Symbol>(operatorArguments))
    /// Default value for Axis
    /// Axis along which to split.
    static member AxisDefault : int = 1
    /// Default value for SqueezeAxis
    /// If true, Removes the axis with length 1 from the shapes of the output arrays. **Note** that setting `squeeze_axis` to ``true`` removes axis with length 1 only along the `axis` which it is split. Also `squeeze_axis` can be set to ``true`` only if ``input.shape[axis] == num_outputs``.
    static member SqueezeAxisDefault : bool = false
    /// The input
    member __.Data = operatorArguments.GetInput "data"
    /// Number of splits. Note that this should evenly divide the length of the `axis`.
    member __.NumOutputs : int = match operatorArguments.GetParameter "num_outputs" with Some(v) -> unbox v | None -> failwithf "Required parameter num_outputs is missing"
    /// Axis along which to split.
    member __.Axis = operatorArguments.GetParameter("axis", SliceChannel.AxisDefault)
    /// If true, Removes the axis with length 1 from the shapes of the output arrays. **Note** that setting `squeeze_axis` to ``true`` removes axis with length 1 only along the `axis` which it is split. Also `squeeze_axis` can be set to ``true`` only if ``input.shape[axis] == num_outputs``.
    member __.SqueezeAxis = operatorArguments.GetParameter("squeeze_axis", SliceChannel.SqueezeAxisDefault)
    /// <summary>Copy SliceChannel instance with updated inputs/parameters.</summary>
    /// <param name="data">The input</param>
    /// <param name="numOutputs">Number of splits. Note that this should evenly divide the length of the `axis`.</param>
    /// <param name="axis">Axis along which to split.</param>
    /// <param name="squeezeAxis">If true, Removes the axis with length 1 from the shapes of the output arrays. **Note** that setting `squeeze_axis` to ``true`` removes axis with length 1 only along the `axis` which it is split. Also `squeeze_axis` can be set to ``true`` only if ``input.shape[axis] == num_outputs``.</param>
    member this.With([<Optional>] ?data : Symbol,
        [<Optional>] ?numOutputs : int,
        [<Optional>] ?axis : int,
        [<Optional>] ?squeezeAxis : bool) = 
        let operatorArguments = 
            [
                data |> Option.map (fun x -> "data", Input x)
                numOutputs |> Option.map (fun x -> "num_outputs", Parameter(Some (box x)))
                axis |> Option.map (fun x -> "axis", Parameter(Some (box x)))
                squeezeAxis |> Option.map (fun x -> "squeeze_axis", Parameter(Some (box x)))
            ] |> List.choose id
        new SliceChannel(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type SoftmaxOutput private (operatorArguments) = 
    inherit SymbolOperator("SoftmaxOutput", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new SoftmaxOutput(args)
    override this.WithArguments(args : Arguments<Symbol>) = new SoftmaxOutput(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <summary>Computes the gradient of cross entropy loss with respect to softmax output.
    /// 
    /// - This operator computes the gradient in two steps.
    ///   The cross entropy loss does not actually need to be computed.
    /// 
    ///   - Applies softmax function on the input array.
    ///   - Computes and returns the gradient of cross entropy loss w.r.t. the softmax output.
    /// 
    /// - The softmax function, cross entropy loss and gradient is given by:
    /// 
    ///   - Softmax Function:
    /// 
    ///     .. math:: \text{softmax}(x)_i = \frac{exp(x_i)}{\sum_j exp(x_j)}
    /// 
    ///   - Cross Entropy Function:
    /// 
    ///     .. math:: \text{CE(label, output)} = - \sum_i \text{label}_i \log(\text{output}_i)
    /// 
    ///   - The gradient of cross entropy loss w.r.t softmax output:
    /// 
    ///     .. math:: \text{gradient} = \text{output} - \text{label}
    /// 
    /// - During forward propagation, the softmax function is computed for each instance in the input array.
    /// 
    ///   For general *N*-D input arrays with shape :math:`(d_1, d_2, ..., d_n)`. The size is
    ///   :math:`s=d_1 \cdot d_2 \cdot \cdot \cdot d_n`. We can use the parameters `preserve_shape`
    ///   and `multi_output` to specify the way to compute softmax:
    /// 
    ///   - By default, `preserve_shape` is ``false``. This operator will reshape the input array
    ///     into a 2-D array with shape :math:`(d_1, \frac{s}{d_1})` and then compute the softmax function for
    ///     each row in the reshaped array, and afterwards reshape it back to the original shape
    ///     :math:`(d_1, d_2, ..., d_n)`.
    ///   - If `preserve_shape` is ``true``, the softmax function will be computed along
    ///     the last axis (`axis` = ``-1``).
    ///   - If `multi_output` is ``true``, the softmax function will be computed along
    ///     the second axis (`axis` = ``1``).
    /// 
    /// - During backward propagation, the gradient of cross-entropy loss w.r.t softmax output array is computed.
    ///   The provided label can be a one-hot label array or a probability label array.
    /// 
    ///   - If the parameter `use_ignore` is ``true``, `ignore_label` can specify input instances
    ///     with a particular label to be ignored during backward propagation. **This has no effect when
    ///     softmax `output` has same shape as `label`**.
    /// 
    ///     Example::
    /// 
    ///       data = [[1,2,3,4],[2,2,2,2],[3,3,3,3],[4,4,4,4]]
    ///       label = [1,0,2,3]
    ///       ignore_label = 1
    ///       SoftmaxOutput(data=data, label = label,\
    ///                     multi_output=true, use_ignore=true,\
    ///                     ignore_label=ignore_label)
    ///       ## forward softmax output
    ///       [[ 0.0320586   0.08714432  0.23688284  0.64391428]
    ///        [ 0.25        0.25        0.25        0.25      ]
    ///        [ 0.25        0.25        0.25        0.25      ]
    ///        [ 0.25        0.25        0.25        0.25      ]]
    ///       ## backward gradient output
    ///       [[ 0.    0.    0.    0.  ]
    ///        [-0.75  0.25  0.25  0.25]
    ///        [ 0.25  0.25 -0.75  0.25]
    ///        [ 0.25  0.25  0.25 -0.75]]
    ///       ## notice that the first row is all 0 because label[0] is 1, which is equal to ignore_label.
    /// 
    ///   - The parameter `grad_scale` can be used to rescale the gradient, which is often used to
    ///     give each loss function different weights.
    /// 
    ///   - This operator also supports various ways to normalize the gradient by `normalization`,
    ///     The `normalization` is applied if softmax output has different shape than the labels.
    ///     The `normalization` mode can be set to the followings:
    /// 
    ///     - ``&#39;null&#39;``: do nothing.
    ///     - ``&#39;batch&#39;``: divide the gradient by the batch size.
    ///     - ``&#39;valid&#39;``: divide the gradient by the number of instances which are not ignored.
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\softmax_output.cc:L230</summary>
    /// <param name="data">Input array.</param>
    /// <param name="label">Ground truth label.</param>
    /// <param name="gradScale">Scales the gradient by a float factor.</param>
    /// <param name="ignoreLabel">The instances whose `labels` == `ignore_label` will be ignored during backward, if `use_ignore` is set to ``true``).</param>
    /// <param name="multiOutput">If set to ``true``, the softmax function will be computed along axis ``1``. This is applied when the shape of input array differs from the shape of label array.</param>
    /// <param name="useIgnore">If set to ``true``, the `ignore_label` value will not contribute to the backward gradient.</param>
    /// <param name="preserveShape">If set to ``true``, the softmax function will be computed along the last axis (``-1``).</param>
    /// <param name="normalization">Normalizes the gradient.</param>
    /// <param name="outGrad">Multiplies gradient with output gradient element-wise.</param>
    /// <param name="smoothAlpha">Constant for computing a label smoothed version of cross-entropyfor the backwards pass.  This constant gets subtracted from theone-hot encoding of the gold label and distributed uniformly toall other labels.</param>
    new([<Optional>] ?data : Symbol,
        [<Optional>] ?label : Symbol,
        [<Optional>] ?gradScale : float,
        [<Optional>] ?ignoreLabel : float,
        [<Optional>] ?multiOutput : bool,
        [<Optional>] ?useIgnore : bool,
        [<Optional>] ?preserveShape : bool,
        [<Optional>] ?normalization : Normalization,
        [<Optional>] ?outGrad : bool,
        [<Optional>] ?smoothAlpha : float) = 
        let data = defaultArg data (new ImplicitVariable() :> Symbol)
        let label = defaultArg label (new ImplicitVariable() :> Symbol)
        let operatorArguments = 
            [
                "data", Input data
                "label", Input label
                "grad_scale", gradScale |> Option.map box |> Parameter
                "ignore_label", ignoreLabel |> Option.map box |> Parameter
                "multi_output", multiOutput |> Option.map box |> Parameter
                "use_ignore", useIgnore |> Option.map box |> Parameter
                "preserve_shape", preserveShape |> Option.map box |> Parameter
                "normalization", normalization |> Option.map box |> Parameter
                "out_grad", outGrad |> Option.map box |> Parameter
                "smooth_alpha", smoothAlpha |> Option.map box |> Parameter
            ]
        new SoftmaxOutput(Arguments<Symbol>(operatorArguments))
    /// Default value for GradScale
    /// Scales the gradient by a float factor.
    static member GradScaleDefault : double = 1.0
    /// Default value for IgnoreLabel
    /// The instances whose `labels` == `ignore_label` will be ignored during backward, if `use_ignore` is set to ``true``).
    static member IgnoreLabelDefault : double = -1.0
    /// Default value for MultiOutput
    /// If set to ``true``, the softmax function will be computed along axis ``1``. This is applied when the shape of input array differs from the shape of label array.
    static member MultiOutputDefault : bool = false
    /// Default value for UseIgnore
    /// If set to ``true``, the `ignore_label` value will not contribute to the backward gradient.
    static member UseIgnoreDefault : bool = false
    /// Default value for PreserveShape
    /// If set to ``true``, the softmax function will be computed along the last axis (``-1``).
    static member PreserveShapeDefault : bool = false
    /// Default value for Normalization
    /// Normalizes the gradient.
    static member NormalizationDefault : Normalization = Normalization.Null
    /// Default value for OutGrad
    /// Multiplies gradient with output gradient element-wise.
    static member OutGradDefault : bool = false
    /// Default value for SmoothAlpha
    /// Constant for computing a label smoothed version of cross-entropyfor the backwards pass.  This constant gets subtracted from theone-hot encoding of the gold label and distributed uniformly toall other labels.
    static member SmoothAlphaDefault : double = 0.0
    /// Input array.
    member __.Data = operatorArguments.GetInput "data"
    /// Ground truth label.
    member __.Label = operatorArguments.GetInput "label"
    /// Scales the gradient by a float factor.
    member __.GradScale = operatorArguments.GetParameter("grad_scale", SoftmaxOutput.GradScaleDefault)
    /// The instances whose `labels` == `ignore_label` will be ignored during backward, if `use_ignore` is set to ``true``).
    member __.IgnoreLabel = operatorArguments.GetParameter("ignore_label", SoftmaxOutput.IgnoreLabelDefault)
    /// If set to ``true``, the softmax function will be computed along axis ``1``. This is applied when the shape of input array differs from the shape of label array.
    member __.MultiOutput = operatorArguments.GetParameter("multi_output", SoftmaxOutput.MultiOutputDefault)
    /// If set to ``true``, the `ignore_label` value will not contribute to the backward gradient.
    member __.UseIgnore = operatorArguments.GetParameter("use_ignore", SoftmaxOutput.UseIgnoreDefault)
    /// If set to ``true``, the softmax function will be computed along the last axis (``-1``).
    member __.PreserveShape = operatorArguments.GetParameter("preserve_shape", SoftmaxOutput.PreserveShapeDefault)
    /// Normalizes the gradient.
    member __.Normalization = operatorArguments.GetParameter("normalization", SoftmaxOutput.NormalizationDefault)
    /// Multiplies gradient with output gradient element-wise.
    member __.OutGrad = operatorArguments.GetParameter("out_grad", SoftmaxOutput.OutGradDefault)
    /// Constant for computing a label smoothed version of cross-entropyfor the backwards pass.  This constant gets subtracted from theone-hot encoding of the gold label and distributed uniformly toall other labels.
    member __.SmoothAlpha = operatorArguments.GetParameter("smooth_alpha", SoftmaxOutput.SmoothAlphaDefault)
    /// <summary>Copy SoftmaxOutput instance with updated inputs/parameters.</summary>
    /// <param name="data">Input array.</param>
    /// <param name="label">Ground truth label.</param>
    /// <param name="gradScale">Scales the gradient by a float factor.</param>
    /// <param name="ignoreLabel">The instances whose `labels` == `ignore_label` will be ignored during backward, if `use_ignore` is set to ``true``).</param>
    /// <param name="multiOutput">If set to ``true``, the softmax function will be computed along axis ``1``. This is applied when the shape of input array differs from the shape of label array.</param>
    /// <param name="useIgnore">If set to ``true``, the `ignore_label` value will not contribute to the backward gradient.</param>
    /// <param name="preserveShape">If set to ``true``, the softmax function will be computed along the last axis (``-1``).</param>
    /// <param name="normalization">Normalizes the gradient.</param>
    /// <param name="outGrad">Multiplies gradient with output gradient element-wise.</param>
    /// <param name="smoothAlpha">Constant for computing a label smoothed version of cross-entropyfor the backwards pass.  This constant gets subtracted from theone-hot encoding of the gold label and distributed uniformly toall other labels.</param>
    member this.With([<Optional>] ?data : Symbol,
        [<Optional>] ?label : Symbol,
        [<Optional>] ?gradScale : float,
        [<Optional>] ?ignoreLabel : float,
        [<Optional>] ?multiOutput : bool,
        [<Optional>] ?useIgnore : bool,
        [<Optional>] ?preserveShape : bool,
        [<Optional>] ?normalization : Normalization,
        [<Optional>] ?outGrad : bool,
        [<Optional>] ?smoothAlpha : float) = 
        let operatorArguments = 
            [
                data |> Option.map (fun x -> "data", Input x)
                label |> Option.map (fun x -> "label", Input x)
                gradScale |> Option.map (fun x -> "grad_scale", Parameter(Some (box x)))
                ignoreLabel |> Option.map (fun x -> "ignore_label", Parameter(Some (box x)))
                multiOutput |> Option.map (fun x -> "multi_output", Parameter(Some (box x)))
                useIgnore |> Option.map (fun x -> "use_ignore", Parameter(Some (box x)))
                preserveShape |> Option.map (fun x -> "preserve_shape", Parameter(Some (box x)))
                normalization |> Option.map (fun x -> "normalization", Parameter(Some (box x)))
                outGrad |> Option.map (fun x -> "out_grad", Parameter(Some (box x)))
                smoothAlpha |> Option.map (fun x -> "smooth_alpha", Parameter(Some (box x)))
            ] |> List.choose id
        new SoftmaxOutput(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type SwapAxis private (operatorArguments) = 
    inherit SymbolOperator("SwapAxis", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new SwapAxis(args)
    override this.WithArguments(args : Arguments<Symbol>) = new SwapAxis(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <summary>Interchanges two axes of an array.
    /// 
    /// Examples::
    /// 
    ///   x = [[1, 2, 3]])
    ///   swapaxes(x, 0, 1) = [[ 1],
    ///                        [ 2],
    ///                        [ 3]]
    /// 
    ///   x = [[[ 0, 1],
    ///         [ 2, 3]],
    ///        [[ 4, 5],
    ///         [ 6, 7]]]  // (2,2,2) array
    /// 
    ///  swapaxes(x, 0, 2) = [[[ 0, 4],
    ///                        [ 2, 6]],
    ///                       [[ 1, 5],
    ///                        [ 3, 7]]]
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\swapaxis.cc:L70</summary>
    /// <param name="data">Input array.</param>
    /// <param name="dim1">the first axis to be swapped.</param>
    /// <param name="dim2">the second axis to be swapped.</param>
    new([<Optional>] ?data : Symbol,
        [<Optional>] ?dim1 : int,
        [<Optional>] ?dim2 : int) = 
        let data = defaultArg data (new ImplicitVariable() :> Symbol)
        let operatorArguments = 
            [
                "data", Input data
                "dim1", dim1 |> Option.map box |> Parameter
                "dim2", dim2 |> Option.map box |> Parameter
            ]
        new SwapAxis(Arguments<Symbol>(operatorArguments))
    /// Default value for Dim1
    /// the first axis to be swapped.
    static member Dim1Default : int = 0
    /// Default value for Dim2
    /// the second axis to be swapped.
    static member Dim2Default : int = 0
    /// Input array.
    member __.Data = operatorArguments.GetInput "data"
    /// the first axis to be swapped.
    member __.Dim1 = operatorArguments.GetParameter("dim1", SwapAxis.Dim1Default)
    /// the second axis to be swapped.
    member __.Dim2 = operatorArguments.GetParameter("dim2", SwapAxis.Dim2Default)
    /// <summary>Copy SwapAxis instance with updated inputs/parameters.</summary>
    /// <param name="data">Input array.</param>
    /// <param name="dim1">the first axis to be swapped.</param>
    /// <param name="dim2">the second axis to be swapped.</param>
    member this.With([<Optional>] ?data : Symbol,
        [<Optional>] ?dim1 : int,
        [<Optional>] ?dim2 : int) = 
        let operatorArguments = 
            [
                data |> Option.map (fun x -> "data", Input x)
                dim1 |> Option.map (fun x -> "dim1", Parameter(Some (box x)))
                dim2 |> Option.map (fun x -> "dim2", Parameter(Some (box x)))
            ] |> List.choose id
        new SwapAxis(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type AmpCast private (operatorArguments) = 
    inherit SymbolOperator("amp_cast", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new AmpCast(args)
    override this.WithArguments(args : Arguments<Symbol>) = new AmpCast(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <summary>Cast function between low precision float/FP32 used by AMP.
    /// 
    /// It casts only between low precision float/FP32 and does not do anything for other types.
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\amp_cast.cc:L37</summary>
    /// <param name="data">The input.</param>
    /// <param name="dtype">Output data type.</param>
    new(data : Symbol,
        dtype : IntOrFloatDType) = 
        let operatorArguments = 
            [
                "data", Input data
                "dtype", Parameter(Some(box dtype))
            ]
        new AmpCast(Arguments<Symbol>(operatorArguments))
    /// <summary>Cast function between low precision float/FP32 used by AMP.
    /// 
    /// It casts only between low precision float/FP32 and does not do anything for other types.
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\amp_cast.cc:L37</summary>
    /// <param name="dtype">Output data type.</param>
    /// <param name="data">The input.</param>
    new(dtype : IntOrFloatDType,
        [<Optional>] ?data : Symbol) = 
        let data = defaultArg data (new ImplicitVariable() :> Symbol)
        let operatorArguments = 
            [
                "data", Input data
                "dtype", Parameter(Some(box dtype))
            ]
        new AmpCast(Arguments<Symbol>(operatorArguments))
    /// The input.
    member __.Data = operatorArguments.GetInput "data"
    /// Output data type.
    member __.Dtype : IntOrFloatDType = match operatorArguments.GetParameter "dtype" with Some(v) -> unbox v | None -> failwithf "Required parameter dtype is missing"
    /// <summary>Copy AmpCast instance with updated inputs/parameters.</summary>
    /// <param name="data">The input.</param>
    /// <param name="dtype">Output data type.</param>
    member this.With([<Optional>] ?data : Symbol,
        [<Optional>] ?dtype : IntOrFloatDType) = 
        let operatorArguments = 
            [
                data |> Option.map (fun x -> "data", Input x)
                dtype |> Option.map (fun x -> "dtype", Parameter(Some (box x)))
            ] |> List.choose id
        new AmpCast(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type AmpMulticast private (operatorArguments) = 
    inherit SymbolOperator("amp_multicast", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new AmpMulticast(args)
    override this.WithArguments(args : Arguments<Symbol>) = new AmpMulticast(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <summary>Cast function used by AMP, that casts its inputs to the common widest type.
    /// 
    /// It casts only between low precision float/FP32 and does not do anything for other types.
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\amp_cast.cc:L71</summary>
    /// <param name="data">Weights</param>
    /// <param name="numOutputs">Number of input/output pairs to be casted to the widest type.</param>
    new(data : Symbol seq,
        numOutputs : int) = 
        let operatorArguments = 
            [
                "data", VarArg("", data |> Seq.toArray)
                "num_outputs", Parameter(Some(box numOutputs))
            ]
        new AmpMulticast(Arguments<Symbol>(operatorArguments))
    /// <summary>Cast function used by AMP, that casts its inputs to the common widest type.
    /// 
    /// It casts only between low precision float/FP32 and does not do anything for other types.
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\amp_cast.cc:L71</summary>
    /// <param name="numOutputs">Number of input/output pairs to be casted to the widest type.</param>
    /// <param name="data">Weights</param>
    new(numOutputs : int,
        [<Optional>] ?data : Symbol seq) = 
        let data = defaultArg (data |> Option.map Seq.toArray) Array.empty
        let operatorArguments = 
            [
                "data", VarArg("", data)
                "num_outputs", Parameter(Some(box numOutputs))
            ]
        new AmpMulticast(Arguments<Symbol>(operatorArguments))
    /// <summary>Cast function used by AMP, that casts its inputs to the common widest type.
    /// 
    /// It casts only between low precision float/FP32 and does not do anything for other types.
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\amp_cast.cc:L71</summary>
    /// <param name="numOutputs">Number of input/output pairs to be casted to the widest type.</param>
    /// <param name="data">Weights</param>
    new(numOutputs : int,
        [<ParamArray>] data : Symbol[]) = 
        let operatorArguments = 
            [
                "data", VarArg("", data)
                "num_outputs", Parameter(Some(box numOutputs))
            ]
        new AmpMulticast(Arguments<Symbol>(operatorArguments))
    /// Weights
    member __.Data = operatorArguments.GetVarArg "data"
    /// Number of input/output pairs to be casted to the widest type.
    member __.NumOutputs : int = match operatorArguments.GetParameter "num_outputs" with Some(v) -> unbox v | None -> failwithf "Required parameter num_outputs is missing"
    /// <summary>Copy AmpMulticast instance with updated inputs/parameters.</summary>
    /// <param name="data">Weights</param>
    /// <param name="numOutputs">Number of input/output pairs to be casted to the widest type.</param>
    member this.With([<Optional>] ?data : Symbol seq,
        [<Optional>] ?numOutputs : int) = 
        let operatorArguments = 
            [
                data |> Option.map (fun x -> "data", VarArg("", Seq.toArray x))
                numOutputs |> Option.map (fun x -> "num_outputs", Parameter(Some (box x)))
            ] |> List.choose id
        new AmpMulticast(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type Max private (operatorArguments) = 
    inherit SymbolOperator("max", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new Max(args)
    override this.WithArguments(args : Arguments<Symbol>) = new Max(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <summary>Computes the max of array elements over given axes.
    /// 
    /// Defined in c:\jenkins\workspace\mxnet\mxnet\src\operator\tensor\./broadcast_reduce_op.h:L32</summary>
    /// <param name="data">The input</param>
    /// <param name="axis">The axis or axes along which to perform the reduction.
    /// 
    ///       The default, `axis=()`, will compute over all elements into a
    ///       scalar array with shape `(1,)`.
    /// 
    ///       If `axis` is int, a reduction is performed on a particular axis.
    /// 
    ///       If `axis` is a tuple of ints, a reduction is performed on all the axes
    ///       specified in the tuple.
    /// 
    ///       If `exclude` is true, reduction will be performed on the axes that are
    ///       NOT in axis instead.
    /// 
    ///       Negative values means indexing from right to left.</param>
    /// <param name="keepdims">If this is set to `True`, the reduced axes are left in the result as dimension with size one.</param>
    /// <param name="exclude">Whether to perform reduction on axis that are NOT in axis instead.</param>
    new([<Optional>] ?data : Symbol,
        [<Optional>] ?axis : int seq,
        [<Optional>] ?keepdims : bool,
        [<Optional>] ?exclude : bool) = 
        let data = defaultArg data (new ImplicitVariable() :> Symbol)
        let operatorArguments = 
            [
                "data", Input data
                "axis", axis |> Option.map box |> Parameter
                "keepdims", keepdims |> Option.map box |> Parameter
                "exclude", exclude |> Option.map box |> Parameter
            ]
        new Max(Arguments<Symbol>(operatorArguments))
    /// Default value for Axis
    /// The axis or axes along which to perform the reduction.
    /// 
    ///       The default, `axis=()`, will compute over all elements into a
    ///       scalar array with shape `(1,)`.
    /// 
    ///       If `axis` is int, a reduction is performed on a particular axis.
    /// 
    ///       If `axis` is a tuple of ints, a reduction is performed on all the axes
    ///       specified in the tuple.
    /// 
    ///       If `exclude` is true, reduction will be performed on the axes that are
    ///       NOT in axis instead.
    /// 
    ///       Negative values means indexing from right to left.
    static member AxisDefault : int [] option = None
    /// Default value for Keepdims
    /// If this is set to `True`, the reduced axes are left in the result as dimension with size one.
    static member KeepdimsDefault : bool = false
    /// Default value for Exclude
    /// Whether to perform reduction on axis that are NOT in axis instead.
    static member ExcludeDefault : bool = false
    /// The input
    member __.Data = operatorArguments.GetInput "data"
    /// The axis or axes along which to perform the reduction.
    /// 
    ///       The default, `axis=()`, will compute over all elements into a
    ///       scalar array with shape `(1,)`.
    /// 
    ///       If `axis` is int, a reduction is performed on a particular axis.
    /// 
    ///       If `axis` is a tuple of ints, a reduction is performed on all the axes
    ///       specified in the tuple.
    /// 
    ///       If `exclude` is true, reduction will be performed on the axes that are
    ///       NOT in axis instead.
    /// 
    ///       Negative values means indexing from right to left.
    member __.Axis = operatorArguments.GetParameter("axis", Max.AxisDefault)
    /// If this is set to `True`, the reduced axes are left in the result as dimension with size one.
    member __.Keepdims = operatorArguments.GetParameter("keepdims", Max.KeepdimsDefault)
    /// Whether to perform reduction on axis that are NOT in axis instead.
    member __.Exclude = operatorArguments.GetParameter("exclude", Max.ExcludeDefault)
    /// <summary>Copy Max instance with updated inputs/parameters.</summary>
    /// <param name="data">The input</param>
    /// <param name="axis">The axis or axes along which to perform the reduction.
    /// 
    ///       The default, `axis=()`, will compute over all elements into a
    ///       scalar array with shape `(1,)`.
    /// 
    ///       If `axis` is int, a reduction is performed on a particular axis.
    /// 
    ///       If `axis` is a tuple of ints, a reduction is performed on all the axes
    ///       specified in the tuple.
    /// 
    ///       If `exclude` is true, reduction will be performed on the axes that are
    ///       NOT in axis instead.
    /// 
    ///       Negative values means indexing from right to left.</param>
    /// <param name="keepdims">If this is set to `True`, the reduced axes are left in the result as dimension with size one.</param>
    /// <param name="exclude">Whether to perform reduction on axis that are NOT in axis instead.</param>
    member this.With([<Optional>] ?data : Symbol,
        [<Optional>] ?axis : int seq,
        [<Optional>] ?keepdims : bool,
        [<Optional>] ?exclude : bool) = 
        let operatorArguments = 
            [
                data |> Option.map (fun x -> "data", Input x)
                axis |> Option.map (fun x -> "axis", Parameter(Some (box x)))
                keepdims |> Option.map (fun x -> "keepdims", Parameter(Some (box x)))
                exclude |> Option.map (fun x -> "exclude", Parameter(Some (box x)))
            ] |> List.choose id
        new Max(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type Min private (operatorArguments) = 
    inherit SymbolOperator("min", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new Min(args)
    override this.WithArguments(args : Arguments<Symbol>) = new Min(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <summary>Computes the min of array elements over given axes.
    /// 
    /// Defined in c:\jenkins\workspace\mxnet\mxnet\src\operator\tensor\./broadcast_reduce_op.h:L46</summary>
    /// <param name="data">The input</param>
    /// <param name="axis">The axis or axes along which to perform the reduction.
    /// 
    ///       The default, `axis=()`, will compute over all elements into a
    ///       scalar array with shape `(1,)`.
    /// 
    ///       If `axis` is int, a reduction is performed on a particular axis.
    /// 
    ///       If `axis` is a tuple of ints, a reduction is performed on all the axes
    ///       specified in the tuple.
    /// 
    ///       If `exclude` is true, reduction will be performed on the axes that are
    ///       NOT in axis instead.
    /// 
    ///       Negative values means indexing from right to left.</param>
    /// <param name="keepdims">If this is set to `True`, the reduced axes are left in the result as dimension with size one.</param>
    /// <param name="exclude">Whether to perform reduction on axis that are NOT in axis instead.</param>
    new([<Optional>] ?data : Symbol,
        [<Optional>] ?axis : int seq,
        [<Optional>] ?keepdims : bool,
        [<Optional>] ?exclude : bool) = 
        let data = defaultArg data (new ImplicitVariable() :> Symbol)
        let operatorArguments = 
            [
                "data", Input data
                "axis", axis |> Option.map box |> Parameter
                "keepdims", keepdims |> Option.map box |> Parameter
                "exclude", exclude |> Option.map box |> Parameter
            ]
        new Min(Arguments<Symbol>(operatorArguments))
    /// Default value for Axis
    /// The axis or axes along which to perform the reduction.
    /// 
    ///       The default, `axis=()`, will compute over all elements into a
    ///       scalar array with shape `(1,)`.
    /// 
    ///       If `axis` is int, a reduction is performed on a particular axis.
    /// 
    ///       If `axis` is a tuple of ints, a reduction is performed on all the axes
    ///       specified in the tuple.
    /// 
    ///       If `exclude` is true, reduction will be performed on the axes that are
    ///       NOT in axis instead.
    /// 
    ///       Negative values means indexing from right to left.
    static member AxisDefault : int [] option = None
    /// Default value for Keepdims
    /// If this is set to `True`, the reduced axes are left in the result as dimension with size one.
    static member KeepdimsDefault : bool = false
    /// Default value for Exclude
    /// Whether to perform reduction on axis that are NOT in axis instead.
    static member ExcludeDefault : bool = false
    /// The input
    member __.Data = operatorArguments.GetInput "data"
    /// The axis or axes along which to perform the reduction.
    /// 
    ///       The default, `axis=()`, will compute over all elements into a
    ///       scalar array with shape `(1,)`.
    /// 
    ///       If `axis` is int, a reduction is performed on a particular axis.
    /// 
    ///       If `axis` is a tuple of ints, a reduction is performed on all the axes
    ///       specified in the tuple.
    /// 
    ///       If `exclude` is true, reduction will be performed on the axes that are
    ///       NOT in axis instead.
    /// 
    ///       Negative values means indexing from right to left.
    member __.Axis = operatorArguments.GetParameter("axis", Min.AxisDefault)
    /// If this is set to `True`, the reduced axes are left in the result as dimension with size one.
    member __.Keepdims = operatorArguments.GetParameter("keepdims", Min.KeepdimsDefault)
    /// Whether to perform reduction on axis that are NOT in axis instead.
    member __.Exclude = operatorArguments.GetParameter("exclude", Min.ExcludeDefault)
    /// <summary>Copy Min instance with updated inputs/parameters.</summary>
    /// <param name="data">The input</param>
    /// <param name="axis">The axis or axes along which to perform the reduction.
    /// 
    ///       The default, `axis=()`, will compute over all elements into a
    ///       scalar array with shape `(1,)`.
    /// 
    ///       If `axis` is int, a reduction is performed on a particular axis.
    /// 
    ///       If `axis` is a tuple of ints, a reduction is performed on all the axes
    ///       specified in the tuple.
    /// 
    ///       If `exclude` is true, reduction will be performed on the axes that are
    ///       NOT in axis instead.
    /// 
    ///       Negative values means indexing from right to left.</param>
    /// <param name="keepdims">If this is set to `True`, the reduced axes are left in the result as dimension with size one.</param>
    /// <param name="exclude">Whether to perform reduction on axis that are NOT in axis instead.</param>
    member this.With([<Optional>] ?data : Symbol,
        [<Optional>] ?axis : int seq,
        [<Optional>] ?keepdims : bool,
        [<Optional>] ?exclude : bool) = 
        let operatorArguments = 
            [
                data |> Option.map (fun x -> "data", Input x)
                axis |> Option.map (fun x -> "axis", Parameter(Some (box x)))
                keepdims |> Option.map (fun x -> "keepdims", Parameter(Some (box x)))
                exclude |> Option.map (fun x -> "exclude", Parameter(Some (box x)))
            ] |> List.choose id
        new Min(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type Norm private (operatorArguments) = 
    inherit SymbolOperator("norm", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new Norm(args)
    override this.WithArguments(args : Arguments<Symbol>) = new Norm(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <summary>Computes the norm on an NDArray.
    /// 
    /// This operator computes the norm on an NDArray with the specified axis, depending
    /// on the value of the ord parameter. By default, it computes the L2 norm on the entire
    /// array. Currently only ord=2 supports sparse ndarrays.
    /// 
    /// Examples::
    /// 
    ///   x = [[[1, 2],
    ///         [3, 4]],
    ///        [[2, 2],
    ///         [5, 6]]]
    /// 
    ///   norm(x, ord=2, axis=1) = [[3.1622777 4.472136 ]
    ///                             [5.3851647 6.3245554]]
    /// 
    ///   norm(x, ord=1, axis=1) = [[4., 6.],
    ///                             [7., 8.]]
    /// 
    ///   rsp = x.cast_storage(&#39;row_sparse&#39;)
    /// 
    ///   norm(rsp) = [5.47722578]
    /// 
    ///   csr = x.cast_storage(&#39;csr&#39;)
    /// 
    ///   norm(csr) = [5.47722578]
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\broadcast_reduce_norm_value.cc:L89</summary>
    /// <param name="data">The input</param>
    /// <param name="ord">Order of the norm. Currently ord=1 and ord=2 is supported.</param>
    /// <param name="axis">The axis or axes along which to perform the reduction.
    ///       The default, `axis=()`, will compute over all elements into a
    ///       scalar array with shape `(1,)`.
    ///       If `axis` is int, a reduction is performed on a particular axis.
    ///       If `axis` is a 2-tuple, it specifies the axes that hold 2-D matrices,
    ///       and the matrix norms of these matrices are computed.</param>
    /// <param name="outDtype">The data type of the output.</param>
    /// <param name="keepdims">If this is set to `True`, the reduced axis is left in the result as dimension with size one.</param>
    new([<Optional>] ?data : Symbol,
        [<Optional>] ?ord : int,
        [<Optional>] ?axis : int seq,
        [<Optional>] ?outDtype : OutDtype,
        [<Optional>] ?keepdims : bool) = 
        let data = defaultArg data (new ImplicitVariable() :> Symbol)
        let operatorArguments = 
            [
                "data", Input data
                "ord", ord |> Option.map box |> Parameter
                "axis", axis |> Option.map box |> Parameter
                "out_dtype", outDtype |> Option.map box |> Parameter
                "keepdims", keepdims |> Option.map box |> Parameter
            ]
        new Norm(Arguments<Symbol>(operatorArguments))
    /// Default value for Ord
    /// Order of the norm. Currently ord=1 and ord=2 is supported.
    static member OrdDefault : int = 2
    /// Default value for Axis
    /// The axis or axes along which to perform the reduction.
    ///       The default, `axis=()`, will compute over all elements into a
    ///       scalar array with shape `(1,)`.
    ///       If `axis` is int, a reduction is performed on a particular axis.
    ///       If `axis` is a 2-tuple, it specifies the axes that hold 2-D matrices,
    ///       and the matrix norms of these matrices are computed.
    static member AxisDefault : int [] option = None
    /// Default value for OutDtype
    /// The data type of the output.
    static member OutDtypeDefault : OutDtype option = None
    /// Default value for Keepdims
    /// If this is set to `True`, the reduced axis is left in the result as dimension with size one.
    static member KeepdimsDefault : bool = false
    /// The input
    member __.Data = operatorArguments.GetInput "data"
    /// Order of the norm. Currently ord=1 and ord=2 is supported.
    member __.Ord = operatorArguments.GetParameter("ord", Norm.OrdDefault)
    /// The axis or axes along which to perform the reduction.
    ///       The default, `axis=()`, will compute over all elements into a
    ///       scalar array with shape `(1,)`.
    ///       If `axis` is int, a reduction is performed on a particular axis.
    ///       If `axis` is a 2-tuple, it specifies the axes that hold 2-D matrices,
    ///       and the matrix norms of these matrices are computed.
    member __.Axis = operatorArguments.GetParameter("axis", Norm.AxisDefault)
    /// The data type of the output.
    member __.OutDtype = operatorArguments.GetParameter("out_dtype", Norm.OutDtypeDefault)
    /// If this is set to `True`, the reduced axis is left in the result as dimension with size one.
    member __.Keepdims = operatorArguments.GetParameter("keepdims", Norm.KeepdimsDefault)
    /// <summary>Copy Norm instance with updated inputs/parameters.</summary>
    /// <param name="data">The input</param>
    /// <param name="ord">Order of the norm. Currently ord=1 and ord=2 is supported.</param>
    /// <param name="axis">The axis or axes along which to perform the reduction.
    ///       The default, `axis=()`, will compute over all elements into a
    ///       scalar array with shape `(1,)`.
    ///       If `axis` is int, a reduction is performed on a particular axis.
    ///       If `axis` is a 2-tuple, it specifies the axes that hold 2-D matrices,
    ///       and the matrix norms of these matrices are computed.</param>
    /// <param name="outDtype">The data type of the output.</param>
    /// <param name="keepdims">If this is set to `True`, the reduced axis is left in the result as dimension with size one.</param>
    member this.With([<Optional>] ?data : Symbol,
        [<Optional>] ?ord : int,
        [<Optional>] ?axis : int seq,
        [<Optional>] ?outDtype : OutDtype,
        [<Optional>] ?keepdims : bool) = 
        let operatorArguments = 
            [
                data |> Option.map (fun x -> "data", Input x)
                ord |> Option.map (fun x -> "ord", Parameter(Some (box x)))
                axis |> Option.map (fun x -> "axis", Parameter(Some (box x)))
                outDtype |> Option.map (fun x -> "out_dtype", Parameter(Some (box x)))
                keepdims |> Option.map (fun x -> "keepdims", Parameter(Some (box x)))
            ] |> List.choose id
        new Norm(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type Argmax private (operatorArguments) = 
    inherit SymbolOperator("argmax", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new Argmax(args)
    override this.WithArguments(args : Arguments<Symbol>) = new Argmax(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <summary>Returns indices of the maximum values along an axis.
    /// 
    /// In the case of multiple occurrences of maximum values, the indices corresponding to the first occurrence
    /// are returned.
    /// 
    /// Examples::
    /// 
    ///   x = [[ 0.,  1.,  2.],
    ///        [ 3.,  4.,  5.]]
    /// 
    ///   // argmax along axis 0
    ///   argmax(x, axis=0) = [ 1.,  1.,  1.]
    /// 
    ///   // argmax along axis 1
    ///   argmax(x, axis=1) = [ 2.,  2.]
    /// 
    ///   // argmax along axis 1 keeping same dims as an input array
    ///   argmax(x, axis=1, keepdims=True) = [[ 2.],
    ///                                       [ 2.]]
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\broadcast_reduce_op_index.cc:L52</summary>
    /// <param name="data">The input</param>
    /// <param name="axis">The axis along which to perform the reduction. Negative values means indexing from right to left. ``Requires axis to be set as int, because global reduction is not supported yet.``</param>
    /// <param name="keepdims">If this is set to `True`, the reduced axis is left in the result as dimension with size one.</param>
    new([<Optional>] ?data : Symbol,
        [<Optional>] ?axis : int,
        [<Optional>] ?keepdims : bool) = 
        let data = defaultArg data (new ImplicitVariable() :> Symbol)
        let operatorArguments = 
            [
                "data", Input data
                "axis", axis |> Option.map box |> Parameter
                "keepdims", keepdims |> Option.map box |> Parameter
            ]
        new Argmax(Arguments<Symbol>(operatorArguments))
    /// Default value for Axis
    /// The axis along which to perform the reduction. Negative values means indexing from right to left. ``Requires axis to be set as int, because global reduction is not supported yet.``
    static member AxisDefault : int option = None
    /// Default value for Keepdims
    /// If this is set to `True`, the reduced axis is left in the result as dimension with size one.
    static member KeepdimsDefault : bool = false
    /// The input
    member __.Data = operatorArguments.GetInput "data"
    /// The axis along which to perform the reduction. Negative values means indexing from right to left. ``Requires axis to be set as int, because global reduction is not supported yet.``
    member __.Axis = operatorArguments.GetParameter("axis", Argmax.AxisDefault)
    /// If this is set to `True`, the reduced axis is left in the result as dimension with size one.
    member __.Keepdims = operatorArguments.GetParameter("keepdims", Argmax.KeepdimsDefault)
    /// <summary>Copy Argmax instance with updated inputs/parameters.</summary>
    /// <param name="data">The input</param>
    /// <param name="axis">The axis along which to perform the reduction. Negative values means indexing from right to left. ``Requires axis to be set as int, because global reduction is not supported yet.``</param>
    /// <param name="keepdims">If this is set to `True`, the reduced axis is left in the result as dimension with size one.</param>
    member this.With([<Optional>] ?data : Symbol,
        [<Optional>] ?axis : int,
        [<Optional>] ?keepdims : bool) = 
        let operatorArguments = 
            [
                data |> Option.map (fun x -> "data", Input x)
                axis |> Option.map (fun x -> "axis", Parameter(Some (box x)))
                keepdims |> Option.map (fun x -> "keepdims", Parameter(Some (box x)))
            ] |> List.choose id
        new Argmax(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type Argmin private (operatorArguments) = 
    inherit SymbolOperator("argmin", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new Argmin(args)
    override this.WithArguments(args : Arguments<Symbol>) = new Argmin(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <summary>Returns indices of the minimum values along an axis.
    /// 
    /// In the case of multiple occurrences of minimum values, the indices corresponding to the first occurrence
    /// are returned.
    /// 
    /// Examples::
    /// 
    ///   x = [[ 0.,  1.,  2.],
    ///        [ 3.,  4.,  5.]]
    /// 
    ///   // argmin along axis 0
    ///   argmin(x, axis=0) = [ 0.,  0.,  0.]
    /// 
    ///   // argmin along axis 1
    ///   argmin(x, axis=1) = [ 0.,  0.]
    /// 
    ///   // argmin along axis 1 keeping same dims as an input array
    ///   argmin(x, axis=1, keepdims=True) = [[ 0.],
    ///                                       [ 0.]]
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\broadcast_reduce_op_index.cc:L77</summary>
    /// <param name="data">The input</param>
    /// <param name="axis">The axis along which to perform the reduction. Negative values means indexing from right to left. ``Requires axis to be set as int, because global reduction is not supported yet.``</param>
    /// <param name="keepdims">If this is set to `True`, the reduced axis is left in the result as dimension with size one.</param>
    new([<Optional>] ?data : Symbol,
        [<Optional>] ?axis : int,
        [<Optional>] ?keepdims : bool) = 
        let data = defaultArg data (new ImplicitVariable() :> Symbol)
        let operatorArguments = 
            [
                "data", Input data
                "axis", axis |> Option.map box |> Parameter
                "keepdims", keepdims |> Option.map box |> Parameter
            ]
        new Argmin(Arguments<Symbol>(operatorArguments))
    /// Default value for Axis
    /// The axis along which to perform the reduction. Negative values means indexing from right to left. ``Requires axis to be set as int, because global reduction is not supported yet.``
    static member AxisDefault : int option = None
    /// Default value for Keepdims
    /// If this is set to `True`, the reduced axis is left in the result as dimension with size one.
    static member KeepdimsDefault : bool = false
    /// The input
    member __.Data = operatorArguments.GetInput "data"
    /// The axis along which to perform the reduction. Negative values means indexing from right to left. ``Requires axis to be set as int, because global reduction is not supported yet.``
    member __.Axis = operatorArguments.GetParameter("axis", Argmin.AxisDefault)
    /// If this is set to `True`, the reduced axis is left in the result as dimension with size one.
    member __.Keepdims = operatorArguments.GetParameter("keepdims", Argmin.KeepdimsDefault)
    /// <summary>Copy Argmin instance with updated inputs/parameters.</summary>
    /// <param name="data">The input</param>
    /// <param name="axis">The axis along which to perform the reduction. Negative values means indexing from right to left. ``Requires axis to be set as int, because global reduction is not supported yet.``</param>
    /// <param name="keepdims">If this is set to `True`, the reduced axis is left in the result as dimension with size one.</param>
    member this.With([<Optional>] ?data : Symbol,
        [<Optional>] ?axis : int,
        [<Optional>] ?keepdims : bool) = 
        let operatorArguments = 
            [
                data |> Option.map (fun x -> "data", Input x)
                axis |> Option.map (fun x -> "axis", Parameter(Some (box x)))
                keepdims |> Option.map (fun x -> "keepdims", Parameter(Some (box x)))
            ] |> List.choose id
        new Argmin(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type ArgmaxChannel private (operatorArguments) = 
    inherit SymbolOperator("argmax_channel", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new ArgmaxChannel(args)
    override this.WithArguments(args : Arguments<Symbol>) = new ArgmaxChannel(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <summary>Returns argmax indices of each channel from the input array.
    /// 
    /// The result will be an NDArray of shape (num_channel,).
    /// 
    /// In case of multiple occurrences of the maximum values, the indices corresponding to the first occurrence
    /// are returned.
    /// 
    /// Examples::
    /// 
    ///   x = [[ 0.,  1.,  2.],
    ///        [ 3.,  4.,  5.]]
    /// 
    ///   argmax_channel(x) = [ 2.,  2.]
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\broadcast_reduce_op_index.cc:L97</summary>
    /// <param name="data">The input array</param>
    new([<Optional>] ?data : Symbol) =
        let data = defaultArg data (new ImplicitVariable() :> Symbol)
        let operatorArguments = 
            [
                "data", Input data
            ]
        new ArgmaxChannel(Arguments<Symbol>(operatorArguments))
    /// The input array
    member __.Data = operatorArguments.GetInput "data"
    /// <summary>Copy ArgmaxChannel instance with updated inputs/parameters.</summary>
    /// <param name="data">The input array</param>
    member this.With([<Optional>] ?data : Symbol) =
        let operatorArguments = 
            [
                data |> Option.map (fun x -> "data", Input x)
            ] |> List.choose id
        new ArgmaxChannel(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type Pick private (operatorArguments) = 
    inherit SymbolOperator("pick", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new Pick(args)
    override this.WithArguments(args : Arguments<Symbol>) = new Pick(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <summary>Picks elements from an input array according to the input indices along the given axis.
    /// 
    /// Given an input array of shape ``(d0, d1)`` and indices of shape ``(i0,)``, the result will be
    /// an output array of shape ``(i0,)`` with::
    /// 
    ///   output[i] = input[i, indices[i]]
    /// 
    /// By default, if any index mentioned is too large, it is replaced by the index that addresses
    /// the last element along an axis (the `clip` mode).
    /// 
    /// This function supports n-dimensional input and (n-1)-dimensional indices arrays.
    /// 
    /// Examples::
    /// 
    ///   x = [[ 1.,  2.],
    ///        [ 3.,  4.],
    ///        [ 5.,  6.]]
    /// 
    ///   // picks elements with specified indices along axis 0
    ///   pick(x, y=[0,1], 0) = [ 1.,  4.]
    /// 
    ///   // picks elements with specified indices along axis 1
    ///   pick(x, y=[0,1,0], 1) = [ 1.,  4.,  5.]
    /// 
    ///   y = [[ 1.],
    ///        [ 0.],
    ///        [ 2.]]
    /// 
    ///   // picks elements with specified indices along axis 1 using &#39;wrap&#39; mode
    ///   // to place indicies that would normally be out of bounds
    ///   pick(x, y=[2,-1,-2], 1, mode=&#39;wrap&#39;) = [ 1.,  4.,  5.]
    /// 
    ///   y = [[ 1.],
    ///        [ 0.],
    ///        [ 2.]]
    /// 
    ///   // picks elements with specified indices along axis 1 and dims are maintained
    ///   pick(x,y, 1, keepdims=True) = [[ 2.],
    ///                                  [ 3.],
    ///                                  [ 6.]]
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\broadcast_reduce_op_index.cc:L155</summary>
    /// <param name="data">The input array</param>
    /// <param name="index">The index array</param>
    /// <param name="axis">int or None. The axis to picking the elements. Negative values means indexing from right to left. If is `None`, the elements in the index w.r.t the flattened input will be picked.</param>
    /// <param name="keepdims">If true, the axis where we pick the elements is left in the result as dimension with size one.</param>
    /// <param name="mode">Specify how out-of-bound indices behave. Default is &quot;clip&quot;. &quot;clip&quot; means clip to the range. So, if all indices mentioned are too large, they are replaced by the index that addresses the last element along an axis.  &quot;wrap&quot; means to wrap around.</param>
    new([<Optional>] ?data : Symbol,
        [<Optional>] ?index : Symbol,
        [<Optional>] ?axis : int,
        [<Optional>] ?keepdims : bool,
        [<Optional>] ?mode : PickMode) = 
        let data = defaultArg data (new ImplicitVariable() :> Symbol)
        let index = defaultArg index (new ImplicitVariable() :> Symbol)
        let operatorArguments = 
            [
                "data", Input data
                "index", Input index
                "axis", axis |> Option.map box |> Parameter
                "keepdims", keepdims |> Option.map box |> Parameter
                "mode", mode |> Option.map box |> Parameter
            ]
        new Pick(Arguments<Symbol>(operatorArguments))
    /// Default value for Axis
    /// int or None. The axis to picking the elements. Negative values means indexing from right to left. If is `None`, the elements in the index w.r.t the flattened input will be picked.
    static member AxisDefault : int option = Some(-1)
    /// Default value for Keepdims
    /// If true, the axis where we pick the elements is left in the result as dimension with size one.
    static member KeepdimsDefault : bool = false
    /// Default value for Mode
    /// Specify how out-of-bound indices behave. Default is &quot;clip&quot;. &quot;clip&quot; means clip to the range. So, if all indices mentioned are too large, they are replaced by the index that addresses the last element along an axis.  &quot;wrap&quot; means to wrap around.
    static member ModeDefault : PickMode = PickMode.Clip
    /// The input array
    member __.Data = operatorArguments.GetInput "data"
    /// The index array
    member __.Index = operatorArguments.GetInput "index"
    /// int or None. The axis to picking the elements. Negative values means indexing from right to left. If is `None`, the elements in the index w.r.t the flattened input will be picked.
    member __.Axis = operatorArguments.GetParameter("axis", Pick.AxisDefault)
    /// If true, the axis where we pick the elements is left in the result as dimension with size one.
    member __.Keepdims = operatorArguments.GetParameter("keepdims", Pick.KeepdimsDefault)
    /// Specify how out-of-bound indices behave. Default is &quot;clip&quot;. &quot;clip&quot; means clip to the range. So, if all indices mentioned are too large, they are replaced by the index that addresses the last element along an axis.  &quot;wrap&quot; means to wrap around.
    member __.Mode = operatorArguments.GetParameter("mode", Pick.ModeDefault)
    /// <summary>Copy Pick instance with updated inputs/parameters.</summary>
    /// <param name="data">The input array</param>
    /// <param name="index">The index array</param>
    /// <param name="axis">int or None. The axis to picking the elements. Negative values means indexing from right to left. If is `None`, the elements in the index w.r.t the flattened input will be picked.</param>
    /// <param name="keepdims">If true, the axis where we pick the elements is left in the result as dimension with size one.</param>
    /// <param name="mode">Specify how out-of-bound indices behave. Default is &quot;clip&quot;. &quot;clip&quot; means clip to the range. So, if all indices mentioned are too large, they are replaced by the index that addresses the last element along an axis.  &quot;wrap&quot; means to wrap around.</param>
    member this.With([<Optional>] ?data : Symbol,
        [<Optional>] ?index : Symbol,
        [<Optional>] ?axis : int,
        [<Optional>] ?keepdims : bool,
        [<Optional>] ?mode : PickMode) = 
        let operatorArguments = 
            [
                data |> Option.map (fun x -> "data", Input x)
                index |> Option.map (fun x -> "index", Input x)
                axis |> Option.map (fun x -> "axis", Parameter(Some (box x)))
                keepdims |> Option.map (fun x -> "keepdims", Parameter(Some (box x)))
                mode |> Option.map (fun x -> "mode", Parameter(Some (box x)))
            ] |> List.choose id
        new Pick(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type BroadcastAxis private (operatorArguments) = 
    inherit SymbolOperator("broadcast_axis", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new BroadcastAxis(args)
    override this.WithArguments(args : Arguments<Symbol>) = new BroadcastAxis(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <summary>Broadcasts the input array over particular axes.
    /// 
    /// Broadcasting is allowed on axes with size 1, such as from `(2,1,3,1)` to
    /// `(2,8,3,9)`. Elements will be duplicated on the broadcasted axes.
    /// 
    /// `broadcast_axes` is an alias to the function `broadcast_axis`.
    /// 
    /// Example::
    /// 
    ///    // given x of shape (1,2,1)
    ///    x = [[[ 1.],
    ///          [ 2.]]]
    /// 
    ///    // broadcast x on on axis 2
    ///    broadcast_axis(x, axis=2, size=3) = [[[ 1.,  1.,  1.],
    ///                                          [ 2.,  2.,  2.]]]
    ///    // broadcast x on on axes 0 and 2
    ///    broadcast_axis(x, axis=(0,2), size=(2,3)) = [[[ 1.,  1.,  1.],
    ///                                                  [ 2.,  2.,  2.]],
    ///                                                 [[ 1.,  1.,  1.],
    ///                                                  [ 2.,  2.,  2.]]]
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\broadcast_reduce_op_value.cc:L58</summary>
    /// <param name="data">The input</param>
    /// <param name="axis">The axes to perform the broadcasting.</param>
    /// <param name="size">Target sizes of the broadcasting axes.</param>
    new([<Optional>] ?data : Symbol,
        [<Optional>] ?axis : int seq,
        [<Optional>] ?size : int seq) = 
        let data = defaultArg data (new ImplicitVariable() :> Symbol)
        let operatorArguments = 
            [
                "data", Input data
                "axis", axis |> Option.map box |> Parameter
                "size", size |> Option.map box |> Parameter
            ]
        new BroadcastAxis(Arguments<Symbol>(operatorArguments))
    /// Default value for Axis
    /// The axes to perform the broadcasting.
    static member AxisDefault : int [] = [||]
    /// Default value for Size
    /// Target sizes of the broadcasting axes.
    static member SizeDefault : int [] = [||]
    /// The input
    member __.Data = operatorArguments.GetInput "data"
    /// The axes to perform the broadcasting.
    member __.Axis = operatorArguments.GetParameter("axis", BroadcastAxis.AxisDefault)
    /// Target sizes of the broadcasting axes.
    member __.Size = operatorArguments.GetParameter("size", BroadcastAxis.SizeDefault)
    /// <summary>Copy BroadcastAxis instance with updated inputs/parameters.</summary>
    /// <param name="data">The input</param>
    /// <param name="axis">The axes to perform the broadcasting.</param>
    /// <param name="size">Target sizes of the broadcasting axes.</param>
    member this.With([<Optional>] ?data : Symbol,
        [<Optional>] ?axis : int seq,
        [<Optional>] ?size : int seq) = 
        let operatorArguments = 
            [
                data |> Option.map (fun x -> "data", Input x)
                axis |> Option.map (fun x -> "axis", Parameter(Some (box x)))
                size |> Option.map (fun x -> "size", Parameter(Some (box x)))
            ] |> List.choose id
        new BroadcastAxis(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type BroadcastTo private (operatorArguments) = 
    inherit SymbolOperator("broadcast_to", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new BroadcastTo(args)
    override this.WithArguments(args : Arguments<Symbol>) = new BroadcastTo(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <summary>Broadcasts the input array to a new shape.
    /// 
    /// Broadcasting is a mechanism that allows NDArrays to perform arithmetic operations
    /// with arrays of different shapes efficiently without creating multiple copies of arrays.
    /// Also see, `Broadcasting &lt;https://docs.scipy.org/doc/numpy/user/basics.broadcasting.html&gt;`_ for more explanation.
    /// 
    /// Broadcasting is allowed on axes with size 1, such as from `(2,1,3,1)` to
    /// `(2,8,3,9)`. Elements will be duplicated on the broadcasted axes.
    /// 
    /// For example::
    /// 
    ///    broadcast_to([[1,2,3]], shape=(2,3)) = [[ 1.,  2.,  3.],
    ///                                            [ 1.,  2.,  3.]])
    /// 
    /// The dimension which you do not want to change can also be kept as `0` which means copy the original value.
    /// So with `shape=(2,0)`, we will obtain the same result as in the above example.
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\broadcast_reduce_op_value.cc:L82</summary>
    /// <param name="data">The input</param>
    /// <param name="shape">The shape of the desired array. We can set the dim to zero if it&#39;s same as the original. E.g `A = broadcast_to(B, shape=(10, 0, 0))` has the same meaning as `A = broadcast_axis(B, axis=0, size=10)`.</param>
    new([<Optional>] ?data : Symbol,
        [<Optional>] ?shape : int seq) = 
        let data = defaultArg data (new ImplicitVariable() :> Symbol)
        let operatorArguments = 
            [
                "data", Input data
                "shape", shape |> Option.map box |> Parameter
            ]
        new BroadcastTo(Arguments<Symbol>(operatorArguments))
    /// Default value for Shape
    /// The shape of the desired array. We can set the dim to zero if it&#39;s same as the original. E.g `A = broadcast_to(B, shape=(10, 0, 0))` has the same meaning as `A = broadcast_axis(B, axis=0, size=10)`.
    static member ShapeDefault : int [] = [||]
    /// The input
    member __.Data = operatorArguments.GetInput "data"
    /// The shape of the desired array. We can set the dim to zero if it&#39;s same as the original. E.g `A = broadcast_to(B, shape=(10, 0, 0))` has the same meaning as `A = broadcast_axis(B, axis=0, size=10)`.
    member __.Shape = operatorArguments.GetParameter("shape", BroadcastTo.ShapeDefault)
    /// <summary>Copy BroadcastTo instance with updated inputs/parameters.</summary>
    /// <param name="data">The input</param>
    /// <param name="shape">The shape of the desired array. We can set the dim to zero if it&#39;s same as the original. E.g `A = broadcast_to(B, shape=(10, 0, 0))` has the same meaning as `A = broadcast_axis(B, axis=0, size=10)`.</param>
    member this.With([<Optional>] ?data : Symbol,
        [<Optional>] ?shape : int seq) = 
        let operatorArguments = 
            [
                data |> Option.map (fun x -> "data", Input x)
                shape |> Option.map (fun x -> "shape", Parameter(Some (box x)))
            ] |> List.choose id
        new BroadcastTo(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type BroadcastBackward private (operatorArguments) = 
    inherit SymbolOperator("_broadcast_backward", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new BroadcastBackward(args)
    override this.WithArguments(args : Arguments<Symbol>) = new BroadcastBackward(this.OperatorArguments.AddReplace(args)) :> Symbol
    new() =
        let operatorArguments = 
            [
            ]
        new BroadcastBackward(Arguments<Symbol>(operatorArguments))

type BroadcastLike private (operatorArguments) = 
    inherit SymbolOperator("broadcast_like", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new BroadcastLike(args)
    override this.WithArguments(args : Arguments<Symbol>) = new BroadcastLike(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <summary>Broadcasts lhs to have the same shape as rhs.
    /// 
    /// Broadcasting is a mechanism that allows NDArrays to perform arithmetic operations
    /// with arrays of different shapes efficiently without creating multiple copies of arrays.
    /// Also see, `Broadcasting &lt;https://docs.scipy.org/doc/numpy/user/basics.broadcasting.html&gt;`_ for more explanation.
    /// 
    /// Broadcasting is allowed on axes with size 1, such as from `(2,1,3,1)` to
    /// `(2,8,3,9)`. Elements will be duplicated on the broadcasted axes.
    /// 
    /// For example::
    /// 
    ///    broadcast_like([[1,2,3]], [[5,6,7],[7,8,9]]) = [[ 1.,  2.,  3.],
    ///                                                    [ 1.,  2.,  3.]])
    /// 
    ///    broadcast_like([9], [1,2,3,4,5], lhs_axes=(0,), rhs_axes=(-1,)) = [9,9,9,9,9]
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\broadcast_reduce_op_value.cc:L135</summary>
    /// <param name="lhs">First input.</param>
    /// <param name="rhs">Second input.</param>
    /// <param name="lhsAxes">Axes to perform broadcast on in the first input array</param>
    /// <param name="rhsAxes">Axes to copy from the second input array</param>
    new([<Optional>] ?lhs : Symbol,
        [<Optional>] ?rhs : Symbol,
        [<Optional>] ?lhsAxes : int seq,
        [<Optional>] ?rhsAxes : int seq) = 
        let lhs = defaultArg lhs (new ImplicitVariable() :> Symbol)
        let rhs = defaultArg rhs (new ImplicitVariable() :> Symbol)
        let operatorArguments = 
            [
                "lhs", Input lhs
                "rhs", Input rhs
                "lhs_axes", lhsAxes |> Option.map box |> Parameter
                "rhs_axes", rhsAxes |> Option.map box |> Parameter
            ]
        new BroadcastLike(Arguments<Symbol>(operatorArguments))
    /// Default value for LhsAxes
    /// Axes to perform broadcast on in the first input array
    static member LhsAxesDefault : int [] option = None
    /// Default value for RhsAxes
    /// Axes to copy from the second input array
    static member RhsAxesDefault : int [] option = None
    /// First input.
    member __.Lhs = operatorArguments.GetInput "lhs"
    /// Second input.
    member __.Rhs = operatorArguments.GetInput "rhs"
    /// Axes to perform broadcast on in the first input array
    member __.LhsAxes = operatorArguments.GetParameter("lhs_axes", BroadcastLike.LhsAxesDefault)
    /// Axes to copy from the second input array
    member __.RhsAxes = operatorArguments.GetParameter("rhs_axes", BroadcastLike.RhsAxesDefault)
    /// <summary>Copy BroadcastLike instance with updated inputs/parameters.</summary>
    /// <param name="lhs">First input.</param>
    /// <param name="rhs">Second input.</param>
    /// <param name="lhsAxes">Axes to perform broadcast on in the first input array</param>
    /// <param name="rhsAxes">Axes to copy from the second input array</param>
    member this.With([<Optional>] ?lhs : Symbol,
        [<Optional>] ?rhs : Symbol,
        [<Optional>] ?lhsAxes : int seq,
        [<Optional>] ?rhsAxes : int seq) = 
        let operatorArguments = 
            [
                lhs |> Option.map (fun x -> "lhs", Input x)
                rhs |> Option.map (fun x -> "rhs", Input x)
                lhsAxes |> Option.map (fun x -> "lhs_axes", Parameter(Some (box x)))
                rhsAxes |> Option.map (fun x -> "rhs_axes", Parameter(Some (box x)))
            ] |> List.choose id
        new BroadcastLike(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type Prod private (operatorArguments) = 
    inherit SymbolOperator("prod", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new Prod(args)
    override this.WithArguments(args : Arguments<Symbol>) = new Prod(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <summary>Computes the product of array elements over given axes.
    /// 
    /// Defined in c:\jenkins\workspace\mxnet\mxnet\src\operator\tensor\./broadcast_reduce_op.h:L31</summary>
    /// <param name="data">The input</param>
    /// <param name="axis">The axis or axes along which to perform the reduction.
    /// 
    ///       The default, `axis=()`, will compute over all elements into a
    ///       scalar array with shape `(1,)`.
    /// 
    ///       If `axis` is int, a reduction is performed on a particular axis.
    /// 
    ///       If `axis` is a tuple of ints, a reduction is performed on all the axes
    ///       specified in the tuple.
    /// 
    ///       If `exclude` is true, reduction will be performed on the axes that are
    ///       NOT in axis instead.
    /// 
    ///       Negative values means indexing from right to left.</param>
    /// <param name="keepdims">If this is set to `True`, the reduced axes are left in the result as dimension with size one.</param>
    /// <param name="exclude">Whether to perform reduction on axis that are NOT in axis instead.</param>
    new([<Optional>] ?data : Symbol,
        [<Optional>] ?axis : int seq,
        [<Optional>] ?keepdims : bool,
        [<Optional>] ?exclude : bool) = 
        let data = defaultArg data (new ImplicitVariable() :> Symbol)
        let operatorArguments = 
            [
                "data", Input data
                "axis", axis |> Option.map box |> Parameter
                "keepdims", keepdims |> Option.map box |> Parameter
                "exclude", exclude |> Option.map box |> Parameter
            ]
        new Prod(Arguments<Symbol>(operatorArguments))
    /// Default value for Axis
    /// The axis or axes along which to perform the reduction.
    /// 
    ///       The default, `axis=()`, will compute over all elements into a
    ///       scalar array with shape `(1,)`.
    /// 
    ///       If `axis` is int, a reduction is performed on a particular axis.
    /// 
    ///       If `axis` is a tuple of ints, a reduction is performed on all the axes
    ///       specified in the tuple.
    /// 
    ///       If `exclude` is true, reduction will be performed on the axes that are
    ///       NOT in axis instead.
    /// 
    ///       Negative values means indexing from right to left.
    static member AxisDefault : int [] option = None
    /// Default value for Keepdims
    /// If this is set to `True`, the reduced axes are left in the result as dimension with size one.
    static member KeepdimsDefault : bool = false
    /// Default value for Exclude
    /// Whether to perform reduction on axis that are NOT in axis instead.
    static member ExcludeDefault : bool = false
    /// The input
    member __.Data = operatorArguments.GetInput "data"
    /// The axis or axes along which to perform the reduction.
    /// 
    ///       The default, `axis=()`, will compute over all elements into a
    ///       scalar array with shape `(1,)`.
    /// 
    ///       If `axis` is int, a reduction is performed on a particular axis.
    /// 
    ///       If `axis` is a tuple of ints, a reduction is performed on all the axes
    ///       specified in the tuple.
    /// 
    ///       If `exclude` is true, reduction will be performed on the axes that are
    ///       NOT in axis instead.
    /// 
    ///       Negative values means indexing from right to left.
    member __.Axis = operatorArguments.GetParameter("axis", Prod.AxisDefault)
    /// If this is set to `True`, the reduced axes are left in the result as dimension with size one.
    member __.Keepdims = operatorArguments.GetParameter("keepdims", Prod.KeepdimsDefault)
    /// Whether to perform reduction on axis that are NOT in axis instead.
    member __.Exclude = operatorArguments.GetParameter("exclude", Prod.ExcludeDefault)
    /// <summary>Copy Prod instance with updated inputs/parameters.</summary>
    /// <param name="data">The input</param>
    /// <param name="axis">The axis or axes along which to perform the reduction.
    /// 
    ///       The default, `axis=()`, will compute over all elements into a
    ///       scalar array with shape `(1,)`.
    /// 
    ///       If `axis` is int, a reduction is performed on a particular axis.
    /// 
    ///       If `axis` is a tuple of ints, a reduction is performed on all the axes
    ///       specified in the tuple.
    /// 
    ///       If `exclude` is true, reduction will be performed on the axes that are
    ///       NOT in axis instead.
    /// 
    ///       Negative values means indexing from right to left.</param>
    /// <param name="keepdims">If this is set to `True`, the reduced axes are left in the result as dimension with size one.</param>
    /// <param name="exclude">Whether to perform reduction on axis that are NOT in axis instead.</param>
    member this.With([<Optional>] ?data : Symbol,
        [<Optional>] ?axis : int seq,
        [<Optional>] ?keepdims : bool,
        [<Optional>] ?exclude : bool) = 
        let operatorArguments = 
            [
                data |> Option.map (fun x -> "data", Input x)
                axis |> Option.map (fun x -> "axis", Parameter(Some (box x)))
                keepdims |> Option.map (fun x -> "keepdims", Parameter(Some (box x)))
                exclude |> Option.map (fun x -> "exclude", Parameter(Some (box x)))
            ] |> List.choose id
        new Prod(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type Nanprod private (operatorArguments) = 
    inherit SymbolOperator("nanprod", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new Nanprod(args)
    override this.WithArguments(args : Arguments<Symbol>) = new Nanprod(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <summary>Computes the product of array elements over given axes treating Not a Numbers (``NaN``) as one.
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\broadcast_reduce_prod_value.cc:L46</summary>
    /// <param name="data">The input</param>
    /// <param name="axis">The axis or axes along which to perform the reduction.
    /// 
    ///       The default, `axis=()`, will compute over all elements into a
    ///       scalar array with shape `(1,)`.
    /// 
    ///       If `axis` is int, a reduction is performed on a particular axis.
    /// 
    ///       If `axis` is a tuple of ints, a reduction is performed on all the axes
    ///       specified in the tuple.
    /// 
    ///       If `exclude` is true, reduction will be performed on the axes that are
    ///       NOT in axis instead.
    /// 
    ///       Negative values means indexing from right to left.</param>
    /// <param name="keepdims">If this is set to `True`, the reduced axes are left in the result as dimension with size one.</param>
    /// <param name="exclude">Whether to perform reduction on axis that are NOT in axis instead.</param>
    new([<Optional>] ?data : Symbol,
        [<Optional>] ?axis : int seq,
        [<Optional>] ?keepdims : bool,
        [<Optional>] ?exclude : bool) = 
        let data = defaultArg data (new ImplicitVariable() :> Symbol)
        let operatorArguments = 
            [
                "data", Input data
                "axis", axis |> Option.map box |> Parameter
                "keepdims", keepdims |> Option.map box |> Parameter
                "exclude", exclude |> Option.map box |> Parameter
            ]
        new Nanprod(Arguments<Symbol>(operatorArguments))
    /// Default value for Axis
    /// The axis or axes along which to perform the reduction.
    /// 
    ///       The default, `axis=()`, will compute over all elements into a
    ///       scalar array with shape `(1,)`.
    /// 
    ///       If `axis` is int, a reduction is performed on a particular axis.
    /// 
    ///       If `axis` is a tuple of ints, a reduction is performed on all the axes
    ///       specified in the tuple.
    /// 
    ///       If `exclude` is true, reduction will be performed on the axes that are
    ///       NOT in axis instead.
    /// 
    ///       Negative values means indexing from right to left.
    static member AxisDefault : int [] option = None
    /// Default value for Keepdims
    /// If this is set to `True`, the reduced axes are left in the result as dimension with size one.
    static member KeepdimsDefault : bool = false
    /// Default value for Exclude
    /// Whether to perform reduction on axis that are NOT in axis instead.
    static member ExcludeDefault : bool = false
    /// The input
    member __.Data = operatorArguments.GetInput "data"
    /// The axis or axes along which to perform the reduction.
    /// 
    ///       The default, `axis=()`, will compute over all elements into a
    ///       scalar array with shape `(1,)`.
    /// 
    ///       If `axis` is int, a reduction is performed on a particular axis.
    /// 
    ///       If `axis` is a tuple of ints, a reduction is performed on all the axes
    ///       specified in the tuple.
    /// 
    ///       If `exclude` is true, reduction will be performed on the axes that are
    ///       NOT in axis instead.
    /// 
    ///       Negative values means indexing from right to left.
    member __.Axis = operatorArguments.GetParameter("axis", Nanprod.AxisDefault)
    /// If this is set to `True`, the reduced axes are left in the result as dimension with size one.
    member __.Keepdims = operatorArguments.GetParameter("keepdims", Nanprod.KeepdimsDefault)
    /// Whether to perform reduction on axis that are NOT in axis instead.
    member __.Exclude = operatorArguments.GetParameter("exclude", Nanprod.ExcludeDefault)
    /// <summary>Copy Nanprod instance with updated inputs/parameters.</summary>
    /// <param name="data">The input</param>
    /// <param name="axis">The axis or axes along which to perform the reduction.
    /// 
    ///       The default, `axis=()`, will compute over all elements into a
    ///       scalar array with shape `(1,)`.
    /// 
    ///       If `axis` is int, a reduction is performed on a particular axis.
    /// 
    ///       If `axis` is a tuple of ints, a reduction is performed on all the axes
    ///       specified in the tuple.
    /// 
    ///       If `exclude` is true, reduction will be performed on the axes that are
    ///       NOT in axis instead.
    /// 
    ///       Negative values means indexing from right to left.</param>
    /// <param name="keepdims">If this is set to `True`, the reduced axes are left in the result as dimension with size one.</param>
    /// <param name="exclude">Whether to perform reduction on axis that are NOT in axis instead.</param>
    member this.With([<Optional>] ?data : Symbol,
        [<Optional>] ?axis : int seq,
        [<Optional>] ?keepdims : bool,
        [<Optional>] ?exclude : bool) = 
        let operatorArguments = 
            [
                data |> Option.map (fun x -> "data", Input x)
                axis |> Option.map (fun x -> "axis", Parameter(Some (box x)))
                keepdims |> Option.map (fun x -> "keepdims", Parameter(Some (box x)))
                exclude |> Option.map (fun x -> "exclude", Parameter(Some (box x)))
            ] |> List.choose id
        new Nanprod(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type Sum private (operatorArguments) = 
    inherit SymbolOperator("sum", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new Sum(args)
    override this.WithArguments(args : Arguments<Symbol>) = new Sum(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <summary>Computes the sum of array elements over given axes.
    /// 
    /// .. Note::
    /// 
    ///   `sum` and `sum_axis` are equivalent.
    ///   For ndarray of csr storage type summation along axis 0 and axis 1 is supported.
    ///   Setting keepdims or exclude to True will cause a fallback to dense operator.
    /// 
    /// Example::
    /// 
    ///   data = [[[1, 2], [2, 3], [1, 3]],
    ///           [[1, 4], [4, 3], [5, 2]],
    ///           [[7, 1], [7, 2], [7, 3]]]
    /// 
    ///   sum(data, axis=1)
    ///   [[  4.   8.]
    ///    [ 10.   9.]
    ///    [ 21.   6.]]
    /// 
    ///   sum(data, axis=[1,2])
    ///   [ 12.  19.  27.]
    /// 
    ///   data = [[1, 2, 0],
    ///           [3, 0, 1],
    ///           [4, 1, 0]]
    /// 
    ///   csr = cast_storage(data, &#39;csr&#39;)
    /// 
    ///   sum(csr, axis=0)
    ///   [ 8.  3.  1.]
    /// 
    ///   sum(csr, axis=1)
    ///   [ 3.  4.  5.]
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\broadcast_reduce_sum_value.cc:L67</summary>
    /// <param name="data">The input</param>
    /// <param name="axis">The axis or axes along which to perform the reduction.
    /// 
    ///       The default, `axis=()`, will compute over all elements into a
    ///       scalar array with shape `(1,)`.
    /// 
    ///       If `axis` is int, a reduction is performed on a particular axis.
    /// 
    ///       If `axis` is a tuple of ints, a reduction is performed on all the axes
    ///       specified in the tuple.
    /// 
    ///       If `exclude` is true, reduction will be performed on the axes that are
    ///       NOT in axis instead.
    /// 
    ///       Negative values means indexing from right to left.</param>
    /// <param name="keepdims">If this is set to `True`, the reduced axes are left in the result as dimension with size one.</param>
    /// <param name="exclude">Whether to perform reduction on axis that are NOT in axis instead.</param>
    new([<Optional>] ?data : Symbol,
        [<Optional>] ?axis : int seq,
        [<Optional>] ?keepdims : bool,
        [<Optional>] ?exclude : bool) = 
        let data = defaultArg data (new ImplicitVariable() :> Symbol)
        let operatorArguments = 
            [
                "data", Input data
                "axis", axis |> Option.map box |> Parameter
                "keepdims", keepdims |> Option.map box |> Parameter
                "exclude", exclude |> Option.map box |> Parameter
            ]
        new Sum(Arguments<Symbol>(operatorArguments))
    /// Default value for Axis
    /// The axis or axes along which to perform the reduction.
    /// 
    ///       The default, `axis=()`, will compute over all elements into a
    ///       scalar array with shape `(1,)`.
    /// 
    ///       If `axis` is int, a reduction is performed on a particular axis.
    /// 
    ///       If `axis` is a tuple of ints, a reduction is performed on all the axes
    ///       specified in the tuple.
    /// 
    ///       If `exclude` is true, reduction will be performed on the axes that are
    ///       NOT in axis instead.
    /// 
    ///       Negative values means indexing from right to left.
    static member AxisDefault : int [] option = None
    /// Default value for Keepdims
    /// If this is set to `True`, the reduced axes are left in the result as dimension with size one.
    static member KeepdimsDefault : bool = false
    /// Default value for Exclude
    /// Whether to perform reduction on axis that are NOT in axis instead.
    static member ExcludeDefault : bool = false
    /// The input
    member __.Data = operatorArguments.GetInput "data"
    /// The axis or axes along which to perform the reduction.
    /// 
    ///       The default, `axis=()`, will compute over all elements into a
    ///       scalar array with shape `(1,)`.
    /// 
    ///       If `axis` is int, a reduction is performed on a particular axis.
    /// 
    ///       If `axis` is a tuple of ints, a reduction is performed on all the axes
    ///       specified in the tuple.
    /// 
    ///       If `exclude` is true, reduction will be performed on the axes that are
    ///       NOT in axis instead.
    /// 
    ///       Negative values means indexing from right to left.
    member __.Axis = operatorArguments.GetParameter("axis", Sum.AxisDefault)
    /// If this is set to `True`, the reduced axes are left in the result as dimension with size one.
    member __.Keepdims = operatorArguments.GetParameter("keepdims", Sum.KeepdimsDefault)
    /// Whether to perform reduction on axis that are NOT in axis instead.
    member __.Exclude = operatorArguments.GetParameter("exclude", Sum.ExcludeDefault)
    /// <summary>Copy Sum instance with updated inputs/parameters.</summary>
    /// <param name="data">The input</param>
    /// <param name="axis">The axis or axes along which to perform the reduction.
    /// 
    ///       The default, `axis=()`, will compute over all elements into a
    ///       scalar array with shape `(1,)`.
    /// 
    ///       If `axis` is int, a reduction is performed on a particular axis.
    /// 
    ///       If `axis` is a tuple of ints, a reduction is performed on all the axes
    ///       specified in the tuple.
    /// 
    ///       If `exclude` is true, reduction will be performed on the axes that are
    ///       NOT in axis instead.
    /// 
    ///       Negative values means indexing from right to left.</param>
    /// <param name="keepdims">If this is set to `True`, the reduced axes are left in the result as dimension with size one.</param>
    /// <param name="exclude">Whether to perform reduction on axis that are NOT in axis instead.</param>
    member this.With([<Optional>] ?data : Symbol,
        [<Optional>] ?axis : int seq,
        [<Optional>] ?keepdims : bool,
        [<Optional>] ?exclude : bool) = 
        let operatorArguments = 
            [
                data |> Option.map (fun x -> "data", Input x)
                axis |> Option.map (fun x -> "axis", Parameter(Some (box x)))
                keepdims |> Option.map (fun x -> "keepdims", Parameter(Some (box x)))
                exclude |> Option.map (fun x -> "exclude", Parameter(Some (box x)))
            ] |> List.choose id
        new Sum(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type Mean private (operatorArguments) = 
    inherit SymbolOperator("mean", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new Mean(args)
    override this.WithArguments(args : Arguments<Symbol>) = new Mean(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <summary>Computes the mean of array elements over given axes.
    /// 
    /// Defined in c:\jenkins\workspace\mxnet\mxnet\src\operator\tensor\./broadcast_reduce_op.h:L83</summary>
    /// <param name="data">The input</param>
    /// <param name="axis">The axis or axes along which to perform the reduction.
    /// 
    ///       The default, `axis=()`, will compute over all elements into a
    ///       scalar array with shape `(1,)`.
    /// 
    ///       If `axis` is int, a reduction is performed on a particular axis.
    /// 
    ///       If `axis` is a tuple of ints, a reduction is performed on all the axes
    ///       specified in the tuple.
    /// 
    ///       If `exclude` is true, reduction will be performed on the axes that are
    ///       NOT in axis instead.
    /// 
    ///       Negative values means indexing from right to left.</param>
    /// <param name="keepdims">If this is set to `True`, the reduced axes are left in the result as dimension with size one.</param>
    /// <param name="exclude">Whether to perform reduction on axis that are NOT in axis instead.</param>
    new([<Optional>] ?data : Symbol,
        [<Optional>] ?axis : int seq,
        [<Optional>] ?keepdims : bool,
        [<Optional>] ?exclude : bool) = 
        let data = defaultArg data (new ImplicitVariable() :> Symbol)
        let operatorArguments = 
            [
                "data", Input data
                "axis", axis |> Option.map box |> Parameter
                "keepdims", keepdims |> Option.map box |> Parameter
                "exclude", exclude |> Option.map box |> Parameter
            ]
        new Mean(Arguments<Symbol>(operatorArguments))
    /// Default value for Axis
    /// The axis or axes along which to perform the reduction.
    /// 
    ///       The default, `axis=()`, will compute over all elements into a
    ///       scalar array with shape `(1,)`.
    /// 
    ///       If `axis` is int, a reduction is performed on a particular axis.
    /// 
    ///       If `axis` is a tuple of ints, a reduction is performed on all the axes
    ///       specified in the tuple.
    /// 
    ///       If `exclude` is true, reduction will be performed on the axes that are
    ///       NOT in axis instead.
    /// 
    ///       Negative values means indexing from right to left.
    static member AxisDefault : int [] option = None
    /// Default value for Keepdims
    /// If this is set to `True`, the reduced axes are left in the result as dimension with size one.
    static member KeepdimsDefault : bool = false
    /// Default value for Exclude
    /// Whether to perform reduction on axis that are NOT in axis instead.
    static member ExcludeDefault : bool = false
    /// The input
    member __.Data = operatorArguments.GetInput "data"
    /// The axis or axes along which to perform the reduction.
    /// 
    ///       The default, `axis=()`, will compute over all elements into a
    ///       scalar array with shape `(1,)`.
    /// 
    ///       If `axis` is int, a reduction is performed on a particular axis.
    /// 
    ///       If `axis` is a tuple of ints, a reduction is performed on all the axes
    ///       specified in the tuple.
    /// 
    ///       If `exclude` is true, reduction will be performed on the axes that are
    ///       NOT in axis instead.
    /// 
    ///       Negative values means indexing from right to left.
    member __.Axis = operatorArguments.GetParameter("axis", Mean.AxisDefault)
    /// If this is set to `True`, the reduced axes are left in the result as dimension with size one.
    member __.Keepdims = operatorArguments.GetParameter("keepdims", Mean.KeepdimsDefault)
    /// Whether to perform reduction on axis that are NOT in axis instead.
    member __.Exclude = operatorArguments.GetParameter("exclude", Mean.ExcludeDefault)
    /// <summary>Copy Mean instance with updated inputs/parameters.</summary>
    /// <param name="data">The input</param>
    /// <param name="axis">The axis or axes along which to perform the reduction.
    /// 
    ///       The default, `axis=()`, will compute over all elements into a
    ///       scalar array with shape `(1,)`.
    /// 
    ///       If `axis` is int, a reduction is performed on a particular axis.
    /// 
    ///       If `axis` is a tuple of ints, a reduction is performed on all the axes
    ///       specified in the tuple.
    /// 
    ///       If `exclude` is true, reduction will be performed on the axes that are
    ///       NOT in axis instead.
    /// 
    ///       Negative values means indexing from right to left.</param>
    /// <param name="keepdims">If this is set to `True`, the reduced axes are left in the result as dimension with size one.</param>
    /// <param name="exclude">Whether to perform reduction on axis that are NOT in axis instead.</param>
    member this.With([<Optional>] ?data : Symbol,
        [<Optional>] ?axis : int seq,
        [<Optional>] ?keepdims : bool,
        [<Optional>] ?exclude : bool) = 
        let operatorArguments = 
            [
                data |> Option.map (fun x -> "data", Input x)
                axis |> Option.map (fun x -> "axis", Parameter(Some (box x)))
                keepdims |> Option.map (fun x -> "keepdims", Parameter(Some (box x)))
                exclude |> Option.map (fun x -> "exclude", Parameter(Some (box x)))
            ] |> List.choose id
        new Mean(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type Nansum private (operatorArguments) = 
    inherit SymbolOperator("nansum", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new Nansum(args)
    override this.WithArguments(args : Arguments<Symbol>) = new Nansum(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <summary>Computes the sum of array elements over given axes treating Not a Numbers (``NaN``) as zero.
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\broadcast_reduce_sum_value.cc:L100</summary>
    /// <param name="data">The input</param>
    /// <param name="axis">The axis or axes along which to perform the reduction.
    /// 
    ///       The default, `axis=()`, will compute over all elements into a
    ///       scalar array with shape `(1,)`.
    /// 
    ///       If `axis` is int, a reduction is performed on a particular axis.
    /// 
    ///       If `axis` is a tuple of ints, a reduction is performed on all the axes
    ///       specified in the tuple.
    /// 
    ///       If `exclude` is true, reduction will be performed on the axes that are
    ///       NOT in axis instead.
    /// 
    ///       Negative values means indexing from right to left.</param>
    /// <param name="keepdims">If this is set to `True`, the reduced axes are left in the result as dimension with size one.</param>
    /// <param name="exclude">Whether to perform reduction on axis that are NOT in axis instead.</param>
    new([<Optional>] ?data : Symbol,
        [<Optional>] ?axis : int seq,
        [<Optional>] ?keepdims : bool,
        [<Optional>] ?exclude : bool) = 
        let data = defaultArg data (new ImplicitVariable() :> Symbol)
        let operatorArguments = 
            [
                "data", Input data
                "axis", axis |> Option.map box |> Parameter
                "keepdims", keepdims |> Option.map box |> Parameter
                "exclude", exclude |> Option.map box |> Parameter
            ]
        new Nansum(Arguments<Symbol>(operatorArguments))
    /// Default value for Axis
    /// The axis or axes along which to perform the reduction.
    /// 
    ///       The default, `axis=()`, will compute over all elements into a
    ///       scalar array with shape `(1,)`.
    /// 
    ///       If `axis` is int, a reduction is performed on a particular axis.
    /// 
    ///       If `axis` is a tuple of ints, a reduction is performed on all the axes
    ///       specified in the tuple.
    /// 
    ///       If `exclude` is true, reduction will be performed on the axes that are
    ///       NOT in axis instead.
    /// 
    ///       Negative values means indexing from right to left.
    static member AxisDefault : int [] option = None
    /// Default value for Keepdims
    /// If this is set to `True`, the reduced axes are left in the result as dimension with size one.
    static member KeepdimsDefault : bool = false
    /// Default value for Exclude
    /// Whether to perform reduction on axis that are NOT in axis instead.
    static member ExcludeDefault : bool = false
    /// The input
    member __.Data = operatorArguments.GetInput "data"
    /// The axis or axes along which to perform the reduction.
    /// 
    ///       The default, `axis=()`, will compute over all elements into a
    ///       scalar array with shape `(1,)`.
    /// 
    ///       If `axis` is int, a reduction is performed on a particular axis.
    /// 
    ///       If `axis` is a tuple of ints, a reduction is performed on all the axes
    ///       specified in the tuple.
    /// 
    ///       If `exclude` is true, reduction will be performed on the axes that are
    ///       NOT in axis instead.
    /// 
    ///       Negative values means indexing from right to left.
    member __.Axis = operatorArguments.GetParameter("axis", Nansum.AxisDefault)
    /// If this is set to `True`, the reduced axes are left in the result as dimension with size one.
    member __.Keepdims = operatorArguments.GetParameter("keepdims", Nansum.KeepdimsDefault)
    /// Whether to perform reduction on axis that are NOT in axis instead.
    member __.Exclude = operatorArguments.GetParameter("exclude", Nansum.ExcludeDefault)
    /// <summary>Copy Nansum instance with updated inputs/parameters.</summary>
    /// <param name="data">The input</param>
    /// <param name="axis">The axis or axes along which to perform the reduction.
    /// 
    ///       The default, `axis=()`, will compute over all elements into a
    ///       scalar array with shape `(1,)`.
    /// 
    ///       If `axis` is int, a reduction is performed on a particular axis.
    /// 
    ///       If `axis` is a tuple of ints, a reduction is performed on all the axes
    ///       specified in the tuple.
    /// 
    ///       If `exclude` is true, reduction will be performed on the axes that are
    ///       NOT in axis instead.
    /// 
    ///       Negative values means indexing from right to left.</param>
    /// <param name="keepdims">If this is set to `True`, the reduced axes are left in the result as dimension with size one.</param>
    /// <param name="exclude">Whether to perform reduction on axis that are NOT in axis instead.</param>
    member this.With([<Optional>] ?data : Symbol,
        [<Optional>] ?axis : int seq,
        [<Optional>] ?keepdims : bool,
        [<Optional>] ?exclude : bool) = 
        let operatorArguments = 
            [
                data |> Option.map (fun x -> "data", Input x)
                axis |> Option.map (fun x -> "axis", Parameter(Some (box x)))
                keepdims |> Option.map (fun x -> "keepdims", Parameter(Some (box x)))
                exclude |> Option.map (fun x -> "exclude", Parameter(Some (box x)))
            ] |> List.choose id
        new Nansum(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type CastStorage private (operatorArguments) = 
    inherit SymbolOperator("cast_storage", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new CastStorage(args)
    override this.WithArguments(args : Arguments<Symbol>) = new CastStorage(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <summary>Casts tensor storage type to the new type.
    /// 
    /// When an NDArray with default storage type is cast to csr or row_sparse storage,
    /// the result is compact, which means:
    /// 
    /// - for csr, zero values will not be retained
    /// - for row_sparse, row slices of all zeros will not be retained
    /// 
    /// The storage type of ``cast_storage`` output depends on stype parameter:
    /// 
    /// - cast_storage(csr, &#39;default&#39;) = default
    /// - cast_storage(row_sparse, &#39;default&#39;) = default
    /// - cast_storage(default, &#39;csr&#39;) = csr
    /// - cast_storage(default, &#39;row_sparse&#39;) = row_sparse
    /// - cast_storage(csr, &#39;csr&#39;) = csr
    /// - cast_storage(row_sparse, &#39;row_sparse&#39;) = row_sparse
    /// 
    /// Example::
    /// 
    ///     dense = [[ 0.,  1.,  0.],
    ///              [ 2.,  0.,  3.],
    ///              [ 0.,  0.,  0.],
    ///              [ 0.,  0.,  0.]]
    /// 
    ///     # cast to row_sparse storage type
    ///     rsp = cast_storage(dense, &#39;row_sparse&#39;)
    ///     rsp.indices = [0, 1]
    ///     rsp.values = [[ 0.,  1.,  0.],
    ///                   [ 2.,  0.,  3.]]
    /// 
    ///     # cast to csr storage type
    ///     csr = cast_storage(dense, &#39;csr&#39;)
    ///     csr.indices = [1, 0, 2]
    ///     csr.values = [ 1.,  2.,  3.]
    ///     csr.indptr = [0, 1, 3, 3, 3]
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\cast_storage.cc:L71</summary>
    /// <param name="data">The input.</param>
    /// <param name="stype">Output storage type.</param>
    new(data : Symbol,
        stype : Stype) = 
        let operatorArguments = 
            [
                "data", Input data
                "stype", Parameter(Some(box stype))
            ]
        new CastStorage(Arguments<Symbol>(operatorArguments))
    /// <summary>Casts tensor storage type to the new type.
    /// 
    /// When an NDArray with default storage type is cast to csr or row_sparse storage,
    /// the result is compact, which means:
    /// 
    /// - for csr, zero values will not be retained
    /// - for row_sparse, row slices of all zeros will not be retained
    /// 
    /// The storage type of ``cast_storage`` output depends on stype parameter:
    /// 
    /// - cast_storage(csr, &#39;default&#39;) = default
    /// - cast_storage(row_sparse, &#39;default&#39;) = default
    /// - cast_storage(default, &#39;csr&#39;) = csr
    /// - cast_storage(default, &#39;row_sparse&#39;) = row_sparse
    /// - cast_storage(csr, &#39;csr&#39;) = csr
    /// - cast_storage(row_sparse, &#39;row_sparse&#39;) = row_sparse
    /// 
    /// Example::
    /// 
    ///     dense = [[ 0.,  1.,  0.],
    ///              [ 2.,  0.,  3.],
    ///              [ 0.,  0.,  0.],
    ///              [ 0.,  0.,  0.]]
    /// 
    ///     # cast to row_sparse storage type
    ///     rsp = cast_storage(dense, &#39;row_sparse&#39;)
    ///     rsp.indices = [0, 1]
    ///     rsp.values = [[ 0.,  1.,  0.],
    ///                   [ 2.,  0.,  3.]]
    /// 
    ///     # cast to csr storage type
    ///     csr = cast_storage(dense, &#39;csr&#39;)
    ///     csr.indices = [1, 0, 2]
    ///     csr.values = [ 1.,  2.,  3.]
    ///     csr.indptr = [0, 1, 3, 3, 3]
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\cast_storage.cc:L71</summary>
    /// <param name="stype">Output storage type.</param>
    /// <param name="data">The input.</param>
    new(stype : Stype,
        [<Optional>] ?data : Symbol) = 
        let data = defaultArg data (new ImplicitVariable() :> Symbol)
        let operatorArguments = 
            [
                "data", Input data
                "stype", Parameter(Some(box stype))
            ]
        new CastStorage(Arguments<Symbol>(operatorArguments))
    /// The input.
    member __.Data = operatorArguments.GetInput "data"
    /// Output storage type.
    member __.Stype : Stype = match operatorArguments.GetParameter "stype" with Some(v) -> unbox v | None -> failwithf "Required parameter stype is missing"
    /// <summary>Copy CastStorage instance with updated inputs/parameters.</summary>
    /// <param name="data">The input.</param>
    /// <param name="stype">Output storage type.</param>
    member this.With([<Optional>] ?data : Symbol,
        [<Optional>] ?stype : Stype) = 
        let operatorArguments = 
            [
                data |> Option.map (fun x -> "data", Input x)
                stype |> Option.map (fun x -> "stype", Parameter(Some (box x)))
            ] |> List.choose id
        new CastStorage(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type Where private (operatorArguments) = 
    inherit SymbolOperator("where", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new Where(args)
    override this.WithArguments(args : Arguments<Symbol>) = new Where(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <summary>Return the elements, either from x or y, depending on the condition.
    /// 
    /// Given three ndarrays, condition, x, and y, return an ndarray with the elements from x or y,
    /// depending on the elements from condition are true or false. x and y must have the same shape.
    /// If condition has the same shape as x, each element in the output array is from x if the
    /// corresponding element in the condition is true, and from y if false.
    /// 
    /// If condition does not have the same shape as x, it must be a 1D array whose size is
    /// the same as x&#39;s first dimension size. Each row of the output array is from x&#39;s row
    /// if the corresponding element from condition is true, and from y&#39;s row if false.
    /// 
    /// Note that all non-zero values are interpreted as ``True`` in condition.
    /// 
    /// Examples::
    /// 
    ///   x = [[1, 2], [3, 4]]
    ///   y = [[5, 6], [7, 8]]
    ///   cond = [[0, 1], [-1, 0]]
    /// 
    ///   where(cond, x, y) = [[5, 2], [3, 8]]
    /// 
    ///   csr_cond = cast_storage(cond, &#39;csr&#39;)
    /// 
    ///   where(csr_cond, x, y) = [[5, 2], [3, 8]]
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\control_flow_op.cc:L57</summary>
    /// <param name="condition">condition array</param>
    /// <param name="x"></param>
    /// <param name="y"></param>
    new([<Optional>] ?condition : Symbol,
        [<Optional>] ?x : Symbol,
        [<Optional>] ?y : Symbol) = 
        let condition = defaultArg condition (new ImplicitVariable() :> Symbol)
        let x = defaultArg x (new ImplicitVariable() :> Symbol)
        let y = defaultArg y (new ImplicitVariable() :> Symbol)
        let operatorArguments = 
            [
                "condition", Input condition
                "x", Input x
                "y", Input y
            ]
        new Where(Arguments<Symbol>(operatorArguments))
    /// condition array
    member __.Condition = operatorArguments.GetInput "condition"
    /// 
    member __.X = operatorArguments.GetInput "x"
    /// 
    member __.Y = operatorArguments.GetInput "y"
    /// <summary>Copy Where instance with updated inputs/parameters.</summary>
    /// <param name="condition">condition array</param>
    /// <param name="x"></param>
    /// <param name="y"></param>
    member this.With([<Optional>] ?condition : Symbol,
        [<Optional>] ?x : Symbol,
        [<Optional>] ?y : Symbol) = 
        let operatorArguments = 
            [
                condition |> Option.map (fun x -> "condition", Input x)
                x |> Option.map (fun x -> "x", Input x)
                y |> Option.map (fun x -> "y", Input x)
            ] |> List.choose id
        new Where(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type Diag private (operatorArguments) = 
    inherit SymbolOperator("diag", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new Diag(args)
    override this.WithArguments(args : Arguments<Symbol>) = new Diag(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <summary>Extracts a diagonal or constructs a diagonal array.
    /// 
    /// ``diag``&#39;s behavior depends on the input array dimensions:
    /// 
    /// - 1-D arrays: constructs a 2-D array with the input as its diagonal, all other elements are zero.
    /// - N-D arrays: extracts the diagonals of the sub-arrays with axes specified by ``axis1`` and ``axis2``.
    ///   The output shape would be decided by removing the axes numbered ``axis1`` and ``axis2`` from the
    ///   input shape and appending to the result a new axis with the size of the diagonals in question.
    /// 
    ///   For example, when the input shape is `(2, 3, 4, 5)`, ``axis1`` and ``axis2`` are 0 and 2
    ///   respectively and ``k`` is 0, the resulting shape would be `(3, 5, 2)`.
    /// 
    /// Examples::
    /// 
    ///   x = [[1, 2, 3],
    ///        [4, 5, 6]]
    /// 
    ///   diag(x) = [1, 5]
    /// 
    ///   diag(x, k=1) = [2, 6]
    /// 
    ///   diag(x, k=-1) = [4]
    /// 
    ///   x = [1, 2, 3]
    /// 
    ///   diag(x) = [[1, 0, 0],
    ///              [0, 2, 0],
    ///              [0, 0, 3]]
    /// 
    ///   diag(x, k=1) = [[0, 1, 0],
    ///                   [0, 0, 2],
    ///                   [0, 0, 0]]
    /// 
    ///   diag(x, k=-1) = [[0, 0, 0],
    ///                    [1, 0, 0],
    ///                    [0, 2, 0]]
    /// 
    ///   x = [[[1, 2],
    ///         [3, 4]],
    /// 
    ///        [[5, 6],
    ///         [7, 8]]]
    /// 
    ///   diag(x) = [[1, 7],
    ///              [2, 8]]
    /// 
    ///   diag(x, k=1) = [[3],
    ///                   [4]]
    /// 
    ///   diag(x, axis1=-2, axis2=-1) = [[1, 4],
    ///                                  [5, 8]]
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\diag_op.cc:L87</summary>
    /// <param name="data">Input ndarray</param>
    /// <param name="k">Diagonal in question. The default is 0. Use k&gt;0 for diagonals above the main diagonal, and k&lt;0 for diagonals below the main diagonal. If input has shape (S0 S1) k must be between -S0 and S1</param>
    /// <param name="axis1">The first axis of the sub-arrays of interest. Ignored when the input is a 1-D array.</param>
    /// <param name="axis2">The second axis of the sub-arrays of interest. Ignored when the input is a 1-D array.</param>
    new([<Optional>] ?data : Symbol,
        [<Optional>] ?k : int,
        [<Optional>] ?axis1 : int,
        [<Optional>] ?axis2 : int) = 
        let data = defaultArg data (new ImplicitVariable() :> Symbol)
        let operatorArguments = 
            [
                "data", Input data
                "k", k |> Option.map box |> Parameter
                "axis1", axis1 |> Option.map box |> Parameter
                "axis2", axis2 |> Option.map box |> Parameter
            ]
        new Diag(Arguments<Symbol>(operatorArguments))
    /// Default value for K
    /// Diagonal in question. The default is 0. Use k&gt;0 for diagonals above the main diagonal, and k&lt;0 for diagonals below the main diagonal. If input has shape (S0 S1) k must be between -S0 and S1
    static member KDefault : int = 0
    /// Default value for Axis1
    /// The first axis of the sub-arrays of interest. Ignored when the input is a 1-D array.
    static member Axis1Default : int = 0
    /// Default value for Axis2
    /// The second axis of the sub-arrays of interest. Ignored when the input is a 1-D array.
    static member Axis2Default : int = 1
    /// Input ndarray
    member __.Data = operatorArguments.GetInput "data"
    /// Diagonal in question. The default is 0. Use k&gt;0 for diagonals above the main diagonal, and k&lt;0 for diagonals below the main diagonal. If input has shape (S0 S1) k must be between -S0 and S1
    member __.K = operatorArguments.GetParameter("k", Diag.KDefault)
    /// The first axis of the sub-arrays of interest. Ignored when the input is a 1-D array.
    member __.Axis1 = operatorArguments.GetParameter("axis1", Diag.Axis1Default)
    /// The second axis of the sub-arrays of interest. Ignored when the input is a 1-D array.
    member __.Axis2 = operatorArguments.GetParameter("axis2", Diag.Axis2Default)
    /// <summary>Copy Diag instance with updated inputs/parameters.</summary>
    /// <param name="data">Input ndarray</param>
    /// <param name="k">Diagonal in question. The default is 0. Use k&gt;0 for diagonals above the main diagonal, and k&lt;0 for diagonals below the main diagonal. If input has shape (S0 S1) k must be between -S0 and S1</param>
    /// <param name="axis1">The first axis of the sub-arrays of interest. Ignored when the input is a 1-D array.</param>
    /// <param name="axis2">The second axis of the sub-arrays of interest. Ignored when the input is a 1-D array.</param>
    member this.With([<Optional>] ?data : Symbol,
        [<Optional>] ?k : int,
        [<Optional>] ?axis1 : int,
        [<Optional>] ?axis2 : int) = 
        let operatorArguments = 
            [
                data |> Option.map (fun x -> "data", Input x)
                k |> Option.map (fun x -> "k", Parameter(Some (box x)))
                axis1 |> Option.map (fun x -> "axis1", Parameter(Some (box x)))
                axis2 |> Option.map (fun x -> "axis2", Parameter(Some (box x)))
            ] |> List.choose id
        new Diag(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type Dot private (operatorArguments) = 
    inherit SymbolOperator("dot", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new Dot(args)
    override this.WithArguments(args : Arguments<Symbol>) = new Dot(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <summary>Dot product of two arrays.
    /// 
    /// ``dot``&#39;s behavior depends on the input array dimensions:
    /// 
    /// - 1-D arrays: inner product of vectors
    /// - 2-D arrays: matrix multiplication
    /// - N-D arrays: a sum product over the last axis of the first input and the first
    ///   axis of the second input
    /// 
    ///   For example, given 3-D ``x`` with shape `(n,m,k)` and ``y`` with shape `(k,r,s)`, the
    ///   result array will have shape `(n,m,r,s)`. It is computed by::
    /// 
    ///     dot(x,y)[i,j,a,b] = sum(x[i,j,:]*y[:,a,b])
    /// 
    ///   Example::
    /// 
    ///     x = reshape([0,1,2,3,4,5,6,7], shape=(2,2,2))
    ///     y = reshape([7,6,5,4,3,2,1,0], shape=(2,2,2))
    ///     dot(x,y)[0,0,1,1] = 0
    ///     sum(x[0,0,:]*y[:,1,1]) = 0
    /// 
    /// The storage type of ``dot`` output depends on storage types of inputs, transpose option and
    /// forward_stype option for output storage type. Implemented sparse operations include:
    /// 
    /// - dot(default, default, transpose_a=True/False, transpose_b=True/False) = default
    /// - dot(csr, default, transpose_a=True) = default
    /// - dot(csr, default, transpose_a=True) = row_sparse
    /// - dot(csr, default) = default
    /// - dot(csr, row_sparse) = default
    /// - dot(default, csr) = csr (CPU only)
    /// - dot(default, csr, forward_stype=&#39;default&#39;) = default
    /// - dot(default, csr, transpose_b=True, forward_stype=&#39;default&#39;) = default
    /// 
    /// If the combination of input storage types and forward_stype does not match any of the
    /// above patterns, ``dot`` will fallback and generate output with default storage.
    /// 
    /// .. Note::
    /// 
    ///     If the storage type of the lhs is &quot;csr&quot;, the storage type of gradient w.r.t rhs will be
    ///     &quot;row_sparse&quot;. Only a subset of optimizers support sparse gradients, including SGD, AdaGrad
    ///     and Adam. Note that by default lazy updates is turned on, which may perform differently
    ///     from standard updates. For more details, please check the Optimization API at:
    ///     https://mxnet.incubator.apache.org/api/python/optimization/optimization.html
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\dot.cc:L77</summary>
    /// <param name="lhs">The first input</param>
    /// <param name="rhs">The second input</param>
    /// <param name="transposeA">If true then transpose the first input before dot.</param>
    /// <param name="transposeB">If true then transpose the second input before dot.</param>
    /// <param name="forwardStype">The desired storage type of the forward output given by user, if thecombination of input storage types and this hint does not matchany implemented ones, the dot operator will perform fallback operationand still produce an output of the desired storage type.</param>
    new([<Optional>] ?lhs : Symbol,
        [<Optional>] ?rhs : Symbol,
        [<Optional>] ?transposeA : bool,
        [<Optional>] ?transposeB : bool,
        [<Optional>] ?forwardStype : ForwardStype) = 
        let lhs = defaultArg lhs (new ImplicitVariable() :> Symbol)
        let rhs = defaultArg rhs (new ImplicitVariable() :> Symbol)
        let operatorArguments = 
            [
                "lhs", Input lhs
                "rhs", Input rhs
                "transpose_a", transposeA |> Option.map box |> Parameter
                "transpose_b", transposeB |> Option.map box |> Parameter
                "forward_stype", forwardStype |> Option.map box |> Parameter
            ]
        new Dot(Arguments<Symbol>(operatorArguments))
    /// Default value for TransposeA
    /// If true then transpose the first input before dot.
    static member TransposeADefault : bool = false
    /// Default value for TransposeB
    /// If true then transpose the second input before dot.
    static member TransposeBDefault : bool = false
    /// Default value for ForwardStype
    /// The desired storage type of the forward output given by user, if thecombination of input storage types and this hint does not matchany implemented ones, the dot operator will perform fallback operationand still produce an output of the desired storage type.
    static member ForwardStypeDefault : ForwardStype option = None
    /// The first input
    member __.Lhs = operatorArguments.GetInput "lhs"
    /// The second input
    member __.Rhs = operatorArguments.GetInput "rhs"
    /// If true then transpose the first input before dot.
    member __.TransposeA = operatorArguments.GetParameter("transpose_a", Dot.TransposeADefault)
    /// If true then transpose the second input before dot.
    member __.TransposeB = operatorArguments.GetParameter("transpose_b", Dot.TransposeBDefault)
    /// The desired storage type of the forward output given by user, if thecombination of input storage types and this hint does not matchany implemented ones, the dot operator will perform fallback operationand still produce an output of the desired storage type.
    member __.ForwardStype = operatorArguments.GetParameter("forward_stype", Dot.ForwardStypeDefault)
    /// <summary>Copy Dot instance with updated inputs/parameters.</summary>
    /// <param name="lhs">The first input</param>
    /// <param name="rhs">The second input</param>
    /// <param name="transposeA">If true then transpose the first input before dot.</param>
    /// <param name="transposeB">If true then transpose the second input before dot.</param>
    /// <param name="forwardStype">The desired storage type of the forward output given by user, if thecombination of input storage types and this hint does not matchany implemented ones, the dot operator will perform fallback operationand still produce an output of the desired storage type.</param>
    member this.With([<Optional>] ?lhs : Symbol,
        [<Optional>] ?rhs : Symbol,
        [<Optional>] ?transposeA : bool,
        [<Optional>] ?transposeB : bool,
        [<Optional>] ?forwardStype : ForwardStype) = 
        let operatorArguments = 
            [
                lhs |> Option.map (fun x -> "lhs", Input x)
                rhs |> Option.map (fun x -> "rhs", Input x)
                transposeA |> Option.map (fun x -> "transpose_a", Parameter(Some (box x)))
                transposeB |> Option.map (fun x -> "transpose_b", Parameter(Some (box x)))
                forwardStype |> Option.map (fun x -> "forward_stype", Parameter(Some (box x)))
            ] |> List.choose id
        new Dot(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type BatchDot private (operatorArguments) = 
    inherit SymbolOperator("batch_dot", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new BatchDot(args)
    override this.WithArguments(args : Arguments<Symbol>) = new BatchDot(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <summary>Batchwise dot product.
    /// 
    /// ``batch_dot`` is used to compute dot product of ``x`` and ``y`` when ``x`` and
    /// ``y`` are data in batch, namely 3D arrays in shape of `(batch_size, :, :)`.
    /// 
    /// For example, given ``x`` with shape `(batch_size, n, m)` and ``y`` with shape
    /// `(batch_size, m, k)`, the result array will have shape `(batch_size, n, k)`,
    /// which is computed by::
    /// 
    ///    batch_dot(x,y)[i,:,:] = dot(x[i,:,:], y[i,:,:])
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\dot.cc:L126</summary>
    /// <param name="lhs">The first input</param>
    /// <param name="rhs">The second input</param>
    /// <param name="transposeA">If true then transpose the first input before dot.</param>
    /// <param name="transposeB">If true then transpose the second input before dot.</param>
    /// <param name="forwardStype">The desired storage type of the forward output given by user, if thecombination of input storage types and this hint does not matchany implemented ones, the dot operator will perform fallback operationand still produce an output of the desired storage type.</param>
    new([<Optional>] ?lhs : Symbol,
        [<Optional>] ?rhs : Symbol,
        [<Optional>] ?transposeA : bool,
        [<Optional>] ?transposeB : bool,
        [<Optional>] ?forwardStype : ForwardStype) = 
        let lhs = defaultArg lhs (new ImplicitVariable() :> Symbol)
        let rhs = defaultArg rhs (new ImplicitVariable() :> Symbol)
        let operatorArguments = 
            [
                "lhs", Input lhs
                "rhs", Input rhs
                "transpose_a", transposeA |> Option.map box |> Parameter
                "transpose_b", transposeB |> Option.map box |> Parameter
                "forward_stype", forwardStype |> Option.map box |> Parameter
            ]
        new BatchDot(Arguments<Symbol>(operatorArguments))
    /// Default value for TransposeA
    /// If true then transpose the first input before dot.
    static member TransposeADefault : bool = false
    /// Default value for TransposeB
    /// If true then transpose the second input before dot.
    static member TransposeBDefault : bool = false
    /// Default value for ForwardStype
    /// The desired storage type of the forward output given by user, if thecombination of input storage types and this hint does not matchany implemented ones, the dot operator will perform fallback operationand still produce an output of the desired storage type.
    static member ForwardStypeDefault : ForwardStype option = None
    /// The first input
    member __.Lhs = operatorArguments.GetInput "lhs"
    /// The second input
    member __.Rhs = operatorArguments.GetInput "rhs"
    /// If true then transpose the first input before dot.
    member __.TransposeA = operatorArguments.GetParameter("transpose_a", BatchDot.TransposeADefault)
    /// If true then transpose the second input before dot.
    member __.TransposeB = operatorArguments.GetParameter("transpose_b", BatchDot.TransposeBDefault)
    /// The desired storage type of the forward output given by user, if thecombination of input storage types and this hint does not matchany implemented ones, the dot operator will perform fallback operationand still produce an output of the desired storage type.
    member __.ForwardStype = operatorArguments.GetParameter("forward_stype", BatchDot.ForwardStypeDefault)
    /// <summary>Copy BatchDot instance with updated inputs/parameters.</summary>
    /// <param name="lhs">The first input</param>
    /// <param name="rhs">The second input</param>
    /// <param name="transposeA">If true then transpose the first input before dot.</param>
    /// <param name="transposeB">If true then transpose the second input before dot.</param>
    /// <param name="forwardStype">The desired storage type of the forward output given by user, if thecombination of input storage types and this hint does not matchany implemented ones, the dot operator will perform fallback operationand still produce an output of the desired storage type.</param>
    member this.With([<Optional>] ?lhs : Symbol,
        [<Optional>] ?rhs : Symbol,
        [<Optional>] ?transposeA : bool,
        [<Optional>] ?transposeB : bool,
        [<Optional>] ?forwardStype : ForwardStype) = 
        let operatorArguments = 
            [
                lhs |> Option.map (fun x -> "lhs", Input x)
                rhs |> Option.map (fun x -> "rhs", Input x)
                transposeA |> Option.map (fun x -> "transpose_a", Parameter(Some (box x)))
                transposeB |> Option.map (fun x -> "transpose_b", Parameter(Some (box x)))
                forwardStype |> Option.map (fun x -> "forward_stype", Parameter(Some (box x)))
            ] |> List.choose id
        new BatchDot(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type BroadcastAdd private (operatorArguments) = 
    inherit SymbolOperator("broadcast_add", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new BroadcastAdd(args)
    override this.WithArguments(args : Arguments<Symbol>) = new BroadcastAdd(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <summary>Returns element-wise sum of the input arrays with broadcasting.
    /// 
    /// `broadcast_plus` is an alias to the function `broadcast_add`.
    /// 
    /// Example::
    /// 
    ///    x = [[ 1.,  1.,  1.],
    ///         [ 1.,  1.,  1.]]
    /// 
    ///    y = [[ 0.],
    ///         [ 1.]]
    /// 
    ///    broadcast_add(x, y) = [[ 1.,  1.,  1.],
    ///                           [ 2.,  2.,  2.]]
    /// 
    ///    broadcast_plus(x, y) = [[ 1.,  1.,  1.],
    ///                            [ 2.,  2.,  2.]]
    /// 
    /// Supported sparse operations:
    /// 
    ///    broadcast_add(csr, dense(1D)) = dense
    ///    broadcast_add(dense(1D), csr) = dense
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\elemwise_binary_broadcast_op_basic.cc:L58</summary>
    /// <param name="lhs">First input to the function</param>
    /// <param name="rhs">Second input to the function</param>
    new([<Optional>] ?lhs : Symbol,
        [<Optional>] ?rhs : Symbol) = 
        let lhs = defaultArg lhs (new ImplicitVariable() :> Symbol)
        let rhs = defaultArg rhs (new ImplicitVariable() :> Symbol)
        let operatorArguments = 
            [
                "lhs", Input lhs
                "rhs", Input rhs
            ]
        new BroadcastAdd(Arguments<Symbol>(operatorArguments))
    /// First input to the function
    member __.Lhs = operatorArguments.GetInput "lhs"
    /// Second input to the function
    member __.Rhs = operatorArguments.GetInput "rhs"
    /// <summary>Copy BroadcastAdd instance with updated inputs/parameters.</summary>
    /// <param name="lhs">First input to the function</param>
    /// <param name="rhs">Second input to the function</param>
    member this.With([<Optional>] ?lhs : Symbol,
        [<Optional>] ?rhs : Symbol) = 
        let operatorArguments = 
            [
                lhs |> Option.map (fun x -> "lhs", Input x)
                rhs |> Option.map (fun x -> "rhs", Input x)
            ] |> List.choose id
        new BroadcastAdd(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type BroadcastSub private (operatorArguments) = 
    inherit SymbolOperator("broadcast_sub", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new BroadcastSub(args)
    override this.WithArguments(args : Arguments<Symbol>) = new BroadcastSub(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <summary>Returns element-wise difference of the input arrays with broadcasting.
    /// 
    /// `broadcast_minus` is an alias to the function `broadcast_sub`.
    /// 
    /// Example::
    /// 
    ///    x = [[ 1.,  1.,  1.],
    ///         [ 1.,  1.,  1.]]
    /// 
    ///    y = [[ 0.],
    ///         [ 1.]]
    /// 
    ///    broadcast_sub(x, y) = [[ 1.,  1.,  1.],
    ///                           [ 0.,  0.,  0.]]
    /// 
    ///    broadcast_minus(x, y) = [[ 1.,  1.,  1.],
    ///                             [ 0.,  0.,  0.]]
    /// 
    /// Supported sparse operations:
    /// 
    ///    broadcast_sub/minus(csr, dense(1D)) = dense
    ///    broadcast_sub/minus(dense(1D), csr) = dense
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\elemwise_binary_broadcast_op_basic.cc:L106</summary>
    /// <param name="lhs">First input to the function</param>
    /// <param name="rhs">Second input to the function</param>
    new([<Optional>] ?lhs : Symbol,
        [<Optional>] ?rhs : Symbol) = 
        let lhs = defaultArg lhs (new ImplicitVariable() :> Symbol)
        let rhs = defaultArg rhs (new ImplicitVariable() :> Symbol)
        let operatorArguments = 
            [
                "lhs", Input lhs
                "rhs", Input rhs
            ]
        new BroadcastSub(Arguments<Symbol>(operatorArguments))
    /// First input to the function
    member __.Lhs = operatorArguments.GetInput "lhs"
    /// Second input to the function
    member __.Rhs = operatorArguments.GetInput "rhs"
    /// <summary>Copy BroadcastSub instance with updated inputs/parameters.</summary>
    /// <param name="lhs">First input to the function</param>
    /// <param name="rhs">Second input to the function</param>
    member this.With([<Optional>] ?lhs : Symbol,
        [<Optional>] ?rhs : Symbol) = 
        let operatorArguments = 
            [
                lhs |> Option.map (fun x -> "lhs", Input x)
                rhs |> Option.map (fun x -> "rhs", Input x)
            ] |> List.choose id
        new BroadcastSub(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type BroadcastMul private (operatorArguments) = 
    inherit SymbolOperator("broadcast_mul", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new BroadcastMul(args)
    override this.WithArguments(args : Arguments<Symbol>) = new BroadcastMul(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <summary>Returns element-wise product of the input arrays with broadcasting.
    /// 
    /// Example::
    /// 
    ///    x = [[ 1.,  1.,  1.],
    ///         [ 1.,  1.,  1.]]
    /// 
    ///    y = [[ 0.],
    ///         [ 1.]]
    /// 
    ///    broadcast_mul(x, y) = [[ 0.,  0.,  0.],
    ///                           [ 1.,  1.,  1.]]
    /// 
    /// Supported sparse operations:
    /// 
    ///    broadcast_mul(csr, dense(1D)) = csr
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\elemwise_binary_broadcast_op_basic.cc:L146</summary>
    /// <param name="lhs">First input to the function</param>
    /// <param name="rhs">Second input to the function</param>
    new([<Optional>] ?lhs : Symbol,
        [<Optional>] ?rhs : Symbol) = 
        let lhs = defaultArg lhs (new ImplicitVariable() :> Symbol)
        let rhs = defaultArg rhs (new ImplicitVariable() :> Symbol)
        let operatorArguments = 
            [
                "lhs", Input lhs
                "rhs", Input rhs
            ]
        new BroadcastMul(Arguments<Symbol>(operatorArguments))
    /// First input to the function
    member __.Lhs = operatorArguments.GetInput "lhs"
    /// Second input to the function
    member __.Rhs = operatorArguments.GetInput "rhs"
    /// <summary>Copy BroadcastMul instance with updated inputs/parameters.</summary>
    /// <param name="lhs">First input to the function</param>
    /// <param name="rhs">Second input to the function</param>
    member this.With([<Optional>] ?lhs : Symbol,
        [<Optional>] ?rhs : Symbol) = 
        let operatorArguments = 
            [
                lhs |> Option.map (fun x -> "lhs", Input x)
                rhs |> Option.map (fun x -> "rhs", Input x)
            ] |> List.choose id
        new BroadcastMul(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type BroadcastDiv private (operatorArguments) = 
    inherit SymbolOperator("broadcast_div", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new BroadcastDiv(args)
    override this.WithArguments(args : Arguments<Symbol>) = new BroadcastDiv(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <summary>Returns element-wise division of the input arrays with broadcasting.
    /// 
    /// Example::
    /// 
    ///    x = [[ 6.,  6.,  6.],
    ///         [ 6.,  6.,  6.]]
    /// 
    ///    y = [[ 2.],
    ///         [ 3.]]
    /// 
    ///    broadcast_div(x, y) = [[ 3.,  3.,  3.],
    ///                           [ 2.,  2.,  2.]]
    /// 
    /// Supported sparse operations:
    /// 
    ///    broadcast_div(csr, dense(1D)) = csr
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\elemwise_binary_broadcast_op_basic.cc:L187</summary>
    /// <param name="lhs">First input to the function</param>
    /// <param name="rhs">Second input to the function</param>
    new([<Optional>] ?lhs : Symbol,
        [<Optional>] ?rhs : Symbol) = 
        let lhs = defaultArg lhs (new ImplicitVariable() :> Symbol)
        let rhs = defaultArg rhs (new ImplicitVariable() :> Symbol)
        let operatorArguments = 
            [
                "lhs", Input lhs
                "rhs", Input rhs
            ]
        new BroadcastDiv(Arguments<Symbol>(operatorArguments))
    /// First input to the function
    member __.Lhs = operatorArguments.GetInput "lhs"
    /// Second input to the function
    member __.Rhs = operatorArguments.GetInput "rhs"
    /// <summary>Copy BroadcastDiv instance with updated inputs/parameters.</summary>
    /// <param name="lhs">First input to the function</param>
    /// <param name="rhs">Second input to the function</param>
    member this.With([<Optional>] ?lhs : Symbol,
        [<Optional>] ?rhs : Symbol) = 
        let operatorArguments = 
            [
                lhs |> Option.map (fun x -> "lhs", Input x)
                rhs |> Option.map (fun x -> "rhs", Input x)
            ] |> List.choose id
        new BroadcastDiv(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type BroadcastMod private (operatorArguments) = 
    inherit SymbolOperator("broadcast_mod", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new BroadcastMod(args)
    override this.WithArguments(args : Arguments<Symbol>) = new BroadcastMod(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <summary>Returns element-wise modulo of the input arrays with broadcasting.
    /// 
    /// Example::
    /// 
    ///    x = [[ 8.,  8.,  8.],
    ///         [ 8.,  8.,  8.]]
    /// 
    ///    y = [[ 2.],
    ///         [ 3.]]
    /// 
    ///    broadcast_mod(x, y) = [[ 0.,  0.,  0.],
    ///                           [ 2.,  2.,  2.]]
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\elemwise_binary_broadcast_op_basic.cc:L222</summary>
    /// <param name="lhs">First input to the function</param>
    /// <param name="rhs">Second input to the function</param>
    new([<Optional>] ?lhs : Symbol,
        [<Optional>] ?rhs : Symbol) = 
        let lhs = defaultArg lhs (new ImplicitVariable() :> Symbol)
        let rhs = defaultArg rhs (new ImplicitVariable() :> Symbol)
        let operatorArguments = 
            [
                "lhs", Input lhs
                "rhs", Input rhs
            ]
        new BroadcastMod(Arguments<Symbol>(operatorArguments))
    /// First input to the function
    member __.Lhs = operatorArguments.GetInput "lhs"
    /// Second input to the function
    member __.Rhs = operatorArguments.GetInput "rhs"
    /// <summary>Copy BroadcastMod instance with updated inputs/parameters.</summary>
    /// <param name="lhs">First input to the function</param>
    /// <param name="rhs">Second input to the function</param>
    member this.With([<Optional>] ?lhs : Symbol,
        [<Optional>] ?rhs : Symbol) = 
        let operatorArguments = 
            [
                lhs |> Option.map (fun x -> "lhs", Input x)
                rhs |> Option.map (fun x -> "rhs", Input x)
            ] |> List.choose id
        new BroadcastMod(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type BroadcastPower private (operatorArguments) = 
    inherit SymbolOperator("broadcast_power", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new BroadcastPower(args)
    override this.WithArguments(args : Arguments<Symbol>) = new BroadcastPower(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <summary>Returns result of first array elements raised to powers from second array, element-wise with broadcasting.
    /// 
    /// Example::
    /// 
    ///    x = [[ 1.,  1.,  1.],
    ///         [ 1.,  1.,  1.]]
    /// 
    ///    y = [[ 0.],
    ///         [ 1.]]
    /// 
    ///    broadcast_power(x, y) = [[ 2.,  2.,  2.],
    ///                             [ 4.,  4.,  4.]]
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\elemwise_binary_broadcast_op_extended.cc:L45</summary>
    /// <param name="lhs">First input to the function</param>
    /// <param name="rhs">Second input to the function</param>
    new([<Optional>] ?lhs : Symbol,
        [<Optional>] ?rhs : Symbol) = 
        let lhs = defaultArg lhs (new ImplicitVariable() :> Symbol)
        let rhs = defaultArg rhs (new ImplicitVariable() :> Symbol)
        let operatorArguments = 
            [
                "lhs", Input lhs
                "rhs", Input rhs
            ]
        new BroadcastPower(Arguments<Symbol>(operatorArguments))
    /// First input to the function
    member __.Lhs = operatorArguments.GetInput "lhs"
    /// Second input to the function
    member __.Rhs = operatorArguments.GetInput "rhs"
    /// <summary>Copy BroadcastPower instance with updated inputs/parameters.</summary>
    /// <param name="lhs">First input to the function</param>
    /// <param name="rhs">Second input to the function</param>
    member this.With([<Optional>] ?lhs : Symbol,
        [<Optional>] ?rhs : Symbol) = 
        let operatorArguments = 
            [
                lhs |> Option.map (fun x -> "lhs", Input x)
                rhs |> Option.map (fun x -> "rhs", Input x)
            ] |> List.choose id
        new BroadcastPower(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type BroadcastMaximum private (operatorArguments) = 
    inherit SymbolOperator("broadcast_maximum", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new BroadcastMaximum(args)
    override this.WithArguments(args : Arguments<Symbol>) = new BroadcastMaximum(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <summary>Returns element-wise maximum of the input arrays with broadcasting.
    /// 
    /// This function compares two input arrays and returns a new array having the element-wise maxima.
    /// 
    /// Example::
    /// 
    ///    x = [[ 1.,  1.,  1.],
    ///         [ 1.,  1.,  1.]]
    /// 
    ///    y = [[ 0.],
    ///         [ 1.]]
    /// 
    ///    broadcast_maximum(x, y) = [[ 1.,  1.,  1.],
    ///                               [ 1.,  1.,  1.]]
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\elemwise_binary_broadcast_op_extended.cc:L81</summary>
    /// <param name="lhs">First input to the function</param>
    /// <param name="rhs">Second input to the function</param>
    new([<Optional>] ?lhs : Symbol,
        [<Optional>] ?rhs : Symbol) = 
        let lhs = defaultArg lhs (new ImplicitVariable() :> Symbol)
        let rhs = defaultArg rhs (new ImplicitVariable() :> Symbol)
        let operatorArguments = 
            [
                "lhs", Input lhs
                "rhs", Input rhs
            ]
        new BroadcastMaximum(Arguments<Symbol>(operatorArguments))
    /// First input to the function
    member __.Lhs = operatorArguments.GetInput "lhs"
    /// Second input to the function
    member __.Rhs = operatorArguments.GetInput "rhs"
    /// <summary>Copy BroadcastMaximum instance with updated inputs/parameters.</summary>
    /// <param name="lhs">First input to the function</param>
    /// <param name="rhs">Second input to the function</param>
    member this.With([<Optional>] ?lhs : Symbol,
        [<Optional>] ?rhs : Symbol) = 
        let operatorArguments = 
            [
                lhs |> Option.map (fun x -> "lhs", Input x)
                rhs |> Option.map (fun x -> "rhs", Input x)
            ] |> List.choose id
        new BroadcastMaximum(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type BroadcastMinimum private (operatorArguments) = 
    inherit SymbolOperator("broadcast_minimum", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new BroadcastMinimum(args)
    override this.WithArguments(args : Arguments<Symbol>) = new BroadcastMinimum(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <summary>Returns element-wise minimum of the input arrays with broadcasting.
    /// 
    /// This function compares two input arrays and returns a new array having the element-wise minima.
    /// 
    /// Example::
    /// 
    ///    x = [[ 1.,  1.,  1.],
    ///         [ 1.,  1.,  1.]]
    /// 
    ///    y = [[ 0.],
    ///         [ 1.]]
    /// 
    ///    broadcast_maximum(x, y) = [[ 0.,  0.,  0.],
    ///                               [ 1.,  1.,  1.]]
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\elemwise_binary_broadcast_op_extended.cc:L117</summary>
    /// <param name="lhs">First input to the function</param>
    /// <param name="rhs">Second input to the function</param>
    new([<Optional>] ?lhs : Symbol,
        [<Optional>] ?rhs : Symbol) = 
        let lhs = defaultArg lhs (new ImplicitVariable() :> Symbol)
        let rhs = defaultArg rhs (new ImplicitVariable() :> Symbol)
        let operatorArguments = 
            [
                "lhs", Input lhs
                "rhs", Input rhs
            ]
        new BroadcastMinimum(Arguments<Symbol>(operatorArguments))
    /// First input to the function
    member __.Lhs = operatorArguments.GetInput "lhs"
    /// Second input to the function
    member __.Rhs = operatorArguments.GetInput "rhs"
    /// <summary>Copy BroadcastMinimum instance with updated inputs/parameters.</summary>
    /// <param name="lhs">First input to the function</param>
    /// <param name="rhs">Second input to the function</param>
    member this.With([<Optional>] ?lhs : Symbol,
        [<Optional>] ?rhs : Symbol) = 
        let operatorArguments = 
            [
                lhs |> Option.map (fun x -> "lhs", Input x)
                rhs |> Option.map (fun x -> "rhs", Input x)
            ] |> List.choose id
        new BroadcastMinimum(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type BroadcastHypot private (operatorArguments) = 
    inherit SymbolOperator("broadcast_hypot", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new BroadcastHypot(args)
    override this.WithArguments(args : Arguments<Symbol>) = new BroadcastHypot(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <summary> Returns the hypotenuse of a right angled triangle, given its &quot;legs&quot;
    /// with broadcasting.
    /// 
    /// It is equivalent to doing :math:`sqrt(x_1^2 + x_2^2)`.
    /// 
    /// Example::
    /// 
    ///    x = [[ 3.,  3.,  3.]]
    /// 
    ///    y = [[ 4.],
    ///         [ 4.]]
    /// 
    ///    broadcast_hypot(x, y) = [[ 5.,  5.,  5.],
    ///                             [ 5.,  5.,  5.]]
    /// 
    ///    z = [[ 0.],
    ///         [ 4.]]
    /// 
    ///    broadcast_hypot(x, z) = [[ 3.,  3.,  3.],
    ///                             [ 5.,  5.,  5.]]
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\elemwise_binary_broadcast_op_extended.cc:L158</summary>
    /// <param name="lhs">First input to the function</param>
    /// <param name="rhs">Second input to the function</param>
    new([<Optional>] ?lhs : Symbol,
        [<Optional>] ?rhs : Symbol) = 
        let lhs = defaultArg lhs (new ImplicitVariable() :> Symbol)
        let rhs = defaultArg rhs (new ImplicitVariable() :> Symbol)
        let operatorArguments = 
            [
                "lhs", Input lhs
                "rhs", Input rhs
            ]
        new BroadcastHypot(Arguments<Symbol>(operatorArguments))
    /// First input to the function
    member __.Lhs = operatorArguments.GetInput "lhs"
    /// Second input to the function
    member __.Rhs = operatorArguments.GetInput "rhs"
    /// <summary>Copy BroadcastHypot instance with updated inputs/parameters.</summary>
    /// <param name="lhs">First input to the function</param>
    /// <param name="rhs">Second input to the function</param>
    member this.With([<Optional>] ?lhs : Symbol,
        [<Optional>] ?rhs : Symbol) = 
        let operatorArguments = 
            [
                lhs |> Option.map (fun x -> "lhs", Input x)
                rhs |> Option.map (fun x -> "rhs", Input x)
            ] |> List.choose id
        new BroadcastHypot(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type BroadcastEqual private (operatorArguments) = 
    inherit SymbolOperator("broadcast_equal", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new BroadcastEqual(args)
    override this.WithArguments(args : Arguments<Symbol>) = new BroadcastEqual(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <summary>Returns the result of element-wise **equal to** (==) comparison operation with broadcasting.
    /// 
    /// Example::
    /// 
    ///    x = [[ 1.,  1.,  1.],
    ///         [ 1.,  1.,  1.]]
    /// 
    ///    y = [[ 0.],
    ///         [ 1.]]
    /// 
    ///    broadcast_equal(x, y) = [[ 0.,  0.,  0.],
    ///                             [ 1.,  1.,  1.]]
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\elemwise_binary_broadcast_op_logic.cc:L47</summary>
    /// <param name="lhs">First input to the function</param>
    /// <param name="rhs">Second input to the function</param>
    new([<Optional>] ?lhs : Symbol,
        [<Optional>] ?rhs : Symbol) = 
        let lhs = defaultArg lhs (new ImplicitVariable() :> Symbol)
        let rhs = defaultArg rhs (new ImplicitVariable() :> Symbol)
        let operatorArguments = 
            [
                "lhs", Input lhs
                "rhs", Input rhs
            ]
        new BroadcastEqual(Arguments<Symbol>(operatorArguments))
    /// First input to the function
    member __.Lhs = operatorArguments.GetInput "lhs"
    /// Second input to the function
    member __.Rhs = operatorArguments.GetInput "rhs"
    /// <summary>Copy BroadcastEqual instance with updated inputs/parameters.</summary>
    /// <param name="lhs">First input to the function</param>
    /// <param name="rhs">Second input to the function</param>
    member this.With([<Optional>] ?lhs : Symbol,
        [<Optional>] ?rhs : Symbol) = 
        let operatorArguments = 
            [
                lhs |> Option.map (fun x -> "lhs", Input x)
                rhs |> Option.map (fun x -> "rhs", Input x)
            ] |> List.choose id
        new BroadcastEqual(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type BroadcastNotEqual private (operatorArguments) = 
    inherit SymbolOperator("broadcast_not_equal", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new BroadcastNotEqual(args)
    override this.WithArguments(args : Arguments<Symbol>) = new BroadcastNotEqual(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <summary>Returns the result of element-wise **not equal to** (!=) comparison operation with broadcasting.
    /// 
    /// Example::
    /// 
    ///    x = [[ 1.,  1.,  1.],
    ///         [ 1.,  1.,  1.]]
    /// 
    ///    y = [[ 0.],
    ///         [ 1.]]
    /// 
    ///    broadcast_not_equal(x, y) = [[ 1.,  1.,  1.],
    ///                                 [ 0.,  0.,  0.]]
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\elemwise_binary_broadcast_op_logic.cc:L66</summary>
    /// <param name="lhs">First input to the function</param>
    /// <param name="rhs">Second input to the function</param>
    new([<Optional>] ?lhs : Symbol,
        [<Optional>] ?rhs : Symbol) = 
        let lhs = defaultArg lhs (new ImplicitVariable() :> Symbol)
        let rhs = defaultArg rhs (new ImplicitVariable() :> Symbol)
        let operatorArguments = 
            [
                "lhs", Input lhs
                "rhs", Input rhs
            ]
        new BroadcastNotEqual(Arguments<Symbol>(operatorArguments))
    /// First input to the function
    member __.Lhs = operatorArguments.GetInput "lhs"
    /// Second input to the function
    member __.Rhs = operatorArguments.GetInput "rhs"
    /// <summary>Copy BroadcastNotEqual instance with updated inputs/parameters.</summary>
    /// <param name="lhs">First input to the function</param>
    /// <param name="rhs">Second input to the function</param>
    member this.With([<Optional>] ?lhs : Symbol,
        [<Optional>] ?rhs : Symbol) = 
        let operatorArguments = 
            [
                lhs |> Option.map (fun x -> "lhs", Input x)
                rhs |> Option.map (fun x -> "rhs", Input x)
            ] |> List.choose id
        new BroadcastNotEqual(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type BroadcastGreater private (operatorArguments) = 
    inherit SymbolOperator("broadcast_greater", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new BroadcastGreater(args)
    override this.WithArguments(args : Arguments<Symbol>) = new BroadcastGreater(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <summary>Returns the result of element-wise **greater than** (&gt;) comparison operation with broadcasting.
    /// 
    /// Example::
    /// 
    ///    x = [[ 1.,  1.,  1.],
    ///         [ 1.,  1.,  1.]]
    /// 
    ///    y = [[ 0.],
    ///         [ 1.]]
    /// 
    ///    broadcast_greater(x, y) = [[ 1.,  1.,  1.],
    ///                               [ 0.,  0.,  0.]]
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\elemwise_binary_broadcast_op_logic.cc:L85</summary>
    /// <param name="lhs">First input to the function</param>
    /// <param name="rhs">Second input to the function</param>
    new([<Optional>] ?lhs : Symbol,
        [<Optional>] ?rhs : Symbol) = 
        let lhs = defaultArg lhs (new ImplicitVariable() :> Symbol)
        let rhs = defaultArg rhs (new ImplicitVariable() :> Symbol)
        let operatorArguments = 
            [
                "lhs", Input lhs
                "rhs", Input rhs
            ]
        new BroadcastGreater(Arguments<Symbol>(operatorArguments))
    /// First input to the function
    member __.Lhs = operatorArguments.GetInput "lhs"
    /// Second input to the function
    member __.Rhs = operatorArguments.GetInput "rhs"
    /// <summary>Copy BroadcastGreater instance with updated inputs/parameters.</summary>
    /// <param name="lhs">First input to the function</param>
    /// <param name="rhs">Second input to the function</param>
    member this.With([<Optional>] ?lhs : Symbol,
        [<Optional>] ?rhs : Symbol) = 
        let operatorArguments = 
            [
                lhs |> Option.map (fun x -> "lhs", Input x)
                rhs |> Option.map (fun x -> "rhs", Input x)
            ] |> List.choose id
        new BroadcastGreater(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type BroadcastGreaterEqual private (operatorArguments) = 
    inherit SymbolOperator("broadcast_greater_equal", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new BroadcastGreaterEqual(args)
    override this.WithArguments(args : Arguments<Symbol>) = new BroadcastGreaterEqual(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <summary>Returns the result of element-wise **greater than or equal to** (&gt;=) comparison operation with broadcasting.
    /// 
    /// Example::
    /// 
    ///    x = [[ 1.,  1.,  1.],
    ///         [ 1.,  1.,  1.]]
    /// 
    ///    y = [[ 0.],
    ///         [ 1.]]
    /// 
    ///    broadcast_greater_equal(x, y) = [[ 1.,  1.,  1.],
    ///                                     [ 1.,  1.,  1.]]
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\elemwise_binary_broadcast_op_logic.cc:L104</summary>
    /// <param name="lhs">First input to the function</param>
    /// <param name="rhs">Second input to the function</param>
    new([<Optional>] ?lhs : Symbol,
        [<Optional>] ?rhs : Symbol) = 
        let lhs = defaultArg lhs (new ImplicitVariable() :> Symbol)
        let rhs = defaultArg rhs (new ImplicitVariable() :> Symbol)
        let operatorArguments = 
            [
                "lhs", Input lhs
                "rhs", Input rhs
            ]
        new BroadcastGreaterEqual(Arguments<Symbol>(operatorArguments))
    /// First input to the function
    member __.Lhs = operatorArguments.GetInput "lhs"
    /// Second input to the function
    member __.Rhs = operatorArguments.GetInput "rhs"
    /// <summary>Copy BroadcastGreaterEqual instance with updated inputs/parameters.</summary>
    /// <param name="lhs">First input to the function</param>
    /// <param name="rhs">Second input to the function</param>
    member this.With([<Optional>] ?lhs : Symbol,
        [<Optional>] ?rhs : Symbol) = 
        let operatorArguments = 
            [
                lhs |> Option.map (fun x -> "lhs", Input x)
                rhs |> Option.map (fun x -> "rhs", Input x)
            ] |> List.choose id
        new BroadcastGreaterEqual(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type BroadcastLesser private (operatorArguments) = 
    inherit SymbolOperator("broadcast_lesser", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new BroadcastLesser(args)
    override this.WithArguments(args : Arguments<Symbol>) = new BroadcastLesser(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <summary>Returns the result of element-wise **lesser than** (&lt;) comparison operation with broadcasting.
    /// 
    /// Example::
    /// 
    ///    x = [[ 1.,  1.,  1.],
    ///         [ 1.,  1.,  1.]]
    /// 
    ///    y = [[ 0.],
    ///         [ 1.]]
    /// 
    ///    broadcast_lesser(x, y) = [[ 0.,  0.,  0.],
    ///                              [ 0.,  0.,  0.]]
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\elemwise_binary_broadcast_op_logic.cc:L123</summary>
    /// <param name="lhs">First input to the function</param>
    /// <param name="rhs">Second input to the function</param>
    new([<Optional>] ?lhs : Symbol,
        [<Optional>] ?rhs : Symbol) = 
        let lhs = defaultArg lhs (new ImplicitVariable() :> Symbol)
        let rhs = defaultArg rhs (new ImplicitVariable() :> Symbol)
        let operatorArguments = 
            [
                "lhs", Input lhs
                "rhs", Input rhs
            ]
        new BroadcastLesser(Arguments<Symbol>(operatorArguments))
    /// First input to the function
    member __.Lhs = operatorArguments.GetInput "lhs"
    /// Second input to the function
    member __.Rhs = operatorArguments.GetInput "rhs"
    /// <summary>Copy BroadcastLesser instance with updated inputs/parameters.</summary>
    /// <param name="lhs">First input to the function</param>
    /// <param name="rhs">Second input to the function</param>
    member this.With([<Optional>] ?lhs : Symbol,
        [<Optional>] ?rhs : Symbol) = 
        let operatorArguments = 
            [
                lhs |> Option.map (fun x -> "lhs", Input x)
                rhs |> Option.map (fun x -> "rhs", Input x)
            ] |> List.choose id
        new BroadcastLesser(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type BroadcastLesserEqual private (operatorArguments) = 
    inherit SymbolOperator("broadcast_lesser_equal", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new BroadcastLesserEqual(args)
    override this.WithArguments(args : Arguments<Symbol>) = new BroadcastLesserEqual(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <summary>Returns the result of element-wise **lesser than or equal to** (&lt;=) comparison operation with broadcasting.
    /// 
    /// Example::
    /// 
    ///    x = [[ 1.,  1.,  1.],
    ///         [ 1.,  1.,  1.]]
    /// 
    ///    y = [[ 0.],
    ///         [ 1.]]
    /// 
    ///    broadcast_lesser_equal(x, y) = [[ 0.,  0.,  0.],
    ///                                    [ 1.,  1.,  1.]]
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\elemwise_binary_broadcast_op_logic.cc:L142</summary>
    /// <param name="lhs">First input to the function</param>
    /// <param name="rhs">Second input to the function</param>
    new([<Optional>] ?lhs : Symbol,
        [<Optional>] ?rhs : Symbol) = 
        let lhs = defaultArg lhs (new ImplicitVariable() :> Symbol)
        let rhs = defaultArg rhs (new ImplicitVariable() :> Symbol)
        let operatorArguments = 
            [
                "lhs", Input lhs
                "rhs", Input rhs
            ]
        new BroadcastLesserEqual(Arguments<Symbol>(operatorArguments))
    /// First input to the function
    member __.Lhs = operatorArguments.GetInput "lhs"
    /// Second input to the function
    member __.Rhs = operatorArguments.GetInput "rhs"
    /// <summary>Copy BroadcastLesserEqual instance with updated inputs/parameters.</summary>
    /// <param name="lhs">First input to the function</param>
    /// <param name="rhs">Second input to the function</param>
    member this.With([<Optional>] ?lhs : Symbol,
        [<Optional>] ?rhs : Symbol) = 
        let operatorArguments = 
            [
                lhs |> Option.map (fun x -> "lhs", Input x)
                rhs |> Option.map (fun x -> "rhs", Input x)
            ] |> List.choose id
        new BroadcastLesserEqual(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type BroadcastLogicalAnd private (operatorArguments) = 
    inherit SymbolOperator("broadcast_logical_and", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new BroadcastLogicalAnd(args)
    override this.WithArguments(args : Arguments<Symbol>) = new BroadcastLogicalAnd(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <summary>Returns the result of element-wise **logical and** with broadcasting.
    /// 
    /// Example::
    /// 
    ///    x = [[ 1.,  1.,  1.],
    ///         [ 1.,  1.,  1.]]
    /// 
    ///    y = [[ 0.],
    ///         [ 1.]]
    /// 
    ///    broadcast_logical_and(x, y) = [[ 0.,  0.,  0.],
    ///                                   [ 1.,  1.,  1.]]
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\elemwise_binary_broadcast_op_logic.cc:L160</summary>
    /// <param name="lhs">First input to the function</param>
    /// <param name="rhs">Second input to the function</param>
    new([<Optional>] ?lhs : Symbol,
        [<Optional>] ?rhs : Symbol) = 
        let lhs = defaultArg lhs (new ImplicitVariable() :> Symbol)
        let rhs = defaultArg rhs (new ImplicitVariable() :> Symbol)
        let operatorArguments = 
            [
                "lhs", Input lhs
                "rhs", Input rhs
            ]
        new BroadcastLogicalAnd(Arguments<Symbol>(operatorArguments))
    /// First input to the function
    member __.Lhs = operatorArguments.GetInput "lhs"
    /// Second input to the function
    member __.Rhs = operatorArguments.GetInput "rhs"
    /// <summary>Copy BroadcastLogicalAnd instance with updated inputs/parameters.</summary>
    /// <param name="lhs">First input to the function</param>
    /// <param name="rhs">Second input to the function</param>
    member this.With([<Optional>] ?lhs : Symbol,
        [<Optional>] ?rhs : Symbol) = 
        let operatorArguments = 
            [
                lhs |> Option.map (fun x -> "lhs", Input x)
                rhs |> Option.map (fun x -> "rhs", Input x)
            ] |> List.choose id
        new BroadcastLogicalAnd(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type BroadcastLogicalOr private (operatorArguments) = 
    inherit SymbolOperator("broadcast_logical_or", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new BroadcastLogicalOr(args)
    override this.WithArguments(args : Arguments<Symbol>) = new BroadcastLogicalOr(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <summary>Returns the result of element-wise **logical or** with broadcasting.
    /// 
    /// Example::
    /// 
    ///    x = [[ 1.,  1.,  0.],
    ///         [ 1.,  1.,  0.]]
    /// 
    ///    y = [[ 1.],
    ///         [ 0.]]
    /// 
    ///    broadcast_logical_or(x, y) = [[ 1.,  1.,  1.],
    ///                                  [ 1.,  1.,  0.]]
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\elemwise_binary_broadcast_op_logic.cc:L178</summary>
    /// <param name="lhs">First input to the function</param>
    /// <param name="rhs">Second input to the function</param>
    new([<Optional>] ?lhs : Symbol,
        [<Optional>] ?rhs : Symbol) = 
        let lhs = defaultArg lhs (new ImplicitVariable() :> Symbol)
        let rhs = defaultArg rhs (new ImplicitVariable() :> Symbol)
        let operatorArguments = 
            [
                "lhs", Input lhs
                "rhs", Input rhs
            ]
        new BroadcastLogicalOr(Arguments<Symbol>(operatorArguments))
    /// First input to the function
    member __.Lhs = operatorArguments.GetInput "lhs"
    /// Second input to the function
    member __.Rhs = operatorArguments.GetInput "rhs"
    /// <summary>Copy BroadcastLogicalOr instance with updated inputs/parameters.</summary>
    /// <param name="lhs">First input to the function</param>
    /// <param name="rhs">Second input to the function</param>
    member this.With([<Optional>] ?lhs : Symbol,
        [<Optional>] ?rhs : Symbol) = 
        let operatorArguments = 
            [
                lhs |> Option.map (fun x -> "lhs", Input x)
                rhs |> Option.map (fun x -> "rhs", Input x)
            ] |> List.choose id
        new BroadcastLogicalOr(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type BroadcastLogicalXor private (operatorArguments) = 
    inherit SymbolOperator("broadcast_logical_xor", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new BroadcastLogicalXor(args)
    override this.WithArguments(args : Arguments<Symbol>) = new BroadcastLogicalXor(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <summary>Returns the result of element-wise **logical xor** with broadcasting.
    /// 
    /// Example::
    /// 
    ///    x = [[ 1.,  1.,  0.],
    ///         [ 1.,  1.,  0.]]
    /// 
    ///    y = [[ 1.],
    ///         [ 0.]]
    /// 
    ///    broadcast_logical_xor(x, y) = [[ 0.,  0.,  1.],
    ///                                   [ 1.,  1.,  0.]]
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\elemwise_binary_broadcast_op_logic.cc:L196</summary>
    /// <param name="lhs">First input to the function</param>
    /// <param name="rhs">Second input to the function</param>
    new([<Optional>] ?lhs : Symbol,
        [<Optional>] ?rhs : Symbol) = 
        let lhs = defaultArg lhs (new ImplicitVariable() :> Symbol)
        let rhs = defaultArg rhs (new ImplicitVariable() :> Symbol)
        let operatorArguments = 
            [
                "lhs", Input lhs
                "rhs", Input rhs
            ]
        new BroadcastLogicalXor(Arguments<Symbol>(operatorArguments))
    /// First input to the function
    member __.Lhs = operatorArguments.GetInput "lhs"
    /// Second input to the function
    member __.Rhs = operatorArguments.GetInput "rhs"
    /// <summary>Copy BroadcastLogicalXor instance with updated inputs/parameters.</summary>
    /// <param name="lhs">First input to the function</param>
    /// <param name="rhs">Second input to the function</param>
    member this.With([<Optional>] ?lhs : Symbol,
        [<Optional>] ?rhs : Symbol) = 
        let operatorArguments = 
            [
                lhs |> Option.map (fun x -> "lhs", Input x)
                rhs |> Option.map (fun x -> "rhs", Input x)
            ] |> List.choose id
        new BroadcastLogicalXor(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type ElemwiseAdd private (operatorArguments) = 
    inherit SymbolOperator("elemwise_add", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new ElemwiseAdd(args)
    override this.WithArguments(args : Arguments<Symbol>) = new ElemwiseAdd(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <summary>Adds arguments element-wise.
    /// 
    /// The storage type of ``elemwise_add`` output depends on storage types of inputs
    /// 
    ///    - elemwise_add(row_sparse, row_sparse) = row_sparse
    ///    - elemwise_add(csr, csr) = csr
    ///    - elemwise_add(default, csr) = default
    ///    - elemwise_add(csr, default) = default
    ///    - elemwise_add(default, rsp) = default
    ///    - elemwise_add(rsp, default) = default
    ///    - otherwise, ``elemwise_add`` generates output with default storage
    /// 
    /// </summary>
    /// <param name="lhs">first input</param>
    /// <param name="rhs">second input</param>
    new([<Optional>] ?lhs : Symbol,
        [<Optional>] ?rhs : Symbol) = 
        let lhs = defaultArg lhs (new ImplicitVariable() :> Symbol)
        let rhs = defaultArg rhs (new ImplicitVariable() :> Symbol)
        let operatorArguments = 
            [
                "lhs", Input lhs
                "rhs", Input rhs
            ]
        new ElemwiseAdd(Arguments<Symbol>(operatorArguments))
    /// first input
    member __.Lhs = operatorArguments.GetInput "lhs"
    /// second input
    member __.Rhs = operatorArguments.GetInput "rhs"
    /// <summary>Copy ElemwiseAdd instance with updated inputs/parameters.</summary>
    /// <param name="lhs">first input</param>
    /// <param name="rhs">second input</param>
    member this.With([<Optional>] ?lhs : Symbol,
        [<Optional>] ?rhs : Symbol) = 
        let operatorArguments = 
            [
                lhs |> Option.map (fun x -> "lhs", Input x)
                rhs |> Option.map (fun x -> "rhs", Input x)
            ] |> List.choose id
        new ElemwiseAdd(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type GradAdd private (operatorArguments) = 
    inherit SymbolOperator("_grad_add", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new GradAdd(args)
    override this.WithArguments(args : Arguments<Symbol>) = new GradAdd(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <param name="lhs">first input</param>
    /// <param name="rhs">second input</param>
    new([<Optional>] ?lhs : Symbol,
        [<Optional>] ?rhs : Symbol) = 
        let lhs = defaultArg lhs (new ImplicitVariable() :> Symbol)
        let rhs = defaultArg rhs (new ImplicitVariable() :> Symbol)
        let operatorArguments = 
            [
                "lhs", Input lhs
                "rhs", Input rhs
            ]
        new GradAdd(Arguments<Symbol>(operatorArguments))
    /// first input
    member __.Lhs = operatorArguments.GetInput "lhs"
    /// second input
    member __.Rhs = operatorArguments.GetInput "rhs"
    /// <summary>Copy GradAdd instance with updated inputs/parameters.</summary>
    /// <param name="lhs">first input</param>
    /// <param name="rhs">second input</param>
    member this.With([<Optional>] ?lhs : Symbol,
        [<Optional>] ?rhs : Symbol) = 
        let operatorArguments = 
            [
                lhs |> Option.map (fun x -> "lhs", Input x)
                rhs |> Option.map (fun x -> "rhs", Input x)
            ] |> List.choose id
        new GradAdd(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type ElemwiseSub private (operatorArguments) = 
    inherit SymbolOperator("elemwise_sub", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new ElemwiseSub(args)
    override this.WithArguments(args : Arguments<Symbol>) = new ElemwiseSub(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <summary>Subtracts arguments element-wise.
    /// 
    /// The storage type of ``elemwise_sub`` output depends on storage types of inputs
    /// 
    ///    - elemwise_sub(row_sparse, row_sparse) = row_sparse
    ///    - elemwise_sub(csr, csr) = csr
    ///    - elemwise_sub(default, csr) = default
    ///    - elemwise_sub(csr, default) = default
    ///    - elemwise_sub(default, rsp) = default
    ///    - elemwise_sub(rsp, default) = default
    ///    - otherwise, ``elemwise_sub`` generates output with default storage
    /// 
    /// </summary>
    /// <param name="lhs">first input</param>
    /// <param name="rhs">second input</param>
    new([<Optional>] ?lhs : Symbol,
        [<Optional>] ?rhs : Symbol) = 
        let lhs = defaultArg lhs (new ImplicitVariable() :> Symbol)
        let rhs = defaultArg rhs (new ImplicitVariable() :> Symbol)
        let operatorArguments = 
            [
                "lhs", Input lhs
                "rhs", Input rhs
            ]
        new ElemwiseSub(Arguments<Symbol>(operatorArguments))
    /// first input
    member __.Lhs = operatorArguments.GetInput "lhs"
    /// second input
    member __.Rhs = operatorArguments.GetInput "rhs"
    /// <summary>Copy ElemwiseSub instance with updated inputs/parameters.</summary>
    /// <param name="lhs">first input</param>
    /// <param name="rhs">second input</param>
    member this.With([<Optional>] ?lhs : Symbol,
        [<Optional>] ?rhs : Symbol) = 
        let operatorArguments = 
            [
                lhs |> Option.map (fun x -> "lhs", Input x)
                rhs |> Option.map (fun x -> "rhs", Input x)
            ] |> List.choose id
        new ElemwiseSub(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type ElemwiseMul private (operatorArguments) = 
    inherit SymbolOperator("elemwise_mul", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new ElemwiseMul(args)
    override this.WithArguments(args : Arguments<Symbol>) = new ElemwiseMul(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <summary>Multiplies arguments element-wise.
    /// 
    /// The storage type of ``elemwise_mul`` output depends on storage types of inputs
    /// 
    ///    - elemwise_mul(default, default) = default
    ///    - elemwise_mul(row_sparse, row_sparse) = row_sparse
    ///    - elemwise_mul(default, row_sparse) = row_sparse
    ///    - elemwise_mul(row_sparse, default) = row_sparse
    ///    - elemwise_mul(csr, csr) = csr
    ///    - otherwise, ``elemwise_mul`` generates output with default storage
    /// 
    /// </summary>
    /// <param name="lhs">first input</param>
    /// <param name="rhs">second input</param>
    new([<Optional>] ?lhs : Symbol,
        [<Optional>] ?rhs : Symbol) = 
        let lhs = defaultArg lhs (new ImplicitVariable() :> Symbol)
        let rhs = defaultArg rhs (new ImplicitVariable() :> Symbol)
        let operatorArguments = 
            [
                "lhs", Input lhs
                "rhs", Input rhs
            ]
        new ElemwiseMul(Arguments<Symbol>(operatorArguments))
    /// first input
    member __.Lhs = operatorArguments.GetInput "lhs"
    /// second input
    member __.Rhs = operatorArguments.GetInput "rhs"
    /// <summary>Copy ElemwiseMul instance with updated inputs/parameters.</summary>
    /// <param name="lhs">first input</param>
    /// <param name="rhs">second input</param>
    member this.With([<Optional>] ?lhs : Symbol,
        [<Optional>] ?rhs : Symbol) = 
        let operatorArguments = 
            [
                lhs |> Option.map (fun x -> "lhs", Input x)
                rhs |> Option.map (fun x -> "rhs", Input x)
            ] |> List.choose id
        new ElemwiseMul(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type ElemwiseDiv private (operatorArguments) = 
    inherit SymbolOperator("elemwise_div", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new ElemwiseDiv(args)
    override this.WithArguments(args : Arguments<Symbol>) = new ElemwiseDiv(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <summary>Divides arguments element-wise.
    /// 
    /// The storage type of ``elemwise_div`` output is always dense
    /// 
    /// </summary>
    /// <param name="lhs">first input</param>
    /// <param name="rhs">second input</param>
    new([<Optional>] ?lhs : Symbol,
        [<Optional>] ?rhs : Symbol) = 
        let lhs = defaultArg lhs (new ImplicitVariable() :> Symbol)
        let rhs = defaultArg rhs (new ImplicitVariable() :> Symbol)
        let operatorArguments = 
            [
                "lhs", Input lhs
                "rhs", Input rhs
            ]
        new ElemwiseDiv(Arguments<Symbol>(operatorArguments))
    /// first input
    member __.Lhs = operatorArguments.GetInput "lhs"
    /// second input
    member __.Rhs = operatorArguments.GetInput "rhs"
    /// <summary>Copy ElemwiseDiv instance with updated inputs/parameters.</summary>
    /// <param name="lhs">first input</param>
    /// <param name="rhs">second input</param>
    member this.With([<Optional>] ?lhs : Symbol,
        [<Optional>] ?rhs : Symbol) = 
        let operatorArguments = 
            [
                lhs |> Option.map (fun x -> "lhs", Input x)
                rhs |> Option.map (fun x -> "rhs", Input x)
            ] |> List.choose id
        new ElemwiseDiv(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type Mod private (operatorArguments) = 
    inherit SymbolOperator("_mod", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new Mod(args)
    override this.WithArguments(args : Arguments<Symbol>) = new Mod(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <param name="lhs">first input</param>
    /// <param name="rhs">second input</param>
    new([<Optional>] ?lhs : Symbol,
        [<Optional>] ?rhs : Symbol) = 
        let lhs = defaultArg lhs (new ImplicitVariable() :> Symbol)
        let rhs = defaultArg rhs (new ImplicitVariable() :> Symbol)
        let operatorArguments = 
            [
                "lhs", Input lhs
                "rhs", Input rhs
            ]
        new Mod(Arguments<Symbol>(operatorArguments))
    /// first input
    member __.Lhs = operatorArguments.GetInput "lhs"
    /// second input
    member __.Rhs = operatorArguments.GetInput "rhs"
    /// <summary>Copy Mod instance with updated inputs/parameters.</summary>
    /// <param name="lhs">first input</param>
    /// <param name="rhs">second input</param>
    member this.With([<Optional>] ?lhs : Symbol,
        [<Optional>] ?rhs : Symbol) = 
        let operatorArguments = 
            [
                lhs |> Option.map (fun x -> "lhs", Input x)
                rhs |> Option.map (fun x -> "rhs", Input x)
            ] |> List.choose id
        new Mod(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type Power private (operatorArguments) = 
    inherit SymbolOperator("_power", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new Power(args)
    override this.WithArguments(args : Arguments<Symbol>) = new Power(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <param name="lhs">first input</param>
    /// <param name="rhs">second input</param>
    new([<Optional>] ?lhs : Symbol,
        [<Optional>] ?rhs : Symbol) = 
        let lhs = defaultArg lhs (new ImplicitVariable() :> Symbol)
        let rhs = defaultArg rhs (new ImplicitVariable() :> Symbol)
        let operatorArguments = 
            [
                "lhs", Input lhs
                "rhs", Input rhs
            ]
        new Power(Arguments<Symbol>(operatorArguments))
    /// first input
    member __.Lhs = operatorArguments.GetInput "lhs"
    /// second input
    member __.Rhs = operatorArguments.GetInput "rhs"
    /// <summary>Copy Power instance with updated inputs/parameters.</summary>
    /// <param name="lhs">first input</param>
    /// <param name="rhs">second input</param>
    member this.With([<Optional>] ?lhs : Symbol,
        [<Optional>] ?rhs : Symbol) = 
        let operatorArguments = 
            [
                lhs |> Option.map (fun x -> "lhs", Input x)
                rhs |> Option.map (fun x -> "rhs", Input x)
            ] |> List.choose id
        new Power(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type Maximum private (operatorArguments) = 
    inherit SymbolOperator("_maximum", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new Maximum(args)
    override this.WithArguments(args : Arguments<Symbol>) = new Maximum(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <param name="lhs">first input</param>
    /// <param name="rhs">second input</param>
    new([<Optional>] ?lhs : Symbol,
        [<Optional>] ?rhs : Symbol) = 
        let lhs = defaultArg lhs (new ImplicitVariable() :> Symbol)
        let rhs = defaultArg rhs (new ImplicitVariable() :> Symbol)
        let operatorArguments = 
            [
                "lhs", Input lhs
                "rhs", Input rhs
            ]
        new Maximum(Arguments<Symbol>(operatorArguments))
    /// first input
    member __.Lhs = operatorArguments.GetInput "lhs"
    /// second input
    member __.Rhs = operatorArguments.GetInput "rhs"
    /// <summary>Copy Maximum instance with updated inputs/parameters.</summary>
    /// <param name="lhs">first input</param>
    /// <param name="rhs">second input</param>
    member this.With([<Optional>] ?lhs : Symbol,
        [<Optional>] ?rhs : Symbol) = 
        let operatorArguments = 
            [
                lhs |> Option.map (fun x -> "lhs", Input x)
                rhs |> Option.map (fun x -> "rhs", Input x)
            ] |> List.choose id
        new Maximum(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type Minimum private (operatorArguments) = 
    inherit SymbolOperator("_minimum", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new Minimum(args)
    override this.WithArguments(args : Arguments<Symbol>) = new Minimum(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <param name="lhs">first input</param>
    /// <param name="rhs">second input</param>
    new([<Optional>] ?lhs : Symbol,
        [<Optional>] ?rhs : Symbol) = 
        let lhs = defaultArg lhs (new ImplicitVariable() :> Symbol)
        let rhs = defaultArg rhs (new ImplicitVariable() :> Symbol)
        let operatorArguments = 
            [
                "lhs", Input lhs
                "rhs", Input rhs
            ]
        new Minimum(Arguments<Symbol>(operatorArguments))
    /// first input
    member __.Lhs = operatorArguments.GetInput "lhs"
    /// second input
    member __.Rhs = operatorArguments.GetInput "rhs"
    /// <summary>Copy Minimum instance with updated inputs/parameters.</summary>
    /// <param name="lhs">first input</param>
    /// <param name="rhs">second input</param>
    member this.With([<Optional>] ?lhs : Symbol,
        [<Optional>] ?rhs : Symbol) = 
        let operatorArguments = 
            [
                lhs |> Option.map (fun x -> "lhs", Input x)
                rhs |> Option.map (fun x -> "rhs", Input x)
            ] |> List.choose id
        new Minimum(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type Hypot private (operatorArguments) = 
    inherit SymbolOperator("_hypot", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new Hypot(args)
    override this.WithArguments(args : Arguments<Symbol>) = new Hypot(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <summary>Given the &quot;legs&quot; of a right triangle, return its hypotenuse.
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\elemwise_binary_op_extended.cc:L79</summary>
    /// <param name="lhs">first input</param>
    /// <param name="rhs">second input</param>
    new([<Optional>] ?lhs : Symbol,
        [<Optional>] ?rhs : Symbol) = 
        let lhs = defaultArg lhs (new ImplicitVariable() :> Symbol)
        let rhs = defaultArg rhs (new ImplicitVariable() :> Symbol)
        let operatorArguments = 
            [
                "lhs", Input lhs
                "rhs", Input rhs
            ]
        new Hypot(Arguments<Symbol>(operatorArguments))
    /// first input
    member __.Lhs = operatorArguments.GetInput "lhs"
    /// second input
    member __.Rhs = operatorArguments.GetInput "rhs"
    /// <summary>Copy Hypot instance with updated inputs/parameters.</summary>
    /// <param name="lhs">first input</param>
    /// <param name="rhs">second input</param>
    member this.With([<Optional>] ?lhs : Symbol,
        [<Optional>] ?rhs : Symbol) = 
        let operatorArguments = 
            [
                lhs |> Option.map (fun x -> "lhs", Input x)
                rhs |> Option.map (fun x -> "rhs", Input x)
            ] |> List.choose id
        new Hypot(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type Equal private (operatorArguments) = 
    inherit SymbolOperator("_equal", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new Equal(args)
    override this.WithArguments(args : Arguments<Symbol>) = new Equal(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <param name="lhs">first input</param>
    /// <param name="rhs">second input</param>
    new([<Optional>] ?lhs : Symbol,
        [<Optional>] ?rhs : Symbol) = 
        let lhs = defaultArg lhs (new ImplicitVariable() :> Symbol)
        let rhs = defaultArg rhs (new ImplicitVariable() :> Symbol)
        let operatorArguments = 
            [
                "lhs", Input lhs
                "rhs", Input rhs
            ]
        new Equal(Arguments<Symbol>(operatorArguments))
    /// first input
    member __.Lhs = operatorArguments.GetInput "lhs"
    /// second input
    member __.Rhs = operatorArguments.GetInput "rhs"
    /// <summary>Copy Equal instance with updated inputs/parameters.</summary>
    /// <param name="lhs">first input</param>
    /// <param name="rhs">second input</param>
    member this.With([<Optional>] ?lhs : Symbol,
        [<Optional>] ?rhs : Symbol) = 
        let operatorArguments = 
            [
                lhs |> Option.map (fun x -> "lhs", Input x)
                rhs |> Option.map (fun x -> "rhs", Input x)
            ] |> List.choose id
        new Equal(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type NotEqual private (operatorArguments) = 
    inherit SymbolOperator("_not_equal", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new NotEqual(args)
    override this.WithArguments(args : Arguments<Symbol>) = new NotEqual(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <param name="lhs">first input</param>
    /// <param name="rhs">second input</param>
    new([<Optional>] ?lhs : Symbol,
        [<Optional>] ?rhs : Symbol) = 
        let lhs = defaultArg lhs (new ImplicitVariable() :> Symbol)
        let rhs = defaultArg rhs (new ImplicitVariable() :> Symbol)
        let operatorArguments = 
            [
                "lhs", Input lhs
                "rhs", Input rhs
            ]
        new NotEqual(Arguments<Symbol>(operatorArguments))
    /// first input
    member __.Lhs = operatorArguments.GetInput "lhs"
    /// second input
    member __.Rhs = operatorArguments.GetInput "rhs"
    /// <summary>Copy NotEqual instance with updated inputs/parameters.</summary>
    /// <param name="lhs">first input</param>
    /// <param name="rhs">second input</param>
    member this.With([<Optional>] ?lhs : Symbol,
        [<Optional>] ?rhs : Symbol) = 
        let operatorArguments = 
            [
                lhs |> Option.map (fun x -> "lhs", Input x)
                rhs |> Option.map (fun x -> "rhs", Input x)
            ] |> List.choose id
        new NotEqual(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type Greater private (operatorArguments) = 
    inherit SymbolOperator("_greater", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new Greater(args)
    override this.WithArguments(args : Arguments<Symbol>) = new Greater(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <param name="lhs">first input</param>
    /// <param name="rhs">second input</param>
    new([<Optional>] ?lhs : Symbol,
        [<Optional>] ?rhs : Symbol) = 
        let lhs = defaultArg lhs (new ImplicitVariable() :> Symbol)
        let rhs = defaultArg rhs (new ImplicitVariable() :> Symbol)
        let operatorArguments = 
            [
                "lhs", Input lhs
                "rhs", Input rhs
            ]
        new Greater(Arguments<Symbol>(operatorArguments))
    /// first input
    member __.Lhs = operatorArguments.GetInput "lhs"
    /// second input
    member __.Rhs = operatorArguments.GetInput "rhs"
    /// <summary>Copy Greater instance with updated inputs/parameters.</summary>
    /// <param name="lhs">first input</param>
    /// <param name="rhs">second input</param>
    member this.With([<Optional>] ?lhs : Symbol,
        [<Optional>] ?rhs : Symbol) = 
        let operatorArguments = 
            [
                lhs |> Option.map (fun x -> "lhs", Input x)
                rhs |> Option.map (fun x -> "rhs", Input x)
            ] |> List.choose id
        new Greater(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type GreaterEqual private (operatorArguments) = 
    inherit SymbolOperator("_greater_equal", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new GreaterEqual(args)
    override this.WithArguments(args : Arguments<Symbol>) = new GreaterEqual(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <param name="lhs">first input</param>
    /// <param name="rhs">second input</param>
    new([<Optional>] ?lhs : Symbol,
        [<Optional>] ?rhs : Symbol) = 
        let lhs = defaultArg lhs (new ImplicitVariable() :> Symbol)
        let rhs = defaultArg rhs (new ImplicitVariable() :> Symbol)
        let operatorArguments = 
            [
                "lhs", Input lhs
                "rhs", Input rhs
            ]
        new GreaterEqual(Arguments<Symbol>(operatorArguments))
    /// first input
    member __.Lhs = operatorArguments.GetInput "lhs"
    /// second input
    member __.Rhs = operatorArguments.GetInput "rhs"
    /// <summary>Copy GreaterEqual instance with updated inputs/parameters.</summary>
    /// <param name="lhs">first input</param>
    /// <param name="rhs">second input</param>
    member this.With([<Optional>] ?lhs : Symbol,
        [<Optional>] ?rhs : Symbol) = 
        let operatorArguments = 
            [
                lhs |> Option.map (fun x -> "lhs", Input x)
                rhs |> Option.map (fun x -> "rhs", Input x)
            ] |> List.choose id
        new GreaterEqual(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type Lesser private (operatorArguments) = 
    inherit SymbolOperator("_lesser", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new Lesser(args)
    override this.WithArguments(args : Arguments<Symbol>) = new Lesser(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <param name="lhs">first input</param>
    /// <param name="rhs">second input</param>
    new([<Optional>] ?lhs : Symbol,
        [<Optional>] ?rhs : Symbol) = 
        let lhs = defaultArg lhs (new ImplicitVariable() :> Symbol)
        let rhs = defaultArg rhs (new ImplicitVariable() :> Symbol)
        let operatorArguments = 
            [
                "lhs", Input lhs
                "rhs", Input rhs
            ]
        new Lesser(Arguments<Symbol>(operatorArguments))
    /// first input
    member __.Lhs = operatorArguments.GetInput "lhs"
    /// second input
    member __.Rhs = operatorArguments.GetInput "rhs"
    /// <summary>Copy Lesser instance with updated inputs/parameters.</summary>
    /// <param name="lhs">first input</param>
    /// <param name="rhs">second input</param>
    member this.With([<Optional>] ?lhs : Symbol,
        [<Optional>] ?rhs : Symbol) = 
        let operatorArguments = 
            [
                lhs |> Option.map (fun x -> "lhs", Input x)
                rhs |> Option.map (fun x -> "rhs", Input x)
            ] |> List.choose id
        new Lesser(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type LesserEqual private (operatorArguments) = 
    inherit SymbolOperator("_lesser_equal", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new LesserEqual(args)
    override this.WithArguments(args : Arguments<Symbol>) = new LesserEqual(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <param name="lhs">first input</param>
    /// <param name="rhs">second input</param>
    new([<Optional>] ?lhs : Symbol,
        [<Optional>] ?rhs : Symbol) = 
        let lhs = defaultArg lhs (new ImplicitVariable() :> Symbol)
        let rhs = defaultArg rhs (new ImplicitVariable() :> Symbol)
        let operatorArguments = 
            [
                "lhs", Input lhs
                "rhs", Input rhs
            ]
        new LesserEqual(Arguments<Symbol>(operatorArguments))
    /// first input
    member __.Lhs = operatorArguments.GetInput "lhs"
    /// second input
    member __.Rhs = operatorArguments.GetInput "rhs"
    /// <summary>Copy LesserEqual instance with updated inputs/parameters.</summary>
    /// <param name="lhs">first input</param>
    /// <param name="rhs">second input</param>
    member this.With([<Optional>] ?lhs : Symbol,
        [<Optional>] ?rhs : Symbol) = 
        let operatorArguments = 
            [
                lhs |> Option.map (fun x -> "lhs", Input x)
                rhs |> Option.map (fun x -> "rhs", Input x)
            ] |> List.choose id
        new LesserEqual(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type LogicalAnd private (operatorArguments) = 
    inherit SymbolOperator("_logical_and", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new LogicalAnd(args)
    override this.WithArguments(args : Arguments<Symbol>) = new LogicalAnd(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <param name="lhs">first input</param>
    /// <param name="rhs">second input</param>
    new([<Optional>] ?lhs : Symbol,
        [<Optional>] ?rhs : Symbol) = 
        let lhs = defaultArg lhs (new ImplicitVariable() :> Symbol)
        let rhs = defaultArg rhs (new ImplicitVariable() :> Symbol)
        let operatorArguments = 
            [
                "lhs", Input lhs
                "rhs", Input rhs
            ]
        new LogicalAnd(Arguments<Symbol>(operatorArguments))
    /// first input
    member __.Lhs = operatorArguments.GetInput "lhs"
    /// second input
    member __.Rhs = operatorArguments.GetInput "rhs"
    /// <summary>Copy LogicalAnd instance with updated inputs/parameters.</summary>
    /// <param name="lhs">first input</param>
    /// <param name="rhs">second input</param>
    member this.With([<Optional>] ?lhs : Symbol,
        [<Optional>] ?rhs : Symbol) = 
        let operatorArguments = 
            [
                lhs |> Option.map (fun x -> "lhs", Input x)
                rhs |> Option.map (fun x -> "rhs", Input x)
            ] |> List.choose id
        new LogicalAnd(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type LogicalOr private (operatorArguments) = 
    inherit SymbolOperator("_logical_or", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new LogicalOr(args)
    override this.WithArguments(args : Arguments<Symbol>) = new LogicalOr(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <param name="lhs">first input</param>
    /// <param name="rhs">second input</param>
    new([<Optional>] ?lhs : Symbol,
        [<Optional>] ?rhs : Symbol) = 
        let lhs = defaultArg lhs (new ImplicitVariable() :> Symbol)
        let rhs = defaultArg rhs (new ImplicitVariable() :> Symbol)
        let operatorArguments = 
            [
                "lhs", Input lhs
                "rhs", Input rhs
            ]
        new LogicalOr(Arguments<Symbol>(operatorArguments))
    /// first input
    member __.Lhs = operatorArguments.GetInput "lhs"
    /// second input
    member __.Rhs = operatorArguments.GetInput "rhs"
    /// <summary>Copy LogicalOr instance with updated inputs/parameters.</summary>
    /// <param name="lhs">first input</param>
    /// <param name="rhs">second input</param>
    member this.With([<Optional>] ?lhs : Symbol,
        [<Optional>] ?rhs : Symbol) = 
        let operatorArguments = 
            [
                lhs |> Option.map (fun x -> "lhs", Input x)
                rhs |> Option.map (fun x -> "rhs", Input x)
            ] |> List.choose id
        new LogicalOr(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type LogicalXor private (operatorArguments) = 
    inherit SymbolOperator("_logical_xor", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new LogicalXor(args)
    override this.WithArguments(args : Arguments<Symbol>) = new LogicalXor(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <param name="lhs">first input</param>
    /// <param name="rhs">second input</param>
    new([<Optional>] ?lhs : Symbol,
        [<Optional>] ?rhs : Symbol) = 
        let lhs = defaultArg lhs (new ImplicitVariable() :> Symbol)
        let rhs = defaultArg rhs (new ImplicitVariable() :> Symbol)
        let operatorArguments = 
            [
                "lhs", Input lhs
                "rhs", Input rhs
            ]
        new LogicalXor(Arguments<Symbol>(operatorArguments))
    /// first input
    member __.Lhs = operatorArguments.GetInput "lhs"
    /// second input
    member __.Rhs = operatorArguments.GetInput "rhs"
    /// <summary>Copy LogicalXor instance with updated inputs/parameters.</summary>
    /// <param name="lhs">first input</param>
    /// <param name="rhs">second input</param>
    member this.With([<Optional>] ?lhs : Symbol,
        [<Optional>] ?rhs : Symbol) = 
        let operatorArguments = 
            [
                lhs |> Option.map (fun x -> "lhs", Input x)
                rhs |> Option.map (fun x -> "rhs", Input x)
            ] |> List.choose id
        new LogicalXor(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type PlusScalar private (operatorArguments) = 
    inherit SymbolOperator("_plus_scalar", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new PlusScalar(args)
    override this.WithArguments(args : Arguments<Symbol>) = new PlusScalar(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <param name="data">source input</param>
    /// <param name="scalar">scalar input</param>
    new(data : Symbol,
        scalar : float) = 
        let operatorArguments = 
            [
                "data", Input data
                "scalar", Parameter(Some(box scalar))
            ]
        new PlusScalar(Arguments<Symbol>(operatorArguments))
    /// <param name="scalar">scalar input</param>
    /// <param name="data">source input</param>
    new(scalar : float,
        [<Optional>] ?data : Symbol) = 
        let data = defaultArg data (new ImplicitVariable() :> Symbol)
        let operatorArguments = 
            [
                "data", Input data
                "scalar", Parameter(Some(box scalar))
            ]
        new PlusScalar(Arguments<Symbol>(operatorArguments))
    /// source input
    member __.Data = operatorArguments.GetInput "data"
    /// scalar input
    member __.Scalar : float = match operatorArguments.GetParameter "scalar" with Some(v) -> unbox v | None -> failwithf "Required parameter scalar is missing"
    /// <summary>Copy PlusScalar instance with updated inputs/parameters.</summary>
    /// <param name="data">source input</param>
    /// <param name="scalar">scalar input</param>
    member this.With([<Optional>] ?data : Symbol,
        [<Optional>] ?scalar : float) = 
        let operatorArguments = 
            [
                data |> Option.map (fun x -> "data", Input x)
                scalar |> Option.map (fun x -> "scalar", Parameter(Some (box x)))
            ] |> List.choose id
        new PlusScalar(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type MinusScalar private (operatorArguments) = 
    inherit SymbolOperator("_minus_scalar", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new MinusScalar(args)
    override this.WithArguments(args : Arguments<Symbol>) = new MinusScalar(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <param name="data">source input</param>
    /// <param name="scalar">scalar input</param>
    new(data : Symbol,
        scalar : float) = 
        let operatorArguments = 
            [
                "data", Input data
                "scalar", Parameter(Some(box scalar))
            ]
        new MinusScalar(Arguments<Symbol>(operatorArguments))
    /// <param name="scalar">scalar input</param>
    /// <param name="data">source input</param>
    new(scalar : float,
        [<Optional>] ?data : Symbol) = 
        let data = defaultArg data (new ImplicitVariable() :> Symbol)
        let operatorArguments = 
            [
                "data", Input data
                "scalar", Parameter(Some(box scalar))
            ]
        new MinusScalar(Arguments<Symbol>(operatorArguments))
    /// source input
    member __.Data = operatorArguments.GetInput "data"
    /// scalar input
    member __.Scalar : float = match operatorArguments.GetParameter "scalar" with Some(v) -> unbox v | None -> failwithf "Required parameter scalar is missing"
    /// <summary>Copy MinusScalar instance with updated inputs/parameters.</summary>
    /// <param name="data">source input</param>
    /// <param name="scalar">scalar input</param>
    member this.With([<Optional>] ?data : Symbol,
        [<Optional>] ?scalar : float) = 
        let operatorArguments = 
            [
                data |> Option.map (fun x -> "data", Input x)
                scalar |> Option.map (fun x -> "scalar", Parameter(Some (box x)))
            ] |> List.choose id
        new MinusScalar(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type RminusScalar private (operatorArguments) = 
    inherit SymbolOperator("_rminus_scalar", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new RminusScalar(args)
    override this.WithArguments(args : Arguments<Symbol>) = new RminusScalar(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <param name="data">source input</param>
    /// <param name="scalar">scalar input</param>
    new(data : Symbol,
        scalar : float) = 
        let operatorArguments = 
            [
                "data", Input data
                "scalar", Parameter(Some(box scalar))
            ]
        new RminusScalar(Arguments<Symbol>(operatorArguments))
    /// <param name="scalar">scalar input</param>
    /// <param name="data">source input</param>
    new(scalar : float,
        [<Optional>] ?data : Symbol) = 
        let data = defaultArg data (new ImplicitVariable() :> Symbol)
        let operatorArguments = 
            [
                "data", Input data
                "scalar", Parameter(Some(box scalar))
            ]
        new RminusScalar(Arguments<Symbol>(operatorArguments))
    /// source input
    member __.Data = operatorArguments.GetInput "data"
    /// scalar input
    member __.Scalar : float = match operatorArguments.GetParameter "scalar" with Some(v) -> unbox v | None -> failwithf "Required parameter scalar is missing"
    /// <summary>Copy RminusScalar instance with updated inputs/parameters.</summary>
    /// <param name="data">source input</param>
    /// <param name="scalar">scalar input</param>
    member this.With([<Optional>] ?data : Symbol,
        [<Optional>] ?scalar : float) = 
        let operatorArguments = 
            [
                data |> Option.map (fun x -> "data", Input x)
                scalar |> Option.map (fun x -> "scalar", Parameter(Some (box x)))
            ] |> List.choose id
        new RminusScalar(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type MulScalar private (operatorArguments) = 
    inherit SymbolOperator("_mul_scalar", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new MulScalar(args)
    override this.WithArguments(args : Arguments<Symbol>) = new MulScalar(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <summary>Multiply an array with a scalar.
    /// 
    /// ``_mul_scalar`` only operates on data array of input if input is sparse.
    /// 
    /// For example, if input of shape (100, 100) has only 2 non zero elements,
    /// i.e. input.data = [5, 6], scalar = nan,
    /// it will result output.data = [nan, nan] instead of 10000 nans.
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\elemwise_binary_scalar_op_basic.cc:L149</summary>
    /// <param name="data">source input</param>
    /// <param name="scalar">scalar input</param>
    new(data : Symbol,
        scalar : float) = 
        let operatorArguments = 
            [
                "data", Input data
                "scalar", Parameter(Some(box scalar))
            ]
        new MulScalar(Arguments<Symbol>(operatorArguments))
    /// <summary>Multiply an array with a scalar.
    /// 
    /// ``_mul_scalar`` only operates on data array of input if input is sparse.
    /// 
    /// For example, if input of shape (100, 100) has only 2 non zero elements,
    /// i.e. input.data = [5, 6], scalar = nan,
    /// it will result output.data = [nan, nan] instead of 10000 nans.
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\elemwise_binary_scalar_op_basic.cc:L149</summary>
    /// <param name="scalar">scalar input</param>
    /// <param name="data">source input</param>
    new(scalar : float,
        [<Optional>] ?data : Symbol) = 
        let data = defaultArg data (new ImplicitVariable() :> Symbol)
        let operatorArguments = 
            [
                "data", Input data
                "scalar", Parameter(Some(box scalar))
            ]
        new MulScalar(Arguments<Symbol>(operatorArguments))
    /// source input
    member __.Data = operatorArguments.GetInput "data"
    /// scalar input
    member __.Scalar : float = match operatorArguments.GetParameter "scalar" with Some(v) -> unbox v | None -> failwithf "Required parameter scalar is missing"
    /// <summary>Copy MulScalar instance with updated inputs/parameters.</summary>
    /// <param name="data">source input</param>
    /// <param name="scalar">scalar input</param>
    member this.With([<Optional>] ?data : Symbol,
        [<Optional>] ?scalar : float) = 
        let operatorArguments = 
            [
                data |> Option.map (fun x -> "data", Input x)
                scalar |> Option.map (fun x -> "scalar", Parameter(Some (box x)))
            ] |> List.choose id
        new MulScalar(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type DivScalar private (operatorArguments) = 
    inherit SymbolOperator("_div_scalar", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new DivScalar(args)
    override this.WithArguments(args : Arguments<Symbol>) = new DivScalar(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <summary>Divide an array with a scalar.
    /// 
    /// ``_div_scalar`` only operates on data array of input if input is sparse.
    /// 
    /// For example, if input of shape (100, 100) has only 2 non zero elements,
    /// i.e. input.data = [5, 6], scalar = nan,
    /// it will result output.data = [nan, nan] instead of 10000 nans.
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\elemwise_binary_scalar_op_basic.cc:L171</summary>
    /// <param name="data">source input</param>
    /// <param name="scalar">scalar input</param>
    new(data : Symbol,
        scalar : float) = 
        let operatorArguments = 
            [
                "data", Input data
                "scalar", Parameter(Some(box scalar))
            ]
        new DivScalar(Arguments<Symbol>(operatorArguments))
    /// <summary>Divide an array with a scalar.
    /// 
    /// ``_div_scalar`` only operates on data array of input if input is sparse.
    /// 
    /// For example, if input of shape (100, 100) has only 2 non zero elements,
    /// i.e. input.data = [5, 6], scalar = nan,
    /// it will result output.data = [nan, nan] instead of 10000 nans.
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\elemwise_binary_scalar_op_basic.cc:L171</summary>
    /// <param name="scalar">scalar input</param>
    /// <param name="data">source input</param>
    new(scalar : float,
        [<Optional>] ?data : Symbol) = 
        let data = defaultArg data (new ImplicitVariable() :> Symbol)
        let operatorArguments = 
            [
                "data", Input data
                "scalar", Parameter(Some(box scalar))
            ]
        new DivScalar(Arguments<Symbol>(operatorArguments))
    /// source input
    member __.Data = operatorArguments.GetInput "data"
    /// scalar input
    member __.Scalar : float = match operatorArguments.GetParameter "scalar" with Some(v) -> unbox v | None -> failwithf "Required parameter scalar is missing"
    /// <summary>Copy DivScalar instance with updated inputs/parameters.</summary>
    /// <param name="data">source input</param>
    /// <param name="scalar">scalar input</param>
    member this.With([<Optional>] ?data : Symbol,
        [<Optional>] ?scalar : float) = 
        let operatorArguments = 
            [
                data |> Option.map (fun x -> "data", Input x)
                scalar |> Option.map (fun x -> "scalar", Parameter(Some (box x)))
            ] |> List.choose id
        new DivScalar(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type RdivScalar private (operatorArguments) = 
    inherit SymbolOperator("_rdiv_scalar", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new RdivScalar(args)
    override this.WithArguments(args : Arguments<Symbol>) = new RdivScalar(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <param name="data">source input</param>
    /// <param name="scalar">scalar input</param>
    new(data : Symbol,
        scalar : float) = 
        let operatorArguments = 
            [
                "data", Input data
                "scalar", Parameter(Some(box scalar))
            ]
        new RdivScalar(Arguments<Symbol>(operatorArguments))
    /// <param name="scalar">scalar input</param>
    /// <param name="data">source input</param>
    new(scalar : float,
        [<Optional>] ?data : Symbol) = 
        let data = defaultArg data (new ImplicitVariable() :> Symbol)
        let operatorArguments = 
            [
                "data", Input data
                "scalar", Parameter(Some(box scalar))
            ]
        new RdivScalar(Arguments<Symbol>(operatorArguments))
    /// source input
    member __.Data = operatorArguments.GetInput "data"
    /// scalar input
    member __.Scalar : float = match operatorArguments.GetParameter "scalar" with Some(v) -> unbox v | None -> failwithf "Required parameter scalar is missing"
    /// <summary>Copy RdivScalar instance with updated inputs/parameters.</summary>
    /// <param name="data">source input</param>
    /// <param name="scalar">scalar input</param>
    member this.With([<Optional>] ?data : Symbol,
        [<Optional>] ?scalar : float) = 
        let operatorArguments = 
            [
                data |> Option.map (fun x -> "data", Input x)
                scalar |> Option.map (fun x -> "scalar", Parameter(Some (box x)))
            ] |> List.choose id
        new RdivScalar(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type ModScalar private (operatorArguments) = 
    inherit SymbolOperator("_mod_scalar", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new ModScalar(args)
    override this.WithArguments(args : Arguments<Symbol>) = new ModScalar(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <param name="data">source input</param>
    /// <param name="scalar">scalar input</param>
    new(data : Symbol,
        scalar : float) = 
        let operatorArguments = 
            [
                "data", Input data
                "scalar", Parameter(Some(box scalar))
            ]
        new ModScalar(Arguments<Symbol>(operatorArguments))
    /// <param name="scalar">scalar input</param>
    /// <param name="data">source input</param>
    new(scalar : float,
        [<Optional>] ?data : Symbol) = 
        let data = defaultArg data (new ImplicitVariable() :> Symbol)
        let operatorArguments = 
            [
                "data", Input data
                "scalar", Parameter(Some(box scalar))
            ]
        new ModScalar(Arguments<Symbol>(operatorArguments))
    /// source input
    member __.Data = operatorArguments.GetInput "data"
    /// scalar input
    member __.Scalar : float = match operatorArguments.GetParameter "scalar" with Some(v) -> unbox v | None -> failwithf "Required parameter scalar is missing"
    /// <summary>Copy ModScalar instance with updated inputs/parameters.</summary>
    /// <param name="data">source input</param>
    /// <param name="scalar">scalar input</param>
    member this.With([<Optional>] ?data : Symbol,
        [<Optional>] ?scalar : float) = 
        let operatorArguments = 
            [
                data |> Option.map (fun x -> "data", Input x)
                scalar |> Option.map (fun x -> "scalar", Parameter(Some (box x)))
            ] |> List.choose id
        new ModScalar(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type RmodScalar private (operatorArguments) = 
    inherit SymbolOperator("_rmod_scalar", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new RmodScalar(args)
    override this.WithArguments(args : Arguments<Symbol>) = new RmodScalar(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <param name="data">source input</param>
    /// <param name="scalar">scalar input</param>
    new(data : Symbol,
        scalar : float) = 
        let operatorArguments = 
            [
                "data", Input data
                "scalar", Parameter(Some(box scalar))
            ]
        new RmodScalar(Arguments<Symbol>(operatorArguments))
    /// <param name="scalar">scalar input</param>
    /// <param name="data">source input</param>
    new(scalar : float,
        [<Optional>] ?data : Symbol) = 
        let data = defaultArg data (new ImplicitVariable() :> Symbol)
        let operatorArguments = 
            [
                "data", Input data
                "scalar", Parameter(Some(box scalar))
            ]
        new RmodScalar(Arguments<Symbol>(operatorArguments))
    /// source input
    member __.Data = operatorArguments.GetInput "data"
    /// scalar input
    member __.Scalar : float = match operatorArguments.GetParameter "scalar" with Some(v) -> unbox v | None -> failwithf "Required parameter scalar is missing"
    /// <summary>Copy RmodScalar instance with updated inputs/parameters.</summary>
    /// <param name="data">source input</param>
    /// <param name="scalar">scalar input</param>
    member this.With([<Optional>] ?data : Symbol,
        [<Optional>] ?scalar : float) = 
        let operatorArguments = 
            [
                data |> Option.map (fun x -> "data", Input x)
                scalar |> Option.map (fun x -> "scalar", Parameter(Some (box x)))
            ] |> List.choose id
        new RmodScalar(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type MaximumScalar private (operatorArguments) = 
    inherit SymbolOperator("_maximum_scalar", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new MaximumScalar(args)
    override this.WithArguments(args : Arguments<Symbol>) = new MaximumScalar(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <param name="data">source input</param>
    /// <param name="scalar">scalar input</param>
    new(data : Symbol,
        scalar : float) = 
        let operatorArguments = 
            [
                "data", Input data
                "scalar", Parameter(Some(box scalar))
            ]
        new MaximumScalar(Arguments<Symbol>(operatorArguments))
    /// <param name="scalar">scalar input</param>
    /// <param name="data">source input</param>
    new(scalar : float,
        [<Optional>] ?data : Symbol) = 
        let data = defaultArg data (new ImplicitVariable() :> Symbol)
        let operatorArguments = 
            [
                "data", Input data
                "scalar", Parameter(Some(box scalar))
            ]
        new MaximumScalar(Arguments<Symbol>(operatorArguments))
    /// source input
    member __.Data = operatorArguments.GetInput "data"
    /// scalar input
    member __.Scalar : float = match operatorArguments.GetParameter "scalar" with Some(v) -> unbox v | None -> failwithf "Required parameter scalar is missing"
    /// <summary>Copy MaximumScalar instance with updated inputs/parameters.</summary>
    /// <param name="data">source input</param>
    /// <param name="scalar">scalar input</param>
    member this.With([<Optional>] ?data : Symbol,
        [<Optional>] ?scalar : float) = 
        let operatorArguments = 
            [
                data |> Option.map (fun x -> "data", Input x)
                scalar |> Option.map (fun x -> "scalar", Parameter(Some (box x)))
            ] |> List.choose id
        new MaximumScalar(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type MinimumScalar private (operatorArguments) = 
    inherit SymbolOperator("_minimum_scalar", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new MinimumScalar(args)
    override this.WithArguments(args : Arguments<Symbol>) = new MinimumScalar(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <param name="data">source input</param>
    /// <param name="scalar">scalar input</param>
    new(data : Symbol,
        scalar : float) = 
        let operatorArguments = 
            [
                "data", Input data
                "scalar", Parameter(Some(box scalar))
            ]
        new MinimumScalar(Arguments<Symbol>(operatorArguments))
    /// <param name="scalar">scalar input</param>
    /// <param name="data">source input</param>
    new(scalar : float,
        [<Optional>] ?data : Symbol) = 
        let data = defaultArg data (new ImplicitVariable() :> Symbol)
        let operatorArguments = 
            [
                "data", Input data
                "scalar", Parameter(Some(box scalar))
            ]
        new MinimumScalar(Arguments<Symbol>(operatorArguments))
    /// source input
    member __.Data = operatorArguments.GetInput "data"
    /// scalar input
    member __.Scalar : float = match operatorArguments.GetParameter "scalar" with Some(v) -> unbox v | None -> failwithf "Required parameter scalar is missing"
    /// <summary>Copy MinimumScalar instance with updated inputs/parameters.</summary>
    /// <param name="data">source input</param>
    /// <param name="scalar">scalar input</param>
    member this.With([<Optional>] ?data : Symbol,
        [<Optional>] ?scalar : float) = 
        let operatorArguments = 
            [
                data |> Option.map (fun x -> "data", Input x)
                scalar |> Option.map (fun x -> "scalar", Parameter(Some (box x)))
            ] |> List.choose id
        new MinimumScalar(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type PowerScalar private (operatorArguments) = 
    inherit SymbolOperator("_power_scalar", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new PowerScalar(args)
    override this.WithArguments(args : Arguments<Symbol>) = new PowerScalar(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <param name="data">source input</param>
    /// <param name="scalar">scalar input</param>
    new(data : Symbol,
        scalar : float) = 
        let operatorArguments = 
            [
                "data", Input data
                "scalar", Parameter(Some(box scalar))
            ]
        new PowerScalar(Arguments<Symbol>(operatorArguments))
    /// <param name="scalar">scalar input</param>
    /// <param name="data">source input</param>
    new(scalar : float,
        [<Optional>] ?data : Symbol) = 
        let data = defaultArg data (new ImplicitVariable() :> Symbol)
        let operatorArguments = 
            [
                "data", Input data
                "scalar", Parameter(Some(box scalar))
            ]
        new PowerScalar(Arguments<Symbol>(operatorArguments))
    /// source input
    member __.Data = operatorArguments.GetInput "data"
    /// scalar input
    member __.Scalar : float = match operatorArguments.GetParameter "scalar" with Some(v) -> unbox v | None -> failwithf "Required parameter scalar is missing"
    /// <summary>Copy PowerScalar instance with updated inputs/parameters.</summary>
    /// <param name="data">source input</param>
    /// <param name="scalar">scalar input</param>
    member this.With([<Optional>] ?data : Symbol,
        [<Optional>] ?scalar : float) = 
        let operatorArguments = 
            [
                data |> Option.map (fun x -> "data", Input x)
                scalar |> Option.map (fun x -> "scalar", Parameter(Some (box x)))
            ] |> List.choose id
        new PowerScalar(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type RpowerScalar private (operatorArguments) = 
    inherit SymbolOperator("_rpower_scalar", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new RpowerScalar(args)
    override this.WithArguments(args : Arguments<Symbol>) = new RpowerScalar(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <param name="data">source input</param>
    /// <param name="scalar">scalar input</param>
    new(data : Symbol,
        scalar : float) = 
        let operatorArguments = 
            [
                "data", Input data
                "scalar", Parameter(Some(box scalar))
            ]
        new RpowerScalar(Arguments<Symbol>(operatorArguments))
    /// <param name="scalar">scalar input</param>
    /// <param name="data">source input</param>
    new(scalar : float,
        [<Optional>] ?data : Symbol) = 
        let data = defaultArg data (new ImplicitVariable() :> Symbol)
        let operatorArguments = 
            [
                "data", Input data
                "scalar", Parameter(Some(box scalar))
            ]
        new RpowerScalar(Arguments<Symbol>(operatorArguments))
    /// source input
    member __.Data = operatorArguments.GetInput "data"
    /// scalar input
    member __.Scalar : float = match operatorArguments.GetParameter "scalar" with Some(v) -> unbox v | None -> failwithf "Required parameter scalar is missing"
    /// <summary>Copy RpowerScalar instance with updated inputs/parameters.</summary>
    /// <param name="data">source input</param>
    /// <param name="scalar">scalar input</param>
    member this.With([<Optional>] ?data : Symbol,
        [<Optional>] ?scalar : float) = 
        let operatorArguments = 
            [
                data |> Option.map (fun x -> "data", Input x)
                scalar |> Option.map (fun x -> "scalar", Parameter(Some (box x)))
            ] |> List.choose id
        new RpowerScalar(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type HypotScalar private (operatorArguments) = 
    inherit SymbolOperator("_hypot_scalar", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new HypotScalar(args)
    override this.WithArguments(args : Arguments<Symbol>) = new HypotScalar(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <param name="data">source input</param>
    /// <param name="scalar">scalar input</param>
    new(data : Symbol,
        scalar : float) = 
        let operatorArguments = 
            [
                "data", Input data
                "scalar", Parameter(Some(box scalar))
            ]
        new HypotScalar(Arguments<Symbol>(operatorArguments))
    /// <param name="scalar">scalar input</param>
    /// <param name="data">source input</param>
    new(scalar : float,
        [<Optional>] ?data : Symbol) = 
        let data = defaultArg data (new ImplicitVariable() :> Symbol)
        let operatorArguments = 
            [
                "data", Input data
                "scalar", Parameter(Some(box scalar))
            ]
        new HypotScalar(Arguments<Symbol>(operatorArguments))
    /// source input
    member __.Data = operatorArguments.GetInput "data"
    /// scalar input
    member __.Scalar : float = match operatorArguments.GetParameter "scalar" with Some(v) -> unbox v | None -> failwithf "Required parameter scalar is missing"
    /// <summary>Copy HypotScalar instance with updated inputs/parameters.</summary>
    /// <param name="data">source input</param>
    /// <param name="scalar">scalar input</param>
    member this.With([<Optional>] ?data : Symbol,
        [<Optional>] ?scalar : float) = 
        let operatorArguments = 
            [
                data |> Option.map (fun x -> "data", Input x)
                scalar |> Option.map (fun x -> "scalar", Parameter(Some (box x)))
            ] |> List.choose id
        new HypotScalar(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type SmoothL1 private (operatorArguments) = 
    inherit SymbolOperator("smooth_l1", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new SmoothL1(args)
    override this.WithArguments(args : Arguments<Symbol>) = new SmoothL1(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <summary>Calculate Smooth L1 Loss(lhs, scalar) by summing
    /// 
    /// .. math::
    /// 
    ///     f(x) =
    ///     \begin{cases}
    ///     (\sigma x)^2/2,&amp; \text{if }x &lt; 1/\sigma^2\\
    ///     |x|-0.5/\sigma^2,&amp; \text{otherwise}
    ///     \end{cases}
    /// 
    /// where :math:`x` is an element of the tensor *lhs* and :math:`\sigma` is the scalar.
    /// 
    /// Example::
    /// 
    ///   smooth_l1([1, 2, 3, 4]) = [0.5, 1.5, 2.5, 3.5]
    ///   smooth_l1([1, 2, 3, 4], scalar=1) = [0.5, 1.5, 2.5, 3.5]
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\elemwise_binary_scalar_op_extended.cc:L108</summary>
    /// <param name="data">source input</param>
    /// <param name="scalar">scalar input</param>
    new(data : Symbol,
        scalar : float) = 
        let operatorArguments = 
            [
                "data", Input data
                "scalar", Parameter(Some(box scalar))
            ]
        new SmoothL1(Arguments<Symbol>(operatorArguments))
    /// <summary>Calculate Smooth L1 Loss(lhs, scalar) by summing
    /// 
    /// .. math::
    /// 
    ///     f(x) =
    ///     \begin{cases}
    ///     (\sigma x)^2/2,&amp; \text{if }x &lt; 1/\sigma^2\\
    ///     |x|-0.5/\sigma^2,&amp; \text{otherwise}
    ///     \end{cases}
    /// 
    /// where :math:`x` is an element of the tensor *lhs* and :math:`\sigma` is the scalar.
    /// 
    /// Example::
    /// 
    ///   smooth_l1([1, 2, 3, 4]) = [0.5, 1.5, 2.5, 3.5]
    ///   smooth_l1([1, 2, 3, 4], scalar=1) = [0.5, 1.5, 2.5, 3.5]
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\elemwise_binary_scalar_op_extended.cc:L108</summary>
    /// <param name="scalar">scalar input</param>
    /// <param name="data">source input</param>
    new(scalar : float,
        [<Optional>] ?data : Symbol) = 
        let data = defaultArg data (new ImplicitVariable() :> Symbol)
        let operatorArguments = 
            [
                "data", Input data
                "scalar", Parameter(Some(box scalar))
            ]
        new SmoothL1(Arguments<Symbol>(operatorArguments))
    /// source input
    member __.Data = operatorArguments.GetInput "data"
    /// scalar input
    member __.Scalar : float = match operatorArguments.GetParameter "scalar" with Some(v) -> unbox v | None -> failwithf "Required parameter scalar is missing"
    /// <summary>Copy SmoothL1 instance with updated inputs/parameters.</summary>
    /// <param name="data">source input</param>
    /// <param name="scalar">scalar input</param>
    member this.With([<Optional>] ?data : Symbol,
        [<Optional>] ?scalar : float) = 
        let operatorArguments = 
            [
                data |> Option.map (fun x -> "data", Input x)
                scalar |> Option.map (fun x -> "scalar", Parameter(Some (box x)))
            ] |> List.choose id
        new SmoothL1(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type EqualScalar private (operatorArguments) = 
    inherit SymbolOperator("_equal_scalar", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new EqualScalar(args)
    override this.WithArguments(args : Arguments<Symbol>) = new EqualScalar(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <param name="data">source input</param>
    /// <param name="scalar">scalar input</param>
    new(data : Symbol,
        scalar : float) = 
        let operatorArguments = 
            [
                "data", Input data
                "scalar", Parameter(Some(box scalar))
            ]
        new EqualScalar(Arguments<Symbol>(operatorArguments))
    /// <param name="scalar">scalar input</param>
    /// <param name="data">source input</param>
    new(scalar : float,
        [<Optional>] ?data : Symbol) = 
        let data = defaultArg data (new ImplicitVariable() :> Symbol)
        let operatorArguments = 
            [
                "data", Input data
                "scalar", Parameter(Some(box scalar))
            ]
        new EqualScalar(Arguments<Symbol>(operatorArguments))
    /// source input
    member __.Data = operatorArguments.GetInput "data"
    /// scalar input
    member __.Scalar : float = match operatorArguments.GetParameter "scalar" with Some(v) -> unbox v | None -> failwithf "Required parameter scalar is missing"
    /// <summary>Copy EqualScalar instance with updated inputs/parameters.</summary>
    /// <param name="data">source input</param>
    /// <param name="scalar">scalar input</param>
    member this.With([<Optional>] ?data : Symbol,
        [<Optional>] ?scalar : float) = 
        let operatorArguments = 
            [
                data |> Option.map (fun x -> "data", Input x)
                scalar |> Option.map (fun x -> "scalar", Parameter(Some (box x)))
            ] |> List.choose id
        new EqualScalar(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type NotEqualScalar private (operatorArguments) = 
    inherit SymbolOperator("_not_equal_scalar", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new NotEqualScalar(args)
    override this.WithArguments(args : Arguments<Symbol>) = new NotEqualScalar(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <param name="data">source input</param>
    /// <param name="scalar">scalar input</param>
    new(data : Symbol,
        scalar : float) = 
        let operatorArguments = 
            [
                "data", Input data
                "scalar", Parameter(Some(box scalar))
            ]
        new NotEqualScalar(Arguments<Symbol>(operatorArguments))
    /// <param name="scalar">scalar input</param>
    /// <param name="data">source input</param>
    new(scalar : float,
        [<Optional>] ?data : Symbol) = 
        let data = defaultArg data (new ImplicitVariable() :> Symbol)
        let operatorArguments = 
            [
                "data", Input data
                "scalar", Parameter(Some(box scalar))
            ]
        new NotEqualScalar(Arguments<Symbol>(operatorArguments))
    /// source input
    member __.Data = operatorArguments.GetInput "data"
    /// scalar input
    member __.Scalar : float = match operatorArguments.GetParameter "scalar" with Some(v) -> unbox v | None -> failwithf "Required parameter scalar is missing"
    /// <summary>Copy NotEqualScalar instance with updated inputs/parameters.</summary>
    /// <param name="data">source input</param>
    /// <param name="scalar">scalar input</param>
    member this.With([<Optional>] ?data : Symbol,
        [<Optional>] ?scalar : float) = 
        let operatorArguments = 
            [
                data |> Option.map (fun x -> "data", Input x)
                scalar |> Option.map (fun x -> "scalar", Parameter(Some (box x)))
            ] |> List.choose id
        new NotEqualScalar(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type GreaterScalar private (operatorArguments) = 
    inherit SymbolOperator("_greater_scalar", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new GreaterScalar(args)
    override this.WithArguments(args : Arguments<Symbol>) = new GreaterScalar(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <param name="data">source input</param>
    /// <param name="scalar">scalar input</param>
    new(data : Symbol,
        scalar : float) = 
        let operatorArguments = 
            [
                "data", Input data
                "scalar", Parameter(Some(box scalar))
            ]
        new GreaterScalar(Arguments<Symbol>(operatorArguments))
    /// <param name="scalar">scalar input</param>
    /// <param name="data">source input</param>
    new(scalar : float,
        [<Optional>] ?data : Symbol) = 
        let data = defaultArg data (new ImplicitVariable() :> Symbol)
        let operatorArguments = 
            [
                "data", Input data
                "scalar", Parameter(Some(box scalar))
            ]
        new GreaterScalar(Arguments<Symbol>(operatorArguments))
    /// source input
    member __.Data = operatorArguments.GetInput "data"
    /// scalar input
    member __.Scalar : float = match operatorArguments.GetParameter "scalar" with Some(v) -> unbox v | None -> failwithf "Required parameter scalar is missing"
    /// <summary>Copy GreaterScalar instance with updated inputs/parameters.</summary>
    /// <param name="data">source input</param>
    /// <param name="scalar">scalar input</param>
    member this.With([<Optional>] ?data : Symbol,
        [<Optional>] ?scalar : float) = 
        let operatorArguments = 
            [
                data |> Option.map (fun x -> "data", Input x)
                scalar |> Option.map (fun x -> "scalar", Parameter(Some (box x)))
            ] |> List.choose id
        new GreaterScalar(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type GreaterEqualScalar private (operatorArguments) = 
    inherit SymbolOperator("_greater_equal_scalar", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new GreaterEqualScalar(args)
    override this.WithArguments(args : Arguments<Symbol>) = new GreaterEqualScalar(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <param name="data">source input</param>
    /// <param name="scalar">scalar input</param>
    new(data : Symbol,
        scalar : float) = 
        let operatorArguments = 
            [
                "data", Input data
                "scalar", Parameter(Some(box scalar))
            ]
        new GreaterEqualScalar(Arguments<Symbol>(operatorArguments))
    /// <param name="scalar">scalar input</param>
    /// <param name="data">source input</param>
    new(scalar : float,
        [<Optional>] ?data : Symbol) = 
        let data = defaultArg data (new ImplicitVariable() :> Symbol)
        let operatorArguments = 
            [
                "data", Input data
                "scalar", Parameter(Some(box scalar))
            ]
        new GreaterEqualScalar(Arguments<Symbol>(operatorArguments))
    /// source input
    member __.Data = operatorArguments.GetInput "data"
    /// scalar input
    member __.Scalar : float = match operatorArguments.GetParameter "scalar" with Some(v) -> unbox v | None -> failwithf "Required parameter scalar is missing"
    /// <summary>Copy GreaterEqualScalar instance with updated inputs/parameters.</summary>
    /// <param name="data">source input</param>
    /// <param name="scalar">scalar input</param>
    member this.With([<Optional>] ?data : Symbol,
        [<Optional>] ?scalar : float) = 
        let operatorArguments = 
            [
                data |> Option.map (fun x -> "data", Input x)
                scalar |> Option.map (fun x -> "scalar", Parameter(Some (box x)))
            ] |> List.choose id
        new GreaterEqualScalar(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type LesserScalar private (operatorArguments) = 
    inherit SymbolOperator("_lesser_scalar", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new LesserScalar(args)
    override this.WithArguments(args : Arguments<Symbol>) = new LesserScalar(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <param name="data">source input</param>
    /// <param name="scalar">scalar input</param>
    new(data : Symbol,
        scalar : float) = 
        let operatorArguments = 
            [
                "data", Input data
                "scalar", Parameter(Some(box scalar))
            ]
        new LesserScalar(Arguments<Symbol>(operatorArguments))
    /// <param name="scalar">scalar input</param>
    /// <param name="data">source input</param>
    new(scalar : float,
        [<Optional>] ?data : Symbol) = 
        let data = defaultArg data (new ImplicitVariable() :> Symbol)
        let operatorArguments = 
            [
                "data", Input data
                "scalar", Parameter(Some(box scalar))
            ]
        new LesserScalar(Arguments<Symbol>(operatorArguments))
    /// source input
    member __.Data = operatorArguments.GetInput "data"
    /// scalar input
    member __.Scalar : float = match operatorArguments.GetParameter "scalar" with Some(v) -> unbox v | None -> failwithf "Required parameter scalar is missing"
    /// <summary>Copy LesserScalar instance with updated inputs/parameters.</summary>
    /// <param name="data">source input</param>
    /// <param name="scalar">scalar input</param>
    member this.With([<Optional>] ?data : Symbol,
        [<Optional>] ?scalar : float) = 
        let operatorArguments = 
            [
                data |> Option.map (fun x -> "data", Input x)
                scalar |> Option.map (fun x -> "scalar", Parameter(Some (box x)))
            ] |> List.choose id
        new LesserScalar(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type LesserEqualScalar private (operatorArguments) = 
    inherit SymbolOperator("_lesser_equal_scalar", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new LesserEqualScalar(args)
    override this.WithArguments(args : Arguments<Symbol>) = new LesserEqualScalar(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <param name="data">source input</param>
    /// <param name="scalar">scalar input</param>
    new(data : Symbol,
        scalar : float) = 
        let operatorArguments = 
            [
                "data", Input data
                "scalar", Parameter(Some(box scalar))
            ]
        new LesserEqualScalar(Arguments<Symbol>(operatorArguments))
    /// <param name="scalar">scalar input</param>
    /// <param name="data">source input</param>
    new(scalar : float,
        [<Optional>] ?data : Symbol) = 
        let data = defaultArg data (new ImplicitVariable() :> Symbol)
        let operatorArguments = 
            [
                "data", Input data
                "scalar", Parameter(Some(box scalar))
            ]
        new LesserEqualScalar(Arguments<Symbol>(operatorArguments))
    /// source input
    member __.Data = operatorArguments.GetInput "data"
    /// scalar input
    member __.Scalar : float = match operatorArguments.GetParameter "scalar" with Some(v) -> unbox v | None -> failwithf "Required parameter scalar is missing"
    /// <summary>Copy LesserEqualScalar instance with updated inputs/parameters.</summary>
    /// <param name="data">source input</param>
    /// <param name="scalar">scalar input</param>
    member this.With([<Optional>] ?data : Symbol,
        [<Optional>] ?scalar : float) = 
        let operatorArguments = 
            [
                data |> Option.map (fun x -> "data", Input x)
                scalar |> Option.map (fun x -> "scalar", Parameter(Some (box x)))
            ] |> List.choose id
        new LesserEqualScalar(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type LogicalAndScalar private (operatorArguments) = 
    inherit SymbolOperator("_logical_and_scalar", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new LogicalAndScalar(args)
    override this.WithArguments(args : Arguments<Symbol>) = new LogicalAndScalar(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <param name="data">source input</param>
    /// <param name="scalar">scalar input</param>
    new(data : Symbol,
        scalar : float) = 
        let operatorArguments = 
            [
                "data", Input data
                "scalar", Parameter(Some(box scalar))
            ]
        new LogicalAndScalar(Arguments<Symbol>(operatorArguments))
    /// <param name="scalar">scalar input</param>
    /// <param name="data">source input</param>
    new(scalar : float,
        [<Optional>] ?data : Symbol) = 
        let data = defaultArg data (new ImplicitVariable() :> Symbol)
        let operatorArguments = 
            [
                "data", Input data
                "scalar", Parameter(Some(box scalar))
            ]
        new LogicalAndScalar(Arguments<Symbol>(operatorArguments))
    /// source input
    member __.Data = operatorArguments.GetInput "data"
    /// scalar input
    member __.Scalar : float = match operatorArguments.GetParameter "scalar" with Some(v) -> unbox v | None -> failwithf "Required parameter scalar is missing"
    /// <summary>Copy LogicalAndScalar instance with updated inputs/parameters.</summary>
    /// <param name="data">source input</param>
    /// <param name="scalar">scalar input</param>
    member this.With([<Optional>] ?data : Symbol,
        [<Optional>] ?scalar : float) = 
        let operatorArguments = 
            [
                data |> Option.map (fun x -> "data", Input x)
                scalar |> Option.map (fun x -> "scalar", Parameter(Some (box x)))
            ] |> List.choose id
        new LogicalAndScalar(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type LogicalOrScalar private (operatorArguments) = 
    inherit SymbolOperator("_logical_or_scalar", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new LogicalOrScalar(args)
    override this.WithArguments(args : Arguments<Symbol>) = new LogicalOrScalar(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <param name="data">source input</param>
    /// <param name="scalar">scalar input</param>
    new(data : Symbol,
        scalar : float) = 
        let operatorArguments = 
            [
                "data", Input data
                "scalar", Parameter(Some(box scalar))
            ]
        new LogicalOrScalar(Arguments<Symbol>(operatorArguments))
    /// <param name="scalar">scalar input</param>
    /// <param name="data">source input</param>
    new(scalar : float,
        [<Optional>] ?data : Symbol) = 
        let data = defaultArg data (new ImplicitVariable() :> Symbol)
        let operatorArguments = 
            [
                "data", Input data
                "scalar", Parameter(Some(box scalar))
            ]
        new LogicalOrScalar(Arguments<Symbol>(operatorArguments))
    /// source input
    member __.Data = operatorArguments.GetInput "data"
    /// scalar input
    member __.Scalar : float = match operatorArguments.GetParameter "scalar" with Some(v) -> unbox v | None -> failwithf "Required parameter scalar is missing"
    /// <summary>Copy LogicalOrScalar instance with updated inputs/parameters.</summary>
    /// <param name="data">source input</param>
    /// <param name="scalar">scalar input</param>
    member this.With([<Optional>] ?data : Symbol,
        [<Optional>] ?scalar : float) = 
        let operatorArguments = 
            [
                data |> Option.map (fun x -> "data", Input x)
                scalar |> Option.map (fun x -> "scalar", Parameter(Some (box x)))
            ] |> List.choose id
        new LogicalOrScalar(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type LogicalXorScalar private (operatorArguments) = 
    inherit SymbolOperator("_logical_xor_scalar", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new LogicalXorScalar(args)
    override this.WithArguments(args : Arguments<Symbol>) = new LogicalXorScalar(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <param name="data">source input</param>
    /// <param name="scalar">scalar input</param>
    new(data : Symbol,
        scalar : float) = 
        let operatorArguments = 
            [
                "data", Input data
                "scalar", Parameter(Some(box scalar))
            ]
        new LogicalXorScalar(Arguments<Symbol>(operatorArguments))
    /// <param name="scalar">scalar input</param>
    /// <param name="data">source input</param>
    new(scalar : float,
        [<Optional>] ?data : Symbol) = 
        let data = defaultArg data (new ImplicitVariable() :> Symbol)
        let operatorArguments = 
            [
                "data", Input data
                "scalar", Parameter(Some(box scalar))
            ]
        new LogicalXorScalar(Arguments<Symbol>(operatorArguments))
    /// source input
    member __.Data = operatorArguments.GetInput "data"
    /// scalar input
    member __.Scalar : float = match operatorArguments.GetParameter "scalar" with Some(v) -> unbox v | None -> failwithf "Required parameter scalar is missing"
    /// <summary>Copy LogicalXorScalar instance with updated inputs/parameters.</summary>
    /// <param name="data">source input</param>
    /// <param name="scalar">scalar input</param>
    member this.With([<Optional>] ?data : Symbol,
        [<Optional>] ?scalar : float) = 
        let operatorArguments = 
            [
                data |> Option.map (fun x -> "data", Input x)
                scalar |> Option.map (fun x -> "scalar", Parameter(Some (box x)))
            ] |> List.choose id
        new LogicalXorScalar(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type ScatterElemwiseDiv private (operatorArguments) = 
    inherit SymbolOperator("_scatter_elemwise_div", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new ScatterElemwiseDiv(args)
    override this.WithArguments(args : Arguments<Symbol>) = new ScatterElemwiseDiv(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <summary>Divides arguments element-wise.  If the left-hand-side input is &#39;row_sparse&#39;, then
    /// only the values which exist in the left-hand sparse array are computed.  The &#39;missing&#39; values
    /// are ignored.
    /// 
    /// The storage type of ``_scatter_elemwise_div`` output depends on storage types of inputs
    /// 
    /// - _scatter_elemwise_div(row_sparse, row_sparse) = row_sparse
    /// - _scatter_elemwise_div(row_sparse, dense) = row_sparse
    /// - _scatter_elemwise_div(row_sparse, csr) = row_sparse
    /// - otherwise, ``_scatter_elemwise_div`` behaves exactly like elemwise_div and generates output
    /// with default storage
    /// 
    /// </summary>
    /// <param name="lhs">first input</param>
    /// <param name="rhs">second input</param>
    new([<Optional>] ?lhs : Symbol,
        [<Optional>] ?rhs : Symbol) = 
        let lhs = defaultArg lhs (new ImplicitVariable() :> Symbol)
        let rhs = defaultArg rhs (new ImplicitVariable() :> Symbol)
        let operatorArguments = 
            [
                "lhs", Input lhs
                "rhs", Input rhs
            ]
        new ScatterElemwiseDiv(Arguments<Symbol>(operatorArguments))
    /// first input
    member __.Lhs = operatorArguments.GetInput "lhs"
    /// second input
    member __.Rhs = operatorArguments.GetInput "rhs"
    /// <summary>Copy ScatterElemwiseDiv instance with updated inputs/parameters.</summary>
    /// <param name="lhs">first input</param>
    /// <param name="rhs">second input</param>
    member this.With([<Optional>] ?lhs : Symbol,
        [<Optional>] ?rhs : Symbol) = 
        let operatorArguments = 
            [
                lhs |> Option.map (fun x -> "lhs", Input x)
                rhs |> Option.map (fun x -> "rhs", Input x)
            ] |> List.choose id
        new ScatterElemwiseDiv(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type ScatterPlusScalar private (operatorArguments) = 
    inherit SymbolOperator("_scatter_plus_scalar", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new ScatterPlusScalar(args)
    override this.WithArguments(args : Arguments<Symbol>) = new ScatterPlusScalar(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <summary>Adds a scalar to a tensor element-wise.  If the left-hand-side input is
    /// &#39;row_sparse&#39; or &#39;csr&#39;, then only the values which exist in the left-hand sparse array are computed.
    /// The &#39;missing&#39; values are ignored.
    /// 
    /// The storage type of ``_scatter_plus_scalar`` output depends on storage types of inputs
    /// 
    /// - _scatter_plus_scalar(row_sparse, scalar) = row_sparse
    /// - _scatter_plus_scalar(csr, scalar) = csr
    /// - otherwise, ``_scatter_plus_scalar`` behaves exactly like _plus_scalar and generates output
    /// with default storage
    /// 
    /// </summary>
    /// <param name="data">source input</param>
    /// <param name="scalar">scalar input</param>
    new(data : Symbol,
        scalar : float) = 
        let operatorArguments = 
            [
                "data", Input data
                "scalar", Parameter(Some(box scalar))
            ]
        new ScatterPlusScalar(Arguments<Symbol>(operatorArguments))
    /// <summary>Adds a scalar to a tensor element-wise.  If the left-hand-side input is
    /// &#39;row_sparse&#39; or &#39;csr&#39;, then only the values which exist in the left-hand sparse array are computed.
    /// The &#39;missing&#39; values are ignored.
    /// 
    /// The storage type of ``_scatter_plus_scalar`` output depends on storage types of inputs
    /// 
    /// - _scatter_plus_scalar(row_sparse, scalar) = row_sparse
    /// - _scatter_plus_scalar(csr, scalar) = csr
    /// - otherwise, ``_scatter_plus_scalar`` behaves exactly like _plus_scalar and generates output
    /// with default storage
    /// 
    /// </summary>
    /// <param name="scalar">scalar input</param>
    /// <param name="data">source input</param>
    new(scalar : float,
        [<Optional>] ?data : Symbol) = 
        let data = defaultArg data (new ImplicitVariable() :> Symbol)
        let operatorArguments = 
            [
                "data", Input data
                "scalar", Parameter(Some(box scalar))
            ]
        new ScatterPlusScalar(Arguments<Symbol>(operatorArguments))
    /// source input
    member __.Data = operatorArguments.GetInput "data"
    /// scalar input
    member __.Scalar : float = match operatorArguments.GetParameter "scalar" with Some(v) -> unbox v | None -> failwithf "Required parameter scalar is missing"
    /// <summary>Copy ScatterPlusScalar instance with updated inputs/parameters.</summary>
    /// <param name="data">source input</param>
    /// <param name="scalar">scalar input</param>
    member this.With([<Optional>] ?data : Symbol,
        [<Optional>] ?scalar : float) = 
        let operatorArguments = 
            [
                data |> Option.map (fun x -> "data", Input x)
                scalar |> Option.map (fun x -> "scalar", Parameter(Some (box x)))
            ] |> List.choose id
        new ScatterPlusScalar(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type ScatterMinusScalar private (operatorArguments) = 
    inherit SymbolOperator("_scatter_minus_scalar", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new ScatterMinusScalar(args)
    override this.WithArguments(args : Arguments<Symbol>) = new ScatterMinusScalar(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <summary>Subtracts a scalar to a tensor element-wise.  If the left-hand-side input is
    /// &#39;row_sparse&#39; or &#39;csr&#39;, then only the values which exist in the left-hand sparse array are computed.
    /// The &#39;missing&#39; values are ignored.
    /// 
    /// The storage type of ``_scatter_minus_scalar`` output depends on storage types of inputs
    /// 
    /// - _scatter_minus_scalar(row_sparse, scalar) = row_sparse
    /// - _scatter_minus_scalar(csr, scalar) = csr
    /// - otherwise, ``_scatter_minus_scalar`` behaves exactly like _minus_scalar and generates output
    /// with default storage
    /// 
    /// </summary>
    /// <param name="data">source input</param>
    /// <param name="scalar">scalar input</param>
    new(data : Symbol,
        scalar : float) = 
        let operatorArguments = 
            [
                "data", Input data
                "scalar", Parameter(Some(box scalar))
            ]
        new ScatterMinusScalar(Arguments<Symbol>(operatorArguments))
    /// <summary>Subtracts a scalar to a tensor element-wise.  If the left-hand-side input is
    /// &#39;row_sparse&#39; or &#39;csr&#39;, then only the values which exist in the left-hand sparse array are computed.
    /// The &#39;missing&#39; values are ignored.
    /// 
    /// The storage type of ``_scatter_minus_scalar`` output depends on storage types of inputs
    /// 
    /// - _scatter_minus_scalar(row_sparse, scalar) = row_sparse
    /// - _scatter_minus_scalar(csr, scalar) = csr
    /// - otherwise, ``_scatter_minus_scalar`` behaves exactly like _minus_scalar and generates output
    /// with default storage
    /// 
    /// </summary>
    /// <param name="scalar">scalar input</param>
    /// <param name="data">source input</param>
    new(scalar : float,
        [<Optional>] ?data : Symbol) = 
        let data = defaultArg data (new ImplicitVariable() :> Symbol)
        let operatorArguments = 
            [
                "data", Input data
                "scalar", Parameter(Some(box scalar))
            ]
        new ScatterMinusScalar(Arguments<Symbol>(operatorArguments))
    /// source input
    member __.Data = operatorArguments.GetInput "data"
    /// scalar input
    member __.Scalar : float = match operatorArguments.GetParameter "scalar" with Some(v) -> unbox v | None -> failwithf "Required parameter scalar is missing"
    /// <summary>Copy ScatterMinusScalar instance with updated inputs/parameters.</summary>
    /// <param name="data">source input</param>
    /// <param name="scalar">scalar input</param>
    member this.With([<Optional>] ?data : Symbol,
        [<Optional>] ?scalar : float) = 
        let operatorArguments = 
            [
                data |> Option.map (fun x -> "data", Input x)
                scalar |> Option.map (fun x -> "scalar", Parameter(Some (box x)))
            ] |> List.choose id
        new ScatterMinusScalar(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type AddN private (operatorArguments) = 
    inherit SymbolOperator("add_n", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new AddN(args)
    override this.WithArguments(args : Arguments<Symbol>) = new AddN(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <summary>Adds all input arguments element-wise.
    /// 
    /// .. math::
    ///    add\_n(a_1, a_2, ..., a_n) = a_1 + a_2 + ... + a_n
    /// 
    /// ``add_n`` is potentially more efficient than calling ``add`` by `n` times.
    /// 
    /// The storage type of ``add_n`` output depends on storage types of inputs
    /// 
    /// - add_n(row_sparse, row_sparse, ..) = row_sparse
    /// - add_n(default, csr, default) = default
    /// - add_n(any input combinations longer than 4 (&gt;4) with at least one default type) = default
    /// - otherwise, ``add_n`` falls all inputs back to default storage and generates default storage
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\elemwise_sum.cc:L155</summary>
    /// <param name="args">Positional input arguments</param>
    new([<ParamArray>] args : Symbol[]) =
        let operatorArguments = 
            [
                "args", VarArg("num_args", args)
            ]
        new AddN(Arguments<Symbol>(operatorArguments))
    /// Positional input arguments
    member __.Args = operatorArguments.GetVarArg "args"
    /// <summary>Copy AddN instance with updated inputs/parameters.</summary>
    /// <param name="args">Positional input arguments</param>
    member this.With([<Optional>] ?args : Symbol seq) =
        let operatorArguments = 
            [
                args |> Option.map (fun x -> "args", VarArg("num_args", Seq.toArray x))
            ] |> List.choose id
        new AddN(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type Relu private (operatorArguments) = 
    inherit SymbolOperator("relu", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new Relu(args)
    override this.WithArguments(args : Arguments<Symbol>) = new Relu(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <summary>Computes rectified linear activation.
    /// 
    /// .. math::
    ///    max(features, 0)
    /// 
    /// The storage type of ``relu`` output depends upon the input storage type:
    /// 
    ///    - relu(default) = default
    ///    - relu(row_sparse) = row_sparse
    ///    - relu(csr) = csr
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\elemwise_unary_op_basic.cc:L85</summary>
    /// <param name="data">The input array.</param>
    new([<Optional>] ?data : Symbol) =
        let data = defaultArg data (new ImplicitVariable() :> Symbol)
        let operatorArguments = 
            [
                "data", Input data
            ]
        new Relu(Arguments<Symbol>(operatorArguments))
    /// The input array.
    member __.Data = operatorArguments.GetInput "data"
    /// <summary>Copy Relu instance with updated inputs/parameters.</summary>
    /// <param name="data">The input array.</param>
    member this.With([<Optional>] ?data : Symbol) =
        let operatorArguments = 
            [
                data |> Option.map (fun x -> "data", Input x)
            ] |> List.choose id
        new Relu(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type Sigmoid private (operatorArguments) = 
    inherit SymbolOperator("sigmoid", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new Sigmoid(args)
    override this.WithArguments(args : Arguments<Symbol>) = new Sigmoid(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <summary>Computes sigmoid of x element-wise.
    /// 
    /// .. math::
    ///    y = 1 / (1 + exp(-x))
    /// 
    /// The storage type of ``sigmoid`` output is always dense
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\elemwise_unary_op_basic.cc:L119</summary>
    /// <param name="data">The input array.</param>
    new([<Optional>] ?data : Symbol) =
        let data = defaultArg data (new ImplicitVariable() :> Symbol)
        let operatorArguments = 
            [
                "data", Input data
            ]
        new Sigmoid(Arguments<Symbol>(operatorArguments))
    /// The input array.
    member __.Data = operatorArguments.GetInput "data"
    /// <summary>Copy Sigmoid instance with updated inputs/parameters.</summary>
    /// <param name="data">The input array.</param>
    member this.With([<Optional>] ?data : Symbol) =
        let operatorArguments = 
            [
                data |> Option.map (fun x -> "data", Input x)
            ] |> List.choose id
        new Sigmoid(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type HardSigmoid private (operatorArguments) = 
    inherit SymbolOperator("hard_sigmoid", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new HardSigmoid(args)
    override this.WithArguments(args : Arguments<Symbol>) = new HardSigmoid(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <summary>Computes hard sigmoid of x element-wise.
    /// 
    /// .. math::
    ///    y = max(0, min(1, alpha * x + beta))
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\elemwise_unary_op_basic.cc:L161</summary>
    /// <param name="data">The input array.</param>
    /// <param name="alpha">Slope of hard sigmoid</param>
    /// <param name="beta">Bias of hard sigmoid.</param>
    new([<Optional>] ?data : Symbol,
        [<Optional>] ?alpha : float,
        [<Optional>] ?beta : float) = 
        let data = defaultArg data (new ImplicitVariable() :> Symbol)
        let operatorArguments = 
            [
                "data", Input data
                "alpha", alpha |> Option.map box |> Parameter
                "beta", beta |> Option.map box |> Parameter
            ]
        new HardSigmoid(Arguments<Symbol>(operatorArguments))
    /// Default value for Alpha
    /// Slope of hard sigmoid
    static member AlphaDefault : double = 0.200000003
    /// Default value for Beta
    /// Bias of hard sigmoid.
    static member BetaDefault : double = 0.5
    /// The input array.
    member __.Data = operatorArguments.GetInput "data"
    /// Slope of hard sigmoid
    member __.Alpha = operatorArguments.GetParameter("alpha", HardSigmoid.AlphaDefault)
    /// Bias of hard sigmoid.
    member __.Beta = operatorArguments.GetParameter("beta", HardSigmoid.BetaDefault)
    /// <summary>Copy HardSigmoid instance with updated inputs/parameters.</summary>
    /// <param name="data">The input array.</param>
    /// <param name="alpha">Slope of hard sigmoid</param>
    /// <param name="beta">Bias of hard sigmoid.</param>
    member this.With([<Optional>] ?data : Symbol,
        [<Optional>] ?alpha : float,
        [<Optional>] ?beta : float) = 
        let operatorArguments = 
            [
                data |> Option.map (fun x -> "data", Input x)
                alpha |> Option.map (fun x -> "alpha", Parameter(Some (box x)))
                beta |> Option.map (fun x -> "beta", Parameter(Some (box x)))
            ] |> List.choose id
        new HardSigmoid(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type Softsign private (operatorArguments) = 
    inherit SymbolOperator("softsign", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new Softsign(args)
    override this.WithArguments(args : Arguments<Symbol>) = new Softsign(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <summary>Computes softsign of x element-wise.
    /// 
    /// .. math::
    ///    y = x / (1 + abs(x))
    /// 
    /// The storage type of ``softsign`` output is always dense
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\elemwise_unary_op_basic.cc:L191</summary>
    /// <param name="data">The input array.</param>
    new([<Optional>] ?data : Symbol) =
        let data = defaultArg data (new ImplicitVariable() :> Symbol)
        let operatorArguments = 
            [
                "data", Input data
            ]
        new Softsign(Arguments<Symbol>(operatorArguments))
    /// The input array.
    member __.Data = operatorArguments.GetInput "data"
    /// <summary>Copy Softsign instance with updated inputs/parameters.</summary>
    /// <param name="data">The input array.</param>
    member this.With([<Optional>] ?data : Symbol) =
        let operatorArguments = 
            [
                data |> Option.map (fun x -> "data", Input x)
            ] |> List.choose id
        new Softsign(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type Copy private (operatorArguments) = 
    inherit SymbolOperator("_copy", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new Copy(args)
    override this.WithArguments(args : Arguments<Symbol>) = new Copy(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <summary>Returns a copy of the input.
    /// 
    /// From:C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\elemwise_unary_op_basic.cc:246</summary>
    /// <param name="data">The input array.</param>
    new([<Optional>] ?data : Symbol) =
        let data = defaultArg data (new ImplicitVariable() :> Symbol)
        let operatorArguments = 
            [
                "data", Input data
            ]
        new Copy(Arguments<Symbol>(operatorArguments))
    /// The input array.
    member __.Data = operatorArguments.GetInput "data"
    /// <summary>Copy Copy instance with updated inputs/parameters.</summary>
    /// <param name="data">The input array.</param>
    member this.With([<Optional>] ?data : Symbol) =
        let operatorArguments = 
            [
                data |> Option.map (fun x -> "data", Input x)
            ] |> List.choose id
        new Copy(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type BlockGrad private (operatorArguments) = 
    inherit SymbolOperator("BlockGrad", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new BlockGrad(args)
    override this.WithArguments(args : Arguments<Symbol>) = new BlockGrad(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <summary>Stops gradient computation.
    /// 
    /// Stops the accumulated gradient of the inputs from flowing through this operator
    /// in the backward direction. In other words, this operator prevents the contribution
    /// of its inputs to be taken into account for computing gradients.
    /// 
    /// Example::
    /// 
    ///   v1 = [1, 2]
    ///   v2 = [0, 1]
    ///   a = Variable(&#39;a&#39;)
    ///   b = Variable(&#39;b&#39;)
    ///   b_stop_grad = stop_gradient(3 * b)
    ///   loss = MakeLoss(b_stop_grad + a)
    /// 
    ///   executor = loss.simple_bind(ctx=cpu(), a=(1,2), b=(1,2))
    ///   executor.forward(is_train=True, a=v1, b=v2)
    ///   executor.outputs
    ///   [ 1.  5.]
    /// 
    ///   executor.backward()
    ///   executor.grad_arrays
    ///   [ 0.  0.]
    ///   [ 1.  1.]
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\elemwise_unary_op_basic.cc:L327</summary>
    /// <param name="data">The input array.</param>
    new([<Optional>] ?data : Symbol) =
        let data = defaultArg data (new ImplicitVariable() :> Symbol)
        let operatorArguments = 
            [
                "data", Input data
            ]
        new BlockGrad(Arguments<Symbol>(operatorArguments))
    /// The input array.
    member __.Data = operatorArguments.GetInput "data"
    /// <summary>Copy BlockGrad instance with updated inputs/parameters.</summary>
    /// <param name="data">The input array.</param>
    member this.With([<Optional>] ?data : Symbol) =
        let operatorArguments = 
            [
                data |> Option.map (fun x -> "data", Input x)
            ] |> List.choose id
        new BlockGrad(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type IdentityWithAttrLikeRhs private (operatorArguments) = 
    inherit SymbolOperator("_identity_with_attr_like_rhs", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new IdentityWithAttrLikeRhs(args)
    override this.WithArguments(args : Arguments<Symbol>) = new IdentityWithAttrLikeRhs(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <param name="lhs">First input.</param>
    /// <param name="rhs">Second input.</param>
    new([<Optional>] ?lhs : Symbol,
        [<Optional>] ?rhs : Symbol) = 
        let lhs = defaultArg lhs (new ImplicitVariable() :> Symbol)
        let rhs = defaultArg rhs (new ImplicitVariable() :> Symbol)
        let operatorArguments = 
            [
                "lhs", Input lhs
                "rhs", Input rhs
            ]
        new IdentityWithAttrLikeRhs(Arguments<Symbol>(operatorArguments))
    /// First input.
    member __.Lhs = operatorArguments.GetInput "lhs"
    /// Second input.
    member __.Rhs = operatorArguments.GetInput "rhs"
    /// <summary>Copy IdentityWithAttrLikeRhs instance with updated inputs/parameters.</summary>
    /// <param name="lhs">First input.</param>
    /// <param name="rhs">Second input.</param>
    member this.With([<Optional>] ?lhs : Symbol,
        [<Optional>] ?rhs : Symbol) = 
        let operatorArguments = 
            [
                lhs |> Option.map (fun x -> "lhs", Input x)
                rhs |> Option.map (fun x -> "rhs", Input x)
            ] |> List.choose id
        new IdentityWithAttrLikeRhs(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type ReshapeLike private (operatorArguments) = 
    inherit SymbolOperator("reshape_like", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new ReshapeLike(args)
    override this.WithArguments(args : Arguments<Symbol>) = new ReshapeLike(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <summary>Reshape some or all dimensions of `lhs` to have the same shape as some or all dimensions of `rhs`.
    /// 
    /// Returns a **view** of the `lhs` array with a new shape without altering any data.
    /// 
    /// Example::
    /// 
    ///   x = [1, 2, 3, 4, 5, 6]
    ///   y = [[0, -4], [3, 2], [2, 2]]
    ///   reshape_like(x, y) = [[1, 2], [3, 4], [5, 6]]
    /// 
    /// More precise control over how dimensions are inherited is achieved by specifying \
    /// slices over the `lhs` and `rhs` array dimensions. Only the sliced `lhs` dimensions \
    /// are reshaped to the `rhs` sliced dimensions, with the non-sliced `lhs` dimensions staying the same.
    /// 
    ///   Examples::
    /// 
    ///   - lhs shape = (30,7), rhs shape = (15,2,4), lhs_begin=0, lhs_end=1, rhs_begin=0, rhs_end=2, output shape = (15,2,7)
    ///   - lhs shape = (3, 5), rhs shape = (1,15,4), lhs_begin=0, lhs_end=2, rhs_begin=1, rhs_end=2, output shape = (15)
    /// 
    /// Negative indices are supported, and `None` can be used for either `lhs_end` or `rhs_end` to indicate the end of the range.
    /// 
    ///   Example::
    /// 
    ///   - lhs shape = (30, 12), rhs shape = (4, 2, 2, 3), lhs_begin=-1, lhs_end=None, rhs_begin=1, rhs_end=None, output shape = (30, 2, 2, 3)
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\elemwise_unary_op_basic.cc:L513</summary>
    /// <param name="lhs">First input.</param>
    /// <param name="rhs">Second input.</param>
    /// <param name="lhsBegin">Defaults to 0. The beginning index along which the lhs dimensions are to be reshaped. Supports negative indices.</param>
    /// <param name="lhsEnd">Defaults to None. The ending index along which the lhs dimensions are to be used for reshaping. Supports negative indices.</param>
    /// <param name="rhsBegin">Defaults to 0. The beginning index along which the rhs dimensions are to be used for reshaping. Supports negative indices.</param>
    /// <param name="rhsEnd">Defaults to None. The ending index along which the rhs dimensions are to be used for reshaping. Supports negative indices.</param>
    new([<Optional>] ?lhs : Symbol,
        [<Optional>] ?rhs : Symbol,
        [<Optional>] ?lhsBegin : int,
        [<Optional>] ?lhsEnd : int,
        [<Optional>] ?rhsBegin : int,
        [<Optional>] ?rhsEnd : int) = 
        let lhs = defaultArg lhs (new ImplicitVariable() :> Symbol)
        let rhs = defaultArg rhs (new ImplicitVariable() :> Symbol)
        let operatorArguments = 
            [
                "lhs", Input lhs
                "rhs", Input rhs
                "lhs_begin", lhsBegin |> Option.map box |> Parameter
                "lhs_end", lhsEnd |> Option.map box |> Parameter
                "rhs_begin", rhsBegin |> Option.map box |> Parameter
                "rhs_end", rhsEnd |> Option.map box |> Parameter
            ]
        new ReshapeLike(Arguments<Symbol>(operatorArguments))
    /// Default value for LhsBegin
    /// Defaults to 0. The beginning index along which the lhs dimensions are to be reshaped. Supports negative indices.
    static member LhsBeginDefault : int option = None
    /// Default value for LhsEnd
    /// Defaults to None. The ending index along which the lhs dimensions are to be used for reshaping. Supports negative indices.
    static member LhsEndDefault : int option = None
    /// Default value for RhsBegin
    /// Defaults to 0. The beginning index along which the rhs dimensions are to be used for reshaping. Supports negative indices.
    static member RhsBeginDefault : int option = None
    /// Default value for RhsEnd
    /// Defaults to None. The ending index along which the rhs dimensions are to be used for reshaping. Supports negative indices.
    static member RhsEndDefault : int option = None
    /// First input.
    member __.Lhs = operatorArguments.GetInput "lhs"
    /// Second input.
    member __.Rhs = operatorArguments.GetInput "rhs"
    /// Defaults to 0. The beginning index along which the lhs dimensions are to be reshaped. Supports negative indices.
    member __.LhsBegin = operatorArguments.GetParameter("lhs_begin", ReshapeLike.LhsBeginDefault)
    /// Defaults to None. The ending index along which the lhs dimensions are to be used for reshaping. Supports negative indices.
    member __.LhsEnd = operatorArguments.GetParameter("lhs_end", ReshapeLike.LhsEndDefault)
    /// Defaults to 0. The beginning index along which the rhs dimensions are to be used for reshaping. Supports negative indices.
    member __.RhsBegin = operatorArguments.GetParameter("rhs_begin", ReshapeLike.RhsBeginDefault)
    /// Defaults to None. The ending index along which the rhs dimensions are to be used for reshaping. Supports negative indices.
    member __.RhsEnd = operatorArguments.GetParameter("rhs_end", ReshapeLike.RhsEndDefault)
    /// <summary>Copy ReshapeLike instance with updated inputs/parameters.</summary>
    /// <param name="lhs">First input.</param>
    /// <param name="rhs">Second input.</param>
    /// <param name="lhsBegin">Defaults to 0. The beginning index along which the lhs dimensions are to be reshaped. Supports negative indices.</param>
    /// <param name="lhsEnd">Defaults to None. The ending index along which the lhs dimensions are to be used for reshaping. Supports negative indices.</param>
    /// <param name="rhsBegin">Defaults to 0. The beginning index along which the rhs dimensions are to be used for reshaping. Supports negative indices.</param>
    /// <param name="rhsEnd">Defaults to None. The ending index along which the rhs dimensions are to be used for reshaping. Supports negative indices.</param>
    member this.With([<Optional>] ?lhs : Symbol,
        [<Optional>] ?rhs : Symbol,
        [<Optional>] ?lhsBegin : int,
        [<Optional>] ?lhsEnd : int,
        [<Optional>] ?rhsBegin : int,
        [<Optional>] ?rhsEnd : int) = 
        let operatorArguments = 
            [
                lhs |> Option.map (fun x -> "lhs", Input x)
                rhs |> Option.map (fun x -> "rhs", Input x)
                lhsBegin |> Option.map (fun x -> "lhs_begin", Parameter(Some (box x)))
                lhsEnd |> Option.map (fun x -> "lhs_end", Parameter(Some (box x)))
                rhsBegin |> Option.map (fun x -> "rhs_begin", Parameter(Some (box x)))
                rhsEnd |> Option.map (fun x -> "rhs_end", Parameter(Some (box x)))
            ] |> List.choose id
        new ReshapeLike(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type ShapeArray private (operatorArguments) = 
    inherit SymbolOperator("shape_array", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new ShapeArray(args)
    override this.WithArguments(args : Arguments<Symbol>) = new ShapeArray(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <summary>Returns a 1D int64 array containing the shape of data.
    /// 
    /// Example::
    /// 
    ///   shape_array([[1,2,3,4], [5,6,7,8]]) = [2,4]
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\elemwise_unary_op_basic.cc:L574</summary>
    /// <param name="data">Input Array.</param>
    new([<Optional>] ?data : Symbol) =
        let data = defaultArg data (new ImplicitVariable() :> Symbol)
        let operatorArguments = 
            [
                "data", Input data
            ]
        new ShapeArray(Arguments<Symbol>(operatorArguments))
    /// Input Array.
    member __.Data = operatorArguments.GetInput "data"
    /// <summary>Copy ShapeArray instance with updated inputs/parameters.</summary>
    /// <param name="data">Input Array.</param>
    member this.With([<Optional>] ?data : Symbol) =
        let operatorArguments = 
            [
                data |> Option.map (fun x -> "data", Input x)
            ] |> List.choose id
        new ShapeArray(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type SizeArray private (operatorArguments) = 
    inherit SymbolOperator("size_array", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new SizeArray(args)
    override this.WithArguments(args : Arguments<Symbol>) = new SizeArray(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <summary>Returns a 1D int64 array containing the size of data.
    /// 
    /// Example::
    /// 
    ///   size_array([[1,2,3,4], [5,6,7,8]]) = [8]
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\elemwise_unary_op_basic.cc:L625</summary>
    /// <param name="data">Input Array.</param>
    new([<Optional>] ?data : Symbol) =
        let data = defaultArg data (new ImplicitVariable() :> Symbol)
        let operatorArguments = 
            [
                "data", Input data
            ]
        new SizeArray(Arguments<Symbol>(operatorArguments))
    /// Input Array.
    member __.Data = operatorArguments.GetInput "data"
    /// <summary>Copy SizeArray instance with updated inputs/parameters.</summary>
    /// <param name="data">Input Array.</param>
    member this.With([<Optional>] ?data : Symbol) =
        let operatorArguments = 
            [
                data |> Option.map (fun x -> "data", Input x)
            ] |> List.choose id
        new SizeArray(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type Cast private (operatorArguments) = 
    inherit SymbolOperator("Cast", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new Cast(args)
    override this.WithArguments(args : Arguments<Symbol>) = new Cast(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <summary>Casts all elements of the input to a new type.
    /// 
    /// .. note:: ``Cast`` is deprecated. Use ``cast`` instead.
    /// 
    /// Example::
    /// 
    ///    cast([0.9, 1.3], dtype=&#39;int32&#39;) = [0, 1]
    ///    cast([1e20, 11.1], dtype=&#39;float16&#39;) = [inf, 11.09375]
    ///    cast([300, 11.1, 10.9, -1, -3], dtype=&#39;uint8&#39;) = [44, 11, 10, 255, 253]
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\elemwise_unary_op_basic.cc:L664</summary>
    /// <param name="data">The input.</param>
    /// <param name="dtype">Output data type.</param>
    new(data : Symbol,
        dtype : IntOrFloatDType) = 
        let operatorArguments = 
            [
                "data", Input data
                "dtype", Parameter(Some(box dtype))
            ]
        new Cast(Arguments<Symbol>(operatorArguments))
    /// <summary>Casts all elements of the input to a new type.
    /// 
    /// .. note:: ``Cast`` is deprecated. Use ``cast`` instead.
    /// 
    /// Example::
    /// 
    ///    cast([0.9, 1.3], dtype=&#39;int32&#39;) = [0, 1]
    ///    cast([1e20, 11.1], dtype=&#39;float16&#39;) = [inf, 11.09375]
    ///    cast([300, 11.1, 10.9, -1, -3], dtype=&#39;uint8&#39;) = [44, 11, 10, 255, 253]
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\elemwise_unary_op_basic.cc:L664</summary>
    /// <param name="dtype">Output data type.</param>
    /// <param name="data">The input.</param>
    new(dtype : IntOrFloatDType,
        [<Optional>] ?data : Symbol) = 
        let data = defaultArg data (new ImplicitVariable() :> Symbol)
        let operatorArguments = 
            [
                "data", Input data
                "dtype", Parameter(Some(box dtype))
            ]
        new Cast(Arguments<Symbol>(operatorArguments))
    /// The input.
    member __.Data = operatorArguments.GetInput "data"
    /// Output data type.
    member __.Dtype : IntOrFloatDType = match operatorArguments.GetParameter "dtype" with Some(v) -> unbox v | None -> failwithf "Required parameter dtype is missing"
    /// <summary>Copy Cast instance with updated inputs/parameters.</summary>
    /// <param name="data">The input.</param>
    /// <param name="dtype">Output data type.</param>
    member this.With([<Optional>] ?data : Symbol,
        [<Optional>] ?dtype : IntOrFloatDType) = 
        let operatorArguments = 
            [
                data |> Option.map (fun x -> "data", Input x)
                dtype |> Option.map (fun x -> "dtype", Parameter(Some (box x)))
            ] |> List.choose id
        new Cast(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type Negative private (operatorArguments) = 
    inherit SymbolOperator("negative", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new Negative(args)
    override this.WithArguments(args : Arguments<Symbol>) = new Negative(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <summary>Numerical negative of the argument, element-wise.
    /// 
    /// The storage type of ``negative`` output depends upon the input storage type:
    /// 
    ///    - negative(default) = default
    ///    - negative(row_sparse) = row_sparse
    ///    - negative(csr) = csr
    /// 
    /// </summary>
    /// <param name="data">The input array.</param>
    new([<Optional>] ?data : Symbol) =
        let data = defaultArg data (new ImplicitVariable() :> Symbol)
        let operatorArguments = 
            [
                "data", Input data
            ]
        new Negative(Arguments<Symbol>(operatorArguments))
    /// The input array.
    member __.Data = operatorArguments.GetInput "data"
    /// <summary>Copy Negative instance with updated inputs/parameters.</summary>
    /// <param name="data">The input array.</param>
    member this.With([<Optional>] ?data : Symbol) =
        let operatorArguments = 
            [
                data |> Option.map (fun x -> "data", Input x)
            ] |> List.choose id
        new Negative(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type Abs private (operatorArguments) = 
    inherit SymbolOperator("abs", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new Abs(args)
    override this.WithArguments(args : Arguments<Symbol>) = new Abs(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <summary>Returns element-wise absolute value of the input.
    /// 
    /// Example::
    /// 
    ///    abs([-2, 0, 3]) = [2, 0, 3]
    /// 
    /// The storage type of ``abs`` output depends upon the input storage type:
    /// 
    ///    - abs(default) = default
    ///    - abs(row_sparse) = row_sparse
    ///    - abs(csr) = csr
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\elemwise_unary_op_basic.cc:L720</summary>
    /// <param name="data">The input array.</param>
    new([<Optional>] ?data : Symbol) =
        let data = defaultArg data (new ImplicitVariable() :> Symbol)
        let operatorArguments = 
            [
                "data", Input data
            ]
        new Abs(Arguments<Symbol>(operatorArguments))
    /// The input array.
    member __.Data = operatorArguments.GetInput "data"
    /// <summary>Copy Abs instance with updated inputs/parameters.</summary>
    /// <param name="data">The input array.</param>
    member this.With([<Optional>] ?data : Symbol) =
        let operatorArguments = 
            [
                data |> Option.map (fun x -> "data", Input x)
            ] |> List.choose id
        new Abs(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type Sign private (operatorArguments) = 
    inherit SymbolOperator("sign", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new Sign(args)
    override this.WithArguments(args : Arguments<Symbol>) = new Sign(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <summary>Returns element-wise sign of the input.
    /// 
    /// Example::
    /// 
    ///    sign([-2, 0, 3]) = [-1, 0, 1]
    /// 
    /// The storage type of ``sign`` output depends upon the input storage type:
    /// 
    ///    - sign(default) = default
    ///    - sign(row_sparse) = row_sparse
    ///    - sign(csr) = csr
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\elemwise_unary_op_basic.cc:L758</summary>
    /// <param name="data">The input array.</param>
    new([<Optional>] ?data : Symbol) =
        let data = defaultArg data (new ImplicitVariable() :> Symbol)
        let operatorArguments = 
            [
                "data", Input data
            ]
        new Sign(Arguments<Symbol>(operatorArguments))
    /// The input array.
    member __.Data = operatorArguments.GetInput "data"
    /// <summary>Copy Sign instance with updated inputs/parameters.</summary>
    /// <param name="data">The input array.</param>
    member this.With([<Optional>] ?data : Symbol) =
        let operatorArguments = 
            [
                data |> Option.map (fun x -> "data", Input x)
            ] |> List.choose id
        new Sign(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type Round private (operatorArguments) = 
    inherit SymbolOperator("round", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new Round(args)
    override this.WithArguments(args : Arguments<Symbol>) = new Round(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <summary>Returns element-wise rounded value to the nearest integer of the input.
    /// 
    /// Example::
    /// 
    ///    round([-1.5, 1.5, -1.9, 1.9, 2.1]) = [-2.,  2., -2.,  2.,  2.]
    /// 
    /// The storage type of ``round`` output depends upon the input storage type:
    /// 
    ///   - round(default) = default
    ///   - round(row_sparse) = row_sparse
    ///   - round(csr) = csr
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\elemwise_unary_op_basic.cc:L777</summary>
    /// <param name="data">The input array.</param>
    new([<Optional>] ?data : Symbol) =
        let data = defaultArg data (new ImplicitVariable() :> Symbol)
        let operatorArguments = 
            [
                "data", Input data
            ]
        new Round(Arguments<Symbol>(operatorArguments))
    /// The input array.
    member __.Data = operatorArguments.GetInput "data"
    /// <summary>Copy Round instance with updated inputs/parameters.</summary>
    /// <param name="data">The input array.</param>
    member this.With([<Optional>] ?data : Symbol) =
        let operatorArguments = 
            [
                data |> Option.map (fun x -> "data", Input x)
            ] |> List.choose id
        new Round(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type Rint private (operatorArguments) = 
    inherit SymbolOperator("rint", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new Rint(args)
    override this.WithArguments(args : Arguments<Symbol>) = new Rint(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <summary>Returns element-wise rounded value to the nearest integer of the input.
    /// 
    /// .. note::
    ///    - For input ``n.5`` ``rint`` returns ``n`` while ``round`` returns ``n+1``.
    ///    - For input ``-n.5`` both ``rint`` and ``round`` returns ``-n-1``.
    /// 
    /// Example::
    /// 
    ///    rint([-1.5, 1.5, -1.9, 1.9, 2.1]) = [-2.,  1., -2.,  2.,  2.]
    /// 
    /// The storage type of ``rint`` output depends upon the input storage type:
    /// 
    ///    - rint(default) = default
    ///    - rint(row_sparse) = row_sparse
    ///    - rint(csr) = csr
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\elemwise_unary_op_basic.cc:L798</summary>
    /// <param name="data">The input array.</param>
    new([<Optional>] ?data : Symbol) =
        let data = defaultArg data (new ImplicitVariable() :> Symbol)
        let operatorArguments = 
            [
                "data", Input data
            ]
        new Rint(Arguments<Symbol>(operatorArguments))
    /// The input array.
    member __.Data = operatorArguments.GetInput "data"
    /// <summary>Copy Rint instance with updated inputs/parameters.</summary>
    /// <param name="data">The input array.</param>
    member this.With([<Optional>] ?data : Symbol) =
        let operatorArguments = 
            [
                data |> Option.map (fun x -> "data", Input x)
            ] |> List.choose id
        new Rint(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type Ceil private (operatorArguments) = 
    inherit SymbolOperator("ceil", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new Ceil(args)
    override this.WithArguments(args : Arguments<Symbol>) = new Ceil(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <summary>Returns element-wise ceiling of the input.
    /// 
    /// The ceil of the scalar x is the smallest integer i, such that i &gt;= x.
    /// 
    /// Example::
    /// 
    ///    ceil([-2.1, -1.9, 1.5, 1.9, 2.1]) = [-2., -1.,  2.,  2.,  3.]
    /// 
    /// The storage type of ``ceil`` output depends upon the input storage type:
    /// 
    ///    - ceil(default) = default
    ///    - ceil(row_sparse) = row_sparse
    ///    - ceil(csr) = csr
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\elemwise_unary_op_basic.cc:L817</summary>
    /// <param name="data">The input array.</param>
    new([<Optional>] ?data : Symbol) =
        let data = defaultArg data (new ImplicitVariable() :> Symbol)
        let operatorArguments = 
            [
                "data", Input data
            ]
        new Ceil(Arguments<Symbol>(operatorArguments))
    /// The input array.
    member __.Data = operatorArguments.GetInput "data"
    /// <summary>Copy Ceil instance with updated inputs/parameters.</summary>
    /// <param name="data">The input array.</param>
    member this.With([<Optional>] ?data : Symbol) =
        let operatorArguments = 
            [
                data |> Option.map (fun x -> "data", Input x)
            ] |> List.choose id
        new Ceil(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type Floor private (operatorArguments) = 
    inherit SymbolOperator("floor", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new Floor(args)
    override this.WithArguments(args : Arguments<Symbol>) = new Floor(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <summary>Returns element-wise floor of the input.
    /// 
    /// The floor of the scalar x is the largest integer i, such that i &lt;= x.
    /// 
    /// Example::
    /// 
    ///    floor([-2.1, -1.9, 1.5, 1.9, 2.1]) = [-3., -2.,  1.,  1.,  2.]
    /// 
    /// The storage type of ``floor`` output depends upon the input storage type:
    /// 
    ///    - floor(default) = default
    ///    - floor(row_sparse) = row_sparse
    ///    - floor(csr) = csr
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\elemwise_unary_op_basic.cc:L836</summary>
    /// <param name="data">The input array.</param>
    new([<Optional>] ?data : Symbol) =
        let data = defaultArg data (new ImplicitVariable() :> Symbol)
        let operatorArguments = 
            [
                "data", Input data
            ]
        new Floor(Arguments<Symbol>(operatorArguments))
    /// The input array.
    member __.Data = operatorArguments.GetInput "data"
    /// <summary>Copy Floor instance with updated inputs/parameters.</summary>
    /// <param name="data">The input array.</param>
    member this.With([<Optional>] ?data : Symbol) =
        let operatorArguments = 
            [
                data |> Option.map (fun x -> "data", Input x)
            ] |> List.choose id
        new Floor(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type Trunc private (operatorArguments) = 
    inherit SymbolOperator("trunc", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new Trunc(args)
    override this.WithArguments(args : Arguments<Symbol>) = new Trunc(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <summary>Return the element-wise truncated value of the input.
    /// 
    /// The truncated value of the scalar x is the nearest integer i which is closer to
    /// zero than x is. In short, the fractional part of the signed number x is discarded.
    /// 
    /// Example::
    /// 
    ///    trunc([-2.1, -1.9, 1.5, 1.9, 2.1]) = [-2., -1.,  1.,  1.,  2.]
    /// 
    /// The storage type of ``trunc`` output depends upon the input storage type:
    /// 
    ///    - trunc(default) = default
    ///    - trunc(row_sparse) = row_sparse
    ///    - trunc(csr) = csr
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\elemwise_unary_op_basic.cc:L856</summary>
    /// <param name="data">The input array.</param>
    new([<Optional>] ?data : Symbol) =
        let data = defaultArg data (new ImplicitVariable() :> Symbol)
        let operatorArguments = 
            [
                "data", Input data
            ]
        new Trunc(Arguments<Symbol>(operatorArguments))
    /// The input array.
    member __.Data = operatorArguments.GetInput "data"
    /// <summary>Copy Trunc instance with updated inputs/parameters.</summary>
    /// <param name="data">The input array.</param>
    member this.With([<Optional>] ?data : Symbol) =
        let operatorArguments = 
            [
                data |> Option.map (fun x -> "data", Input x)
            ] |> List.choose id
        new Trunc(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type Fix private (operatorArguments) = 
    inherit SymbolOperator("fix", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new Fix(args)
    override this.WithArguments(args : Arguments<Symbol>) = new Fix(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <summary>Returns element-wise rounded value to the nearest \
    /// integer towards zero of the input.
    /// 
    /// Example::
    /// 
    ///    fix([-2.1, -1.9, 1.9, 2.1]) = [-2., -1.,  1., 2.]
    /// 
    /// The storage type of ``fix`` output depends upon the input storage type:
    /// 
    ///    - fix(default) = default
    ///    - fix(row_sparse) = row_sparse
    ///    - fix(csr) = csr
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\elemwise_unary_op_basic.cc:L874</summary>
    /// <param name="data">The input array.</param>
    new([<Optional>] ?data : Symbol) =
        let data = defaultArg data (new ImplicitVariable() :> Symbol)
        let operatorArguments = 
            [
                "data", Input data
            ]
        new Fix(Arguments<Symbol>(operatorArguments))
    /// The input array.
    member __.Data = operatorArguments.GetInput "data"
    /// <summary>Copy Fix instance with updated inputs/parameters.</summary>
    /// <param name="data">The input array.</param>
    member this.With([<Optional>] ?data : Symbol) =
        let operatorArguments = 
            [
                data |> Option.map (fun x -> "data", Input x)
            ] |> List.choose id
        new Fix(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type Erf private (operatorArguments) = 
    inherit SymbolOperator("erf", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new Erf(args)
    override this.WithArguments(args : Arguments<Symbol>) = new Erf(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <summary>Returns element-wise gauss error function of the input.
    /// 
    /// Example::
    /// 
    ///    erf([0, -1., 10.]) = [0., -0.8427, 1.]
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\elemwise_unary_op_basic.cc:L885</summary>
    /// <param name="data">The input array.</param>
    new([<Optional>] ?data : Symbol) =
        let data = defaultArg data (new ImplicitVariable() :> Symbol)
        let operatorArguments = 
            [
                "data", Input data
            ]
        new Erf(Arguments<Symbol>(operatorArguments))
    /// The input array.
    member __.Data = operatorArguments.GetInput "data"
    /// <summary>Copy Erf instance with updated inputs/parameters.</summary>
    /// <param name="data">The input array.</param>
    member this.With([<Optional>] ?data : Symbol) =
        let operatorArguments = 
            [
                data |> Option.map (fun x -> "data", Input x)
            ] |> List.choose id
        new Erf(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type Erfinv private (operatorArguments) = 
    inherit SymbolOperator("erfinv", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new Erfinv(args)
    override this.WithArguments(args : Arguments<Symbol>) = new Erfinv(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <summary>Returns element-wise inverse gauss error function of the input.
    /// 
    /// Example::
    /// 
    ///    erfinv([0, 0.5., -1.]) = [0., 0.4769, -inf]
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\elemwise_unary_op_basic.cc:L906</summary>
    /// <param name="data">The input array.</param>
    new([<Optional>] ?data : Symbol) =
        let data = defaultArg data (new ImplicitVariable() :> Symbol)
        let operatorArguments = 
            [
                "data", Input data
            ]
        new Erfinv(Arguments<Symbol>(operatorArguments))
    /// The input array.
    member __.Data = operatorArguments.GetInput "data"
    /// <summary>Copy Erfinv instance with updated inputs/parameters.</summary>
    /// <param name="data">The input array.</param>
    member this.With([<Optional>] ?data : Symbol) =
        let operatorArguments = 
            [
                data |> Option.map (fun x -> "data", Input x)
            ] |> List.choose id
        new Erfinv(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type Gamma private (operatorArguments) = 
    inherit SymbolOperator("gamma", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new Gamma(args)
    override this.WithArguments(args : Arguments<Symbol>) = new Gamma(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <summary>Returns the gamma function (extension of the factorial function \
    /// to the reals), computed element-wise on the input array.
    /// 
    /// The storage type of ``gamma`` output is always dense
    /// 
    /// </summary>
    /// <param name="data">The input array.</param>
    new([<Optional>] ?data : Symbol) =
        let data = defaultArg data (new ImplicitVariable() :> Symbol)
        let operatorArguments = 
            [
                "data", Input data
            ]
        new Gamma(Arguments<Symbol>(operatorArguments))
    /// The input array.
    member __.Data = operatorArguments.GetInput "data"
    /// <summary>Copy Gamma instance with updated inputs/parameters.</summary>
    /// <param name="data">The input array.</param>
    member this.With([<Optional>] ?data : Symbol) =
        let operatorArguments = 
            [
                data |> Option.map (fun x -> "data", Input x)
            ] |> List.choose id
        new Gamma(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type Gammaln private (operatorArguments) = 
    inherit SymbolOperator("gammaln", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new Gammaln(args)
    override this.WithArguments(args : Arguments<Symbol>) = new Gammaln(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <summary>Returns element-wise log of the absolute value of the gamma function \
    /// of the input.
    /// 
    /// The storage type of ``gammaln`` output is always dense
    /// 
    /// </summary>
    /// <param name="data">The input array.</param>
    new([<Optional>] ?data : Symbol) =
        let data = defaultArg data (new ImplicitVariable() :> Symbol)
        let operatorArguments = 
            [
                "data", Input data
            ]
        new Gammaln(Arguments<Symbol>(operatorArguments))
    /// The input array.
    member __.Data = operatorArguments.GetInput "data"
    /// <summary>Copy Gammaln instance with updated inputs/parameters.</summary>
    /// <param name="data">The input array.</param>
    member this.With([<Optional>] ?data : Symbol) =
        let operatorArguments = 
            [
                data |> Option.map (fun x -> "data", Input x)
            ] |> List.choose id
        new Gammaln(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type LogicalNot private (operatorArguments) = 
    inherit SymbolOperator("logical_not", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new LogicalNot(args)
    override this.WithArguments(args : Arguments<Symbol>) = new LogicalNot(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <summary>Returns the result of logical NOT (!) function
    /// 
    /// Example:
    ///   logical_not([-2., 0., 1.]) = [0., 1., 0.]
    /// 
    /// </summary>
    /// <param name="data">The input array.</param>
    new([<Optional>] ?data : Symbol) =
        let data = defaultArg data (new ImplicitVariable() :> Symbol)
        let operatorArguments = 
            [
                "data", Input data
            ]
        new LogicalNot(Arguments<Symbol>(operatorArguments))
    /// The input array.
    member __.Data = operatorArguments.GetInput "data"
    /// <summary>Copy LogicalNot instance with updated inputs/parameters.</summary>
    /// <param name="data">The input array.</param>
    member this.With([<Optional>] ?data : Symbol) =
        let operatorArguments = 
            [
                data |> Option.map (fun x -> "data", Input x)
            ] |> List.choose id
        new LogicalNot(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type Exp private (operatorArguments) = 
    inherit SymbolOperator("exp", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new Exp(args)
    override this.WithArguments(args : Arguments<Symbol>) = new Exp(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <summary>Returns element-wise exponential value of the input.
    /// 
    /// .. math::
    ///    exp(x) = e^x \approx 2.718^x
    /// 
    /// Example::
    /// 
    ///    exp([0, 1, 2]) = [1., 2.71828175, 7.38905621]
    /// 
    /// The storage type of ``exp`` output is always dense
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\elemwise_unary_op_logexp.cc:L63</summary>
    /// <param name="data">The input array.</param>
    new([<Optional>] ?data : Symbol) =
        let data = defaultArg data (new ImplicitVariable() :> Symbol)
        let operatorArguments = 
            [
                "data", Input data
            ]
        new Exp(Arguments<Symbol>(operatorArguments))
    /// The input array.
    member __.Data = operatorArguments.GetInput "data"
    /// <summary>Copy Exp instance with updated inputs/parameters.</summary>
    /// <param name="data">The input array.</param>
    member this.With([<Optional>] ?data : Symbol) =
        let operatorArguments = 
            [
                data |> Option.map (fun x -> "data", Input x)
            ] |> List.choose id
        new Exp(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type Log private (operatorArguments) = 
    inherit SymbolOperator("log", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new Log(args)
    override this.WithArguments(args : Arguments<Symbol>) = new Log(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <summary>Returns element-wise Natural logarithmic value of the input.
    /// 
    /// The natural logarithm is logarithm in base *e*, so that ``log(exp(x)) = x``
    /// 
    /// The storage type of ``log`` output is always dense
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\elemwise_unary_op_logexp.cc:L76</summary>
    /// <param name="data">The input array.</param>
    new([<Optional>] ?data : Symbol) =
        let data = defaultArg data (new ImplicitVariable() :> Symbol)
        let operatorArguments = 
            [
                "data", Input data
            ]
        new Log(Arguments<Symbol>(operatorArguments))
    /// The input array.
    member __.Data = operatorArguments.GetInput "data"
    /// <summary>Copy Log instance with updated inputs/parameters.</summary>
    /// <param name="data">The input array.</param>
    member this.With([<Optional>] ?data : Symbol) =
        let operatorArguments = 
            [
                data |> Option.map (fun x -> "data", Input x)
            ] |> List.choose id
        new Log(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type Log10 private (operatorArguments) = 
    inherit SymbolOperator("log10", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new Log10(args)
    override this.WithArguments(args : Arguments<Symbol>) = new Log10(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <summary>Returns element-wise Base-10 logarithmic value of the input.
    /// 
    /// ``10**log10(x) = x``
    /// 
    /// The storage type of ``log10`` output is always dense
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\elemwise_unary_op_logexp.cc:L93</summary>
    /// <param name="data">The input array.</param>
    new([<Optional>] ?data : Symbol) =
        let data = defaultArg data (new ImplicitVariable() :> Symbol)
        let operatorArguments = 
            [
                "data", Input data
            ]
        new Log10(Arguments<Symbol>(operatorArguments))
    /// The input array.
    member __.Data = operatorArguments.GetInput "data"
    /// <summary>Copy Log10 instance with updated inputs/parameters.</summary>
    /// <param name="data">The input array.</param>
    member this.With([<Optional>] ?data : Symbol) =
        let operatorArguments = 
            [
                data |> Option.map (fun x -> "data", Input x)
            ] |> List.choose id
        new Log10(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type Log2 private (operatorArguments) = 
    inherit SymbolOperator("log2", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new Log2(args)
    override this.WithArguments(args : Arguments<Symbol>) = new Log2(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <summary>Returns element-wise Base-2 logarithmic value of the input.
    /// 
    /// ``2**log2(x) = x``
    /// 
    /// The storage type of ``log2`` output is always dense
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\elemwise_unary_op_logexp.cc:L105</summary>
    /// <param name="data">The input array.</param>
    new([<Optional>] ?data : Symbol) =
        let data = defaultArg data (new ImplicitVariable() :> Symbol)
        let operatorArguments = 
            [
                "data", Input data
            ]
        new Log2(Arguments<Symbol>(operatorArguments))
    /// The input array.
    member __.Data = operatorArguments.GetInput "data"
    /// <summary>Copy Log2 instance with updated inputs/parameters.</summary>
    /// <param name="data">The input array.</param>
    member this.With([<Optional>] ?data : Symbol) =
        let operatorArguments = 
            [
                data |> Option.map (fun x -> "data", Input x)
            ] |> List.choose id
        new Log2(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type Log1p private (operatorArguments) = 
    inherit SymbolOperator("log1p", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new Log1p(args)
    override this.WithArguments(args : Arguments<Symbol>) = new Log1p(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <summary>Returns element-wise ``log(1 + x)`` value of the input.
    /// 
    /// This function is more accurate than ``log(1 + x)``  for small ``x`` so that
    /// :math:`1+x\approx 1`
    /// 
    /// The storage type of ``log1p`` output depends upon the input storage type:
    /// 
    ///    - log1p(default) = default
    ///    - log1p(row_sparse) = row_sparse
    ///    - log1p(csr) = csr
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\elemwise_unary_op_logexp.cc:L206</summary>
    /// <param name="data">The input array.</param>
    new([<Optional>] ?data : Symbol) =
        let data = defaultArg data (new ImplicitVariable() :> Symbol)
        let operatorArguments = 
            [
                "data", Input data
            ]
        new Log1p(Arguments<Symbol>(operatorArguments))
    /// The input array.
    member __.Data = operatorArguments.GetInput "data"
    /// <summary>Copy Log1p instance with updated inputs/parameters.</summary>
    /// <param name="data">The input array.</param>
    member this.With([<Optional>] ?data : Symbol) =
        let operatorArguments = 
            [
                data |> Option.map (fun x -> "data", Input x)
            ] |> List.choose id
        new Log1p(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type Expm1 private (operatorArguments) = 
    inherit SymbolOperator("expm1", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new Expm1(args)
    override this.WithArguments(args : Arguments<Symbol>) = new Expm1(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <summary>Returns ``exp(x) - 1`` computed element-wise on the input.
    /// 
    /// This function provides greater precision than ``exp(x) - 1`` for small values of ``x``.
    /// 
    /// The storage type of ``expm1`` output depends upon the input storage type:
    /// 
    ///    - expm1(default) = default
    ///    - expm1(row_sparse) = row_sparse
    ///    - expm1(csr) = csr
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\elemwise_unary_op_logexp.cc:L224</summary>
    /// <param name="data">The input array.</param>
    new([<Optional>] ?data : Symbol) =
        let data = defaultArg data (new ImplicitVariable() :> Symbol)
        let operatorArguments = 
            [
                "data", Input data
            ]
        new Expm1(Arguments<Symbol>(operatorArguments))
    /// The input array.
    member __.Data = operatorArguments.GetInput "data"
    /// <summary>Copy Expm1 instance with updated inputs/parameters.</summary>
    /// <param name="data">The input array.</param>
    member this.With([<Optional>] ?data : Symbol) =
        let operatorArguments = 
            [
                data |> Option.map (fun x -> "data", Input x)
            ] |> List.choose id
        new Expm1(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type Reciprocal private (operatorArguments) = 
    inherit SymbolOperator("reciprocal", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new Reciprocal(args)
    override this.WithArguments(args : Arguments<Symbol>) = new Reciprocal(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <summary>Returns the reciprocal of the argument, element-wise.
    /// 
    /// Calculates 1/x.
    /// 
    /// Example::
    /// 
    ///     reciprocal([-2, 1, 3, 1.6, 0.2]) = [-0.5, 1.0, 0.33333334, 0.625, 5.0]
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\elemwise_unary_op_pow.cc:L42</summary>
    /// <param name="data">The input array.</param>
    new([<Optional>] ?data : Symbol) =
        let data = defaultArg data (new ImplicitVariable() :> Symbol)
        let operatorArguments = 
            [
                "data", Input data
            ]
        new Reciprocal(Arguments<Symbol>(operatorArguments))
    /// The input array.
    member __.Data = operatorArguments.GetInput "data"
    /// <summary>Copy Reciprocal instance with updated inputs/parameters.</summary>
    /// <param name="data">The input array.</param>
    member this.With([<Optional>] ?data : Symbol) =
        let operatorArguments = 
            [
                data |> Option.map (fun x -> "data", Input x)
            ] |> List.choose id
        new Reciprocal(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type Square private (operatorArguments) = 
    inherit SymbolOperator("square", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new Square(args)
    override this.WithArguments(args : Arguments<Symbol>) = new Square(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <summary>Returns element-wise squared value of the input.
    /// 
    /// .. math::
    ///    square(x) = x^2
    /// 
    /// Example::
    /// 
    ///    square([2, 3, 4]) = [4, 9, 16]
    /// 
    /// The storage type of ``square`` output depends upon the input storage type:
    /// 
    ///    - square(default) = default
    ///    - square(row_sparse) = row_sparse
    ///    - square(csr) = csr
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\elemwise_unary_op_pow.cc:L118</summary>
    /// <param name="data">The input array.</param>
    new([<Optional>] ?data : Symbol) =
        let data = defaultArg data (new ImplicitVariable() :> Symbol)
        let operatorArguments = 
            [
                "data", Input data
            ]
        new Square(Arguments<Symbol>(operatorArguments))
    /// The input array.
    member __.Data = operatorArguments.GetInput "data"
    /// <summary>Copy Square instance with updated inputs/parameters.</summary>
    /// <param name="data">The input array.</param>
    member this.With([<Optional>] ?data : Symbol) =
        let operatorArguments = 
            [
                data |> Option.map (fun x -> "data", Input x)
            ] |> List.choose id
        new Square(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type Sqrt private (operatorArguments) = 
    inherit SymbolOperator("sqrt", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new Sqrt(args)
    override this.WithArguments(args : Arguments<Symbol>) = new Sqrt(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <summary>Returns element-wise square-root value of the input.
    /// 
    /// .. math::
    ///    \textrm{sqrt}(x) = \sqrt{x}
    /// 
    /// Example::
    /// 
    ///    sqrt([4, 9, 16]) = [2, 3, 4]
    /// 
    /// The storage type of ``sqrt`` output depends upon the input storage type:
    /// 
    ///    - sqrt(default) = default
    ///    - sqrt(row_sparse) = row_sparse
    ///    - sqrt(csr) = csr
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\elemwise_unary_op_pow.cc:L142</summary>
    /// <param name="data">The input array.</param>
    new([<Optional>] ?data : Symbol) =
        let data = defaultArg data (new ImplicitVariable() :> Symbol)
        let operatorArguments = 
            [
                "data", Input data
            ]
        new Sqrt(Arguments<Symbol>(operatorArguments))
    /// The input array.
    member __.Data = operatorArguments.GetInput "data"
    /// <summary>Copy Sqrt instance with updated inputs/parameters.</summary>
    /// <param name="data">The input array.</param>
    member this.With([<Optional>] ?data : Symbol) =
        let operatorArguments = 
            [
                data |> Option.map (fun x -> "data", Input x)
            ] |> List.choose id
        new Sqrt(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type Rsqrt private (operatorArguments) = 
    inherit SymbolOperator("rsqrt", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new Rsqrt(args)
    override this.WithArguments(args : Arguments<Symbol>) = new Rsqrt(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <summary>Returns element-wise inverse square-root value of the input.
    /// 
    /// .. math::
    ///    rsqrt(x) = 1/\sqrt{x}
    /// 
    /// Example::
    /// 
    ///    rsqrt([4,9,16]) = [0.5, 0.33333334, 0.25]
    /// 
    /// The storage type of ``rsqrt`` output is always dense
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\elemwise_unary_op_pow.cc:L193</summary>
    /// <param name="data">The input array.</param>
    new([<Optional>] ?data : Symbol) =
        let data = defaultArg data (new ImplicitVariable() :> Symbol)
        let operatorArguments = 
            [
                "data", Input data
            ]
        new Rsqrt(Arguments<Symbol>(operatorArguments))
    /// The input array.
    member __.Data = operatorArguments.GetInput "data"
    /// <summary>Copy Rsqrt instance with updated inputs/parameters.</summary>
    /// <param name="data">The input array.</param>
    member this.With([<Optional>] ?data : Symbol) =
        let operatorArguments = 
            [
                data |> Option.map (fun x -> "data", Input x)
            ] |> List.choose id
        new Rsqrt(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type Cbrt private (operatorArguments) = 
    inherit SymbolOperator("cbrt", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new Cbrt(args)
    override this.WithArguments(args : Arguments<Symbol>) = new Cbrt(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <summary>Returns element-wise cube-root value of the input.
    /// 
    /// .. math::
    ///    cbrt(x) = \sqrt[3]{x}
    /// 
    /// Example::
    /// 
    ///    cbrt([1, 8, -125]) = [1, 2, -5]
    /// 
    /// The storage type of ``cbrt`` output depends upon the input storage type:
    /// 
    ///    - cbrt(default) = default
    ///    - cbrt(row_sparse) = row_sparse
    ///    - cbrt(csr) = csr
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\elemwise_unary_op_pow.cc:L216</summary>
    /// <param name="data">The input array.</param>
    new([<Optional>] ?data : Symbol) =
        let data = defaultArg data (new ImplicitVariable() :> Symbol)
        let operatorArguments = 
            [
                "data", Input data
            ]
        new Cbrt(Arguments<Symbol>(operatorArguments))
    /// The input array.
    member __.Data = operatorArguments.GetInput "data"
    /// <summary>Copy Cbrt instance with updated inputs/parameters.</summary>
    /// <param name="data">The input array.</param>
    member this.With([<Optional>] ?data : Symbol) =
        let operatorArguments = 
            [
                data |> Option.map (fun x -> "data", Input x)
            ] |> List.choose id
        new Cbrt(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type Rcbrt private (operatorArguments) = 
    inherit SymbolOperator("rcbrt", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new Rcbrt(args)
    override this.WithArguments(args : Arguments<Symbol>) = new Rcbrt(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <summary>Returns element-wise inverse cube-root value of the input.
    /// 
    /// .. math::
    ///    rcbrt(x) = 1/\sqrt[3]{x}
    /// 
    /// Example::
    /// 
    ///    rcbrt([1,8,-125]) = [1.0, 0.5, -0.2]
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\elemwise_unary_op_pow.cc:L269</summary>
    /// <param name="data">The input array.</param>
    new([<Optional>] ?data : Symbol) =
        let data = defaultArg data (new ImplicitVariable() :> Symbol)
        let operatorArguments = 
            [
                "data", Input data
            ]
        new Rcbrt(Arguments<Symbol>(operatorArguments))
    /// The input array.
    member __.Data = operatorArguments.GetInput "data"
    /// <summary>Copy Rcbrt instance with updated inputs/parameters.</summary>
    /// <param name="data">The input array.</param>
    member this.With([<Optional>] ?data : Symbol) =
        let operatorArguments = 
            [
                data |> Option.map (fun x -> "data", Input x)
            ] |> List.choose id
        new Rcbrt(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type Sin private (operatorArguments) = 
    inherit SymbolOperator("sin", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new Sin(args)
    override this.WithArguments(args : Arguments<Symbol>) = new Sin(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <summary>Computes the element-wise sine of the input array.
    /// 
    /// The input should be in radians (:math:`2\pi` rad equals 360 degrees).
    /// 
    /// .. math::
    ///    sin([0, \pi/4, \pi/2]) = [0, 0.707, 1]
    /// 
    /// The storage type of ``sin`` output depends upon the input storage type:
    /// 
    ///    - sin(default) = default
    ///    - sin(row_sparse) = row_sparse
    ///    - sin(csr) = csr
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\elemwise_unary_op_trig.cc:L47</summary>
    /// <param name="data">The input array.</param>
    new([<Optional>] ?data : Symbol) =
        let data = defaultArg data (new ImplicitVariable() :> Symbol)
        let operatorArguments = 
            [
                "data", Input data
            ]
        new Sin(Arguments<Symbol>(operatorArguments))
    /// The input array.
    member __.Data = operatorArguments.GetInput "data"
    /// <summary>Copy Sin instance with updated inputs/parameters.</summary>
    /// <param name="data">The input array.</param>
    member this.With([<Optional>] ?data : Symbol) =
        let operatorArguments = 
            [
                data |> Option.map (fun x -> "data", Input x)
            ] |> List.choose id
        new Sin(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type Cos private (operatorArguments) = 
    inherit SymbolOperator("cos", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new Cos(args)
    override this.WithArguments(args : Arguments<Symbol>) = new Cos(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <summary>Computes the element-wise cosine of the input array.
    /// 
    /// The input should be in radians (:math:`2\pi` rad equals 360 degrees).
    /// 
    /// .. math::
    ///    cos([0, \pi/4, \pi/2]) = [1, 0.707, 0]
    /// 
    /// The storage type of ``cos`` output is always dense
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\elemwise_unary_op_trig.cc:L90</summary>
    /// <param name="data">The input array.</param>
    new([<Optional>] ?data : Symbol) =
        let data = defaultArg data (new ImplicitVariable() :> Symbol)
        let operatorArguments = 
            [
                "data", Input data
            ]
        new Cos(Arguments<Symbol>(operatorArguments))
    /// The input array.
    member __.Data = operatorArguments.GetInput "data"
    /// <summary>Copy Cos instance with updated inputs/parameters.</summary>
    /// <param name="data">The input array.</param>
    member this.With([<Optional>] ?data : Symbol) =
        let operatorArguments = 
            [
                data |> Option.map (fun x -> "data", Input x)
            ] |> List.choose id
        new Cos(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type Tan private (operatorArguments) = 
    inherit SymbolOperator("tan", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new Tan(args)
    override this.WithArguments(args : Arguments<Symbol>) = new Tan(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <summary>Computes the element-wise tangent of the input array.
    /// 
    /// The input should be in radians (:math:`2\pi` rad equals 360 degrees).
    /// 
    /// .. math::
    ///    tan([0, \pi/4, \pi/2]) = [0, 1, -inf]
    /// 
    /// The storage type of ``tan`` output depends upon the input storage type:
    /// 
    ///    - tan(default) = default
    ///    - tan(row_sparse) = row_sparse
    ///    - tan(csr) = csr
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\elemwise_unary_op_trig.cc:L140</summary>
    /// <param name="data">The input array.</param>
    new([<Optional>] ?data : Symbol) =
        let data = defaultArg data (new ImplicitVariable() :> Symbol)
        let operatorArguments = 
            [
                "data", Input data
            ]
        new Tan(Arguments<Symbol>(operatorArguments))
    /// The input array.
    member __.Data = operatorArguments.GetInput "data"
    /// <summary>Copy Tan instance with updated inputs/parameters.</summary>
    /// <param name="data">The input array.</param>
    member this.With([<Optional>] ?data : Symbol) =
        let operatorArguments = 
            [
                data |> Option.map (fun x -> "data", Input x)
            ] |> List.choose id
        new Tan(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type Arcsin private (operatorArguments) = 
    inherit SymbolOperator("arcsin", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new Arcsin(args)
    override this.WithArguments(args : Arguments<Symbol>) = new Arcsin(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <summary>Returns element-wise inverse sine of the input array.
    /// 
    /// The input should be in the range `[-1, 1]`.
    /// The output is in the closed interval of [:math:`-\pi/2`, :math:`\pi/2`].
    /// 
    /// .. math::
    ///    arcsin([-1, -.707, 0, .707, 1]) = [-\pi/2, -\pi/4, 0, \pi/4, \pi/2]
    /// 
    /// The storage type of ``arcsin`` output depends upon the input storage type:
    /// 
    ///    - arcsin(default) = default
    ///    - arcsin(row_sparse) = row_sparse
    ///    - arcsin(csr) = csr
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\elemwise_unary_op_trig.cc:L187</summary>
    /// <param name="data">The input array.</param>
    new([<Optional>] ?data : Symbol) =
        let data = defaultArg data (new ImplicitVariable() :> Symbol)
        let operatorArguments = 
            [
                "data", Input data
            ]
        new Arcsin(Arguments<Symbol>(operatorArguments))
    /// The input array.
    member __.Data = operatorArguments.GetInput "data"
    /// <summary>Copy Arcsin instance with updated inputs/parameters.</summary>
    /// <param name="data">The input array.</param>
    member this.With([<Optional>] ?data : Symbol) =
        let operatorArguments = 
            [
                data |> Option.map (fun x -> "data", Input x)
            ] |> List.choose id
        new Arcsin(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type Arccos private (operatorArguments) = 
    inherit SymbolOperator("arccos", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new Arccos(args)
    override this.WithArguments(args : Arguments<Symbol>) = new Arccos(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <summary>Returns element-wise inverse cosine of the input array.
    /// 
    /// The input should be in range `[-1, 1]`.
    /// The output is in the closed interval :math:`[0, \pi]`
    /// 
    /// .. math::
    ///    arccos([-1, -.707, 0, .707, 1]) = [\pi, 3\pi/4, \pi/2, \pi/4, 0]
    /// 
    /// The storage type of ``arccos`` output is always dense
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\elemwise_unary_op_trig.cc:L206</summary>
    /// <param name="data">The input array.</param>
    new([<Optional>] ?data : Symbol) =
        let data = defaultArg data (new ImplicitVariable() :> Symbol)
        let operatorArguments = 
            [
                "data", Input data
            ]
        new Arccos(Arguments<Symbol>(operatorArguments))
    /// The input array.
    member __.Data = operatorArguments.GetInput "data"
    /// <summary>Copy Arccos instance with updated inputs/parameters.</summary>
    /// <param name="data">The input array.</param>
    member this.With([<Optional>] ?data : Symbol) =
        let operatorArguments = 
            [
                data |> Option.map (fun x -> "data", Input x)
            ] |> List.choose id
        new Arccos(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type Arctan private (operatorArguments) = 
    inherit SymbolOperator("arctan", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new Arctan(args)
    override this.WithArguments(args : Arguments<Symbol>) = new Arctan(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <summary>Returns element-wise inverse tangent of the input array.
    /// 
    /// The output is in the closed interval :math:`[-\pi/2, \pi/2]`
    /// 
    /// .. math::
    ///    arctan([-1, 0, 1]) = [-\pi/4, 0, \pi/4]
    /// 
    /// The storage type of ``arctan`` output depends upon the input storage type:
    /// 
    ///    - arctan(default) = default
    ///    - arctan(row_sparse) = row_sparse
    ///    - arctan(csr) = csr
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\elemwise_unary_op_trig.cc:L227</summary>
    /// <param name="data">The input array.</param>
    new([<Optional>] ?data : Symbol) =
        let data = defaultArg data (new ImplicitVariable() :> Symbol)
        let operatorArguments = 
            [
                "data", Input data
            ]
        new Arctan(Arguments<Symbol>(operatorArguments))
    /// The input array.
    member __.Data = operatorArguments.GetInput "data"
    /// <summary>Copy Arctan instance with updated inputs/parameters.</summary>
    /// <param name="data">The input array.</param>
    member this.With([<Optional>] ?data : Symbol) =
        let operatorArguments = 
            [
                data |> Option.map (fun x -> "data", Input x)
            ] |> List.choose id
        new Arctan(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type Degrees private (operatorArguments) = 
    inherit SymbolOperator("degrees", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new Degrees(args)
    override this.WithArguments(args : Arguments<Symbol>) = new Degrees(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <summary>Converts each element of the input array from radians to degrees.
    /// 
    /// .. math::
    ///    degrees([0, \pi/2, \pi, 3\pi/2, 2\pi]) = [0, 90, 180, 270, 360]
    /// 
    /// The storage type of ``degrees`` output depends upon the input storage type:
    /// 
    ///    - degrees(default) = default
    ///    - degrees(row_sparse) = row_sparse
    ///    - degrees(csr) = csr
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\elemwise_unary_op_trig.cc:L274</summary>
    /// <param name="data">The input array.</param>
    new([<Optional>] ?data : Symbol) =
        let data = defaultArg data (new ImplicitVariable() :> Symbol)
        let operatorArguments = 
            [
                "data", Input data
            ]
        new Degrees(Arguments<Symbol>(operatorArguments))
    /// The input array.
    member __.Data = operatorArguments.GetInput "data"
    /// <summary>Copy Degrees instance with updated inputs/parameters.</summary>
    /// <param name="data">The input array.</param>
    member this.With([<Optional>] ?data : Symbol) =
        let operatorArguments = 
            [
                data |> Option.map (fun x -> "data", Input x)
            ] |> List.choose id
        new Degrees(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type Radians private (operatorArguments) = 
    inherit SymbolOperator("radians", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new Radians(args)
    override this.WithArguments(args : Arguments<Symbol>) = new Radians(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <summary>Converts each element of the input array from degrees to radians.
    /// 
    /// .. math::
    ///    radians([0, 90, 180, 270, 360]) = [0, \pi/2, \pi, 3\pi/2, 2\pi]
    /// 
    /// The storage type of ``radians`` output depends upon the input storage type:
    /// 
    ///    - radians(default) = default
    ///    - radians(row_sparse) = row_sparse
    ///    - radians(csr) = csr
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\elemwise_unary_op_trig.cc:L293</summary>
    /// <param name="data">The input array.</param>
    new([<Optional>] ?data : Symbol) =
        let data = defaultArg data (new ImplicitVariable() :> Symbol)
        let operatorArguments = 
            [
                "data", Input data
            ]
        new Radians(Arguments<Symbol>(operatorArguments))
    /// The input array.
    member __.Data = operatorArguments.GetInput "data"
    /// <summary>Copy Radians instance with updated inputs/parameters.</summary>
    /// <param name="data">The input array.</param>
    member this.With([<Optional>] ?data : Symbol) =
        let operatorArguments = 
            [
                data |> Option.map (fun x -> "data", Input x)
            ] |> List.choose id
        new Radians(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type Sinh private (operatorArguments) = 
    inherit SymbolOperator("sinh", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new Sinh(args)
    override this.WithArguments(args : Arguments<Symbol>) = new Sinh(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <summary>Returns the hyperbolic sine of the input array, computed element-wise.
    /// 
    /// .. math::
    ///    sinh(x) = 0.5\times(exp(x) - exp(-x))
    /// 
    /// The storage type of ``sinh`` output depends upon the input storage type:
    /// 
    ///    - sinh(default) = default
    ///    - sinh(row_sparse) = row_sparse
    ///    - sinh(csr) = csr
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\elemwise_unary_op_trig.cc:L313</summary>
    /// <param name="data">The input array.</param>
    new([<Optional>] ?data : Symbol) =
        let data = defaultArg data (new ImplicitVariable() :> Symbol)
        let operatorArguments = 
            [
                "data", Input data
            ]
        new Sinh(Arguments<Symbol>(operatorArguments))
    /// The input array.
    member __.Data = operatorArguments.GetInput "data"
    /// <summary>Copy Sinh instance with updated inputs/parameters.</summary>
    /// <param name="data">The input array.</param>
    member this.With([<Optional>] ?data : Symbol) =
        let operatorArguments = 
            [
                data |> Option.map (fun x -> "data", Input x)
            ] |> List.choose id
        new Sinh(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type Cosh private (operatorArguments) = 
    inherit SymbolOperator("cosh", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new Cosh(args)
    override this.WithArguments(args : Arguments<Symbol>) = new Cosh(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <summary>Returns the hyperbolic cosine  of the input array, computed element-wise.
    /// 
    /// .. math::
    ///    cosh(x) = 0.5\times(exp(x) + exp(-x))
    /// 
    /// The storage type of ``cosh`` output is always dense
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\elemwise_unary_op_trig.cc:L351</summary>
    /// <param name="data">The input array.</param>
    new([<Optional>] ?data : Symbol) =
        let data = defaultArg data (new ImplicitVariable() :> Symbol)
        let operatorArguments = 
            [
                "data", Input data
            ]
        new Cosh(Arguments<Symbol>(operatorArguments))
    /// The input array.
    member __.Data = operatorArguments.GetInput "data"
    /// <summary>Copy Cosh instance with updated inputs/parameters.</summary>
    /// <param name="data">The input array.</param>
    member this.With([<Optional>] ?data : Symbol) =
        let operatorArguments = 
            [
                data |> Option.map (fun x -> "data", Input x)
            ] |> List.choose id
        new Cosh(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type Tanh private (operatorArguments) = 
    inherit SymbolOperator("tanh", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new Tanh(args)
    override this.WithArguments(args : Arguments<Symbol>) = new Tanh(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <summary>Returns the hyperbolic tangent of the input array, computed element-wise.
    /// 
    /// .. math::
    ///    tanh(x) = sinh(x) / cosh(x)
    /// 
    /// The storage type of ``tanh`` output depends upon the input storage type:
    /// 
    ///    - tanh(default) = default
    ///    - tanh(row_sparse) = row_sparse
    ///    - tanh(csr) = csr
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\elemwise_unary_op_trig.cc:L393</summary>
    /// <param name="data">The input array.</param>
    new([<Optional>] ?data : Symbol) =
        let data = defaultArg data (new ImplicitVariable() :> Symbol)
        let operatorArguments = 
            [
                "data", Input data
            ]
        new Tanh(Arguments<Symbol>(operatorArguments))
    /// The input array.
    member __.Data = operatorArguments.GetInput "data"
    /// <summary>Copy Tanh instance with updated inputs/parameters.</summary>
    /// <param name="data">The input array.</param>
    member this.With([<Optional>] ?data : Symbol) =
        let operatorArguments = 
            [
                data |> Option.map (fun x -> "data", Input x)
            ] |> List.choose id
        new Tanh(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type Arcsinh private (operatorArguments) = 
    inherit SymbolOperator("arcsinh", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new Arcsinh(args)
    override this.WithArguments(args : Arguments<Symbol>) = new Arcsinh(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <summary>Returns the element-wise inverse hyperbolic sine of the input array, \
    /// computed element-wise.
    /// 
    /// The storage type of ``arcsinh`` output depends upon the input storage type:
    /// 
    ///    - arcsinh(default) = default
    ///    - arcsinh(row_sparse) = row_sparse
    ///    - arcsinh(csr) = csr
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\elemwise_unary_op_trig.cc:L436</summary>
    /// <param name="data">The input array.</param>
    new([<Optional>] ?data : Symbol) =
        let data = defaultArg data (new ImplicitVariable() :> Symbol)
        let operatorArguments = 
            [
                "data", Input data
            ]
        new Arcsinh(Arguments<Symbol>(operatorArguments))
    /// The input array.
    member __.Data = operatorArguments.GetInput "data"
    /// <summary>Copy Arcsinh instance with updated inputs/parameters.</summary>
    /// <param name="data">The input array.</param>
    member this.With([<Optional>] ?data : Symbol) =
        let operatorArguments = 
            [
                data |> Option.map (fun x -> "data", Input x)
            ] |> List.choose id
        new Arcsinh(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type Arccosh private (operatorArguments) = 
    inherit SymbolOperator("arccosh", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new Arccosh(args)
    override this.WithArguments(args : Arguments<Symbol>) = new Arccosh(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <summary>Returns the element-wise inverse hyperbolic cosine of the input array, \
    /// computed element-wise.
    /// 
    /// The storage type of ``arccosh`` output is always dense
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\elemwise_unary_op_trig.cc:L474</summary>
    /// <param name="data">The input array.</param>
    new([<Optional>] ?data : Symbol) =
        let data = defaultArg data (new ImplicitVariable() :> Symbol)
        let operatorArguments = 
            [
                "data", Input data
            ]
        new Arccosh(Arguments<Symbol>(operatorArguments))
    /// The input array.
    member __.Data = operatorArguments.GetInput "data"
    /// <summary>Copy Arccosh instance with updated inputs/parameters.</summary>
    /// <param name="data">The input array.</param>
    member this.With([<Optional>] ?data : Symbol) =
        let operatorArguments = 
            [
                data |> Option.map (fun x -> "data", Input x)
            ] |> List.choose id
        new Arccosh(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type Arctanh private (operatorArguments) = 
    inherit SymbolOperator("arctanh", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new Arctanh(args)
    override this.WithArguments(args : Arguments<Symbol>) = new Arctanh(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <summary>Returns the element-wise inverse hyperbolic tangent of the input array, \
    /// computed element-wise.
    /// 
    /// The storage type of ``arctanh`` output depends upon the input storage type:
    /// 
    ///    - arctanh(default) = default
    ///    - arctanh(row_sparse) = row_sparse
    ///    - arctanh(csr) = csr
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\elemwise_unary_op_trig.cc:L515</summary>
    /// <param name="data">The input array.</param>
    new([<Optional>] ?data : Symbol) =
        let data = defaultArg data (new ImplicitVariable() :> Symbol)
        let operatorArguments = 
            [
                "data", Input data
            ]
        new Arctanh(Arguments<Symbol>(operatorArguments))
    /// The input array.
    member __.Data = operatorArguments.GetInput "data"
    /// <summary>Copy Arctanh instance with updated inputs/parameters.</summary>
    /// <param name="data">The input array.</param>
    member this.With([<Optional>] ?data : Symbol) =
        let operatorArguments = 
            [
                data |> Option.map (fun x -> "data", Input x)
            ] |> List.choose id
        new Arctanh(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type Histogram private (operatorArguments) = 
    inherit SymbolOperator("_histogram", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new Histogram(args)
    override this.WithArguments(args : Arguments<Symbol>) = new Histogram(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <summary>This operators implements the histogram function.
    /// 
    /// Example::
    ///   x = [[0, 1], [2, 2], [3, 4]]
    ///   histo, bin_edges = histogram(data=x, bin_bounds=[], bin_cnt=5, range=(0,5))
    ///   histo = [1, 1, 2, 1, 1]
    ///   bin_edges = [0., 1., 2., 3., 4.]
    ///   histo, bin_edges = histogram(data=x, bin_bounds=[0., 2.1, 3.])
    ///   histo = [4, 1]
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\histogram.cc:L136</summary>
    /// <param name="data">Input ndarray</param>
    /// <param name="bins">Input ndarray</param>
    /// <param name="binCnt">Number of bins for uniform case</param>
    /// <param name="range">The lower and upper range of the bins. if not provided, range is simply (a.min(), a.max()). values outside the range are ignored. the first element of the range must be less than or equal to the second. range affects the automatic bin computation as well. while bin width is computed to be optimal based on the actual data within range, the bin count will fill the entire range including portions containing no data.</param>
    new([<Optional>] ?data : Symbol,
        [<Optional>] ?bins : Symbol,
        [<Optional>] ?binCnt : int,
        [<Optional>] ?range : float seq) = 
        let data = defaultArg data (new ImplicitVariable() :> Symbol)
        let bins = defaultArg bins (new ImplicitVariable() :> Symbol)
        let operatorArguments = 
            [
                "data", Input data
                "bins", Input bins
                "bin_cnt", binCnt |> Option.map box |> Parameter
                "range", range |> Option.map box |> Parameter
            ]
        new Histogram(Arguments<Symbol>(operatorArguments))
    /// Default value for BinCnt
    /// Number of bins for uniform case
    static member BinCntDefault : int option = None
    /// Default value for Range
    /// The lower and upper range of the bins. if not provided, range is simply (a.min(), a.max()). values outside the range are ignored. the first element of the range must be less than or equal to the second. range affects the automatic bin computation as well. while bin width is computed to be optimal based on the actual data within range, the bin count will fill the entire range including portions containing no data.
    static member RangeDefault : int [] option = None
    /// Input ndarray
    member __.Data = operatorArguments.GetInput "data"
    /// Input ndarray
    member __.Bins = operatorArguments.GetInput "bins"
    /// Number of bins for uniform case
    member __.BinCnt = operatorArguments.GetParameter("bin_cnt", Histogram.BinCntDefault)
    /// The lower and upper range of the bins. if not provided, range is simply (a.min(), a.max()). values outside the range are ignored. the first element of the range must be less than or equal to the second. range affects the automatic bin computation as well. while bin width is computed to be optimal based on the actual data within range, the bin count will fill the entire range including portions containing no data.
    member __.Range = operatorArguments.GetParameter("range", Histogram.RangeDefault)
    /// <summary>Copy Histogram instance with updated inputs/parameters.</summary>
    /// <param name="data">Input ndarray</param>
    /// <param name="bins">Input ndarray</param>
    /// <param name="binCnt">Number of bins for uniform case</param>
    /// <param name="range">The lower and upper range of the bins. if not provided, range is simply (a.min(), a.max()). values outside the range are ignored. the first element of the range must be less than or equal to the second. range affects the automatic bin computation as well. while bin width is computed to be optimal based on the actual data within range, the bin count will fill the entire range including portions containing no data.</param>
    member this.With([<Optional>] ?data : Symbol,
        [<Optional>] ?bins : Symbol,
        [<Optional>] ?binCnt : int,
        [<Optional>] ?range : float seq) = 
        let operatorArguments = 
            [
                data |> Option.map (fun x -> "data", Input x)
                bins |> Option.map (fun x -> "bins", Input x)
                binCnt |> Option.map (fun x -> "bin_cnt", Parameter(Some (box x)))
                range |> Option.map (fun x -> "range", Parameter(Some (box x)))
            ] |> List.choose id
        new Histogram(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type Embedding private (operatorArguments) = 
    inherit SymbolOperator("Embedding", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new Embedding(args)
    override this.WithArguments(args : Arguments<Symbol>) = new Embedding(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <summary>Maps integer indices to vector representations (embeddings).
    /// 
    /// This operator maps words to real-valued vectors in a high-dimensional space,
    /// called word embeddings. These embeddings can capture semantic and syntactic properties of the words.
    /// For example, it has been noted that in the learned embedding spaces, similar words tend
    /// to be close to each other and dissimilar words far apart.
    /// 
    /// For an input array of shape (d1, ..., dK),
    /// the shape of an output array is (d1, ..., dK, output_dim).
    /// All the input values should be integers in the range [0, input_dim).
    /// 
    /// If the input_dim is ip0 and output_dim is op0, then shape of the embedding weight matrix must be
    /// (ip0, op0).
    /// 
    /// When &quot;sparse_grad&quot; is False, if any index mentioned is too large, it is replaced by the index that
    /// addresses the last vector in an embedding matrix.
    /// When &quot;sparse_grad&quot; is True, an error will be raised if invalid indices are found.
    /// 
    /// Examples::
    /// 
    ///   input_dim = 4
    ///   output_dim = 5
    /// 
    ///   // Each row in weight matrix y represents a word. So, y = (w0,w1,w2,w3)
    ///   y = [[  0.,   1.,   2.,   3.,   4.],
    ///        [  5.,   6.,   7.,   8.,   9.],
    ///        [ 10.,  11.,  12.,  13.,  14.],
    ///        [ 15.,  16.,  17.,  18.,  19.]]
    /// 
    ///   // Input array x represents n-grams(2-gram). So, x = [(w1,w3), (w0,w2)]
    ///   x = [[ 1.,  3.],
    ///        [ 0.,  2.]]
    /// 
    ///   // Mapped input x to its vector representation y.
    ///   Embedding(x, y, 4, 5) = [[[  5.,   6.,   7.,   8.,   9.],
    ///                             [ 15.,  16.,  17.,  18.,  19.]],
    /// 
    ///                            [[  0.,   1.,   2.,   3.,   4.],
    ///                             [ 10.,  11.,  12.,  13.,  14.]]]
    /// 
    /// 
    /// The storage type of weight can be either row_sparse or default.
    /// 
    /// .. Note::
    /// 
    ///     If &quot;sparse_grad&quot; is set to True, the storage type of gradient w.r.t weights will be
    ///     &quot;row_sparse&quot;. Only a subset of optimizers support sparse gradients, including SGD, AdaGrad
    ///     and Adam. Note that by default lazy updates is turned on, which may perform differently
    ///     from standard updates. For more details, please check the Optimization API at:
    ///     https://mxnet.incubator.apache.org/api/python/optimization/optimization.html
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\indexing_op.cc:L534</summary>
    /// <param name="data">The input array to the embedding operator.</param>
    /// <param name="weight">The embedding weight matrix.</param>
    /// <param name="inputDim">Vocabulary size of the input indices.</param>
    /// <param name="outputDim">Dimension of the embedding vectors.</param>
    /// <param name="dtype">Data type of weight.</param>
    /// <param name="sparseGrad">Compute row sparse gradient in the backward calculation. If set to True, the grad&#39;s storage type is row_sparse.</param>
    new(data : Symbol,
        weight : Symbol,
        inputDim : int,
        outputDim : int,
        [<Optional>] ?dtype : IntOrFloatDType,
        [<Optional>] ?sparseGrad : bool) = 
        let operatorArguments = 
            [
                "data", Input data
                "weight", Input weight
                "input_dim", Parameter(Some(box inputDim))
                "output_dim", Parameter(Some(box outputDim))
                "dtype", dtype |> Option.map box |> Parameter
                "sparse_grad", sparseGrad |> Option.map box |> Parameter
            ]
        new Embedding(Arguments<Symbol>(operatorArguments))
    /// <summary>Maps integer indices to vector representations (embeddings).
    /// 
    /// This operator maps words to real-valued vectors in a high-dimensional space,
    /// called word embeddings. These embeddings can capture semantic and syntactic properties of the words.
    /// For example, it has been noted that in the learned embedding spaces, similar words tend
    /// to be close to each other and dissimilar words far apart.
    /// 
    /// For an input array of shape (d1, ..., dK),
    /// the shape of an output array is (d1, ..., dK, output_dim).
    /// All the input values should be integers in the range [0, input_dim).
    /// 
    /// If the input_dim is ip0 and output_dim is op0, then shape of the embedding weight matrix must be
    /// (ip0, op0).
    /// 
    /// When &quot;sparse_grad&quot; is False, if any index mentioned is too large, it is replaced by the index that
    /// addresses the last vector in an embedding matrix.
    /// When &quot;sparse_grad&quot; is True, an error will be raised if invalid indices are found.
    /// 
    /// Examples::
    /// 
    ///   input_dim = 4
    ///   output_dim = 5
    /// 
    ///   // Each row in weight matrix y represents a word. So, y = (w0,w1,w2,w3)
    ///   y = [[  0.,   1.,   2.,   3.,   4.],
    ///        [  5.,   6.,   7.,   8.,   9.],
    ///        [ 10.,  11.,  12.,  13.,  14.],
    ///        [ 15.,  16.,  17.,  18.,  19.]]
    /// 
    ///   // Input array x represents n-grams(2-gram). So, x = [(w1,w3), (w0,w2)]
    ///   x = [[ 1.,  3.],
    ///        [ 0.,  2.]]
    /// 
    ///   // Mapped input x to its vector representation y.
    ///   Embedding(x, y, 4, 5) = [[[  5.,   6.,   7.,   8.,   9.],
    ///                             [ 15.,  16.,  17.,  18.,  19.]],
    /// 
    ///                            [[  0.,   1.,   2.,   3.,   4.],
    ///                             [ 10.,  11.,  12.,  13.,  14.]]]
    /// 
    /// 
    /// The storage type of weight can be either row_sparse or default.
    /// 
    /// .. Note::
    /// 
    ///     If &quot;sparse_grad&quot; is set to True, the storage type of gradient w.r.t weights will be
    ///     &quot;row_sparse&quot;. Only a subset of optimizers support sparse gradients, including SGD, AdaGrad
    ///     and Adam. Note that by default lazy updates is turned on, which may perform differently
    ///     from standard updates. For more details, please check the Optimization API at:
    ///     https://mxnet.incubator.apache.org/api/python/optimization/optimization.html
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\indexing_op.cc:L534</summary>
    /// <param name="inputDim">Vocabulary size of the input indices.</param>
    /// <param name="outputDim">Dimension of the embedding vectors.</param>
    /// <param name="data">The input array to the embedding operator.</param>
    /// <param name="weight">The embedding weight matrix.</param>
    /// <param name="dtype">Data type of weight.</param>
    /// <param name="sparseGrad">Compute row sparse gradient in the backward calculation. If set to True, the grad&#39;s storage type is row_sparse.</param>
    new(inputDim : int,
        outputDim : int,
        [<Optional>] ?data : Symbol,
        [<Optional>] ?weight : Symbol,
        [<Optional>] ?dtype : IntOrFloatDType,
        [<Optional>] ?sparseGrad : bool) = 
        let data = defaultArg data (new ImplicitVariable() :> Symbol)
        let weight = defaultArg weight (new ImplicitVariable() :> Symbol)
        let operatorArguments = 
            [
                "data", Input data
                "weight", Input weight
                "input_dim", Parameter(Some(box inputDim))
                "output_dim", Parameter(Some(box outputDim))
                "dtype", dtype |> Option.map box |> Parameter
                "sparse_grad", sparseGrad |> Option.map box |> Parameter
            ]
        new Embedding(Arguments<Symbol>(operatorArguments))
    /// Default value for Dtype
    /// Data type of weight.
    static member DtypeDefault : IntOrFloatDType = IntOrFloatDType.Float32
    /// Default value for SparseGrad
    /// Compute row sparse gradient in the backward calculation. If set to True, the grad&#39;s storage type is row_sparse.
    static member SparseGradDefault : bool = false
    /// The input array to the embedding operator.
    member __.Data = operatorArguments.GetInput "data"
    /// The embedding weight matrix.
    member __.Weight = operatorArguments.GetInput "weight"
    /// Vocabulary size of the input indices.
    member __.InputDim : int = match operatorArguments.GetParameter "input_dim" with Some(v) -> unbox v | None -> failwithf "Required parameter input_dim is missing"
    /// Dimension of the embedding vectors.
    member __.OutputDim : int = match operatorArguments.GetParameter "output_dim" with Some(v) -> unbox v | None -> failwithf "Required parameter output_dim is missing"
    /// Data type of weight.
    member __.Dtype = operatorArguments.GetParameter("dtype", Embedding.DtypeDefault)
    /// Compute row sparse gradient in the backward calculation. If set to True, the grad&#39;s storage type is row_sparse.
    member __.SparseGrad = operatorArguments.GetParameter("sparse_grad", Embedding.SparseGradDefault)
    /// <summary>Copy Embedding instance with updated inputs/parameters.</summary>
    /// <param name="data">The input array to the embedding operator.</param>
    /// <param name="weight">The embedding weight matrix.</param>
    /// <param name="inputDim">Vocabulary size of the input indices.</param>
    /// <param name="outputDim">Dimension of the embedding vectors.</param>
    /// <param name="dtype">Data type of weight.</param>
    /// <param name="sparseGrad">Compute row sparse gradient in the backward calculation. If set to True, the grad&#39;s storage type is row_sparse.</param>
    member this.With([<Optional>] ?data : Symbol,
        [<Optional>] ?weight : Symbol,
        [<Optional>] ?inputDim : int,
        [<Optional>] ?outputDim : int,
        [<Optional>] ?dtype : IntOrFloatDType,
        [<Optional>] ?sparseGrad : bool) = 
        let operatorArguments = 
            [
                data |> Option.map (fun x -> "data", Input x)
                weight |> Option.map (fun x -> "weight", Input x)
                inputDim |> Option.map (fun x -> "input_dim", Parameter(Some (box x)))
                outputDim |> Option.map (fun x -> "output_dim", Parameter(Some (box x)))
                dtype |> Option.map (fun x -> "dtype", Parameter(Some (box x)))
                sparseGrad |> Option.map (fun x -> "sparse_grad", Parameter(Some (box x)))
            ] |> List.choose id
        new Embedding(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type ContribSparseEmbedding private (operatorArguments) = 
    inherit SymbolOperator("_contrib_SparseEmbedding", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new ContribSparseEmbedding(args)
    override this.WithArguments(args : Arguments<Symbol>) = new ContribSparseEmbedding(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <summary>Maps integer indices to vector representations (embeddings).
    /// 
    /// note:: ``contrib.SparseEmbedding`` is deprecated, use ``Embedding`` instead.
    /// 
    /// This operator maps words to real-valued vectors in a high-dimensional space,
    /// called word embeddings. These embeddings can capture semantic and syntactic properties of the words.
    /// For example, it has been noted that in the learned embedding spaces, similar words tend
    /// to be close to each other and dissimilar words far apart.
    /// 
    /// For an input array of shape (d1, ..., dK),
    /// the shape of an output array is (d1, ..., dK, output_dim).
    /// All the input values should be integers in the range [0, input_dim).
    /// 
    /// If the input_dim is ip0 and output_dim is op0, then shape of the embedding weight matrix must be
    /// (ip0, op0).
    /// 
    /// The storage type of the gradient will be `row_sparse`.
    /// 
    /// .. Note::
    /// 
    ///     `SparseEmbedding` is designed for the use case where `input_dim` is very large (e.g. 100k).
    ///     The operator is available on both CPU and GPU.
    ///     When `deterministic` is set to `True`, the accumulation of gradients follows a
    ///     deterministic order if a feature appears multiple times in the input. However, the
    ///     accumulation is usually slower when the order is enforced on GPU.
    ///     When the operator is used on the GPU, the recommended value for `deterministic` is `True`.
    /// 
    /// Examples::
    /// 
    ///   input_dim = 4
    ///   output_dim = 5
    /// 
    ///   // Each row in weight matrix y represents a word. So, y = (w0,w1,w2,w3)
    ///   y = [[  0.,   1.,   2.,   3.,   4.],
    ///        [  5.,   6.,   7.,   8.,   9.],
    ///        [ 10.,  11.,  12.,  13.,  14.],
    ///        [ 15.,  16.,  17.,  18.,  19.]]
    /// 
    ///   // Input array x represents n-grams(2-gram). So, x = [(w1,w3), (w0,w2)]
    ///   x = [[ 1.,  3.],
    ///        [ 0.,  2.]]
    /// 
    ///   // Mapped input x to its vector representation y.
    ///   SparseEmbedding(x, y, 4, 5) = [[[  5.,   6.,   7.,   8.,   9.],
    ///                                  [ 15.,  16.,  17.,  18.,  19.]],
    /// 
    ///                                 [[  0.,   1.,   2.,   3.,   4.],
    ///                                  [ 10.,  11.,  12.,  13.,  14.]]]
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\indexing_op.cc:L610</summary>
    /// <param name="data">The input array to the embedding operator.</param>
    /// <param name="weight">The embedding weight matrix.</param>
    /// <param name="inputDim">Vocabulary size of the input indices.</param>
    /// <param name="outputDim">Dimension of the embedding vectors.</param>
    /// <param name="dtype">Data type of weight.</param>
    /// <param name="sparseGrad">Compute row sparse gradient in the backward calculation. If set to True, the grad&#39;s storage type is row_sparse.</param>
    new(data : Symbol,
        weight : Symbol,
        inputDim : int,
        outputDim : int,
        [<Optional>] ?dtype : IntOrFloatDType,
        [<Optional>] ?sparseGrad : bool) = 
        let operatorArguments = 
            [
                "data", Input data
                "weight", Input weight
                "input_dim", Parameter(Some(box inputDim))
                "output_dim", Parameter(Some(box outputDim))
                "dtype", dtype |> Option.map box |> Parameter
                "sparse_grad", sparseGrad |> Option.map box |> Parameter
            ]
        new ContribSparseEmbedding(Arguments<Symbol>(operatorArguments))
    /// <summary>Maps integer indices to vector representations (embeddings).
    /// 
    /// note:: ``contrib.SparseEmbedding`` is deprecated, use ``Embedding`` instead.
    /// 
    /// This operator maps words to real-valued vectors in a high-dimensional space,
    /// called word embeddings. These embeddings can capture semantic and syntactic properties of the words.
    /// For example, it has been noted that in the learned embedding spaces, similar words tend
    /// to be close to each other and dissimilar words far apart.
    /// 
    /// For an input array of shape (d1, ..., dK),
    /// the shape of an output array is (d1, ..., dK, output_dim).
    /// All the input values should be integers in the range [0, input_dim).
    /// 
    /// If the input_dim is ip0 and output_dim is op0, then shape of the embedding weight matrix must be
    /// (ip0, op0).
    /// 
    /// The storage type of the gradient will be `row_sparse`.
    /// 
    /// .. Note::
    /// 
    ///     `SparseEmbedding` is designed for the use case where `input_dim` is very large (e.g. 100k).
    ///     The operator is available on both CPU and GPU.
    ///     When `deterministic` is set to `True`, the accumulation of gradients follows a
    ///     deterministic order if a feature appears multiple times in the input. However, the
    ///     accumulation is usually slower when the order is enforced on GPU.
    ///     When the operator is used on the GPU, the recommended value for `deterministic` is `True`.
    /// 
    /// Examples::
    /// 
    ///   input_dim = 4
    ///   output_dim = 5
    /// 
    ///   // Each row in weight matrix y represents a word. So, y = (w0,w1,w2,w3)
    ///   y = [[  0.,   1.,   2.,   3.,   4.],
    ///        [  5.,   6.,   7.,   8.,   9.],
    ///        [ 10.,  11.,  12.,  13.,  14.],
    ///        [ 15.,  16.,  17.,  18.,  19.]]
    /// 
    ///   // Input array x represents n-grams(2-gram). So, x = [(w1,w3), (w0,w2)]
    ///   x = [[ 1.,  3.],
    ///        [ 0.,  2.]]
    /// 
    ///   // Mapped input x to its vector representation y.
    ///   SparseEmbedding(x, y, 4, 5) = [[[  5.,   6.,   7.,   8.,   9.],
    ///                                  [ 15.,  16.,  17.,  18.,  19.]],
    /// 
    ///                                 [[  0.,   1.,   2.,   3.,   4.],
    ///                                  [ 10.,  11.,  12.,  13.,  14.]]]
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\indexing_op.cc:L610</summary>
    /// <param name="inputDim">Vocabulary size of the input indices.</param>
    /// <param name="outputDim">Dimension of the embedding vectors.</param>
    /// <param name="data">The input array to the embedding operator.</param>
    /// <param name="weight">The embedding weight matrix.</param>
    /// <param name="dtype">Data type of weight.</param>
    /// <param name="sparseGrad">Compute row sparse gradient in the backward calculation. If set to True, the grad&#39;s storage type is row_sparse.</param>
    new(inputDim : int,
        outputDim : int,
        [<Optional>] ?data : Symbol,
        [<Optional>] ?weight : Symbol,
        [<Optional>] ?dtype : IntOrFloatDType,
        [<Optional>] ?sparseGrad : bool) = 
        let data = defaultArg data (new ImplicitVariable() :> Symbol)
        let weight = defaultArg weight (new ImplicitVariable() :> Symbol)
        let operatorArguments = 
            [
                "data", Input data
                "weight", Input weight
                "input_dim", Parameter(Some(box inputDim))
                "output_dim", Parameter(Some(box outputDim))
                "dtype", dtype |> Option.map box |> Parameter
                "sparse_grad", sparseGrad |> Option.map box |> Parameter
            ]
        new ContribSparseEmbedding(Arguments<Symbol>(operatorArguments))
    /// Default value for Dtype
    /// Data type of weight.
    static member DtypeDefault : IntOrFloatDType = IntOrFloatDType.Float32
    /// Default value for SparseGrad
    /// Compute row sparse gradient in the backward calculation. If set to True, the grad&#39;s storage type is row_sparse.
    static member SparseGradDefault : bool = false
    /// The input array to the embedding operator.
    member __.Data = operatorArguments.GetInput "data"
    /// The embedding weight matrix.
    member __.Weight = operatorArguments.GetInput "weight"
    /// Vocabulary size of the input indices.
    member __.InputDim : int = match operatorArguments.GetParameter "input_dim" with Some(v) -> unbox v | None -> failwithf "Required parameter input_dim is missing"
    /// Dimension of the embedding vectors.
    member __.OutputDim : int = match operatorArguments.GetParameter "output_dim" with Some(v) -> unbox v | None -> failwithf "Required parameter output_dim is missing"
    /// Data type of weight.
    member __.Dtype = operatorArguments.GetParameter("dtype", ContribSparseEmbedding.DtypeDefault)
    /// Compute row sparse gradient in the backward calculation. If set to True, the grad&#39;s storage type is row_sparse.
    member __.SparseGrad = operatorArguments.GetParameter("sparse_grad", ContribSparseEmbedding.SparseGradDefault)
    /// <summary>Copy ContribSparseEmbedding instance with updated inputs/parameters.</summary>
    /// <param name="data">The input array to the embedding operator.</param>
    /// <param name="weight">The embedding weight matrix.</param>
    /// <param name="inputDim">Vocabulary size of the input indices.</param>
    /// <param name="outputDim">Dimension of the embedding vectors.</param>
    /// <param name="dtype">Data type of weight.</param>
    /// <param name="sparseGrad">Compute row sparse gradient in the backward calculation. If set to True, the grad&#39;s storage type is row_sparse.</param>
    member this.With([<Optional>] ?data : Symbol,
        [<Optional>] ?weight : Symbol,
        [<Optional>] ?inputDim : int,
        [<Optional>] ?outputDim : int,
        [<Optional>] ?dtype : IntOrFloatDType,
        [<Optional>] ?sparseGrad : bool) = 
        let operatorArguments = 
            [
                data |> Option.map (fun x -> "data", Input x)
                weight |> Option.map (fun x -> "weight", Input x)
                inputDim |> Option.map (fun x -> "input_dim", Parameter(Some (box x)))
                outputDim |> Option.map (fun x -> "output_dim", Parameter(Some (box x)))
                dtype |> Option.map (fun x -> "dtype", Parameter(Some (box x)))
                sparseGrad |> Option.map (fun x -> "sparse_grad", Parameter(Some (box x)))
            ] |> List.choose id
        new ContribSparseEmbedding(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type Take private (operatorArguments) = 
    inherit SymbolOperator("take", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new Take(args)
    override this.WithArguments(args : Arguments<Symbol>) = new Take(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <summary>Takes elements from an input array along the given axis.
    /// 
    /// This function slices the input array along a particular axis with the provided indices.
    /// 
    /// Given data tensor of rank r &gt;= 1, and indices tensor of rank q, gather entries of the axis
    /// dimension of data (by default outer-most one as axis=0) indexed by indices, and concatenates them
    /// in an output tensor of rank q + (r - 1).
    /// 
    /// Examples::
    /// 
    ///   x = [4.  5.  6.]
    /// 
    ///   // Trivial case, take the second element along the first axis.
    /// 
    ///   take(x, [1]) = [ 5. ]
    /// 
    ///   // The other trivial case, axis=-1, take the third element along the first axis
    /// 
    ///   take(x, [3], axis=-1, mode=&#39;clip&#39;) = [ 6. ]
    /// 
    ///   x = [[ 1.,  2.],
    ///        [ 3.,  4.],
    ///        [ 5.,  6.]]
    /// 
    ///   // In this case we will get rows 0 and 1, then 1 and 2. Along axis 0
    /// 
    ///   take(x, [[0,1],[1,2]]) = [[[ 1.,  2.],
    ///                              [ 3.,  4.]],
    /// 
    ///                             [[ 3.,  4.],
    ///                              [ 5.,  6.]]]
    /// 
    ///   // In this case we will get rows 0 and 1, then 1 and 2 (calculated by wrapping around).
    ///   // Along axis 1
    /// 
    ///   take(x, [[0, 3], [-1, -2]], axis=1, mode=&#39;wrap&#39;) = [[[ 1.  2.]
    ///                                                        [ 2.  1.]]
    /// 
    ///                                                       [[ 3.  4.]
    ///                                                        [ 4.  3.]]
    /// 
    ///                                                       [[ 5.  6.]
    ///                                                        [ 6.  5.]]]
    /// 
    /// The storage type of ``take`` output depends upon the input storage type:
    /// 
    ///    - take(default, default) = default
    ///    - take(csr, default, axis=0) = csr
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\indexing_op.cc:L711</summary>
    /// <param name="a">The input array.</param>
    /// <param name="indices">The indices of the values to be extracted.</param>
    /// <param name="axis">The axis of input array to be taken.For input tensor of rank r, it could be in the range of [-r, r-1]</param>
    /// <param name="mode">Specify how out-of-bound indices bahave. Default is &quot;clip&quot;. &quot;clip&quot; means clip to the range. So, if all indices mentioned are too large, they are replaced by the index that addresses the last element along an axis. &quot;wrap&quot; means to wrap around. &quot;raise&quot; means to raise an error when index out of range.</param>
    new([<Optional>] ?a : Symbol,
        [<Optional>] ?indices : Symbol,
        [<Optional>] ?axis : int,
        [<Optional>] ?mode : TakeMode) = 
        let a = defaultArg a (new ImplicitVariable() :> Symbol)
        let indices = defaultArg indices (new ImplicitVariable() :> Symbol)
        let operatorArguments = 
            [
                "a", Input a
                "indices", Input indices
                "axis", axis |> Option.map box |> Parameter
                "mode", mode |> Option.map box |> Parameter
            ]
        new Take(Arguments<Symbol>(operatorArguments))
    /// Default value for Axis
    /// The axis of input array to be taken.For input tensor of rank r, it could be in the range of [-r, r-1]
    static member AxisDefault : int = 0
    /// Default value for Mode
    /// Specify how out-of-bound indices bahave. Default is &quot;clip&quot;. &quot;clip&quot; means clip to the range. So, if all indices mentioned are too large, they are replaced by the index that addresses the last element along an axis. &quot;wrap&quot; means to wrap around. &quot;raise&quot; means to raise an error when index out of range.
    static member ModeDefault : TakeMode = TakeMode.Clip
    /// The input array.
    member __.A = operatorArguments.GetInput "a"
    /// The indices of the values to be extracted.
    member __.Indices = operatorArguments.GetInput "indices"
    /// The axis of input array to be taken.For input tensor of rank r, it could be in the range of [-r, r-1]
    member __.Axis = operatorArguments.GetParameter("axis", Take.AxisDefault)
    /// Specify how out-of-bound indices bahave. Default is &quot;clip&quot;. &quot;clip&quot; means clip to the range. So, if all indices mentioned are too large, they are replaced by the index that addresses the last element along an axis. &quot;wrap&quot; means to wrap around. &quot;raise&quot; means to raise an error when index out of range.
    member __.Mode = operatorArguments.GetParameter("mode", Take.ModeDefault)
    /// <summary>Copy Take instance with updated inputs/parameters.</summary>
    /// <param name="a">The input array.</param>
    /// <param name="indices">The indices of the values to be extracted.</param>
    /// <param name="axis">The axis of input array to be taken.For input tensor of rank r, it could be in the range of [-r, r-1]</param>
    /// <param name="mode">Specify how out-of-bound indices bahave. Default is &quot;clip&quot;. &quot;clip&quot; means clip to the range. So, if all indices mentioned are too large, they are replaced by the index that addresses the last element along an axis. &quot;wrap&quot; means to wrap around. &quot;raise&quot; means to raise an error when index out of range.</param>
    member this.With([<Optional>] ?a : Symbol,
        [<Optional>] ?indices : Symbol,
        [<Optional>] ?axis : int,
        [<Optional>] ?mode : TakeMode) = 
        let operatorArguments = 
            [
                a |> Option.map (fun x -> "a", Input x)
                indices |> Option.map (fun x -> "indices", Input x)
                axis |> Option.map (fun x -> "axis", Parameter(Some (box x)))
                mode |> Option.map (fun x -> "mode", Parameter(Some (box x)))
            ] |> List.choose id
        new Take(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type BatchTake private (operatorArguments) = 
    inherit SymbolOperator("batch_take", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new BatchTake(args)
    override this.WithArguments(args : Arguments<Symbol>) = new BatchTake(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <summary>Takes elements from a data batch.
    /// 
    /// .. note::
    ///   `batch_take` is deprecated. Use `pick` instead.
    /// 
    /// Given an input array of shape ``(d0, d1)`` and indices of shape ``(i0,)``, the result will be
    /// an output array of shape ``(i0,)`` with::
    /// 
    ///   output[i] = input[i, indices[i]]
    /// 
    /// Examples::
    /// 
    ///   x = [[ 1.,  2.],
    ///        [ 3.,  4.],
    ///        [ 5.,  6.]]
    /// 
    ///   // takes elements with specified indices
    ///   batch_take(x, [0,1,0]) = [ 1.  4.  5.]
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\indexing_op.cc:L769</summary>
    /// <param name="a">The input array</param>
    /// <param name="indices">The index array</param>
    new([<Optional>] ?a : Symbol,
        [<Optional>] ?indices : Symbol) = 
        let a = defaultArg a (new ImplicitVariable() :> Symbol)
        let indices = defaultArg indices (new ImplicitVariable() :> Symbol)
        let operatorArguments = 
            [
                "a", Input a
                "indices", Input indices
            ]
        new BatchTake(Arguments<Symbol>(operatorArguments))
    /// The input array
    member __.A = operatorArguments.GetInput "a"
    /// The index array
    member __.Indices = operatorArguments.GetInput "indices"
    /// <summary>Copy BatchTake instance with updated inputs/parameters.</summary>
    /// <param name="a">The input array</param>
    /// <param name="indices">The index array</param>
    member this.With([<Optional>] ?a : Symbol,
        [<Optional>] ?indices : Symbol) = 
        let operatorArguments = 
            [
                a |> Option.map (fun x -> "a", Input x)
                indices |> Option.map (fun x -> "indices", Input x)
            ] |> List.choose id
        new BatchTake(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type OneHot private (operatorArguments) = 
    inherit SymbolOperator("one_hot", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new OneHot(args)
    override this.WithArguments(args : Arguments<Symbol>) = new OneHot(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <summary>Returns a one-hot array.
    /// 
    /// The locations represented by `indices` take value `on_value`, while all
    /// other locations take value `off_value`.
    /// 
    /// `one_hot` operation with `indices` of shape ``(i0, i1)`` and `depth`  of ``d`` would result
    /// in an output array of shape ``(i0, i1, d)`` with::
    /// 
    ///   output[i,j,:] = off_value
    ///   output[i,j,indices[i,j]] = on_value
    /// 
    /// Examples::
    /// 
    ///   one_hot([1,0,2,0], 3) = [[ 0.  1.  0.]
    ///                            [ 1.  0.  0.]
    ///                            [ 0.  0.  1.]
    ///                            [ 1.  0.  0.]]
    /// 
    ///   one_hot([1,0,2,0], 3, on_value=8, off_value=1,
    ///           dtype=&#39;int32&#39;) = [[1 8 1]
    ///                             [8 1 1]
    ///                             [1 1 8]
    ///                             [8 1 1]]
    /// 
    ///   one_hot([[1,0],[1,0],[2,0]], 3) = [[[ 0.  1.  0.]
    ///                                       [ 1.  0.  0.]]
    /// 
    ///                                      [[ 0.  1.  0.]
    ///                                       [ 1.  0.  0.]]
    /// 
    ///                                      [[ 0.  0.  1.]
    ///                                       [ 1.  0.  0.]]]
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\indexing_op.cc:L816</summary>
    /// <param name="indices">array of locations where to set on_value</param>
    /// <param name="depth">Depth of the one hot dimension.</param>
    /// <param name="onValue">The value assigned to the locations represented by indices.</param>
    /// <param name="offValue">The value assigned to the locations not represented by indices.</param>
    /// <param name="dtype">DType of the output</param>
    new(indices : Symbol,
        depth : int,
        [<Optional>] ?onValue : double,
        [<Optional>] ?offValue : double,
        [<Optional>] ?dtype : IntOrFloatDType) = 
        let operatorArguments = 
            [
                "indices", Input indices
                "depth", Parameter(Some(box depth))
                "on_value", onValue |> Option.map box |> Parameter
                "off_value", offValue |> Option.map box |> Parameter
                "dtype", dtype |> Option.map box |> Parameter
            ]
        new OneHot(Arguments<Symbol>(operatorArguments))
    /// <summary>Returns a one-hot array.
    /// 
    /// The locations represented by `indices` take value `on_value`, while all
    /// other locations take value `off_value`.
    /// 
    /// `one_hot` operation with `indices` of shape ``(i0, i1)`` and `depth`  of ``d`` would result
    /// in an output array of shape ``(i0, i1, d)`` with::
    /// 
    ///   output[i,j,:] = off_value
    ///   output[i,j,indices[i,j]] = on_value
    /// 
    /// Examples::
    /// 
    ///   one_hot([1,0,2,0], 3) = [[ 0.  1.  0.]
    ///                            [ 1.  0.  0.]
    ///                            [ 0.  0.  1.]
    ///                            [ 1.  0.  0.]]
    /// 
    ///   one_hot([1,0,2,0], 3, on_value=8, off_value=1,
    ///           dtype=&#39;int32&#39;) = [[1 8 1]
    ///                             [8 1 1]
    ///                             [1 1 8]
    ///                             [8 1 1]]
    /// 
    ///   one_hot([[1,0],[1,0],[2,0]], 3) = [[[ 0.  1.  0.]
    ///                                       [ 1.  0.  0.]]
    /// 
    ///                                      [[ 0.  1.  0.]
    ///                                       [ 1.  0.  0.]]
    /// 
    ///                                      [[ 0.  0.  1.]
    ///                                       [ 1.  0.  0.]]]
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\indexing_op.cc:L816</summary>
    /// <param name="depth">Depth of the one hot dimension.</param>
    /// <param name="indices">array of locations where to set on_value</param>
    /// <param name="onValue">The value assigned to the locations represented by indices.</param>
    /// <param name="offValue">The value assigned to the locations not represented by indices.</param>
    /// <param name="dtype">DType of the output</param>
    new(depth : int,
        [<Optional>] ?indices : Symbol,
        [<Optional>] ?onValue : double,
        [<Optional>] ?offValue : double,
        [<Optional>] ?dtype : IntOrFloatDType) = 
        let indices = defaultArg indices (new ImplicitVariable() :> Symbol)
        let operatorArguments = 
            [
                "indices", Input indices
                "depth", Parameter(Some(box depth))
                "on_value", onValue |> Option.map box |> Parameter
                "off_value", offValue |> Option.map box |> Parameter
                "dtype", dtype |> Option.map box |> Parameter
            ]
        new OneHot(Arguments<Symbol>(operatorArguments))
    /// Default value for OnValue
    /// The value assigned to the locations represented by indices.
    static member OnValueDefault : double = 1.0
    /// Default value for OffValue
    /// The value assigned to the locations not represented by indices.
    static member OffValueDefault : double = 0.0
    /// Default value for Dtype
    /// DType of the output
    static member DtypeDefault : IntOrFloatDType = IntOrFloatDType.Float32
    /// array of locations where to set on_value
    member __.Indices = operatorArguments.GetInput "indices"
    /// Depth of the one hot dimension.
    member __.Depth : int = match operatorArguments.GetParameter "depth" with Some(v) -> unbox v | None -> failwithf "Required parameter depth is missing"
    /// The value assigned to the locations represented by indices.
    member __.OnValue = operatorArguments.GetParameter("on_value", OneHot.OnValueDefault)
    /// The value assigned to the locations not represented by indices.
    member __.OffValue = operatorArguments.GetParameter("off_value", OneHot.OffValueDefault)
    /// DType of the output
    member __.Dtype = operatorArguments.GetParameter("dtype", OneHot.DtypeDefault)
    /// <summary>Copy OneHot instance with updated inputs/parameters.</summary>
    /// <param name="indices">array of locations where to set on_value</param>
    /// <param name="depth">Depth of the one hot dimension.</param>
    /// <param name="onValue">The value assigned to the locations represented by indices.</param>
    /// <param name="offValue">The value assigned to the locations not represented by indices.</param>
    /// <param name="dtype">DType of the output</param>
    member this.With([<Optional>] ?indices : Symbol,
        [<Optional>] ?depth : int,
        [<Optional>] ?onValue : double,
        [<Optional>] ?offValue : double,
        [<Optional>] ?dtype : IntOrFloatDType) = 
        let operatorArguments = 
            [
                indices |> Option.map (fun x -> "indices", Input x)
                depth |> Option.map (fun x -> "depth", Parameter(Some (box x)))
                onValue |> Option.map (fun x -> "on_value", Parameter(Some (box x)))
                offValue |> Option.map (fun x -> "off_value", Parameter(Some (box x)))
                dtype |> Option.map (fun x -> "dtype", Parameter(Some (box x)))
            ] |> List.choose id
        new OneHot(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type GatherNd private (operatorArguments) = 
    inherit SymbolOperator("gather_nd", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new GatherNd(args)
    override this.WithArguments(args : Arguments<Symbol>) = new GatherNd(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <summary>Gather elements or slices from `data` and store to a tensor whose
    /// shape is defined by `indices`.
    /// 
    /// Given `data` with shape `(X_0, X_1, ..., X_{N-1})` and indices with shape
    /// `(M, Y_0, ..., Y_{K-1})`, the output will have shape `(Y_0, ..., Y_{K-1}, X_M, ..., X_{N-1})`,
    /// where `M &lt;= N`. If `M == N`, output shape will simply be `(Y_0, ..., Y_{K-1})`.
    /// 
    /// The elements in output is defined as follows::
    /// 
    ///   output[y_0, ..., y_{K-1}, x_M, ..., x_{N-1}] = data[indices[0, y_0, ..., y_{K-1}],
    ///                                                       ...,
    ///                                                       indices[M-1, y_0, ..., y_{K-1}],
    ///                                                       x_M, ..., x_{N-1}]
    /// 
    /// Examples::
    /// 
    ///   data = [[0, 1], [2, 3]]
    ///   indices = [[1, 1, 0], [0, 1, 0]]
    ///   gather_nd(data, indices) = [2, 3, 0]
    /// 
    ///   data = [[[1, 2], [3, 4]], [[5, 6], [7, 8]]]
    ///   indices = [[0, 1], [1, 0]]
    ///   gather_nd(data, indices) = [[3, 4], [5, 6]]
    /// 
    /// </summary>
    /// <param name="data">data</param>
    /// <param name="indices">indices</param>
    new([<Optional>] ?data : Symbol,
        [<Optional>] ?indices : Symbol) = 
        let data = defaultArg data (new ImplicitVariable() :> Symbol)
        let indices = defaultArg indices (new ImplicitVariable() :> Symbol)
        let operatorArguments = 
            [
                "data", Input data
                "indices", Input indices
            ]
        new GatherNd(Arguments<Symbol>(operatorArguments))
    /// data
    member __.Data = operatorArguments.GetInput "data"
    /// indices
    member __.Indices = operatorArguments.GetInput "indices"
    /// <summary>Copy GatherNd instance with updated inputs/parameters.</summary>
    /// <param name="data">data</param>
    /// <param name="indices">indices</param>
    member this.With([<Optional>] ?data : Symbol,
        [<Optional>] ?indices : Symbol) = 
        let operatorArguments = 
            [
                data |> Option.map (fun x -> "data", Input x)
                indices |> Option.map (fun x -> "indices", Input x)
            ] |> List.choose id
        new GatherNd(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type ScatterNd private (operatorArguments) = 
    inherit SymbolOperator("scatter_nd", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new ScatterNd(args)
    override this.WithArguments(args : Arguments<Symbol>) = new ScatterNd(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <summary>Scatters data into a new tensor according to indices.
    /// 
    /// Given `data` with shape `(Y_0, ..., Y_{K-1}, X_M, ..., X_{N-1})` and indices with shape
    /// `(M, Y_0, ..., Y_{K-1})`, the output will have shape `(X_0, X_1, ..., X_{N-1})`,
    /// where `M &lt;= N`. If `M == N`, data shape should simply be `(Y_0, ..., Y_{K-1})`.
    /// 
    /// The elements in output is defined as follows::
    /// 
    ///   output[indices[0, y_0, ..., y_{K-1}],
    ///          ...,
    ///          indices[M-1, y_0, ..., y_{K-1}],
    ///          x_M, ..., x_{N-1}] = data[y_0, ..., y_{K-1}, x_M, ..., x_{N-1}]
    /// 
    /// all other entries in output are 0.
    /// 
    /// .. warning::
    /// 
    ///     If the indices have duplicates, the result will be non-deterministic and
    ///     the gradient of `scatter_nd` will not be correct!!
    /// 
    /// 
    /// Examples::
    /// 
    ///   data = [2, 3, 0]
    ///   indices = [[1, 1, 0], [0, 1, 0]]
    ///   shape = (2, 2)
    ///   scatter_nd(data, indices, shape) = [[0, 0], [2, 3]]
    /// 
    ///   data = [[[1, 2], [3, 4]], [[5, 6], [7, 8]]]
    ///   indices = [[0, 1], [1, 1]]
    ///   shape = (2, 2, 2, 2)
    ///   scatter_nd(data, indices, shape) = [[[[0, 0],
    ///                                         [0, 0]],
    /// 
    ///                                        [[1, 2],
    ///                                         [3, 4]]],
    /// 
    ///                                       [[[0, 0],
    ///                                         [0, 0]],
    /// 
    ///                                        [[5, 6],
    ///                                         [7, 8]]]]
    /// 
    /// </summary>
    /// <param name="data">data</param>
    /// <param name="indices">indices</param>
    /// <param name="shape">Shape of output.</param>
    new(data : Symbol,
        indices : Symbol,
        shape : int seq) = 
        let operatorArguments = 
            [
                "data", Input data
                "indices", Input indices
                "shape", Parameter(Some(box shape))
            ]
        new ScatterNd(Arguments<Symbol>(operatorArguments))
    /// <summary>Scatters data into a new tensor according to indices.
    /// 
    /// Given `data` with shape `(Y_0, ..., Y_{K-1}, X_M, ..., X_{N-1})` and indices with shape
    /// `(M, Y_0, ..., Y_{K-1})`, the output will have shape `(X_0, X_1, ..., X_{N-1})`,
    /// where `M &lt;= N`. If `M == N`, data shape should simply be `(Y_0, ..., Y_{K-1})`.
    /// 
    /// The elements in output is defined as follows::
    /// 
    ///   output[indices[0, y_0, ..., y_{K-1}],
    ///          ...,
    ///          indices[M-1, y_0, ..., y_{K-1}],
    ///          x_M, ..., x_{N-1}] = data[y_0, ..., y_{K-1}, x_M, ..., x_{N-1}]
    /// 
    /// all other entries in output are 0.
    /// 
    /// .. warning::
    /// 
    ///     If the indices have duplicates, the result will be non-deterministic and
    ///     the gradient of `scatter_nd` will not be correct!!
    /// 
    /// 
    /// Examples::
    /// 
    ///   data = [2, 3, 0]
    ///   indices = [[1, 1, 0], [0, 1, 0]]
    ///   shape = (2, 2)
    ///   scatter_nd(data, indices, shape) = [[0, 0], [2, 3]]
    /// 
    ///   data = [[[1, 2], [3, 4]], [[5, 6], [7, 8]]]
    ///   indices = [[0, 1], [1, 1]]
    ///   shape = (2, 2, 2, 2)
    ///   scatter_nd(data, indices, shape) = [[[[0, 0],
    ///                                         [0, 0]],
    /// 
    ///                                        [[1, 2],
    ///                                         [3, 4]]],
    /// 
    ///                                       [[[0, 0],
    ///                                         [0, 0]],
    /// 
    ///                                        [[5, 6],
    ///                                         [7, 8]]]]
    /// 
    /// </summary>
    /// <param name="shape">Shape of output.</param>
    /// <param name="data">data</param>
    /// <param name="indices">indices</param>
    new(shape : int seq,
        [<Optional>] ?data : Symbol,
        [<Optional>] ?indices : Symbol) = 
        let data = defaultArg data (new ImplicitVariable() :> Symbol)
        let indices = defaultArg indices (new ImplicitVariable() :> Symbol)
        let operatorArguments = 
            [
                "data", Input data
                "indices", Input indices
                "shape", Parameter(Some(box shape))
            ]
        new ScatterNd(Arguments<Symbol>(operatorArguments))
    /// data
    member __.Data = operatorArguments.GetInput "data"
    /// indices
    member __.Indices = operatorArguments.GetInput "indices"
    /// Shape of output.
    member __.Shape : int seq = match operatorArguments.GetParameter "shape" with Some(v) -> unbox v | None -> failwithf "Required parameter shape is missing"
    /// <summary>Copy ScatterNd instance with updated inputs/parameters.</summary>
    /// <param name="data">data</param>
    /// <param name="indices">indices</param>
    /// <param name="shape">Shape of output.</param>
    member this.With([<Optional>] ?data : Symbol,
        [<Optional>] ?indices : Symbol,
        [<Optional>] ?shape : int seq) = 
        let operatorArguments = 
            [
                data |> Option.map (fun x -> "data", Input x)
                indices |> Option.map (fun x -> "indices", Input x)
                shape |> Option.map (fun x -> "shape", Parameter(Some (box x)))
            ] |> List.choose id
        new ScatterNd(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type ScatterSetNd private (operatorArguments) = 
    inherit SymbolOperator("_scatter_set_nd", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new ScatterSetNd(args)
    override this.WithArguments(args : Arguments<Symbol>) = new ScatterSetNd(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <summary>This operator has the same functionality as scatter_nd
    /// except that it does not reset the elements not indexed by the input
    /// index `NDArray` in the input data `NDArray`. output should be explicitly
    /// given and be the same as lhs.
    /// 
    /// .. note:: This operator is for internal use only.
    /// 
    /// Examples::
    /// 
    ///   data = [2, 3, 0]
    ///   indices = [[1, 1, 0], [0, 1, 0]]
    ///   out = [[1, 1], [1, 1]]
    ///   _scatter_set_nd(lhs=out, rhs=data, indices=indices, out=out)
    ///   out = [[0, 1], [2, 3]]
    /// 
    /// </summary>
    /// <param name="lhs">source input</param>
    /// <param name="rhs">value to assign</param>
    /// <param name="indices">indices</param>
    /// <param name="shape">Shape of output.</param>
    new(lhs : Symbol,
        rhs : Symbol,
        indices : Symbol,
        shape : int seq) = 
        let operatorArguments = 
            [
                "lhs", Input lhs
                "rhs", Input rhs
                "indices", Input indices
                "shape", Parameter(Some(box shape))
            ]
        new ScatterSetNd(Arguments<Symbol>(operatorArguments))
    /// <summary>This operator has the same functionality as scatter_nd
    /// except that it does not reset the elements not indexed by the input
    /// index `NDArray` in the input data `NDArray`. output should be explicitly
    /// given and be the same as lhs.
    /// 
    /// .. note:: This operator is for internal use only.
    /// 
    /// Examples::
    /// 
    ///   data = [2, 3, 0]
    ///   indices = [[1, 1, 0], [0, 1, 0]]
    ///   out = [[1, 1], [1, 1]]
    ///   _scatter_set_nd(lhs=out, rhs=data, indices=indices, out=out)
    ///   out = [[0, 1], [2, 3]]
    /// 
    /// </summary>
    /// <param name="shape">Shape of output.</param>
    /// <param name="lhs">source input</param>
    /// <param name="rhs">value to assign</param>
    /// <param name="indices">indices</param>
    new(shape : int seq,
        [<Optional>] ?lhs : Symbol,
        [<Optional>] ?rhs : Symbol,
        [<Optional>] ?indices : Symbol) = 
        let lhs = defaultArg lhs (new ImplicitVariable() :> Symbol)
        let rhs = defaultArg rhs (new ImplicitVariable() :> Symbol)
        let indices = defaultArg indices (new ImplicitVariable() :> Symbol)
        let operatorArguments = 
            [
                "lhs", Input lhs
                "rhs", Input rhs
                "indices", Input indices
                "shape", Parameter(Some(box shape))
            ]
        new ScatterSetNd(Arguments<Symbol>(operatorArguments))
    /// source input
    member __.Lhs = operatorArguments.GetInput "lhs"
    /// value to assign
    member __.Rhs = operatorArguments.GetInput "rhs"
    /// indices
    member __.Indices = operatorArguments.GetInput "indices"
    /// Shape of output.
    member __.Shape : int seq = match operatorArguments.GetParameter "shape" with Some(v) -> unbox v | None -> failwithf "Required parameter shape is missing"
    /// <summary>Copy ScatterSetNd instance with updated inputs/parameters.</summary>
    /// <param name="lhs">source input</param>
    /// <param name="rhs">value to assign</param>
    /// <param name="indices">indices</param>
    /// <param name="shape">Shape of output.</param>
    member this.With([<Optional>] ?lhs : Symbol,
        [<Optional>] ?rhs : Symbol,
        [<Optional>] ?indices : Symbol,
        [<Optional>] ?shape : int seq) = 
        let operatorArguments = 
            [
                lhs |> Option.map (fun x -> "lhs", Input x)
                rhs |> Option.map (fun x -> "rhs", Input x)
                indices |> Option.map (fun x -> "indices", Input x)
                shape |> Option.map (fun x -> "shape", Parameter(Some (box x)))
            ] |> List.choose id
        new ScatterSetNd(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type ZerosWithoutDtype private (operatorArguments) = 
    inherit SymbolOperator("_zeros_without_dtype", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new ZerosWithoutDtype(args)
    override this.WithArguments(args : Arguments<Symbol>) = new ZerosWithoutDtype(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <summary>fill target with zeros without default dtype</summary>
    /// <param name="shape">The shape of the output</param>
    /// <param name="dtype">Target data type.</param>
    new([<Optional>] ?shape : int seq,
        [<Optional>] ?dtype : int) = 
        let operatorArguments = 
            [
                "shape", shape |> Option.map box |> Parameter
                "dtype", dtype |> Option.map box |> Parameter
            ]
        new ZerosWithoutDtype(Arguments<Symbol>(operatorArguments))
    /// Default value for Shape
    /// The shape of the output
    static member ShapeDefault : int [] option = None
    /// Default value for Dtype
    /// Target data type.
    static member DtypeDefault : int = -1
    /// The shape of the output
    member __.Shape = operatorArguments.GetParameter("shape", ZerosWithoutDtype.ShapeDefault)
    /// Target data type.
    member __.Dtype = operatorArguments.GetParameter("dtype", ZerosWithoutDtype.DtypeDefault)
    /// <summary>Copy ZerosWithoutDtype instance with updated inputs/parameters.</summary>
    /// <param name="shape">The shape of the output</param>
    /// <param name="dtype">Target data type.</param>
    member this.With([<Optional>] ?shape : int seq,
        [<Optional>] ?dtype : int) = 
        let operatorArguments = 
            [
                shape |> Option.map (fun x -> "shape", Parameter(Some (box x)))
                dtype |> Option.map (fun x -> "dtype", Parameter(Some (box x)))
            ] |> List.choose id
        new ZerosWithoutDtype(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type Zeros private (operatorArguments) = 
    inherit SymbolOperator("_zeros", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new Zeros(args)
    override this.WithArguments(args : Arguments<Symbol>) = new Zeros(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <summary>fill target with zeros</summary>
    /// <param name="shape">The shape of the output</param>
    /// <param name="dtype">Target data type.</param>
    new([<Optional>] ?shape : int seq,
        [<Optional>] ?dtype : IntOrFloatDType) = 
        let operatorArguments = 
            [
                "shape", shape |> Option.map box |> Parameter
                "dtype", dtype |> Option.map box |> Parameter
            ]
        new Zeros(Arguments<Symbol>(operatorArguments))
    /// Default value for Shape
    /// The shape of the output
    static member ShapeDefault : int [] = [||]
    /// Default value for Dtype
    /// Target data type.
    static member DtypeDefault : IntOrFloatDType = IntOrFloatDType.Float32
    /// The shape of the output
    member __.Shape = operatorArguments.GetParameter("shape", Zeros.ShapeDefault)
    /// Target data type.
    member __.Dtype = operatorArguments.GetParameter("dtype", Zeros.DtypeDefault)
    /// <summary>Copy Zeros instance with updated inputs/parameters.</summary>
    /// <param name="shape">The shape of the output</param>
    /// <param name="dtype">Target data type.</param>
    member this.With([<Optional>] ?shape : int seq,
        [<Optional>] ?dtype : IntOrFloatDType) = 
        let operatorArguments = 
            [
                shape |> Option.map (fun x -> "shape", Parameter(Some (box x)))
                dtype |> Option.map (fun x -> "dtype", Parameter(Some (box x)))
            ] |> List.choose id
        new Zeros(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type Eye private (operatorArguments) = 
    inherit SymbolOperator("_eye", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new Eye(args)
    override this.WithArguments(args : Arguments<Symbol>) = new Eye(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <summary>Return a 2-D array with ones on the diagonal and zeros elsewhere.</summary>
    /// <param name="N">Number of rows in the output.</param>
    /// <param name="M">Number of columns in the output. If 0, defaults to N</param>
    /// <param name="k">Index of the diagonal. 0 (the default) refers to the main diagonal.A positive value refers to an upper diagonal.A negative value to a lower diagonal.</param>
    /// <param name="dtype">Target data type.</param>
    new(N : int64,
        [<Optional>] ?M : int64,
        [<Optional>] ?k : int64,
        [<Optional>] ?dtype : IntOrFloatDType) = 
        let operatorArguments = 
            [
                "N", Parameter(Some(box N))
                "M", M |> Option.map box |> Parameter
                "k", k |> Option.map box |> Parameter
                "dtype", dtype |> Option.map box |> Parameter
            ]
        new Eye(Arguments<Symbol>(operatorArguments))
    /// Default value for M
    /// Number of columns in the output. If 0, defaults to N
    static member MDefault : int64 = 0L
    /// Default value for K
    /// Index of the diagonal. 0 (the default) refers to the main diagonal.A positive value refers to an upper diagonal.A negative value to a lower diagonal.
    static member KDefault : int64 = 0L
    /// Default value for Dtype
    /// Target data type.
    static member DtypeDefault : IntOrFloatDType = IntOrFloatDType.Float32
    /// Number of rows in the output.
    member __.N : int64 = match operatorArguments.GetParameter "N" with Some(v) -> unbox v | None -> failwithf "Required parameter N is missing"
    /// Number of columns in the output. If 0, defaults to N
    member __.M = operatorArguments.GetParameter("M", Eye.MDefault)
    /// Index of the diagonal. 0 (the default) refers to the main diagonal.A positive value refers to an upper diagonal.A negative value to a lower diagonal.
    member __.K = operatorArguments.GetParameter("k", Eye.KDefault)
    /// Target data type.
    member __.Dtype = operatorArguments.GetParameter("dtype", Eye.DtypeDefault)
    /// <summary>Copy Eye instance with updated inputs/parameters.</summary>
    /// <param name="N">Number of rows in the output.</param>
    /// <param name="M">Number of columns in the output. If 0, defaults to N</param>
    /// <param name="k">Index of the diagonal. 0 (the default) refers to the main diagonal.A positive value refers to an upper diagonal.A negative value to a lower diagonal.</param>
    /// <param name="dtype">Target data type.</param>
    member this.With([<Optional>] ?N : int64,
        [<Optional>] ?M : int64,
        [<Optional>] ?k : int64,
        [<Optional>] ?dtype : IntOrFloatDType) = 
        let operatorArguments = 
            [
                N |> Option.map (fun x -> "N", Parameter(Some (box x)))
                M |> Option.map (fun x -> "M", Parameter(Some (box x)))
                k |> Option.map (fun x -> "k", Parameter(Some (box x)))
                dtype |> Option.map (fun x -> "dtype", Parameter(Some (box x)))
            ] |> List.choose id
        new Eye(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type Ones private (operatorArguments) = 
    inherit SymbolOperator("_ones", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new Ones(args)
    override this.WithArguments(args : Arguments<Symbol>) = new Ones(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <summary>fill target with ones</summary>
    /// <param name="shape">The shape of the output</param>
    /// <param name="dtype">Target data type.</param>
    new([<Optional>] ?shape : int seq,
        [<Optional>] ?dtype : IntOrFloatDType) = 
        let operatorArguments = 
            [
                "shape", shape |> Option.map box |> Parameter
                "dtype", dtype |> Option.map box |> Parameter
            ]
        new Ones(Arguments<Symbol>(operatorArguments))
    /// Default value for Shape
    /// The shape of the output
    static member ShapeDefault : int [] = [||]
    /// Default value for Dtype
    /// Target data type.
    static member DtypeDefault : IntOrFloatDType = IntOrFloatDType.Float32
    /// The shape of the output
    member __.Shape = operatorArguments.GetParameter("shape", Ones.ShapeDefault)
    /// Target data type.
    member __.Dtype = operatorArguments.GetParameter("dtype", Ones.DtypeDefault)
    /// <summary>Copy Ones instance with updated inputs/parameters.</summary>
    /// <param name="shape">The shape of the output</param>
    /// <param name="dtype">Target data type.</param>
    member this.With([<Optional>] ?shape : int seq,
        [<Optional>] ?dtype : IntOrFloatDType) = 
        let operatorArguments = 
            [
                shape |> Option.map (fun x -> "shape", Parameter(Some (box x)))
                dtype |> Option.map (fun x -> "dtype", Parameter(Some (box x)))
            ] |> List.choose id
        new Ones(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type Full private (operatorArguments) = 
    inherit SymbolOperator("_full", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new Full(args)
    override this.WithArguments(args : Arguments<Symbol>) = new Full(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <summary>fill target with a scalar value</summary>
    /// <param name="value">Value with which to fill newly created tensor</param>
    /// <param name="shape">The shape of the output</param>
    /// <param name="dtype">Target data type.</param>
    new(value : double,
        [<Optional>] ?shape : int seq,
        [<Optional>] ?dtype : IntOrFloatDType) = 
        let operatorArguments = 
            [
                "value", Parameter(Some(box value))
                "shape", shape |> Option.map box |> Parameter
                "dtype", dtype |> Option.map box |> Parameter
            ]
        new Full(Arguments<Symbol>(operatorArguments))
    /// Default value for Shape
    /// The shape of the output
    static member ShapeDefault : int [] option = None
    /// Default value for Dtype
    /// Target data type.
    static member DtypeDefault : IntOrFloatDType = IntOrFloatDType.Float32
    /// Value with which to fill newly created tensor
    member __.Value : double = match operatorArguments.GetParameter "value" with Some(v) -> unbox v | None -> failwithf "Required parameter value is missing"
    /// The shape of the output
    member __.Shape = operatorArguments.GetParameter("shape", Full.ShapeDefault)
    /// Target data type.
    member __.Dtype = operatorArguments.GetParameter("dtype", Full.DtypeDefault)
    /// <summary>Copy Full instance with updated inputs/parameters.</summary>
    /// <param name="value">Value with which to fill newly created tensor</param>
    /// <param name="shape">The shape of the output</param>
    /// <param name="dtype">Target data type.</param>
    member this.With([<Optional>] ?value : double,
        [<Optional>] ?shape : int seq,
        [<Optional>] ?dtype : IntOrFloatDType) = 
        let operatorArguments = 
            [
                value |> Option.map (fun x -> "value", Parameter(Some (box x)))
                shape |> Option.map (fun x -> "shape", Parameter(Some (box x)))
                dtype |> Option.map (fun x -> "dtype", Parameter(Some (box x)))
            ] |> List.choose id
        new Full(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type Arange private (operatorArguments) = 
    inherit SymbolOperator("_arange", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new Arange(args)
    override this.WithArguments(args : Arguments<Symbol>) = new Arange(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <summary>Return evenly spaced values within a given interval. Similar to Numpy</summary>
    /// <param name="start">Start of interval. The interval includes this value. The default start value is 0.</param>
    /// <param name="stop">End of interval. The interval does not include this value, except in some cases where step is not an integer and floating point round-off affects the length of out.</param>
    /// <param name="step">Spacing between values.</param>
    /// <param name="repeat">The repeating time of all elements. E.g repeat=3, the element a will be repeated three times --&gt; a, a, a.</param>
    /// <param name="inferRange">When set to True, infer the stop position from the start, step, repeat, and output tensor size.</param>
    /// <param name="dtype">Target data type.</param>
    new(start : double,
        [<Optional>] ?stop : float,
        [<Optional>] ?step : double,
        [<Optional>] ?repeat : int,
        [<Optional>] ?inferRange : bool,
        [<Optional>] ?dtype : IntOrFloatDType) = 
        let operatorArguments = 
            [
                "start", Parameter(Some(box start))
                "stop", stop |> Option.map box |> Parameter
                "step", step |> Option.map box |> Parameter
                "repeat", repeat |> Option.map box |> Parameter
                "infer_range", inferRange |> Option.map box |> Parameter
                "dtype", dtype |> Option.map box |> Parameter
            ]
        new Arange(Arguments<Symbol>(operatorArguments))
    /// Default value for Stop
    /// End of interval. The interval does not include this value, except in some cases where step is not an integer and floating point round-off affects the length of out.
    static member StopDefault : double option = None
    /// Default value for Step
    /// Spacing between values.
    static member StepDefault : double = 1.0
    /// Default value for Repeat
    /// The repeating time of all elements. E.g repeat=3, the element a will be repeated three times --&gt; a, a, a.
    static member RepeatDefault : int = 1
    /// Default value for InferRange
    /// When set to True, infer the stop position from the start, step, repeat, and output tensor size.
    static member InferRangeDefault : bool = false
    /// Default value for Dtype
    /// Target data type.
    static member DtypeDefault : IntOrFloatDType = IntOrFloatDType.Float32
    /// Start of interval. The interval includes this value. The default start value is 0.
    member __.Start : double = match operatorArguments.GetParameter "start" with Some(v) -> unbox v | None -> failwithf "Required parameter start is missing"
    /// End of interval. The interval does not include this value, except in some cases where step is not an integer and floating point round-off affects the length of out.
    member __.Stop = operatorArguments.GetParameter("stop", Arange.StopDefault)
    /// Spacing between values.
    member __.Step = operatorArguments.GetParameter("step", Arange.StepDefault)
    /// The repeating time of all elements. E.g repeat=3, the element a will be repeated three times --&gt; a, a, a.
    member __.Repeat = operatorArguments.GetParameter("repeat", Arange.RepeatDefault)
    /// When set to True, infer the stop position from the start, step, repeat, and output tensor size.
    member __.InferRange = operatorArguments.GetParameter("infer_range", Arange.InferRangeDefault)
    /// Target data type.
    member __.Dtype = operatorArguments.GetParameter("dtype", Arange.DtypeDefault)
    /// <summary>Copy Arange instance with updated inputs/parameters.</summary>
    /// <param name="start">Start of interval. The interval includes this value. The default start value is 0.</param>
    /// <param name="stop">End of interval. The interval does not include this value, except in some cases where step is not an integer and floating point round-off affects the length of out.</param>
    /// <param name="step">Spacing between values.</param>
    /// <param name="repeat">The repeating time of all elements. E.g repeat=3, the element a will be repeated three times --&gt; a, a, a.</param>
    /// <param name="inferRange">When set to True, infer the stop position from the start, step, repeat, and output tensor size.</param>
    /// <param name="dtype">Target data type.</param>
    member this.With([<Optional>] ?start : double,
        [<Optional>] ?stop : float,
        [<Optional>] ?step : double,
        [<Optional>] ?repeat : int,
        [<Optional>] ?inferRange : bool,
        [<Optional>] ?dtype : IntOrFloatDType) = 
        let operatorArguments = 
            [
                start |> Option.map (fun x -> "start", Parameter(Some (box x)))
                stop |> Option.map (fun x -> "stop", Parameter(Some (box x)))
                step |> Option.map (fun x -> "step", Parameter(Some (box x)))
                repeat |> Option.map (fun x -> "repeat", Parameter(Some (box x)))
                inferRange |> Option.map (fun x -> "infer_range", Parameter(Some (box x)))
                dtype |> Option.map (fun x -> "dtype", Parameter(Some (box x)))
            ] |> List.choose id
        new Arange(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type ContribArangeLike private (operatorArguments) = 
    inherit SymbolOperator("_contrib_arange_like", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new ContribArangeLike(args)
    override this.WithArguments(args : Arguments<Symbol>) = new ContribArangeLike(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <summary>Return an array with evenly spaced values. If axis is not given, the output will 
    /// have the same shape as the input array. Otherwise, the output will be a 1-D array with size of 
    /// the specified axis in input shape.
    /// 
    /// Examples::
    /// 
    ///   x = [[0.14883883 0.7772398  0.94865847 0.7225052 ]
    ///        [0.23729339 0.6112595  0.66538996 0.5132841 ]
    ///        [0.30822644 0.9912457  0.15502319 0.7043658 ]]
    ///        &lt;NDArray 3x4 @cpu(0)&gt;
    /// 
    ///   out = mx.nd.contrib.arange_like(x, start=0)
    /// 
    ///     [[ 0.  1.  2.  3.]
    ///      [ 4.  5.  6.  7.]
    ///      [ 8.  9. 10. 11.]]
    ///      &lt;NDArray 3x4 @cpu(0)&gt;
    /// 
    ///   out = mx.nd.contrib.arange_like(x, start=0, axis=-1)
    /// 
    ///     [0. 1. 2. 3.]
    ///     &lt;NDArray 4 @cpu(0)&gt;
    /// </summary>
    /// <param name="data">The input</param>
    /// <param name="start">Start of interval. The interval includes this value. The default start value is 0.</param>
    /// <param name="step">Spacing between values.</param>
    /// <param name="repeat">The repeating time of all elements. E.g repeat=3, the element a will be repeated three times --&gt; a, a, a.</param>
    /// <param name="axis">Arange elements according to the size of a certain axis of input array. The negative numbers are interpreted counting from the backward. If not provided, will arange elements according to the input shape.</param>
    new([<Optional>] ?data : Symbol,
        [<Optional>] ?start : double,
        [<Optional>] ?step : double,
        [<Optional>] ?repeat : int,
        [<Optional>] ?axis : int) = 
        let data = defaultArg data (new ImplicitVariable() :> Symbol)
        let operatorArguments = 
            [
                "data", Input data
                "start", start |> Option.map box |> Parameter
                "step", step |> Option.map box |> Parameter
                "repeat", repeat |> Option.map box |> Parameter
                "axis", axis |> Option.map box |> Parameter
            ]
        new ContribArangeLike(Arguments<Symbol>(operatorArguments))
    /// Default value for Start
    /// Start of interval. The interval includes this value. The default start value is 0.
    static member StartDefault : double = 0.0
    /// Default value for Step
    /// Spacing between values.
    static member StepDefault : double = 1.0
    /// Default value for Repeat
    /// The repeating time of all elements. E.g repeat=3, the element a will be repeated three times --&gt; a, a, a.
    static member RepeatDefault : int = 1
    /// Default value for Axis
    /// Arange elements according to the size of a certain axis of input array. The negative numbers are interpreted counting from the backward. If not provided, will arange elements according to the input shape.
    static member AxisDefault : int option = None
    /// The input
    member __.Data = operatorArguments.GetInput "data"
    /// Start of interval. The interval includes this value. The default start value is 0.
    member __.Start = operatorArguments.GetParameter("start", ContribArangeLike.StartDefault)
    /// Spacing between values.
    member __.Step = operatorArguments.GetParameter("step", ContribArangeLike.StepDefault)
    /// The repeating time of all elements. E.g repeat=3, the element a will be repeated three times --&gt; a, a, a.
    member __.Repeat = operatorArguments.GetParameter("repeat", ContribArangeLike.RepeatDefault)
    /// Arange elements according to the size of a certain axis of input array. The negative numbers are interpreted counting from the backward. If not provided, will arange elements according to the input shape.
    member __.Axis = operatorArguments.GetParameter("axis", ContribArangeLike.AxisDefault)
    /// <summary>Copy ContribArangeLike instance with updated inputs/parameters.</summary>
    /// <param name="data">The input</param>
    /// <param name="start">Start of interval. The interval includes this value. The default start value is 0.</param>
    /// <param name="step">Spacing between values.</param>
    /// <param name="repeat">The repeating time of all elements. E.g repeat=3, the element a will be repeated three times --&gt; a, a, a.</param>
    /// <param name="axis">Arange elements according to the size of a certain axis of input array. The negative numbers are interpreted counting from the backward. If not provided, will arange elements according to the input shape.</param>
    member this.With([<Optional>] ?data : Symbol,
        [<Optional>] ?start : double,
        [<Optional>] ?step : double,
        [<Optional>] ?repeat : int,
        [<Optional>] ?axis : int) = 
        let operatorArguments = 
            [
                data |> Option.map (fun x -> "data", Input x)
                start |> Option.map (fun x -> "start", Parameter(Some (box x)))
                step |> Option.map (fun x -> "step", Parameter(Some (box x)))
                repeat |> Option.map (fun x -> "repeat", Parameter(Some (box x)))
                axis |> Option.map (fun x -> "axis", Parameter(Some (box x)))
            ] |> List.choose id
        new ContribArangeLike(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type Linspace private (operatorArguments) = 
    inherit SymbolOperator("_linspace", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new Linspace(args)
    override this.WithArguments(args : Arguments<Symbol>) = new Linspace(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <summary>Return evenly spaced numbers over a specified interval. Similar to Numpy</summary>
    /// <param name="start">Start of interval. The interval includes this value. The default start value is 0.</param>
    /// <param name="stop">End of interval. The interval does not include this value, except in some cases where step is not an integer and floating point round-off affects the length of out.</param>
    /// <param name="step">Spacing between values.</param>
    /// <param name="repeat">The repeating time of all elements. E.g repeat=3, the element a will be repeated three times --&gt; a, a, a.</param>
    /// <param name="inferRange">When set to True, infer the stop position from the start, step, repeat, and output tensor size.</param>
    /// <param name="dtype">Target data type.</param>
    new(start : double,
        [<Optional>] ?stop : float,
        [<Optional>] ?step : double,
        [<Optional>] ?repeat : int,
        [<Optional>] ?inferRange : bool,
        [<Optional>] ?dtype : IntOrFloatDType) = 
        let operatorArguments = 
            [
                "start", Parameter(Some(box start))
                "stop", stop |> Option.map box |> Parameter
                "step", step |> Option.map box |> Parameter
                "repeat", repeat |> Option.map box |> Parameter
                "infer_range", inferRange |> Option.map box |> Parameter
                "dtype", dtype |> Option.map box |> Parameter
            ]
        new Linspace(Arguments<Symbol>(operatorArguments))
    /// Default value for Stop
    /// End of interval. The interval does not include this value, except in some cases where step is not an integer and floating point round-off affects the length of out.
    static member StopDefault : double option = None
    /// Default value for Step
    /// Spacing between values.
    static member StepDefault : double = 1.0
    /// Default value for Repeat
    /// The repeating time of all elements. E.g repeat=3, the element a will be repeated three times --&gt; a, a, a.
    static member RepeatDefault : int = 1
    /// Default value for InferRange
    /// When set to True, infer the stop position from the start, step, repeat, and output tensor size.
    static member InferRangeDefault : bool = false
    /// Default value for Dtype
    /// Target data type.
    static member DtypeDefault : IntOrFloatDType = IntOrFloatDType.Float32
    /// Start of interval. The interval includes this value. The default start value is 0.
    member __.Start : double = match operatorArguments.GetParameter "start" with Some(v) -> unbox v | None -> failwithf "Required parameter start is missing"
    /// End of interval. The interval does not include this value, except in some cases where step is not an integer and floating point round-off affects the length of out.
    member __.Stop = operatorArguments.GetParameter("stop", Linspace.StopDefault)
    /// Spacing between values.
    member __.Step = operatorArguments.GetParameter("step", Linspace.StepDefault)
    /// The repeating time of all elements. E.g repeat=3, the element a will be repeated three times --&gt; a, a, a.
    member __.Repeat = operatorArguments.GetParameter("repeat", Linspace.RepeatDefault)
    /// When set to True, infer the stop position from the start, step, repeat, and output tensor size.
    member __.InferRange = operatorArguments.GetParameter("infer_range", Linspace.InferRangeDefault)
    /// Target data type.
    member __.Dtype = operatorArguments.GetParameter("dtype", Linspace.DtypeDefault)
    /// <summary>Copy Linspace instance with updated inputs/parameters.</summary>
    /// <param name="start">Start of interval. The interval includes this value. The default start value is 0.</param>
    /// <param name="stop">End of interval. The interval does not include this value, except in some cases where step is not an integer and floating point round-off affects the length of out.</param>
    /// <param name="step">Spacing between values.</param>
    /// <param name="repeat">The repeating time of all elements. E.g repeat=3, the element a will be repeated three times --&gt; a, a, a.</param>
    /// <param name="inferRange">When set to True, infer the stop position from the start, step, repeat, and output tensor size.</param>
    /// <param name="dtype">Target data type.</param>
    member this.With([<Optional>] ?start : double,
        [<Optional>] ?stop : float,
        [<Optional>] ?step : double,
        [<Optional>] ?repeat : int,
        [<Optional>] ?inferRange : bool,
        [<Optional>] ?dtype : IntOrFloatDType) = 
        let operatorArguments = 
            [
                start |> Option.map (fun x -> "start", Parameter(Some (box x)))
                stop |> Option.map (fun x -> "stop", Parameter(Some (box x)))
                step |> Option.map (fun x -> "step", Parameter(Some (box x)))
                repeat |> Option.map (fun x -> "repeat", Parameter(Some (box x)))
                inferRange |> Option.map (fun x -> "infer_range", Parameter(Some (box x)))
                dtype |> Option.map (fun x -> "dtype", Parameter(Some (box x)))
            ] |> List.choose id
        new Linspace(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type ZerosLike private (operatorArguments) = 
    inherit SymbolOperator("zeros_like", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new ZerosLike(args)
    override this.WithArguments(args : Arguments<Symbol>) = new ZerosLike(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <summary>Return an array of zeros with the same shape, type and storage type
    /// as the input array.
    /// 
    /// The storage type of ``zeros_like`` output depends on the storage type of the input
    /// 
    /// - zeros_like(row_sparse) = row_sparse
    /// - zeros_like(csr) = csr
    /// - zeros_like(default) = default
    /// 
    /// Examples::
    /// 
    ///   x = [[ 1.,  1.,  1.],
    ///        [ 1.,  1.,  1.]]
    /// 
    ///   zeros_like(x) = [[ 0.,  0.,  0.],
    ///                    [ 0.,  0.,  0.]]
    /// 
    /// </summary>
    /// <param name="data">The input</param>
    new([<Optional>] ?data : Symbol) =
        let data = defaultArg data (new ImplicitVariable() :> Symbol)
        let operatorArguments = 
            [
                "data", Input data
            ]
        new ZerosLike(Arguments<Symbol>(operatorArguments))
    /// The input
    member __.Data = operatorArguments.GetInput "data"
    /// <summary>Copy ZerosLike instance with updated inputs/parameters.</summary>
    /// <param name="data">The input</param>
    member this.With([<Optional>] ?data : Symbol) =
        let operatorArguments = 
            [
                data |> Option.map (fun x -> "data", Input x)
            ] |> List.choose id
        new ZerosLike(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type OnesLike private (operatorArguments) = 
    inherit SymbolOperator("ones_like", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new OnesLike(args)
    override this.WithArguments(args : Arguments<Symbol>) = new OnesLike(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <summary>Return an array of ones with the same shape and type
    /// as the input array.
    /// 
    /// Examples::
    /// 
    ///   x = [[ 0.,  0.,  0.],
    ///        [ 0.,  0.,  0.]]
    /// 
    ///   ones_like(x) = [[ 1.,  1.,  1.],
    ///                   [ 1.,  1.,  1.]]
    /// 
    /// </summary>
    /// <param name="data">The input</param>
    new([<Optional>] ?data : Symbol) =
        let data = defaultArg data (new ImplicitVariable() :> Symbol)
        let operatorArguments = 
            [
                "data", Input data
            ]
        new OnesLike(Arguments<Symbol>(operatorArguments))
    /// The input
    member __.Data = operatorArguments.GetInput "data"
    /// <summary>Copy OnesLike instance with updated inputs/parameters.</summary>
    /// <param name="data">The input</param>
    member this.With([<Optional>] ?data : Symbol) =
        let operatorArguments = 
            [
                data |> Option.map (fun x -> "data", Input x)
            ] |> List.choose id
        new OnesLike(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type LinalgGemm private (operatorArguments) = 
    inherit SymbolOperator("_linalg_gemm", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new LinalgGemm(args)
    override this.WithArguments(args : Arguments<Symbol>) = new LinalgGemm(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <summary>Performs general matrix multiplication and accumulation.
    /// Input are tensors *A*, *B*, *C*, each of dimension *n &gt;= 2* and having the same shape
    /// on the leading *n-2* dimensions.
    /// 
    /// If *n=2*, the BLAS3 function *gemm* is performed:
    /// 
    ///    *out* = *alpha* \* *op*\ (*A*) \* *op*\ (*B*) + *beta* \* *C*
    /// 
    /// Here, *alpha* and *beta* are scalar parameters, and *op()* is either the identity or
    /// matrix transposition (depending on *transpose_a*, *transpose_b*).
    /// 
    /// If *n&gt;2*, *gemm* is performed separately for a batch of matrices. The column indices of the matrices
    /// are given by the last dimensions of the tensors, the row indices by the axis specified with the *axis*
    /// parameter. By default, the trailing two dimensions will be used for matrix encoding.
    /// 
    /// For a non-default axis parameter, the operation performed is equivalent to a series of swapaxes/gemm/swapaxes
    /// calls. For example let *A*, *B*, *C* be 5 dimensional tensors. Then gemm(*A*, *B*, *C*, axis=1) is equivalent
    /// to the following without the overhead of the additional swapaxis operations::
    /// 
    ///     A1 = swapaxes(A, dim1=1, dim2=3)
    ///     B1 = swapaxes(B, dim1=1, dim2=3)
    ///     C = swapaxes(C, dim1=1, dim2=3)
    ///     C = gemm(A1, B1, C)
    ///     C = swapaxis(C, dim1=1, dim2=3)
    /// 
    /// When the input data is of type float32 and the environment variables MXNET_CUDA_ALLOW_TENSOR_CORE
    /// and MXNET_CUDA_TENSOR_OP_MATH_ALLOW_CONVERSION are set to 1, this operator will try to use
    /// pseudo-float16 precision (float32 math with float16 I/O) precision in order to use
    /// Tensor Cores on suitable NVIDIA GPUs. This can sometimes give significant speedups.
    /// 
    /// .. note:: The operator supports float32 and float64 data types only.
    /// 
    /// Examples::
    /// 
    ///    Single matrix multiply-add
    ///    A = [[1.0, 1.0], [1.0, 1.0]]
    ///    B = [[1.0, 1.0], [1.0, 1.0], [1.0, 1.0]]
    ///    C = [[1.0, 1.0, 1.0], [1.0, 1.0, 1.0]]
    ///    gemm(A, B, C, transpose_b=True, alpha=2.0, beta=10.0)
    ///            = [[14.0, 14.0, 14.0], [14.0, 14.0, 14.0]]
    /// 
    ///    Batch matrix multiply-add
    ///    A = [[[1.0, 1.0]], [[0.1, 0.1]]]
    ///    B = [[[1.0, 1.0]], [[0.1, 0.1]]]
    ///    C = [[[10.0]], [[0.01]]]
    ///    gemm(A, B, C, transpose_b=True, alpha=2.0 , beta=10.0)
    ///            = [[[104.0]], [[0.14]]]
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\la_op.cc:L89</summary>
    /// <param name="A">Tensor of input matrices</param>
    /// <param name="B">Tensor of input matrices</param>
    /// <param name="C">Tensor of input matrices</param>
    /// <param name="transposeA">Multiply with transposed of first input (A).</param>
    /// <param name="transposeB">Multiply with transposed of second input (B).</param>
    /// <param name="alpha">Scalar factor multiplied with A*B.</param>
    /// <param name="beta">Scalar factor multiplied with C.</param>
    /// <param name="axis">Axis corresponding to the matrix rows.</param>
    new([<Optional>] ?A : Symbol,
        [<Optional>] ?B : Symbol,
        [<Optional>] ?C : Symbol,
        [<Optional>] ?transposeA : bool,
        [<Optional>] ?transposeB : bool,
        [<Optional>] ?alpha : double,
        [<Optional>] ?beta : double,
        [<Optional>] ?axis : int) = 
        let A = defaultArg A (new ImplicitVariable() :> Symbol)
        let B = defaultArg B (new ImplicitVariable() :> Symbol)
        let C = defaultArg C (new ImplicitVariable() :> Symbol)
        let operatorArguments = 
            [
                "A", Input A
                "B", Input B
                "C", Input C
                "transpose_a", transposeA |> Option.map box |> Parameter
                "transpose_b", transposeB |> Option.map box |> Parameter
                "alpha", alpha |> Option.map box |> Parameter
                "beta", beta |> Option.map box |> Parameter
                "axis", axis |> Option.map box |> Parameter
            ]
        new LinalgGemm(Arguments<Symbol>(operatorArguments))
    /// Default value for TransposeA
    /// Multiply with transposed of first input (A).
    static member TransposeADefault : bool = false
    /// Default value for TransposeB
    /// Multiply with transposed of second input (B).
    static member TransposeBDefault : bool = false
    /// Default value for Alpha
    /// Scalar factor multiplied with A*B.
    static member AlphaDefault : double = 1.0
    /// Default value for Beta
    /// Scalar factor multiplied with C.
    static member BetaDefault : double = 1.0
    /// Default value for Axis
    /// Axis corresponding to the matrix rows.
    static member AxisDefault : int = -2
    /// Tensor of input matrices
    member __.A = operatorArguments.GetInput "A"
    /// Tensor of input matrices
    member __.B = operatorArguments.GetInput "B"
    /// Tensor of input matrices
    member __.C = operatorArguments.GetInput "C"
    /// Multiply with transposed of first input (A).
    member __.TransposeA = operatorArguments.GetParameter("transpose_a", LinalgGemm.TransposeADefault)
    /// Multiply with transposed of second input (B).
    member __.TransposeB = operatorArguments.GetParameter("transpose_b", LinalgGemm.TransposeBDefault)
    /// Scalar factor multiplied with A*B.
    member __.Alpha = operatorArguments.GetParameter("alpha", LinalgGemm.AlphaDefault)
    /// Scalar factor multiplied with C.
    member __.Beta = operatorArguments.GetParameter("beta", LinalgGemm.BetaDefault)
    /// Axis corresponding to the matrix rows.
    member __.Axis = operatorArguments.GetParameter("axis", LinalgGemm.AxisDefault)
    /// <summary>Copy LinalgGemm instance with updated inputs/parameters.</summary>
    /// <param name="A">Tensor of input matrices</param>
    /// <param name="B">Tensor of input matrices</param>
    /// <param name="C">Tensor of input matrices</param>
    /// <param name="transposeA">Multiply with transposed of first input (A).</param>
    /// <param name="transposeB">Multiply with transposed of second input (B).</param>
    /// <param name="alpha">Scalar factor multiplied with A*B.</param>
    /// <param name="beta">Scalar factor multiplied with C.</param>
    /// <param name="axis">Axis corresponding to the matrix rows.</param>
    member this.With([<Optional>] ?A : Symbol,
        [<Optional>] ?B : Symbol,
        [<Optional>] ?C : Symbol,
        [<Optional>] ?transposeA : bool,
        [<Optional>] ?transposeB : bool,
        [<Optional>] ?alpha : double,
        [<Optional>] ?beta : double,
        [<Optional>] ?axis : int) = 
        let operatorArguments = 
            [
                A |> Option.map (fun x -> "A", Input x)
                B |> Option.map (fun x -> "B", Input x)
                C |> Option.map (fun x -> "C", Input x)
                transposeA |> Option.map (fun x -> "transpose_a", Parameter(Some (box x)))
                transposeB |> Option.map (fun x -> "transpose_b", Parameter(Some (box x)))
                alpha |> Option.map (fun x -> "alpha", Parameter(Some (box x)))
                beta |> Option.map (fun x -> "beta", Parameter(Some (box x)))
                axis |> Option.map (fun x -> "axis", Parameter(Some (box x)))
            ] |> List.choose id
        new LinalgGemm(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type LinalgGemm2 private (operatorArguments) = 
    inherit SymbolOperator("_linalg_gemm2", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new LinalgGemm2(args)
    override this.WithArguments(args : Arguments<Symbol>) = new LinalgGemm2(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <summary>Performs general matrix multiplication.
    /// Input are tensors *A*, *B*, each of dimension *n &gt;= 2* and having the same shape
    /// on the leading *n-2* dimensions.
    /// 
    /// If *n=2*, the BLAS3 function *gemm* is performed:
    /// 
    ///    *out* = *alpha* \* *op*\ (*A*) \* *op*\ (*B*)
    /// 
    /// Here *alpha* is a scalar parameter and *op()* is either the identity or the matrix
    /// transposition (depending on *transpose_a*, *transpose_b*).
    /// 
    /// If *n&gt;2*, *gemm* is performed separately for a batch of matrices. The column indices of the matrices
    /// are given by the last dimensions of the tensors, the row indices by the axis specified with the *axis*
    /// parameter. By default, the trailing two dimensions will be used for matrix encoding.
    /// 
    /// For a non-default axis parameter, the operation performed is equivalent to a series of swapaxes/gemm/swapaxes
    /// calls. For example let *A*, *B* be 5 dimensional tensors. Then gemm(*A*, *B*, axis=1) is equivalent to
    /// the following without the overhead of the additional swapaxis operations::
    /// 
    ///     A1 = swapaxes(A, dim1=1, dim2=3)
    ///     B1 = swapaxes(B, dim1=1, dim2=3)
    ///     C = gemm2(A1, B1)
    ///     C = swapaxis(C, dim1=1, dim2=3)
    /// 
    /// When the input data is of type float32 and the environment variables MXNET_CUDA_ALLOW_TENSOR_CORE
    /// and MXNET_CUDA_TENSOR_OP_MATH_ALLOW_CONVERSION are set to 1, this operator will try to use
    /// pseudo-float16 precision (float32 math with float16 I/O) precision in order to use
    /// Tensor Cores on suitable NVIDIA GPUs. This can sometimes give significant speedups.
    /// 
    /// .. note:: The operator supports float32 and float64 data types only.
    /// 
    /// Examples::
    /// 
    ///    Single matrix multiply
    ///    A = [[1.0, 1.0], [1.0, 1.0]]
    ///    B = [[1.0, 1.0], [1.0, 1.0], [1.0, 1.0]]
    ///    gemm2(A, B, transpose_b=True, alpha=2.0)
    ///             = [[4.0, 4.0, 4.0], [4.0, 4.0, 4.0]]
    /// 
    ///    Batch matrix multiply
    ///    A = [[[1.0, 1.0]], [[0.1, 0.1]]]
    ///    B = [[[1.0, 1.0]], [[0.1, 0.1]]]
    ///    gemm2(A, B, transpose_b=True, alpha=2.0)
    ///            = [[[4.0]], [[0.04 ]]]
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\la_op.cc:L163</summary>
    /// <param name="A">Tensor of input matrices</param>
    /// <param name="B">Tensor of input matrices</param>
    /// <param name="transposeA">Multiply with transposed of first input (A).</param>
    /// <param name="transposeB">Multiply with transposed of second input (B).</param>
    /// <param name="alpha">Scalar factor multiplied with A*B.</param>
    /// <param name="axis">Axis corresponding to the matrix row indices.</param>
    new([<Optional>] ?A : Symbol,
        [<Optional>] ?B : Symbol,
        [<Optional>] ?transposeA : bool,
        [<Optional>] ?transposeB : bool,
        [<Optional>] ?alpha : double,
        [<Optional>] ?axis : int) = 
        let A = defaultArg A (new ImplicitVariable() :> Symbol)
        let B = defaultArg B (new ImplicitVariable() :> Symbol)
        let operatorArguments = 
            [
                "A", Input A
                "B", Input B
                "transpose_a", transposeA |> Option.map box |> Parameter
                "transpose_b", transposeB |> Option.map box |> Parameter
                "alpha", alpha |> Option.map box |> Parameter
                "axis", axis |> Option.map box |> Parameter
            ]
        new LinalgGemm2(Arguments<Symbol>(operatorArguments))
    /// Default value for TransposeA
    /// Multiply with transposed of first input (A).
    static member TransposeADefault : bool = false
    /// Default value for TransposeB
    /// Multiply with transposed of second input (B).
    static member TransposeBDefault : bool = false
    /// Default value for Alpha
    /// Scalar factor multiplied with A*B.
    static member AlphaDefault : double = 1.0
    /// Default value for Axis
    /// Axis corresponding to the matrix row indices.
    static member AxisDefault : int = -2
    /// Tensor of input matrices
    member __.A = operatorArguments.GetInput "A"
    /// Tensor of input matrices
    member __.B = operatorArguments.GetInput "B"
    /// Multiply with transposed of first input (A).
    member __.TransposeA = operatorArguments.GetParameter("transpose_a", LinalgGemm2.TransposeADefault)
    /// Multiply with transposed of second input (B).
    member __.TransposeB = operatorArguments.GetParameter("transpose_b", LinalgGemm2.TransposeBDefault)
    /// Scalar factor multiplied with A*B.
    member __.Alpha = operatorArguments.GetParameter("alpha", LinalgGemm2.AlphaDefault)
    /// Axis corresponding to the matrix row indices.
    member __.Axis = operatorArguments.GetParameter("axis", LinalgGemm2.AxisDefault)
    /// <summary>Copy LinalgGemm2 instance with updated inputs/parameters.</summary>
    /// <param name="A">Tensor of input matrices</param>
    /// <param name="B">Tensor of input matrices</param>
    /// <param name="transposeA">Multiply with transposed of first input (A).</param>
    /// <param name="transposeB">Multiply with transposed of second input (B).</param>
    /// <param name="alpha">Scalar factor multiplied with A*B.</param>
    /// <param name="axis">Axis corresponding to the matrix row indices.</param>
    member this.With([<Optional>] ?A : Symbol,
        [<Optional>] ?B : Symbol,
        [<Optional>] ?transposeA : bool,
        [<Optional>] ?transposeB : bool,
        [<Optional>] ?alpha : double,
        [<Optional>] ?axis : int) = 
        let operatorArguments = 
            [
                A |> Option.map (fun x -> "A", Input x)
                B |> Option.map (fun x -> "B", Input x)
                transposeA |> Option.map (fun x -> "transpose_a", Parameter(Some (box x)))
                transposeB |> Option.map (fun x -> "transpose_b", Parameter(Some (box x)))
                alpha |> Option.map (fun x -> "alpha", Parameter(Some (box x)))
                axis |> Option.map (fun x -> "axis", Parameter(Some (box x)))
            ] |> List.choose id
        new LinalgGemm2(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type LinalgPotrf private (operatorArguments) = 
    inherit SymbolOperator("_linalg_potrf", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new LinalgPotrf(args)
    override this.WithArguments(args : Arguments<Symbol>) = new LinalgPotrf(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <summary>Performs Cholesky factorization of a symmetric positive-definite matrix.
    /// Input is a tensor *A* of dimension *n &gt;= 2*.
    /// 
    /// If *n=2*, the Cholesky factor *B* of the symmetric, positive definite matrix *A* is
    /// computed. *B* is triangular (entries of upper or lower triangle are all zero), has
    /// positive diagonal entries, and:
    /// 
    ///   *A* = *B* \* *B*\ :sup:`T`  if *lower* = *true*
    ///   *A* = *B*\ :sup:`T` \* *B*  if *lower* = *false*
    /// 
    /// If *n&gt;2*, *potrf* is performed separately on the trailing two dimensions for all inputs
    /// (batch mode).
    /// 
    /// .. note:: The operator supports float32 and float64 data types only.
    /// 
    /// Examples::
    /// 
    ///    Single matrix factorization
    ///    A = [[4.0, 1.0], [1.0, 4.25]]
    ///    potrf(A) = [[2.0, 0], [0.5, 2.0]]
    /// 
    ///    Batch matrix factorization
    ///    A = [[[4.0, 1.0], [1.0, 4.25]], [[16.0, 4.0], [4.0, 17.0]]]
    ///    potrf(A) = [[[2.0, 0], [0.5, 2.0]], [[4.0, 0], [1.0, 4.0]]]
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\la_op.cc:L214</summary>
    /// <param name="A">Tensor of input matrices to be decomposed</param>
    new([<Optional>] ?A : Symbol) =
        let A = defaultArg A (new ImplicitVariable() :> Symbol)
        let operatorArguments = 
            [
                "A", Input A
            ]
        new LinalgPotrf(Arguments<Symbol>(operatorArguments))
    /// Tensor of input matrices to be decomposed
    member __.A = operatorArguments.GetInput "A"
    /// <summary>Copy LinalgPotrf instance with updated inputs/parameters.</summary>
    /// <param name="A">Tensor of input matrices to be decomposed</param>
    member this.With([<Optional>] ?A : Symbol) =
        let operatorArguments = 
            [
                A |> Option.map (fun x -> "A", Input x)
            ] |> List.choose id
        new LinalgPotrf(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type LinalgPotri private (operatorArguments) = 
    inherit SymbolOperator("_linalg_potri", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new LinalgPotri(args)
    override this.WithArguments(args : Arguments<Symbol>) = new LinalgPotri(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <summary>Performs matrix inversion from a Cholesky factorization.
    /// Input is a tensor *A* of dimension *n &gt;= 2*.
    /// 
    /// If *n=2*, *A* is a triangular matrix (entries of upper or lower triangle are all zero)
    /// with positive diagonal. We compute:
    /// 
    ///   *out* = *A*\ :sup:`-T` \* *A*\ :sup:`-1` if *lower* = *true*
    ///   *out* = *A*\ :sup:`-1` \* *A*\ :sup:`-T` if *lower* = *false*
    /// 
    /// In other words, if *A* is the Cholesky factor of a symmetric positive definite matrix
    /// *B* (obtained by *potrf*), then
    /// 
    ///   *out* = *B*\ :sup:`-1`
    /// 
    /// If *n&gt;2*, *potri* is performed separately on the trailing two dimensions for all inputs
    /// (batch mode).
    /// 
    /// .. note:: The operator supports float32 and float64 data types only.
    /// 
    /// .. note:: Use this operator only if you are certain you need the inverse of *B*, and
    ///           cannot use the Cholesky factor *A* (*potrf*), together with backsubstitution
    ///           (*trsm*). The latter is numerically much safer, and also cheaper.
    /// 
    /// Examples::
    /// 
    ///    Single matrix inverse
    ///    A = [[2.0, 0], [0.5, 2.0]]
    ///    potri(A) = [[0.26563, -0.0625], [-0.0625, 0.25]]
    /// 
    ///    Batch matrix inverse
    ///    A = [[[2.0, 0], [0.5, 2.0]], [[4.0, 0], [1.0, 4.0]]]
    ///    potri(A) = [[[0.26563, -0.0625], [-0.0625, 0.25]],
    ///                [[0.06641, -0.01562], [-0.01562, 0,0625]]]
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\la_op.cc:L275</summary>
    /// <param name="A">Tensor of lower triangular matrices</param>
    new([<Optional>] ?A : Symbol) =
        let A = defaultArg A (new ImplicitVariable() :> Symbol)
        let operatorArguments = 
            [
                "A", Input A
            ]
        new LinalgPotri(Arguments<Symbol>(operatorArguments))
    /// Tensor of lower triangular matrices
    member __.A = operatorArguments.GetInput "A"
    /// <summary>Copy LinalgPotri instance with updated inputs/parameters.</summary>
    /// <param name="A">Tensor of lower triangular matrices</param>
    member this.With([<Optional>] ?A : Symbol) =
        let operatorArguments = 
            [
                A |> Option.map (fun x -> "A", Input x)
            ] |> List.choose id
        new LinalgPotri(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type LinalgTrmm private (operatorArguments) = 
    inherit SymbolOperator("_linalg_trmm", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new LinalgTrmm(args)
    override this.WithArguments(args : Arguments<Symbol>) = new LinalgTrmm(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <summary>Performs multiplication with a lower triangular matrix.
    /// Input are tensors *A*, *B*, each of dimension *n &gt;= 2* and having the same shape
    /// on the leading *n-2* dimensions.
    /// 
    /// If *n=2*, *A* must be triangular. The operator performs the BLAS3 function
    /// *trmm*:
    /// 
    ///    *out* = *alpha* \* *op*\ (*A*) \* *B*
    /// 
    /// if *rightside=False*, or
    /// 
    ///    *out* = *alpha* \* *B* \* *op*\ (*A*)
    /// 
    /// if *rightside=True*. Here, *alpha* is a scalar parameter, and *op()* is either the
    /// identity or the matrix transposition (depending on *transpose*).
    /// 
    /// If *n&gt;2*, *trmm* is performed separately on the trailing two dimensions for all inputs
    /// (batch mode).
    /// 
    /// .. note:: The operator supports float32 and float64 data types only.
    /// 
    /// Examples::
    /// 
    ///    Single triangular matrix multiply
    ///    A = [[1.0, 0], [1.0, 1.0]]
    ///    B = [[1.0, 1.0, 1.0], [1.0, 1.0, 1.0]]
    ///    trmm(A, B, alpha=2.0) = [[2.0, 2.0, 2.0], [4.0, 4.0, 4.0]]
    /// 
    ///    Batch triangular matrix multiply
    ///    A = [[[1.0, 0], [1.0, 1.0]], [[1.0, 0], [1.0, 1.0]]]
    ///    B = [[[1.0, 1.0, 1.0], [1.0, 1.0, 1.0]], [[0.5, 0.5, 0.5], [0.5, 0.5, 0.5]]]
    ///    trmm(A, B, alpha=2.0) = [[[2.0, 2.0, 2.0], [4.0, 4.0, 4.0]],
    ///                             [[1.0, 1.0, 1.0], [2.0, 2.0, 2.0]]]
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\la_op.cc:L333</summary>
    /// <param name="A">Tensor of lower triangular matrices</param>
    /// <param name="B">Tensor of matrices</param>
    /// <param name="transpose">Use transposed of the triangular matrix</param>
    /// <param name="rightside">Multiply triangular matrix from the right to non-triangular one.</param>
    /// <param name="lower">True if the triangular matrix is lower triangular, false if it is upper triangular.</param>
    /// <param name="alpha">Scalar factor to be applied to the result.</param>
    new([<Optional>] ?A : Symbol,
        [<Optional>] ?B : Symbol,
        [<Optional>] ?transpose : bool,
        [<Optional>] ?rightside : bool,
        [<Optional>] ?lower : bool,
        [<Optional>] ?alpha : double) = 
        let A = defaultArg A (new ImplicitVariable() :> Symbol)
        let B = defaultArg B (new ImplicitVariable() :> Symbol)
        let operatorArguments = 
            [
                "A", Input A
                "B", Input B
                "transpose", transpose |> Option.map box |> Parameter
                "rightside", rightside |> Option.map box |> Parameter
                "lower", lower |> Option.map box |> Parameter
                "alpha", alpha |> Option.map box |> Parameter
            ]
        new LinalgTrmm(Arguments<Symbol>(operatorArguments))
    /// Default value for Transpose
    /// Use transposed of the triangular matrix
    static member TransposeDefault : bool = false
    /// Default value for Rightside
    /// Multiply triangular matrix from the right to non-triangular one.
    static member RightsideDefault : bool = false
    /// Default value for Lower
    /// True if the triangular matrix is lower triangular, false if it is upper triangular.
    static member LowerDefault : bool = true
    /// Default value for Alpha
    /// Scalar factor to be applied to the result.
    static member AlphaDefault : double = 1.0
    /// Tensor of lower triangular matrices
    member __.A = operatorArguments.GetInput "A"
    /// Tensor of matrices
    member __.B = operatorArguments.GetInput "B"
    /// Use transposed of the triangular matrix
    member __.Transpose = operatorArguments.GetParameter("transpose", LinalgTrmm.TransposeDefault)
    /// Multiply triangular matrix from the right to non-triangular one.
    member __.Rightside = operatorArguments.GetParameter("rightside", LinalgTrmm.RightsideDefault)
    /// True if the triangular matrix is lower triangular, false if it is upper triangular.
    member __.Lower = operatorArguments.GetParameter("lower", LinalgTrmm.LowerDefault)
    /// Scalar factor to be applied to the result.
    member __.Alpha = operatorArguments.GetParameter("alpha", LinalgTrmm.AlphaDefault)
    /// <summary>Copy LinalgTrmm instance with updated inputs/parameters.</summary>
    /// <param name="A">Tensor of lower triangular matrices</param>
    /// <param name="B">Tensor of matrices</param>
    /// <param name="transpose">Use transposed of the triangular matrix</param>
    /// <param name="rightside">Multiply triangular matrix from the right to non-triangular one.</param>
    /// <param name="lower">True if the triangular matrix is lower triangular, false if it is upper triangular.</param>
    /// <param name="alpha">Scalar factor to be applied to the result.</param>
    member this.With([<Optional>] ?A : Symbol,
        [<Optional>] ?B : Symbol,
        [<Optional>] ?transpose : bool,
        [<Optional>] ?rightside : bool,
        [<Optional>] ?lower : bool,
        [<Optional>] ?alpha : double) = 
        let operatorArguments = 
            [
                A |> Option.map (fun x -> "A", Input x)
                B |> Option.map (fun x -> "B", Input x)
                transpose |> Option.map (fun x -> "transpose", Parameter(Some (box x)))
                rightside |> Option.map (fun x -> "rightside", Parameter(Some (box x)))
                lower |> Option.map (fun x -> "lower", Parameter(Some (box x)))
                alpha |> Option.map (fun x -> "alpha", Parameter(Some (box x)))
            ] |> List.choose id
        new LinalgTrmm(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type LinalgTrsm private (operatorArguments) = 
    inherit SymbolOperator("_linalg_trsm", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new LinalgTrsm(args)
    override this.WithArguments(args : Arguments<Symbol>) = new LinalgTrsm(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <summary>Solves matrix equation involving a lower triangular matrix.
    /// Input are tensors *A*, *B*, each of dimension *n &gt;= 2* and having the same shape
    /// on the leading *n-2* dimensions.
    /// 
    /// If *n=2*, *A* must be triangular. The operator performs the BLAS3 function
    /// *trsm*, solving for *out* in:
    /// 
    ///    *op*\ (*A*) \* *out* = *alpha* \* *B*
    /// 
    /// if *rightside=False*, or
    /// 
    ///    *out* \* *op*\ (*A*) = *alpha* \* *B*
    /// 
    /// if *rightside=True*. Here, *alpha* is a scalar parameter, and *op()* is either the
    /// identity or the matrix transposition (depending on *transpose*).
    /// 
    /// If *n&gt;2*, *trsm* is performed separately on the trailing two dimensions for all inputs
    /// (batch mode).
    /// 
    /// .. note:: The operator supports float32 and float64 data types only.
    /// 
    /// Examples::
    /// 
    ///    Single matrix solve
    ///    A = [[1.0, 0], [1.0, 1.0]]
    ///    B = [[2.0, 2.0, 2.0], [4.0, 4.0, 4.0]]
    ///    trsm(A, B, alpha=0.5) = [[1.0, 1.0, 1.0], [1.0, 1.0, 1.0]]
    /// 
    ///    Batch matrix solve
    ///    A = [[[1.0, 0], [1.0, 1.0]], [[1.0, 0], [1.0, 1.0]]]
    ///    B = [[[2.0, 2.0, 2.0], [4.0, 4.0, 4.0]],
    ///         [[4.0, 4.0, 4.0], [8.0, 8.0, 8.0]]]
    ///    trsm(A, B, alpha=0.5) = [[[1.0, 1.0, 1.0], [1.0, 1.0, 1.0]],
    ///                             [[2.0, 2.0, 2.0], [2.0, 2.0, 2.0]]]
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\la_op.cc:L396</summary>
    /// <param name="A">Tensor of lower triangular matrices</param>
    /// <param name="B">Tensor of matrices</param>
    /// <param name="transpose">Use transposed of the triangular matrix</param>
    /// <param name="rightside">Multiply triangular matrix from the right to non-triangular one.</param>
    /// <param name="lower">True if the triangular matrix is lower triangular, false if it is upper triangular.</param>
    /// <param name="alpha">Scalar factor to be applied to the result.</param>
    new([<Optional>] ?A : Symbol,
        [<Optional>] ?B : Symbol,
        [<Optional>] ?transpose : bool,
        [<Optional>] ?rightside : bool,
        [<Optional>] ?lower : bool,
        [<Optional>] ?alpha : double) = 
        let A = defaultArg A (new ImplicitVariable() :> Symbol)
        let B = defaultArg B (new ImplicitVariable() :> Symbol)
        let operatorArguments = 
            [
                "A", Input A
                "B", Input B
                "transpose", transpose |> Option.map box |> Parameter
                "rightside", rightside |> Option.map box |> Parameter
                "lower", lower |> Option.map box |> Parameter
                "alpha", alpha |> Option.map box |> Parameter
            ]
        new LinalgTrsm(Arguments<Symbol>(operatorArguments))
    /// Default value for Transpose
    /// Use transposed of the triangular matrix
    static member TransposeDefault : bool = false
    /// Default value for Rightside
    /// Multiply triangular matrix from the right to non-triangular one.
    static member RightsideDefault : bool = false
    /// Default value for Lower
    /// True if the triangular matrix is lower triangular, false if it is upper triangular.
    static member LowerDefault : bool = true
    /// Default value for Alpha
    /// Scalar factor to be applied to the result.
    static member AlphaDefault : double = 1.0
    /// Tensor of lower triangular matrices
    member __.A = operatorArguments.GetInput "A"
    /// Tensor of matrices
    member __.B = operatorArguments.GetInput "B"
    /// Use transposed of the triangular matrix
    member __.Transpose = operatorArguments.GetParameter("transpose", LinalgTrsm.TransposeDefault)
    /// Multiply triangular matrix from the right to non-triangular one.
    member __.Rightside = operatorArguments.GetParameter("rightside", LinalgTrsm.RightsideDefault)
    /// True if the triangular matrix is lower triangular, false if it is upper triangular.
    member __.Lower = operatorArguments.GetParameter("lower", LinalgTrsm.LowerDefault)
    /// Scalar factor to be applied to the result.
    member __.Alpha = operatorArguments.GetParameter("alpha", LinalgTrsm.AlphaDefault)
    /// <summary>Copy LinalgTrsm instance with updated inputs/parameters.</summary>
    /// <param name="A">Tensor of lower triangular matrices</param>
    /// <param name="B">Tensor of matrices</param>
    /// <param name="transpose">Use transposed of the triangular matrix</param>
    /// <param name="rightside">Multiply triangular matrix from the right to non-triangular one.</param>
    /// <param name="lower">True if the triangular matrix is lower triangular, false if it is upper triangular.</param>
    /// <param name="alpha">Scalar factor to be applied to the result.</param>
    member this.With([<Optional>] ?A : Symbol,
        [<Optional>] ?B : Symbol,
        [<Optional>] ?transpose : bool,
        [<Optional>] ?rightside : bool,
        [<Optional>] ?lower : bool,
        [<Optional>] ?alpha : double) = 
        let operatorArguments = 
            [
                A |> Option.map (fun x -> "A", Input x)
                B |> Option.map (fun x -> "B", Input x)
                transpose |> Option.map (fun x -> "transpose", Parameter(Some (box x)))
                rightside |> Option.map (fun x -> "rightside", Parameter(Some (box x)))
                lower |> Option.map (fun x -> "lower", Parameter(Some (box x)))
                alpha |> Option.map (fun x -> "alpha", Parameter(Some (box x)))
            ] |> List.choose id
        new LinalgTrsm(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type LinalgSumlogdiag private (operatorArguments) = 
    inherit SymbolOperator("_linalg_sumlogdiag", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new LinalgSumlogdiag(args)
    override this.WithArguments(args : Arguments<Symbol>) = new LinalgSumlogdiag(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <summary>Computes the sum of the logarithms of the diagonal elements of a square matrix.
    /// Input is a tensor *A* of dimension *n &gt;= 2*.
    /// 
    /// If *n=2*, *A* must be square with positive diagonal entries. We sum the natural
    /// logarithms of the diagonal elements, the result has shape (1,).
    /// 
    /// If *n&gt;2*, *sumlogdiag* is performed separately on the trailing two dimensions for all
    /// inputs (batch mode).
    /// 
    /// .. note:: The operator supports float32 and float64 data types only.
    /// 
    /// Examples::
    /// 
    ///    Single matrix reduction
    ///    A = [[1.0, 1.0], [1.0, 7.0]]
    ///    sumlogdiag(A) = [1.9459]
    /// 
    ///    Batch matrix reduction
    ///    A = [[[1.0, 1.0], [1.0, 7.0]], [[3.0, 0], [0, 17.0]]]
    ///    sumlogdiag(A) = [1.9459, 3.9318]
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\la_op.cc:L445</summary>
    /// <param name="A">Tensor of square matrices</param>
    new([<Optional>] ?A : Symbol) =
        let A = defaultArg A (new ImplicitVariable() :> Symbol)
        let operatorArguments = 
            [
                "A", Input A
            ]
        new LinalgSumlogdiag(Arguments<Symbol>(operatorArguments))
    /// Tensor of square matrices
    member __.A = operatorArguments.GetInput "A"
    /// <summary>Copy LinalgSumlogdiag instance with updated inputs/parameters.</summary>
    /// <param name="A">Tensor of square matrices</param>
    member this.With([<Optional>] ?A : Symbol) =
        let operatorArguments = 
            [
                A |> Option.map (fun x -> "A", Input x)
            ] |> List.choose id
        new LinalgSumlogdiag(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type LinalgExtractdiag private (operatorArguments) = 
    inherit SymbolOperator("_linalg_extractdiag", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new LinalgExtractdiag(args)
    override this.WithArguments(args : Arguments<Symbol>) = new LinalgExtractdiag(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <summary>Extracts the diagonal entries of a square matrix.
    /// Input is a tensor *A* of dimension *n &gt;= 2*.
    /// 
    /// If *n=2*, then *A* represents a single square matrix which diagonal elements get extracted as a 1-dimensional tensor.
    /// 
    /// If *n&gt;2*, then *A* represents a batch of square matrices on the trailing two dimensions. The extracted diagonals are returned as an *n-1*-dimensional tensor.
    /// 
    /// .. note:: The operator supports float32 and float64 data types only.
    /// 
    /// Examples::
    /// 
    ///     Single matrix diagonal extraction
    ///     A = [[1.0, 2.0],
    ///          [3.0, 4.0]]
    /// 
    ///     extractdiag(A) = [1.0, 4.0]
    /// 
    ///     extractdiag(A, 1) = [2.0]
    /// 
    ///     Batch matrix diagonal extraction
    ///     A = [[[1.0, 2.0],
    ///           [3.0, 4.0]],
    ///          [[5.0, 6.0],
    ///           [7.0, 8.0]]]
    /// 
    ///     extractdiag(A) = [[1.0, 4.0],
    ///                       [5.0, 8.0]]
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\la_op.cc:L495</summary>
    /// <param name="A">Tensor of square matrices</param>
    /// <param name="offset">Offset of the diagonal versus the main diagonal. 0 corresponds to the main diagonal, a negative/positive value to diagonals below/above the main diagonal.</param>
    new([<Optional>] ?A : Symbol,
        [<Optional>] ?offset : int) = 
        let A = defaultArg A (new ImplicitVariable() :> Symbol)
        let operatorArguments = 
            [
                "A", Input A
                "offset", offset |> Option.map box |> Parameter
            ]
        new LinalgExtractdiag(Arguments<Symbol>(operatorArguments))
    /// Default value for Offset
    /// Offset of the diagonal versus the main diagonal. 0 corresponds to the main diagonal, a negative/positive value to diagonals below/above the main diagonal.
    static member OffsetDefault : int = 0
    /// Tensor of square matrices
    member __.A = operatorArguments.GetInput "A"
    /// Offset of the diagonal versus the main diagonal. 0 corresponds to the main diagonal, a negative/positive value to diagonals below/above the main diagonal.
    member __.Offset = operatorArguments.GetParameter("offset", LinalgExtractdiag.OffsetDefault)
    /// <summary>Copy LinalgExtractdiag instance with updated inputs/parameters.</summary>
    /// <param name="A">Tensor of square matrices</param>
    /// <param name="offset">Offset of the diagonal versus the main diagonal. 0 corresponds to the main diagonal, a negative/positive value to diagonals below/above the main diagonal.</param>
    member this.With([<Optional>] ?A : Symbol,
        [<Optional>] ?offset : int) = 
        let operatorArguments = 
            [
                A |> Option.map (fun x -> "A", Input x)
                offset |> Option.map (fun x -> "offset", Parameter(Some (box x)))
            ] |> List.choose id
        new LinalgExtractdiag(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type LinalgMakediag private (operatorArguments) = 
    inherit SymbolOperator("_linalg_makediag", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new LinalgMakediag(args)
    override this.WithArguments(args : Arguments<Symbol>) = new LinalgMakediag(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <summary>Constructs a square matrix with the input as diagonal.
    /// Input is a tensor *A* of dimension *n &gt;= 1*.
    /// 
    /// If *n=1*, then *A* represents the diagonal entries of a single square matrix. This matrix will be returned as a 2-dimensional tensor.
    /// If *n&gt;1*, then *A* represents a batch of diagonals of square matrices. The batch of diagonal matrices will be returned as an *n+1*-dimensional tensor.
    /// 
    /// .. note:: The operator supports float32 and float64 data types only.
    /// 
    /// Examples::
    /// 
    ///     Single diagonal matrix construction
    ///     A = [1.0, 2.0]
    /// 
    ///     makediag(A)    = [[1.0, 0.0],
    ///                       [0.0, 2.0]]
    /// 
    ///     makediag(A, 1) = [[0.0, 1.0, 0.0],
    ///                       [0.0, 0.0, 2.0],
    ///                       [0.0, 0.0, 0.0]]
    /// 
    ///     Batch diagonal matrix construction
    ///     A = [[1.0, 2.0],
    ///          [3.0, 4.0]]
    /// 
    ///     makediag(A) = [[[1.0, 0.0],
    ///                     [0.0, 2.0]],
    ///                    [[3.0, 0.0],
    ///                     [0.0, 4.0]]]
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\la_op.cc:L547</summary>
    /// <param name="A">Tensor of diagonal entries</param>
    /// <param name="offset">Offset of the diagonal versus the main diagonal. 0 corresponds to the main diagonal, a negative/positive value to diagonals below/above the main diagonal.</param>
    new([<Optional>] ?A : Symbol,
        [<Optional>] ?offset : int) = 
        let A = defaultArg A (new ImplicitVariable() :> Symbol)
        let operatorArguments = 
            [
                "A", Input A
                "offset", offset |> Option.map box |> Parameter
            ]
        new LinalgMakediag(Arguments<Symbol>(operatorArguments))
    /// Default value for Offset
    /// Offset of the diagonal versus the main diagonal. 0 corresponds to the main diagonal, a negative/positive value to diagonals below/above the main diagonal.
    static member OffsetDefault : int = 0
    /// Tensor of diagonal entries
    member __.A = operatorArguments.GetInput "A"
    /// Offset of the diagonal versus the main diagonal. 0 corresponds to the main diagonal, a negative/positive value to diagonals below/above the main diagonal.
    member __.Offset = operatorArguments.GetParameter("offset", LinalgMakediag.OffsetDefault)
    /// <summary>Copy LinalgMakediag instance with updated inputs/parameters.</summary>
    /// <param name="A">Tensor of diagonal entries</param>
    /// <param name="offset">Offset of the diagonal versus the main diagonal. 0 corresponds to the main diagonal, a negative/positive value to diagonals below/above the main diagonal.</param>
    member this.With([<Optional>] ?A : Symbol,
        [<Optional>] ?offset : int) = 
        let operatorArguments = 
            [
                A |> Option.map (fun x -> "A", Input x)
                offset |> Option.map (fun x -> "offset", Parameter(Some (box x)))
            ] |> List.choose id
        new LinalgMakediag(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type LinalgExtracttrian private (operatorArguments) = 
    inherit SymbolOperator("_linalg_extracttrian", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new LinalgExtracttrian(args)
    override this.WithArguments(args : Arguments<Symbol>) = new LinalgExtracttrian(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <summary>Extracts a triangular sub-matrix from a square matrix.
    /// Input is a tensor *A* of dimension *n &gt;= 2*.
    /// 
    /// If *n=2*, then *A* represents a single square matrix from which a triangular sub-matrix is extracted as a 1-dimensional tensor.
    /// 
    /// If *n&gt;2*, then *A* represents a batch of square matrices on the trailing two dimensions. The extracted triangular sub-matrices are returned as an *n-1*-dimensional tensor.
    /// 
    /// The *offset* and *lower* parameters determine the triangle to be extracted:
    /// 
    /// - When *offset = 0* either the lower or upper triangle with respect to the main diagonal is extracted depending on the value of parameter *lower*.
    /// - When *offset = k &gt; 0* the upper triangle with respect to the k-th diagonal above the main diagonal is extracted. 
    /// - When *offset = k &lt; 0* the lower triangle with respect to the k-th diagonal below the main diagonal is extracted. 
    /// 
    /// .. note:: The operator supports float32 and float64 data types only.
    /// 
    /// Examples::
    /// 
    ///     Single triagonal extraction
    ///     A = [[1.0, 2.0],
    ///          [3.0, 4.0]]
    /// 
    ///     extracttrian(A) = [1.0, 3.0, 4.0]
    ///     extracttrian(A, lower=False) = [1.0, 2.0, 4.0]
    ///     extracttrian(A, 1) = [2.0]
    ///     extracttrian(A, -1) = [3.0]
    /// 
    ///     Batch triagonal extraction
    ///     A = [[[1.0, 2.0],
    ///           [3.0, 4.0]],
    ///          [[5.0, 6.0],
    ///           [7.0, 8.0]]]
    /// 
    ///     extracttrian(A) = [[1.0, 3.0, 4.0],
    ///                        [5.0, 7.0, 8.0]]
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\la_op.cc:L605</summary>
    /// <param name="A">Tensor of square matrices</param>
    /// <param name="offset">Offset of the diagonal versus the main diagonal. 0 corresponds to the main diagonal, a negative/positive value to diagonals below/above the main diagonal.</param>
    /// <param name="lower">Refer to the lower triangular matrix if lower=true, refer to the upper otherwise. Only relevant when offset=0</param>
    new([<Optional>] ?A : Symbol,
        [<Optional>] ?offset : int,
        [<Optional>] ?lower : bool) = 
        let A = defaultArg A (new ImplicitVariable() :> Symbol)
        let operatorArguments = 
            [
                "A", Input A
                "offset", offset |> Option.map box |> Parameter
                "lower", lower |> Option.map box |> Parameter
            ]
        new LinalgExtracttrian(Arguments<Symbol>(operatorArguments))
    /// Default value for Offset
    /// Offset of the diagonal versus the main diagonal. 0 corresponds to the main diagonal, a negative/positive value to diagonals below/above the main diagonal.
    static member OffsetDefault : int = 0
    /// Default value for Lower
    /// Refer to the lower triangular matrix if lower=true, refer to the upper otherwise. Only relevant when offset=0
    static member LowerDefault : bool = true
    /// Tensor of square matrices
    member __.A = operatorArguments.GetInput "A"
    /// Offset of the diagonal versus the main diagonal. 0 corresponds to the main diagonal, a negative/positive value to diagonals below/above the main diagonal.
    member __.Offset = operatorArguments.GetParameter("offset", LinalgExtracttrian.OffsetDefault)
    /// Refer to the lower triangular matrix if lower=true, refer to the upper otherwise. Only relevant when offset=0
    member __.Lower = operatorArguments.GetParameter("lower", LinalgExtracttrian.LowerDefault)
    /// <summary>Copy LinalgExtracttrian instance with updated inputs/parameters.</summary>
    /// <param name="A">Tensor of square matrices</param>
    /// <param name="offset">Offset of the diagonal versus the main diagonal. 0 corresponds to the main diagonal, a negative/positive value to diagonals below/above the main diagonal.</param>
    /// <param name="lower">Refer to the lower triangular matrix if lower=true, refer to the upper otherwise. Only relevant when offset=0</param>
    member this.With([<Optional>] ?A : Symbol,
        [<Optional>] ?offset : int,
        [<Optional>] ?lower : bool) = 
        let operatorArguments = 
            [
                A |> Option.map (fun x -> "A", Input x)
                offset |> Option.map (fun x -> "offset", Parameter(Some (box x)))
                lower |> Option.map (fun x -> "lower", Parameter(Some (box x)))
            ] |> List.choose id
        new LinalgExtracttrian(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type LinalgMaketrian private (operatorArguments) = 
    inherit SymbolOperator("_linalg_maketrian", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new LinalgMaketrian(args)
    override this.WithArguments(args : Arguments<Symbol>) = new LinalgMaketrian(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <summary>Constructs a square matrix with the input representing a specific triangular sub-matrix.
    /// This is basically the inverse of *linalg.extracttrian*. Input is a tensor *A* of dimension *n &gt;= 1*.
    /// 
    /// If *n=1*, then *A* represents the entries of a triangular matrix which is lower triangular if *offset&lt;0* or *offset=0*, *lower=true*. The resulting matrix is derived by first constructing the square
    /// matrix with the entries outside the triangle set to zero and then adding *offset*-times an additional 
    /// diagonal with zero entries to the square matrix. 
    /// 
    /// If *n&gt;1*, then *A* represents a batch of triangular sub-matrices. The batch of corresponding square matrices is returned as an *n+1*-dimensional tensor.
    /// 
    /// .. note:: The operator supports float32 and float64 data types only.
    /// 
    /// Examples::
    /// 
    ///     Single  matrix construction
    ///     A = [1.0, 2.0, 3.0]
    /// 
    ///     maketrian(A)              = [[1.0, 0.0],
    ///                                  [2.0, 3.0]]
    /// 
    ///     maketrian(A, lower=false) = [[1.0, 2.0],
    ///                                  [0.0, 3.0]]
    /// 
    ///     maketrian(A, offset=1)    = [[0.0, 1.0, 2.0],
    ///                                  [0.0, 0.0, 3.0],
    ///                                  [0.0, 0.0, 0.0]]
    ///     maketrian(A, offset=-1)   = [[0.0, 0.0, 0.0],
    ///                                  [1.0, 0.0, 0.0],
    ///                                  [2.0, 3.0, 0.0]]
    /// 
    ///     Batch matrix construction
    ///     A = [[1.0, 2.0, 3.0],
    ///          [4.0, 5.0, 6.0]]
    /// 
    ///     maketrian(A)           = [[[1.0, 0.0],
    ///                                [2.0, 3.0]],
    ///                               [[4.0, 0.0],
    ///                                [5.0, 6.0]]]
    /// 
    ///     maketrian(A, offset=1) = [[[0.0, 1.0, 2.0],
    ///                                [0.0, 0.0, 3.0],
    ///                                [0.0, 0.0, 0.0]],
    ///                               [[0.0, 4.0, 5.0],
    ///                                [0.0, 0.0, 6.0],
    ///                                [0.0, 0.0, 0.0]]]
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\la_op.cc:L673</summary>
    /// <param name="A">Tensor of triangular matrices stored as vectors</param>
    /// <param name="offset">Offset of the diagonal versus the main diagonal. 0 corresponds to the main diagonal, a negative/positive value to diagonals below/above the main diagonal.</param>
    /// <param name="lower">Refer to the lower triangular matrix if lower=true, refer to the upper otherwise. Only relevant when offset=0</param>
    new([<Optional>] ?A : Symbol,
        [<Optional>] ?offset : int,
        [<Optional>] ?lower : bool) = 
        let A = defaultArg A (new ImplicitVariable() :> Symbol)
        let operatorArguments = 
            [
                "A", Input A
                "offset", offset |> Option.map box |> Parameter
                "lower", lower |> Option.map box |> Parameter
            ]
        new LinalgMaketrian(Arguments<Symbol>(operatorArguments))
    /// Default value for Offset
    /// Offset of the diagonal versus the main diagonal. 0 corresponds to the main diagonal, a negative/positive value to diagonals below/above the main diagonal.
    static member OffsetDefault : int = 0
    /// Default value for Lower
    /// Refer to the lower triangular matrix if lower=true, refer to the upper otherwise. Only relevant when offset=0
    static member LowerDefault : bool = true
    /// Tensor of triangular matrices stored as vectors
    member __.A = operatorArguments.GetInput "A"
    /// Offset of the diagonal versus the main diagonal. 0 corresponds to the main diagonal, a negative/positive value to diagonals below/above the main diagonal.
    member __.Offset = operatorArguments.GetParameter("offset", LinalgMaketrian.OffsetDefault)
    /// Refer to the lower triangular matrix if lower=true, refer to the upper otherwise. Only relevant when offset=0
    member __.Lower = operatorArguments.GetParameter("lower", LinalgMaketrian.LowerDefault)
    /// <summary>Copy LinalgMaketrian instance with updated inputs/parameters.</summary>
    /// <param name="A">Tensor of triangular matrices stored as vectors</param>
    /// <param name="offset">Offset of the diagonal versus the main diagonal. 0 corresponds to the main diagonal, a negative/positive value to diagonals below/above the main diagonal.</param>
    /// <param name="lower">Refer to the lower triangular matrix if lower=true, refer to the upper otherwise. Only relevant when offset=0</param>
    member this.With([<Optional>] ?A : Symbol,
        [<Optional>] ?offset : int,
        [<Optional>] ?lower : bool) = 
        let operatorArguments = 
            [
                A |> Option.map (fun x -> "A", Input x)
                offset |> Option.map (fun x -> "offset", Parameter(Some (box x)))
                lower |> Option.map (fun x -> "lower", Parameter(Some (box x)))
            ] |> List.choose id
        new LinalgMaketrian(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type LinalgSyrk private (operatorArguments) = 
    inherit SymbolOperator("_linalg_syrk", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new LinalgSyrk(args)
    override this.WithArguments(args : Arguments<Symbol>) = new LinalgSyrk(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <summary>Multiplication of matrix with its transpose.
    /// Input is a tensor *A* of dimension *n &gt;= 2*.
    /// 
    /// If *n=2*, the operator performs the BLAS3 function *syrk*:
    /// 
    ///   *out* = *alpha* \* *A* \* *A*\ :sup:`T`
    /// 
    /// if *transpose=False*, or
    /// 
    ///   *out* = *alpha* \* *A*\ :sup:`T` \ \* *A*
    /// 
    /// if *transpose=True*.
    /// 
    /// If *n&gt;2*, *syrk* is performed separately on the trailing two dimensions for all
    /// inputs (batch mode).
    /// 
    /// .. note:: The operator supports float32 and float64 data types only.
    /// 
    /// Examples::
    /// 
    ///    Single matrix multiply
    ///    A = [[1., 2., 3.], [4., 5., 6.]]
    ///    syrk(A, alpha=1., transpose=False)
    ///             = [[14., 32.],
    ///                [32., 77.]]
    ///    syrk(A, alpha=1., transpose=True)
    ///             = [[17., 22., 27.],
    ///                [22., 29., 36.],
    ///                [27., 36., 45.]]
    /// 
    ///    Batch matrix multiply
    ///    A = [[[1., 1.]], [[0.1, 0.1]]]
    ///    syrk(A, alpha=2., transpose=False) = [[[4.]], [[0.04]]]
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\la_op.cc:L730</summary>
    /// <param name="A">Tensor of input matrices</param>
    /// <param name="transpose">Use transpose of input matrix.</param>
    /// <param name="alpha">Scalar factor to be applied to the result.</param>
    new([<Optional>] ?A : Symbol,
        [<Optional>] ?transpose : bool,
        [<Optional>] ?alpha : double) = 
        let A = defaultArg A (new ImplicitVariable() :> Symbol)
        let operatorArguments = 
            [
                "A", Input A
                "transpose", transpose |> Option.map box |> Parameter
                "alpha", alpha |> Option.map box |> Parameter
            ]
        new LinalgSyrk(Arguments<Symbol>(operatorArguments))
    /// Default value for Transpose
    /// Use transpose of input matrix.
    static member TransposeDefault : bool = false
    /// Default value for Alpha
    /// Scalar factor to be applied to the result.
    static member AlphaDefault : double = 1.0
    /// Tensor of input matrices
    member __.A = operatorArguments.GetInput "A"
    /// Use transpose of input matrix.
    member __.Transpose = operatorArguments.GetParameter("transpose", LinalgSyrk.TransposeDefault)
    /// Scalar factor to be applied to the result.
    member __.Alpha = operatorArguments.GetParameter("alpha", LinalgSyrk.AlphaDefault)
    /// <summary>Copy LinalgSyrk instance with updated inputs/parameters.</summary>
    /// <param name="A">Tensor of input matrices</param>
    /// <param name="transpose">Use transpose of input matrix.</param>
    /// <param name="alpha">Scalar factor to be applied to the result.</param>
    member this.With([<Optional>] ?A : Symbol,
        [<Optional>] ?transpose : bool,
        [<Optional>] ?alpha : double) = 
        let operatorArguments = 
            [
                A |> Option.map (fun x -> "A", Input x)
                transpose |> Option.map (fun x -> "transpose", Parameter(Some (box x)))
                alpha |> Option.map (fun x -> "alpha", Parameter(Some (box x)))
            ] |> List.choose id
        new LinalgSyrk(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type LinalgGelqf private (operatorArguments) = 
    inherit SymbolOperator("_linalg_gelqf", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new LinalgGelqf(args)
    override this.WithArguments(args : Arguments<Symbol>) = new LinalgGelqf(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <summary>LQ factorization for general matrix.
    /// Input is a tensor *A* of dimension *n &gt;= 2*.
    /// 
    /// If *n=2*, we compute the LQ factorization (LAPACK *gelqf*, followed by *orglq*). *A*
    /// must have shape *(x, y)* with *x &lt;= y*, and must have full rank *=x*. The LQ
    /// factorization consists of *L* with shape *(x, x)* and *Q* with shape *(x, y)*, so
    /// that:
    /// 
    ///    *A* = *L* \* *Q*
    /// 
    /// Here, *L* is lower triangular (upper triangle equal to zero) with nonzero diagonal,
    /// and *Q* is row-orthonormal, meaning that
    /// 
    ///    *Q* \* *Q*\ :sup:`T`
    /// 
    /// is equal to the identity matrix of shape *(x, x)*.
    /// 
    /// If *n&gt;2*, *gelqf* is performed separately on the trailing two dimensions for all
    /// inputs (batch mode).
    /// 
    /// .. note:: The operator supports float32 and float64 data types only.
    /// 
    /// Examples::
    /// 
    ///    Single LQ factorization
    ///    A = [[1., 2., 3.], [4., 5., 6.]]
    ///    Q, L = gelqf(A)
    ///    Q = [[-0.26726124, -0.53452248, -0.80178373],
    ///         [0.87287156, 0.21821789, -0.43643578]]
    ///    L = [[-3.74165739, 0.],
    ///         [-8.55235974, 1.96396101]]
    /// 
    ///    Batch LQ factorization
    ///    A = [[[1., 2., 3.], [4., 5., 6.]],
    ///         [[7., 8., 9.], [10., 11., 12.]]]
    ///    Q, L = gelqf(A)
    ///    Q = [[[-0.26726124, -0.53452248, -0.80178373],
    ///          [0.87287156, 0.21821789, -0.43643578]],
    ///         [[-0.50257071, -0.57436653, -0.64616234],
    ///          [0.7620735, 0.05862104, -0.64483142]]]
    ///    L = [[[-3.74165739, 0.],
    ///          [-8.55235974, 1.96396101]],
    ///         [[-13.92838828, 0.],
    ///          [-19.09768702, 0.52758934]]]
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\la_op.cc:L798</summary>
    /// <param name="A">Tensor of input matrices to be factorized</param>
    new([<Optional>] ?A : Symbol) =
        let A = defaultArg A (new ImplicitVariable() :> Symbol)
        let operatorArguments = 
            [
                "A", Input A
            ]
        new LinalgGelqf(Arguments<Symbol>(operatorArguments))
    /// Tensor of input matrices to be factorized
    member __.A = operatorArguments.GetInput "A"
    /// <summary>Copy LinalgGelqf instance with updated inputs/parameters.</summary>
    /// <param name="A">Tensor of input matrices to be factorized</param>
    member this.With([<Optional>] ?A : Symbol) =
        let operatorArguments = 
            [
                A |> Option.map (fun x -> "A", Input x)
            ] |> List.choose id
        new LinalgGelqf(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type LinalgSyevd private (operatorArguments) = 
    inherit SymbolOperator("_linalg_syevd", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new LinalgSyevd(args)
    override this.WithArguments(args : Arguments<Symbol>) = new LinalgSyevd(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <summary>Eigendecomposition for symmetric matrix.
    /// Input is a tensor *A* of dimension *n &gt;= 2*.
    /// 
    /// If *n=2*, *A* must be symmetric, of shape *(x, x)*. We compute the eigendecomposition,
    /// resulting in the orthonormal matrix *U* of eigenvectors, shape *(x, x)*, and the
    /// vector *L* of eigenvalues, shape *(x,)*, so that:
    /// 
    ///    *U* \* *A* = *diag(L)* \* *U*
    /// 
    /// Here:
    /// 
    ///    *U* \* *U*\ :sup:`T` = *U*\ :sup:`T` \* *U* = *I*
    /// 
    /// where *I* is the identity matrix. Also, *L(0) &lt;= L(1) &lt;= L(2) &lt;= ...* (ascending order).
    /// 
    /// If *n&gt;2*, *syevd* is performed separately on the trailing two dimensions of *A* (batch
    /// mode). In this case, *U* has *n* dimensions like *A*, and *L* has *n-1* dimensions.
    /// 
    /// .. note:: The operator supports float32 and float64 data types only.
    /// 
    /// .. note:: Derivatives for this operator are defined only if *A* is such that all its
    ///           eigenvalues are distinct, and the eigengaps are not too small. If you need
    ///           gradients, do not apply this operator to matrices with multiple eigenvalues.
    /// 
    /// Examples::
    /// 
    ///    Single symmetric eigendecomposition
    ///    A = [[1., 2.], [2., 4.]]
    ///    U, L = syevd(A)
    ///    U = [[0.89442719, -0.4472136],
    ///         [0.4472136, 0.89442719]]
    ///    L = [0., 5.]
    /// 
    ///    Batch symmetric eigendecomposition
    ///    A = [[[1., 2.], [2., 4.]],
    ///         [[1., 2.], [2., 5.]]]
    ///    U, L = syevd(A)
    ///    U = [[[0.89442719, -0.4472136],
    ///          [0.4472136, 0.89442719]],
    ///         [[0.92387953, -0.38268343],
    ///          [0.38268343, 0.92387953]]]
    ///    L = [[0., 5.],
    ///         [0.17157288, 5.82842712]]
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\la_op.cc:L867</summary>
    /// <param name="A">Tensor of input matrices to be factorized</param>
    new([<Optional>] ?A : Symbol) =
        let A = defaultArg A (new ImplicitVariable() :> Symbol)
        let operatorArguments = 
            [
                "A", Input A
            ]
        new LinalgSyevd(Arguments<Symbol>(operatorArguments))
    /// Tensor of input matrices to be factorized
    member __.A = operatorArguments.GetInput "A"
    /// <summary>Copy LinalgSyevd instance with updated inputs/parameters.</summary>
    /// <param name="A">Tensor of input matrices to be factorized</param>
    member this.With([<Optional>] ?A : Symbol) =
        let operatorArguments = 
            [
                A |> Option.map (fun x -> "A", Input x)
            ] |> List.choose id
        new LinalgSyevd(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type LinalgInverse private (operatorArguments) = 
    inherit SymbolOperator("_linalg_inverse", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new LinalgInverse(args)
    override this.WithArguments(args : Arguments<Symbol>) = new LinalgInverse(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <summary>Compute the inverse of a matrix.
    /// Input is a tensor *A* of dimension *n &gt;= 2*.
    /// 
    /// If *n=2*, *A* is a square matrix. We compute:
    /// 
    ///   *out* = *A*\ :sup:`-1`
    /// 
    /// If *n&gt;2*, *inverse* is performed separately on the trailing two dimensions
    /// for all inputs (batch mode).
    /// 
    /// .. note:: The operator supports float32 and float64 data types only.
    /// 
    /// Examples::
    /// 
    ///    Single matrix inverse
    ///    A = [[1., 4.], [2., 3.]]
    ///    inverse(A) = [[-0.6, 0.8], [0.4, -0.2]]
    /// 
    ///    Batch matrix inverse
    ///    A = [[[1., 4.], [2., 3.]],
    ///         [[1., 3.], [2., 4.]]]
    ///    inverse(A) = [[[-0.6, 0.8], [0.4, -0.2]],
    ///                  [[-2., 1.5], [1., -0.5]]]
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\la_op.cc:L917</summary>
    /// <param name="A">Tensor of square matrix</param>
    new([<Optional>] ?A : Symbol) =
        let A = defaultArg A (new ImplicitVariable() :> Symbol)
        let operatorArguments = 
            [
                "A", Input A
            ]
        new LinalgInverse(Arguments<Symbol>(operatorArguments))
    /// Tensor of square matrix
    member __.A = operatorArguments.GetInput "A"
    /// <summary>Copy LinalgInverse instance with updated inputs/parameters.</summary>
    /// <param name="A">Tensor of square matrix</param>
    member this.With([<Optional>] ?A : Symbol) =
        let operatorArguments = 
            [
                A |> Option.map (fun x -> "A", Input x)
            ] |> List.choose id
        new LinalgInverse(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type LinalgDet private (operatorArguments) = 
    inherit SymbolOperator("_linalg_det", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new LinalgDet(args)
    override this.WithArguments(args : Arguments<Symbol>) = new LinalgDet(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <summary>Compute the determinant of a matrix.
    /// Input is a tensor *A* of dimension *n &gt;= 2*.
    /// 
    /// If *n=2*, *A* is a square matrix. We compute:
    /// 
    ///   *out* = *det(A)*
    /// 
    /// If *n&gt;2*, *det* is performed separately on the trailing two dimensions
    /// for all inputs (batch mode).
    /// 
    /// .. note:: The operator supports float32 and float64 data types only.
    /// .. note:: There is no gradient backwarded when A is non-invertible (which is
    ///           equivalent to det(A) = 0) because zero is rarely hit upon in float
    ///           point computation and the Jacobi&#39;s formula on determinant gradient
    ///           is not computationally efficient when A is non-invertible.
    /// 
    /// Examples::
    /// 
    ///    Single matrix determinant
    ///    A = [[1., 4.], [2., 3.]]
    ///    det(A) = [-5.]
    /// 
    ///    Batch matrix determinant
    ///    A = [[[1., 4.], [2., 3.]],
    ///         [[2., 3.], [1., 4.]]]
    ///    det(A) = [-5., 5.]
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\la_op.cc:L970</summary>
    /// <param name="A">Tensor of square matrix</param>
    new([<Optional>] ?A : Symbol) =
        let A = defaultArg A (new ImplicitVariable() :> Symbol)
        let operatorArguments = 
            [
                "A", Input A
            ]
        new LinalgDet(Arguments<Symbol>(operatorArguments))
    /// Tensor of square matrix
    member __.A = operatorArguments.GetInput "A"
    /// <summary>Copy LinalgDet instance with updated inputs/parameters.</summary>
    /// <param name="A">Tensor of square matrix</param>
    member this.With([<Optional>] ?A : Symbol) =
        let operatorArguments = 
            [
                A |> Option.map (fun x -> "A", Input x)
            ] |> List.choose id
        new LinalgDet(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type LinalgSlogdet private (operatorArguments) = 
    inherit SymbolOperator("_linalg_slogdet", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new LinalgSlogdet(args)
    override this.WithArguments(args : Arguments<Symbol>) = new LinalgSlogdet(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <summary>Compute the sign and log of the determinant of a matrix.
    /// Input is a tensor *A* of dimension *n &gt;= 2*.
    /// 
    /// If *n=2*, *A* is a square matrix. We compute:
    /// 
    ///   *sign* = *sign(det(A))*
    ///   *logabsdet* = *log(abs(det(A)))*
    /// 
    /// If *n&gt;2*, *slogdet* is performed separately on the trailing two dimensions
    /// for all inputs (batch mode).
    /// 
    /// .. note:: The operator supports float32 and float64 data types only.
    /// .. note:: The gradient is not properly defined on sign, so the gradient of
    ///           it is not backwarded.
    /// .. note:: No gradient is backwarded when A is non-invertible. Please see
    ///           the docs of operator det for detail.
    /// 
    /// Examples::
    /// 
    ///    Single matrix signed log determinant
    ///    A = [[2., 3.], [1., 4.]]
    ///    sign, logabsdet = slogdet(A)
    ///    sign = [1.]
    ///    logabsdet = [1.609438]
    /// 
    ///    Batch matrix signed log determinant
    ///    A = [[[2., 3.], [1., 4.]],
    ///         [[1., 2.], [2., 4.]],
    ///         [[1., 2.], [4., 3.]]]
    ///    sign, logabsdet = slogdet(A)
    ///    sign = [1., 0., -1.]
    ///    logabsdet = [1.609438, -inf, 1.609438]
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\la_op.cc:L1027</summary>
    /// <param name="A">Tensor of square matrix</param>
    new([<Optional>] ?A : Symbol) =
        let A = defaultArg A (new ImplicitVariable() :> Symbol)
        let operatorArguments = 
            [
                "A", Input A
            ]
        new LinalgSlogdet(Arguments<Symbol>(operatorArguments))
    /// Tensor of square matrix
    member __.A = operatorArguments.GetInput "A"
    /// <summary>Copy LinalgSlogdet instance with updated inputs/parameters.</summary>
    /// <param name="A">Tensor of square matrix</param>
    member this.With([<Optional>] ?A : Symbol) =
        let operatorArguments = 
            [
                A |> Option.map (fun x -> "A", Input x)
            ] |> List.choose id
        new LinalgSlogdet(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type Reshape private (operatorArguments) = 
    inherit SymbolOperator("Reshape", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new Reshape(args)
    override this.WithArguments(args : Arguments<Symbol>) = new Reshape(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <summary>Reshapes the input array.
    /// 
    /// .. note:: ``Reshape`` is deprecated, use ``reshape``
    /// 
    /// Given an array and a shape, this function returns a copy of the array in the new shape.
    /// The shape is a tuple of integers such as (2,3,4). The size of the new shape should be same as the size of the input array.
    /// 
    /// Example::
    /// 
    ///   reshape([1,2,3,4], shape=(2,2)) = [[1,2], [3,4]]
    /// 
    /// Some dimensions of the shape can take special values from the set {0, -1, -2, -3, -4}. The significance of each is explained below:
    /// 
    /// - ``0``  copy this dimension from the input to the output shape.
    /// 
    ///   Example::
    /// 
    ///   - input shape = (2,3,4), shape = (4,0,2), output shape = (4,3,2)
    ///   - input shape = (2,3,4), shape = (2,0,0), output shape = (2,3,4)
    /// 
    /// - ``-1`` infers the dimension of the output shape by using the remainder of the input dimensions
    ///   keeping the size of the new array same as that of the input array.
    ///   At most one dimension of shape can be -1.
    /// 
    ///   Example::
    /// 
    ///   - input shape = (2,3,4), shape = (6,1,-1), output shape = (6,1,4)
    ///   - input shape = (2,3,4), shape = (3,-1,8), output shape = (3,1,8)
    ///   - input shape = (2,3,4), shape=(-1,), output shape = (24,)
    /// 
    /// - ``-2`` copy all/remainder of the input dimensions to the output shape.
    /// 
    ///   Example::
    /// 
    ///   - input shape = (2,3,4), shape = (-2,), output shape = (2,3,4)
    ///   - input shape = (2,3,4), shape = (2,-2), output shape = (2,3,4)
    ///   - input shape = (2,3,4), shape = (-2,1,1), output shape = (2,3,4,1,1)
    /// 
    /// - ``-3`` use the product of two consecutive dimensions of the input shape as the output dimension.
    /// 
    ///   Example::
    /// 
    ///   - input shape = (2,3,4), shape = (-3,4), output shape = (6,4)
    ///   - input shape = (2,3,4,5), shape = (-3,-3), output shape = (6,20)
    ///   - input shape = (2,3,4), shape = (0,-3), output shape = (2,12)
    ///   - input shape = (2,3,4), shape = (-3,-2), output shape = (6,4)
    /// 
    /// - ``-4`` split one dimension of the input into two dimensions passed subsequent to -4 in shape (can contain -1).
    /// 
    ///   Example::
    /// 
    ///   - input shape = (2,3,4), shape = (-4,1,2,-2), output shape =(1,2,3,4)
    ///   - input shape = (2,3,4), shape = (2,-4,-1,3,-2), output shape = (2,1,3,4)
    /// 
    /// If the argument `reverse` is set to 1, then the special values are inferred from right to left.
    /// 
    ///   Example::
    /// 
    ///   - without reverse=1, for input shape = (10,5,4), shape = (-1,0), output shape would be (40,5)
    ///   - with reverse=1, output shape will be (50,4).
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\matrix_op.cc:L202</summary>
    /// <param name="data">Input data to reshape.</param>
    /// <param name="shape">The target shape</param>
    /// <param name="reverse">If true then the special values are inferred from right to left</param>
    /// <param name="targetShape">(Deprecated! Use ``shape`` instead.) Target new shape. One and only one dim can be 0, in which case it will be inferred from the rest of dims</param>
    /// <param name="keepHighest">(Deprecated! Use ``shape`` instead.) Whether keep the highest dim unchanged.If set to true, then the first dim in target_shape is ignored,and always fixed as input</param>
    new([<Optional>] ?data : Symbol,
        [<Optional>] ?shape : int seq,
        [<Optional>] ?reverse : bool,
        [<Optional>] ?targetShape : int seq,
        [<Optional>] ?keepHighest : bool) = 
        let data = defaultArg data (new ImplicitVariable() :> Symbol)
        let operatorArguments = 
            [
                "data", Input data
                "shape", shape |> Option.map box |> Parameter
                "reverse", reverse |> Option.map box |> Parameter
                "target_shape", targetShape |> Option.map box |> Parameter
                "keep_highest", keepHighest |> Option.map box |> Parameter
            ]
        new Reshape(Arguments<Symbol>(operatorArguments))
    /// Default value for Shape
    /// The target shape
    static member ShapeDefault : int [] = [||]
    /// Default value for Reverse
    /// If true then the special values are inferred from right to left
    static member ReverseDefault : bool = false
    /// Default value for TargetShape
    /// (Deprecated! Use ``shape`` instead.) Target new shape. One and only one dim can be 0, in which case it will be inferred from the rest of dims
    static member TargetShapeDefault : int [] = [||]
    /// Default value for KeepHighest
    /// (Deprecated! Use ``shape`` instead.) Whether keep the highest dim unchanged.If set to true, then the first dim in target_shape is ignored,and always fixed as input
    static member KeepHighestDefault : bool = false
    /// Input data to reshape.
    member __.Data = operatorArguments.GetInput "data"
    /// The target shape
    member __.Shape = operatorArguments.GetParameter("shape", Reshape.ShapeDefault)
    /// If true then the special values are inferred from right to left
    member __.Reverse = operatorArguments.GetParameter("reverse", Reshape.ReverseDefault)
    /// (Deprecated! Use ``shape`` instead.) Target new shape. One and only one dim can be 0, in which case it will be inferred from the rest of dims
    member __.TargetShape = operatorArguments.GetParameter("target_shape", Reshape.TargetShapeDefault)
    /// (Deprecated! Use ``shape`` instead.) Whether keep the highest dim unchanged.If set to true, then the first dim in target_shape is ignored,and always fixed as input
    member __.KeepHighest = operatorArguments.GetParameter("keep_highest", Reshape.KeepHighestDefault)
    /// <summary>Copy Reshape instance with updated inputs/parameters.</summary>
    /// <param name="data">Input data to reshape.</param>
    /// <param name="shape">The target shape</param>
    /// <param name="reverse">If true then the special values are inferred from right to left</param>
    /// <param name="targetShape">(Deprecated! Use ``shape`` instead.) Target new shape. One and only one dim can be 0, in which case it will be inferred from the rest of dims</param>
    /// <param name="keepHighest">(Deprecated! Use ``shape`` instead.) Whether keep the highest dim unchanged.If set to true, then the first dim in target_shape is ignored,and always fixed as input</param>
    member this.With([<Optional>] ?data : Symbol,
        [<Optional>] ?shape : int seq,
        [<Optional>] ?reverse : bool,
        [<Optional>] ?targetShape : int seq,
        [<Optional>] ?keepHighest : bool) = 
        let operatorArguments = 
            [
                data |> Option.map (fun x -> "data", Input x)
                shape |> Option.map (fun x -> "shape", Parameter(Some (box x)))
                reverse |> Option.map (fun x -> "reverse", Parameter(Some (box x)))
                targetShape |> Option.map (fun x -> "target_shape", Parameter(Some (box x)))
                keepHighest |> Option.map (fun x -> "keep_highest", Parameter(Some (box x)))
            ] |> List.choose id
        new Reshape(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type Transpose private (operatorArguments) = 
    inherit SymbolOperator("transpose", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new Transpose(args)
    override this.WithArguments(args : Arguments<Symbol>) = new Transpose(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <summary>Permutes the dimensions of an array.
    /// 
    /// Examples::
    /// 
    ///   x = [[ 1, 2],
    ///        [ 3, 4]]
    /// 
    ///   transpose(x) = [[ 1.,  3.],
    ///                   [ 2.,  4.]]
    /// 
    ///   x = [[[ 1.,  2.],
    ///         [ 3.,  4.]],
    /// 
    ///        [[ 5.,  6.],
    ///         [ 7.,  8.]]]
    /// 
    ///   transpose(x) = [[[ 1.,  5.],
    ///                    [ 3.,  7.]],
    /// 
    ///                   [[ 2.,  6.],
    ///                    [ 4.,  8.]]]
    /// 
    ///   transpose(x, axes=(1,0,2)) = [[[ 1.,  2.],
    ///                                  [ 5.,  6.]],
    /// 
    ///                                 [[ 3.,  4.],
    ///                                  [ 7.,  8.]]]
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\matrix_op.cc:L379</summary>
    /// <param name="data">Source input</param>
    /// <param name="axes">Target axis order. By default the axes will be inverted.</param>
    new([<Optional>] ?data : Symbol,
        [<Optional>] ?axes : int seq) = 
        let data = defaultArg data (new ImplicitVariable() :> Symbol)
        let operatorArguments = 
            [
                "data", Input data
                "axes", axes |> Option.map box |> Parameter
            ]
        new Transpose(Arguments<Symbol>(operatorArguments))
    /// Default value for Axes
    /// Target axis order. By default the axes will be inverted.
    static member AxesDefault : int [] = [||]
    /// Source input
    member __.Data = operatorArguments.GetInput "data"
    /// Target axis order. By default the axes will be inverted.
    member __.Axes = operatorArguments.GetParameter("axes", Transpose.AxesDefault)
    /// <summary>Copy Transpose instance with updated inputs/parameters.</summary>
    /// <param name="data">Source input</param>
    /// <param name="axes">Target axis order. By default the axes will be inverted.</param>
    member this.With([<Optional>] ?data : Symbol,
        [<Optional>] ?axes : int seq) = 
        let operatorArguments = 
            [
                data |> Option.map (fun x -> "data", Input x)
                axes |> Option.map (fun x -> "axes", Parameter(Some (box x)))
            ] |> List.choose id
        new Transpose(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type ExpandDims private (operatorArguments) = 
    inherit SymbolOperator("expand_dims", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new ExpandDims(args)
    override this.WithArguments(args : Arguments<Symbol>) = new ExpandDims(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <summary>Inserts a new axis of size 1 into the array shape
    /// 
    /// For example, given ``x`` with shape ``(2,3,4)``, then ``expand_dims(x, axis=1)``
    /// will return a new array with shape ``(2,1,3,4)``.
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\matrix_op.cc:L421</summary>
    /// <param name="data">Source input</param>
    /// <param name="axis">Position where new axis is to be inserted. Suppose that the input `NDArray`&#39;s dimension is `ndim`, the range of the inserted axis is `[-ndim, ndim]`</param>
    new(data : Symbol,
        axis : int) = 
        let operatorArguments = 
            [
                "data", Input data
                "axis", Parameter(Some(box axis))
            ]
        new ExpandDims(Arguments<Symbol>(operatorArguments))
    /// <summary>Inserts a new axis of size 1 into the array shape
    /// 
    /// For example, given ``x`` with shape ``(2,3,4)``, then ``expand_dims(x, axis=1)``
    /// will return a new array with shape ``(2,1,3,4)``.
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\matrix_op.cc:L421</summary>
    /// <param name="axis">Position where new axis is to be inserted. Suppose that the input `NDArray`&#39;s dimension is `ndim`, the range of the inserted axis is `[-ndim, ndim]`</param>
    /// <param name="data">Source input</param>
    new(axis : int,
        [<Optional>] ?data : Symbol) = 
        let data = defaultArg data (new ImplicitVariable() :> Symbol)
        let operatorArguments = 
            [
                "data", Input data
                "axis", Parameter(Some(box axis))
            ]
        new ExpandDims(Arguments<Symbol>(operatorArguments))
    /// Source input
    member __.Data = operatorArguments.GetInput "data"
    /// Position where new axis is to be inserted. Suppose that the input `NDArray`&#39;s dimension is `ndim`, the range of the inserted axis is `[-ndim, ndim]`
    member __.Axis : int = match operatorArguments.GetParameter "axis" with Some(v) -> unbox v | None -> failwithf "Required parameter axis is missing"
    /// <summary>Copy ExpandDims instance with updated inputs/parameters.</summary>
    /// <param name="data">Source input</param>
    /// <param name="axis">Position where new axis is to be inserted. Suppose that the input `NDArray`&#39;s dimension is `ndim`, the range of the inserted axis is `[-ndim, ndim]`</param>
    member this.With([<Optional>] ?data : Symbol,
        [<Optional>] ?axis : int) = 
        let operatorArguments = 
            [
                data |> Option.map (fun x -> "data", Input x)
                axis |> Option.map (fun x -> "axis", Parameter(Some (box x)))
            ] |> List.choose id
        new ExpandDims(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type Slice private (operatorArguments) = 
    inherit SymbolOperator("slice", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new Slice(args)
    override this.WithArguments(args : Arguments<Symbol>) = new Slice(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <summary>Slices a region of the array.
    /// 
    /// .. note:: ``crop`` is deprecated. Use ``slice`` instead.
    /// 
    /// This function returns a sliced array between the indices given
    /// by `begin` and `end` with the corresponding `step`.
    /// 
    /// For an input array of ``shape=(d_0, d_1, ..., d_n-1)``,
    /// slice operation with ``begin=(b_0, b_1...b_m-1)``,
    /// ``end=(e_0, e_1, ..., e_m-1)``, and ``step=(s_0, s_1, ..., s_m-1)``,
    /// where m &lt;= n, results in an array with the shape
    /// ``(|e_0-b_0|/|s_0|, ..., |e_m-1-b_m-1|/|s_m-1|, d_m, ..., d_n-1)``.
    /// 
    /// The resulting array&#39;s *k*-th dimension contains elements
    /// from the *k*-th dimension of the input array starting
    /// from index ``b_k`` (inclusive) with step ``s_k``
    /// until reaching ``e_k`` (exclusive).
    /// 
    /// If the *k*-th elements are `None` in the sequence of `begin`, `end`,
    /// and `step`, the following rule will be used to set default values.
    /// If `s_k` is `None`, set `s_k=1`. If `s_k &gt; 0`, set `b_k=0`, `e_k=d_k`;
    /// else, set `b_k=d_k-1`, `e_k=-1`.
    /// 
    /// The storage type of ``slice`` output depends on storage types of inputs
    /// 
    /// - slice(csr) = csr
    /// - otherwise, ``slice`` generates output with default storage
    /// 
    /// .. note:: When input data storage type is csr, it only supports
    ///    step=(), or step=(None,), or step=(1,) to generate a csr output.
    ///    For other step parameter values, it falls back to slicing
    ///    a dense tensor.
    /// 
    /// Example::
    /// 
    ///   x = [[  1.,   2.,   3.,   4.],
    ///        [  5.,   6.,   7.,   8.],
    ///        [  9.,  10.,  11.,  12.]]
    /// 
    ///   slice(x, begin=(0,1), end=(2,4)) = [[ 2.,  3.,  4.],
    ///                                      [ 6.,  7.,  8.]]
    ///   slice(x, begin=(None, 0), end=(None, 3), step=(-1, 2)) = [[9., 11.],
    ///                                                             [5.,  7.],
    ///                                                             [1.,  3.]]
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\matrix_op.cc:L511</summary>
    /// <param name="data">Source input</param>
    /// <param name="sliceBegin">starting indices for the slice operation, supports negative indices.</param>
    /// <param name="sliceEnd">ending indices for the slice operation, supports negative indices.</param>
    /// <param name="step">step for the slice operation, supports negative values.</param>
    new(data : Symbol,
        sliceBegin : int option seq,
        sliceEnd : int option seq,
        [<Optional>] ?step : int option seq) = 
        let operatorArguments = 
            [
                "data", Input data
                "begin", Parameter(Some(box sliceBegin))
                "end", Parameter(Some(box sliceEnd))
                "step", step |> Option.map box |> Parameter
            ]
        new Slice(Arguments<Symbol>(operatorArguments))
    /// <summary>Slices a region of the array.
    /// 
    /// .. note:: ``crop`` is deprecated. Use ``slice`` instead.
    /// 
    /// This function returns a sliced array between the indices given
    /// by `begin` and `end` with the corresponding `step`.
    /// 
    /// For an input array of ``shape=(d_0, d_1, ..., d_n-1)``,
    /// slice operation with ``begin=(b_0, b_1...b_m-1)``,
    /// ``end=(e_0, e_1, ..., e_m-1)``, and ``step=(s_0, s_1, ..., s_m-1)``,
    /// where m &lt;= n, results in an array with the shape
    /// ``(|e_0-b_0|/|s_0|, ..., |e_m-1-b_m-1|/|s_m-1|, d_m, ..., d_n-1)``.
    /// 
    /// The resulting array&#39;s *k*-th dimension contains elements
    /// from the *k*-th dimension of the input array starting
    /// from index ``b_k`` (inclusive) with step ``s_k``
    /// until reaching ``e_k`` (exclusive).
    /// 
    /// If the *k*-th elements are `None` in the sequence of `begin`, `end`,
    /// and `step`, the following rule will be used to set default values.
    /// If `s_k` is `None`, set `s_k=1`. If `s_k &gt; 0`, set `b_k=0`, `e_k=d_k`;
    /// else, set `b_k=d_k-1`, `e_k=-1`.
    /// 
    /// The storage type of ``slice`` output depends on storage types of inputs
    /// 
    /// - slice(csr) = csr
    /// - otherwise, ``slice`` generates output with default storage
    /// 
    /// .. note:: When input data storage type is csr, it only supports
    ///    step=(), or step=(None,), or step=(1,) to generate a csr output.
    ///    For other step parameter values, it falls back to slicing
    ///    a dense tensor.
    /// 
    /// Example::
    /// 
    ///   x = [[  1.,   2.,   3.,   4.],
    ///        [  5.,   6.,   7.,   8.],
    ///        [  9.,  10.,  11.,  12.]]
    /// 
    ///   slice(x, begin=(0,1), end=(2,4)) = [[ 2.,  3.,  4.],
    ///                                      [ 6.,  7.,  8.]]
    ///   slice(x, begin=(None, 0), end=(None, 3), step=(-1, 2)) = [[9., 11.],
    ///                                                             [5.,  7.],
    ///                                                             [1.,  3.]]
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\matrix_op.cc:L511</summary>
    /// <param name="sliceBegin">starting indices for the slice operation, supports negative indices.</param>
    /// <param name="sliceEnd">ending indices for the slice operation, supports negative indices.</param>
    /// <param name="data">Source input</param>
    /// <param name="step">step for the slice operation, supports negative values.</param>
    new(sliceBegin : int option seq,
        sliceEnd : int option seq,
        [<Optional>] ?data : Symbol,
        [<Optional>] ?step : int option seq) = 
        let data = defaultArg data (new ImplicitVariable() :> Symbol)
        let operatorArguments = 
            [
                "data", Input data
                "begin", Parameter(Some(box sliceBegin))
                "end", Parameter(Some(box sliceEnd))
                "step", step |> Option.map box |> Parameter
            ]
        new Slice(Arguments<Symbol>(operatorArguments))
    /// Default value for Step
    /// step for the slice operation, supports negative values.
    static member StepDefault : int [] = [||]
    /// Source input
    member __.Data = operatorArguments.GetInput "data"
    /// starting indices for the slice operation, supports negative indices.
    member __.SliceBegin : int option seq = match operatorArguments.GetParameter "begin" with Some(v) -> unbox v | None -> failwithf "Required parameter begin is missing"
    /// ending indices for the slice operation, supports negative indices.
    member __.SliceEnd : int option seq = match operatorArguments.GetParameter "end" with Some(v) -> unbox v | None -> failwithf "Required parameter end is missing"
    /// step for the slice operation, supports negative values.
    member __.Step = operatorArguments.GetParameter("step", Slice.StepDefault)
    /// <summary>Copy Slice instance with updated inputs/parameters.</summary>
    /// <param name="data">Source input</param>
    /// <param name="sliceBegin">starting indices for the slice operation, supports negative indices.</param>
    /// <param name="sliceEnd">ending indices for the slice operation, supports negative indices.</param>
    /// <param name="step">step for the slice operation, supports negative values.</param>
    member this.With([<Optional>] ?data : Symbol,
        [<Optional>] ?sliceBegin : int option seq,
        [<Optional>] ?sliceEnd : int option seq,
        [<Optional>] ?step : int option seq) = 
        let operatorArguments = 
            [
                data |> Option.map (fun x -> "data", Input x)
                sliceBegin |> Option.map (fun x -> "begin", Parameter(Some (box x)))
                sliceEnd |> Option.map (fun x -> "end", Parameter(Some (box x)))
                step |> Option.map (fun x -> "step", Parameter(Some (box x)))
            ] |> List.choose id
        new Slice(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type SliceAssign private (operatorArguments) = 
    inherit SymbolOperator("_slice_assign", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new SliceAssign(args)
    override this.WithArguments(args : Arguments<Symbol>) = new SliceAssign(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <summary>Assign the rhs to a cropped subset of lhs.
    /// 
    /// Requirements
    /// ------------
    /// - output should be explicitly given and be the same as lhs.
    /// - lhs and rhs are of the same data type, and on the same device.
    /// 
    /// 
    /// From:C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\matrix_op.cc:543</summary>
    /// <param name="lhs">Source input</param>
    /// <param name="rhs">value to assign</param>
    /// <param name="sliceBegin">starting indices for the slice operation, supports negative indices.</param>
    /// <param name="sliceEnd">ending indices for the slice operation, supports negative indices.</param>
    /// <param name="step">step for the slice operation, supports negative values.</param>
    new(lhs : Symbol,
        rhs : Symbol,
        sliceBegin : int option seq,
        sliceEnd : int option seq,
        [<Optional>] ?step : int option seq) = 
        let operatorArguments = 
            [
                "lhs", Input lhs
                "rhs", Input rhs
                "begin", Parameter(Some(box sliceBegin))
                "end", Parameter(Some(box sliceEnd))
                "step", step |> Option.map box |> Parameter
            ]
        new SliceAssign(Arguments<Symbol>(operatorArguments))
    /// <summary>Assign the rhs to a cropped subset of lhs.
    /// 
    /// Requirements
    /// ------------
    /// - output should be explicitly given and be the same as lhs.
    /// - lhs and rhs are of the same data type, and on the same device.
    /// 
    /// 
    /// From:C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\matrix_op.cc:543</summary>
    /// <param name="sliceBegin">starting indices for the slice operation, supports negative indices.</param>
    /// <param name="sliceEnd">ending indices for the slice operation, supports negative indices.</param>
    /// <param name="lhs">Source input</param>
    /// <param name="rhs">value to assign</param>
    /// <param name="step">step for the slice operation, supports negative values.</param>
    new(sliceBegin : int option seq,
        sliceEnd : int option seq,
        [<Optional>] ?lhs : Symbol,
        [<Optional>] ?rhs : Symbol,
        [<Optional>] ?step : int option seq) = 
        let lhs = defaultArg lhs (new ImplicitVariable() :> Symbol)
        let rhs = defaultArg rhs (new ImplicitVariable() :> Symbol)
        let operatorArguments = 
            [
                "lhs", Input lhs
                "rhs", Input rhs
                "begin", Parameter(Some(box sliceBegin))
                "end", Parameter(Some(box sliceEnd))
                "step", step |> Option.map box |> Parameter
            ]
        new SliceAssign(Arguments<Symbol>(operatorArguments))
    /// Default value for Step
    /// step for the slice operation, supports negative values.
    static member StepDefault : int [] = [||]
    /// Source input
    member __.Lhs = operatorArguments.GetInput "lhs"
    /// value to assign
    member __.Rhs = operatorArguments.GetInput "rhs"
    /// starting indices for the slice operation, supports negative indices.
    member __.SliceBegin : int option seq = match operatorArguments.GetParameter "begin" with Some(v) -> unbox v | None -> failwithf "Required parameter begin is missing"
    /// ending indices for the slice operation, supports negative indices.
    member __.SliceEnd : int option seq = match operatorArguments.GetParameter "end" with Some(v) -> unbox v | None -> failwithf "Required parameter end is missing"
    /// step for the slice operation, supports negative values.
    member __.Step = operatorArguments.GetParameter("step", SliceAssign.StepDefault)
    /// <summary>Copy SliceAssign instance with updated inputs/parameters.</summary>
    /// <param name="lhs">Source input</param>
    /// <param name="rhs">value to assign</param>
    /// <param name="sliceBegin">starting indices for the slice operation, supports negative indices.</param>
    /// <param name="sliceEnd">ending indices for the slice operation, supports negative indices.</param>
    /// <param name="step">step for the slice operation, supports negative values.</param>
    member this.With([<Optional>] ?lhs : Symbol,
        [<Optional>] ?rhs : Symbol,
        [<Optional>] ?sliceBegin : int option seq,
        [<Optional>] ?sliceEnd : int option seq,
        [<Optional>] ?step : int option seq) = 
        let operatorArguments = 
            [
                lhs |> Option.map (fun x -> "lhs", Input x)
                rhs |> Option.map (fun x -> "rhs", Input x)
                sliceBegin |> Option.map (fun x -> "begin", Parameter(Some (box x)))
                sliceEnd |> Option.map (fun x -> "end", Parameter(Some (box x)))
                step |> Option.map (fun x -> "step", Parameter(Some (box x)))
            ] |> List.choose id
        new SliceAssign(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type SliceAssignScalar private (operatorArguments) = 
    inherit SymbolOperator("_slice_assign_scalar", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new SliceAssignScalar(args)
    override this.WithArguments(args : Arguments<Symbol>) = new SliceAssignScalar(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <summary>(Assign the scalar to a cropped subset of the input.
    /// 
    /// Requirements
    /// ------------
    /// - output should be explicitly given and be the same as input
    /// )
    /// 
    /// From:C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\matrix_op.cc:569</summary>
    /// <param name="data">Source input</param>
    /// <param name="sliceBegin">starting indices for the slice operation, supports negative indices.</param>
    /// <param name="sliceEnd">ending indices for the slice operation, supports negative indices.</param>
    /// <param name="scalar">The scalar value for assignment.</param>
    /// <param name="step">step for the slice operation, supports negative values.</param>
    new(data : Symbol,
        sliceBegin : int option seq,
        sliceEnd : int option seq,
        [<Optional>] ?scalar : double,
        [<Optional>] ?step : int option seq) = 
        let operatorArguments = 
            [
                "data", Input data
                "begin", Parameter(Some(box sliceBegin))
                "end", Parameter(Some(box sliceEnd))
                "scalar", scalar |> Option.map box |> Parameter
                "step", step |> Option.map box |> Parameter
            ]
        new SliceAssignScalar(Arguments<Symbol>(operatorArguments))
    /// <summary>(Assign the scalar to a cropped subset of the input.
    /// 
    /// Requirements
    /// ------------
    /// - output should be explicitly given and be the same as input
    /// )
    /// 
    /// From:C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\matrix_op.cc:569</summary>
    /// <param name="sliceBegin">starting indices for the slice operation, supports negative indices.</param>
    /// <param name="sliceEnd">ending indices for the slice operation, supports negative indices.</param>
    /// <param name="data">Source input</param>
    /// <param name="scalar">The scalar value for assignment.</param>
    /// <param name="step">step for the slice operation, supports negative values.</param>
    new(sliceBegin : int option seq,
        sliceEnd : int option seq,
        [<Optional>] ?data : Symbol,
        [<Optional>] ?scalar : double,
        [<Optional>] ?step : int option seq) = 
        let data = defaultArg data (new ImplicitVariable() :> Symbol)
        let operatorArguments = 
            [
                "data", Input data
                "begin", Parameter(Some(box sliceBegin))
                "end", Parameter(Some(box sliceEnd))
                "scalar", scalar |> Option.map box |> Parameter
                "step", step |> Option.map box |> Parameter
            ]
        new SliceAssignScalar(Arguments<Symbol>(operatorArguments))
    /// Default value for Scalar
    /// The scalar value for assignment.
    static member ScalarDefault : double = 0.0
    /// Default value for Step
    /// step for the slice operation, supports negative values.
    static member StepDefault : int [] = [||]
    /// Source input
    member __.Data = operatorArguments.GetInput "data"
    /// starting indices for the slice operation, supports negative indices.
    member __.SliceBegin : int option seq = match operatorArguments.GetParameter "begin" with Some(v) -> unbox v | None -> failwithf "Required parameter begin is missing"
    /// ending indices for the slice operation, supports negative indices.
    member __.SliceEnd : int option seq = match operatorArguments.GetParameter "end" with Some(v) -> unbox v | None -> failwithf "Required parameter end is missing"
    /// The scalar value for assignment.
    member __.Scalar = operatorArguments.GetParameter("scalar", SliceAssignScalar.ScalarDefault)
    /// step for the slice operation, supports negative values.
    member __.Step = operatorArguments.GetParameter("step", SliceAssignScalar.StepDefault)
    /// <summary>Copy SliceAssignScalar instance with updated inputs/parameters.</summary>
    /// <param name="data">Source input</param>
    /// <param name="sliceBegin">starting indices for the slice operation, supports negative indices.</param>
    /// <param name="sliceEnd">ending indices for the slice operation, supports negative indices.</param>
    /// <param name="scalar">The scalar value for assignment.</param>
    /// <param name="step">step for the slice operation, supports negative values.</param>
    member this.With([<Optional>] ?data : Symbol,
        [<Optional>] ?sliceBegin : int option seq,
        [<Optional>] ?sliceEnd : int option seq,
        [<Optional>] ?scalar : double,
        [<Optional>] ?step : int option seq) = 
        let operatorArguments = 
            [
                data |> Option.map (fun x -> "data", Input x)
                sliceBegin |> Option.map (fun x -> "begin", Parameter(Some (box x)))
                sliceEnd |> Option.map (fun x -> "end", Parameter(Some (box x)))
                scalar |> Option.map (fun x -> "scalar", Parameter(Some (box x)))
                step |> Option.map (fun x -> "step", Parameter(Some (box x)))
            ] |> List.choose id
        new SliceAssignScalar(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type SliceAxis private (operatorArguments) = 
    inherit SymbolOperator("slice_axis", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new SliceAxis(args)
    override this.WithArguments(args : Arguments<Symbol>) = new SliceAxis(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <summary>Slices along a given axis.
    /// 
    /// Returns an array slice along a given `axis` starting from the `begin` index
    /// to the `end` index.
    /// 
    /// Examples::
    /// 
    ///   x = [[  1.,   2.,   3.,   4.],
    ///        [  5.,   6.,   7.,   8.],
    ///        [  9.,  10.,  11.,  12.]]
    /// 
    ///   slice_axis(x, axis=0, begin=1, end=3) = [[  5.,   6.,   7.,   8.],
    ///                                            [  9.,  10.,  11.,  12.]]
    /// 
    ///   slice_axis(x, axis=1, begin=0, end=2) = [[  1.,   2.],
    ///                                            [  5.,   6.],
    ///                                            [  9.,  10.]]
    /// 
    ///   slice_axis(x, axis=1, begin=-3, end=-1) = [[  2.,   3.],
    ///                                              [  6.,   7.],
    ///                                              [ 10.,  11.]]
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\matrix_op.cc:L605</summary>
    /// <param name="data">Source input</param>
    /// <param name="axis">Axis along which to be sliced, supports negative indexes.</param>
    /// <param name="sliceBegin">The beginning index along the axis to be sliced,  supports negative indexes.</param>
    /// <param name="sliceEnd">The ending index along the axis to be sliced,  supports negative indexes.</param>
    new(data : Symbol,
        axis : int,
        sliceBegin : int,
        [<Optional>] ?sliceEnd : int) = 
        let operatorArguments = 
            [
                "data", Input data
                "axis", Parameter(Some(box axis))
                "begin", Parameter(Some(box sliceBegin))
                "end", sliceEnd |> Option.map box |> Parameter
            ]
        new SliceAxis(Arguments<Symbol>(operatorArguments))
    /// <summary>Slices along a given axis.
    /// 
    /// Returns an array slice along a given `axis` starting from the `begin` index
    /// to the `end` index.
    /// 
    /// Examples::
    /// 
    ///   x = [[  1.,   2.,   3.,   4.],
    ///        [  5.,   6.,   7.,   8.],
    ///        [  9.,  10.,  11.,  12.]]
    /// 
    ///   slice_axis(x, axis=0, begin=1, end=3) = [[  5.,   6.,   7.,   8.],
    ///                                            [  9.,  10.,  11.,  12.]]
    /// 
    ///   slice_axis(x, axis=1, begin=0, end=2) = [[  1.,   2.],
    ///                                            [  5.,   6.],
    ///                                            [  9.,  10.]]
    /// 
    ///   slice_axis(x, axis=1, begin=-3, end=-1) = [[  2.,   3.],
    ///                                              [  6.,   7.],
    ///                                              [ 10.,  11.]]
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\matrix_op.cc:L605</summary>
    /// <param name="axis">Axis along which to be sliced, supports negative indexes.</param>
    /// <param name="sliceBegin">The beginning index along the axis to be sliced,  supports negative indexes.</param>
    /// <param name="data">Source input</param>
    /// <param name="sliceEnd">The ending index along the axis to be sliced,  supports negative indexes.</param>
    new(axis : int,
        sliceBegin : int,
        [<Optional>] ?data : Symbol,
        [<Optional>] ?sliceEnd : int) = 
        let data = defaultArg data (new ImplicitVariable() :> Symbol)
        let operatorArguments = 
            [
                "data", Input data
                "axis", Parameter(Some(box axis))
                "begin", Parameter(Some(box sliceBegin))
                "end", sliceEnd |> Option.map box |> Parameter
            ]
        new SliceAxis(Arguments<Symbol>(operatorArguments))
    /// Default value for SliceEnd
    /// The ending index along the axis to be sliced,  supports negative indexes.
    static member SliceEndDefault : int option = None
    /// Source input
    member __.Data = operatorArguments.GetInput "data"
    /// Axis along which to be sliced, supports negative indexes.
    member __.Axis : int = match operatorArguments.GetParameter "axis" with Some(v) -> unbox v | None -> failwithf "Required parameter axis is missing"
    /// The beginning index along the axis to be sliced,  supports negative indexes.
    member __.SliceBegin : int = match operatorArguments.GetParameter "begin" with Some(v) -> unbox v | None -> failwithf "Required parameter begin is missing"
    /// The ending index along the axis to be sliced,  supports negative indexes.
    member __.SliceEnd = operatorArguments.GetParameter("end", SliceAxis.SliceEndDefault)
    /// <summary>Copy SliceAxis instance with updated inputs/parameters.</summary>
    /// <param name="data">Source input</param>
    /// <param name="axis">Axis along which to be sliced, supports negative indexes.</param>
    /// <param name="sliceBegin">The beginning index along the axis to be sliced,  supports negative indexes.</param>
    /// <param name="sliceEnd">The ending index along the axis to be sliced,  supports negative indexes.</param>
    member this.With([<Optional>] ?data : Symbol,
        [<Optional>] ?axis : int,
        [<Optional>] ?sliceBegin : int,
        [<Optional>] ?sliceEnd : int) = 
        let operatorArguments = 
            [
                data |> Option.map (fun x -> "data", Input x)
                axis |> Option.map (fun x -> "axis", Parameter(Some (box x)))
                sliceBegin |> Option.map (fun x -> "begin", Parameter(Some (box x)))
                sliceEnd |> Option.map (fun x -> "end", Parameter(Some (box x)))
            ] |> List.choose id
        new SliceAxis(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type SliceLike private (operatorArguments) = 
    inherit SymbolOperator("slice_like", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new SliceLike(args)
    override this.WithArguments(args : Arguments<Symbol>) = new SliceLike(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <summary>Slices a region of the array like the shape of another array.
    /// 
    /// This function is similar to ``slice``, however, the `begin` are always `0`s
    /// and `end` of specific axes are inferred from the second input `shape_like`.
    /// 
    /// Given the second `shape_like` input of ``shape=(d_0, d_1, ..., d_n-1)``,
    /// a ``slice_like`` operator with default empty `axes`, it performs the
    /// following operation:
    /// 
    /// `` out = slice(input, begin=(0, 0, ..., 0), end=(d_0, d_1, ..., d_n-1))``.
    /// 
    /// When `axes` is not empty, it is used to speficy which axes are being sliced.
    /// 
    /// Given a 4-d input data, ``slice_like`` operator with ``axes=(0, 2, -1)``
    /// will perform the following operation:
    /// 
    /// `` out = slice(input, begin=(0, 0, 0, 0), end=(d_0, None, d_2, d_3))``.
    /// 
    /// Note that it is allowed to have first and second input with different dimensions,
    /// however, you have to make sure the `axes` are specified and not exceeding the
    /// dimension limits.
    /// 
    /// For example, given `input_1` with ``shape=(2,3,4,5)`` and `input_2` with
    /// ``shape=(1,2,3)``, it is not allowed to use:
    /// 
    /// `` out = slice_like(a, b)`` because ndim of `input_1` is 4, and ndim of `input_2`
    /// is 3.
    /// 
    /// The following is allowed in this situation:
    /// 
    /// `` out = slice_like(a, b, axes=(0, 2))``
    /// 
    /// Example::
    /// 
    ///   x = [[  1.,   2.,   3.,   4.],
    ///        [  5.,   6.,   7.,   8.],
    ///        [  9.,  10.,  11.,  12.]]
    /// 
    ///   y = [[  0.,   0.,   0.],
    ///        [  0.,   0.,   0.]]
    /// 
    ///   slice_like(x, y) = [[ 1.,  2.,  3.]
    ///                       [ 5.,  6.,  7.]]
    ///   slice_like(x, y, axes=(0, 1)) = [[ 1.,  2.,  3.]
    ///                                    [ 5.,  6.,  7.]]
    ///   slice_like(x, y, axes=(0)) = [[ 1.,  2.,  3.,  4.]
    ///                                 [ 5.,  6.,  7.,  8.]]
    ///   slice_like(x, y, axes=(-1)) = [[  1.,   2.,   3.]
    ///                                  [  5.,   6.,   7.]
    ///                                  [  9.,  10.,  11.]]
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\matrix_op.cc:L674</summary>
    /// <param name="data">Source input</param>
    /// <param name="shapeLike">Shape like input</param>
    /// <param name="axes">List of axes on which input data will be sliced according to the corresponding size of the second input. By default will slice on all axes. Negative axes are supported.</param>
    new([<Optional>] ?data : Symbol,
        [<Optional>] ?shapeLike : Symbol,
        [<Optional>] ?axes : int seq) = 
        let data = defaultArg data (new ImplicitVariable() :> Symbol)
        let shapeLike = defaultArg shapeLike (new ImplicitVariable() :> Symbol)
        let operatorArguments = 
            [
                "data", Input data
                "shape_like", Input shapeLike
                "axes", axes |> Option.map box |> Parameter
            ]
        new SliceLike(Arguments<Symbol>(operatorArguments))
    /// Default value for Axes
    /// List of axes on which input data will be sliced according to the corresponding size of the second input. By default will slice on all axes. Negative axes are supported.
    static member AxesDefault : int [] = [||]
    /// Source input
    member __.Data = operatorArguments.GetInput "data"
    /// Shape like input
    member __.ShapeLike = operatorArguments.GetInput "shape_like"
    /// List of axes on which input data will be sliced according to the corresponding size of the second input. By default will slice on all axes. Negative axes are supported.
    member __.Axes = operatorArguments.GetParameter("axes", SliceLike.AxesDefault)
    /// <summary>Copy SliceLike instance with updated inputs/parameters.</summary>
    /// <param name="data">Source input</param>
    /// <param name="shapeLike">Shape like input</param>
    /// <param name="axes">List of axes on which input data will be sliced according to the corresponding size of the second input. By default will slice on all axes. Negative axes are supported.</param>
    member this.With([<Optional>] ?data : Symbol,
        [<Optional>] ?shapeLike : Symbol,
        [<Optional>] ?axes : int seq) = 
        let operatorArguments = 
            [
                data |> Option.map (fun x -> "data", Input x)
                shapeLike |> Option.map (fun x -> "shape_like", Input x)
                axes |> Option.map (fun x -> "axes", Parameter(Some (box x)))
            ] |> List.choose id
        new SliceLike(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type Clip private (operatorArguments) = 
    inherit SymbolOperator("clip", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new Clip(args)
    override this.WithArguments(args : Arguments<Symbol>) = new Clip(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <summary>Clips (limits) the values in an array.
    /// 
    /// Given an interval, values outside the interval are clipped to the interval edges.
    /// Clipping ``x`` between `a_min` and `a_max` would be::
    /// 
    /// .. math::
    /// 
    ///    clip(x, a_min, a_max) = \max(\min(x, a_max), a_min))
    /// 
    /// Example::
    /// 
    ///     x = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
    /// 
    ///     clip(x,1,8) = [ 1.,  1.,  2.,  3.,  4.,  5.,  6.,  7.,  8.,  8.]
    /// 
    /// The storage type of ``clip`` output depends on storage types of inputs and the a_min, a_max \
    /// parameter values:
    /// 
    ///    - clip(default) = default
    ///    - clip(row_sparse, a_min &lt;= 0, a_max &gt;= 0) = row_sparse
    ///    - clip(csr, a_min &lt;= 0, a_max &gt;= 0) = csr
    ///    - clip(row_sparse, a_min &lt; 0, a_max &lt; 0) = default
    ///    - clip(row_sparse, a_min &gt; 0, a_max &gt; 0) = default
    ///    - clip(csr, a_min &lt; 0, a_max &lt; 0) = csr
    ///    - clip(csr, a_min &gt; 0, a_max &gt; 0) = csr
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\matrix_op.cc:L735</summary>
    /// <param name="data">Input array.</param>
    /// <param name="aMin">Minimum value</param>
    /// <param name="aMax">Maximum value</param>
    new(data : Symbol,
        aMin : float,
        aMax : float) = 
        let operatorArguments = 
            [
                "data", Input data
                "a_min", Parameter(Some(box aMin))
                "a_max", Parameter(Some(box aMax))
            ]
        new Clip(Arguments<Symbol>(operatorArguments))
    /// <summary>Clips (limits) the values in an array.
    /// 
    /// Given an interval, values outside the interval are clipped to the interval edges.
    /// Clipping ``x`` between `a_min` and `a_max` would be::
    /// 
    /// .. math::
    /// 
    ///    clip(x, a_min, a_max) = \max(\min(x, a_max), a_min))
    /// 
    /// Example::
    /// 
    ///     x = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
    /// 
    ///     clip(x,1,8) = [ 1.,  1.,  2.,  3.,  4.,  5.,  6.,  7.,  8.,  8.]
    /// 
    /// The storage type of ``clip`` output depends on storage types of inputs and the a_min, a_max \
    /// parameter values:
    /// 
    ///    - clip(default) = default
    ///    - clip(row_sparse, a_min &lt;= 0, a_max &gt;= 0) = row_sparse
    ///    - clip(csr, a_min &lt;= 0, a_max &gt;= 0) = csr
    ///    - clip(row_sparse, a_min &lt; 0, a_max &lt; 0) = default
    ///    - clip(row_sparse, a_min &gt; 0, a_max &gt; 0) = default
    ///    - clip(csr, a_min &lt; 0, a_max &lt; 0) = csr
    ///    - clip(csr, a_min &gt; 0, a_max &gt; 0) = csr
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\matrix_op.cc:L735</summary>
    /// <param name="aMin">Minimum value</param>
    /// <param name="aMax">Maximum value</param>
    /// <param name="data">Input array.</param>
    new(aMin : float,
        aMax : float,
        [<Optional>] ?data : Symbol) = 
        let data = defaultArg data (new ImplicitVariable() :> Symbol)
        let operatorArguments = 
            [
                "data", Input data
                "a_min", Parameter(Some(box aMin))
                "a_max", Parameter(Some(box aMax))
            ]
        new Clip(Arguments<Symbol>(operatorArguments))
    /// Input array.
    member __.Data = operatorArguments.GetInput "data"
    /// Minimum value
    member __.AMin : float = match operatorArguments.GetParameter "a_min" with Some(v) -> unbox v | None -> failwithf "Required parameter a_min is missing"
    /// Maximum value
    member __.AMax : float = match operatorArguments.GetParameter "a_max" with Some(v) -> unbox v | None -> failwithf "Required parameter a_max is missing"
    /// <summary>Copy Clip instance with updated inputs/parameters.</summary>
    /// <param name="data">Input array.</param>
    /// <param name="aMin">Minimum value</param>
    /// <param name="aMax">Maximum value</param>
    member this.With([<Optional>] ?data : Symbol,
        [<Optional>] ?aMin : float,
        [<Optional>] ?aMax : float) = 
        let operatorArguments = 
            [
                data |> Option.map (fun x -> "data", Input x)
                aMin |> Option.map (fun x -> "a_min", Parameter(Some (box x)))
                aMax |> Option.map (fun x -> "a_max", Parameter(Some (box x)))
            ] |> List.choose id
        new Clip(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type Repeat private (operatorArguments) = 
    inherit SymbolOperator("repeat", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new Repeat(args)
    override this.WithArguments(args : Arguments<Symbol>) = new Repeat(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <summary>Repeats elements of an array.
    /// 
    /// By default, ``repeat`` flattens the input array into 1-D and then repeats the
    /// elements::
    /// 
    ///   x = [[ 1, 2],
    ///        [ 3, 4]]
    /// 
    ///   repeat(x, repeats=2) = [ 1.,  1.,  2.,  2.,  3.,  3.,  4.,  4.]
    /// 
    /// The parameter ``axis`` specifies the axis along which to perform repeat::
    /// 
    ///   repeat(x, repeats=2, axis=1) = [[ 1.,  1.,  2.,  2.],
    ///                                   [ 3.,  3.,  4.,  4.]]
    /// 
    ///   repeat(x, repeats=2, axis=0) = [[ 1.,  2.],
    ///                                   [ 1.,  2.],
    ///                                   [ 3.,  4.],
    ///                                   [ 3.,  4.]]
    /// 
    ///   repeat(x, repeats=2, axis=-1) = [[ 1.,  1.,  2.,  2.],
    ///                                    [ 3.,  3.,  4.,  4.]]
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\matrix_op.cc:L810</summary>
    /// <param name="data">Input data array</param>
    /// <param name="repeats">The number of repetitions for each element.</param>
    /// <param name="axis">The axis along which to repeat values. The negative numbers are interpreted counting from the backward. By default, use the flattened input array, and return a flat output array.</param>
    new(data : Symbol,
        repeats : int,
        [<Optional>] ?axis : int) = 
        let operatorArguments = 
            [
                "data", Input data
                "repeats", Parameter(Some(box repeats))
                "axis", axis |> Option.map box |> Parameter
            ]
        new Repeat(Arguments<Symbol>(operatorArguments))
    /// <summary>Repeats elements of an array.
    /// 
    /// By default, ``repeat`` flattens the input array into 1-D and then repeats the
    /// elements::
    /// 
    ///   x = [[ 1, 2],
    ///        [ 3, 4]]
    /// 
    ///   repeat(x, repeats=2) = [ 1.,  1.,  2.,  2.,  3.,  3.,  4.,  4.]
    /// 
    /// The parameter ``axis`` specifies the axis along which to perform repeat::
    /// 
    ///   repeat(x, repeats=2, axis=1) = [[ 1.,  1.,  2.,  2.],
    ///                                   [ 3.,  3.,  4.,  4.]]
    /// 
    ///   repeat(x, repeats=2, axis=0) = [[ 1.,  2.],
    ///                                   [ 1.,  2.],
    ///                                   [ 3.,  4.],
    ///                                   [ 3.,  4.]]
    /// 
    ///   repeat(x, repeats=2, axis=-1) = [[ 1.,  1.,  2.,  2.],
    ///                                    [ 3.,  3.,  4.,  4.]]
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\matrix_op.cc:L810</summary>
    /// <param name="repeats">The number of repetitions for each element.</param>
    /// <param name="data">Input data array</param>
    /// <param name="axis">The axis along which to repeat values. The negative numbers are interpreted counting from the backward. By default, use the flattened input array, and return a flat output array.</param>
    new(repeats : int,
        [<Optional>] ?data : Symbol,
        [<Optional>] ?axis : int) = 
        let data = defaultArg data (new ImplicitVariable() :> Symbol)
        let operatorArguments = 
            [
                "data", Input data
                "repeats", Parameter(Some(box repeats))
                "axis", axis |> Option.map box |> Parameter
            ]
        new Repeat(Arguments<Symbol>(operatorArguments))
    /// Default value for Axis
    /// The axis along which to repeat values. The negative numbers are interpreted counting from the backward. By default, use the flattened input array, and return a flat output array.
    static member AxisDefault : int option = None
    /// Input data array
    member __.Data = operatorArguments.GetInput "data"
    /// The number of repetitions for each element.
    member __.Repeats : int = match operatorArguments.GetParameter "repeats" with Some(v) -> unbox v | None -> failwithf "Required parameter repeats is missing"
    /// The axis along which to repeat values. The negative numbers are interpreted counting from the backward. By default, use the flattened input array, and return a flat output array.
    member __.Axis = operatorArguments.GetParameter("axis", Repeat.AxisDefault)
    /// <summary>Copy Repeat instance with updated inputs/parameters.</summary>
    /// <param name="data">Input data array</param>
    /// <param name="repeats">The number of repetitions for each element.</param>
    /// <param name="axis">The axis along which to repeat values. The negative numbers are interpreted counting from the backward. By default, use the flattened input array, and return a flat output array.</param>
    member this.With([<Optional>] ?data : Symbol,
        [<Optional>] ?repeats : int,
        [<Optional>] ?axis : int) = 
        let operatorArguments = 
            [
                data |> Option.map (fun x -> "data", Input x)
                repeats |> Option.map (fun x -> "repeats", Parameter(Some (box x)))
                axis |> Option.map (fun x -> "axis", Parameter(Some (box x)))
            ] |> List.choose id
        new Repeat(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type Tile private (operatorArguments) = 
    inherit SymbolOperator("tile", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new Tile(args)
    override this.WithArguments(args : Arguments<Symbol>) = new Tile(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <summary>Repeats the whole array multiple times.
    /// 
    /// If ``reps`` has length *d*, and input array has dimension of *n*. There are
    /// three cases:
    /// 
    /// - **n=d**. Repeat *i*-th dimension of the input by ``reps[i]`` times::
    /// 
    ///     x = [[1, 2],
    ///          [3, 4]]
    /// 
    ///     tile(x, reps=(2,3)) = [[ 1.,  2.,  1.,  2.,  1.,  2.],
    ///                            [ 3.,  4.,  3.,  4.,  3.,  4.],
    ///                            [ 1.,  2.,  1.,  2.,  1.,  2.],
    ///                            [ 3.,  4.,  3.,  4.,  3.,  4.]]
    /// 
    /// - **n&gt;d**. ``reps`` is promoted to length *n* by pre-pending 1&#39;s to it. Thus for
    ///   an input shape ``(2,3)``, ``repos=(2,)`` is treated as ``(1,2)``::
    /// 
    /// 
    ///     tile(x, reps=(2,)) = [[ 1.,  2.,  1.,  2.],
    ///                           [ 3.,  4.,  3.,  4.]]
    /// 
    /// - **n&lt;d**. The input is promoted to be d-dimensional by prepending new axes. So a
    ///   shape ``(2,2)`` array is promoted to ``(1,2,2)`` for 3-D replication::
    /// 
    ///     tile(x, reps=(2,2,3)) = [[[ 1.,  2.,  1.,  2.,  1.,  2.],
    ///                               [ 3.,  4.,  3.,  4.,  3.,  4.],
    ///                               [ 1.,  2.,  1.,  2.,  1.,  2.],
    ///                               [ 3.,  4.,  3.,  4.,  3.,  4.]],
    /// 
    ///                              [[ 1.,  2.,  1.,  2.,  1.,  2.],
    ///                               [ 3.,  4.,  3.,  4.,  3.,  4.],
    ///                               [ 1.,  2.,  1.,  2.,  1.,  2.],
    ///                               [ 3.,  4.,  3.,  4.,  3.,  4.]]]
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\matrix_op.cc:L872</summary>
    /// <param name="data">Input data array</param>
    /// <param name="reps">The number of times for repeating the tensor a. Each dim size of reps must be a positive integer. If reps has length d, the result will have dimension of max(d, a.ndim); If a.ndim &lt; d, a is promoted to be d-dimensional by prepending new axes. If a.ndim &gt; d, reps is promoted to a.ndim by pre-pending 1&#39;s to it.</param>
    new(data : Symbol,
        reps : int seq) = 
        let operatorArguments = 
            [
                "data", Input data
                "reps", Parameter(Some(box reps))
            ]
        new Tile(Arguments<Symbol>(operatorArguments))
    /// <summary>Repeats the whole array multiple times.
    /// 
    /// If ``reps`` has length *d*, and input array has dimension of *n*. There are
    /// three cases:
    /// 
    /// - **n=d**. Repeat *i*-th dimension of the input by ``reps[i]`` times::
    /// 
    ///     x = [[1, 2],
    ///          [3, 4]]
    /// 
    ///     tile(x, reps=(2,3)) = [[ 1.,  2.,  1.,  2.,  1.,  2.],
    ///                            [ 3.,  4.,  3.,  4.,  3.,  4.],
    ///                            [ 1.,  2.,  1.,  2.,  1.,  2.],
    ///                            [ 3.,  4.,  3.,  4.,  3.,  4.]]
    /// 
    /// - **n&gt;d**. ``reps`` is promoted to length *n* by pre-pending 1&#39;s to it. Thus for
    ///   an input shape ``(2,3)``, ``repos=(2,)`` is treated as ``(1,2)``::
    /// 
    /// 
    ///     tile(x, reps=(2,)) = [[ 1.,  2.,  1.,  2.],
    ///                           [ 3.,  4.,  3.,  4.]]
    /// 
    /// - **n&lt;d**. The input is promoted to be d-dimensional by prepending new axes. So a
    ///   shape ``(2,2)`` array is promoted to ``(1,2,2)`` for 3-D replication::
    /// 
    ///     tile(x, reps=(2,2,3)) = [[[ 1.,  2.,  1.,  2.,  1.,  2.],
    ///                               [ 3.,  4.,  3.,  4.,  3.,  4.],
    ///                               [ 1.,  2.,  1.,  2.,  1.,  2.],
    ///                               [ 3.,  4.,  3.,  4.,  3.,  4.]],
    /// 
    ///                              [[ 1.,  2.,  1.,  2.,  1.,  2.],
    ///                               [ 3.,  4.,  3.,  4.,  3.,  4.],
    ///                               [ 1.,  2.,  1.,  2.,  1.,  2.],
    ///                               [ 3.,  4.,  3.,  4.,  3.,  4.]]]
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\matrix_op.cc:L872</summary>
    /// <param name="reps">The number of times for repeating the tensor a. Each dim size of reps must be a positive integer. If reps has length d, the result will have dimension of max(d, a.ndim); If a.ndim &lt; d, a is promoted to be d-dimensional by prepending new axes. If a.ndim &gt; d, reps is promoted to a.ndim by pre-pending 1&#39;s to it.</param>
    /// <param name="data">Input data array</param>
    new(reps : int seq,
        [<Optional>] ?data : Symbol) = 
        let data = defaultArg data (new ImplicitVariable() :> Symbol)
        let operatorArguments = 
            [
                "data", Input data
                "reps", Parameter(Some(box reps))
            ]
        new Tile(Arguments<Symbol>(operatorArguments))
    /// Input data array
    member __.Data = operatorArguments.GetInput "data"
    /// The number of times for repeating the tensor a. Each dim size of reps must be a positive integer. If reps has length d, the result will have dimension of max(d, a.ndim); If a.ndim &lt; d, a is promoted to be d-dimensional by prepending new axes. If a.ndim &gt; d, reps is promoted to a.ndim by pre-pending 1&#39;s to it.
    member __.Reps : int seq = match operatorArguments.GetParameter "reps" with Some(v) -> unbox v | None -> failwithf "Required parameter reps is missing"
    /// <summary>Copy Tile instance with updated inputs/parameters.</summary>
    /// <param name="data">Input data array</param>
    /// <param name="reps">The number of times for repeating the tensor a. Each dim size of reps must be a positive integer. If reps has length d, the result will have dimension of max(d, a.ndim); If a.ndim &lt; d, a is promoted to be d-dimensional by prepending new axes. If a.ndim &gt; d, reps is promoted to a.ndim by pre-pending 1&#39;s to it.</param>
    member this.With([<Optional>] ?data : Symbol,
        [<Optional>] ?reps : int seq) = 
        let operatorArguments = 
            [
                data |> Option.map (fun x -> "data", Input x)
                reps |> Option.map (fun x -> "reps", Parameter(Some (box x)))
            ] |> List.choose id
        new Tile(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type Reverse private (operatorArguments) = 
    inherit SymbolOperator("reverse", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new Reverse(args)
    override this.WithArguments(args : Arguments<Symbol>) = new Reverse(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <summary>Reverses the order of elements along given axis while preserving array shape.
    /// 
    /// Note: reverse and flip are equivalent. We use reverse in the following examples.
    /// 
    /// Examples::
    /// 
    ///   x = [[ 0.,  1.,  2.,  3.,  4.],
    ///        [ 5.,  6.,  7.,  8.,  9.]]
    /// 
    ///   reverse(x, axis=0) = [[ 5.,  6.,  7.,  8.,  9.],
    ///                         [ 0.,  1.,  2.,  3.,  4.]]
    /// 
    ///   reverse(x, axis=1) = [[ 4.,  3.,  2.,  1.,  0.],
    ///                         [ 9.,  8.,  7.,  6.,  5.]]
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\matrix_op.cc:L913</summary>
    /// <param name="data">Input data array</param>
    /// <param name="axis">The axis which to reverse elements.</param>
    new(data : Symbol,
        axis : int seq) = 
        let operatorArguments = 
            [
                "data", Input data
                "axis", Parameter(Some(box axis))
            ]
        new Reverse(Arguments<Symbol>(operatorArguments))
    /// <summary>Reverses the order of elements along given axis while preserving array shape.
    /// 
    /// Note: reverse and flip are equivalent. We use reverse in the following examples.
    /// 
    /// Examples::
    /// 
    ///   x = [[ 0.,  1.,  2.,  3.,  4.],
    ///        [ 5.,  6.,  7.,  8.,  9.]]
    /// 
    ///   reverse(x, axis=0) = [[ 5.,  6.,  7.,  8.,  9.],
    ///                         [ 0.,  1.,  2.,  3.,  4.]]
    /// 
    ///   reverse(x, axis=1) = [[ 4.,  3.,  2.,  1.,  0.],
    ///                         [ 9.,  8.,  7.,  6.,  5.]]
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\matrix_op.cc:L913</summary>
    /// <param name="axis">The axis which to reverse elements.</param>
    /// <param name="data">Input data array</param>
    new(axis : int seq,
        [<Optional>] ?data : Symbol) = 
        let data = defaultArg data (new ImplicitVariable() :> Symbol)
        let operatorArguments = 
            [
                "data", Input data
                "axis", Parameter(Some(box axis))
            ]
        new Reverse(Arguments<Symbol>(operatorArguments))
    /// Input data array
    member __.Data = operatorArguments.GetInput "data"
    /// The axis which to reverse elements.
    member __.Axis : int seq = match operatorArguments.GetParameter "axis" with Some(v) -> unbox v | None -> failwithf "Required parameter axis is missing"
    /// <summary>Copy Reverse instance with updated inputs/parameters.</summary>
    /// <param name="data">Input data array</param>
    /// <param name="axis">The axis which to reverse elements.</param>
    member this.With([<Optional>] ?data : Symbol,
        [<Optional>] ?axis : int seq) = 
        let operatorArguments = 
            [
                data |> Option.map (fun x -> "data", Input x)
                axis |> Option.map (fun x -> "axis", Parameter(Some (box x)))
            ] |> List.choose id
        new Reverse(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type Stack private (operatorArguments) = 
    inherit SymbolOperator("stack", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new Stack(args)
    override this.WithArguments(args : Arguments<Symbol>) = new Stack(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <summary>Join a sequence of arrays along a new axis.
    /// 
    /// The axis parameter specifies the index of the new axis in the dimensions of the
    /// result. For example, if axis=0 it will be the first dimension and if axis=-1 it
    /// will be the last dimension.
    /// 
    /// Examples::
    /// 
    ///   x = [1, 2]
    ///   y = [3, 4]
    /// 
    ///   stack(x, y) = [[1, 2],
    ///                  [3, 4]]
    ///   stack(x, y, axis=1) = [[1, 3],
    ///                          [2, 4]]
    /// </summary>
    /// <param name="data">List of arrays to stack</param>
    /// <param name="axis">The axis in the result array along which the input arrays are stacked.</param>
    new([<Optional>] ?data : Symbol seq,
        [<Optional>] ?axis : int) = 
        let data = defaultArg (data |> Option.map Seq.toArray) Array.empty
        let operatorArguments = 
            [
                "data", VarArg("num_args", data)
                "axis", axis |> Option.map box |> Parameter
            ]
        new Stack(Arguments<Symbol>(operatorArguments))
    /// Default value for Axis
    /// The axis in the result array along which the input arrays are stacked.
    static member AxisDefault : int = 0
    /// List of arrays to stack
    member __.Data = operatorArguments.GetVarArg "data"
    /// The axis in the result array along which the input arrays are stacked.
    member __.Axis = operatorArguments.GetParameter("axis", Stack.AxisDefault)
    /// <summary>Copy Stack instance with updated inputs/parameters.</summary>
    /// <param name="data">List of arrays to stack</param>
    /// <param name="axis">The axis in the result array along which the input arrays are stacked.</param>
    member this.With([<Optional>] ?data : Symbol seq,
        [<Optional>] ?axis : int) = 
        let operatorArguments = 
            [
                data |> Option.map (fun x -> "data", VarArg("num_args", Seq.toArray x))
                axis |> Option.map (fun x -> "axis", Parameter(Some (box x)))
            ] |> List.choose id
        new Stack(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type Squeeze private (operatorArguments) = 
    inherit SymbolOperator("squeeze", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new Squeeze(args)
    override this.WithArguments(args : Arguments<Symbol>) = new Squeeze(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <summary>Remove single-dimensional entries from the shape of an array.
    /// Same behavior of defining the output tensor shape as numpy.squeeze for the most of cases.
    /// See the following note for exception.
    /// 
    /// Examples::
    /// 
    ///   data = [[[0], [1], [2]]]
    ///   squeeze(data) = [0, 1, 2]
    ///   squeeze(data, axis=0) = [[0], [1], [2]]
    ///   squeeze(data, axis=2) = [[0, 1, 2]]
    ///   squeeze(data, axis=(0, 2)) = [0, 1, 2]
    /// 
    /// .. Note::
    ///   The output of this operator will keep at least one dimension not removed. For example,
    ///   squeeze([[[4]]]) = [4], while in numpy.squeeze, the output will become a scalar.
    /// </summary>
    /// <param name="data">data to squeeze</param>
    /// <param name="axis">Selects a subset of the single-dimensional entries in the shape. If an axis is selected with shape entry greater than one, an error is raised.</param>
    new([<Optional>] ?data : Symbol seq,
        [<Optional>] ?axis : int seq) = 
        let data = defaultArg (data |> Option.map Seq.toArray) Array.empty
        let operatorArguments = 
            [
                "data", VarArg("", data)
                "axis", axis |> Option.map box |> Parameter
            ]
        new Squeeze(Arguments<Symbol>(operatorArguments))
    /// Default value for Axis
    /// Selects a subset of the single-dimensional entries in the shape. If an axis is selected with shape entry greater than one, an error is raised.
    static member AxisDefault : int [] option = None
    /// data to squeeze
    member __.Data = operatorArguments.GetVarArg "data"
    /// Selects a subset of the single-dimensional entries in the shape. If an axis is selected with shape entry greater than one, an error is raised.
    member __.Axis = operatorArguments.GetParameter("axis", Squeeze.AxisDefault)
    /// <summary>Copy Squeeze instance with updated inputs/parameters.</summary>
    /// <param name="data">data to squeeze</param>
    /// <param name="axis">Selects a subset of the single-dimensional entries in the shape. If an axis is selected with shape entry greater than one, an error is raised.</param>
    member this.With([<Optional>] ?data : Symbol seq,
        [<Optional>] ?axis : int seq) = 
        let operatorArguments = 
            [
                data |> Option.map (fun x -> "data", VarArg("", Seq.toArray x))
                axis |> Option.map (fun x -> "axis", Parameter(Some (box x)))
            ] |> List.choose id
        new Squeeze(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type DepthToSpace private (operatorArguments) = 
    inherit SymbolOperator("depth_to_space", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new DepthToSpace(args)
    override this.WithArguments(args : Arguments<Symbol>) = new DepthToSpace(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <summary>Rearranges(permutes) data from depth into blocks of spatial data.
    /// Similar to ONNX DepthToSpace operator:
    /// https://github.com/onnx/onnx/blob/master/docs/Operators.md#DepthToSpace.
    /// The output is a new tensor where the values from depth dimension are moved in spatial blocks 
    /// to height and width dimension. The reverse of this operation is ``space_to_depth``.
    /// 
    /// .. math::
    /// 
    ///     \begin{gather*}
    ///     x \prime = reshape(x, [N, block\_size, block\_size, C / (block\_size ^ 2), H * block\_size, W * block\_size]) \\
    ///     x \prime \prime = transpose(x \prime, [0, 3, 4, 1, 5, 2]) \\
    ///     y = reshape(x \prime \prime, [N, C / (block\_size ^ 2), H * block\_size, W * block\_size])
    ///     \end{gather*}
    /// 
    /// where :math:`x` is an input tensor with default layout as :math:`[N, C, H, W]`: [batch, channels, height, width] 
    /// and :math:`y` is the output tensor of layout :math:`[N, C / (block\_size ^ 2), H * block\_size, W * block\_size]`
    /// 
    /// Example::
    /// 
    ///   x = [[[[0, 1, 2],
    ///          [3, 4, 5]],
    ///         [[6, 7, 8],
    ///          [9, 10, 11]],
    ///         [[12, 13, 14],
    ///          [15, 16, 17]],
    ///         [[18, 19, 20],
    ///          [21, 22, 23]]]]
    /// 
    ///   depth_to_space(x, 2) = [[[[0, 6, 1, 7, 2, 8],
    ///                             [12, 18, 13, 19, 14, 20],
    ///                             [3, 9, 4, 10, 5, 11],
    ///                             [15, 21, 16, 22, 17, 23]]]]
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\matrix_op.cc:L1065</summary>
    /// <param name="data">Input ndarray</param>
    /// <param name="blockSize">Blocks of [block_size. block_size] are moved</param>
    new(data : Symbol,
        blockSize : int) = 
        let operatorArguments = 
            [
                "data", Input data
                "block_size", Parameter(Some(box blockSize))
            ]
        new DepthToSpace(Arguments<Symbol>(operatorArguments))
    /// <summary>Rearranges(permutes) data from depth into blocks of spatial data.
    /// Similar to ONNX DepthToSpace operator:
    /// https://github.com/onnx/onnx/blob/master/docs/Operators.md#DepthToSpace.
    /// The output is a new tensor where the values from depth dimension are moved in spatial blocks 
    /// to height and width dimension. The reverse of this operation is ``space_to_depth``.
    /// 
    /// .. math::
    /// 
    ///     \begin{gather*}
    ///     x \prime = reshape(x, [N, block\_size, block\_size, C / (block\_size ^ 2), H * block\_size, W * block\_size]) \\
    ///     x \prime \prime = transpose(x \prime, [0, 3, 4, 1, 5, 2]) \\
    ///     y = reshape(x \prime \prime, [N, C / (block\_size ^ 2), H * block\_size, W * block\_size])
    ///     \end{gather*}
    /// 
    /// where :math:`x` is an input tensor with default layout as :math:`[N, C, H, W]`: [batch, channels, height, width] 
    /// and :math:`y` is the output tensor of layout :math:`[N, C / (block\_size ^ 2), H * block\_size, W * block\_size]`
    /// 
    /// Example::
    /// 
    ///   x = [[[[0, 1, 2],
    ///          [3, 4, 5]],
    ///         [[6, 7, 8],
    ///          [9, 10, 11]],
    ///         [[12, 13, 14],
    ///          [15, 16, 17]],
    ///         [[18, 19, 20],
    ///          [21, 22, 23]]]]
    /// 
    ///   depth_to_space(x, 2) = [[[[0, 6, 1, 7, 2, 8],
    ///                             [12, 18, 13, 19, 14, 20],
    ///                             [3, 9, 4, 10, 5, 11],
    ///                             [15, 21, 16, 22, 17, 23]]]]
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\matrix_op.cc:L1065</summary>
    /// <param name="blockSize">Blocks of [block_size. block_size] are moved</param>
    /// <param name="data">Input ndarray</param>
    new(blockSize : int,
        [<Optional>] ?data : Symbol) = 
        let data = defaultArg data (new ImplicitVariable() :> Symbol)
        let operatorArguments = 
            [
                "data", Input data
                "block_size", Parameter(Some(box blockSize))
            ]
        new DepthToSpace(Arguments<Symbol>(operatorArguments))
    /// Input ndarray
    member __.Data = operatorArguments.GetInput "data"
    /// Blocks of [block_size. block_size] are moved
    member __.BlockSize : int = match operatorArguments.GetParameter "block_size" with Some(v) -> unbox v | None -> failwithf "Required parameter block_size is missing"
    /// <summary>Copy DepthToSpace instance with updated inputs/parameters.</summary>
    /// <param name="data">Input ndarray</param>
    /// <param name="blockSize">Blocks of [block_size. block_size] are moved</param>
    member this.With([<Optional>] ?data : Symbol,
        [<Optional>] ?blockSize : int) = 
        let operatorArguments = 
            [
                data |> Option.map (fun x -> "data", Input x)
                blockSize |> Option.map (fun x -> "block_size", Parameter(Some (box x)))
            ] |> List.choose id
        new DepthToSpace(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type SpaceToDepth private (operatorArguments) = 
    inherit SymbolOperator("space_to_depth", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new SpaceToDepth(args)
    override this.WithArguments(args : Arguments<Symbol>) = new SpaceToDepth(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <summary>Rearranges(permutes) blocks of spatial data into depth.
    /// Similar to ONNX SpaceToDepth operator:
    /// https://github.com/onnx/onnx/blob/master/docs/Operators.md#SpaceToDepth 
    /// 
    /// The output is a new tensor where the values from height and width dimension are 
    /// moved to the depth dimension. The reverse of this operation is ``depth_to_space``.
    /// 
    /// .. math::
    /// 
    ///     \begin{gather*}
    ///     x \prime = reshape(x, [N, C, H / block\_size, block\_size, W / block\_size, block\_size]) \\
    ///     x \prime \prime = transpose(x \prime, [0, 3, 5, 1, 2, 4]) \\
    ///     y = reshape(x \prime \prime, [N, C * (block\_size ^ 2), H / block\_size, W / block\_size])
    ///     \end{gather*}
    /// 
    /// where :math:`x` is an input tensor with default layout as :math:`[N, C, H, W]`: [batch, channels, height, width] 
    /// and :math:`y` is the output tensor of layout :math:`[N, C * (block\_size ^ 2), H / block\_size, W / block\_size]`
    /// 
    /// Example::
    /// 
    ///   x = [[[[0, 6, 1, 7, 2, 8],
    ///          [12, 18, 13, 19, 14, 20],
    ///          [3, 9, 4, 10, 5, 11],
    ///          [15, 21, 16, 22, 17, 23]]]]
    /// 
    /// 
    ///   space_to_depth(x, 2) = [[[[0, 1, 2],
    ///                             [3, 4, 5]],
    ///                            [[6, 7, 8],
    ///                             [9, 10, 11]],
    ///                            [[12, 13, 14],
    ///                             [15, 16, 17]],
    ///                            [[18, 19, 20],
    ///                             [21, 22, 23]]]]
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\matrix_op.cc:L1119</summary>
    /// <param name="data">Input ndarray</param>
    /// <param name="blockSize">Blocks of [block_size. block_size] are moved</param>
    new(data : Symbol,
        blockSize : int) = 
        let operatorArguments = 
            [
                "data", Input data
                "block_size", Parameter(Some(box blockSize))
            ]
        new SpaceToDepth(Arguments<Symbol>(operatorArguments))
    /// <summary>Rearranges(permutes) blocks of spatial data into depth.
    /// Similar to ONNX SpaceToDepth operator:
    /// https://github.com/onnx/onnx/blob/master/docs/Operators.md#SpaceToDepth 
    /// 
    /// The output is a new tensor where the values from height and width dimension are 
    /// moved to the depth dimension. The reverse of this operation is ``depth_to_space``.
    /// 
    /// .. math::
    /// 
    ///     \begin{gather*}
    ///     x \prime = reshape(x, [N, C, H / block\_size, block\_size, W / block\_size, block\_size]) \\
    ///     x \prime \prime = transpose(x \prime, [0, 3, 5, 1, 2, 4]) \\
    ///     y = reshape(x \prime \prime, [N, C * (block\_size ^ 2), H / block\_size, W / block\_size])
    ///     \end{gather*}
    /// 
    /// where :math:`x` is an input tensor with default layout as :math:`[N, C, H, W]`: [batch, channels, height, width] 
    /// and :math:`y` is the output tensor of layout :math:`[N, C * (block\_size ^ 2), H / block\_size, W / block\_size]`
    /// 
    /// Example::
    /// 
    ///   x = [[[[0, 6, 1, 7, 2, 8],
    ///          [12, 18, 13, 19, 14, 20],
    ///          [3, 9, 4, 10, 5, 11],
    ///          [15, 21, 16, 22, 17, 23]]]]
    /// 
    /// 
    ///   space_to_depth(x, 2) = [[[[0, 1, 2],
    ///                             [3, 4, 5]],
    ///                            [[6, 7, 8],
    ///                             [9, 10, 11]],
    ///                            [[12, 13, 14],
    ///                             [15, 16, 17]],
    ///                            [[18, 19, 20],
    ///                             [21, 22, 23]]]]
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\matrix_op.cc:L1119</summary>
    /// <param name="blockSize">Blocks of [block_size. block_size] are moved</param>
    /// <param name="data">Input ndarray</param>
    new(blockSize : int,
        [<Optional>] ?data : Symbol) = 
        let data = defaultArg data (new ImplicitVariable() :> Symbol)
        let operatorArguments = 
            [
                "data", Input data
                "block_size", Parameter(Some(box blockSize))
            ]
        new SpaceToDepth(Arguments<Symbol>(operatorArguments))
    /// Input ndarray
    member __.Data = operatorArguments.GetInput "data"
    /// Blocks of [block_size. block_size] are moved
    member __.BlockSize : int = match operatorArguments.GetParameter "block_size" with Some(v) -> unbox v | None -> failwithf "Required parameter block_size is missing"
    /// <summary>Copy SpaceToDepth instance with updated inputs/parameters.</summary>
    /// <param name="data">Input ndarray</param>
    /// <param name="blockSize">Blocks of [block_size. block_size] are moved</param>
    member this.With([<Optional>] ?data : Symbol,
        [<Optional>] ?blockSize : int) = 
        let operatorArguments = 
            [
                data |> Option.map (fun x -> "data", Input x)
                blockSize |> Option.map (fun x -> "block_size", Parameter(Some (box x)))
            ] |> List.choose id
        new SpaceToDepth(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type SplitV2 private (operatorArguments) = 
    inherit SymbolOperator("_split_v2", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new SplitV2(args)
    override this.WithArguments(args : Arguments<Symbol>) = new SplitV2(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <summary>Splits an array along a particular axis into multiple sub-arrays.
    /// 
    /// Example::
    /// 
    ///    x  = [[[ 1.]
    ///           [ 2.]]
    ///          [[ 3.]
    ///           [ 4.]]
    ///          [[ 5.]
    ///           [ 6.]]]
    ///    x.shape = (3, 2, 1)
    /// 
    ///    y = split_v2(x, axis=1, indices_or_sections=2) // a list of 2 arrays with shape (3, 1, 1)
    ///    y = [[[ 1.]]
    ///         [[ 3.]]
    ///         [[ 5.]]]
    /// 
    ///        [[[ 2.]]
    ///         [[ 4.]]
    ///         [[ 6.]]]
    /// 
    ///    y[0].shape = (3, 1, 1)
    /// 
    ///    z = split_v2(x, axis=0, indices_or_sections=3) // a list of 3 arrays with shape (1, 2, 1)
    ///    z = [[[ 1.]
    ///          [ 2.]]]
    /// 
    ///        [[[ 3.]
    ///          [ 4.]]]
    /// 
    ///        [[[ 5.]
    ///          [ 6.]]]
    /// 
    ///    z[0].shape = (1, 2, 1)
    /// 
    ///    w = split_v2(x, axis=0, indices_or_sections=(1,)) // a list of 2 arrays with shape [(1, 2, 1), (2, 2, 1)]
    ///    w = [[[ 1.]
    ///          [ 2.]]]
    /// 
    ///        [[[3.]
    ///          [4.]]
    /// 
    ///         [[5.]
    ///          [6.]]]
    /// 
    ///   w[0].shape = (1, 2, 1)
    ///   w[1].shape = (2, 2, 1)
    /// 
    /// `squeeze_axis=True` removes the axis with length 1 from the shapes of the output arrays.
    /// **Note** that setting `squeeze_axis` to ``1`` removes axis with length 1 only
    /// along the `axis` which it is split.
    /// Also `squeeze_axis` can be set to true only if ``input.shape[axis] == indices_or_sections``.
    /// 
    /// Example::
    /// 
    ///    z = split_v2(x, axis=0, indices_or_sections=3, squeeze_axis=1) // a list of 3 arrays with shape (2, 1)
    ///    z = [[ 1.]
    ///         [ 2.]]
    /// 
    ///        [[ 3.]
    ///         [ 4.]]
    /// 
    ///        [[ 5.]
    ///         [ 6.]]
    ///    z[0].shape = (2, 1)
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\matrix_op.cc:L1206</summary>
    /// <param name="data">The input</param>
    /// <param name="indices">Indices of splits. The elements should denote the boundaries of at which split is performed along the `axis`.</param>
    /// <param name="axis">Axis along which to split.</param>
    /// <param name="squeezeAxis">If true, Removes the axis with length 1 from the shapes of the output arrays. **Note** that setting `squeeze_axis` to ``true`` removes axis with length 1 only along the `axis` which it is split. Also `squeeze_axis` can be set to ``true`` only if ``input.shape[axis] == num_outputs``.</param>
    /// <param name="sections">Number of sections if equally splitted. Default to 0 which means split by indices.</param>
    new(data : Symbol,
        indices : int seq,
        [<Optional>] ?axis : int,
        [<Optional>] ?squeezeAxis : bool,
        [<Optional>] ?sections : int) = 
        let operatorArguments = 
            [
                "data", Input data
                "indices", Parameter(Some(box indices))
                "axis", axis |> Option.map box |> Parameter
                "squeeze_axis", squeezeAxis |> Option.map box |> Parameter
                "sections", sections |> Option.map box |> Parameter
            ]
        new SplitV2(Arguments<Symbol>(operatorArguments))
    /// <summary>Splits an array along a particular axis into multiple sub-arrays.
    /// 
    /// Example::
    /// 
    ///    x  = [[[ 1.]
    ///           [ 2.]]
    ///          [[ 3.]
    ///           [ 4.]]
    ///          [[ 5.]
    ///           [ 6.]]]
    ///    x.shape = (3, 2, 1)
    /// 
    ///    y = split_v2(x, axis=1, indices_or_sections=2) // a list of 2 arrays with shape (3, 1, 1)
    ///    y = [[[ 1.]]
    ///         [[ 3.]]
    ///         [[ 5.]]]
    /// 
    ///        [[[ 2.]]
    ///         [[ 4.]]
    ///         [[ 6.]]]
    /// 
    ///    y[0].shape = (3, 1, 1)
    /// 
    ///    z = split_v2(x, axis=0, indices_or_sections=3) // a list of 3 arrays with shape (1, 2, 1)
    ///    z = [[[ 1.]
    ///          [ 2.]]]
    /// 
    ///        [[[ 3.]
    ///          [ 4.]]]
    /// 
    ///        [[[ 5.]
    ///          [ 6.]]]
    /// 
    ///    z[0].shape = (1, 2, 1)
    /// 
    ///    w = split_v2(x, axis=0, indices_or_sections=(1,)) // a list of 2 arrays with shape [(1, 2, 1), (2, 2, 1)]
    ///    w = [[[ 1.]
    ///          [ 2.]]]
    /// 
    ///        [[[3.]
    ///          [4.]]
    /// 
    ///         [[5.]
    ///          [6.]]]
    /// 
    ///   w[0].shape = (1, 2, 1)
    ///   w[1].shape = (2, 2, 1)
    /// 
    /// `squeeze_axis=True` removes the axis with length 1 from the shapes of the output arrays.
    /// **Note** that setting `squeeze_axis` to ``1`` removes axis with length 1 only
    /// along the `axis` which it is split.
    /// Also `squeeze_axis` can be set to true only if ``input.shape[axis] == indices_or_sections``.
    /// 
    /// Example::
    /// 
    ///    z = split_v2(x, axis=0, indices_or_sections=3, squeeze_axis=1) // a list of 3 arrays with shape (2, 1)
    ///    z = [[ 1.]
    ///         [ 2.]]
    /// 
    ///        [[ 3.]
    ///         [ 4.]]
    /// 
    ///        [[ 5.]
    ///         [ 6.]]
    ///    z[0].shape = (2, 1)
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\matrix_op.cc:L1206</summary>
    /// <param name="indices">Indices of splits. The elements should denote the boundaries of at which split is performed along the `axis`.</param>
    /// <param name="data">The input</param>
    /// <param name="axis">Axis along which to split.</param>
    /// <param name="squeezeAxis">If true, Removes the axis with length 1 from the shapes of the output arrays. **Note** that setting `squeeze_axis` to ``true`` removes axis with length 1 only along the `axis` which it is split. Also `squeeze_axis` can be set to ``true`` only if ``input.shape[axis] == num_outputs``.</param>
    /// <param name="sections">Number of sections if equally splitted. Default to 0 which means split by indices.</param>
    new(indices : int seq,
        [<Optional>] ?data : Symbol,
        [<Optional>] ?axis : int,
        [<Optional>] ?squeezeAxis : bool,
        [<Optional>] ?sections : int) = 
        let data = defaultArg data (new ImplicitVariable() :> Symbol)
        let operatorArguments = 
            [
                "data", Input data
                "indices", Parameter(Some(box indices))
                "axis", axis |> Option.map box |> Parameter
                "squeeze_axis", squeezeAxis |> Option.map box |> Parameter
                "sections", sections |> Option.map box |> Parameter
            ]
        new SplitV2(Arguments<Symbol>(operatorArguments))
    /// Default value for Axis
    /// Axis along which to split.
    static member AxisDefault : int = 1
    /// Default value for SqueezeAxis
    /// If true, Removes the axis with length 1 from the shapes of the output arrays. **Note** that setting `squeeze_axis` to ``true`` removes axis with length 1 only along the `axis` which it is split. Also `squeeze_axis` can be set to ``true`` only if ``input.shape[axis] == num_outputs``.
    static member SqueezeAxisDefault : bool = false
    /// Default value for Sections
    /// Number of sections if equally splitted. Default to 0 which means split by indices.
    static member SectionsDefault : int = 0
    /// The input
    member __.Data = operatorArguments.GetInput "data"
    /// Indices of splits. The elements should denote the boundaries of at which split is performed along the `axis`.
    member __.Indices : int seq = match operatorArguments.GetParameter "indices" with Some(v) -> unbox v | None -> failwithf "Required parameter indices is missing"
    /// Axis along which to split.
    member __.Axis = operatorArguments.GetParameter("axis", SplitV2.AxisDefault)
    /// If true, Removes the axis with length 1 from the shapes of the output arrays. **Note** that setting `squeeze_axis` to ``true`` removes axis with length 1 only along the `axis` which it is split. Also `squeeze_axis` can be set to ``true`` only if ``input.shape[axis] == num_outputs``.
    member __.SqueezeAxis = operatorArguments.GetParameter("squeeze_axis", SplitV2.SqueezeAxisDefault)
    /// Number of sections if equally splitted. Default to 0 which means split by indices.
    member __.Sections = operatorArguments.GetParameter("sections", SplitV2.SectionsDefault)
    /// <summary>Copy SplitV2 instance with updated inputs/parameters.</summary>
    /// <param name="data">The input</param>
    /// <param name="indices">Indices of splits. The elements should denote the boundaries of at which split is performed along the `axis`.</param>
    /// <param name="axis">Axis along which to split.</param>
    /// <param name="squeezeAxis">If true, Removes the axis with length 1 from the shapes of the output arrays. **Note** that setting `squeeze_axis` to ``true`` removes axis with length 1 only along the `axis` which it is split. Also `squeeze_axis` can be set to ``true`` only if ``input.shape[axis] == num_outputs``.</param>
    /// <param name="sections">Number of sections if equally splitted. Default to 0 which means split by indices.</param>
    member this.With([<Optional>] ?data : Symbol,
        [<Optional>] ?indices : int seq,
        [<Optional>] ?axis : int,
        [<Optional>] ?squeezeAxis : bool,
        [<Optional>] ?sections : int) = 
        let operatorArguments = 
            [
                data |> Option.map (fun x -> "data", Input x)
                indices |> Option.map (fun x -> "indices", Parameter(Some (box x)))
                axis |> Option.map (fun x -> "axis", Parameter(Some (box x)))
                squeezeAxis |> Option.map (fun x -> "squeeze_axis", Parameter(Some (box x)))
                sections |> Option.map (fun x -> "sections", Parameter(Some (box x)))
            ] |> List.choose id
        new SplitV2(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type SplitV2Backward private (operatorArguments) = 
    inherit SymbolOperator("_split_v2_backward", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new SplitV2Backward(args)
    override this.WithArguments(args : Arguments<Symbol>) = new SplitV2Backward(this.OperatorArguments.AddReplace(args)) :> Symbol
    new() =
        let operatorArguments = 
            [
            ]
        new SplitV2Backward(Arguments<Symbol>(operatorArguments))

type Topk private (operatorArguments) = 
    inherit SymbolOperator("topk", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new Topk(args)
    override this.WithArguments(args : Arguments<Symbol>) = new Topk(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <summary>Returns the top *k* elements in an input array along the given axis.
    ///  The returned elements will be sorted.
    /// 
    /// Examples::
    /// 
    ///   x = [[ 0.3,  0.2,  0.4],
    ///        [ 0.1,  0.3,  0.2]]
    /// 
    ///   // returns an index of the largest element on last axis
    ///   topk(x) = [[ 2.],
    ///              [ 1.]]
    /// 
    ///   // returns the value of top-2 largest elements on last axis
    ///   topk(x, ret_typ=&#39;value&#39;, k=2) = [[ 0.4,  0.3],
    ///                                    [ 0.3,  0.2]]
    /// 
    ///   // returns the value of top-2 smallest elements on last axis
    ///   topk(x, ret_typ=&#39;value&#39;, k=2, is_ascend=1) = [[ 0.2 ,  0.3],
    ///                                                [ 0.1 ,  0.2]]
    /// 
    ///   // returns the value of top-2 largest elements on axis 0
    ///   topk(x, axis=0, ret_typ=&#39;value&#39;, k=2) = [[ 0.3,  0.3,  0.4],
    ///                                            [ 0.1,  0.2,  0.2]]
    /// 
    ///   // flattens and then returns list of both values and indices
    ///   topk(x, ret_typ=&#39;both&#39;, k=2) = [[[ 0.4,  0.3], [ 0.3,  0.2]] ,  [[ 2.,  0.], [ 1.,  2.]]]
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\ordering_op.cc:L65</summary>
    /// <param name="data">The input array</param>
    /// <param name="axis">Axis along which to choose the top k indices. If not given, the flattened array is used. Default is -1.</param>
    /// <param name="k">Number of top elements to select, should be always smaller than or equal to the element number in the given axis. A global sort is performed if set k &lt; 1.</param>
    /// <param name="retTyp">The return type.
    ///  &quot;value&quot; means to return the top k values, &quot;indices&quot; means to return the indices of the top k values, &quot;mask&quot; means to return a mask array containing 0 and 1. 1 means the top k values. &quot;both&quot; means to return a list of both values and indices of top k elements.</param>
    /// <param name="isAscend">Whether to choose k largest or k smallest elements. Top K largest elements will be chosen if set to false.</param>
    /// <param name="dtype">DType of the output indices when ret_typ is &quot;indices&quot; or &quot;both&quot;. An error will be raised if the selected data type cannot precisely represent the indices.</param>
    new([<Optional>] ?data : Symbol,
        [<Optional>] ?axis : int,
        [<Optional>] ?k : int,
        [<Optional>] ?retTyp : RetTyp,
        [<Optional>] ?isAscend : bool,
        [<Optional>] ?dtype : TopkDtype) = 
        let data = defaultArg data (new ImplicitVariable() :> Symbol)
        let operatorArguments = 
            [
                "data", Input data
                "axis", axis |> Option.map box |> Parameter
                "k", k |> Option.map box |> Parameter
                "ret_typ", retTyp |> Option.map box |> Parameter
                "is_ascend", isAscend |> Option.map box |> Parameter
                "dtype", dtype |> Option.map box |> Parameter
            ]
        new Topk(Arguments<Symbol>(operatorArguments))
    /// Default value for Axis
    /// Axis along which to choose the top k indices. If not given, the flattened array is used. Default is -1.
    static member AxisDefault : int option = Some(-1)
    /// Default value for K
    /// Number of top elements to select, should be always smaller than or equal to the element number in the given axis. A global sort is performed if set k &lt; 1.
    static member KDefault : int = 1
    /// Default value for RetTyp
    /// The return type.
    ///  &quot;value&quot; means to return the top k values, &quot;indices&quot; means to return the indices of the top k values, &quot;mask&quot; means to return a mask array containing 0 and 1. 1 means the top k values. &quot;both&quot; means to return a list of both values and indices of top k elements.
    static member RetTypDefault : RetTyp = RetTyp.Indices
    /// Default value for IsAscend
    /// Whether to choose k largest or k smallest elements. Top K largest elements will be chosen if set to false.
    static member IsAscendDefault : bool = false
    /// Default value for Dtype
    /// DType of the output indices when ret_typ is &quot;indices&quot; or &quot;both&quot;. An error will be raised if the selected data type cannot precisely represent the indices.
    static member DtypeDefault : TopkDtype = TopkDtype.Float32
    /// The input array
    member __.Data = operatorArguments.GetInput "data"
    /// Axis along which to choose the top k indices. If not given, the flattened array is used. Default is -1.
    member __.Axis = operatorArguments.GetParameter("axis", Topk.AxisDefault)
    /// Number of top elements to select, should be always smaller than or equal to the element number in the given axis. A global sort is performed if set k &lt; 1.
    member __.K = operatorArguments.GetParameter("k", Topk.KDefault)
    /// The return type.
    ///  &quot;value&quot; means to return the top k values, &quot;indices&quot; means to return the indices of the top k values, &quot;mask&quot; means to return a mask array containing 0 and 1. 1 means the top k values. &quot;both&quot; means to return a list of both values and indices of top k elements.
    member __.RetTyp = operatorArguments.GetParameter("ret_typ", Topk.RetTypDefault)
    /// Whether to choose k largest or k smallest elements. Top K largest elements will be chosen if set to false.
    member __.IsAscend = operatorArguments.GetParameter("is_ascend", Topk.IsAscendDefault)
    /// DType of the output indices when ret_typ is &quot;indices&quot; or &quot;both&quot;. An error will be raised if the selected data type cannot precisely represent the indices.
    member __.Dtype = operatorArguments.GetParameter("dtype", Topk.DtypeDefault)
    /// <summary>Copy Topk instance with updated inputs/parameters.</summary>
    /// <param name="data">The input array</param>
    /// <param name="axis">Axis along which to choose the top k indices. If not given, the flattened array is used. Default is -1.</param>
    /// <param name="k">Number of top elements to select, should be always smaller than or equal to the element number in the given axis. A global sort is performed if set k &lt; 1.</param>
    /// <param name="retTyp">The return type.
    ///  &quot;value&quot; means to return the top k values, &quot;indices&quot; means to return the indices of the top k values, &quot;mask&quot; means to return a mask array containing 0 and 1. 1 means the top k values. &quot;both&quot; means to return a list of both values and indices of top k elements.</param>
    /// <param name="isAscend">Whether to choose k largest or k smallest elements. Top K largest elements will be chosen if set to false.</param>
    /// <param name="dtype">DType of the output indices when ret_typ is &quot;indices&quot; or &quot;both&quot;. An error will be raised if the selected data type cannot precisely represent the indices.</param>
    member this.With([<Optional>] ?data : Symbol,
        [<Optional>] ?axis : int,
        [<Optional>] ?k : int,
        [<Optional>] ?retTyp : RetTyp,
        [<Optional>] ?isAscend : bool,
        [<Optional>] ?dtype : TopkDtype) = 
        let operatorArguments = 
            [
                data |> Option.map (fun x -> "data", Input x)
                axis |> Option.map (fun x -> "axis", Parameter(Some (box x)))
                k |> Option.map (fun x -> "k", Parameter(Some (box x)))
                retTyp |> Option.map (fun x -> "ret_typ", Parameter(Some (box x)))
                isAscend |> Option.map (fun x -> "is_ascend", Parameter(Some (box x)))
                dtype |> Option.map (fun x -> "dtype", Parameter(Some (box x)))
            ] |> List.choose id
        new Topk(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type Sort private (operatorArguments) = 
    inherit SymbolOperator("sort", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new Sort(args)
    override this.WithArguments(args : Arguments<Symbol>) = new Sort(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <summary>Returns a sorted copy of an input array along the given axis.
    /// 
    /// Examples::
    /// 
    ///   x = [[ 1, 4],
    ///        [ 3, 1]]
    /// 
    ///   // sorts along the last axis
    ///   sort(x) = [[ 1.,  4.],
    ///              [ 1.,  3.]]
    /// 
    ///   // flattens and then sorts
    ///   sort(x, axis=None) = [ 1.,  1.,  3.,  4.]
    /// 
    ///   // sorts along the first axis
    ///   sort(x, axis=0) = [[ 1.,  1.],
    ///                      [ 3.,  4.]]
    /// 
    ///   // in a descend order
    ///   sort(x, is_ascend=0) = [[ 4.,  1.],
    ///                           [ 3.,  1.]]
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\ordering_op.cc:L128</summary>
    /// <param name="data">The input array</param>
    /// <param name="axis">Axis along which to choose sort the input tensor. If not given, the flattened array is used. Default is -1.</param>
    /// <param name="isAscend">Whether to sort in ascending or descending order.</param>
    new([<Optional>] ?data : Symbol,
        [<Optional>] ?axis : int,
        [<Optional>] ?isAscend : bool) = 
        let data = defaultArg data (new ImplicitVariable() :> Symbol)
        let operatorArguments = 
            [
                "data", Input data
                "axis", axis |> Option.map box |> Parameter
                "is_ascend", isAscend |> Option.map box |> Parameter
            ]
        new Sort(Arguments<Symbol>(operatorArguments))
    /// Default value for Axis
    /// Axis along which to choose sort the input tensor. If not given, the flattened array is used. Default is -1.
    static member AxisDefault : int option = Some(-1)
    /// Default value for IsAscend
    /// Whether to sort in ascending or descending order.
    static member IsAscendDefault : bool = true
    /// The input array
    member __.Data = operatorArguments.GetInput "data"
    /// Axis along which to choose sort the input tensor. If not given, the flattened array is used. Default is -1.
    member __.Axis = operatorArguments.GetParameter("axis", Sort.AxisDefault)
    /// Whether to sort in ascending or descending order.
    member __.IsAscend = operatorArguments.GetParameter("is_ascend", Sort.IsAscendDefault)
    /// <summary>Copy Sort instance with updated inputs/parameters.</summary>
    /// <param name="data">The input array</param>
    /// <param name="axis">Axis along which to choose sort the input tensor. If not given, the flattened array is used. Default is -1.</param>
    /// <param name="isAscend">Whether to sort in ascending or descending order.</param>
    member this.With([<Optional>] ?data : Symbol,
        [<Optional>] ?axis : int,
        [<Optional>] ?isAscend : bool) = 
        let operatorArguments = 
            [
                data |> Option.map (fun x -> "data", Input x)
                axis |> Option.map (fun x -> "axis", Parameter(Some (box x)))
                isAscend |> Option.map (fun x -> "is_ascend", Parameter(Some (box x)))
            ] |> List.choose id
        new Sort(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type Argsort private (operatorArguments) = 
    inherit SymbolOperator("argsort", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new Argsort(args)
    override this.WithArguments(args : Arguments<Symbol>) = new Argsort(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <summary>Returns the indices that would sort an input array along the given axis.
    /// 
    /// This function performs sorting along the given axis and returns an array of indices having same shape
    /// as an input array that index data in sorted order.
    /// 
    /// Examples::
    /// 
    ///   x = [[ 0.3,  0.2,  0.4],
    ///        [ 0.1,  0.3,  0.2]]
    /// 
    ///   // sort along axis -1
    ///   argsort(x) = [[ 1.,  0.,  2.],
    ///                 [ 0.,  2.,  1.]]
    /// 
    ///   // sort along axis 0
    ///   argsort(x, axis=0) = [[ 1.,  0.,  1.]
    ///                         [ 0.,  1.,  0.]]
    /// 
    ///   // flatten and then sort
    ///   argsort(x, axis=None) = [ 3.,  1.,  5.,  0.,  4.,  2.]
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\ordering_op.cc:L178</summary>
    /// <param name="data">The input array</param>
    /// <param name="axis">Axis along which to sort the input tensor. If not given, the flattened array is used. Default is -1.</param>
    /// <param name="isAscend">Whether to sort in ascending or descending order.</param>
    /// <param name="dtype">DType of the output indices. It is only valid when ret_typ is &quot;indices&quot; or &quot;both&quot;. An error will be raised if the selected data type cannot precisely represent the indices.</param>
    new([<Optional>] ?data : Symbol,
        [<Optional>] ?axis : int,
        [<Optional>] ?isAscend : bool,
        [<Optional>] ?dtype : ArgsortDtype) = 
        let data = defaultArg data (new ImplicitVariable() :> Symbol)
        let operatorArguments = 
            [
                "data", Input data
                "axis", axis |> Option.map box |> Parameter
                "is_ascend", isAscend |> Option.map box |> Parameter
                "dtype", dtype |> Option.map box |> Parameter
            ]
        new Argsort(Arguments<Symbol>(operatorArguments))
    /// Default value for Axis
    /// Axis along which to sort the input tensor. If not given, the flattened array is used. Default is -1.
    static member AxisDefault : int option = Some(-1)
    /// Default value for IsAscend
    /// Whether to sort in ascending or descending order.
    static member IsAscendDefault : bool = true
    /// Default value for Dtype
    /// DType of the output indices. It is only valid when ret_typ is &quot;indices&quot; or &quot;both&quot;. An error will be raised if the selected data type cannot precisely represent the indices.
    static member DtypeDefault : ArgsortDtype = ArgsortDtype.Float32
    /// The input array
    member __.Data = operatorArguments.GetInput "data"
    /// Axis along which to sort the input tensor. If not given, the flattened array is used. Default is -1.
    member __.Axis = operatorArguments.GetParameter("axis", Argsort.AxisDefault)
    /// Whether to sort in ascending or descending order.
    member __.IsAscend = operatorArguments.GetParameter("is_ascend", Argsort.IsAscendDefault)
    /// DType of the output indices. It is only valid when ret_typ is &quot;indices&quot; or &quot;both&quot;. An error will be raised if the selected data type cannot precisely represent the indices.
    member __.Dtype = operatorArguments.GetParameter("dtype", Argsort.DtypeDefault)
    /// <summary>Copy Argsort instance with updated inputs/parameters.</summary>
    /// <param name="data">The input array</param>
    /// <param name="axis">Axis along which to sort the input tensor. If not given, the flattened array is used. Default is -1.</param>
    /// <param name="isAscend">Whether to sort in ascending or descending order.</param>
    /// <param name="dtype">DType of the output indices. It is only valid when ret_typ is &quot;indices&quot; or &quot;both&quot;. An error will be raised if the selected data type cannot precisely represent the indices.</param>
    member this.With([<Optional>] ?data : Symbol,
        [<Optional>] ?axis : int,
        [<Optional>] ?isAscend : bool,
        [<Optional>] ?dtype : ArgsortDtype) = 
        let operatorArguments = 
            [
                data |> Option.map (fun x -> "data", Input x)
                axis |> Option.map (fun x -> "axis", Parameter(Some (box x)))
                isAscend |> Option.map (fun x -> "is_ascend", Parameter(Some (box x)))
                dtype |> Option.map (fun x -> "dtype", Parameter(Some (box x)))
            ] |> List.choose id
        new Argsort(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type RavelMultiIndex private (operatorArguments) = 
    inherit SymbolOperator("_ravel_multi_index", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new RavelMultiIndex(args)
    override this.WithArguments(args : Arguments<Symbol>) = new RavelMultiIndex(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <summary>Converts a batch of index arrays into an array of flat indices. The operator follows numpy conventions so a single multi index is given by a column of the input matrix. The leading dimension may be left unspecified by using -1 as placeholder.  
    /// 
    /// Examples::
    ///    
    ///    A = [[3,6,6],[4,5,1]]
    ///    ravel(A, shape=(7,6)) = [22,41,37]
    ///    ravel(A, shape=(-1,6)) = [22,41,37]
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\ravel.cc:L42</summary>
    /// <param name="data">Batch of multi-indices</param>
    /// <param name="shape">Shape of the array into which the multi-indices apply.</param>
    new([<Optional>] ?data : Symbol,
        [<Optional>] ?shape : int seq) = 
        let data = defaultArg data (new ImplicitVariable() :> Symbol)
        let operatorArguments = 
            [
                "data", Input data
                "shape", shape |> Option.map box |> Parameter
            ]
        new RavelMultiIndex(Arguments<Symbol>(operatorArguments))
    /// Default value for Shape
    /// Shape of the array into which the multi-indices apply.
    static member ShapeDefault : int [] option = None
    /// Batch of multi-indices
    member __.Data = operatorArguments.GetInput "data"
    /// Shape of the array into which the multi-indices apply.
    member __.Shape = operatorArguments.GetParameter("shape", RavelMultiIndex.ShapeDefault)
    /// <summary>Copy RavelMultiIndex instance with updated inputs/parameters.</summary>
    /// <param name="data">Batch of multi-indices</param>
    /// <param name="shape">Shape of the array into which the multi-indices apply.</param>
    member this.With([<Optional>] ?data : Symbol,
        [<Optional>] ?shape : int seq) = 
        let operatorArguments = 
            [
                data |> Option.map (fun x -> "data", Input x)
                shape |> Option.map (fun x -> "shape", Parameter(Some (box x)))
            ] |> List.choose id
        new RavelMultiIndex(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type UnravelIndex private (operatorArguments) = 
    inherit SymbolOperator("_unravel_index", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new UnravelIndex(args)
    override this.WithArguments(args : Arguments<Symbol>) = new UnravelIndex(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <summary>Converts an array of flat indices into a batch of index arrays. The operator follows numpy conventions so a single multi index is given by a column of the output matrix. The leading dimension may be left unspecified by using -1 as placeholder.  
    /// 
    /// Examples::
    /// 
    ///    A = [22,41,37]
    ///    unravel(A, shape=(7,6)) = [[3,6,6],[4,5,1]]
    ///    unravel(A, shape=(-1,6)) = [[3,6,6],[4,5,1]]
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\ravel.cc:L67</summary>
    /// <param name="data">Array of flat indices</param>
    /// <param name="shape">Shape of the array into which the multi-indices apply.</param>
    new([<Optional>] ?data : Symbol,
        [<Optional>] ?shape : int seq) = 
        let data = defaultArg data (new ImplicitVariable() :> Symbol)
        let operatorArguments = 
            [
                "data", Input data
                "shape", shape |> Option.map box |> Parameter
            ]
        new UnravelIndex(Arguments<Symbol>(operatorArguments))
    /// Default value for Shape
    /// Shape of the array into which the multi-indices apply.
    static member ShapeDefault : int [] option = None
    /// Array of flat indices
    member __.Data = operatorArguments.GetInput "data"
    /// Shape of the array into which the multi-indices apply.
    member __.Shape = operatorArguments.GetParameter("shape", UnravelIndex.ShapeDefault)
    /// <summary>Copy UnravelIndex instance with updated inputs/parameters.</summary>
    /// <param name="data">Array of flat indices</param>
    /// <param name="shape">Shape of the array into which the multi-indices apply.</param>
    member this.With([<Optional>] ?data : Symbol,
        [<Optional>] ?shape : int seq) = 
        let operatorArguments = 
            [
                data |> Option.map (fun x -> "data", Input x)
                shape |> Option.map (fun x -> "shape", Parameter(Some (box x)))
            ] |> List.choose id
        new UnravelIndex(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type SparseRetain private (operatorArguments) = 
    inherit SymbolOperator("_sparse_retain", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new SparseRetain(args)
    override this.WithArguments(args : Arguments<Symbol>) = new SparseRetain(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <summary>Pick rows specified by user input index array from a row sparse matrix
    /// and save them in the output sparse matrix.
    /// 
    /// Example::
    /// 
    ///   data = [[1, 2], [3, 4], [5, 6]]
    ///   indices = [0, 1, 3]
    ///   shape = (4, 2)
    ///   rsp_in = row_sparse_array(data, indices)
    ///   to_retain = [0, 3]
    ///   rsp_out = retain(rsp_in, to_retain)
    ///   rsp_out.data = [[1, 2], [5, 6]]
    ///   rsp_out.indices = [0, 3]
    /// 
    /// The storage type of ``retain`` output depends on storage types of inputs
    /// 
    /// - retain(row_sparse, default) = row_sparse
    /// - otherwise, ``retain`` is not supported
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\sparse_retain.cc:L53</summary>
    /// <param name="data">The input array for sparse_retain operator.</param>
    /// <param name="indices">The index array of rows ids that will be retained.</param>
    new([<Optional>] ?data : Symbol,
        [<Optional>] ?indices : Symbol) = 
        let data = defaultArg data (new ImplicitVariable() :> Symbol)
        let indices = defaultArg indices (new ImplicitVariable() :> Symbol)
        let operatorArguments = 
            [
                "data", Input data
                "indices", Input indices
            ]
        new SparseRetain(Arguments<Symbol>(operatorArguments))
    /// The input array for sparse_retain operator.
    member __.Data = operatorArguments.GetInput "data"
    /// The index array of rows ids that will be retained.
    member __.Indices = operatorArguments.GetInput "indices"
    /// <summary>Copy SparseRetain instance with updated inputs/parameters.</summary>
    /// <param name="data">The input array for sparse_retain operator.</param>
    /// <param name="indices">The index array of rows ids that will be retained.</param>
    member this.With([<Optional>] ?data : Symbol,
        [<Optional>] ?indices : Symbol) = 
        let operatorArguments = 
            [
                data |> Option.map (fun x -> "data", Input x)
                indices |> Option.map (fun x -> "indices", Input x)
            ] |> List.choose id
        new SparseRetain(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type SquareSum private (operatorArguments) = 
    inherit SymbolOperator("_square_sum", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new SquareSum(args)
    override this.WithArguments(args : Arguments<Symbol>) = new SquareSum(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <summary>Computes the square sum of array elements over a given axis
    /// for row-sparse matrix. This is a temporary solution for fusing ops square and
    /// sum together for row-sparse matrix to save memory for storing gradients.
    /// It will become deprecated once the functionality of fusing operators is finished
    /// in the future.
    /// 
    /// Example::
    /// 
    ///   dns = mx.nd.array([[0, 0], [1, 2], [0, 0], [3, 4], [0, 0]])
    ///   rsp = dns.tostype(&#39;row_sparse&#39;)
    ///   sum = mx.nd._internal._square_sum(rsp, axis=1)
    ///   sum = [0, 5, 0, 25, 0]
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\square_sum.cc:L63</summary>
    /// <param name="data">The input</param>
    /// <param name="axis">The axis or axes along which to perform the reduction.
    /// 
    ///       The default, `axis=()`, will compute over all elements into a
    ///       scalar array with shape `(1,)`.
    /// 
    ///       If `axis` is int, a reduction is performed on a particular axis.
    /// 
    ///       If `axis` is a tuple of ints, a reduction is performed on all the axes
    ///       specified in the tuple.
    /// 
    ///       If `exclude` is true, reduction will be performed on the axes that are
    ///       NOT in axis instead.
    /// 
    ///       Negative values means indexing from right to left.</param>
    /// <param name="keepdims">If this is set to `True`, the reduced axes are left in the result as dimension with size one.</param>
    /// <param name="exclude">Whether to perform reduction on axis that are NOT in axis instead.</param>
    new([<Optional>] ?data : Symbol,
        [<Optional>] ?axis : int seq,
        [<Optional>] ?keepdims : bool,
        [<Optional>] ?exclude : bool) = 
        let data = defaultArg data (new ImplicitVariable() :> Symbol)
        let operatorArguments = 
            [
                "data", Input data
                "axis", axis |> Option.map box |> Parameter
                "keepdims", keepdims |> Option.map box |> Parameter
                "exclude", exclude |> Option.map box |> Parameter
            ]
        new SquareSum(Arguments<Symbol>(operatorArguments))
    /// Default value for Axis
    /// The axis or axes along which to perform the reduction.
    /// 
    ///       The default, `axis=()`, will compute over all elements into a
    ///       scalar array with shape `(1,)`.
    /// 
    ///       If `axis` is int, a reduction is performed on a particular axis.
    /// 
    ///       If `axis` is a tuple of ints, a reduction is performed on all the axes
    ///       specified in the tuple.
    /// 
    ///       If `exclude` is true, reduction will be performed on the axes that are
    ///       NOT in axis instead.
    /// 
    ///       Negative values means indexing from right to left.
    static member AxisDefault : int [] option = None
    /// Default value for Keepdims
    /// If this is set to `True`, the reduced axes are left in the result as dimension with size one.
    static member KeepdimsDefault : bool = false
    /// Default value for Exclude
    /// Whether to perform reduction on axis that are NOT in axis instead.
    static member ExcludeDefault : bool = false
    /// The input
    member __.Data = operatorArguments.GetInput "data"
    /// The axis or axes along which to perform the reduction.
    /// 
    ///       The default, `axis=()`, will compute over all elements into a
    ///       scalar array with shape `(1,)`.
    /// 
    ///       If `axis` is int, a reduction is performed on a particular axis.
    /// 
    ///       If `axis` is a tuple of ints, a reduction is performed on all the axes
    ///       specified in the tuple.
    /// 
    ///       If `exclude` is true, reduction will be performed on the axes that are
    ///       NOT in axis instead.
    /// 
    ///       Negative values means indexing from right to left.
    member __.Axis = operatorArguments.GetParameter("axis", SquareSum.AxisDefault)
    /// If this is set to `True`, the reduced axes are left in the result as dimension with size one.
    member __.Keepdims = operatorArguments.GetParameter("keepdims", SquareSum.KeepdimsDefault)
    /// Whether to perform reduction on axis that are NOT in axis instead.
    member __.Exclude = operatorArguments.GetParameter("exclude", SquareSum.ExcludeDefault)
    /// <summary>Copy SquareSum instance with updated inputs/parameters.</summary>
    /// <param name="data">The input</param>
    /// <param name="axis">The axis or axes along which to perform the reduction.
    /// 
    ///       The default, `axis=()`, will compute over all elements into a
    ///       scalar array with shape `(1,)`.
    /// 
    ///       If `axis` is int, a reduction is performed on a particular axis.
    /// 
    ///       If `axis` is a tuple of ints, a reduction is performed on all the axes
    ///       specified in the tuple.
    /// 
    ///       If `exclude` is true, reduction will be performed on the axes that are
    ///       NOT in axis instead.
    /// 
    ///       Negative values means indexing from right to left.</param>
    /// <param name="keepdims">If this is set to `True`, the reduced axes are left in the result as dimension with size one.</param>
    /// <param name="exclude">Whether to perform reduction on axis that are NOT in axis instead.</param>
    member this.With([<Optional>] ?data : Symbol,
        [<Optional>] ?axis : int seq,
        [<Optional>] ?keepdims : bool,
        [<Optional>] ?exclude : bool) = 
        let operatorArguments = 
            [
                data |> Option.map (fun x -> "data", Input x)
                axis |> Option.map (fun x -> "axis", Parameter(Some (box x)))
                keepdims |> Option.map (fun x -> "keepdims", Parameter(Some (box x)))
                exclude |> Option.map (fun x -> "exclude", Parameter(Some (box x)))
            ] |> List.choose id
        new SquareSum(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type BilinearSampler private (operatorArguments) = 
    inherit SymbolOperator("BilinearSampler", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new BilinearSampler(args)
    override this.WithArguments(args : Arguments<Symbol>) = new BilinearSampler(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <summary>Applies bilinear sampling to input feature map.
    /// 
    /// Bilinear Sampling is the key of  [NIPS2015] \&quot;Spatial Transformer Networks\&quot;. The usage of the operator is very similar to remap function in OpenCV,
    /// except that the operator has the backward pass.
    /// 
    /// Given :math:`data` and :math:`grid`, then the output is computed by
    /// 
    /// .. math::
    ///   x_{src} = grid[batch, 0, y_{dst}, x_{dst}] \\
    ///   y_{src} = grid[batch, 1, y_{dst}, x_{dst}] \\
    ///   output[batch, channel, y_{dst}, x_{dst}] = G(data[batch, channel, y_{src}, x_{src})
    /// 
    /// :math:`x_{dst}`, :math:`y_{dst}` enumerate all spatial locations in :math:`output`, and :math:`G()` denotes the bilinear interpolation kernel.
    /// The out-boundary points will be padded with zeros.The shape of the output will be (data.shape[0], data.shape[1], grid.shape[2], grid.shape[3]).
    /// 
    /// The operator assumes that :math:`data` has &#39;NCHW&#39; layout and :math:`grid` has been normalized to [-1, 1].
    /// 
    /// BilinearSampler often cooperates with GridGenerator which generates sampling grids for BilinearSampler.
    /// GridGenerator supports two kinds of transformation: ``affine`` and ``warp``.
    /// If users want to design a CustomOp to manipulate :math:`grid`, please firstly refer to the code of GridGenerator.
    /// 
    /// Example 1::
    /// 
    ///   ## Zoom out data two times
    ///   data = array([[[[1, 4, 3, 6],
    ///                   [1, 8, 8, 9],
    ///                   [0, 4, 1, 5],
    ///                   [1, 0, 1, 3]]]])
    /// 
    ///   affine_matrix = array([[2, 0, 0],
    ///                          [0, 2, 0]])
    /// 
    ///   affine_matrix = reshape(affine_matrix, shape=(1, 6))
    /// 
    ///   grid = GridGenerator(data=affine_matrix, transform_type=&#39;affine&#39;, target_shape=(4, 4))
    /// 
    ///   out = BilinearSampler(data, grid)
    /// 
    ///   out
    ///   [[[[ 0,   0,     0,   0],
    ///      [ 0,   3.5,   6.5, 0],
    ///      [ 0,   1.25,  2.5, 0],
    ///      [ 0,   0,     0,   0]]]
    /// 
    /// 
    /// Example 2::
    /// 
    ///   ## shift data horizontally by -1 pixel
    /// 
    ///   data = array([[[[1, 4, 3, 6],
    ///                   [1, 8, 8, 9],
    ///                   [0, 4, 1, 5],
    ///                   [1, 0, 1, 3]]]])
    /// 
    ///   warp_maxtrix = array([[[[1, 1, 1, 1],
    ///                           [1, 1, 1, 1],
    ///                           [1, 1, 1, 1],
    ///                           [1, 1, 1, 1]],
    ///                          [[0, 0, 0, 0],
    ///                           [0, 0, 0, 0],
    ///                           [0, 0, 0, 0],
    ///                           [0, 0, 0, 0]]]])
    /// 
    ///   grid = GridGenerator(data=warp_matrix, transform_type=&#39;warp&#39;)
    ///   out = BilinearSampler(data, grid)
    /// 
    ///   out
    ///   [[[[ 4,  3,  6,  0],
    ///      [ 8,  8,  9,  0],
    ///      [ 4,  1,  5,  0],
    ///      [ 0,  1,  3,  0]]]
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\bilinear_sampler.cc:L256</summary>
    /// <param name="data">Input data to the BilinearsamplerOp.</param>
    /// <param name="grid">Input grid to the BilinearsamplerOp.grid has two channels: x_src, y_src</param>
    /// <param name="cudnnOff">whether to turn cudnn off</param>
    new([<Optional>] ?data : Symbol,
        [<Optional>] ?grid : Symbol,
        [<Optional>] ?cudnnOff : bool) = 
        let data = defaultArg data (new ImplicitVariable() :> Symbol)
        let grid = defaultArg grid (new ImplicitVariable() :> Symbol)
        let operatorArguments = 
            [
                "data", Input data
                "grid", Input grid
                "cudnn_off", cudnnOff |> Option.map box |> Parameter
            ]
        new BilinearSampler(Arguments<Symbol>(operatorArguments))
    /// Default value for CudnnOff
    /// whether to turn cudnn off
    static member CudnnOffDefault : bool option = None
    /// Input data to the BilinearsamplerOp.
    member __.Data = operatorArguments.GetInput "data"
    /// Input grid to the BilinearsamplerOp.grid has two channels: x_src, y_src
    member __.Grid = operatorArguments.GetInput "grid"
    /// whether to turn cudnn off
    member __.CudnnOff = operatorArguments.GetParameter("cudnn_off", BilinearSampler.CudnnOffDefault)
    /// <summary>Copy BilinearSampler instance with updated inputs/parameters.</summary>
    /// <param name="data">Input data to the BilinearsamplerOp.</param>
    /// <param name="grid">Input grid to the BilinearsamplerOp.grid has two channels: x_src, y_src</param>
    /// <param name="cudnnOff">whether to turn cudnn off</param>
    member this.With([<Optional>] ?data : Symbol,
        [<Optional>] ?grid : Symbol,
        [<Optional>] ?cudnnOff : bool) = 
        let operatorArguments = 
            [
                data |> Option.map (fun x -> "data", Input x)
                grid |> Option.map (fun x -> "grid", Input x)
                cudnnOff |> Option.map (fun x -> "cudnn_off", Parameter(Some (box x)))
            ] |> List.choose id
        new BilinearSampler(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type ContribCountSketch private (operatorArguments) = 
    inherit SymbolOperator("_contrib_count_sketch", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new ContribCountSketch(args)
    override this.WithArguments(args : Arguments<Symbol>) = new ContribCountSketch(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <summary>Apply CountSketch to input: map a d-dimension data to k-dimension data&quot;
    /// 
    /// .. note:: `count_sketch` is only available on GPU.
    /// 
    /// Assume input data has shape (N, d), sign hash table s has shape (N, d),
    /// index hash table h has shape (N, d) and mapping dimension out_dim = k,
    /// each element in s is either +1 or -1, each element in h is random integer from 0 to k-1.
    /// Then the operator computs:
    /// 
    /// .. math::
    ///    out[h[i]] += data[i] * s[i]
    /// 
    /// Example::
    /// 
    ///    out_dim = 5
    ///    x = [[1.2, 2.5, 3.4],[3.2, 5.7, 6.6]]
    ///    h = [[0, 3, 4]]
    ///    s = [[1, -1, 1]]
    ///    mx.contrib.ndarray.count_sketch(data=x, h=h, s=s, out_dim = 5) = [[1.2, 0, 0, -2.5, 3.4],
    ///                                                                      [3.2, 0, 0, -5.7, 6.6]]
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\contrib\count_sketch.cc:L67</summary>
    /// <param name="data">Input data to the CountSketchOp.</param>
    /// <param name="h">The index vector</param>
    /// <param name="s">The sign vector</param>
    /// <param name="outDim">The output dimension.</param>
    /// <param name="processingBatchSize">How many sketch vectors to process at one time.</param>
    new(data : Symbol,
        h : Symbol,
        s : Symbol,
        outDim : int,
        [<Optional>] ?processingBatchSize : int) = 
        let operatorArguments = 
            [
                "data", Input data
                "h", Input h
                "s", Input s
                "out_dim", Parameter(Some(box outDim))
                "processing_batch_size", processingBatchSize |> Option.map box |> Parameter
            ]
        new ContribCountSketch(Arguments<Symbol>(operatorArguments))
    /// <summary>Apply CountSketch to input: map a d-dimension data to k-dimension data&quot;
    /// 
    /// .. note:: `count_sketch` is only available on GPU.
    /// 
    /// Assume input data has shape (N, d), sign hash table s has shape (N, d),
    /// index hash table h has shape (N, d) and mapping dimension out_dim = k,
    /// each element in s is either +1 or -1, each element in h is random integer from 0 to k-1.
    /// Then the operator computs:
    /// 
    /// .. math::
    ///    out[h[i]] += data[i] * s[i]
    /// 
    /// Example::
    /// 
    ///    out_dim = 5
    ///    x = [[1.2, 2.5, 3.4],[3.2, 5.7, 6.6]]
    ///    h = [[0, 3, 4]]
    ///    s = [[1, -1, 1]]
    ///    mx.contrib.ndarray.count_sketch(data=x, h=h, s=s, out_dim = 5) = [[1.2, 0, 0, -2.5, 3.4],
    ///                                                                      [3.2, 0, 0, -5.7, 6.6]]
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\contrib\count_sketch.cc:L67</summary>
    /// <param name="outDim">The output dimension.</param>
    /// <param name="data">Input data to the CountSketchOp.</param>
    /// <param name="h">The index vector</param>
    /// <param name="s">The sign vector</param>
    /// <param name="processingBatchSize">How many sketch vectors to process at one time.</param>
    new(outDim : int,
        [<Optional>] ?data : Symbol,
        [<Optional>] ?h : Symbol,
        [<Optional>] ?s : Symbol,
        [<Optional>] ?processingBatchSize : int) = 
        let data = defaultArg data (new ImplicitVariable() :> Symbol)
        let h = defaultArg h (new ImplicitVariable() :> Symbol)
        let s = defaultArg s (new ImplicitVariable() :> Symbol)
        let operatorArguments = 
            [
                "data", Input data
                "h", Input h
                "s", Input s
                "out_dim", Parameter(Some(box outDim))
                "processing_batch_size", processingBatchSize |> Option.map box |> Parameter
            ]
        new ContribCountSketch(Arguments<Symbol>(operatorArguments))
    /// Default value for ProcessingBatchSize
    /// How many sketch vectors to process at one time.
    static member ProcessingBatchSizeDefault : int = 32
    /// Input data to the CountSketchOp.
    member __.Data = operatorArguments.GetInput "data"
    /// The index vector
    member __.H = operatorArguments.GetInput "h"
    /// The sign vector
    member __.S = operatorArguments.GetInput "s"
    /// The output dimension.
    member __.OutDim : int = match operatorArguments.GetParameter "out_dim" with Some(v) -> unbox v | None -> failwithf "Required parameter out_dim is missing"
    /// How many sketch vectors to process at one time.
    member __.ProcessingBatchSize = operatorArguments.GetParameter("processing_batch_size", ContribCountSketch.ProcessingBatchSizeDefault)
    /// <summary>Copy ContribCountSketch instance with updated inputs/parameters.</summary>
    /// <param name="data">Input data to the CountSketchOp.</param>
    /// <param name="h">The index vector</param>
    /// <param name="s">The sign vector</param>
    /// <param name="outDim">The output dimension.</param>
    /// <param name="processingBatchSize">How many sketch vectors to process at one time.</param>
    member this.With([<Optional>] ?data : Symbol,
        [<Optional>] ?h : Symbol,
        [<Optional>] ?s : Symbol,
        [<Optional>] ?outDim : int,
        [<Optional>] ?processingBatchSize : int) = 
        let operatorArguments = 
            [
                data |> Option.map (fun x -> "data", Input x)
                h |> Option.map (fun x -> "h", Input x)
                s |> Option.map (fun x -> "s", Input x)
                outDim |> Option.map (fun x -> "out_dim", Parameter(Some (box x)))
                processingBatchSize |> Option.map (fun x -> "processing_batch_size", Parameter(Some (box x)))
            ] |> List.choose id
        new ContribCountSketch(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type ContribDeformableConvolution private (operatorArguments) = 
    inherit SymbolOperator("_contrib_DeformableConvolution", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new ContribDeformableConvolution(args)
    override this.WithArguments(args : Arguments<Symbol>) = new ContribDeformableConvolution(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <summary>Compute 2-D deformable convolution on 4-D input.
    /// 
    /// The deformable convolution operation is described in https://arxiv.org/abs/1703.06211
    /// 
    /// For 2-D deformable convolution, the shapes are
    /// 
    /// - **data**: *(batch_size, channel, height, width)*
    /// - **offset**: *(batch_size, num_deformable_group * kernel[0] * kernel[1] * 2, height, width)*
    /// - **weight**: *(num_filter, channel, kernel[0], kernel[1])*
    /// - **bias**: *(num_filter,)*
    /// - **out**: *(batch_size, num_filter, out_height, out_width)*.
    /// 
    /// Define::
    /// 
    ///   f(x,k,p,s,d) = floor((x+2*p-d*(k-1)-1)/s)+1
    /// 
    /// then we have::
    /// 
    ///   out_height=f(height, kernel[0], pad[0], stride[0], dilate[0])
    ///   out_width=f(width, kernel[1], pad[1], stride[1], dilate[1])
    /// 
    /// If ``no_bias`` is set to be true, then the ``bias`` term is ignored.
    /// 
    /// The default data ``layout`` is *NCHW*, namely *(batch_size, channle, height,
    /// width)*.
    /// 
    /// If ``num_group`` is larger than 1, denoted by *g*, then split the input ``data``
    /// evenly into *g* parts along the channel axis, and also evenly split ``weight``
    /// along the first dimension. Next compute the convolution on the *i*-th part of
    /// the data with the *i*-th weight part. The output is obtained by concating all
    /// the *g* results.
    /// 
    /// If ``num_deformable_group`` is larger than 1, denoted by *dg*, then split the
    /// input ``offset`` evenly into *dg* parts along the channel axis, and also evenly
    /// split ``data`` into *dg* parts along the channel axis. Next compute the
    /// deformable convolution, apply the *i*-th part of the offset on the *i*-th part
    /// of the data.
    /// 
    /// 
    /// Both ``weight`` and ``bias`` are learnable parameters.
    /// 
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\contrib\deformable_convolution.cc:L100</summary>
    /// <param name="data">Input data to the DeformableConvolutionOp.</param>
    /// <param name="offset">Input offset to the DeformableConvolutionOp.</param>
    /// <param name="weight">Weight matrix.</param>
    /// <param name="bias">Bias parameter.</param>
    /// <param name="kernel">Convolution kernel size: (h, w) or (d, h, w)</param>
    /// <param name="numFilter">Convolution filter(channel) number</param>
    /// <param name="stride">Convolution stride: (h, w) or (d, h, w). Defaults to 1 for each dimension.</param>
    /// <param name="dilate">Convolution dilate: (h, w) or (d, h, w). Defaults to 1 for each dimension.</param>
    /// <param name="pad">Zero pad for convolution: (h, w) or (d, h, w). Defaults to no padding.</param>
    /// <param name="numGroup">Number of group partitions.</param>
    /// <param name="numDeformableGroup">Number of deformable group partitions.</param>
    /// <param name="workspace">Maximum temperal workspace allowed for convolution (MB).</param>
    /// <param name="noBias">Whether to disable bias parameter.</param>
    /// <param name="layout">Set layout for input, output and weight. Empty for
    ///     default layout: NCW for 1d, NCHW for 2d and NCDHW for 3d.</param>
    new(data : Symbol,
        offset : Symbol,
        weight : Symbol,
        bias : Symbol,
        kernel : int seq,
        numFilter : int,
        [<Optional>] ?stride : int seq,
        [<Optional>] ?dilate : int seq,
        [<Optional>] ?pad : int seq,
        [<Optional>] ?numGroup : int,
        [<Optional>] ?numDeformableGroup : int,
        [<Optional>] ?workspace : int64,
        [<Optional>] ?noBias : bool,
        [<Optional>] ?layout : ContribDeformableConvolutionLayout) = 
        let operatorArguments = 
            [
                "data", Input data
                "offset", Input offset
                "weight", Input weight
                "bias", Input bias
                "kernel", Parameter(Some(box kernel))
                "num_filter", Parameter(Some(box numFilter))
                "stride", stride |> Option.map box |> Parameter
                "dilate", dilate |> Option.map box |> Parameter
                "pad", pad |> Option.map box |> Parameter
                "num_group", numGroup |> Option.map box |> Parameter
                "num_deformable_group", numDeformableGroup |> Option.map box |> Parameter
                "workspace", workspace |> Option.map box |> Parameter
                "no_bias", noBias |> Option.map box |> Parameter
                "layout", layout |> Option.map box |> Parameter
            ]
        new ContribDeformableConvolution(Arguments<Symbol>(operatorArguments))
    /// <summary>Compute 2-D deformable convolution on 4-D input.
    /// 
    /// The deformable convolution operation is described in https://arxiv.org/abs/1703.06211
    /// 
    /// For 2-D deformable convolution, the shapes are
    /// 
    /// - **data**: *(batch_size, channel, height, width)*
    /// - **offset**: *(batch_size, num_deformable_group * kernel[0] * kernel[1] * 2, height, width)*
    /// - **weight**: *(num_filter, channel, kernel[0], kernel[1])*
    /// - **bias**: *(num_filter,)*
    /// - **out**: *(batch_size, num_filter, out_height, out_width)*.
    /// 
    /// Define::
    /// 
    ///   f(x,k,p,s,d) = floor((x+2*p-d*(k-1)-1)/s)+1
    /// 
    /// then we have::
    /// 
    ///   out_height=f(height, kernel[0], pad[0], stride[0], dilate[0])
    ///   out_width=f(width, kernel[1], pad[1], stride[1], dilate[1])
    /// 
    /// If ``no_bias`` is set to be true, then the ``bias`` term is ignored.
    /// 
    /// The default data ``layout`` is *NCHW*, namely *(batch_size, channle, height,
    /// width)*.
    /// 
    /// If ``num_group`` is larger than 1, denoted by *g*, then split the input ``data``
    /// evenly into *g* parts along the channel axis, and also evenly split ``weight``
    /// along the first dimension. Next compute the convolution on the *i*-th part of
    /// the data with the *i*-th weight part. The output is obtained by concating all
    /// the *g* results.
    /// 
    /// If ``num_deformable_group`` is larger than 1, denoted by *dg*, then split the
    /// input ``offset`` evenly into *dg* parts along the channel axis, and also evenly
    /// split ``data`` into *dg* parts along the channel axis. Next compute the
    /// deformable convolution, apply the *i*-th part of the offset on the *i*-th part
    /// of the data.
    /// 
    /// 
    /// Both ``weight`` and ``bias`` are learnable parameters.
    /// 
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\contrib\deformable_convolution.cc:L100</summary>
    /// <param name="kernel">Convolution kernel size: (h, w) or (d, h, w)</param>
    /// <param name="numFilter">Convolution filter(channel) number</param>
    /// <param name="data">Input data to the DeformableConvolutionOp.</param>
    /// <param name="offset">Input offset to the DeformableConvolutionOp.</param>
    /// <param name="weight">Weight matrix.</param>
    /// <param name="bias">Bias parameter.</param>
    /// <param name="stride">Convolution stride: (h, w) or (d, h, w). Defaults to 1 for each dimension.</param>
    /// <param name="dilate">Convolution dilate: (h, w) or (d, h, w). Defaults to 1 for each dimension.</param>
    /// <param name="pad">Zero pad for convolution: (h, w) or (d, h, w). Defaults to no padding.</param>
    /// <param name="numGroup">Number of group partitions.</param>
    /// <param name="numDeformableGroup">Number of deformable group partitions.</param>
    /// <param name="workspace">Maximum temperal workspace allowed for convolution (MB).</param>
    /// <param name="noBias">Whether to disable bias parameter.</param>
    /// <param name="layout">Set layout for input, output and weight. Empty for
    ///     default layout: NCW for 1d, NCHW for 2d and NCDHW for 3d.</param>
    new(kernel : int seq,
        numFilter : int,
        [<Optional>] ?data : Symbol,
        [<Optional>] ?offset : Symbol,
        [<Optional>] ?weight : Symbol,
        [<Optional>] ?bias : Symbol,
        [<Optional>] ?stride : int seq,
        [<Optional>] ?dilate : int seq,
        [<Optional>] ?pad : int seq,
        [<Optional>] ?numGroup : int,
        [<Optional>] ?numDeformableGroup : int,
        [<Optional>] ?workspace : int64,
        [<Optional>] ?noBias : bool,
        [<Optional>] ?layout : ContribDeformableConvolutionLayout) = 
        let data = defaultArg data (new ImplicitVariable() :> Symbol)
        let offset = defaultArg offset (new ImplicitVariable() :> Symbol)
        let weight = defaultArg weight (new ImplicitVariable() :> Symbol)
        let bias = defaultArg bias (new ImplicitVariable() :> Symbol)
        let operatorArguments = 
            [
                "data", Input data
                "offset", Input offset
                "weight", Input weight
                "bias", Input bias
                "kernel", Parameter(Some(box kernel))
                "num_filter", Parameter(Some(box numFilter))
                "stride", stride |> Option.map box |> Parameter
                "dilate", dilate |> Option.map box |> Parameter
                "pad", pad |> Option.map box |> Parameter
                "num_group", numGroup |> Option.map box |> Parameter
                "num_deformable_group", numDeformableGroup |> Option.map box |> Parameter
                "workspace", workspace |> Option.map box |> Parameter
                "no_bias", noBias |> Option.map box |> Parameter
                "layout", layout |> Option.map box |> Parameter
            ]
        new ContribDeformableConvolution(Arguments<Symbol>(operatorArguments))
    /// Default value for Stride
    /// Convolution stride: (h, w) or (d, h, w). Defaults to 1 for each dimension.
    static member StrideDefault : int [] = [||]
    /// Default value for Dilate
    /// Convolution dilate: (h, w) or (d, h, w). Defaults to 1 for each dimension.
    static member DilateDefault : int [] = [||]
    /// Default value for Pad
    /// Zero pad for convolution: (h, w) or (d, h, w). Defaults to no padding.
    static member PadDefault : int [] = [||]
    /// Default value for NumGroup
    /// Number of group partitions.
    static member NumGroupDefault : int = 1
    /// Default value for NumDeformableGroup
    /// Number of deformable group partitions.
    static member NumDeformableGroupDefault : int = 1
    /// Default value for Workspace
    /// Maximum temperal workspace allowed for convolution (MB).
    static member WorkspaceDefault : int64 = 1024L
    /// Default value for NoBias
    /// Whether to disable bias parameter.
    static member NoBiasDefault : bool = false
    /// Default value for Layout
    /// Set layout for input, output and weight. Empty for
    ///     default layout: NCW for 1d, NCHW for 2d and NCDHW for 3d.
    static member LayoutDefault : ContribDeformableConvolutionLayout option = None
    /// Input data to the DeformableConvolutionOp.
    member __.Data = operatorArguments.GetInput "data"
    /// Input offset to the DeformableConvolutionOp.
    member __.Offset = operatorArguments.GetInput "offset"
    /// Weight matrix.
    member __.Weight = operatorArguments.GetInput "weight"
    /// Bias parameter.
    member __.Bias = operatorArguments.GetInput "bias"
    /// Convolution kernel size: (h, w) or (d, h, w)
    member __.Kernel : int seq = match operatorArguments.GetParameter "kernel" with Some(v) -> unbox v | None -> failwithf "Required parameter kernel is missing"
    /// Convolution filter(channel) number
    member __.NumFilter : int = match operatorArguments.GetParameter "num_filter" with Some(v) -> unbox v | None -> failwithf "Required parameter num_filter is missing"
    /// Convolution stride: (h, w) or (d, h, w). Defaults to 1 for each dimension.
    member __.Stride = operatorArguments.GetParameter("stride", ContribDeformableConvolution.StrideDefault)
    /// Convolution dilate: (h, w) or (d, h, w). Defaults to 1 for each dimension.
    member __.Dilate = operatorArguments.GetParameter("dilate", ContribDeformableConvolution.DilateDefault)
    /// Zero pad for convolution: (h, w) or (d, h, w). Defaults to no padding.
    member __.Pad = operatorArguments.GetParameter("pad", ContribDeformableConvolution.PadDefault)
    /// Number of group partitions.
    member __.NumGroup = operatorArguments.GetParameter("num_group", ContribDeformableConvolution.NumGroupDefault)
    /// Number of deformable group partitions.
    member __.NumDeformableGroup = operatorArguments.GetParameter("num_deformable_group", ContribDeformableConvolution.NumDeformableGroupDefault)
    /// Maximum temperal workspace allowed for convolution (MB).
    member __.Workspace = operatorArguments.GetParameter("workspace", ContribDeformableConvolution.WorkspaceDefault)
    /// Whether to disable bias parameter.
    member __.NoBias = operatorArguments.GetParameter("no_bias", ContribDeformableConvolution.NoBiasDefault)
    /// Set layout for input, output and weight. Empty for
    ///     default layout: NCW for 1d, NCHW for 2d and NCDHW for 3d.
    member __.Layout = operatorArguments.GetParameter("layout", ContribDeformableConvolution.LayoutDefault)
    /// <summary>Copy ContribDeformableConvolution instance with updated inputs/parameters.</summary>
    /// <param name="data">Input data to the DeformableConvolutionOp.</param>
    /// <param name="offset">Input offset to the DeformableConvolutionOp.</param>
    /// <param name="weight">Weight matrix.</param>
    /// <param name="bias">Bias parameter.</param>
    /// <param name="kernel">Convolution kernel size: (h, w) or (d, h, w)</param>
    /// <param name="numFilter">Convolution filter(channel) number</param>
    /// <param name="stride">Convolution stride: (h, w) or (d, h, w). Defaults to 1 for each dimension.</param>
    /// <param name="dilate">Convolution dilate: (h, w) or (d, h, w). Defaults to 1 for each dimension.</param>
    /// <param name="pad">Zero pad for convolution: (h, w) or (d, h, w). Defaults to no padding.</param>
    /// <param name="numGroup">Number of group partitions.</param>
    /// <param name="numDeformableGroup">Number of deformable group partitions.</param>
    /// <param name="workspace">Maximum temperal workspace allowed for convolution (MB).</param>
    /// <param name="noBias">Whether to disable bias parameter.</param>
    /// <param name="layout">Set layout for input, output and weight. Empty for
    ///     default layout: NCW for 1d, NCHW for 2d and NCDHW for 3d.</param>
    member this.With([<Optional>] ?data : Symbol,
        [<Optional>] ?offset : Symbol,
        [<Optional>] ?weight : Symbol,
        [<Optional>] ?bias : Symbol,
        [<Optional>] ?kernel : int seq,
        [<Optional>] ?numFilter : int,
        [<Optional>] ?stride : int seq,
        [<Optional>] ?dilate : int seq,
        [<Optional>] ?pad : int seq,
        [<Optional>] ?numGroup : int,
        [<Optional>] ?numDeformableGroup : int,
        [<Optional>] ?workspace : int64,
        [<Optional>] ?noBias : bool,
        [<Optional>] ?layout : ContribDeformableConvolutionLayout) = 
        let operatorArguments = 
            [
                data |> Option.map (fun x -> "data", Input x)
                offset |> Option.map (fun x -> "offset", Input x)
                weight |> Option.map (fun x -> "weight", Input x)
                bias |> Option.map (fun x -> "bias", Input x)
                kernel |> Option.map (fun x -> "kernel", Parameter(Some (box x)))
                numFilter |> Option.map (fun x -> "num_filter", Parameter(Some (box x)))
                stride |> Option.map (fun x -> "stride", Parameter(Some (box x)))
                dilate |> Option.map (fun x -> "dilate", Parameter(Some (box x)))
                pad |> Option.map (fun x -> "pad", Parameter(Some (box x)))
                numGroup |> Option.map (fun x -> "num_group", Parameter(Some (box x)))
                numDeformableGroup |> Option.map (fun x -> "num_deformable_group", Parameter(Some (box x)))
                workspace |> Option.map (fun x -> "workspace", Parameter(Some (box x)))
                noBias |> Option.map (fun x -> "no_bias", Parameter(Some (box x)))
                layout |> Option.map (fun x -> "layout", Parameter(Some (box x)))
            ] |> List.choose id
        new ContribDeformableConvolution(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type ContribDeformablePSROIPooling private (operatorArguments) = 
    inherit SymbolOperator("_contrib_DeformablePSROIPooling", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new ContribDeformablePSROIPooling(args)
    override this.WithArguments(args : Arguments<Symbol>) = new ContribDeformablePSROIPooling(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <summary>Performs deformable position-sensitive region-of-interest pooling on inputs.
    /// The DeformablePSROIPooling operation is described in https://arxiv.org/abs/1703.06211 .batch_size will change to the number of region bounding boxes after DeformablePSROIPooling</summary>
    /// <param name="data">Input data to the pooling operator, a 4D Feature maps</param>
    /// <param name="rois">Bounding box coordinates, a 2D array of [[batch_index, x1, y1, x2, y2]]. (x1, y1) and (x2, y2) are top left and down right corners of designated region of interest. batch_index indicates the index of corresponding image in the input data</param>
    /// <param name="trans">transition parameter</param>
    /// <param name="spatialScale">Ratio of input feature map height (or w) to raw image height (or w). Equals the reciprocal of total stride in convolutional layers</param>
    /// <param name="outputDim">fix output dim</param>
    /// <param name="groupSize">fix group size</param>
    /// <param name="pooledSize">fix pooled size</param>
    /// <param name="partSize">fix part size</param>
    /// <param name="samplePerPart">fix samples per part</param>
    /// <param name="transStd">fix transition std</param>
    /// <param name="noTrans">Whether to disable trans parameter.</param>
    new(data : Symbol,
        rois : Symbol,
        trans : Symbol,
        spatialScale : float,
        outputDim : int,
        groupSize : int,
        pooledSize : int,
        [<Optional>] ?partSize : int,
        [<Optional>] ?samplePerPart : int,
        [<Optional>] ?transStd : float,
        [<Optional>] ?noTrans : bool) = 
        let operatorArguments = 
            [
                "data", Input data
                "rois", Input rois
                "trans", Input trans
                "spatial_scale", Parameter(Some(box spatialScale))
                "output_dim", Parameter(Some(box outputDim))
                "group_size", Parameter(Some(box groupSize))
                "pooled_size", Parameter(Some(box pooledSize))
                "part_size", partSize |> Option.map box |> Parameter
                "sample_per_part", samplePerPart |> Option.map box |> Parameter
                "trans_std", transStd |> Option.map box |> Parameter
                "no_trans", noTrans |> Option.map box |> Parameter
            ]
        new ContribDeformablePSROIPooling(Arguments<Symbol>(operatorArguments))
    /// <summary>Performs deformable position-sensitive region-of-interest pooling on inputs.
    /// The DeformablePSROIPooling operation is described in https://arxiv.org/abs/1703.06211 .batch_size will change to the number of region bounding boxes after DeformablePSROIPooling</summary>
    /// <param name="spatialScale">Ratio of input feature map height (or w) to raw image height (or w). Equals the reciprocal of total stride in convolutional layers</param>
    /// <param name="outputDim">fix output dim</param>
    /// <param name="groupSize">fix group size</param>
    /// <param name="pooledSize">fix pooled size</param>
    /// <param name="data">Input data to the pooling operator, a 4D Feature maps</param>
    /// <param name="rois">Bounding box coordinates, a 2D array of [[batch_index, x1, y1, x2, y2]]. (x1, y1) and (x2, y2) are top left and down right corners of designated region of interest. batch_index indicates the index of corresponding image in the input data</param>
    /// <param name="trans">transition parameter</param>
    /// <param name="partSize">fix part size</param>
    /// <param name="samplePerPart">fix samples per part</param>
    /// <param name="transStd">fix transition std</param>
    /// <param name="noTrans">Whether to disable trans parameter.</param>
    new(spatialScale : float,
        outputDim : int,
        groupSize : int,
        pooledSize : int,
        [<Optional>] ?data : Symbol,
        [<Optional>] ?rois : Symbol,
        [<Optional>] ?trans : Symbol,
        [<Optional>] ?partSize : int,
        [<Optional>] ?samplePerPart : int,
        [<Optional>] ?transStd : float,
        [<Optional>] ?noTrans : bool) = 
        let data = defaultArg data (new ImplicitVariable() :> Symbol)
        let rois = defaultArg rois (new ImplicitVariable() :> Symbol)
        let trans = defaultArg trans (new ImplicitVariable() :> Symbol)
        let operatorArguments = 
            [
                "data", Input data
                "rois", Input rois
                "trans", Input trans
                "spatial_scale", Parameter(Some(box spatialScale))
                "output_dim", Parameter(Some(box outputDim))
                "group_size", Parameter(Some(box groupSize))
                "pooled_size", Parameter(Some(box pooledSize))
                "part_size", partSize |> Option.map box |> Parameter
                "sample_per_part", samplePerPart |> Option.map box |> Parameter
                "trans_std", transStd |> Option.map box |> Parameter
                "no_trans", noTrans |> Option.map box |> Parameter
            ]
        new ContribDeformablePSROIPooling(Arguments<Symbol>(operatorArguments))
    /// Default value for PartSize
    /// fix part size
    static member PartSizeDefault : int = 0
    /// Default value for SamplePerPart
    /// fix samples per part
    static member SamplePerPartDefault : int = 1
    /// Default value for TransStd
    /// fix transition std
    static member TransStdDefault : double = 0.0
    /// Default value for NoTrans
    /// Whether to disable trans parameter.
    static member NoTransDefault : bool = false
    /// Input data to the pooling operator, a 4D Feature maps
    member __.Data = operatorArguments.GetInput "data"
    /// Bounding box coordinates, a 2D array of [[batch_index, x1, y1, x2, y2]]. (x1, y1) and (x2, y2) are top left and down right corners of designated region of interest. batch_index indicates the index of corresponding image in the input data
    member __.Rois = operatorArguments.GetInput "rois"
    /// transition parameter
    member __.Trans = operatorArguments.GetInput "trans"
    /// Ratio of input feature map height (or w) to raw image height (or w). Equals the reciprocal of total stride in convolutional layers
    member __.SpatialScale : float = match operatorArguments.GetParameter "spatial_scale" with Some(v) -> unbox v | None -> failwithf "Required parameter spatial_scale is missing"
    /// fix output dim
    member __.OutputDim : int = match operatorArguments.GetParameter "output_dim" with Some(v) -> unbox v | None -> failwithf "Required parameter output_dim is missing"
    /// fix group size
    member __.GroupSize : int = match operatorArguments.GetParameter "group_size" with Some(v) -> unbox v | None -> failwithf "Required parameter group_size is missing"
    /// fix pooled size
    member __.PooledSize : int = match operatorArguments.GetParameter "pooled_size" with Some(v) -> unbox v | None -> failwithf "Required parameter pooled_size is missing"
    /// fix part size
    member __.PartSize = operatorArguments.GetParameter("part_size", ContribDeformablePSROIPooling.PartSizeDefault)
    /// fix samples per part
    member __.SamplePerPart = operatorArguments.GetParameter("sample_per_part", ContribDeformablePSROIPooling.SamplePerPartDefault)
    /// fix transition std
    member __.TransStd = operatorArguments.GetParameter("trans_std", ContribDeformablePSROIPooling.TransStdDefault)
    /// Whether to disable trans parameter.
    member __.NoTrans = operatorArguments.GetParameter("no_trans", ContribDeformablePSROIPooling.NoTransDefault)
    /// <summary>Copy ContribDeformablePSROIPooling instance with updated inputs/parameters.</summary>
    /// <param name="data">Input data to the pooling operator, a 4D Feature maps</param>
    /// <param name="rois">Bounding box coordinates, a 2D array of [[batch_index, x1, y1, x2, y2]]. (x1, y1) and (x2, y2) are top left and down right corners of designated region of interest. batch_index indicates the index of corresponding image in the input data</param>
    /// <param name="trans">transition parameter</param>
    /// <param name="spatialScale">Ratio of input feature map height (or w) to raw image height (or w). Equals the reciprocal of total stride in convolutional layers</param>
    /// <param name="outputDim">fix output dim</param>
    /// <param name="groupSize">fix group size</param>
    /// <param name="pooledSize">fix pooled size</param>
    /// <param name="partSize">fix part size</param>
    /// <param name="samplePerPart">fix samples per part</param>
    /// <param name="transStd">fix transition std</param>
    /// <param name="noTrans">Whether to disable trans parameter.</param>
    member this.With([<Optional>] ?data : Symbol,
        [<Optional>] ?rois : Symbol,
        [<Optional>] ?trans : Symbol,
        [<Optional>] ?spatialScale : float,
        [<Optional>] ?outputDim : int,
        [<Optional>] ?groupSize : int,
        [<Optional>] ?pooledSize : int,
        [<Optional>] ?partSize : int,
        [<Optional>] ?samplePerPart : int,
        [<Optional>] ?transStd : float,
        [<Optional>] ?noTrans : bool) = 
        let operatorArguments = 
            [
                data |> Option.map (fun x -> "data", Input x)
                rois |> Option.map (fun x -> "rois", Input x)
                trans |> Option.map (fun x -> "trans", Input x)
                spatialScale |> Option.map (fun x -> "spatial_scale", Parameter(Some (box x)))
                outputDim |> Option.map (fun x -> "output_dim", Parameter(Some (box x)))
                groupSize |> Option.map (fun x -> "group_size", Parameter(Some (box x)))
                pooledSize |> Option.map (fun x -> "pooled_size", Parameter(Some (box x)))
                partSize |> Option.map (fun x -> "part_size", Parameter(Some (box x)))
                samplePerPart |> Option.map (fun x -> "sample_per_part", Parameter(Some (box x)))
                transStd |> Option.map (fun x -> "trans_std", Parameter(Some (box x)))
                noTrans |> Option.map (fun x -> "no_trans", Parameter(Some (box x)))
            ] |> List.choose id
        new ContribDeformablePSROIPooling(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type ContribFft private (operatorArguments) = 
    inherit SymbolOperator("_contrib_fft", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new ContribFft(args)
    override this.WithArguments(args : Arguments<Symbol>) = new ContribFft(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <summary>Apply 1D FFT to input&quot;
    /// 
    /// .. note:: `fft` is only available on GPU.
    /// 
    /// Currently accept 2 input data shapes: (N, d) or (N1, N2, N3, d), data can only be real numbers.
    /// The output data has shape: (N, 2*d) or (N1, N2, N3, 2*d). The format is: [real0, imag0, real1, imag1, ...].
    /// 
    /// Example::
    /// 
    ///    data = np.random.normal(0,1,(3,4))
    ///    out = mx.contrib.ndarray.fft(data = mx.nd.array(data,ctx = mx.gpu(0)))
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\contrib\fft.cc:L56</summary>
    /// <param name="data">Input data to the FFTOp.</param>
    /// <param name="computeSize">Maximum size of sub-batch to be forwarded at one time</param>
    new([<Optional>] ?data : Symbol,
        [<Optional>] ?computeSize : int) = 
        let data = defaultArg data (new ImplicitVariable() :> Symbol)
        let operatorArguments = 
            [
                "data", Input data
                "compute_size", computeSize |> Option.map box |> Parameter
            ]
        new ContribFft(Arguments<Symbol>(operatorArguments))
    /// Default value for ComputeSize
    /// Maximum size of sub-batch to be forwarded at one time
    static member ComputeSizeDefault : int = 128
    /// Input data to the FFTOp.
    member __.Data = operatorArguments.GetInput "data"
    /// Maximum size of sub-batch to be forwarded at one time
    member __.ComputeSize = operatorArguments.GetParameter("compute_size", ContribFft.ComputeSizeDefault)
    /// <summary>Copy ContribFft instance with updated inputs/parameters.</summary>
    /// <param name="data">Input data to the FFTOp.</param>
    /// <param name="computeSize">Maximum size of sub-batch to be forwarded at one time</param>
    member this.With([<Optional>] ?data : Symbol,
        [<Optional>] ?computeSize : int) = 
        let operatorArguments = 
            [
                data |> Option.map (fun x -> "data", Input x)
                computeSize |> Option.map (fun x -> "compute_size", Parameter(Some (box x)))
            ] |> List.choose id
        new ContribFft(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type ContribIfft private (operatorArguments) = 
    inherit SymbolOperator("_contrib_ifft", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new ContribIfft(args)
    override this.WithArguments(args : Arguments<Symbol>) = new ContribIfft(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <summary>Apply 1D ifft to input&quot;
    /// 
    /// .. note:: `ifft` is only available on GPU.
    /// 
    /// Currently accept 2 input data shapes: (N, d) or (N1, N2, N3, d). Data is in format: [real0, imag0, real1, imag1, ...].
    /// Last dimension must be an even number.
    /// The output data has shape: (N, d/2) or (N1, N2, N3, d/2). It is only the real part of the result.
    /// 
    /// Example::
    /// 
    ///    data = np.random.normal(0,1,(3,4))
    ///    out = mx.contrib.ndarray.ifft(data = mx.nd.array(data,ctx = mx.gpu(0)))
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\contrib\ifft.cc:L58</summary>
    /// <param name="data">Input data to the IFFTOp.</param>
    /// <param name="computeSize">Maximum size of sub-batch to be forwarded at one time</param>
    new([<Optional>] ?data : Symbol,
        [<Optional>] ?computeSize : int) = 
        let data = defaultArg data (new ImplicitVariable() :> Symbol)
        let operatorArguments = 
            [
                "data", Input data
                "compute_size", computeSize |> Option.map box |> Parameter
            ]
        new ContribIfft(Arguments<Symbol>(operatorArguments))
    /// Default value for ComputeSize
    /// Maximum size of sub-batch to be forwarded at one time
    static member ComputeSizeDefault : int = 128
    /// Input data to the IFFTOp.
    member __.Data = operatorArguments.GetInput "data"
    /// Maximum size of sub-batch to be forwarded at one time
    member __.ComputeSize = operatorArguments.GetParameter("compute_size", ContribIfft.ComputeSizeDefault)
    /// <summary>Copy ContribIfft instance with updated inputs/parameters.</summary>
    /// <param name="data">Input data to the IFFTOp.</param>
    /// <param name="computeSize">Maximum size of sub-batch to be forwarded at one time</param>
    member this.With([<Optional>] ?data : Symbol,
        [<Optional>] ?computeSize : int) = 
        let operatorArguments = 
            [
                data |> Option.map (fun x -> "data", Input x)
                computeSize |> Option.map (fun x -> "compute_size", Parameter(Some (box x)))
            ] |> List.choose id
        new ContribIfft(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type ContribMultiProposal private (operatorArguments) = 
    inherit SymbolOperator("_contrib_MultiProposal", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new ContribMultiProposal(args)
    override this.WithArguments(args : Arguments<Symbol>) = new ContribMultiProposal(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <summary>Generate region proposals via RPN</summary>
    /// <param name="clsProb">Score of how likely proposal is object.</param>
    /// <param name="bboxPred">BBox Predicted deltas from anchors for proposals</param>
    /// <param name="imInfo">Image size and scale.</param>
    /// <param name="rpnPreNmsTopN">Number of top scoring boxes to keep before applying NMS to RPN proposals</param>
    /// <param name="rpnPostNmsTopN">Number of top scoring boxes to keep after applying NMS to RPN proposals</param>
    /// <param name="threshold">NMS value, below which to suppress.</param>
    /// <param name="rpnMinSize">Minimum height or width in proposal</param>
    /// <param name="scales">Used to generate anchor windows by enumerating scales</param>
    /// <param name="ratios">Used to generate anchor windows by enumerating ratios</param>
    /// <param name="featureStride">The size of the receptive field each unit in the convolution layer of the rpn,for example the product of all stride&#39;s prior to this layer.</param>
    /// <param name="outputScore">Add score to outputs</param>
    /// <param name="iouLoss">Usage of IoU Loss</param>
    new([<Optional>] ?clsProb : Symbol,
        [<Optional>] ?bboxPred : Symbol,
        [<Optional>] ?imInfo : Symbol,
        [<Optional>] ?rpnPreNmsTopN : int,
        [<Optional>] ?rpnPostNmsTopN : int,
        [<Optional>] ?threshold : float,
        [<Optional>] ?rpnMinSize : int,
        [<Optional>] ?scales : double seq,
        [<Optional>] ?ratios : double seq,
        [<Optional>] ?featureStride : int,
        [<Optional>] ?outputScore : bool,
        [<Optional>] ?iouLoss : bool) = 
        let clsProb = defaultArg clsProb (new ImplicitVariable() :> Symbol)
        let bboxPred = defaultArg bboxPred (new ImplicitVariable() :> Symbol)
        let imInfo = defaultArg imInfo (new ImplicitVariable() :> Symbol)
        let operatorArguments = 
            [
                "cls_prob", Input clsProb
                "bbox_pred", Input bboxPred
                "im_info", Input imInfo
                "rpn_pre_nms_top_n", rpnPreNmsTopN |> Option.map box |> Parameter
                "rpn_post_nms_top_n", rpnPostNmsTopN |> Option.map box |> Parameter
                "threshold", threshold |> Option.map box |> Parameter
                "rpn_min_size", rpnMinSize |> Option.map box |> Parameter
                "scales", scales |> Option.map box |> Parameter
                "ratios", ratios |> Option.map box |> Parameter
                "feature_stride", featureStride |> Option.map box |> Parameter
                "output_score", outputScore |> Option.map box |> Parameter
                "iou_loss", iouLoss |> Option.map box |> Parameter
            ]
        new ContribMultiProposal(Arguments<Symbol>(operatorArguments))
    /// Default value for RpnPreNmsTopN
    /// Number of top scoring boxes to keep before applying NMS to RPN proposals
    static member RpnPreNmsTopNDefault : int = 6000
    /// Default value for RpnPostNmsTopN
    /// Number of top scoring boxes to keep after applying NMS to RPN proposals
    static member RpnPostNmsTopNDefault : int = 300
    /// Default value for Threshold
    /// NMS value, below which to suppress.
    static member ThresholdDefault : double = 0.699999988
    /// Default value for RpnMinSize
    /// Minimum height or width in proposal
    static member RpnMinSizeDefault : int = 16
    /// Default value for Scales
    /// Used to generate anchor windows by enumerating scales
    static member ScalesDefault : double [] = [|4.0; 8.0; 16.0; 32.0|]
    /// Default value for Ratios
    /// Used to generate anchor windows by enumerating ratios
    static member RatiosDefault : double [] = [|0.5; 1.0; 2.0|]
    /// Default value for FeatureStride
    /// The size of the receptive field each unit in the convolution layer of the rpn,for example the product of all stride&#39;s prior to this layer.
    static member FeatureStrideDefault : int = 16
    /// Default value for OutputScore
    /// Add score to outputs
    static member OutputScoreDefault : bool = false
    /// Default value for IouLoss
    /// Usage of IoU Loss
    static member IouLossDefault : bool = false
    /// Score of how likely proposal is object.
    member __.ClsProb = operatorArguments.GetInput "cls_prob"
    /// BBox Predicted deltas from anchors for proposals
    member __.BboxPred = operatorArguments.GetInput "bbox_pred"
    /// Image size and scale.
    member __.ImInfo = operatorArguments.GetInput "im_info"
    /// Number of top scoring boxes to keep before applying NMS to RPN proposals
    member __.RpnPreNmsTopN = operatorArguments.GetParameter("rpn_pre_nms_top_n", ContribMultiProposal.RpnPreNmsTopNDefault)
    /// Number of top scoring boxes to keep after applying NMS to RPN proposals
    member __.RpnPostNmsTopN = operatorArguments.GetParameter("rpn_post_nms_top_n", ContribMultiProposal.RpnPostNmsTopNDefault)
    /// NMS value, below which to suppress.
    member __.Threshold = operatorArguments.GetParameter("threshold", ContribMultiProposal.ThresholdDefault)
    /// Minimum height or width in proposal
    member __.RpnMinSize = operatorArguments.GetParameter("rpn_min_size", ContribMultiProposal.RpnMinSizeDefault)
    /// Used to generate anchor windows by enumerating scales
    member __.Scales = operatorArguments.GetParameter("scales", ContribMultiProposal.ScalesDefault)
    /// Used to generate anchor windows by enumerating ratios
    member __.Ratios = operatorArguments.GetParameter("ratios", ContribMultiProposal.RatiosDefault)
    /// The size of the receptive field each unit in the convolution layer of the rpn,for example the product of all stride&#39;s prior to this layer.
    member __.FeatureStride = operatorArguments.GetParameter("feature_stride", ContribMultiProposal.FeatureStrideDefault)
    /// Add score to outputs
    member __.OutputScore = operatorArguments.GetParameter("output_score", ContribMultiProposal.OutputScoreDefault)
    /// Usage of IoU Loss
    member __.IouLoss = operatorArguments.GetParameter("iou_loss", ContribMultiProposal.IouLossDefault)
    /// <summary>Copy ContribMultiProposal instance with updated inputs/parameters.</summary>
    /// <param name="clsProb">Score of how likely proposal is object.</param>
    /// <param name="bboxPred">BBox Predicted deltas from anchors for proposals</param>
    /// <param name="imInfo">Image size and scale.</param>
    /// <param name="rpnPreNmsTopN">Number of top scoring boxes to keep before applying NMS to RPN proposals</param>
    /// <param name="rpnPostNmsTopN">Number of top scoring boxes to keep after applying NMS to RPN proposals</param>
    /// <param name="threshold">NMS value, below which to suppress.</param>
    /// <param name="rpnMinSize">Minimum height or width in proposal</param>
    /// <param name="scales">Used to generate anchor windows by enumerating scales</param>
    /// <param name="ratios">Used to generate anchor windows by enumerating ratios</param>
    /// <param name="featureStride">The size of the receptive field each unit in the convolution layer of the rpn,for example the product of all stride&#39;s prior to this layer.</param>
    /// <param name="outputScore">Add score to outputs</param>
    /// <param name="iouLoss">Usage of IoU Loss</param>
    member this.With([<Optional>] ?clsProb : Symbol,
        [<Optional>] ?bboxPred : Symbol,
        [<Optional>] ?imInfo : Symbol,
        [<Optional>] ?rpnPreNmsTopN : int,
        [<Optional>] ?rpnPostNmsTopN : int,
        [<Optional>] ?threshold : float,
        [<Optional>] ?rpnMinSize : int,
        [<Optional>] ?scales : double seq,
        [<Optional>] ?ratios : double seq,
        [<Optional>] ?featureStride : int,
        [<Optional>] ?outputScore : bool,
        [<Optional>] ?iouLoss : bool) = 
        let operatorArguments = 
            [
                clsProb |> Option.map (fun x -> "cls_prob", Input x)
                bboxPred |> Option.map (fun x -> "bbox_pred", Input x)
                imInfo |> Option.map (fun x -> "im_info", Input x)
                rpnPreNmsTopN |> Option.map (fun x -> "rpn_pre_nms_top_n", Parameter(Some (box x)))
                rpnPostNmsTopN |> Option.map (fun x -> "rpn_post_nms_top_n", Parameter(Some (box x)))
                threshold |> Option.map (fun x -> "threshold", Parameter(Some (box x)))
                rpnMinSize |> Option.map (fun x -> "rpn_min_size", Parameter(Some (box x)))
                scales |> Option.map (fun x -> "scales", Parameter(Some (box x)))
                ratios |> Option.map (fun x -> "ratios", Parameter(Some (box x)))
                featureStride |> Option.map (fun x -> "feature_stride", Parameter(Some (box x)))
                outputScore |> Option.map (fun x -> "output_score", Parameter(Some (box x)))
                iouLoss |> Option.map (fun x -> "iou_loss", Parameter(Some (box x)))
            ] |> List.choose id
        new ContribMultiProposal(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type ContribProposal private (operatorArguments) = 
    inherit SymbolOperator("_contrib_Proposal", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new ContribProposal(args)
    override this.WithArguments(args : Arguments<Symbol>) = new ContribProposal(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <summary>Generate region proposals via RPN</summary>
    /// <param name="clsProb">Score of how likely proposal is object.</param>
    /// <param name="bboxPred">BBox Predicted deltas from anchors for proposals</param>
    /// <param name="imInfo">Image size and scale.</param>
    /// <param name="rpnPreNmsTopN">Number of top scoring boxes to keep before applying NMS to RPN proposals</param>
    /// <param name="rpnPostNmsTopN">Number of top scoring boxes to keep after applying NMS to RPN proposals</param>
    /// <param name="threshold">NMS value, below which to suppress.</param>
    /// <param name="rpnMinSize">Minimum height or width in proposal</param>
    /// <param name="scales">Used to generate anchor windows by enumerating scales</param>
    /// <param name="ratios">Used to generate anchor windows by enumerating ratios</param>
    /// <param name="featureStride">The size of the receptive field each unit in the convolution layer of the rpn,for example the product of all stride&#39;s prior to this layer.</param>
    /// <param name="outputScore">Add score to outputs</param>
    /// <param name="iouLoss">Usage of IoU Loss</param>
    new([<Optional>] ?clsProb : Symbol,
        [<Optional>] ?bboxPred : Symbol,
        [<Optional>] ?imInfo : Symbol,
        [<Optional>] ?rpnPreNmsTopN : int,
        [<Optional>] ?rpnPostNmsTopN : int,
        [<Optional>] ?threshold : float,
        [<Optional>] ?rpnMinSize : int,
        [<Optional>] ?scales : double seq,
        [<Optional>] ?ratios : double seq,
        [<Optional>] ?featureStride : int,
        [<Optional>] ?outputScore : bool,
        [<Optional>] ?iouLoss : bool) = 
        let clsProb = defaultArg clsProb (new ImplicitVariable() :> Symbol)
        let bboxPred = defaultArg bboxPred (new ImplicitVariable() :> Symbol)
        let imInfo = defaultArg imInfo (new ImplicitVariable() :> Symbol)
        let operatorArguments = 
            [
                "cls_prob", Input clsProb
                "bbox_pred", Input bboxPred
                "im_info", Input imInfo
                "rpn_pre_nms_top_n", rpnPreNmsTopN |> Option.map box |> Parameter
                "rpn_post_nms_top_n", rpnPostNmsTopN |> Option.map box |> Parameter
                "threshold", threshold |> Option.map box |> Parameter
                "rpn_min_size", rpnMinSize |> Option.map box |> Parameter
                "scales", scales |> Option.map box |> Parameter
                "ratios", ratios |> Option.map box |> Parameter
                "feature_stride", featureStride |> Option.map box |> Parameter
                "output_score", outputScore |> Option.map box |> Parameter
                "iou_loss", iouLoss |> Option.map box |> Parameter
            ]
        new ContribProposal(Arguments<Symbol>(operatorArguments))
    /// Default value for RpnPreNmsTopN
    /// Number of top scoring boxes to keep before applying NMS to RPN proposals
    static member RpnPreNmsTopNDefault : int = 6000
    /// Default value for RpnPostNmsTopN
    /// Number of top scoring boxes to keep after applying NMS to RPN proposals
    static member RpnPostNmsTopNDefault : int = 300
    /// Default value for Threshold
    /// NMS value, below which to suppress.
    static member ThresholdDefault : double = 0.699999988
    /// Default value for RpnMinSize
    /// Minimum height or width in proposal
    static member RpnMinSizeDefault : int = 16
    /// Default value for Scales
    /// Used to generate anchor windows by enumerating scales
    static member ScalesDefault : double [] = [|4.0; 8.0; 16.0; 32.0|]
    /// Default value for Ratios
    /// Used to generate anchor windows by enumerating ratios
    static member RatiosDefault : double [] = [|0.5; 1.0; 2.0|]
    /// Default value for FeatureStride
    /// The size of the receptive field each unit in the convolution layer of the rpn,for example the product of all stride&#39;s prior to this layer.
    static member FeatureStrideDefault : int = 16
    /// Default value for OutputScore
    /// Add score to outputs
    static member OutputScoreDefault : bool = false
    /// Default value for IouLoss
    /// Usage of IoU Loss
    static member IouLossDefault : bool = false
    /// Score of how likely proposal is object.
    member __.ClsProb = operatorArguments.GetInput "cls_prob"
    /// BBox Predicted deltas from anchors for proposals
    member __.BboxPred = operatorArguments.GetInput "bbox_pred"
    /// Image size and scale.
    member __.ImInfo = operatorArguments.GetInput "im_info"
    /// Number of top scoring boxes to keep before applying NMS to RPN proposals
    member __.RpnPreNmsTopN = operatorArguments.GetParameter("rpn_pre_nms_top_n", ContribProposal.RpnPreNmsTopNDefault)
    /// Number of top scoring boxes to keep after applying NMS to RPN proposals
    member __.RpnPostNmsTopN = operatorArguments.GetParameter("rpn_post_nms_top_n", ContribProposal.RpnPostNmsTopNDefault)
    /// NMS value, below which to suppress.
    member __.Threshold = operatorArguments.GetParameter("threshold", ContribProposal.ThresholdDefault)
    /// Minimum height or width in proposal
    member __.RpnMinSize = operatorArguments.GetParameter("rpn_min_size", ContribProposal.RpnMinSizeDefault)
    /// Used to generate anchor windows by enumerating scales
    member __.Scales = operatorArguments.GetParameter("scales", ContribProposal.ScalesDefault)
    /// Used to generate anchor windows by enumerating ratios
    member __.Ratios = operatorArguments.GetParameter("ratios", ContribProposal.RatiosDefault)
    /// The size of the receptive field each unit in the convolution layer of the rpn,for example the product of all stride&#39;s prior to this layer.
    member __.FeatureStride = operatorArguments.GetParameter("feature_stride", ContribProposal.FeatureStrideDefault)
    /// Add score to outputs
    member __.OutputScore = operatorArguments.GetParameter("output_score", ContribProposal.OutputScoreDefault)
    /// Usage of IoU Loss
    member __.IouLoss = operatorArguments.GetParameter("iou_loss", ContribProposal.IouLossDefault)
    /// <summary>Copy ContribProposal instance with updated inputs/parameters.</summary>
    /// <param name="clsProb">Score of how likely proposal is object.</param>
    /// <param name="bboxPred">BBox Predicted deltas from anchors for proposals</param>
    /// <param name="imInfo">Image size and scale.</param>
    /// <param name="rpnPreNmsTopN">Number of top scoring boxes to keep before applying NMS to RPN proposals</param>
    /// <param name="rpnPostNmsTopN">Number of top scoring boxes to keep after applying NMS to RPN proposals</param>
    /// <param name="threshold">NMS value, below which to suppress.</param>
    /// <param name="rpnMinSize">Minimum height or width in proposal</param>
    /// <param name="scales">Used to generate anchor windows by enumerating scales</param>
    /// <param name="ratios">Used to generate anchor windows by enumerating ratios</param>
    /// <param name="featureStride">The size of the receptive field each unit in the convolution layer of the rpn,for example the product of all stride&#39;s prior to this layer.</param>
    /// <param name="outputScore">Add score to outputs</param>
    /// <param name="iouLoss">Usage of IoU Loss</param>
    member this.With([<Optional>] ?clsProb : Symbol,
        [<Optional>] ?bboxPred : Symbol,
        [<Optional>] ?imInfo : Symbol,
        [<Optional>] ?rpnPreNmsTopN : int,
        [<Optional>] ?rpnPostNmsTopN : int,
        [<Optional>] ?threshold : float,
        [<Optional>] ?rpnMinSize : int,
        [<Optional>] ?scales : double seq,
        [<Optional>] ?ratios : double seq,
        [<Optional>] ?featureStride : int,
        [<Optional>] ?outputScore : bool,
        [<Optional>] ?iouLoss : bool) = 
        let operatorArguments = 
            [
                clsProb |> Option.map (fun x -> "cls_prob", Input x)
                bboxPred |> Option.map (fun x -> "bbox_pred", Input x)
                imInfo |> Option.map (fun x -> "im_info", Input x)
                rpnPreNmsTopN |> Option.map (fun x -> "rpn_pre_nms_top_n", Parameter(Some (box x)))
                rpnPostNmsTopN |> Option.map (fun x -> "rpn_post_nms_top_n", Parameter(Some (box x)))
                threshold |> Option.map (fun x -> "threshold", Parameter(Some (box x)))
                rpnMinSize |> Option.map (fun x -> "rpn_min_size", Parameter(Some (box x)))
                scales |> Option.map (fun x -> "scales", Parameter(Some (box x)))
                ratios |> Option.map (fun x -> "ratios", Parameter(Some (box x)))
                featureStride |> Option.map (fun x -> "feature_stride", Parameter(Some (box x)))
                outputScore |> Option.map (fun x -> "output_score", Parameter(Some (box x)))
                iouLoss |> Option.map (fun x -> "iou_loss", Parameter(Some (box x)))
            ] |> List.choose id
        new ContribProposal(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type ContribPSROIPooling private (operatorArguments) = 
    inherit SymbolOperator("_contrib_PSROIPooling", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new ContribPSROIPooling(args)
    override this.WithArguments(args : Arguments<Symbol>) = new ContribPSROIPooling(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <summary>Performs region-of-interest pooling on inputs. Resize bounding box coordinates by spatial_scale and crop input feature maps accordingly. The cropped feature maps are pooled by max pooling to a fixed size output indicated by pooled_size. batch_size will change to the number of region bounding boxes after PSROIPooling</summary>
    /// <param name="data">Input data to the pooling operator, a 4D Feature maps</param>
    /// <param name="rois">Bounding box coordinates, a 2D array of [[batch_index, x1, y1, x2, y2]]. (x1, y1) and (x2, y2) are top left and down right corners of designated region of interest. batch_index indicates the index of corresponding image in the input data</param>
    /// <param name="spatialScale">Ratio of input feature map height (or w) to raw image height (or w). Equals the reciprocal of total stride in convolutional layers</param>
    /// <param name="outputDim">fix output dim</param>
    /// <param name="pooledSize">fix pooled size</param>
    /// <param name="groupSize">fix group size</param>
    new(data : Symbol,
        rois : Symbol,
        spatialScale : float,
        outputDim : int,
        pooledSize : int,
        [<Optional>] ?groupSize : int) = 
        let operatorArguments = 
            [
                "data", Input data
                "rois", Input rois
                "spatial_scale", Parameter(Some(box spatialScale))
                "output_dim", Parameter(Some(box outputDim))
                "pooled_size", Parameter(Some(box pooledSize))
                "group_size", groupSize |> Option.map box |> Parameter
            ]
        new ContribPSROIPooling(Arguments<Symbol>(operatorArguments))
    /// <summary>Performs region-of-interest pooling on inputs. Resize bounding box coordinates by spatial_scale and crop input feature maps accordingly. The cropped feature maps are pooled by max pooling to a fixed size output indicated by pooled_size. batch_size will change to the number of region bounding boxes after PSROIPooling</summary>
    /// <param name="spatialScale">Ratio of input feature map height (or w) to raw image height (or w). Equals the reciprocal of total stride in convolutional layers</param>
    /// <param name="outputDim">fix output dim</param>
    /// <param name="pooledSize">fix pooled size</param>
    /// <param name="data">Input data to the pooling operator, a 4D Feature maps</param>
    /// <param name="rois">Bounding box coordinates, a 2D array of [[batch_index, x1, y1, x2, y2]]. (x1, y1) and (x2, y2) are top left and down right corners of designated region of interest. batch_index indicates the index of corresponding image in the input data</param>
    /// <param name="groupSize">fix group size</param>
    new(spatialScale : float,
        outputDim : int,
        pooledSize : int,
        [<Optional>] ?data : Symbol,
        [<Optional>] ?rois : Symbol,
        [<Optional>] ?groupSize : int) = 
        let data = defaultArg data (new ImplicitVariable() :> Symbol)
        let rois = defaultArg rois (new ImplicitVariable() :> Symbol)
        let operatorArguments = 
            [
                "data", Input data
                "rois", Input rois
                "spatial_scale", Parameter(Some(box spatialScale))
                "output_dim", Parameter(Some(box outputDim))
                "pooled_size", Parameter(Some(box pooledSize))
                "group_size", groupSize |> Option.map box |> Parameter
            ]
        new ContribPSROIPooling(Arguments<Symbol>(operatorArguments))
    /// Default value for GroupSize
    /// fix group size
    static member GroupSizeDefault : int = 0
    /// Input data to the pooling operator, a 4D Feature maps
    member __.Data = operatorArguments.GetInput "data"
    /// Bounding box coordinates, a 2D array of [[batch_index, x1, y1, x2, y2]]. (x1, y1) and (x2, y2) are top left and down right corners of designated region of interest. batch_index indicates the index of corresponding image in the input data
    member __.Rois = operatorArguments.GetInput "rois"
    /// Ratio of input feature map height (or w) to raw image height (or w). Equals the reciprocal of total stride in convolutional layers
    member __.SpatialScale : float = match operatorArguments.GetParameter "spatial_scale" with Some(v) -> unbox v | None -> failwithf "Required parameter spatial_scale is missing"
    /// fix output dim
    member __.OutputDim : int = match operatorArguments.GetParameter "output_dim" with Some(v) -> unbox v | None -> failwithf "Required parameter output_dim is missing"
    /// fix pooled size
    member __.PooledSize : int = match operatorArguments.GetParameter "pooled_size" with Some(v) -> unbox v | None -> failwithf "Required parameter pooled_size is missing"
    /// fix group size
    member __.GroupSize = operatorArguments.GetParameter("group_size", ContribPSROIPooling.GroupSizeDefault)
    /// <summary>Copy ContribPSROIPooling instance with updated inputs/parameters.</summary>
    /// <param name="data">Input data to the pooling operator, a 4D Feature maps</param>
    /// <param name="rois">Bounding box coordinates, a 2D array of [[batch_index, x1, y1, x2, y2]]. (x1, y1) and (x2, y2) are top left and down right corners of designated region of interest. batch_index indicates the index of corresponding image in the input data</param>
    /// <param name="spatialScale">Ratio of input feature map height (or w) to raw image height (or w). Equals the reciprocal of total stride in convolutional layers</param>
    /// <param name="outputDim">fix output dim</param>
    /// <param name="pooledSize">fix pooled size</param>
    /// <param name="groupSize">fix group size</param>
    member this.With([<Optional>] ?data : Symbol,
        [<Optional>] ?rois : Symbol,
        [<Optional>] ?spatialScale : float,
        [<Optional>] ?outputDim : int,
        [<Optional>] ?pooledSize : int,
        [<Optional>] ?groupSize : int) = 
        let operatorArguments = 
            [
                data |> Option.map (fun x -> "data", Input x)
                rois |> Option.map (fun x -> "rois", Input x)
                spatialScale |> Option.map (fun x -> "spatial_scale", Parameter(Some (box x)))
                outputDim |> Option.map (fun x -> "output_dim", Parameter(Some (box x)))
                pooledSize |> Option.map (fun x -> "pooled_size", Parameter(Some (box x)))
                groupSize |> Option.map (fun x -> "group_size", Parameter(Some (box x)))
            ] |> List.choose id
        new ContribPSROIPooling(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type ConvolutionV1 private (operatorArguments) = 
    inherit SymbolOperator("Convolution_v1", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new ConvolutionV1(args)
    override this.WithArguments(args : Arguments<Symbol>) = new ConvolutionV1(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <summary>This operator is DEPRECATED. Apply convolution to input then add a bias.</summary>
    /// <param name="data">Input data to the ConvolutionV1Op.</param>
    /// <param name="weight">Weight matrix.</param>
    /// <param name="bias">Bias parameter.</param>
    /// <param name="kernel">convolution kernel size: (h, w) or (d, h, w)</param>
    /// <param name="numFilter">convolution filter(channel) number</param>
    /// <param name="stride">convolution stride: (h, w) or (d, h, w)</param>
    /// <param name="dilate">convolution dilate: (h, w) or (d, h, w)</param>
    /// <param name="pad">pad for convolution: (h, w) or (d, h, w)</param>
    /// <param name="numGroup">Number of group partitions. Equivalent to slicing input into num_group
    ///     partitions, apply convolution on each, then concatenate the results</param>
    /// <param name="workspace">Maximum temporary workspace allowed for convolution (MB).This parameter determines the effective batch size of the convolution kernel, which may be smaller than the given batch size. Also, the workspace will be automatically enlarged to make sure that we can run the kernel with batch_size=1</param>
    /// <param name="noBias">Whether to disable bias parameter.</param>
    /// <param name="cudnnTune">Whether to pick convolution algo by running performance test.
    ///     Leads to higher startup time but may give faster speed. Options are:
    ///     &#39;off&#39;: no tuning
    ///     &#39;limited_workspace&#39;: run test and pick the fastest algorithm that doesn&#39;t exceed workspace limit.
    ///     &#39;fastest&#39;: pick the fastest algorithm and ignore workspace limit.
    ///     If set to None (default), behavior is determined by environment
    ///     variable MXNET_CUDNN_AUTOTUNE_DEFAULT: 0 for off,
    ///     1 for limited workspace (default), 2 for fastest.</param>
    /// <param name="cudnnOff">Turn off cudnn for this layer.</param>
    /// <param name="layout">Set layout for input, output and weight. Empty for
    ///     default layout: NCHW for 2d and NCDHW for 3d.</param>
    new(data : Symbol,
        weight : Symbol,
        bias : Symbol,
        kernel : int seq,
        numFilter : int,
        [<Optional>] ?stride : int seq,
        [<Optional>] ?dilate : int seq,
        [<Optional>] ?pad : int seq,
        [<Optional>] ?numGroup : int,
        [<Optional>] ?workspace : int64,
        [<Optional>] ?noBias : bool,
        [<Optional>] ?cudnnTune : CudnnTune,
        [<Optional>] ?cudnnOff : bool,
        [<Optional>] ?layout : ConvolutionV1Layout) = 
        let operatorArguments = 
            [
                "data", Input data
                "weight", Input weight
                "bias", Input bias
                "kernel", Parameter(Some(box kernel))
                "num_filter", Parameter(Some(box numFilter))
                "stride", stride |> Option.map box |> Parameter
                "dilate", dilate |> Option.map box |> Parameter
                "pad", pad |> Option.map box |> Parameter
                "num_group", numGroup |> Option.map box |> Parameter
                "workspace", workspace |> Option.map box |> Parameter
                "no_bias", noBias |> Option.map box |> Parameter
                "cudnn_tune", cudnnTune |> Option.map box |> Parameter
                "cudnn_off", cudnnOff |> Option.map box |> Parameter
                "layout", layout |> Option.map box |> Parameter
            ]
        new ConvolutionV1(Arguments<Symbol>(operatorArguments))
    /// <summary>This operator is DEPRECATED. Apply convolution to input then add a bias.</summary>
    /// <param name="kernel">convolution kernel size: (h, w) or (d, h, w)</param>
    /// <param name="numFilter">convolution filter(channel) number</param>
    /// <param name="data">Input data to the ConvolutionV1Op.</param>
    /// <param name="weight">Weight matrix.</param>
    /// <param name="bias">Bias parameter.</param>
    /// <param name="stride">convolution stride: (h, w) or (d, h, w)</param>
    /// <param name="dilate">convolution dilate: (h, w) or (d, h, w)</param>
    /// <param name="pad">pad for convolution: (h, w) or (d, h, w)</param>
    /// <param name="numGroup">Number of group partitions. Equivalent to slicing input into num_group
    ///     partitions, apply convolution on each, then concatenate the results</param>
    /// <param name="workspace">Maximum temporary workspace allowed for convolution (MB).This parameter determines the effective batch size of the convolution kernel, which may be smaller than the given batch size. Also, the workspace will be automatically enlarged to make sure that we can run the kernel with batch_size=1</param>
    /// <param name="noBias">Whether to disable bias parameter.</param>
    /// <param name="cudnnTune">Whether to pick convolution algo by running performance test.
    ///     Leads to higher startup time but may give faster speed. Options are:
    ///     &#39;off&#39;: no tuning
    ///     &#39;limited_workspace&#39;: run test and pick the fastest algorithm that doesn&#39;t exceed workspace limit.
    ///     &#39;fastest&#39;: pick the fastest algorithm and ignore workspace limit.
    ///     If set to None (default), behavior is determined by environment
    ///     variable MXNET_CUDNN_AUTOTUNE_DEFAULT: 0 for off,
    ///     1 for limited workspace (default), 2 for fastest.</param>
    /// <param name="cudnnOff">Turn off cudnn for this layer.</param>
    /// <param name="layout">Set layout for input, output and weight. Empty for
    ///     default layout: NCHW for 2d and NCDHW for 3d.</param>
    new(kernel : int seq,
        numFilter : int,
        [<Optional>] ?data : Symbol,
        [<Optional>] ?weight : Symbol,
        [<Optional>] ?bias : Symbol,
        [<Optional>] ?stride : int seq,
        [<Optional>] ?dilate : int seq,
        [<Optional>] ?pad : int seq,
        [<Optional>] ?numGroup : int,
        [<Optional>] ?workspace : int64,
        [<Optional>] ?noBias : bool,
        [<Optional>] ?cudnnTune : CudnnTune,
        [<Optional>] ?cudnnOff : bool,
        [<Optional>] ?layout : ConvolutionV1Layout) = 
        let data = defaultArg data (new ImplicitVariable() :> Symbol)
        let weight = defaultArg weight (new ImplicitVariable() :> Symbol)
        let bias = defaultArg bias (new ImplicitVariable() :> Symbol)
        let operatorArguments = 
            [
                "data", Input data
                "weight", Input weight
                "bias", Input bias
                "kernel", Parameter(Some(box kernel))
                "num_filter", Parameter(Some(box numFilter))
                "stride", stride |> Option.map box |> Parameter
                "dilate", dilate |> Option.map box |> Parameter
                "pad", pad |> Option.map box |> Parameter
                "num_group", numGroup |> Option.map box |> Parameter
                "workspace", workspace |> Option.map box |> Parameter
                "no_bias", noBias |> Option.map box |> Parameter
                "cudnn_tune", cudnnTune |> Option.map box |> Parameter
                "cudnn_off", cudnnOff |> Option.map box |> Parameter
                "layout", layout |> Option.map box |> Parameter
            ]
        new ConvolutionV1(Arguments<Symbol>(operatorArguments))
    /// Default value for Stride
    /// convolution stride: (h, w) or (d, h, w)
    static member StrideDefault : int [] = [||]
    /// Default value for Dilate
    /// convolution dilate: (h, w) or (d, h, w)
    static member DilateDefault : int [] = [||]
    /// Default value for Pad
    /// pad for convolution: (h, w) or (d, h, w)
    static member PadDefault : int [] = [||]
    /// Default value for NumGroup
    /// Number of group partitions. Equivalent to slicing input into num_group
    ///     partitions, apply convolution on each, then concatenate the results
    static member NumGroupDefault : int = 1
    /// Default value for Workspace
    /// Maximum temporary workspace allowed for convolution (MB).This parameter determines the effective batch size of the convolution kernel, which may be smaller than the given batch size. Also, the workspace will be automatically enlarged to make sure that we can run the kernel with batch_size=1
    static member WorkspaceDefault : int64 = 1024L
    /// Default value for NoBias
    /// Whether to disable bias parameter.
    static member NoBiasDefault : bool = false
    /// Default value for CudnnTune
    /// Whether to pick convolution algo by running performance test.
    ///     Leads to higher startup time but may give faster speed. Options are:
    ///     &#39;off&#39;: no tuning
    ///     &#39;limited_workspace&#39;: run test and pick the fastest algorithm that doesn&#39;t exceed workspace limit.
    ///     &#39;fastest&#39;: pick the fastest algorithm and ignore workspace limit.
    ///     If set to None (default), behavior is determined by environment
    ///     variable MXNET_CUDNN_AUTOTUNE_DEFAULT: 0 for off,
    ///     1 for limited workspace (default), 2 for fastest.
    static member CudnnTuneDefault : CudnnTune option = None
    /// Default value for CudnnOff
    /// Turn off cudnn for this layer.
    static member CudnnOffDefault : bool = false
    /// Default value for Layout
    /// Set layout for input, output and weight. Empty for
    ///     default layout: NCHW for 2d and NCDHW for 3d.
    static member LayoutDefault : ConvolutionV1Layout option = None
    /// Input data to the ConvolutionV1Op.
    member __.Data = operatorArguments.GetInput "data"
    /// Weight matrix.
    member __.Weight = operatorArguments.GetInput "weight"
    /// Bias parameter.
    member __.Bias = operatorArguments.GetInput "bias"
    /// convolution kernel size: (h, w) or (d, h, w)
    member __.Kernel : int seq = match operatorArguments.GetParameter "kernel" with Some(v) -> unbox v | None -> failwithf "Required parameter kernel is missing"
    /// convolution filter(channel) number
    member __.NumFilter : int = match operatorArguments.GetParameter "num_filter" with Some(v) -> unbox v | None -> failwithf "Required parameter num_filter is missing"
    /// convolution stride: (h, w) or (d, h, w)
    member __.Stride = operatorArguments.GetParameter("stride", ConvolutionV1.StrideDefault)
    /// convolution dilate: (h, w) or (d, h, w)
    member __.Dilate = operatorArguments.GetParameter("dilate", ConvolutionV1.DilateDefault)
    /// pad for convolution: (h, w) or (d, h, w)
    member __.Pad = operatorArguments.GetParameter("pad", ConvolutionV1.PadDefault)
    /// Number of group partitions. Equivalent to slicing input into num_group
    ///     partitions, apply convolution on each, then concatenate the results
    member __.NumGroup = operatorArguments.GetParameter("num_group", ConvolutionV1.NumGroupDefault)
    /// Maximum temporary workspace allowed for convolution (MB).This parameter determines the effective batch size of the convolution kernel, which may be smaller than the given batch size. Also, the workspace will be automatically enlarged to make sure that we can run the kernel with batch_size=1
    member __.Workspace = operatorArguments.GetParameter("workspace", ConvolutionV1.WorkspaceDefault)
    /// Whether to disable bias parameter.
    member __.NoBias = operatorArguments.GetParameter("no_bias", ConvolutionV1.NoBiasDefault)
    /// Whether to pick convolution algo by running performance test.
    ///     Leads to higher startup time but may give faster speed. Options are:
    ///     &#39;off&#39;: no tuning
    ///     &#39;limited_workspace&#39;: run test and pick the fastest algorithm that doesn&#39;t exceed workspace limit.
    ///     &#39;fastest&#39;: pick the fastest algorithm and ignore workspace limit.
    ///     If set to None (default), behavior is determined by environment
    ///     variable MXNET_CUDNN_AUTOTUNE_DEFAULT: 0 for off,
    ///     1 for limited workspace (default), 2 for fastest.
    member __.CudnnTune = operatorArguments.GetParameter("cudnn_tune", ConvolutionV1.CudnnTuneDefault)
    /// Turn off cudnn for this layer.
    member __.CudnnOff = operatorArguments.GetParameter("cudnn_off", ConvolutionV1.CudnnOffDefault)
    /// Set layout for input, output and weight. Empty for
    ///     default layout: NCHW for 2d and NCDHW for 3d.
    member __.Layout = operatorArguments.GetParameter("layout", ConvolutionV1.LayoutDefault)
    /// <summary>Copy ConvolutionV1 instance with updated inputs/parameters.</summary>
    /// <param name="data">Input data to the ConvolutionV1Op.</param>
    /// <param name="weight">Weight matrix.</param>
    /// <param name="bias">Bias parameter.</param>
    /// <param name="kernel">convolution kernel size: (h, w) or (d, h, w)</param>
    /// <param name="numFilter">convolution filter(channel) number</param>
    /// <param name="stride">convolution stride: (h, w) or (d, h, w)</param>
    /// <param name="dilate">convolution dilate: (h, w) or (d, h, w)</param>
    /// <param name="pad">pad for convolution: (h, w) or (d, h, w)</param>
    /// <param name="numGroup">Number of group partitions. Equivalent to slicing input into num_group
    ///     partitions, apply convolution on each, then concatenate the results</param>
    /// <param name="workspace">Maximum temporary workspace allowed for convolution (MB).This parameter determines the effective batch size of the convolution kernel, which may be smaller than the given batch size. Also, the workspace will be automatically enlarged to make sure that we can run the kernel with batch_size=1</param>
    /// <param name="noBias">Whether to disable bias parameter.</param>
    /// <param name="cudnnTune">Whether to pick convolution algo by running performance test.
    ///     Leads to higher startup time but may give faster speed. Options are:
    ///     &#39;off&#39;: no tuning
    ///     &#39;limited_workspace&#39;: run test and pick the fastest algorithm that doesn&#39;t exceed workspace limit.
    ///     &#39;fastest&#39;: pick the fastest algorithm and ignore workspace limit.
    ///     If set to None (default), behavior is determined by environment
    ///     variable MXNET_CUDNN_AUTOTUNE_DEFAULT: 0 for off,
    ///     1 for limited workspace (default), 2 for fastest.</param>
    /// <param name="cudnnOff">Turn off cudnn for this layer.</param>
    /// <param name="layout">Set layout for input, output and weight. Empty for
    ///     default layout: NCHW for 2d and NCDHW for 3d.</param>
    member this.With([<Optional>] ?data : Symbol,
        [<Optional>] ?weight : Symbol,
        [<Optional>] ?bias : Symbol,
        [<Optional>] ?kernel : int seq,
        [<Optional>] ?numFilter : int,
        [<Optional>] ?stride : int seq,
        [<Optional>] ?dilate : int seq,
        [<Optional>] ?pad : int seq,
        [<Optional>] ?numGroup : int,
        [<Optional>] ?workspace : int64,
        [<Optional>] ?noBias : bool,
        [<Optional>] ?cudnnTune : CudnnTune,
        [<Optional>] ?cudnnOff : bool,
        [<Optional>] ?layout : ConvolutionV1Layout) = 
        let operatorArguments = 
            [
                data |> Option.map (fun x -> "data", Input x)
                weight |> Option.map (fun x -> "weight", Input x)
                bias |> Option.map (fun x -> "bias", Input x)
                kernel |> Option.map (fun x -> "kernel", Parameter(Some (box x)))
                numFilter |> Option.map (fun x -> "num_filter", Parameter(Some (box x)))
                stride |> Option.map (fun x -> "stride", Parameter(Some (box x)))
                dilate |> Option.map (fun x -> "dilate", Parameter(Some (box x)))
                pad |> Option.map (fun x -> "pad", Parameter(Some (box x)))
                numGroup |> Option.map (fun x -> "num_group", Parameter(Some (box x)))
                workspace |> Option.map (fun x -> "workspace", Parameter(Some (box x)))
                noBias |> Option.map (fun x -> "no_bias", Parameter(Some (box x)))
                cudnnTune |> Option.map (fun x -> "cudnn_tune", Parameter(Some (box x)))
                cudnnOff |> Option.map (fun x -> "cudnn_off", Parameter(Some (box x)))
                layout |> Option.map (fun x -> "layout", Parameter(Some (box x)))
            ] |> List.choose id
        new ConvolutionV1(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type Correlation private (operatorArguments) = 
    inherit SymbolOperator("Correlation", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new Correlation(args)
    override this.WithArguments(args : Arguments<Symbol>) = new Correlation(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <summary>Applies correlation to inputs.
    /// 
    /// The correlation layer performs multiplicative patch comparisons between two feature maps.
    /// 
    /// Given two multi-channel feature maps :math:`f_{1}, f_{2}`, with :math:`w`, :math:`h`, and :math:`c` being their width, height, and number of channels,
    /// the correlation layer lets the network compare each patch from :math:`f_{1}` with each patch from :math:`f_{2}`.
    /// 
    /// For now we consider only a single comparison of two patches. The &#39;correlation&#39; of two patches centered at :math:`x_{1}` in the first map and
    /// :math:`x_{2}` in the second map is then defined as:
    /// 
    /// .. math::
    /// 
    ///    c(x_{1}, x_{2}) = \sum_{o \in [-k,k] \times [-k,k]} &lt;f_{1}(x_{1} + o), f_{2}(x_{2} + o)&gt;
    /// 
    /// for a square patch of size :math:`K:=2k+1`.
    /// 
    /// Note that the equation above is identical to one step of a convolution in neural networks, but instead of convolving data with a filter, it convolves data with other
    /// data. For this reason, it has no training weights.
    /// 
    /// Computing :math:`c(x_{1}, x_{2})` involves :math:`c * K^{2}` multiplications. Comparing all patch combinations involves :math:`w^{2}*h^{2}` such computations.
    /// 
    /// Given a maximum displacement :math:`d`, for each location :math:`x_{1}` it computes correlations :math:`c(x_{1}, x_{2})` only in a neighborhood of size :math:`D:=2d+1`,
    /// by limiting the range of :math:`x_{2}`. We use strides :math:`s_{1}, s_{2}`, to quantize :math:`x_{1}` globally and to quantize :math:`x_{2}` within the neighborhood
    /// centered around :math:`x_{1}`.
    /// 
    /// The final output is defined by the following expression:
    /// 
    /// .. math::
    ///   out[n, q, i, j] = c(x_{i, j}, x_{q})
    /// 
    /// where :math:`i` and :math:`j` enumerate spatial locations in :math:`f_{1}`, and :math:`q` denotes the :math:`q^{th}` neighborhood of :math:`x_{i,j}`.
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\correlation.cc:L198</summary>
    /// <param name="data1">Input data1 to the correlation.</param>
    /// <param name="data2">Input data2 to the correlation.</param>
    /// <param name="kernelSize">kernel size for Correlation must be an odd number</param>
    /// <param name="maxDisplacement">Max displacement of Correlation </param>
    /// <param name="stride1">stride1 quantize data1 globally</param>
    /// <param name="stride2">stride2 quantize data2 within the neighborhood centered around data1</param>
    /// <param name="padSize">pad for Correlation</param>
    /// <param name="isMultiply">operation type is either multiplication or subduction</param>
    new([<Optional>] ?data1 : Symbol,
        [<Optional>] ?data2 : Symbol,
        [<Optional>] ?kernelSize : int,
        [<Optional>] ?maxDisplacement : int,
        [<Optional>] ?stride1 : int,
        [<Optional>] ?stride2 : int,
        [<Optional>] ?padSize : int,
        [<Optional>] ?isMultiply : bool) = 
        let data1 = defaultArg data1 (new ImplicitVariable() :> Symbol)
        let data2 = defaultArg data2 (new ImplicitVariable() :> Symbol)
        let operatorArguments = 
            [
                "data1", Input data1
                "data2", Input data2
                "kernel_size", kernelSize |> Option.map box |> Parameter
                "max_displacement", maxDisplacement |> Option.map box |> Parameter
                "stride1", stride1 |> Option.map box |> Parameter
                "stride2", stride2 |> Option.map box |> Parameter
                "pad_size", padSize |> Option.map box |> Parameter
                "is_multiply", isMultiply |> Option.map box |> Parameter
            ]
        new Correlation(Arguments<Symbol>(operatorArguments))
    /// Default value for KernelSize
    /// kernel size for Correlation must be an odd number
    static member KernelSizeDefault : int = 1
    /// Default value for MaxDisplacement
    /// Max displacement of Correlation 
    static member MaxDisplacementDefault : int = 1
    /// Default value for Stride1
    /// stride1 quantize data1 globally
    static member Stride1Default : int = 1
    /// Default value for Stride2
    /// stride2 quantize data2 within the neighborhood centered around data1
    static member Stride2Default : int = 1
    /// Default value for PadSize
    /// pad for Correlation
    static member PadSizeDefault : int = 0
    /// Default value for IsMultiply
    /// operation type is either multiplication or subduction
    static member IsMultiplyDefault : bool = true
    /// Input data1 to the correlation.
    member __.Data1 = operatorArguments.GetInput "data1"
    /// Input data2 to the correlation.
    member __.Data2 = operatorArguments.GetInput "data2"
    /// kernel size for Correlation must be an odd number
    member __.KernelSize = operatorArguments.GetParameter("kernel_size", Correlation.KernelSizeDefault)
    /// Max displacement of Correlation 
    member __.MaxDisplacement = operatorArguments.GetParameter("max_displacement", Correlation.MaxDisplacementDefault)
    /// stride1 quantize data1 globally
    member __.Stride1 = operatorArguments.GetParameter("stride1", Correlation.Stride1Default)
    /// stride2 quantize data2 within the neighborhood centered around data1
    member __.Stride2 = operatorArguments.GetParameter("stride2", Correlation.Stride2Default)
    /// pad for Correlation
    member __.PadSize = operatorArguments.GetParameter("pad_size", Correlation.PadSizeDefault)
    /// operation type is either multiplication or subduction
    member __.IsMultiply = operatorArguments.GetParameter("is_multiply", Correlation.IsMultiplyDefault)
    /// <summary>Copy Correlation instance with updated inputs/parameters.</summary>
    /// <param name="data1">Input data1 to the correlation.</param>
    /// <param name="data2">Input data2 to the correlation.</param>
    /// <param name="kernelSize">kernel size for Correlation must be an odd number</param>
    /// <param name="maxDisplacement">Max displacement of Correlation </param>
    /// <param name="stride1">stride1 quantize data1 globally</param>
    /// <param name="stride2">stride2 quantize data2 within the neighborhood centered around data1</param>
    /// <param name="padSize">pad for Correlation</param>
    /// <param name="isMultiply">operation type is either multiplication or subduction</param>
    member this.With([<Optional>] ?data1 : Symbol,
        [<Optional>] ?data2 : Symbol,
        [<Optional>] ?kernelSize : int,
        [<Optional>] ?maxDisplacement : int,
        [<Optional>] ?stride1 : int,
        [<Optional>] ?stride2 : int,
        [<Optional>] ?padSize : int,
        [<Optional>] ?isMultiply : bool) = 
        let operatorArguments = 
            [
                data1 |> Option.map (fun x -> "data1", Input x)
                data2 |> Option.map (fun x -> "data2", Input x)
                kernelSize |> Option.map (fun x -> "kernel_size", Parameter(Some (box x)))
                maxDisplacement |> Option.map (fun x -> "max_displacement", Parameter(Some (box x)))
                stride1 |> Option.map (fun x -> "stride1", Parameter(Some (box x)))
                stride2 |> Option.map (fun x -> "stride2", Parameter(Some (box x)))
                padSize |> Option.map (fun x -> "pad_size", Parameter(Some (box x)))
                isMultiply |> Option.map (fun x -> "is_multiply", Parameter(Some (box x)))
            ] |> List.choose id
        new Correlation(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type CrossDeviceCopy private (operatorArguments) = 
    inherit SymbolOperator("_CrossDeviceCopy", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new CrossDeviceCopy(args)
    override this.WithArguments(args : Arguments<Symbol>) = new CrossDeviceCopy(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <summary>Special op to copy data cross device</summary>
    new() =
        let operatorArguments = 
            [
            ]
        new CrossDeviceCopy(Arguments<Symbol>(operatorArguments))

type GridGenerator private (operatorArguments) = 
    inherit SymbolOperator("GridGenerator", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new GridGenerator(args)
    override this.WithArguments(args : Arguments<Symbol>) = new GridGenerator(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <summary>Generates 2D sampling grid for bilinear sampling.</summary>
    /// <param name="data">Input data to the function.</param>
    /// <param name="transformType">The type of transformation. For `affine`, input data should be an affine matrix of size (batch, 6). For `warp`, input data should be an optical flow of size (batch, 2, h, w).</param>
    /// <param name="targetShape">Specifies the output shape (H, W). This is required if transformation type is `affine`. If transformation type is `warp`, this parameter is ignored.</param>
    new(data : Symbol,
        transformType : GridGeneratorTransformType,
        [<Optional>] ?targetShape : int seq) = 
        let operatorArguments = 
            [
                "data", Input data
                "transform_type", Parameter(Some(box transformType))
                "target_shape", targetShape |> Option.map box |> Parameter
            ]
        new GridGenerator(Arguments<Symbol>(operatorArguments))
    /// <summary>Generates 2D sampling grid for bilinear sampling.</summary>
    /// <param name="transformType">The type of transformation. For `affine`, input data should be an affine matrix of size (batch, 6). For `warp`, input data should be an optical flow of size (batch, 2, h, w).</param>
    /// <param name="data">Input data to the function.</param>
    /// <param name="targetShape">Specifies the output shape (H, W). This is required if transformation type is `affine`. If transformation type is `warp`, this parameter is ignored.</param>
    new(transformType : GridGeneratorTransformType,
        [<Optional>] ?data : Symbol,
        [<Optional>] ?targetShape : int seq) = 
        let data = defaultArg data (new ImplicitVariable() :> Symbol)
        let operatorArguments = 
            [
                "data", Input data
                "transform_type", Parameter(Some(box transformType))
                "target_shape", targetShape |> Option.map box |> Parameter
            ]
        new GridGenerator(Arguments<Symbol>(operatorArguments))
    /// Default value for TargetShape
    /// Specifies the output shape (H, W). This is required if transformation type is `affine`. If transformation type is `warp`, this parameter is ignored.
    static member TargetShapeDefault : int [] = [|0; 0|]
    /// Input data to the function.
    member __.Data = operatorArguments.GetInput "data"
    /// The type of transformation. For `affine`, input data should be an affine matrix of size (batch, 6). For `warp`, input data should be an optical flow of size (batch, 2, h, w).
    member __.TransformType : GridGeneratorTransformType = match operatorArguments.GetParameter "transform_type" with Some(v) -> unbox v | None -> failwithf "Required parameter transform_type is missing"
    /// Specifies the output shape (H, W). This is required if transformation type is `affine`. If transformation type is `warp`, this parameter is ignored.
    member __.TargetShape = operatorArguments.GetParameter("target_shape", GridGenerator.TargetShapeDefault)
    /// <summary>Copy GridGenerator instance with updated inputs/parameters.</summary>
    /// <param name="data">Input data to the function.</param>
    /// <param name="transformType">The type of transformation. For `affine`, input data should be an affine matrix of size (batch, 6). For `warp`, input data should be an optical flow of size (batch, 2, h, w).</param>
    /// <param name="targetShape">Specifies the output shape (H, W). This is required if transformation type is `affine`. If transformation type is `warp`, this parameter is ignored.</param>
    member this.With([<Optional>] ?data : Symbol,
        [<Optional>] ?transformType : GridGeneratorTransformType,
        [<Optional>] ?targetShape : int seq) = 
        let operatorArguments = 
            [
                data |> Option.map (fun x -> "data", Input x)
                transformType |> Option.map (fun x -> "transform_type", Parameter(Some (box x)))
                targetShape |> Option.map (fun x -> "target_shape", Parameter(Some (box x)))
            ] |> List.choose id
        new GridGenerator(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type InstanceNorm private (operatorArguments) = 
    inherit SymbolOperator("InstanceNorm", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new InstanceNorm(args)
    override this.WithArguments(args : Arguments<Symbol>) = new InstanceNorm(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <summary>Applies instance normalization to the n-dimensional input array.
    /// 
    /// This operator takes an n-dimensional input array where (n&gt;2) and normalizes
    /// the input using the following formula:
    /// 
    /// .. math::
    /// 
    ///   out = \frac{x - mean[data]}{ \sqrt{Var[data]} + \epsilon} * gamma + beta
    /// 
    /// This layer is similar to batch normalization layer (`BatchNorm`)
    /// with two differences: first, the normalization is
    /// carried out per example (instance), not over a batch. Second, the
    /// same normalization is applied both at test and train time. This
    /// operation is also known as `contrast normalization`.
    /// 
    /// If the input data is of shape [batch, channel, spacial_dim1, spacial_dim2, ...],
    /// `gamma` and `beta` parameters must be vectors of shape [channel].
    /// 
    /// This implementation is based on paper:
    /// 
    /// .. [1] Instance Normalization: The Missing Ingredient for Fast Stylization,
    ///    D. Ulyanov, A. Vedaldi, V. Lempitsky, 2016 (arXiv:1607.08022v2).
    /// 
    /// Examples::
    /// 
    ///   // Input of shape (2,1,2)
    ///   x = [[[ 1.1,  2.2]],
    ///        [[ 3.3,  4.4]]]
    /// 
    ///   // gamma parameter of length 1
    ///   gamma = [1.5]
    /// 
    ///   // beta parameter of length 1
    ///   beta = [0.5]
    /// 
    ///   // Instance normalization is calculated with the above formula
    ///   InstanceNorm(x,gamma,beta) = [[[-0.997527  ,  1.99752665]],
    ///                                 [[-0.99752653,  1.99752724]]]
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\instance_norm.cc:L95</summary>
    /// <param name="data">An n-dimensional input array (n &gt; 2) of the form [batch, channel, spatial_dim1, spatial_dim2, ...].</param>
    /// <param name="gamma">A vector of length &#39;channel&#39;, which multiplies the normalized input.</param>
    /// <param name="beta">A vector of length &#39;channel&#39;, which is added to the product of the normalized input and the weight.</param>
    /// <param name="eps">An `epsilon` parameter to prevent division by 0.</param>
    new([<Optional>] ?data : Symbol,
        [<Optional>] ?gamma : Symbol,
        [<Optional>] ?beta : Symbol,
        [<Optional>] ?eps : float) = 
        let data = defaultArg data (new ImplicitVariable() :> Symbol)
        let gamma = defaultArg gamma (new ImplicitVariable() :> Symbol)
        let beta = defaultArg beta (new ImplicitVariable() :> Symbol)
        let operatorArguments = 
            [
                "data", Input data
                "gamma", Input gamma
                "beta", Input beta
                "eps", eps |> Option.map box |> Parameter
            ]
        new InstanceNorm(Arguments<Symbol>(operatorArguments))
    /// Default value for Eps
    /// An `epsilon` parameter to prevent division by 0.
    static member EpsDefault : double = 0.00100000005
    /// An n-dimensional input array (n &gt; 2) of the form [batch, channel, spatial_dim1, spatial_dim2, ...].
    member __.Data = operatorArguments.GetInput "data"
    /// A vector of length &#39;channel&#39;, which multiplies the normalized input.
    member __.Gamma = operatorArguments.GetInput "gamma"
    /// A vector of length &#39;channel&#39;, which is added to the product of the normalized input and the weight.
    member __.Beta = operatorArguments.GetInput "beta"
    /// An `epsilon` parameter to prevent division by 0.
    member __.Eps = operatorArguments.GetParameter("eps", InstanceNorm.EpsDefault)
    /// <summary>Copy InstanceNorm instance with updated inputs/parameters.</summary>
    /// <param name="data">An n-dimensional input array (n &gt; 2) of the form [batch, channel, spatial_dim1, spatial_dim2, ...].</param>
    /// <param name="gamma">A vector of length &#39;channel&#39;, which multiplies the normalized input.</param>
    /// <param name="beta">A vector of length &#39;channel&#39;, which is added to the product of the normalized input and the weight.</param>
    /// <param name="eps">An `epsilon` parameter to prevent division by 0.</param>
    member this.With([<Optional>] ?data : Symbol,
        [<Optional>] ?gamma : Symbol,
        [<Optional>] ?beta : Symbol,
        [<Optional>] ?eps : float) = 
        let operatorArguments = 
            [
                data |> Option.map (fun x -> "data", Input x)
                gamma |> Option.map (fun x -> "gamma", Input x)
                beta |> Option.map (fun x -> "beta", Input x)
                eps |> Option.map (fun x -> "eps", Parameter(Some (box x)))
            ] |> List.choose id
        new InstanceNorm(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type L2Normalization private (operatorArguments) = 
    inherit SymbolOperator("L2Normalization", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new L2Normalization(args)
    override this.WithArguments(args : Arguments<Symbol>) = new L2Normalization(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <summary>Normalize the input array using the L2 norm.
    /// 
    /// For 1-D NDArray, it computes::
    /// 
    ///   out = data / sqrt(sum(data ** 2) + eps)
    /// 
    /// For N-D NDArray, if the input array has shape (N, N, ..., N),
    /// 
    /// with ``mode`` = ``instance``, it normalizes each instance in the multidimensional
    /// array by its L2 norm.::
    /// 
    ///   for i in 0...N
    ///     out[i,:,:,...,:] = data[i,:,:,...,:] / sqrt(sum(data[i,:,:,...,:] ** 2) + eps)
    /// 
    /// with ``mode`` = ``channel``, it normalizes each channel in the array by its L2 norm.::
    /// 
    ///   for i in 0...N
    ///     out[:,i,:,...,:] = data[:,i,:,...,:] / sqrt(sum(data[:,i,:,...,:] ** 2) + eps)
    /// 
    /// with ``mode`` = ``spatial``, it normalizes the cross channel norm for each position
    /// in the array by its L2 norm.::
    /// 
    ///   for dim in 2...N
    ///     for i in 0...N
    ///       out[.....,i,...] = take(out, indices=i, axis=dim) / sqrt(sum(take(out, indices=i, axis=dim) ** 2) + eps)
    ///           -dim-
    /// 
    /// Example::
    /// 
    ///   x = [[[1,2],
    ///         [3,4]],
    ///        [[2,2],
    ///         [5,6]]]
    /// 
    ///   L2Normalization(x, mode=&#39;instance&#39;)
    ///   =[[[ 0.18257418  0.36514837]
    ///      [ 0.54772252  0.73029673]]
    ///     [[ 0.24077171  0.24077171]
    ///      [ 0.60192931  0.72231513]]]
    /// 
    ///   L2Normalization(x, mode=&#39;channel&#39;)
    ///   =[[[ 0.31622776  0.44721359]
    ///      [ 0.94868326  0.89442718]]
    ///     [[ 0.37139067  0.31622776]
    ///      [ 0.92847669  0.94868326]]]
    /// 
    ///   L2Normalization(x, mode=&#39;spatial&#39;)
    ///   =[[[ 0.44721359  0.89442718]
    ///      [ 0.60000002  0.80000001]]
    ///     [[ 0.70710677  0.70710677]
    ///      [ 0.6401844   0.76822126]]]
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\l2_normalization.cc:L196</summary>
    /// <param name="data">Input array to normalize.</param>
    /// <param name="eps">A small constant for numerical stability.</param>
    /// <param name="mode">Specify the dimension along which to compute L2 norm.</param>
    new([<Optional>] ?data : Symbol,
        [<Optional>] ?eps : float,
        [<Optional>] ?mode : L2NormalizationMode) = 
        let data = defaultArg data (new ImplicitVariable() :> Symbol)
        let operatorArguments = 
            [
                "data", Input data
                "eps", eps |> Option.map box |> Parameter
                "mode", mode |> Option.map box |> Parameter
            ]
        new L2Normalization(Arguments<Symbol>(operatorArguments))
    /// Default value for Eps
    /// A small constant for numerical stability.
    static member EpsDefault : double = 0.0000000001
    /// Default value for Mode
    /// Specify the dimension along which to compute L2 norm.
    static member ModeDefault : L2NormalizationMode = L2NormalizationMode.Instance
    /// Input array to normalize.
    member __.Data = operatorArguments.GetInput "data"
    /// A small constant for numerical stability.
    member __.Eps = operatorArguments.GetParameter("eps", L2Normalization.EpsDefault)
    /// Specify the dimension along which to compute L2 norm.
    member __.Mode = operatorArguments.GetParameter("mode", L2Normalization.ModeDefault)
    /// <summary>Copy L2Normalization instance with updated inputs/parameters.</summary>
    /// <param name="data">Input array to normalize.</param>
    /// <param name="eps">A small constant for numerical stability.</param>
    /// <param name="mode">Specify the dimension along which to compute L2 norm.</param>
    member this.With([<Optional>] ?data : Symbol,
        [<Optional>] ?eps : float,
        [<Optional>] ?mode : L2NormalizationMode) = 
        let operatorArguments = 
            [
                data |> Option.map (fun x -> "data", Input x)
                eps |> Option.map (fun x -> "eps", Parameter(Some (box x)))
                mode |> Option.map (fun x -> "mode", Parameter(Some (box x)))
            ] |> List.choose id
        new L2Normalization(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type MakeLoss private (operatorArguments) = 
    inherit SymbolOperator("MakeLoss", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new MakeLoss(args)
    override this.WithArguments(args : Arguments<Symbol>) = new MakeLoss(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <summary>Make your own loss function in network construction.
    /// 
    /// This operator accepts a customized loss function symbol as a terminal loss and
    /// the symbol should be an operator with no backward dependency.
    /// The output of this function is the gradient of loss with respect to the input data.
    /// 
    /// For example, if you are a making a cross entropy loss function. Assume ``out`` is the
    /// predicted output and ``label`` is the true label, then the cross entropy can be defined as::
    /// 
    ///   cross_entropy = label * log(out) + (1 - label) * log(1 - out)
    ///   loss = MakeLoss(cross_entropy)
    /// 
    /// We will need to use ``MakeLoss`` when we are creating our own loss function or we want to
    /// combine multiple loss functions. Also we may want to stop some variables&#39; gradients
    /// from backpropagation. See more detail in ``BlockGrad`` or ``stop_gradient``.
    /// 
    /// In addition, we can give a scale to the loss by setting ``grad_scale``,
    /// so that the gradient of the loss will be rescaled in the backpropagation.
    /// 
    /// .. note:: This operator should be used as a Symbol instead of NDArray.
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\make_loss.cc:L71</summary>
    /// <param name="data">Input array.</param>
    /// <param name="gradScale">Gradient scale as a supplement to unary and binary operators</param>
    /// <param name="validThresh">clip each element in the array to 0 when it is less than ``valid_thresh``. This is used when ``normalization`` is set to ``&#39;valid&#39;``.</param>
    /// <param name="normalization">If this is set to null, the output gradient will not be normalized. If this is set to batch, the output gradient will be divided by the batch size. If this is set to valid, the output gradient will be divided by the number of valid input elements.</param>
    new([<Optional>] ?data : Symbol,
        [<Optional>] ?gradScale : float,
        [<Optional>] ?validThresh : float,
        [<Optional>] ?normalization : Normalization) = 
        let data = defaultArg data (new ImplicitVariable() :> Symbol)
        let operatorArguments = 
            [
                "data", Input data
                "grad_scale", gradScale |> Option.map box |> Parameter
                "valid_thresh", validThresh |> Option.map box |> Parameter
                "normalization", normalization |> Option.map box |> Parameter
            ]
        new MakeLoss(Arguments<Symbol>(operatorArguments))
    /// Default value for GradScale
    /// Gradient scale as a supplement to unary and binary operators
    static member GradScaleDefault : double = 1.0
    /// Default value for ValidThresh
    /// clip each element in the array to 0 when it is less than ``valid_thresh``. This is used when ``normalization`` is set to ``&#39;valid&#39;``.
    static member ValidThreshDefault : double = 0.0
    /// Default value for Normalization
    /// If this is set to null, the output gradient will not be normalized. If this is set to batch, the output gradient will be divided by the batch size. If this is set to valid, the output gradient will be divided by the number of valid input elements.
    static member NormalizationDefault : Normalization = Normalization.Null
    /// Input array.
    member __.Data = operatorArguments.GetInput "data"
    /// Gradient scale as a supplement to unary and binary operators
    member __.GradScale = operatorArguments.GetParameter("grad_scale", MakeLoss.GradScaleDefault)
    /// clip each element in the array to 0 when it is less than ``valid_thresh``. This is used when ``normalization`` is set to ``&#39;valid&#39;``.
    member __.ValidThresh = operatorArguments.GetParameter("valid_thresh", MakeLoss.ValidThreshDefault)
    /// If this is set to null, the output gradient will not be normalized. If this is set to batch, the output gradient will be divided by the batch size. If this is set to valid, the output gradient will be divided by the number of valid input elements.
    member __.Normalization = operatorArguments.GetParameter("normalization", MakeLoss.NormalizationDefault)
    /// <summary>Copy MakeLoss instance with updated inputs/parameters.</summary>
    /// <param name="data">Input array.</param>
    /// <param name="gradScale">Gradient scale as a supplement to unary and binary operators</param>
    /// <param name="validThresh">clip each element in the array to 0 when it is less than ``valid_thresh``. This is used when ``normalization`` is set to ``&#39;valid&#39;``.</param>
    /// <param name="normalization">If this is set to null, the output gradient will not be normalized. If this is set to batch, the output gradient will be divided by the batch size. If this is set to valid, the output gradient will be divided by the number of valid input elements.</param>
    member this.With([<Optional>] ?data : Symbol,
        [<Optional>] ?gradScale : float,
        [<Optional>] ?validThresh : float,
        [<Optional>] ?normalization : Normalization) = 
        let operatorArguments = 
            [
                data |> Option.map (fun x -> "data", Input x)
                gradScale |> Option.map (fun x -> "grad_scale", Parameter(Some (box x)))
                validThresh |> Option.map (fun x -> "valid_thresh", Parameter(Some (box x)))
                normalization |> Option.map (fun x -> "normalization", Parameter(Some (box x)))
            ] |> List.choose id
        new MakeLoss(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type SequenceLast private (operatorArguments) = 
    inherit SymbolOperator("SequenceLast", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new SequenceLast(args)
    override this.WithArguments(args : Arguments<Symbol>) = new SequenceLast(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <summary>Takes the last element of a sequence.
    /// 
    /// This function takes an n-dimensional input array of the form
    /// [max_sequence_length, batch_size, other_feature_dims] and returns a (n-1)-dimensional array
    /// of the form [batch_size, other_feature_dims].
    /// 
    /// Parameter `sequence_length` is used to handle variable-length sequences. `sequence_length` should be
    /// an input array of positive ints of dimension [batch_size]. To use this parameter,
    /// set `use_sequence_length` to `True`, otherwise each example in the batch is assumed
    /// to have the max sequence length.
    /// 
    /// .. note:: Alternatively, you can also use `take` operator.
    /// 
    /// Example::
    /// 
    ///    x = [[[  1.,   2.,   3.],
    ///          [  4.,   5.,   6.],
    ///          [  7.,   8.,   9.]],
    /// 
    ///         [[ 10.,   11.,   12.],
    ///          [ 13.,   14.,   15.],
    ///          [ 16.,   17.,   18.]],
    /// 
    ///         [[  19.,   20.,   21.],
    ///          [  22.,   23.,   24.],
    ///          [  25.,   26.,   27.]]]
    /// 
    ///    // returns last sequence when sequence_length parameter is not used
    ///    SequenceLast(x) = [[  19.,   20.,   21.],
    ///                       [  22.,   23.,   24.],
    ///                       [  25.,   26.,   27.]]
    /// 
    ///    // sequence_length is used
    ///    SequenceLast(x, sequence_length=[1,1,1], use_sequence_length=True) =
    ///             [[  1.,   2.,   3.],
    ///              [  4.,   5.,   6.],
    ///              [  7.,   8.,   9.]]
    /// 
    ///    // sequence_length is used
    ///    SequenceLast(x, sequence_length=[1,2,3], use_sequence_length=True) =
    ///             [[  1.,    2.,   3.],
    ///              [  13.,  14.,  15.],
    ///              [  25.,  26.,  27.]]
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\sequence_last.cc:L106</summary>
    /// <param name="data">n-dimensional input array of the form [max_sequence_length, batch_size, other_feature_dims] where n&gt;2</param>
    /// <param name="sequenceLength">vector of sequence lengths of the form [batch_size]</param>
    /// <param name="useSequenceLength">If set to true, this layer takes in an extra input parameter `sequence_length` to specify variable length sequence</param>
    /// <param name="axis">The sequence axis. Only values of 0 and 1 are currently supported.</param>
    new([<Optional>] ?data : Symbol,
        [<Optional>] ?sequenceLength : Symbol,
        [<Optional>] ?useSequenceLength : bool,
        [<Optional>] ?axis : int) = 
        let data = defaultArg data (new ImplicitVariable() :> Symbol)
        let sequenceLength = defaultArg sequenceLength (new ImplicitVariable() :> Symbol)
        let operatorArguments = 
            [
                "data", Input data
                "sequence_length", Input sequenceLength
                "use_sequence_length", useSequenceLength |> Option.map box |> Parameter
                "axis", axis |> Option.map box |> Parameter
            ]
        new SequenceLast(Arguments<Symbol>(operatorArguments))
    /// Default value for UseSequenceLength
    /// If set to true, this layer takes in an extra input parameter `sequence_length` to specify variable length sequence
    static member UseSequenceLengthDefault : bool = false
    /// Default value for Axis
    /// The sequence axis. Only values of 0 and 1 are currently supported.
    static member AxisDefault : int = 0
    /// n-dimensional input array of the form [max_sequence_length, batch_size, other_feature_dims] where n&gt;2
    member __.Data = operatorArguments.GetInput "data"
    /// vector of sequence lengths of the form [batch_size]
    member __.SequenceLength = operatorArguments.GetInput "sequence_length"
    /// If set to true, this layer takes in an extra input parameter `sequence_length` to specify variable length sequence
    member __.UseSequenceLength = operatorArguments.GetParameter("use_sequence_length", SequenceLast.UseSequenceLengthDefault)
    /// The sequence axis. Only values of 0 and 1 are currently supported.
    member __.Axis = operatorArguments.GetParameter("axis", SequenceLast.AxisDefault)
    /// <summary>Copy SequenceLast instance with updated inputs/parameters.</summary>
    /// <param name="data">n-dimensional input array of the form [max_sequence_length, batch_size, other_feature_dims] where n&gt;2</param>
    /// <param name="sequenceLength">vector of sequence lengths of the form [batch_size]</param>
    /// <param name="useSequenceLength">If set to true, this layer takes in an extra input parameter `sequence_length` to specify variable length sequence</param>
    /// <param name="axis">The sequence axis. Only values of 0 and 1 are currently supported.</param>
    member this.With([<Optional>] ?data : Symbol,
        [<Optional>] ?sequenceLength : Symbol,
        [<Optional>] ?useSequenceLength : bool,
        [<Optional>] ?axis : int) = 
        let operatorArguments = 
            [
                data |> Option.map (fun x -> "data", Input x)
                sequenceLength |> Option.map (fun x -> "sequence_length", Input x)
                useSequenceLength |> Option.map (fun x -> "use_sequence_length", Parameter(Some (box x)))
                axis |> Option.map (fun x -> "axis", Parameter(Some (box x)))
            ] |> List.choose id
        new SequenceLast(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type SequenceReverse private (operatorArguments) = 
    inherit SymbolOperator("SequenceReverse", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new SequenceReverse(args)
    override this.WithArguments(args : Arguments<Symbol>) = new SequenceReverse(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <summary>Reverses the elements of each sequence.
    /// 
    /// This function takes an n-dimensional input array of the form [max_sequence_length, batch_size, other_feature_dims]
    /// and returns an array of the same shape.
    /// 
    /// Parameter `sequence_length` is used to handle variable-length sequences.
    /// `sequence_length` should be an input array of positive ints of dimension [batch_size].
    /// To use this parameter, set `use_sequence_length` to `True`,
    /// otherwise each example in the batch is assumed to have the max sequence length.
    /// 
    /// Example::
    /// 
    ///    x = [[[  1.,   2.,   3.],
    ///          [  4.,   5.,   6.]],
    /// 
    ///         [[  7.,   8.,   9.],
    ///          [ 10.,  11.,  12.]],
    /// 
    ///         [[ 13.,  14.,   15.],
    ///          [ 16.,  17.,   18.]]]
    /// 
    ///    // Batch 1
    ///    B1 = [[  1.,   2.,   3.],
    ///          [  7.,   8.,   9.],
    ///          [ 13.,  14.,  15.]]
    /// 
    ///    // Batch 2
    ///    B2 = [[  4.,   5.,   6.],
    ///          [ 10.,  11.,  12.],
    ///          [ 16.,  17.,  18.]]
    /// 
    ///    // returns reverse sequence when sequence_length parameter is not used
    ///    SequenceReverse(x) = [[[ 13.,  14.,   15.],
    ///                           [ 16.,  17.,   18.]],
    /// 
    ///                          [[  7.,   8.,   9.],
    ///                           [ 10.,  11.,  12.]],
    /// 
    ///                          [[  1.,   2.,   3.],
    ///                           [  4.,   5.,   6.]]]
    /// 
    ///    // sequence_length [2,2] means 2 rows of
    ///    // both batch B1 and B2 will be reversed.
    ///    SequenceReverse(x, sequence_length=[2,2], use_sequence_length=True) =
    ///                      [[[  7.,   8.,   9.],
    ///                        [ 10.,  11.,  12.]],
    /// 
    ///                       [[  1.,   2.,   3.],
    ///                        [  4.,   5.,   6.]],
    /// 
    ///                       [[ 13.,  14.,   15.],
    ///                        [ 16.,  17.,   18.]]]
    /// 
    ///    // sequence_length [2,3] means 2 of batch B2 and 3 of batch B3
    ///    // will be reversed.
    ///    SequenceReverse(x, sequence_length=[2,3], use_sequence_length=True) =
    ///                     [[[  7.,   8.,   9.],
    ///                       [ 16.,  17.,  18.]],
    /// 
    ///                      [[  1.,   2.,   3.],
    ///                       [ 10.,  11.,  12.]],
    /// 
    ///                      [[ 13.,  14,   15.],
    ///                       [  4.,   5.,   6.]]]
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\sequence_reverse.cc:L122</summary>
    /// <param name="data">n-dimensional input array of the form [max_sequence_length, batch_size, other dims] where n&gt;2 </param>
    /// <param name="sequenceLength">vector of sequence lengths of the form [batch_size]</param>
    /// <param name="useSequenceLength">If set to true, this layer takes in an extra input parameter `sequence_length` to specify variable length sequence</param>
    /// <param name="axis">The sequence axis. Only 0 is currently supported.</param>
    new([<Optional>] ?data : Symbol,
        [<Optional>] ?sequenceLength : Symbol,
        [<Optional>] ?useSequenceLength : bool,
        [<Optional>] ?axis : int) = 
        let data = defaultArg data (new ImplicitVariable() :> Symbol)
        let sequenceLength = defaultArg sequenceLength (new ImplicitVariable() :> Symbol)
        let operatorArguments = 
            [
                "data", Input data
                "sequence_length", Input sequenceLength
                "use_sequence_length", useSequenceLength |> Option.map box |> Parameter
                "axis", axis |> Option.map box |> Parameter
            ]
        new SequenceReverse(Arguments<Symbol>(operatorArguments))
    /// Default value for UseSequenceLength
    /// If set to true, this layer takes in an extra input parameter `sequence_length` to specify variable length sequence
    static member UseSequenceLengthDefault : bool = false
    /// Default value for Axis
    /// The sequence axis. Only 0 is currently supported.
    static member AxisDefault : int = 0
    /// n-dimensional input array of the form [max_sequence_length, batch_size, other dims] where n&gt;2 
    member __.Data = operatorArguments.GetInput "data"
    /// vector of sequence lengths of the form [batch_size]
    member __.SequenceLength = operatorArguments.GetInput "sequence_length"
    /// If set to true, this layer takes in an extra input parameter `sequence_length` to specify variable length sequence
    member __.UseSequenceLength = operatorArguments.GetParameter("use_sequence_length", SequenceReverse.UseSequenceLengthDefault)
    /// The sequence axis. Only 0 is currently supported.
    member __.Axis = operatorArguments.GetParameter("axis", SequenceReverse.AxisDefault)
    /// <summary>Copy SequenceReverse instance with updated inputs/parameters.</summary>
    /// <param name="data">n-dimensional input array of the form [max_sequence_length, batch_size, other dims] where n&gt;2 </param>
    /// <param name="sequenceLength">vector of sequence lengths of the form [batch_size]</param>
    /// <param name="useSequenceLength">If set to true, this layer takes in an extra input parameter `sequence_length` to specify variable length sequence</param>
    /// <param name="axis">The sequence axis. Only 0 is currently supported.</param>
    member this.With([<Optional>] ?data : Symbol,
        [<Optional>] ?sequenceLength : Symbol,
        [<Optional>] ?useSequenceLength : bool,
        [<Optional>] ?axis : int) = 
        let operatorArguments = 
            [
                data |> Option.map (fun x -> "data", Input x)
                sequenceLength |> Option.map (fun x -> "sequence_length", Input x)
                useSequenceLength |> Option.map (fun x -> "use_sequence_length", Parameter(Some (box x)))
                axis |> Option.map (fun x -> "axis", Parameter(Some (box x)))
            ] |> List.choose id
        new SequenceReverse(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type SpatialTransformer private (operatorArguments) = 
    inherit SymbolOperator("SpatialTransformer", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new SpatialTransformer(args)
    override this.WithArguments(args : Arguments<Symbol>) = new SpatialTransformer(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <summary>Applies a spatial transformer to input feature map.</summary>
    /// <param name="data">Input data to the SpatialTransformerOp.</param>
    /// <param name="loc">localisation net, the output dim should be 6 when transform_type is affine. You shold initialize the weight and bias with identity tranform.</param>
    /// <param name="transformType">transformation type</param>
    /// <param name="samplerType">sampling type</param>
    /// <param name="targetShape">output shape(h, w) of spatial transformer: (y, x)</param>
    /// <param name="cudnnOff">whether to turn cudnn off</param>
    new(data : Symbol,
        loc : Symbol,
        transformType : SpatialTransformerTransformType,
        samplerType : SamplerType,
        [<Optional>] ?targetShape : int seq,
        [<Optional>] ?cudnnOff : bool) = 
        let operatorArguments = 
            [
                "data", Input data
                "loc", Input loc
                "transform_type", Parameter(Some(box transformType))
                "sampler_type", Parameter(Some(box samplerType))
                "target_shape", targetShape |> Option.map box |> Parameter
                "cudnn_off", cudnnOff |> Option.map box |> Parameter
            ]
        new SpatialTransformer(Arguments<Symbol>(operatorArguments))
    /// <summary>Applies a spatial transformer to input feature map.</summary>
    /// <param name="transformType">transformation type</param>
    /// <param name="samplerType">sampling type</param>
    /// <param name="data">Input data to the SpatialTransformerOp.</param>
    /// <param name="loc">localisation net, the output dim should be 6 when transform_type is affine. You shold initialize the weight and bias with identity tranform.</param>
    /// <param name="targetShape">output shape(h, w) of spatial transformer: (y, x)</param>
    /// <param name="cudnnOff">whether to turn cudnn off</param>
    new(transformType : SpatialTransformerTransformType,
        samplerType : SamplerType,
        [<Optional>] ?data : Symbol,
        [<Optional>] ?loc : Symbol,
        [<Optional>] ?targetShape : int seq,
        [<Optional>] ?cudnnOff : bool) = 
        let data = defaultArg data (new ImplicitVariable() :> Symbol)
        let loc = defaultArg loc (new ImplicitVariable() :> Symbol)
        let operatorArguments = 
            [
                "data", Input data
                "loc", Input loc
                "transform_type", Parameter(Some(box transformType))
                "sampler_type", Parameter(Some(box samplerType))
                "target_shape", targetShape |> Option.map box |> Parameter
                "cudnn_off", cudnnOff |> Option.map box |> Parameter
            ]
        new SpatialTransformer(Arguments<Symbol>(operatorArguments))
    /// Default value for TargetShape
    /// output shape(h, w) of spatial transformer: (y, x)
    static member TargetShapeDefault : int [] = [|0; 0|]
    /// Default value for CudnnOff
    /// whether to turn cudnn off
    static member CudnnOffDefault : bool option = None
    /// Input data to the SpatialTransformerOp.
    member __.Data = operatorArguments.GetInput "data"
    /// localisation net, the output dim should be 6 when transform_type is affine. You shold initialize the weight and bias with identity tranform.
    member __.Loc = operatorArguments.GetInput "loc"
    /// transformation type
    member __.TransformType : SpatialTransformerTransformType = match operatorArguments.GetParameter "transform_type" with Some(v) -> unbox v | None -> failwithf "Required parameter transform_type is missing"
    /// sampling type
    member __.SamplerType : SamplerType = match operatorArguments.GetParameter "sampler_type" with Some(v) -> unbox v | None -> failwithf "Required parameter sampler_type is missing"
    /// output shape(h, w) of spatial transformer: (y, x)
    member __.TargetShape = operatorArguments.GetParameter("target_shape", SpatialTransformer.TargetShapeDefault)
    /// whether to turn cudnn off
    member __.CudnnOff = operatorArguments.GetParameter("cudnn_off", SpatialTransformer.CudnnOffDefault)
    /// <summary>Copy SpatialTransformer instance with updated inputs/parameters.</summary>
    /// <param name="data">Input data to the SpatialTransformerOp.</param>
    /// <param name="loc">localisation net, the output dim should be 6 when transform_type is affine. You shold initialize the weight and bias with identity tranform.</param>
    /// <param name="transformType">transformation type</param>
    /// <param name="samplerType">sampling type</param>
    /// <param name="targetShape">output shape(h, w) of spatial transformer: (y, x)</param>
    /// <param name="cudnnOff">whether to turn cudnn off</param>
    member this.With([<Optional>] ?data : Symbol,
        [<Optional>] ?loc : Symbol,
        [<Optional>] ?transformType : SpatialTransformerTransformType,
        [<Optional>] ?samplerType : SamplerType,
        [<Optional>] ?targetShape : int seq,
        [<Optional>] ?cudnnOff : bool) = 
        let operatorArguments = 
            [
                data |> Option.map (fun x -> "data", Input x)
                loc |> Option.map (fun x -> "loc", Input x)
                transformType |> Option.map (fun x -> "transform_type", Parameter(Some (box x)))
                samplerType |> Option.map (fun x -> "sampler_type", Parameter(Some (box x)))
                targetShape |> Option.map (fun x -> "target_shape", Parameter(Some (box x)))
                cudnnOff |> Option.map (fun x -> "cudnn_off", Parameter(Some (box x)))
            ] |> List.choose id
        new SpatialTransformer(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type SVMOutput private (operatorArguments) = 
    inherit SymbolOperator("SVMOutput", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new SVMOutput(args)
    override this.WithArguments(args : Arguments<Symbol>) = new SVMOutput(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <summary>Computes support vector machine based transformation of the input.
    /// 
    /// This tutorial demonstrates using SVM as output layer for classification instead of softmax:
    /// https://github.com/dmlc/mxnet/tree/master/example/svm_mnist.
    /// 
    /// </summary>
    /// <param name="data">Input data for SVM transformation.</param>
    /// <param name="label">Class label for the input data.</param>
    /// <param name="margin">The loss function penalizes outputs that lie outside this margin. Default margin is 1.</param>
    /// <param name="regularizationCoefficient">Regularization parameter for the SVM. This balances the tradeoff between coefficient size and error.</param>
    /// <param name="useLinear">Whether to use L1-SVM objective. L2-SVM objective is used by default.</param>
    new([<Optional>] ?data : Symbol,
        [<Optional>] ?label : Symbol,
        [<Optional>] ?margin : float,
        [<Optional>] ?regularizationCoefficient : float,
        [<Optional>] ?useLinear : bool) = 
        let data = defaultArg data (new ImplicitVariable() :> Symbol)
        let label = defaultArg label (new ImplicitVariable() :> Symbol)
        let operatorArguments = 
            [
                "data", Input data
                "label", Input label
                "margin", margin |> Option.map box |> Parameter
                "regularization_coefficient", regularizationCoefficient |> Option.map box |> Parameter
                "use_linear", useLinear |> Option.map box |> Parameter
            ]
        new SVMOutput(Arguments<Symbol>(operatorArguments))
    /// Default value for Margin
    /// The loss function penalizes outputs that lie outside this margin. Default margin is 1.
    static member MarginDefault : double = 1.0
    /// Default value for RegularizationCoefficient
    /// Regularization parameter for the SVM. This balances the tradeoff between coefficient size and error.
    static member RegularizationCoefficientDefault : double = 1.0
    /// Default value for UseLinear
    /// Whether to use L1-SVM objective. L2-SVM objective is used by default.
    static member UseLinearDefault : bool = false
    /// Input data for SVM transformation.
    member __.Data = operatorArguments.GetInput "data"
    /// Class label for the input data.
    member __.Label = operatorArguments.GetInput "label"
    /// The loss function penalizes outputs that lie outside this margin. Default margin is 1.
    member __.Margin = operatorArguments.GetParameter("margin", SVMOutput.MarginDefault)
    /// Regularization parameter for the SVM. This balances the tradeoff between coefficient size and error.
    member __.RegularizationCoefficient = operatorArguments.GetParameter("regularization_coefficient", SVMOutput.RegularizationCoefficientDefault)
    /// Whether to use L1-SVM objective. L2-SVM objective is used by default.
    member __.UseLinear = operatorArguments.GetParameter("use_linear", SVMOutput.UseLinearDefault)
    /// <summary>Copy SVMOutput instance with updated inputs/parameters.</summary>
    /// <param name="data">Input data for SVM transformation.</param>
    /// <param name="label">Class label for the input data.</param>
    /// <param name="margin">The loss function penalizes outputs that lie outside this margin. Default margin is 1.</param>
    /// <param name="regularizationCoefficient">Regularization parameter for the SVM. This balances the tradeoff between coefficient size and error.</param>
    /// <param name="useLinear">Whether to use L1-SVM objective. L2-SVM objective is used by default.</param>
    member this.With([<Optional>] ?data : Symbol,
        [<Optional>] ?label : Symbol,
        [<Optional>] ?margin : float,
        [<Optional>] ?regularizationCoefficient : float,
        [<Optional>] ?useLinear : bool) = 
        let operatorArguments = 
            [
                data |> Option.map (fun x -> "data", Input x)
                label |> Option.map (fun x -> "label", Input x)
                margin |> Option.map (fun x -> "margin", Parameter(Some (box x)))
                regularizationCoefficient |> Option.map (fun x -> "regularization_coefficient", Parameter(Some (box x)))
                useLinear |> Option.map (fun x -> "use_linear", Parameter(Some (box x)))
            ] |> List.choose id
        new SVMOutput(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type SetValue private (operatorArguments) = 
    inherit SymbolOperator("_set_value", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new SetValue(args)
    override this.WithArguments(args : Arguments<Symbol>) = new SetValue(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <param name="src">Source input to the function.</param>
    new(src : double) =
        let operatorArguments = 
            [
                "src", Parameter(Some(box src))
            ]
        new SetValue(Arguments<Symbol>(operatorArguments))
    /// Source input to the function.
    member __.Src : double = match operatorArguments.GetParameter "src" with Some(v) -> unbox v | None -> failwithf "Required parameter src is missing"
    /// <summary>Copy SetValue instance with updated inputs/parameters.</summary>
    /// <param name="src">Source input to the function.</param>
    member this.With([<Optional>] ?src : double) =
        let operatorArguments = 
            [
                src |> Option.map (fun x -> "src", Parameter(Some (box x)))
            ] |> List.choose id
        new SetValue(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))

type Imdecode private (operatorArguments) = 
    inherit SymbolOperator("_imdecode", operatorArguments)
    static member CreateFromArguments(args : Arguments<Symbol>) = new Imdecode(args)
    override this.WithArguments(args : Arguments<Symbol>) = new Imdecode(this.OperatorArguments.AddReplace(args)) :> Symbol
    /// <summary>Decode an image, clip to (x0, y0, x1, y1), subtract mean, and write to buffer</summary>
    /// <param name="mean">image mean</param>
    /// <param name="index">buffer position for output</param>
    /// <param name="x0">x0</param>
    /// <param name="y0">y0</param>
    /// <param name="x1">x1</param>
    /// <param name="y1">y1</param>
    /// <param name="c">channel</param>
    /// <param name="size">length of str_img</param>
    new(mean : Symbol,
        index : int,
        x0 : int,
        y0 : int,
        x1 : int,
        y1 : int,
        c : int,
        size : int) = 
        let operatorArguments = 
            [
                "mean", Input mean
                "index", Parameter(Some(box index))
                "x0", Parameter(Some(box x0))
                "y0", Parameter(Some(box y0))
                "x1", Parameter(Some(box x1))
                "y1", Parameter(Some(box y1))
                "c", Parameter(Some(box c))
                "size", Parameter(Some(box size))
            ]
        new Imdecode(Arguments<Symbol>(operatorArguments))
    /// <summary>Decode an image, clip to (x0, y0, x1, y1), subtract mean, and write to buffer</summary>
    /// <param name="index">buffer position for output</param>
    /// <param name="x0">x0</param>
    /// <param name="y0">y0</param>
    /// <param name="x1">x1</param>
    /// <param name="y1">y1</param>
    /// <param name="c">channel</param>
    /// <param name="size">length of str_img</param>
    /// <param name="mean">image mean</param>
    new(index : int,
        x0 : int,
        y0 : int,
        x1 : int,
        y1 : int,
        c : int,
        size : int,
        [<Optional>] ?mean : Symbol) = 
        let mean = defaultArg mean (new ImplicitVariable() :> Symbol)
        let operatorArguments = 
            [
                "mean", Input mean
                "index", Parameter(Some(box index))
                "x0", Parameter(Some(box x0))
                "y0", Parameter(Some(box y0))
                "x1", Parameter(Some(box x1))
                "y1", Parameter(Some(box y1))
                "c", Parameter(Some(box c))
                "size", Parameter(Some(box size))
            ]
        new Imdecode(Arguments<Symbol>(operatorArguments))
    /// image mean
    member __.Mean = operatorArguments.GetInput "mean"
    /// buffer position for output
    member __.Index : int = match operatorArguments.GetParameter "index" with Some(v) -> unbox v | None -> failwithf "Required parameter index is missing"
    /// x0
    member __.X0 : int = match operatorArguments.GetParameter "x0" with Some(v) -> unbox v | None -> failwithf "Required parameter x0 is missing"
    /// y0
    member __.Y0 : int = match operatorArguments.GetParameter "y0" with Some(v) -> unbox v | None -> failwithf "Required parameter y0 is missing"
    /// x1
    member __.X1 : int = match operatorArguments.GetParameter "x1" with Some(v) -> unbox v | None -> failwithf "Required parameter x1 is missing"
    /// y1
    member __.Y1 : int = match operatorArguments.GetParameter "y1" with Some(v) -> unbox v | None -> failwithf "Required parameter y1 is missing"
    /// channel
    member __.C : int = match operatorArguments.GetParameter "c" with Some(v) -> unbox v | None -> failwithf "Required parameter c is missing"
    /// length of str_img
    member __.Size : int = match operatorArguments.GetParameter "size" with Some(v) -> unbox v | None -> failwithf "Required parameter size is missing"
    /// <summary>Copy Imdecode instance with updated inputs/parameters.</summary>
    /// <param name="mean">image mean</param>
    /// <param name="index">buffer position for output</param>
    /// <param name="x0">x0</param>
    /// <param name="y0">y0</param>
    /// <param name="x1">x1</param>
    /// <param name="y1">y1</param>
    /// <param name="c">channel</param>
    /// <param name="size">length of str_img</param>
    member this.With([<Optional>] ?mean : Symbol,
        [<Optional>] ?index : int,
        [<Optional>] ?x0 : int,
        [<Optional>] ?y0 : int,
        [<Optional>] ?x1 : int,
        [<Optional>] ?y1 : int,
        [<Optional>] ?c : int,
        [<Optional>] ?size : int) = 
        let operatorArguments = 
            [
                mean |> Option.map (fun x -> "mean", Input x)
                index |> Option.map (fun x -> "index", Parameter(Some (box x)))
                x0 |> Option.map (fun x -> "x0", Parameter(Some (box x)))
                y0 |> Option.map (fun x -> "y0", Parameter(Some (box x)))
                x1 |> Option.map (fun x -> "x1", Parameter(Some (box x)))
                y1 |> Option.map (fun x -> "y1", Parameter(Some (box x)))
                c |> Option.map (fun x -> "c", Parameter(Some (box x)))
                size |> Option.map (fun x -> "size", Parameter(Some (box x)))
            ] |> List.choose id
        new Imdecode(this.OperatorArguments.AddReplace(Arguments<Symbol>(operatorArguments)))
(* GERNATED SYMBOL TYPES END *)//

