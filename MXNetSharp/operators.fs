namespace MXNetSharp
open System
open System.Runtime.InteropServices
open MXNetSharp.Interop
open MXNetSharp.SymbolOperators



type MX() =  
    static member inline NoArg() = (^t : (static member NoArg : ^t)())

    static member CustomFunctionNDArray() =
        let creator = AtomicSymbolCreator.FromName "_CustomFunction"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 Array.empty
                                                 Array.empty
                                                 Array.empty
        outputs |> Array.map (fun h -> new NDArray(h))
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    static member CustomFunction(outputArray : NDArray seq) =
        let creator = AtomicSymbolCreator.FromName "_CustomFunction"
        let names = Array.empty
        let vals = Array.empty
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     Array.empty
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    static member CustomFunction() =
        CustomFunction()


    /// <param name="data">input data list</param>
    static member CachedOp([<ParamArray>] data : NDArray[]) =
        let creator = AtomicSymbolCreator.FromName "_CachedOp"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 (data |> Array.map (fun x -> x.UnsafeHandle))
                                                 Array.empty
                                                 Array.empty
        outputs |> Array.map (fun h -> new NDArray(h))
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="data">input data list</param>
    static member CachedOp(outputArray : NDArray seq, [<ParamArray>] data : NDArray[]) =
        let creator = AtomicSymbolCreator.FromName "_CachedOp"
        let names = Array.empty
        let vals = Array.empty
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     (data |> Array.map (fun x -> x.UnsafeHandle))
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <param name="data">input data list</param>
    static member CachedOp([<ParamArray>] data : Symbol[]) =
        CachedOp(data)


    /// <summary>Decode image with OpenCV. 
    /// Note: return image in RGB by default, instead of OpenCV&#39;s default BGR.</summary>
    /// <param name="buf">Buffer containing binary encoded image</param>
    /// <param name="flag">Convert decoded image to grayscale (0) or color (1).</param>
    /// <param name="toRgb">Whether to convert decoded image to mxnet&#39;s default RGB format (instead of opencv&#39;s default BGR).</param>
    static member Cvimdecode(buf : NDArray, [<Optional; DefaultParameterValue(1)>] flag : int, [<Optional; DefaultParameterValue(true)>] toRgb : bool) =
        let creator = AtomicSymbolCreator.FromName "_cvimdecode"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg buf)) then buf.UnsafeHandle|]
                                                 [|"flag"; "to_rgb"|]
                                                 [|string flag; string toRgb|]
        (new NDArray(outputs.[0]))
    /// <summary>Decode image with OpenCV. 
    /// Note: return image in RGB by default, instead of OpenCV&#39;s default BGR.</summary>
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="buf">Buffer containing binary encoded image</param>
    /// <param name="flag">Convert decoded image to grayscale (0) or color (1).</param>
    /// <param name="toRgb">Whether to convert decoded image to mxnet&#39;s default RGB format (instead of opencv&#39;s default BGR).</param>
    static member Cvimdecode(outputArray : NDArray seq, buf : NDArray, [<Optional; DefaultParameterValue(1)>] flag : int, [<Optional; DefaultParameterValue(true)>] toRgb : bool) =
        let creator = AtomicSymbolCreator.FromName "_cvimdecode"
        let names = [|"flag"; "to_rgb"|]
        let vals = [|string flag; string toRgb|]
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg buf)) then buf.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()

    /// <summary>Read and decode image with OpenCV. 
    /// Note: return image in RGB by default, instead of OpenCV&#39;s default BGR.</summary>
    /// <param name="filename">Name of the image file to be loaded.</param>
    /// <param name="flag">Convert decoded image to grayscale (0) or color (1).</param>
    /// <param name="toRgb">Whether to convert decoded image to mxnet&#39;s default RGB format (instead of opencv&#39;s default BGR).</param>
    static member CvimreadNDArray(filename : string, [<Optional; DefaultParameterValue(1)>] flag : int, [<Optional; DefaultParameterValue(true)>] toRgb : bool) =
        let creator = AtomicSymbolCreator.FromName "_cvimread"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 Array.empty
                                                 [|"filename"; "flag"; "to_rgb"|]
                                                 [|filename; string flag; string toRgb|]
        (new NDArray(outputs.[0]))
    /// <summary>Read and decode image with OpenCV. 
    /// Note: return image in RGB by default, instead of OpenCV&#39;s default BGR.</summary>
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="filename">Name of the image file to be loaded.</param>
    /// <param name="flag">Convert decoded image to grayscale (0) or color (1).</param>
    /// <param name="toRgb">Whether to convert decoded image to mxnet&#39;s default RGB format (instead of opencv&#39;s default BGR).</param>
    static member Cvimread(outputArray : NDArray seq, filename : string, [<Optional; DefaultParameterValue(1)>] flag : int, [<Optional; DefaultParameterValue(true)>] toRgb : bool) =
        let creator = AtomicSymbolCreator.FromName "_cvimread"
        let names = [|"filename"; "flag"; "to_rgb"|]
        let vals = [|filename; string flag; string toRgb|]
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     Array.empty
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <summary>Read and decode image with OpenCV. 
    /// Note: return image in RGB by default, instead of OpenCV&#39;s default BGR.</summary>
    /// <param name="filename">Name of the image file to be loaded.</param>
    /// <param name="flag">Convert decoded image to grayscale (0) or color (1).</param>
    /// <param name="toRgb">Whether to convert decoded image to mxnet&#39;s default RGB format (instead of opencv&#39;s default BGR).</param>
    static member Cvimread(filename : string, [<Optional>] ?flag : int, [<Optional>] ?toRgb : bool) =
        Cvimread(filename, ?flag = flag, ?toRgb = toRgb)

    /// <summary>Resize image with OpenCV. 
    /// </summary>
    /// <param name="src">source image</param>
    /// <param name="w">Width of resized image.</param>
    /// <param name="h">Height of resized image.</param>
    /// <param name="interp">Interpolation method (default=cv2.INTER_LINEAR).</param>
    static member Cvimresize(src : NDArray, w : int, h : int, [<Optional; DefaultParameterValue(1)>] interp : int) =
        let creator = AtomicSymbolCreator.FromName "_cvimresize"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg src)) then src.UnsafeHandle|]
                                                 [|"w"; "h"; "interp"|]
                                                 [|string w; string h; string interp|]
        (new NDArray(outputs.[0]))
    /// <summary>Resize image with OpenCV. 
    /// </summary>
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="src">source image</param>
    /// <param name="w">Width of resized image.</param>
    /// <param name="h">Height of resized image.</param>
    /// <param name="interp">Interpolation method (default=cv2.INTER_LINEAR).</param>
    static member Cvimresize(outputArray : NDArray seq, src : NDArray, w : int, h : int, [<Optional; DefaultParameterValue(1)>] interp : int) =
        let creator = AtomicSymbolCreator.FromName "_cvimresize"
        let names = [|"w"; "h"; "interp"|]
        let vals = [|string w; string h; string interp|]
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg src)) then src.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()

    /// <summary>Pad image border with OpenCV. 
    /// </summary>
    /// <param name="src">source image</param>
    /// <param name="top">Top margin.</param>
    /// <param name="bot">Bottom margin.</param>
    /// <param name="left">Left margin.</param>
    /// <param name="right">Right margin.</param>
    /// <param name="values">Fill with value(RGB[A] or gray), up to 4 channels.</param>
    /// <param name="fillingType">Filling type (default=cv2.BORDER_CONSTANT).</param>
    /// <param name="value">(Deprecated! Use ``values`` instead.) Fill with single value.</param>
    static member CvcopyMakeBorder(src : NDArray, 
                                   top : int, 
                                   bot : int, 
                                   left : int, 
                                   right : int, 
                                   values : double seq, 
                                   [<Optional; DefaultParameterValue(0)>] fillingType : int, 
                                   [<Optional; DefaultParameterValue(0.0)>] value : double) =
        let creator = AtomicSymbolCreator.FromName "_cvcopyMakeBorder"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg src)) then src.UnsafeHandle|]
                                                 [|"top"; "bot"; "left"; "right"; "values"; "type"; "value"|]
                                                 [|string top; string bot; string left; string right; string values; string fillingType; string value|]
        (new NDArray(outputs.[0]))
    /// <summary>Pad image border with OpenCV. 
    /// </summary>
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="src">source image</param>
    /// <param name="top">Top margin.</param>
    /// <param name="bot">Bottom margin.</param>
    /// <param name="left">Left margin.</param>
    /// <param name="right">Right margin.</param>
    /// <param name="values">Fill with value(RGB[A] or gray), up to 4 channels.</param>
    /// <param name="fillingType">Filling type (default=cv2.BORDER_CONSTANT).</param>
    /// <param name="value">(Deprecated! Use ``values`` instead.) Fill with single value.</param>
    static member CvcopyMakeBorder(outputArray : NDArray seq, 
                                   src : NDArray, 
                                   top : int, 
                                   bot : int, 
                                   left : int, 
                                   right : int, 
                                   values : double seq, 
                                   [<Optional; DefaultParameterValue(0)>] fillingType : int, 
                                   [<Optional; DefaultParameterValue(0.0)>] value : double) =
        let creator = AtomicSymbolCreator.FromName "_cvcopyMakeBorder"
        let names = [|"top"; "bot"; "left"; "right"; "values"; "type"; "value"|]
        let vals = [|string top; string bot; string left; string right; string values; string fillingType; string value|]
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg src)) then src.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()

    /// <param name="data">input data</param>
    static member Copyto(data : NDArray) =
        let creator = AtomicSymbolCreator.FromName "_copyto"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle|]
                                                 Array.empty
                                                 Array.empty
        (new NDArray(outputs.[0]))
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="data">input data</param>
    static member Copyto(outputArray : NDArray seq, data : NDArray) =
        let creator = AtomicSymbolCreator.FromName "_copyto"
        let names = Array.empty
        let vals = Array.empty
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()

    /// <summary>Place holder for variable who cannot perform gradient</summary>
    static member NoGradientNDArray() =
        let creator = AtomicSymbolCreator.FromName "_NoGradient"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 Array.empty
                                                 Array.empty
                                                 Array.empty
        (new NDArray(outputs.[0]))
    /// <summary>Place holder for variable who cannot perform gradient</summary>
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    static member NoGradient(outputArray : NDArray seq) =
        let creator = AtomicSymbolCreator.FromName "_NoGradient"
        let names = Array.empty
        let vals = Array.empty
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     Array.empty
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <summary>Place holder for variable who cannot perform gradient</summary>
    static member NoGradient() =
        NoGradient()

    /// <summary>Batch normalization.
    /// 
    /// This operator is DEPRECATED. Perform BatchNorm on the input.
    /// 
    /// Normalizes a data batch by mean and variance, and applies a scale ``gamma`` as
    /// well as offset ``beta``.
    /// 
    /// Assume the input has more than one dimension and we normalize along axis 1.
    /// We first compute the mean and variance along this axis:
    /// 
    /// .. math::
    /// 
    ///   data\_mean[i] = mean(data[:,i,:,...]) \\
    ///   data\_var[i] = var(data[:,i,:,...])
    /// 
    /// Then compute the normalized output, which has the same shape as input, as following:
    /// 
    /// .. math::
    /// 
    ///   out[:,i,:,...] = \frac{data[:,i,:,...] - data\_mean[i]}{\sqrt{data\_var[i]+\epsilon}} * gamma[i] + beta[i]
    /// 
    /// Both *mean* and *var* returns a scalar by treating the input as a vector.
    /// 
    /// Assume the input has size *k* on axis 1, then both ``gamma`` and ``beta``
    /// have shape *(k,)*. If ``output_mean_var`` is set to be true, then outputs both ``data_mean`` and
    /// ``data_var`` as well, which are needed for the backward pass.
    /// 
    /// Besides the inputs and the outputs, this operator accepts two auxiliary
    /// states, ``moving_mean`` and ``moving_var``, which are *k*-length
    /// vectors. They are global statistics for the whole dataset, which are updated
    /// by::
    /// 
    ///   moving_mean = moving_mean * momentum + data_mean * (1 - momentum)
    ///   moving_var = moving_var * momentum + data_var * (1 - momentum)
    /// 
    /// If ``use_global_stats`` is set to be true, then ``moving_mean`` and
    /// ``moving_var`` are used instead of ``data_mean`` and ``data_var`` to compute
    /// the output. It is often used during inference.
    /// 
    /// Both ``gamma`` and ``beta`` are learnable parameters. But if ``fix_gamma`` is true,
    /// then set ``gamma`` to 1 and its gradient to 0.
    /// 
    /// There&#39;s no sparse support for this operator, and it will exhibit problematic behavior if used with
    /// sparse tensors.
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\batch_norm_v1.cc:L95</summary>
    /// <param name="data">Input data to batch normalization</param>
    /// <param name="gamma">gamma array</param>
    /// <param name="beta">beta array</param>
    /// <param name="eps">Epsilon to prevent div 0</param>
    /// <param name="momentum">Momentum for moving average</param>
    /// <param name="fixGamma">Fix gamma while training</param>
    /// <param name="useGlobalStats">Whether use global moving statistics instead of local batch-norm. This will force change batch-norm into a scale shift operator.</param>
    /// <param name="outputMeanVar">Output All,normal mean and var</param>
    static member BatchNormV1(data : NDArray, 
                              gamma : NDArray, 
                              beta : NDArray, 
                              [<Optional; DefaultParameterValue(0.00100000005)>] eps : float, 
                              [<Optional; DefaultParameterValue(0.899999976)>] momentum : float, 
                              [<Optional; DefaultParameterValue(true)>] fixGamma : bool, 
                              [<Optional; DefaultParameterValue(false)>] useGlobalStats : bool, 
                              [<Optional; DefaultParameterValue(false)>] outputMeanVar : bool) =
        let creator = AtomicSymbolCreator.FromName "BatchNorm_v1"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg gamma)) then gamma.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg beta)) then beta.UnsafeHandle|]
                                                 [|"eps"; "momentum"; "fix_gamma"; "use_global_stats"; "output_mean_var"|]
                                                 [|string eps; string momentum; string fixGamma; string useGlobalStats; string outputMeanVar|]
        (new NDArray(outputs.[0]))
    /// <summary>Batch normalization.
    /// 
    /// This operator is DEPRECATED. Perform BatchNorm on the input.
    /// 
    /// Normalizes a data batch by mean and variance, and applies a scale ``gamma`` as
    /// well as offset ``beta``.
    /// 
    /// Assume the input has more than one dimension and we normalize along axis 1.
    /// We first compute the mean and variance along this axis:
    /// 
    /// .. math::
    /// 
    ///   data\_mean[i] = mean(data[:,i,:,...]) \\
    ///   data\_var[i] = var(data[:,i,:,...])
    /// 
    /// Then compute the normalized output, which has the same shape as input, as following:
    /// 
    /// .. math::
    /// 
    ///   out[:,i,:,...] = \frac{data[:,i,:,...] - data\_mean[i]}{\sqrt{data\_var[i]+\epsilon}} * gamma[i] + beta[i]
    /// 
    /// Both *mean* and *var* returns a scalar by treating the input as a vector.
    /// 
    /// Assume the input has size *k* on axis 1, then both ``gamma`` and ``beta``
    /// have shape *(k,)*. If ``output_mean_var`` is set to be true, then outputs both ``data_mean`` and
    /// ``data_var`` as well, which are needed for the backward pass.
    /// 
    /// Besides the inputs and the outputs, this operator accepts two auxiliary
    /// states, ``moving_mean`` and ``moving_var``, which are *k*-length
    /// vectors. They are global statistics for the whole dataset, which are updated
    /// by::
    /// 
    ///   moving_mean = moving_mean * momentum + data_mean * (1 - momentum)
    ///   moving_var = moving_var * momentum + data_var * (1 - momentum)
    /// 
    /// If ``use_global_stats`` is set to be true, then ``moving_mean`` and
    /// ``moving_var`` are used instead of ``data_mean`` and ``data_var`` to compute
    /// the output. It is often used during inference.
    /// 
    /// Both ``gamma`` and ``beta`` are learnable parameters. But if ``fix_gamma`` is true,
    /// then set ``gamma`` to 1 and its gradient to 0.
    /// 
    /// There&#39;s no sparse support for this operator, and it will exhibit problematic behavior if used with
    /// sparse tensors.
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\batch_norm_v1.cc:L95</summary>
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="data">Input data to batch normalization</param>
    /// <param name="gamma">gamma array</param>
    /// <param name="beta">beta array</param>
    /// <param name="eps">Epsilon to prevent div 0</param>
    /// <param name="momentum">Momentum for moving average</param>
    /// <param name="fixGamma">Fix gamma while training</param>
    /// <param name="useGlobalStats">Whether use global moving statistics instead of local batch-norm. This will force change batch-norm into a scale shift operator.</param>
    /// <param name="outputMeanVar">Output All,normal mean and var</param>
    static member BatchNormV1(outputArray : NDArray seq, 
                              data : NDArray, 
                              gamma : NDArray, 
                              beta : NDArray, 
                              [<Optional; DefaultParameterValue(0.00100000005)>] eps : float, 
                              [<Optional; DefaultParameterValue(0.899999976)>] momentum : float, 
                              [<Optional; DefaultParameterValue(true)>] fixGamma : bool, 
                              [<Optional; DefaultParameterValue(false)>] useGlobalStats : bool, 
                              [<Optional; DefaultParameterValue(false)>] outputMeanVar : bool) =
        let creator = AtomicSymbolCreator.FromName "BatchNorm_v1"
        let names = [|"eps"; "momentum"; "fix_gamma"; "use_global_stats"; "output_mean_var"|]
        let vals = [|string eps; string momentum; string fixGamma; string useGlobalStats; string outputMeanVar|]
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg gamma)) then gamma.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg beta)) then beta.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <summary>Batch normalization.
    /// 
    /// This operator is DEPRECATED. Perform BatchNorm on the input.
    /// 
    /// Normalizes a data batch by mean and variance, and applies a scale ``gamma`` as
    /// well as offset ``beta``.
    /// 
    /// Assume the input has more than one dimension and we normalize along axis 1.
    /// We first compute the mean and variance along this axis:
    /// 
    /// .. math::
    /// 
    ///   data\_mean[i] = mean(data[:,i,:,...]) \\
    ///   data\_var[i] = var(data[:,i,:,...])
    /// 
    /// Then compute the normalized output, which has the same shape as input, as following:
    /// 
    /// .. math::
    /// 
    ///   out[:,i,:,...] = \frac{data[:,i,:,...] - data\_mean[i]}{\sqrt{data\_var[i]+\epsilon}} * gamma[i] + beta[i]
    /// 
    /// Both *mean* and *var* returns a scalar by treating the input as a vector.
    /// 
    /// Assume the input has size *k* on axis 1, then both ``gamma`` and ``beta``
    /// have shape *(k,)*. If ``output_mean_var`` is set to be true, then outputs both ``data_mean`` and
    /// ``data_var`` as well, which are needed for the backward pass.
    /// 
    /// Besides the inputs and the outputs, this operator accepts two auxiliary
    /// states, ``moving_mean`` and ``moving_var``, which are *k*-length
    /// vectors. They are global statistics for the whole dataset, which are updated
    /// by::
    /// 
    ///   moving_mean = moving_mean * momentum + data_mean * (1 - momentum)
    ///   moving_var = moving_var * momentum + data_var * (1 - momentum)
    /// 
    /// If ``use_global_stats`` is set to be true, then ``moving_mean`` and
    /// ``moving_var`` are used instead of ``data_mean`` and ``data_var`` to compute
    /// the output. It is often used during inference.
    /// 
    /// Both ``gamma`` and ``beta`` are learnable parameters. But if ``fix_gamma`` is true,
    /// then set ``gamma`` to 1 and its gradient to 0.
    /// 
    /// There&#39;s no sparse support for this operator, and it will exhibit problematic behavior if used with
    /// sparse tensors.
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\batch_norm_v1.cc:L95</summary>
    /// <param name="data">Input data to batch normalization</param>
    /// <param name="gamma">gamma array</param>
    /// <param name="beta">beta array</param>
    /// <param name="eps">Epsilon to prevent div 0</param>
    /// <param name="momentum">Momentum for moving average</param>
    /// <param name="fixGamma">Fix gamma while training</param>
    /// <param name="useGlobalStats">Whether use global moving statistics instead of local batch-norm. This will force change batch-norm into a scale shift operator.</param>
    /// <param name="outputMeanVar">Output All,normal mean and var</param>
    static member BatchNormV1([<Optional>] ?data : Symbol, [<Optional>] ?gamma : Symbol, [<Optional>] ?beta : Symbol, [<Optional>] ?eps : float, [<Optional>] ?momentum : float, [<Optional>] ?fixGamma : bool, [<Optional>] ?useGlobalStats : bool, [<Optional>] ?outputMeanVar : bool) =
        BatchNormV1(?data = data, ?gamma = gamma, ?beta = beta, ?eps = eps, ?momentum = momentum, ?fixGamma = fixGamma, ?useGlobalStats = useGlobalStats, ?outputMeanVar = outputMeanVar)

    /// <summary>Update function for multi-precision AdamW optimizer.
    /// 
    /// AdamW is seen as a modification of Adam by decoupling the weight decay from the
    /// optimization steps taken w.r.t. the loss function.
    /// 
    /// Adam update consists of the following steps, where g represents gradient and m, v
    /// are 1st and 2nd order moment estimates (mean and variance).
    /// 
    /// .. math::
    /// 
    ///  g_t = \nabla J(W_{t-1})\\
    ///  m_t = \beta_1 m_{t-1} + (1 - \beta_1) g_t\\
    ///  v_t = \beta_2 v_{t-1} + (1 - \beta_2) g_t^2\\
    ///  W_t = W_{t-1} - \eta_t (\alpha \frac{ m_t }{ \sqrt{ v_t } + \epsilon } + wd W_{t-1})
    /// 
    /// It updates the weights using::
    /// 
    ///  m = beta1*m + (1-beta1)*grad
    ///  v = beta2*v + (1-beta2)*(grad**2)
    ///  w -= eta * (learning_rate * m / (sqrt(v) + epsilon) + w * wd)
    /// 
    /// Note that gradient is rescaled to grad = rescale_grad * grad. If rescale_grad is NaN, Inf, or 0,
    /// the update is skipped.
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\contrib\adamw.cc:L58</summary>
    /// <param name="weight">Weight</param>
    /// <param name="grad">Gradient</param>
    /// <param name="mean">Moving mean</param>
    /// <param name="var">Moving variance</param>
    /// <param name="weight32">Weight32</param>
    /// <param name="rescaleGrad">Rescale gradient to rescale_grad * grad. If NaN, Inf, or 0, the update is skipped.</param>
    /// <param name="lr">Learning rate</param>
    /// <param name="eta">Learning rate schedule multiplier</param>
    /// <param name="beta1">The decay rate for the 1st moment estimates.</param>
    /// <param name="beta2">The decay rate for the 2nd moment estimates.</param>
    /// <param name="epsilon">A small constant for numerical stability.</param>
    /// <param name="wd">Weight decay augments the objective function with a regularization term that penalizes large weights. The penalty scales with the square of the magnitude of each weight.</param>
    /// <param name="clipGradient">Clip gradient to the range of [-clip_gradient, clip_gradient] If clip_gradient &lt;= 0, gradient clipping is turned off. grad = max(min(grad, clip_gradient), -clip_gradient).</param>
    static member MpAdamwUpdate(weight : NDArray, 
                                grad : NDArray, 
                                mean : NDArray, 
                                var : NDArray, 
                                weight32 : NDArray, 
                                rescaleGrad : NDArray, 
                                lr : float, 
                                eta : float, 
                                [<Optional; DefaultParameterValue(0.899999976)>] beta1 : float, 
                                [<Optional; DefaultParameterValue(0.999000013)>] beta2 : float, 
                                [<Optional; DefaultParameterValue(9.99999994E-09)>] epsilon : float, 
                                [<Optional; DefaultParameterValue(0.0)>] wd : float, 
                                [<Optional; DefaultParameterValue(-1.0)>] clipGradient : float) =
        let creator = AtomicSymbolCreator.FromName "_mp_adamw_update"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg weight)) then weight.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg grad)) then grad.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg mean)) then mean.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg var)) then var.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg weight32)) then weight32.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg rescaleGrad)) then rescaleGrad.UnsafeHandle|]
                                                 [|"lr"; "eta"; "beta1"; "beta2"; "epsilon"; "wd"; "clip_gradient"|]
                                                 [|string lr; string eta; string beta1; string beta2; string epsilon; string wd; string clipGradient|]
        (new NDArray(outputs.[0]))
    /// <summary>Update function for multi-precision AdamW optimizer.
    /// 
    /// AdamW is seen as a modification of Adam by decoupling the weight decay from the
    /// optimization steps taken w.r.t. the loss function.
    /// 
    /// Adam update consists of the following steps, where g represents gradient and m, v
    /// are 1st and 2nd order moment estimates (mean and variance).
    /// 
    /// .. math::
    /// 
    ///  g_t = \nabla J(W_{t-1})\\
    ///  m_t = \beta_1 m_{t-1} + (1 - \beta_1) g_t\\
    ///  v_t = \beta_2 v_{t-1} + (1 - \beta_2) g_t^2\\
    ///  W_t = W_{t-1} - \eta_t (\alpha \frac{ m_t }{ \sqrt{ v_t } + \epsilon } + wd W_{t-1})
    /// 
    /// It updates the weights using::
    /// 
    ///  m = beta1*m + (1-beta1)*grad
    ///  v = beta2*v + (1-beta2)*(grad**2)
    ///  w -= eta * (learning_rate * m / (sqrt(v) + epsilon) + w * wd)
    /// 
    /// Note that gradient is rescaled to grad = rescale_grad * grad. If rescale_grad is NaN, Inf, or 0,
    /// the update is skipped.
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\contrib\adamw.cc:L58</summary>
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="weight">Weight</param>
    /// <param name="grad">Gradient</param>
    /// <param name="mean">Moving mean</param>
    /// <param name="var">Moving variance</param>
    /// <param name="weight32">Weight32</param>
    /// <param name="rescaleGrad">Rescale gradient to rescale_grad * grad. If NaN, Inf, or 0, the update is skipped.</param>
    /// <param name="lr">Learning rate</param>
    /// <param name="eta">Learning rate schedule multiplier</param>
    /// <param name="beta1">The decay rate for the 1st moment estimates.</param>
    /// <param name="beta2">The decay rate for the 2nd moment estimates.</param>
    /// <param name="epsilon">A small constant for numerical stability.</param>
    /// <param name="wd">Weight decay augments the objective function with a regularization term that penalizes large weights. The penalty scales with the square of the magnitude of each weight.</param>
    /// <param name="clipGradient">Clip gradient to the range of [-clip_gradient, clip_gradient] If clip_gradient &lt;= 0, gradient clipping is turned off. grad = max(min(grad, clip_gradient), -clip_gradient).</param>
    static member MpAdamwUpdate(outputArray : NDArray seq, 
                                weight : NDArray, 
                                grad : NDArray, 
                                mean : NDArray, 
                                var : NDArray, 
                                weight32 : NDArray, 
                                rescaleGrad : NDArray, 
                                lr : float, 
                                eta : float, 
                                [<Optional; DefaultParameterValue(0.899999976)>] beta1 : float, 
                                [<Optional; DefaultParameterValue(0.999000013)>] beta2 : float, 
                                [<Optional; DefaultParameterValue(9.99999994E-09)>] epsilon : float, 
                                [<Optional; DefaultParameterValue(0.0)>] wd : float, 
                                [<Optional; DefaultParameterValue(-1.0)>] clipGradient : float) =
        let creator = AtomicSymbolCreator.FromName "_mp_adamw_update"
        let names = [|"lr"; "eta"; "beta1"; "beta2"; "epsilon"; "wd"; "clip_gradient"|]
        let vals = [|string lr; string eta; string beta1; string beta2; string epsilon; string wd; string clipGradient|]
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg weight)) then weight.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg grad)) then grad.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg mean)) then mean.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg var)) then var.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg weight32)) then weight32.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg rescaleGrad)) then rescaleGrad.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <summary>Update function for multi-precision AdamW optimizer.
    /// 
    /// AdamW is seen as a modification of Adam by decoupling the weight decay from the
    /// optimization steps taken w.r.t. the loss function.
    /// 
    /// Adam update consists of the following steps, where g represents gradient and m, v
    /// are 1st and 2nd order moment estimates (mean and variance).
    /// 
    /// .. math::
    /// 
    ///  g_t = \nabla J(W_{t-1})\\
    ///  m_t = \beta_1 m_{t-1} + (1 - \beta_1) g_t\\
    ///  v_t = \beta_2 v_{t-1} + (1 - \beta_2) g_t^2\\
    ///  W_t = W_{t-1} - \eta_t (\alpha \frac{ m_t }{ \sqrt{ v_t } + \epsilon } + wd W_{t-1})
    /// 
    /// It updates the weights using::
    /// 
    ///  m = beta1*m + (1-beta1)*grad
    ///  v = beta2*v + (1-beta2)*(grad**2)
    ///  w -= eta * (learning_rate * m / (sqrt(v) + epsilon) + w * wd)
    /// 
    /// Note that gradient is rescaled to grad = rescale_grad * grad. If rescale_grad is NaN, Inf, or 0,
    /// the update is skipped.
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\contrib\adamw.cc:L58</summary>
    /// <param name="weight">Weight</param>
    /// <param name="grad">Gradient</param>
    /// <param name="mean">Moving mean</param>
    /// <param name="var">Moving variance</param>
    /// <param name="weight32">Weight32</param>
    /// <param name="rescaleGrad">Rescale gradient to rescale_grad * grad. If NaN, Inf, or 0, the update is skipped.</param>
    /// <param name="lr">Learning rate</param>
    /// <param name="eta">Learning rate schedule multiplier</param>
    /// <param name="beta1">The decay rate for the 1st moment estimates.</param>
    /// <param name="beta2">The decay rate for the 2nd moment estimates.</param>
    /// <param name="epsilon">A small constant for numerical stability.</param>
    /// <param name="wd">Weight decay augments the objective function with a regularization term that penalizes large weights. The penalty scales with the square of the magnitude of each weight.</param>
    /// <param name="clipGradient">Clip gradient to the range of [-clip_gradient, clip_gradient] If clip_gradient &lt;= 0, gradient clipping is turned off. grad = max(min(grad, clip_gradient), -clip_gradient).</param>
    static member MpAdamwUpdate(weight : Symbol, grad : Symbol, mean : Symbol, var : Symbol, weight32 : Symbol, rescaleGrad : Symbol, lr : float, eta : float, [<Optional>] ?beta1 : float, [<Optional>] ?beta2 : float, [<Optional>] ?epsilon : float, [<Optional>] ?wd : float, [<Optional>] ?clipGradient : float) =
        MpAdamwUpdate(weight, grad, mean, var, weight32, rescaleGrad, lr, eta, ?beta1 = beta1, ?beta2 = beta2, ?epsilon = epsilon, ?wd = wd, ?clipGradient = clipGradient)
    /// <summary>Update function for multi-precision AdamW optimizer.
    /// 
    /// AdamW is seen as a modification of Adam by decoupling the weight decay from the
    /// optimization steps taken w.r.t. the loss function.
    /// 
    /// Adam update consists of the following steps, where g represents gradient and m, v
    /// are 1st and 2nd order moment estimates (mean and variance).
    /// 
    /// .. math::
    /// 
    ///  g_t = \nabla J(W_{t-1})\\
    ///  m_t = \beta_1 m_{t-1} + (1 - \beta_1) g_t\\
    ///  v_t = \beta_2 v_{t-1} + (1 - \beta_2) g_t^2\\
    ///  W_t = W_{t-1} - \eta_t (\alpha \frac{ m_t }{ \sqrt{ v_t } + \epsilon } + wd W_{t-1})
    /// 
    /// It updates the weights using::
    /// 
    ///  m = beta1*m + (1-beta1)*grad
    ///  v = beta2*v + (1-beta2)*(grad**2)
    ///  w -= eta * (learning_rate * m / (sqrt(v) + epsilon) + w * wd)
    /// 
    /// Note that gradient is rescaled to grad = rescale_grad * grad. If rescale_grad is NaN, Inf, or 0,
    /// the update is skipped.
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\contrib\adamw.cc:L58</summary>
    /// <param name="lr">Learning rate</param>
    /// <param name="eta">Learning rate schedule multiplier</param>
    /// <param name="weight">Weight</param>
    /// <param name="grad">Gradient</param>
    /// <param name="mean">Moving mean</param>
    /// <param name="var">Moving variance</param>
    /// <param name="weight32">Weight32</param>
    /// <param name="rescaleGrad">Rescale gradient to rescale_grad * grad. If NaN, Inf, or 0, the update is skipped.</param>
    /// <param name="beta1">The decay rate for the 1st moment estimates.</param>
    /// <param name="beta2">The decay rate for the 2nd moment estimates.</param>
    /// <param name="epsilon">A small constant for numerical stability.</param>
    /// <param name="wd">Weight decay augments the objective function with a regularization term that penalizes large weights. The penalty scales with the square of the magnitude of each weight.</param>
    /// <param name="clipGradient">Clip gradient to the range of [-clip_gradient, clip_gradient] If clip_gradient &lt;= 0, gradient clipping is turned off. grad = max(min(grad, clip_gradient), -clip_gradient).</param>
    static member MpAdamwUpdate(lr : float, eta : float, [<Optional>] ?weight : Symbol, [<Optional>] ?grad : Symbol, [<Optional>] ?mean : Symbol, [<Optional>] ?var : Symbol, [<Optional>] ?weight32 : Symbol, [<Optional>] ?rescaleGrad : Symbol, [<Optional>] ?beta1 : float, [<Optional>] ?beta2 : float, [<Optional>] ?epsilon : float, [<Optional>] ?wd : float, [<Optional>] ?clipGradient : float) =
        MpAdamwUpdate(lr, eta, ?weight = weight, ?grad = grad, ?mean = mean, ?var = var, ?weight32 = weight32, ?rescaleGrad = rescaleGrad, ?beta1 = beta1, ?beta2 = beta2, ?epsilon = epsilon, ?wd = wd, ?clipGradient = clipGradient)

    /// <summary>Update function for AdamW optimizer. AdamW is seen as a modification of
    /// Adam by decoupling the weight decay from the optimization steps taken w.r.t. the loss function.
    /// 
    /// Adam update consists of the following steps, where g represents gradient and m, v
    /// are 1st and 2nd order moment estimates (mean and variance).
    /// 
    /// .. math::
    /// 
    ///  g_t = \nabla J(W_{t-1})\\
    ///  m_t = \beta_1 m_{t-1} + (1 - \beta_1) g_t\\
    ///  v_t = \beta_2 v_{t-1} + (1 - \beta_2) g_t^2\\
    ///  W_t = W_{t-1} - \eta_t (\alpha \frac{ m_t }{ \sqrt{ v_t } + \epsilon } + wd W_{t-1})
    /// 
    /// It updates the weights using::
    /// 
    ///  m = beta1*m + (1-beta1)*grad
    ///  v = beta2*v + (1-beta2)*(grad**2)
    ///  w -= eta * (learning_rate * m / (sqrt(v) + epsilon) + w * wd)
    /// 
    /// Note that gradient is rescaled to grad = rescale_grad * grad. If rescale_grad is NaN, Inf, or 0,
    /// the update is skipped.
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\contrib\adamw.cc:L101</summary>
    /// <param name="weight">Weight</param>
    /// <param name="grad">Gradient</param>
    /// <param name="mean">Moving mean</param>
    /// <param name="var">Moving variance</param>
    /// <param name="rescaleGrad">Rescale gradient to rescale_grad * grad. If NaN, Inf, or 0, the update is skipped.</param>
    /// <param name="lr">Learning rate</param>
    /// <param name="eta">Learning rate schedule multiplier</param>
    /// <param name="beta1">The decay rate for the 1st moment estimates.</param>
    /// <param name="beta2">The decay rate for the 2nd moment estimates.</param>
    /// <param name="epsilon">A small constant for numerical stability.</param>
    /// <param name="wd">Weight decay augments the objective function with a regularization term that penalizes large weights. The penalty scales with the square of the magnitude of each weight.</param>
    /// <param name="clipGradient">Clip gradient to the range of [-clip_gradient, clip_gradient] If clip_gradient &lt;= 0, gradient clipping is turned off. grad = max(min(grad, clip_gradient), -clip_gradient).</param>
    static member AdamwUpdate(weight : NDArray, 
                              grad : NDArray, 
                              mean : NDArray, 
                              var : NDArray, 
                              rescaleGrad : NDArray, 
                              lr : float, 
                              eta : float, 
                              [<Optional; DefaultParameterValue(0.899999976)>] beta1 : float, 
                              [<Optional; DefaultParameterValue(0.999000013)>] beta2 : float, 
                              [<Optional; DefaultParameterValue(9.99999994E-09)>] epsilon : float, 
                              [<Optional; DefaultParameterValue(0.0)>] wd : float, 
                              [<Optional; DefaultParameterValue(-1.0)>] clipGradient : float) =
        let creator = AtomicSymbolCreator.FromName "_adamw_update"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg weight)) then weight.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg grad)) then grad.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg mean)) then mean.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg var)) then var.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg rescaleGrad)) then rescaleGrad.UnsafeHandle|]
                                                 [|"lr"; "eta"; "beta1"; "beta2"; "epsilon"; "wd"; "clip_gradient"|]
                                                 [|string lr; string eta; string beta1; string beta2; string epsilon; string wd; string clipGradient|]
        (new NDArray(outputs.[0]))
    /// <summary>Update function for AdamW optimizer. AdamW is seen as a modification of
    /// Adam by decoupling the weight decay from the optimization steps taken w.r.t. the loss function.
    /// 
    /// Adam update consists of the following steps, where g represents gradient and m, v
    /// are 1st and 2nd order moment estimates (mean and variance).
    /// 
    /// .. math::
    /// 
    ///  g_t = \nabla J(W_{t-1})\\
    ///  m_t = \beta_1 m_{t-1} + (1 - \beta_1) g_t\\
    ///  v_t = \beta_2 v_{t-1} + (1 - \beta_2) g_t^2\\
    ///  W_t = W_{t-1} - \eta_t (\alpha \frac{ m_t }{ \sqrt{ v_t } + \epsilon } + wd W_{t-1})
    /// 
    /// It updates the weights using::
    /// 
    ///  m = beta1*m + (1-beta1)*grad
    ///  v = beta2*v + (1-beta2)*(grad**2)
    ///  w -= eta * (learning_rate * m / (sqrt(v) + epsilon) + w * wd)
    /// 
    /// Note that gradient is rescaled to grad = rescale_grad * grad. If rescale_grad is NaN, Inf, or 0,
    /// the update is skipped.
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\contrib\adamw.cc:L101</summary>
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="weight">Weight</param>
    /// <param name="grad">Gradient</param>
    /// <param name="mean">Moving mean</param>
    /// <param name="var">Moving variance</param>
    /// <param name="rescaleGrad">Rescale gradient to rescale_grad * grad. If NaN, Inf, or 0, the update is skipped.</param>
    /// <param name="lr">Learning rate</param>
    /// <param name="eta">Learning rate schedule multiplier</param>
    /// <param name="beta1">The decay rate for the 1st moment estimates.</param>
    /// <param name="beta2">The decay rate for the 2nd moment estimates.</param>
    /// <param name="epsilon">A small constant for numerical stability.</param>
    /// <param name="wd">Weight decay augments the objective function with a regularization term that penalizes large weights. The penalty scales with the square of the magnitude of each weight.</param>
    /// <param name="clipGradient">Clip gradient to the range of [-clip_gradient, clip_gradient] If clip_gradient &lt;= 0, gradient clipping is turned off. grad = max(min(grad, clip_gradient), -clip_gradient).</param>
    static member AdamwUpdate(outputArray : NDArray seq, 
                              weight : NDArray, 
                              grad : NDArray, 
                              mean : NDArray, 
                              var : NDArray, 
                              rescaleGrad : NDArray, 
                              lr : float, 
                              eta : float, 
                              [<Optional; DefaultParameterValue(0.899999976)>] beta1 : float, 
                              [<Optional; DefaultParameterValue(0.999000013)>] beta2 : float, 
                              [<Optional; DefaultParameterValue(9.99999994E-09)>] epsilon : float, 
                              [<Optional; DefaultParameterValue(0.0)>] wd : float, 
                              [<Optional; DefaultParameterValue(-1.0)>] clipGradient : float) =
        let creator = AtomicSymbolCreator.FromName "_adamw_update"
        let names = [|"lr"; "eta"; "beta1"; "beta2"; "epsilon"; "wd"; "clip_gradient"|]
        let vals = [|string lr; string eta; string beta1; string beta2; string epsilon; string wd; string clipGradient|]
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg weight)) then weight.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg grad)) then grad.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg mean)) then mean.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg var)) then var.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg rescaleGrad)) then rescaleGrad.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <summary>Update function for AdamW optimizer. AdamW is seen as a modification of
    /// Adam by decoupling the weight decay from the optimization steps taken w.r.t. the loss function.
    /// 
    /// Adam update consists of the following steps, where g represents gradient and m, v
    /// are 1st and 2nd order moment estimates (mean and variance).
    /// 
    /// .. math::
    /// 
    ///  g_t = \nabla J(W_{t-1})\\
    ///  m_t = \beta_1 m_{t-1} + (1 - \beta_1) g_t\\
    ///  v_t = \beta_2 v_{t-1} + (1 - \beta_2) g_t^2\\
    ///  W_t = W_{t-1} - \eta_t (\alpha \frac{ m_t }{ \sqrt{ v_t } + \epsilon } + wd W_{t-1})
    /// 
    /// It updates the weights using::
    /// 
    ///  m = beta1*m + (1-beta1)*grad
    ///  v = beta2*v + (1-beta2)*(grad**2)
    ///  w -= eta * (learning_rate * m / (sqrt(v) + epsilon) + w * wd)
    /// 
    /// Note that gradient is rescaled to grad = rescale_grad * grad. If rescale_grad is NaN, Inf, or 0,
    /// the update is skipped.
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\contrib\adamw.cc:L101</summary>
    /// <param name="weight">Weight</param>
    /// <param name="grad">Gradient</param>
    /// <param name="mean">Moving mean</param>
    /// <param name="var">Moving variance</param>
    /// <param name="rescaleGrad">Rescale gradient to rescale_grad * grad. If NaN, Inf, or 0, the update is skipped.</param>
    /// <param name="lr">Learning rate</param>
    /// <param name="eta">Learning rate schedule multiplier</param>
    /// <param name="beta1">The decay rate for the 1st moment estimates.</param>
    /// <param name="beta2">The decay rate for the 2nd moment estimates.</param>
    /// <param name="epsilon">A small constant for numerical stability.</param>
    /// <param name="wd">Weight decay augments the objective function with a regularization term that penalizes large weights. The penalty scales with the square of the magnitude of each weight.</param>
    /// <param name="clipGradient">Clip gradient to the range of [-clip_gradient, clip_gradient] If clip_gradient &lt;= 0, gradient clipping is turned off. grad = max(min(grad, clip_gradient), -clip_gradient).</param>
    static member AdamwUpdate(weight : Symbol, grad : Symbol, mean : Symbol, var : Symbol, rescaleGrad : Symbol, lr : float, eta : float, [<Optional>] ?beta1 : float, [<Optional>] ?beta2 : float, [<Optional>] ?epsilon : float, [<Optional>] ?wd : float, [<Optional>] ?clipGradient : float) =
        AdamwUpdate(weight, grad, mean, var, rescaleGrad, lr, eta, ?beta1 = beta1, ?beta2 = beta2, ?epsilon = epsilon, ?wd = wd, ?clipGradient = clipGradient)
    /// <summary>Update function for AdamW optimizer. AdamW is seen as a modification of
    /// Adam by decoupling the weight decay from the optimization steps taken w.r.t. the loss function.
    /// 
    /// Adam update consists of the following steps, where g represents gradient and m, v
    /// are 1st and 2nd order moment estimates (mean and variance).
    /// 
    /// .. math::
    /// 
    ///  g_t = \nabla J(W_{t-1})\\
    ///  m_t = \beta_1 m_{t-1} + (1 - \beta_1) g_t\\
    ///  v_t = \beta_2 v_{t-1} + (1 - \beta_2) g_t^2\\
    ///  W_t = W_{t-1} - \eta_t (\alpha \frac{ m_t }{ \sqrt{ v_t } + \epsilon } + wd W_{t-1})
    /// 
    /// It updates the weights using::
    /// 
    ///  m = beta1*m + (1-beta1)*grad
    ///  v = beta2*v + (1-beta2)*(grad**2)
    ///  w -= eta * (learning_rate * m / (sqrt(v) + epsilon) + w * wd)
    /// 
    /// Note that gradient is rescaled to grad = rescale_grad * grad. If rescale_grad is NaN, Inf, or 0,
    /// the update is skipped.
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\contrib\adamw.cc:L101</summary>
    /// <param name="lr">Learning rate</param>
    /// <param name="eta">Learning rate schedule multiplier</param>
    /// <param name="weight">Weight</param>
    /// <param name="grad">Gradient</param>
    /// <param name="mean">Moving mean</param>
    /// <param name="var">Moving variance</param>
    /// <param name="rescaleGrad">Rescale gradient to rescale_grad * grad. If NaN, Inf, or 0, the update is skipped.</param>
    /// <param name="beta1">The decay rate for the 1st moment estimates.</param>
    /// <param name="beta2">The decay rate for the 2nd moment estimates.</param>
    /// <param name="epsilon">A small constant for numerical stability.</param>
    /// <param name="wd">Weight decay augments the objective function with a regularization term that penalizes large weights. The penalty scales with the square of the magnitude of each weight.</param>
    /// <param name="clipGradient">Clip gradient to the range of [-clip_gradient, clip_gradient] If clip_gradient &lt;= 0, gradient clipping is turned off. grad = max(min(grad, clip_gradient), -clip_gradient).</param>
    static member AdamwUpdate(lr : float, eta : float, [<Optional>] ?weight : Symbol, [<Optional>] ?grad : Symbol, [<Optional>] ?mean : Symbol, [<Optional>] ?var : Symbol, [<Optional>] ?rescaleGrad : Symbol, [<Optional>] ?beta1 : float, [<Optional>] ?beta2 : float, [<Optional>] ?epsilon : float, [<Optional>] ?wd : float, [<Optional>] ?clipGradient : float) =
        AdamwUpdate(lr, eta, ?weight = weight, ?grad = grad, ?mean = mean, ?var = var, ?rescaleGrad = rescaleGrad, ?beta1 = beta1, ?beta2 = beta2, ?epsilon = epsilon, ?wd = wd, ?clipGradient = clipGradient)

    /// <summary>Update function for AdamW optimizer.
    /// 
    /// AdamW is seen as a modification of Adam by decoupling the weight decay from the
    /// optimization steps taken w.r.t. the loss function.
    /// 
    /// Adam update consists of the following steps, where g represents gradient and m, v
    /// are 1st and 2nd order moment estimates (mean and variance).
    /// 
    /// .. math::
    /// 
    ///  g_t = \nabla J(W_{t-1})\\
    ///  m_t = \beta_1 m_{t-1} + (1 - \beta_1) g_t\\
    ///  v_t = \beta_2 v_{t-1} + (1 - \beta_2) g_t^2\\
    ///  W_t = W_{t-1} - \eta_t (\alpha \frac{ m_t }{ \sqrt{ v_t } + \epsilon } + wd W_{t-1})
    /// 
    /// It updates the weights using::
    /// 
    ///  m = beta1*m + (1-beta1)*grad
    ///  v = beta2*v + (1-beta2)*(grad**2)
    ///  w -= eta * (learning_rate * m / (sqrt(v) + epsilon) + w * wd)
    /// 
    /// Note that gradient is rescaled to grad = rescale_grad * grad. If rescale_grad is NaN, Inf, or 0,
    /// the update is skipped.
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\contrib\adamw.cc:L167</summary>
    /// <param name="data">data</param>
    /// <param name="lrs">Learning rates</param>
    /// <param name="wds">Weight decay augments the objective function with a regularization term that penalizes large weights. The penalty scales with the square of the magnitude of each weight.</param>
    /// <param name="etas">Learning rates schedule multiplier</param>
    /// <param name="beta1">The decay rate for the 1st moment estimates.</param>
    /// <param name="beta2">The decay rate for the 2nd moment estimates.</param>
    /// <param name="epsilon">A small constant for numerical stability.</param>
    /// <param name="clipGradient">Clip gradient to the range of [-clip_gradient, clip_gradient] If clip_gradient &lt;= 0, gradient clipping is turned off. grad = max(min(grad, clip_gradient), -clip_gradient).</param>
    /// <param name="numWeights">Number of updated weights.</param>
    static member MultiAdamwUpdate([<ParamArray>] data : NDArray[], 
                                   lrs : double seq, 
                                   wds : double seq, 
                                   etas : double seq, 
                                   [<Optional; DefaultParameterValue(0.899999976)>] beta1 : float, 
                                   [<Optional; DefaultParameterValue(0.999000013)>] beta2 : float, 
                                   [<Optional; DefaultParameterValue(9.99999994E-09)>] epsilon : float, 
                                   [<Optional; DefaultParameterValue(-1.0)>] clipGradient : float, 
                                   [<Optional; DefaultParameterValue(1)>] numWeights : int) =
        let creator = AtomicSymbolCreator.FromName "_multi_adamw_update"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 (data |> Array.map (fun x -> x.UnsafeHandle))
                                                 [|"lrs"; "wds"; "etas"; "beta1"; "beta2"; "epsilon"; "clip_gradient"; "num_weights"|]
                                                 [|string lrs; string wds; string etas; string beta1; string beta2; string epsilon; string clipGradient; string numWeights|]
        outputs |> Array.map (fun h -> new NDArray(h))
    /// <summary>Update function for AdamW optimizer.
    /// 
    /// AdamW is seen as a modification of Adam by decoupling the weight decay from the
    /// optimization steps taken w.r.t. the loss function.
    /// 
    /// Adam update consists of the following steps, where g represents gradient and m, v
    /// are 1st and 2nd order moment estimates (mean and variance).
    /// 
    /// .. math::
    /// 
    ///  g_t = \nabla J(W_{t-1})\\
    ///  m_t = \beta_1 m_{t-1} + (1 - \beta_1) g_t\\
    ///  v_t = \beta_2 v_{t-1} + (1 - \beta_2) g_t^2\\
    ///  W_t = W_{t-1} - \eta_t (\alpha \frac{ m_t }{ \sqrt{ v_t } + \epsilon } + wd W_{t-1})
    /// 
    /// It updates the weights using::
    /// 
    ///  m = beta1*m + (1-beta1)*grad
    ///  v = beta2*v + (1-beta2)*(grad**2)
    ///  w -= eta * (learning_rate * m / (sqrt(v) + epsilon) + w * wd)
    /// 
    /// Note that gradient is rescaled to grad = rescale_grad * grad. If rescale_grad is NaN, Inf, or 0,
    /// the update is skipped.
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\contrib\adamw.cc:L167</summary>
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="data">data</param>
    /// <param name="lrs">Learning rates</param>
    /// <param name="wds">Weight decay augments the objective function with a regularization term that penalizes large weights. The penalty scales with the square of the magnitude of each weight.</param>
    /// <param name="etas">Learning rates schedule multiplier</param>
    /// <param name="beta1">The decay rate for the 1st moment estimates.</param>
    /// <param name="beta2">The decay rate for the 2nd moment estimates.</param>
    /// <param name="epsilon">A small constant for numerical stability.</param>
    /// <param name="clipGradient">Clip gradient to the range of [-clip_gradient, clip_gradient] If clip_gradient &lt;= 0, gradient clipping is turned off. grad = max(min(grad, clip_gradient), -clip_gradient).</param>
    /// <param name="numWeights">Number of updated weights.</param>
    static member MultiAdamwUpdate(outputArray : NDArray seq, 
                                   [<ParamArray>] data : NDArray[], 
                                   lrs : double seq, 
                                   wds : double seq, 
                                   etas : double seq, 
                                   [<Optional; DefaultParameterValue(0.899999976)>] beta1 : float, 
                                   [<Optional; DefaultParameterValue(0.999000013)>] beta2 : float, 
                                   [<Optional; DefaultParameterValue(9.99999994E-09)>] epsilon : float, 
                                   [<Optional; DefaultParameterValue(-1.0)>] clipGradient : float, 
                                   [<Optional; DefaultParameterValue(1)>] numWeights : int) =
        let creator = AtomicSymbolCreator.FromName "_multi_adamw_update"
        let names = [|"lrs"; "wds"; "etas"; "beta1"; "beta2"; "epsilon"; "clip_gradient"; "num_weights"|]
        let vals = [|string lrs; string wds; string etas; string beta1; string beta2; string epsilon; string clipGradient; string numWeights|]
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     (data |> Array.map (fun x -> x.UnsafeHandle))
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <summary>Update function for AdamW optimizer.
    /// 
    /// AdamW is seen as a modification of Adam by decoupling the weight decay from the
    /// optimization steps taken w.r.t. the loss function.
    /// 
    /// Adam update consists of the following steps, where g represents gradient and m, v
    /// are 1st and 2nd order moment estimates (mean and variance).
    /// 
    /// .. math::
    /// 
    ///  g_t = \nabla J(W_{t-1})\\
    ///  m_t = \beta_1 m_{t-1} + (1 - \beta_1) g_t\\
    ///  v_t = \beta_2 v_{t-1} + (1 - \beta_2) g_t^2\\
    ///  W_t = W_{t-1} - \eta_t (\alpha \frac{ m_t }{ \sqrt{ v_t } + \epsilon } + wd W_{t-1})
    /// 
    /// It updates the weights using::
    /// 
    ///  m = beta1*m + (1-beta1)*grad
    ///  v = beta2*v + (1-beta2)*(grad**2)
    ///  w -= eta * (learning_rate * m / (sqrt(v) + epsilon) + w * wd)
    /// 
    /// Note that gradient is rescaled to grad = rescale_grad * grad. If rescale_grad is NaN, Inf, or 0,
    /// the update is skipped.
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\contrib\adamw.cc:L167</summary>
    /// <param name="data">data</param>
    /// <param name="lrs">Learning rates</param>
    /// <param name="wds">Weight decay augments the objective function with a regularization term that penalizes large weights. The penalty scales with the square of the magnitude of each weight.</param>
    /// <param name="etas">Learning rates schedule multiplier</param>
    /// <param name="beta1">The decay rate for the 1st moment estimates.</param>
    /// <param name="beta2">The decay rate for the 2nd moment estimates.</param>
    /// <param name="epsilon">A small constant for numerical stability.</param>
    /// <param name="clipGradient">Clip gradient to the range of [-clip_gradient, clip_gradient] If clip_gradient &lt;= 0, gradient clipping is turned off. grad = max(min(grad, clip_gradient), -clip_gradient).</param>
    /// <param name="numWeights">Number of updated weights.</param>
    static member MultiAdamwUpdate(data : Symbol seq, lrs : double seq, wds : double seq, etas : double seq, [<Optional>] ?beta1 : float, [<Optional>] ?beta2 : float, [<Optional>] ?epsilon : float, [<Optional>] ?clipGradient : float, [<Optional>] ?numWeights : int) =
        MultiAdamwUpdate(data, lrs, wds, etas, ?beta1 = beta1, ?beta2 = beta2, ?epsilon = epsilon, ?clipGradient = clipGradient, ?numWeights = numWeights)
    /// <summary>Update function for AdamW optimizer.
    /// 
    /// AdamW is seen as a modification of Adam by decoupling the weight decay from the
    /// optimization steps taken w.r.t. the loss function.
    /// 
    /// Adam update consists of the following steps, where g represents gradient and m, v
    /// are 1st and 2nd order moment estimates (mean and variance).
    /// 
    /// .. math::
    /// 
    ///  g_t = \nabla J(W_{t-1})\\
    ///  m_t = \beta_1 m_{t-1} + (1 - \beta_1) g_t\\
    ///  v_t = \beta_2 v_{t-1} + (1 - \beta_2) g_t^2\\
    ///  W_t = W_{t-1} - \eta_t (\alpha \frac{ m_t }{ \sqrt{ v_t } + \epsilon } + wd W_{t-1})
    /// 
    /// It updates the weights using::
    /// 
    ///  m = beta1*m + (1-beta1)*grad
    ///  v = beta2*v + (1-beta2)*(grad**2)
    ///  w -= eta * (learning_rate * m / (sqrt(v) + epsilon) + w * wd)
    /// 
    /// Note that gradient is rescaled to grad = rescale_grad * grad. If rescale_grad is NaN, Inf, or 0,
    /// the update is skipped.
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\contrib\adamw.cc:L167</summary>
    /// <param name="lrs">Learning rates</param>
    /// <param name="wds">Weight decay augments the objective function with a regularization term that penalizes large weights. The penalty scales with the square of the magnitude of each weight.</param>
    /// <param name="etas">Learning rates schedule multiplier</param>
    /// <param name="data">data</param>
    /// <param name="beta1">The decay rate for the 1st moment estimates.</param>
    /// <param name="beta2">The decay rate for the 2nd moment estimates.</param>
    /// <param name="epsilon">A small constant for numerical stability.</param>
    /// <param name="clipGradient">Clip gradient to the range of [-clip_gradient, clip_gradient] If clip_gradient &lt;= 0, gradient clipping is turned off. grad = max(min(grad, clip_gradient), -clip_gradient).</param>
    /// <param name="numWeights">Number of updated weights.</param>
    static member MultiAdamwUpdate(lrs : double seq, wds : double seq, etas : double seq, [<Optional>] ?data : Symbol seq, [<Optional>] ?beta1 : float, [<Optional>] ?beta2 : float, [<Optional>] ?epsilon : float, [<Optional>] ?clipGradient : float, [<Optional>] ?numWeights : int) =
        MultiAdamwUpdate(lrs, wds, etas, ?data = data, ?beta1 = beta1, ?beta2 = beta2, ?epsilon = epsilon, ?clipGradient = clipGradient, ?numWeights = numWeights)

    /// <summary>Update function for multi-precision AdamW optimizer.
    /// 
    /// AdamW is seen as a modification of Adam by decoupling the weight decay from the
    /// optimization steps taken w.r.t. the loss function.
    /// 
    /// Adam update consists of the following steps, where g represents gradient and m, v
    /// are 1st and 2nd order moment estimates (mean and variance).
    /// 
    /// .. math::
    /// 
    ///  g_t = \nabla J(W_{t-1})\\
    ///  m_t = \beta_1 m_{t-1} + (1 - \beta_1) g_t\\
    ///  v_t = \beta_2 v_{t-1} + (1 - \beta_2) g_t^2\\
    ///  W_t = W_{t-1} - \eta_t (\alpha \frac{ m_t }{ \sqrt{ v_t } + \epsilon } + wd W_{t-1})
    /// 
    /// It updates the weights using::
    /// 
    ///  m = beta1*m + (1-beta1)*grad
    ///  v = beta2*v + (1-beta2)*(grad**2)
    ///  w -= eta * (learning_rate * m / (sqrt(v) + epsilon) + w * wd)
    /// 
    /// Note that gradient is rescaled to grad = rescale_grad * grad. If rescale_grad is NaN, Inf, or 0,
    /// the update is skipped.
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\contrib\adamw.cc:L223</summary>
    /// <param name="data">data</param>
    /// <param name="lrs">Learning rates</param>
    /// <param name="wds">Weight decay augments the objective function with a regularization term that penalizes large weights. The penalty scales with the square of the magnitude of each weight.</param>
    /// <param name="etas">Learning rates schedule multiplier</param>
    /// <param name="beta1">The decay rate for the 1st moment estimates.</param>
    /// <param name="beta2">The decay rate for the 2nd moment estimates.</param>
    /// <param name="epsilon">A small constant for numerical stability.</param>
    /// <param name="clipGradient">Clip gradient to the range of [-clip_gradient, clip_gradient] If clip_gradient &lt;= 0, gradient clipping is turned off. grad = max(min(grad, clip_gradient), -clip_gradient).</param>
    /// <param name="numWeights">Number of updated weights.</param>
    static member MultiMpAdamwUpdate([<ParamArray>] data : NDArray[], 
                                     lrs : double seq, 
                                     wds : double seq, 
                                     etas : double seq, 
                                     [<Optional; DefaultParameterValue(0.899999976)>] beta1 : float, 
                                     [<Optional; DefaultParameterValue(0.999000013)>] beta2 : float, 
                                     [<Optional; DefaultParameterValue(9.99999994E-09)>] epsilon : float, 
                                     [<Optional; DefaultParameterValue(-1.0)>] clipGradient : float, 
                                     [<Optional; DefaultParameterValue(1)>] numWeights : int) =
        let creator = AtomicSymbolCreator.FromName "_multi_mp_adamw_update"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 (data |> Array.map (fun x -> x.UnsafeHandle))
                                                 [|"lrs"; "wds"; "etas"; "beta1"; "beta2"; "epsilon"; "clip_gradient"; "num_weights"|]
                                                 [|string lrs; string wds; string etas; string beta1; string beta2; string epsilon; string clipGradient; string numWeights|]
        outputs |> Array.map (fun h -> new NDArray(h))
    /// <summary>Update function for multi-precision AdamW optimizer.
    /// 
    /// AdamW is seen as a modification of Adam by decoupling the weight decay from the
    /// optimization steps taken w.r.t. the loss function.
    /// 
    /// Adam update consists of the following steps, where g represents gradient and m, v
    /// are 1st and 2nd order moment estimates (mean and variance).
    /// 
    /// .. math::
    /// 
    ///  g_t = \nabla J(W_{t-1})\\
    ///  m_t = \beta_1 m_{t-1} + (1 - \beta_1) g_t\\
    ///  v_t = \beta_2 v_{t-1} + (1 - \beta_2) g_t^2\\
    ///  W_t = W_{t-1} - \eta_t (\alpha \frac{ m_t }{ \sqrt{ v_t } + \epsilon } + wd W_{t-1})
    /// 
    /// It updates the weights using::
    /// 
    ///  m = beta1*m + (1-beta1)*grad
    ///  v = beta2*v + (1-beta2)*(grad**2)
    ///  w -= eta * (learning_rate * m / (sqrt(v) + epsilon) + w * wd)
    /// 
    /// Note that gradient is rescaled to grad = rescale_grad * grad. If rescale_grad is NaN, Inf, or 0,
    /// the update is skipped.
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\contrib\adamw.cc:L223</summary>
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="data">data</param>
    /// <param name="lrs">Learning rates</param>
    /// <param name="wds">Weight decay augments the objective function with a regularization term that penalizes large weights. The penalty scales with the square of the magnitude of each weight.</param>
    /// <param name="etas">Learning rates schedule multiplier</param>
    /// <param name="beta1">The decay rate for the 1st moment estimates.</param>
    /// <param name="beta2">The decay rate for the 2nd moment estimates.</param>
    /// <param name="epsilon">A small constant for numerical stability.</param>
    /// <param name="clipGradient">Clip gradient to the range of [-clip_gradient, clip_gradient] If clip_gradient &lt;= 0, gradient clipping is turned off. grad = max(min(grad, clip_gradient), -clip_gradient).</param>
    /// <param name="numWeights">Number of updated weights.</param>
    static member MultiMpAdamwUpdate(outputArray : NDArray seq, 
                                     [<ParamArray>] data : NDArray[], 
                                     lrs : double seq, 
                                     wds : double seq, 
                                     etas : double seq, 
                                     [<Optional; DefaultParameterValue(0.899999976)>] beta1 : float, 
                                     [<Optional; DefaultParameterValue(0.999000013)>] beta2 : float, 
                                     [<Optional; DefaultParameterValue(9.99999994E-09)>] epsilon : float, 
                                     [<Optional; DefaultParameterValue(-1.0)>] clipGradient : float, 
                                     [<Optional; DefaultParameterValue(1)>] numWeights : int) =
        let creator = AtomicSymbolCreator.FromName "_multi_mp_adamw_update"
        let names = [|"lrs"; "wds"; "etas"; "beta1"; "beta2"; "epsilon"; "clip_gradient"; "num_weights"|]
        let vals = [|string lrs; string wds; string etas; string beta1; string beta2; string epsilon; string clipGradient; string numWeights|]
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     (data |> Array.map (fun x -> x.UnsafeHandle))
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <summary>Update function for multi-precision AdamW optimizer.
    /// 
    /// AdamW is seen as a modification of Adam by decoupling the weight decay from the
    /// optimization steps taken w.r.t. the loss function.
    /// 
    /// Adam update consists of the following steps, where g represents gradient and m, v
    /// are 1st and 2nd order moment estimates (mean and variance).
    /// 
    /// .. math::
    /// 
    ///  g_t = \nabla J(W_{t-1})\\
    ///  m_t = \beta_1 m_{t-1} + (1 - \beta_1) g_t\\
    ///  v_t = \beta_2 v_{t-1} + (1 - \beta_2) g_t^2\\
    ///  W_t = W_{t-1} - \eta_t (\alpha \frac{ m_t }{ \sqrt{ v_t } + \epsilon } + wd W_{t-1})
    /// 
    /// It updates the weights using::
    /// 
    ///  m = beta1*m + (1-beta1)*grad
    ///  v = beta2*v + (1-beta2)*(grad**2)
    ///  w -= eta * (learning_rate * m / (sqrt(v) + epsilon) + w * wd)
    /// 
    /// Note that gradient is rescaled to grad = rescale_grad * grad. If rescale_grad is NaN, Inf, or 0,
    /// the update is skipped.
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\contrib\adamw.cc:L223</summary>
    /// <param name="data">data</param>
    /// <param name="lrs">Learning rates</param>
    /// <param name="wds">Weight decay augments the objective function with a regularization term that penalizes large weights. The penalty scales with the square of the magnitude of each weight.</param>
    /// <param name="etas">Learning rates schedule multiplier</param>
    /// <param name="beta1">The decay rate for the 1st moment estimates.</param>
    /// <param name="beta2">The decay rate for the 2nd moment estimates.</param>
    /// <param name="epsilon">A small constant for numerical stability.</param>
    /// <param name="clipGradient">Clip gradient to the range of [-clip_gradient, clip_gradient] If clip_gradient &lt;= 0, gradient clipping is turned off. grad = max(min(grad, clip_gradient), -clip_gradient).</param>
    /// <param name="numWeights">Number of updated weights.</param>
    static member MultiMpAdamwUpdate(data : Symbol seq, lrs : double seq, wds : double seq, etas : double seq, [<Optional>] ?beta1 : float, [<Optional>] ?beta2 : float, [<Optional>] ?epsilon : float, [<Optional>] ?clipGradient : float, [<Optional>] ?numWeights : int) =
        MultiMpAdamwUpdate(data, lrs, wds, etas, ?beta1 = beta1, ?beta2 = beta2, ?epsilon = epsilon, ?clipGradient = clipGradient, ?numWeights = numWeights)
    /// <summary>Update function for multi-precision AdamW optimizer.
    /// 
    /// AdamW is seen as a modification of Adam by decoupling the weight decay from the
    /// optimization steps taken w.r.t. the loss function.
    /// 
    /// Adam update consists of the following steps, where g represents gradient and m, v
    /// are 1st and 2nd order moment estimates (mean and variance).
    /// 
    /// .. math::
    /// 
    ///  g_t = \nabla J(W_{t-1})\\
    ///  m_t = \beta_1 m_{t-1} + (1 - \beta_1) g_t\\
    ///  v_t = \beta_2 v_{t-1} + (1 - \beta_2) g_t^2\\
    ///  W_t = W_{t-1} - \eta_t (\alpha \frac{ m_t }{ \sqrt{ v_t } + \epsilon } + wd W_{t-1})
    /// 
    /// It updates the weights using::
    /// 
    ///  m = beta1*m + (1-beta1)*grad
    ///  v = beta2*v + (1-beta2)*(grad**2)
    ///  w -= eta * (learning_rate * m / (sqrt(v) + epsilon) + w * wd)
    /// 
    /// Note that gradient is rescaled to grad = rescale_grad * grad. If rescale_grad is NaN, Inf, or 0,
    /// the update is skipped.
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\contrib\adamw.cc:L223</summary>
    /// <param name="lrs">Learning rates</param>
    /// <param name="wds">Weight decay augments the objective function with a regularization term that penalizes large weights. The penalty scales with the square of the magnitude of each weight.</param>
    /// <param name="etas">Learning rates schedule multiplier</param>
    /// <param name="data">data</param>
    /// <param name="beta1">The decay rate for the 1st moment estimates.</param>
    /// <param name="beta2">The decay rate for the 2nd moment estimates.</param>
    /// <param name="epsilon">A small constant for numerical stability.</param>
    /// <param name="clipGradient">Clip gradient to the range of [-clip_gradient, clip_gradient] If clip_gradient &lt;= 0, gradient clipping is turned off. grad = max(min(grad, clip_gradient), -clip_gradient).</param>
    /// <param name="numWeights">Number of updated weights.</param>
    static member MultiMpAdamwUpdate(lrs : double seq, wds : double seq, etas : double seq, [<Optional>] ?data : Symbol seq, [<Optional>] ?beta1 : float, [<Optional>] ?beta2 : float, [<Optional>] ?epsilon : float, [<Optional>] ?clipGradient : float, [<Optional>] ?numWeights : int) =
        MultiMpAdamwUpdate(lrs, wds, etas, ?data = data, ?beta1 = beta1, ?beta2 = beta2, ?epsilon = epsilon, ?clipGradient = clipGradient, ?numWeights = numWeights)

    /// <summary>
    /// Applies a 2D adaptive average pooling over a 4D input with the shape of (NCHW).
    /// The pooling kernel and stride sizes are automatically chosen for desired output sizes.
    /// 
    /// - If a single integer is provided for output_size, the output size is \
    ///   (N x C x output_size x output_size) for any input (NCHW).
    /// 
    /// - If a tuple of integers (height, width) are provided for output_size, the output size is \
    ///   (N x C x height x width) for any input (NCHW).
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\contrib\adaptive_avg_pooling.cc:L214</summary>
    /// <param name="data">Input data</param>
    /// <param name="outputSize">int (output size) or a tuple of int for output (height, width).</param>
    static member ContribAdaptiveAvgPooling2D(data : NDArray, [<Optional>] outputSize : int seq) =
        let creator = AtomicSymbolCreator.FromName "_contrib_AdaptiveAvgPooling2D"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle|]
                                                 [|"output_size"|]
                                                 [|(if isNull (outputSize :> obj) then "[]" else (outputSize |> Seq.map string |> String.concat ", " |> sprintf "[%s]"))|]
        (new NDArray(outputs.[0]))
    /// <summary>
    /// Applies a 2D adaptive average pooling over a 4D input with the shape of (NCHW).
    /// The pooling kernel and stride sizes are automatically chosen for desired output sizes.
    /// 
    /// - If a single integer is provided for output_size, the output size is \
    ///   (N x C x output_size x output_size) for any input (NCHW).
    /// 
    /// - If a tuple of integers (height, width) are provided for output_size, the output size is \
    ///   (N x C x height x width) for any input (NCHW).
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\contrib\adaptive_avg_pooling.cc:L214</summary>
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="data">Input data</param>
    /// <param name="outputSize">int (output size) or a tuple of int for output (height, width).</param>
    static member ContribAdaptiveAvgPooling2D(outputArray : NDArray seq, data : NDArray, [<Optional>] outputSize : int seq) =
        let creator = AtomicSymbolCreator.FromName "_contrib_AdaptiveAvgPooling2D"
        let names = [|"output_size"|]
        let vals = [|(if isNull (outputSize :> obj) then "[]" else (outputSize |> Seq.map string |> String.concat ", " |> sprintf "[%s]"))|]
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <summary>
    /// Applies a 2D adaptive average pooling over a 4D input with the shape of (NCHW).
    /// The pooling kernel and stride sizes are automatically chosen for desired output sizes.
    /// 
    /// - If a single integer is provided for output_size, the output size is \
    ///   (N x C x output_size x output_size) for any input (NCHW).
    /// 
    /// - If a tuple of integers (height, width) are provided for output_size, the output size is \
    ///   (N x C x height x width) for any input (NCHW).
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\contrib\adaptive_avg_pooling.cc:L214</summary>
    /// <param name="data">Input data</param>
    /// <param name="outputSize">int (output size) or a tuple of int for output (height, width).</param>
    static member ContribAdaptiveAvgPooling2D([<Optional>] ?data : Symbol, [<Optional>] ?outputSize : int seq) =
        ContribAdaptiveAvgPooling2D(?data = data, ?outputSize = outputSize)


    /// <summary>Check if all the float numbers in the array are finite (used for AMP)
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\contrib\all_finite.cc:L101</summary>
    /// <param name="data">Array</param>
    /// <param name="initOutput">Initialize output to 1.</param>
    static member AllFinite(data : NDArray, [<Optional; DefaultParameterValue(true)>] initOutput : bool) =
        let creator = AtomicSymbolCreator.FromName "all_finite"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle|]
                                                 [|"init_output"|]
                                                 [|string initOutput|]
        (new NDArray(outputs.[0]))
    /// <summary>Check if all the float numbers in the array are finite (used for AMP)
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\contrib\all_finite.cc:L101</summary>
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="data">Array</param>
    /// <param name="initOutput">Initialize output to 1.</param>
    static member AllFinite(outputArray : NDArray seq, data : NDArray, [<Optional; DefaultParameterValue(true)>] initOutput : bool) =
        let creator = AtomicSymbolCreator.FromName "all_finite"
        let names = [|"init_output"|]
        let vals = [|string initOutput|]
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()

    /// <summary>Check if all the float numbers in all the arrays are finite (used for AMP)
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\contrib\all_finite.cc:L133</summary>
    /// <param name="data">Arrays</param>
    /// <param name="numArrays">Number of arrays.</param>
    /// <param name="initOutput">Initialize output to 1.</param>
    static member MultiAllFinite([<ParamArray>] data : NDArray[], [<Optional; DefaultParameterValue(1)>] numArrays : int, [<Optional; DefaultParameterValue(true)>] initOutput : bool) =
        let creator = AtomicSymbolCreator.FromName "multi_all_finite"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 (data |> Array.map (fun x -> x.UnsafeHandle))
                                                 [|"num_arrays"; "init_output"|]
                                                 [|string numArrays; string initOutput|]
        (new NDArray(outputs.[0]))
    /// <summary>Check if all the float numbers in all the arrays are finite (used for AMP)
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\contrib\all_finite.cc:L133</summary>
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="data">Arrays</param>
    /// <param name="numArrays">Number of arrays.</param>
    /// <param name="initOutput">Initialize output to 1.</param>
    static member MultiAllFinite(outputArray : NDArray seq, [<ParamArray>] data : NDArray[], [<Optional; DefaultParameterValue(1)>] numArrays : int, [<Optional; DefaultParameterValue(true)>] initOutput : bool) =
        let creator = AtomicSymbolCreator.FromName "multi_all_finite"
        let names = [|"num_arrays"; "init_output"|]
        let vals = [|string numArrays; string initOutput|]
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     (data |> Array.map (fun x -> x.UnsafeHandle))
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <summary>Check if all the float numbers in all the arrays are finite (used for AMP)
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\contrib\all_finite.cc:L133</summary>
    /// <param name="data">Arrays</param>
    /// <param name="numArrays">Number of arrays.</param>
    /// <param name="initOutput">Initialize output to 1.</param>
    static member MultiAllFinite([<Optional>] ?data : Symbol seq, [<Optional>] ?numArrays : int, [<Optional>] ?initOutput : bool) =
        MultiAllFinite(?data = data, ?numArrays = numArrays, ?initOutput = initOutput)

    /// <summary>This operators implements the numpy.allclose(a, b, rtol=1e-05, atol=1e-08, equal_nan=False)
    /// 
    /// .. math::
    /// 
    ///     f(x) = |a&#226;b|&#226;&#164;atol+rtol|b|
    /// 
    /// where
    /// :math:`a, b` are the input tensors of equal types an shapes
    /// :math:`atol, rtol` the values of absolute and relative tolerance (by default, rtol=1e-05, atol=1e-08)
    /// 
    /// Examples::
    /// 
    ///   a = [1e10, 1e-7],
    ///   b = [1.00001e10, 1e-8]
    ///   y = allclose(a, b)
    ///   y = False
    /// 
    ///   a = [1e10, 1e-8],
    ///   b = [1.00001e10, 1e-9]
    ///   y = allclose(a, b)
    ///   y = True
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\contrib\allclose_op.cc:L55</summary>
    /// <param name="a">Input array a</param>
    /// <param name="b">Input array b</param>
    /// <param name="rtol">Relative tolerance.</param>
    /// <param name="atol">Absolute tolerance.</param>
    /// <param name="equalNan">Whether to compare NaN&#39;s as equal. If True, NaN&#39;s in A will be considered equal to NaN&#39;s in B in the output array.</param>
    static member ContribAllclose(a : NDArray, 
                                  b : NDArray, 
                                  [<Optional; DefaultParameterValue(9.99999975E-06)>] rtol : float, 
                                  [<Optional; DefaultParameterValue(9.99999994E-09)>] atol : float, 
                                  [<Optional; DefaultParameterValue(true)>] equalNan : bool) =
        let creator = AtomicSymbolCreator.FromName "_contrib_allclose"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg a)) then a.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg b)) then b.UnsafeHandle|]
                                                 [|"rtol"; "atol"; "equal_nan"|]
                                                 [|string rtol; string atol; string equalNan|]
        outputs |> Array.map (fun h -> new NDArray(h))
    /// <summary>This operators implements the numpy.allclose(a, b, rtol=1e-05, atol=1e-08, equal_nan=False)
    /// 
    /// .. math::
    /// 
    ///     f(x) = |a&#226;b|&#226;&#164;atol+rtol|b|
    /// 
    /// where
    /// :math:`a, b` are the input tensors of equal types an shapes
    /// :math:`atol, rtol` the values of absolute and relative tolerance (by default, rtol=1e-05, atol=1e-08)
    /// 
    /// Examples::
    /// 
    ///   a = [1e10, 1e-7],
    ///   b = [1.00001e10, 1e-8]
    ///   y = allclose(a, b)
    ///   y = False
    /// 
    ///   a = [1e10, 1e-8],
    ///   b = [1.00001e10, 1e-9]
    ///   y = allclose(a, b)
    ///   y = True
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\contrib\allclose_op.cc:L55</summary>
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="a">Input array a</param>
    /// <param name="b">Input array b</param>
    /// <param name="rtol">Relative tolerance.</param>
    /// <param name="atol">Absolute tolerance.</param>
    /// <param name="equalNan">Whether to compare NaN&#39;s as equal. If True, NaN&#39;s in A will be considered equal to NaN&#39;s in B in the output array.</param>
    static member ContribAllclose(outputArray : NDArray seq, 
                                  a : NDArray, 
                                  b : NDArray, 
                                  [<Optional; DefaultParameterValue(9.99999975E-06)>] rtol : float, 
                                  [<Optional; DefaultParameterValue(9.99999994E-09)>] atol : float, 
                                  [<Optional; DefaultParameterValue(true)>] equalNan : bool) =
        let creator = AtomicSymbolCreator.FromName "_contrib_allclose"
        let names = [|"rtol"; "atol"; "equal_nan"|]
        let vals = [|string rtol; string atol; string equalNan|]
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg a)) then a.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg b)) then b.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <summary>This operators implements the numpy.allclose(a, b, rtol=1e-05, atol=1e-08, equal_nan=False)
    /// 
    /// .. math::
    /// 
    ///     f(x) = |a&#226;b|&#226;&#164;atol+rtol|b|
    /// 
    /// where
    /// :math:`a, b` are the input tensors of equal types an shapes
    /// :math:`atol, rtol` the values of absolute and relative tolerance (by default, rtol=1e-05, atol=1e-08)
    /// 
    /// Examples::
    /// 
    ///   a = [1e10, 1e-7],
    ///   b = [1.00001e10, 1e-8]
    ///   y = allclose(a, b)
    ///   y = False
    /// 
    ///   a = [1e10, 1e-8],
    ///   b = [1.00001e10, 1e-9]
    ///   y = allclose(a, b)
    ///   y = True
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\contrib\allclose_op.cc:L55</summary>
    /// <param name="a">Input array a</param>
    /// <param name="b">Input array b</param>
    /// <param name="rtol">Relative tolerance.</param>
    /// <param name="atol">Absolute tolerance.</param>
    /// <param name="equalNan">Whether to compare NaN&#39;s as equal. If True, NaN&#39;s in A will be considered equal to NaN&#39;s in B in the output array.</param>
    static member ContribAllclose([<Optional>] ?a : Symbol, [<Optional>] ?b : Symbol, [<Optional>] ?rtol : float, [<Optional>] ?atol : float, [<Optional>] ?equalNan : bool) =
        ContribAllclose(?a = a, ?b = b, ?rtol = rtol, ?atol = atol, ?equalNan = equalNan)

    /// <summary>
    /// Perform 2D resizing (upsampling or downsampling) for 4D input using bilinear interpolation.
    /// 
    /// Expected input is a 4 dimensional NDArray (NCHW) and the output
    /// with the shape of (N x C x height x width). 
    /// The key idea of bilinear interpolation is to perform linear interpolation
    /// first in one direction, and then again in the other direction. See the wikipedia of
    /// `Bilinear interpolation  &lt;https://en.wikipedia.org/wiki/Bilinear_interpolation&gt;`_
    /// for more details.
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\contrib\bilinear_resize.cc:L220</summary>
    /// <param name="data">Input data</param>
    /// <param name="like">Resize data to it&#39;s shape</param>
    /// <param name="height">output height (required, but ignored if scale_height is defined or mode is not &quot;size&quot;)</param>
    /// <param name="width">output width (required, but ignored if scale_width is defined or mode is not &quot;size&quot;)</param>
    /// <param name="scaleHeight">sampling scale of the height (optional, used in modes &quot;scale&quot; and &quot;odd_scale&quot;)</param>
    /// <param name="scaleWidth">sampling scale of the width (optional, used in modes &quot;scale&quot; and &quot;odd_scale&quot;)</param>
    /// <param name="mode">resizing mode. &quot;simple&quot; - output height equals parameter &quot;height&quot; if &quot;scale_height&quot; parameter is not defined or input height multiplied by &quot;scale_height&quot; otherwise. Same for width;&quot;odd_scale&quot; - if original height or width is odd, then result height is calculated like result_h = (original_h - 1) * scale + 1; for scale &gt; 1 the result shape would be like if we did deconvolution with kernel = (1, 1) and stride = (height_scale, width_scale); and for scale &lt; 1 shape would be like we did convolution with kernel = (1, 1) and stride = (int(1 / height_scale), int( 1/ width_scale);&quot;like&quot; - resize first input to the height and width of second input; &quot;to_even_down&quot; - resize input to nearest lower even height and width (if original height is odd then result height = original height - 1);&quot;to_even_up&quot; - resize input to nearest bigger even height and width (if original height is odd then result height = original height + 1);&quot;to_odd_down&quot; - resize input to nearest odd height and width (if original height is odd then result height = original height - 1);&quot;to_odd_up&quot; - resize input to nearest odd height and width (if original height is odd then result height = original height + 1);</param>
    /// <param name="alignCorners">With align_corners = True, the interpolating doesn&#39;t proportionally align theoutput and input pixels, and thus the output values can depend on the input size.</param>
    static member ContribBilinearResize2D(data : NDArray, 
                                          like : NDArray, 
                                          [<Optional>] ?height : int, 
                                          [<Optional>] ?width : int, 
                                          [<Optional>] ?scaleHeight : float, 
                                          [<Optional>] ?scaleWidth : float, 
                                          [<Optional>] ?mode : ContribBilinearResize2DMode, 
                                          [<Optional>] ?alignCorners : bool) =
        let creator = AtomicSymbolCreator.FromName "_contrib_BilinearResize2D"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg like)) then like.UnsafeHandle|]
                                                 [|"height"; "width"; "scale_height"; "scale_width"; "mode"; "align_corners"|]
                                                 [|(match height with None -> "1" | Some height -> string height); (match width with None -> "1" | Some width -> string width); (match scaleHeight with None -> "None" | Some scaleHeight -> string scaleHeight); (match scaleWidth with None -> "None" | Some scaleWidth -> string scaleWidth); (match mode with None -> "size" | Some mode -> string mode); (match alignCorners with None -> "true" | Some alignCorners -> string alignCorners)|]
        (new NDArray(outputs.[0]))
    /// <summary>
    /// Perform 2D resizing (upsampling or downsampling) for 4D input using bilinear interpolation.
    /// 
    /// Expected input is a 4 dimensional NDArray (NCHW) and the output
    /// with the shape of (N x C x height x width). 
    /// The key idea of bilinear interpolation is to perform linear interpolation
    /// first in one direction, and then again in the other direction. See the wikipedia of
    /// `Bilinear interpolation  &lt;https://en.wikipedia.org/wiki/Bilinear_interpolation&gt;`_
    /// for more details.
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\contrib\bilinear_resize.cc:L220</summary>
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="data">Input data</param>
    /// <param name="like">Resize data to it&#39;s shape</param>
    /// <param name="height">output height (required, but ignored if scale_height is defined or mode is not &quot;size&quot;)</param>
    /// <param name="width">output width (required, but ignored if scale_width is defined or mode is not &quot;size&quot;)</param>
    /// <param name="scaleHeight">sampling scale of the height (optional, used in modes &quot;scale&quot; and &quot;odd_scale&quot;)</param>
    /// <param name="scaleWidth">sampling scale of the width (optional, used in modes &quot;scale&quot; and &quot;odd_scale&quot;)</param>
    /// <param name="mode">resizing mode. &quot;simple&quot; - output height equals parameter &quot;height&quot; if &quot;scale_height&quot; parameter is not defined or input height multiplied by &quot;scale_height&quot; otherwise. Same for width;&quot;odd_scale&quot; - if original height or width is odd, then result height is calculated like result_h = (original_h - 1) * scale + 1; for scale &gt; 1 the result shape would be like if we did deconvolution with kernel = (1, 1) and stride = (height_scale, width_scale); and for scale &lt; 1 shape would be like we did convolution with kernel = (1, 1) and stride = (int(1 / height_scale), int( 1/ width_scale);&quot;like&quot; - resize first input to the height and width of second input; &quot;to_even_down&quot; - resize input to nearest lower even height and width (if original height is odd then result height = original height - 1);&quot;to_even_up&quot; - resize input to nearest bigger even height and width (if original height is odd then result height = original height + 1);&quot;to_odd_down&quot; - resize input to nearest odd height and width (if original height is odd then result height = original height - 1);&quot;to_odd_up&quot; - resize input to nearest odd height and width (if original height is odd then result height = original height + 1);</param>
    /// <param name="alignCorners">With align_corners = True, the interpolating doesn&#39;t proportionally align theoutput and input pixels, and thus the output values can depend on the input size.</param>
    static member ContribBilinearResize2D(outputArray : NDArray seq, 
                                          data : NDArray, 
                                          like : NDArray, 
                                          [<Optional>] ?height : int, 
                                          [<Optional>] ?width : int, 
                                          [<Optional>] ?scaleHeight : float, 
                                          [<Optional>] ?scaleWidth : float, 
                                          [<Optional>] ?mode : ContribBilinearResize2DMode, 
                                          [<Optional>] ?alignCorners : bool) =
        let creator = AtomicSymbolCreator.FromName "_contrib_BilinearResize2D"
        let names = [|"height"; "width"; "scale_height"; "scale_width"; "mode"; "align_corners"|]
        let vals = [|(match height with None -> "1" | Some height -> string height); (match width with None -> "1" | Some width -> string width); (match scaleHeight with None -> "None" | Some scaleHeight -> string scaleHeight); (match scaleWidth with None -> "None" | Some scaleWidth -> string scaleWidth); (match mode with None -> "size" | Some mode -> string mode); (match alignCorners with None -> "true" | Some alignCorners -> string alignCorners)|]
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg like)) then like.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <summary>
    /// Perform 2D resizing (upsampling or downsampling) for 4D input using bilinear interpolation.
    /// 
    /// Expected input is a 4 dimensional NDArray (NCHW) and the output
    /// with the shape of (N x C x height x width). 
    /// The key idea of bilinear interpolation is to perform linear interpolation
    /// first in one direction, and then again in the other direction. See the wikipedia of
    /// `Bilinear interpolation  &lt;https://en.wikipedia.org/wiki/Bilinear_interpolation&gt;`_
    /// for more details.
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\contrib\bilinear_resize.cc:L220</summary>
    /// <param name="data">Input data</param>
    /// <param name="like">Resize data to it&#39;s shape</param>
    /// <param name="height">output height (required, but ignored if scale_height is defined or mode is not &quot;size&quot;)</param>
    /// <param name="width">output width (required, but ignored if scale_width is defined or mode is not &quot;size&quot;)</param>
    /// <param name="scaleHeight">sampling scale of the height (optional, used in modes &quot;scale&quot; and &quot;odd_scale&quot;)</param>
    /// <param name="scaleWidth">sampling scale of the width (optional, used in modes &quot;scale&quot; and &quot;odd_scale&quot;)</param>
    /// <param name="mode">resizing mode. &quot;simple&quot; - output height equals parameter &quot;height&quot; if &quot;scale_height&quot; parameter is not defined or input height multiplied by &quot;scale_height&quot; otherwise. Same for width;&quot;odd_scale&quot; - if original height or width is odd, then result height is calculated like result_h = (original_h - 1) * scale + 1; for scale &gt; 1 the result shape would be like if we did deconvolution with kernel = (1, 1) and stride = (height_scale, width_scale); and for scale &lt; 1 shape would be like we did convolution with kernel = (1, 1) and stride = (int(1 / height_scale), int( 1/ width_scale);&quot;like&quot; - resize first input to the height and width of second input; &quot;to_even_down&quot; - resize input to nearest lower even height and width (if original height is odd then result height = original height - 1);&quot;to_even_up&quot; - resize input to nearest bigger even height and width (if original height is odd then result height = original height + 1);&quot;to_odd_down&quot; - resize input to nearest odd height and width (if original height is odd then result height = original height - 1);&quot;to_odd_up&quot; - resize input to nearest odd height and width (if original height is odd then result height = original height + 1);</param>
    /// <param name="alignCorners">With align_corners = True, the interpolating doesn&#39;t proportionally align theoutput and input pixels, and thus the output values can depend on the input size.</param>
    static member ContribBilinearResize2D([<Optional>] ?data : Symbol, [<Optional>] ?like : Symbol, [<Optional>] ?height : int, [<Optional>] ?width : int, [<Optional>] ?scaleHeight : float, [<Optional>] ?scaleWidth : float, [<Optional>] ?mode : ContribBilinearResize2DMode, [<Optional>] ?alignCorners : bool) =
        ContribBilinearResize2D(?data = data, ?like = like, ?height = height, ?width = width, ?scaleHeight = scaleHeight, ?scaleWidth = scaleWidth, ?mode = mode, ?alignCorners = alignCorners)


    /// <summary>
    /// Given an n-d NDArray data, and a 1-d NDArray index,
    /// the operator produces an un-predeterminable shaped n-d NDArray out,
    /// which stands for the rows in x where the corresonding element in index is non-zero.
    /// 
    /// &gt;&gt;&gt; data = mx.nd.array([[1, 2, 3],[4, 5, 6],[7, 8, 9]])
    /// &gt;&gt;&gt; index = mx.nd.array([0, 1, 0])
    /// &gt;&gt;&gt; out = mx.nd.contrib.boolean_mask(data, index)
    /// &gt;&gt;&gt; out
    /// 
    /// [[4. 5. 6.]]
    /// &lt;NDArray 1x3 @cpu(0)&gt;
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\contrib\boolean_mask.cc:L196</summary>
    /// <param name="data">Data</param>
    /// <param name="index">Mask</param>
    /// <param name="axis">An integer that represents the axis in NDArray to mask from.</param>
    static member ContribBooleanMask(data : NDArray, index : NDArray, [<Optional; DefaultParameterValue(0)>] axis : int) =
        let creator = AtomicSymbolCreator.FromName "_contrib_boolean_mask"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg index)) then index.UnsafeHandle|]
                                                 [|"axis"|]
                                                 [|string axis|]
        (new NDArray(outputs.[0]))
    /// <summary>
    /// Given an n-d NDArray data, and a 1-d NDArray index,
    /// the operator produces an un-predeterminable shaped n-d NDArray out,
    /// which stands for the rows in x where the corresonding element in index is non-zero.
    /// 
    /// &gt;&gt;&gt; data = mx.nd.array([[1, 2, 3],[4, 5, 6],[7, 8, 9]])
    /// &gt;&gt;&gt; index = mx.nd.array([0, 1, 0])
    /// &gt;&gt;&gt; out = mx.nd.contrib.boolean_mask(data, index)
    /// &gt;&gt;&gt; out
    /// 
    /// [[4. 5. 6.]]
    /// &lt;NDArray 1x3 @cpu(0)&gt;
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\contrib\boolean_mask.cc:L196</summary>
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="data">Data</param>
    /// <param name="index">Mask</param>
    /// <param name="axis">An integer that represents the axis in NDArray to mask from.</param>
    static member ContribBooleanMask(outputArray : NDArray seq, data : NDArray, index : NDArray, [<Optional; DefaultParameterValue(0)>] axis : int) =
        let creator = AtomicSymbolCreator.FromName "_contrib_boolean_mask"
        let names = [|"axis"|]
        let vals = [|string axis|]
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg index)) then index.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <summary>
    /// Given an n-d NDArray data, and a 1-d NDArray index,
    /// the operator produces an un-predeterminable shaped n-d NDArray out,
    /// which stands for the rows in x where the corresonding element in index is non-zero.
    /// 
    /// &gt;&gt;&gt; data = mx.nd.array([[1, 2, 3],[4, 5, 6],[7, 8, 9]])
    /// &gt;&gt;&gt; index = mx.nd.array([0, 1, 0])
    /// &gt;&gt;&gt; out = mx.nd.contrib.boolean_mask(data, index)
    /// &gt;&gt;&gt; out
    /// 
    /// [[4. 5. 6.]]
    /// &lt;NDArray 1x3 @cpu(0)&gt;
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\contrib\boolean_mask.cc:L196</summary>
    /// <param name="data">Data</param>
    /// <param name="index">Mask</param>
    /// <param name="axis">An integer that represents the axis in NDArray to mask from.</param>
    static member ContribBooleanMask([<Optional>] ?data : Symbol, [<Optional>] ?index : Symbol, [<Optional>] ?axis : int) =
        ContribBooleanMask(?data = data, ?index = index, ?axis = axis)


    /// <summary>Apply non-maximum suppression to input.
    /// 
    /// The output will be sorted in descending order according to `score`. Boxes with
    /// overlaps larger than `overlap_thresh`, smaller scores and background boxes
    /// will be removed and filled with -1, the corresponding position will be recorded
    /// for backward propogation.
    /// 
    /// During back-propagation, the gradient will be copied to the original
    /// position according to the input index. For positions that have been suppressed,
    /// the in_grad will be assigned 0.
    /// In summary, gradients are sticked to its boxes, will either be moved or discarded
    /// according to its original index in input.
    /// 
    /// Input requirements::
    /// 
    ///   1. Input tensor have at least 2 dimensions, (n, k), any higher dims will be regarded
    ///   as batch, e.g. (a, b, c, d, n, k) == (a*b*c*d, n, k)
    ///   2. n is the number of boxes in each batch
    ///   3. k is the width of each box item.
    /// 
    /// By default, a box is [id, score, xmin, ymin, xmax, ymax, ...],
    /// additional elements are allowed.
    /// 
    /// - `id_index`: optional, use -1 to ignore, useful if `force_suppress=False`, which means
    ///   we will skip highly overlapped boxes if one is `apple` while the other is `car`.
    /// 
    /// - `background_id`: optional, default=-1, class id for background boxes, useful
    ///   when `id_index &gt;= 0` which means boxes with background id will be filtered before nms.
    /// 
    /// - `coord_start`: required, default=2, the starting index of the 4 coordinates.
    ///   Two formats are supported:
    /// 
    ///     - `corner`: [xmin, ymin, xmax, ymax]
    /// 
    ///     - `center`: [x, y, width, height]
    /// 
    /// - `score_index`: required, default=1, box score/confidence.
    ///   When two boxes overlap IOU &gt; `overlap_thresh`, the one with smaller score will be suppressed.
    /// 
    /// - `in_format` and `out_format`: default=&#39;corner&#39;, specify in/out box formats.
    /// 
    /// Examples::
    /// 
    ///   x = [[0, 0.5, 0.1, 0.1, 0.2, 0.2], [1, 0.4, 0.1, 0.1, 0.2, 0.2],
    ///        [0, 0.3, 0.1, 0.1, 0.14, 0.14], [2, 0.6, 0.5, 0.5, 0.7, 0.8]]
    ///   box_nms(x, overlap_thresh=0.1, coord_start=2, score_index=1, id_index=0,
    ///       force_suppress=True, in_format=&#39;corner&#39;, out_typ=&#39;corner&#39;) =
    ///       [[2, 0.6, 0.5, 0.5, 0.7, 0.8], [0, 0.5, 0.1, 0.1, 0.2, 0.2],
    ///        [-1, -1, -1, -1, -1, -1], [-1, -1, -1, -1, -1, -1]]
    ///   out_grad = [[0.1, 0.1, 0.1, 0.1, 0.1, 0.1], [0.2, 0.2, 0.2, 0.2, 0.2, 0.2],
    ///               [0.3, 0.3, 0.3, 0.3, 0.3, 0.3], [0.4, 0.4, 0.4, 0.4, 0.4, 0.4]]
    ///   # exe.backward
    ///   in_grad = [[0.2, 0.2, 0.2, 0.2, 0.2, 0.2], [0, 0, 0, 0, 0, 0],
    ///              [0, 0, 0, 0, 0, 0], [0.1, 0.1, 0.1, 0.1, 0.1, 0.1]]
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\contrib\bounding_box.cc:L95</summary>
    /// <param name="data">The input</param>
    /// <param name="overlapThresh">Overlapping(IoU) threshold to suppress object with smaller score.</param>
    /// <param name="validThresh">Filter input boxes to those whose scores greater than valid_thresh.</param>
    /// <param name="topk">Apply nms to topk boxes with descending scores, -1 to no restriction.</param>
    /// <param name="coordStart">Start index of the consecutive 4 coordinates.</param>
    /// <param name="scoreIndex">Index of the scores/confidence of boxes.</param>
    /// <param name="idIndex">Optional, index of the class categories, -1 to disable.</param>
    /// <param name="backgroundId">Optional, id of the background class which will be ignored in nms.</param>
    /// <param name="forceSuppress">Optional, if set false and id_index is provided, nms will only apply to boxes belongs to the same category</param>
    /// <param name="inFormat">The input box encoding type. 
    ///  &quot;corner&quot; means boxes are encoded as [xmin, ymin, xmax, ymax], &quot;center&quot; means boxes are encodes as [x, y, width, height].</param>
    /// <param name="outFormat">The output box encoding type. 
    ///  &quot;corner&quot; means boxes are encoded as [xmin, ymin, xmax, ymax], &quot;center&quot; means boxes are encodes as [x, y, width, height].</param>
    static member ContribBoxNms(data : NDArray, 
                                [<Optional; DefaultParameterValue(0.5)>] overlapThresh : float, 
                                [<Optional; DefaultParameterValue(0.0)>] validThresh : float, 
                                [<Optional; DefaultParameterValue(-1)>] topk : int, 
                                [<Optional; DefaultParameterValue(2)>] coordStart : int, 
                                [<Optional; DefaultParameterValue(1)>] scoreIndex : int, 
                                [<Optional; DefaultParameterValue(-1)>] idIndex : int, 
                                [<Optional; DefaultParameterValue(-1)>] backgroundId : int, 
                                [<Optional; DefaultParameterValue(false)>] forceSuppress : bool, 
                                [<Optional>] inFormat : Format, 
                                [<Optional>] outFormat : Format) =
        let creator = AtomicSymbolCreator.FromName "_contrib_box_nms"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle|]
                                                 [|"overlap_thresh"; "valid_thresh"; "topk"; "coord_start"; "score_index"; "id_index"; "background_id"; "force_suppress"; "in_format"; "out_format"|]
                                                 [|string overlapThresh; string validThresh; string topk; string coordStart; string scoreIndex; string idIndex; string backgroundId; string forceSuppress; (if isNull (inFormat :> obj) then "corner" else string inFormat); (if isNull (outFormat :> obj) then "corner" else string outFormat)|]
        (new NDArray(outputs.[0])), (new NDArray(outputs.[1]))
    /// <summary>Apply non-maximum suppression to input.
    /// 
    /// The output will be sorted in descending order according to `score`. Boxes with
    /// overlaps larger than `overlap_thresh`, smaller scores and background boxes
    /// will be removed and filled with -1, the corresponding position will be recorded
    /// for backward propogation.
    /// 
    /// During back-propagation, the gradient will be copied to the original
    /// position according to the input index. For positions that have been suppressed,
    /// the in_grad will be assigned 0.
    /// In summary, gradients are sticked to its boxes, will either be moved or discarded
    /// according to its original index in input.
    /// 
    /// Input requirements::
    /// 
    ///   1. Input tensor have at least 2 dimensions, (n, k), any higher dims will be regarded
    ///   as batch, e.g. (a, b, c, d, n, k) == (a*b*c*d, n, k)
    ///   2. n is the number of boxes in each batch
    ///   3. k is the width of each box item.
    /// 
    /// By default, a box is [id, score, xmin, ymin, xmax, ymax, ...],
    /// additional elements are allowed.
    /// 
    /// - `id_index`: optional, use -1 to ignore, useful if `force_suppress=False`, which means
    ///   we will skip highly overlapped boxes if one is `apple` while the other is `car`.
    /// 
    /// - `background_id`: optional, default=-1, class id for background boxes, useful
    ///   when `id_index &gt;= 0` which means boxes with background id will be filtered before nms.
    /// 
    /// - `coord_start`: required, default=2, the starting index of the 4 coordinates.
    ///   Two formats are supported:
    /// 
    ///     - `corner`: [xmin, ymin, xmax, ymax]
    /// 
    ///     - `center`: [x, y, width, height]
    /// 
    /// - `score_index`: required, default=1, box score/confidence.
    ///   When two boxes overlap IOU &gt; `overlap_thresh`, the one with smaller score will be suppressed.
    /// 
    /// - `in_format` and `out_format`: default=&#39;corner&#39;, specify in/out box formats.
    /// 
    /// Examples::
    /// 
    ///   x = [[0, 0.5, 0.1, 0.1, 0.2, 0.2], [1, 0.4, 0.1, 0.1, 0.2, 0.2],
    ///        [0, 0.3, 0.1, 0.1, 0.14, 0.14], [2, 0.6, 0.5, 0.5, 0.7, 0.8]]
    ///   box_nms(x, overlap_thresh=0.1, coord_start=2, score_index=1, id_index=0,
    ///       force_suppress=True, in_format=&#39;corner&#39;, out_typ=&#39;corner&#39;) =
    ///       [[2, 0.6, 0.5, 0.5, 0.7, 0.8], [0, 0.5, 0.1, 0.1, 0.2, 0.2],
    ///        [-1, -1, -1, -1, -1, -1], [-1, -1, -1, -1, -1, -1]]
    ///   out_grad = [[0.1, 0.1, 0.1, 0.1, 0.1, 0.1], [0.2, 0.2, 0.2, 0.2, 0.2, 0.2],
    ///               [0.3, 0.3, 0.3, 0.3, 0.3, 0.3], [0.4, 0.4, 0.4, 0.4, 0.4, 0.4]]
    ///   # exe.backward
    ///   in_grad = [[0.2, 0.2, 0.2, 0.2, 0.2, 0.2], [0, 0, 0, 0, 0, 0],
    ///              [0, 0, 0, 0, 0, 0], [0.1, 0.1, 0.1, 0.1, 0.1, 0.1]]
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\contrib\bounding_box.cc:L95</summary>
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="data">The input</param>
    /// <param name="overlapThresh">Overlapping(IoU) threshold to suppress object with smaller score.</param>
    /// <param name="validThresh">Filter input boxes to those whose scores greater than valid_thresh.</param>
    /// <param name="topk">Apply nms to topk boxes with descending scores, -1 to no restriction.</param>
    /// <param name="coordStart">Start index of the consecutive 4 coordinates.</param>
    /// <param name="scoreIndex">Index of the scores/confidence of boxes.</param>
    /// <param name="idIndex">Optional, index of the class categories, -1 to disable.</param>
    /// <param name="backgroundId">Optional, id of the background class which will be ignored in nms.</param>
    /// <param name="forceSuppress">Optional, if set false and id_index is provided, nms will only apply to boxes belongs to the same category</param>
    /// <param name="inFormat">The input box encoding type. 
    ///  &quot;corner&quot; means boxes are encoded as [xmin, ymin, xmax, ymax], &quot;center&quot; means boxes are encodes as [x, y, width, height].</param>
    /// <param name="outFormat">The output box encoding type. 
    ///  &quot;corner&quot; means boxes are encoded as [xmin, ymin, xmax, ymax], &quot;center&quot; means boxes are encodes as [x, y, width, height].</param>
    static member ContribBoxNms(outputArray : NDArray seq, 
                                data : NDArray, 
                                [<Optional; DefaultParameterValue(0.5)>] overlapThresh : float, 
                                [<Optional; DefaultParameterValue(0.0)>] validThresh : float, 
                                [<Optional; DefaultParameterValue(-1)>] topk : int, 
                                [<Optional; DefaultParameterValue(2)>] coordStart : int, 
                                [<Optional; DefaultParameterValue(1)>] scoreIndex : int, 
                                [<Optional; DefaultParameterValue(-1)>] idIndex : int, 
                                [<Optional; DefaultParameterValue(-1)>] backgroundId : int, 
                                [<Optional; DefaultParameterValue(false)>] forceSuppress : bool, 
                                [<Optional>] inFormat : Format, 
                                [<Optional>] outFormat : Format) =
        let creator = AtomicSymbolCreator.FromName "_contrib_box_nms"
        let names = [|"overlap_thresh"; "valid_thresh"; "topk"; "coord_start"; "score_index"; "id_index"; "background_id"; "force_suppress"; "in_format"; "out_format"|]
        let vals = [|string overlapThresh; string validThresh; string topk; string coordStart; string scoreIndex; string idIndex; string backgroundId; string forceSuppress; (if isNull (inFormat :> obj) then "corner" else string inFormat); (if isNull (outFormat :> obj) then "corner" else string outFormat)|]
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <summary>Apply non-maximum suppression to input.
    /// 
    /// The output will be sorted in descending order according to `score`. Boxes with
    /// overlaps larger than `overlap_thresh`, smaller scores and background boxes
    /// will be removed and filled with -1, the corresponding position will be recorded
    /// for backward propogation.
    /// 
    /// During back-propagation, the gradient will be copied to the original
    /// position according to the input index. For positions that have been suppressed,
    /// the in_grad will be assigned 0.
    /// In summary, gradients are sticked to its boxes, will either be moved or discarded
    /// according to its original index in input.
    /// 
    /// Input requirements::
    /// 
    ///   1. Input tensor have at least 2 dimensions, (n, k), any higher dims will be regarded
    ///   as batch, e.g. (a, b, c, d, n, k) == (a*b*c*d, n, k)
    ///   2. n is the number of boxes in each batch
    ///   3. k is the width of each box item.
    /// 
    /// By default, a box is [id, score, xmin, ymin, xmax, ymax, ...],
    /// additional elements are allowed.
    /// 
    /// - `id_index`: optional, use -1 to ignore, useful if `force_suppress=False`, which means
    ///   we will skip highly overlapped boxes if one is `apple` while the other is `car`.
    /// 
    /// - `background_id`: optional, default=-1, class id for background boxes, useful
    ///   when `id_index &gt;= 0` which means boxes with background id will be filtered before nms.
    /// 
    /// - `coord_start`: required, default=2, the starting index of the 4 coordinates.
    ///   Two formats are supported:
    /// 
    ///     - `corner`: [xmin, ymin, xmax, ymax]
    /// 
    ///     - `center`: [x, y, width, height]
    /// 
    /// - `score_index`: required, default=1, box score/confidence.
    ///   When two boxes overlap IOU &gt; `overlap_thresh`, the one with smaller score will be suppressed.
    /// 
    /// - `in_format` and `out_format`: default=&#39;corner&#39;, specify in/out box formats.
    /// 
    /// Examples::
    /// 
    ///   x = [[0, 0.5, 0.1, 0.1, 0.2, 0.2], [1, 0.4, 0.1, 0.1, 0.2, 0.2],
    ///        [0, 0.3, 0.1, 0.1, 0.14, 0.14], [2, 0.6, 0.5, 0.5, 0.7, 0.8]]
    ///   box_nms(x, overlap_thresh=0.1, coord_start=2, score_index=1, id_index=0,
    ///       force_suppress=True, in_format=&#39;corner&#39;, out_typ=&#39;corner&#39;) =
    ///       [[2, 0.6, 0.5, 0.5, 0.7, 0.8], [0, 0.5, 0.1, 0.1, 0.2, 0.2],
    ///        [-1, -1, -1, -1, -1, -1], [-1, -1, -1, -1, -1, -1]]
    ///   out_grad = [[0.1, 0.1, 0.1, 0.1, 0.1, 0.1], [0.2, 0.2, 0.2, 0.2, 0.2, 0.2],
    ///               [0.3, 0.3, 0.3, 0.3, 0.3, 0.3], [0.4, 0.4, 0.4, 0.4, 0.4, 0.4]]
    ///   # exe.backward
    ///   in_grad = [[0.2, 0.2, 0.2, 0.2, 0.2, 0.2], [0, 0, 0, 0, 0, 0],
    ///              [0, 0, 0, 0, 0, 0], [0.1, 0.1, 0.1, 0.1, 0.1, 0.1]]
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\contrib\bounding_box.cc:L95</summary>
    /// <param name="data">The input</param>
    /// <param name="overlapThresh">Overlapping(IoU) threshold to suppress object with smaller score.</param>
    /// <param name="validThresh">Filter input boxes to those whose scores greater than valid_thresh.</param>
    /// <param name="topk">Apply nms to topk boxes with descending scores, -1 to no restriction.</param>
    /// <param name="coordStart">Start index of the consecutive 4 coordinates.</param>
    /// <param name="scoreIndex">Index of the scores/confidence of boxes.</param>
    /// <param name="idIndex">Optional, index of the class categories, -1 to disable.</param>
    /// <param name="backgroundId">Optional, id of the background class which will be ignored in nms.</param>
    /// <param name="forceSuppress">Optional, if set false and id_index is provided, nms will only apply to boxes belongs to the same category</param>
    /// <param name="inFormat">The input box encoding type. 
    ///  &quot;corner&quot; means boxes are encoded as [xmin, ymin, xmax, ymax], &quot;center&quot; means boxes are encodes as [x, y, width, height].</param>
    /// <param name="outFormat">The output box encoding type. 
    ///  &quot;corner&quot; means boxes are encoded as [xmin, ymin, xmax, ymax], &quot;center&quot; means boxes are encodes as [x, y, width, height].</param>
    static member ContribBoxNms([<Optional>] ?data : Symbol, [<Optional>] ?overlapThresh : float, [<Optional>] ?validThresh : float, [<Optional>] ?topk : int, [<Optional>] ?coordStart : int, [<Optional>] ?scoreIndex : int, [<Optional>] ?idIndex : int, [<Optional>] ?backgroundId : int, [<Optional>] ?forceSuppress : bool, [<Optional>] ?inFormat : Format, [<Optional>] ?outFormat : Format) =
        ContribBoxNms(?data = data, ?overlapThresh = overlapThresh, ?validThresh = validThresh, ?topk = topk, ?coordStart = coordStart, ?scoreIndex = scoreIndex, ?idIndex = idIndex, ?backgroundId = backgroundId, ?forceSuppress = forceSuppress, ?inFormat = inFormat, ?outFormat = outFormat)


    /// <summary>Bounding box overlap of two arrays.
    ///   The overlap is defined as Intersection-over-Union, aka, IOU.
    ///   - lhs: (a_1, a_2, ..., a_n, 4) array
    ///   - rhs: (b_1, b_2, ..., b_n, 4) array
    ///   - output: (a_1, a_2, ..., a_n, b_1, b_2, ..., b_n) array
    /// 
    ///   Note::
    /// 
    ///     Zero gradients are back-propagated in this op for now.
    /// 
    ///   Example::
    /// 
    ///     x = [[0.5, 0.5, 1.0, 1.0], [0.0, 0.0, 0.5, 0.5]]
    ///     y = [[0.25, 0.25, 0.75, 0.75]]
    ///     box_iou(x, y, format=&#39;corner&#39;) = [[0.1428], [0.1428]]
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\contrib\bounding_box.cc:L137</summary>
    /// <param name="lhs">The first input</param>
    /// <param name="rhs">The second input</param>
    /// <param name="format">The box encoding type. 
    ///  &quot;corner&quot; means boxes are encoded as [xmin, ymin, xmax, ymax], &quot;center&quot; means boxes are encodes as [x, y, width, height].</param>
    static member ContribBoxIou(lhs : NDArray, rhs : NDArray, [<Optional>] format : Format) =
        let creator = AtomicSymbolCreator.FromName "_contrib_box_iou"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg lhs)) then lhs.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg rhs)) then rhs.UnsafeHandle|]
                                                 [|"format"|]
                                                 [|(if isNull (format :> obj) then "corner" else string format)|]
        (new NDArray(outputs.[0]))
    /// <summary>Bounding box overlap of two arrays.
    ///   The overlap is defined as Intersection-over-Union, aka, IOU.
    ///   - lhs: (a_1, a_2, ..., a_n, 4) array
    ///   - rhs: (b_1, b_2, ..., b_n, 4) array
    ///   - output: (a_1, a_2, ..., a_n, b_1, b_2, ..., b_n) array
    /// 
    ///   Note::
    /// 
    ///     Zero gradients are back-propagated in this op for now.
    /// 
    ///   Example::
    /// 
    ///     x = [[0.5, 0.5, 1.0, 1.0], [0.0, 0.0, 0.5, 0.5]]
    ///     y = [[0.25, 0.25, 0.75, 0.75]]
    ///     box_iou(x, y, format=&#39;corner&#39;) = [[0.1428], [0.1428]]
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\contrib\bounding_box.cc:L137</summary>
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="lhs">The first input</param>
    /// <param name="rhs">The second input</param>
    /// <param name="format">The box encoding type. 
    ///  &quot;corner&quot; means boxes are encoded as [xmin, ymin, xmax, ymax], &quot;center&quot; means boxes are encodes as [x, y, width, height].</param>
    static member ContribBoxIou(outputArray : NDArray seq, lhs : NDArray, rhs : NDArray, [<Optional>] format : Format) =
        let creator = AtomicSymbolCreator.FromName "_contrib_box_iou"
        let names = [|"format"|]
        let vals = [|(if isNull (format :> obj) then "corner" else string format)|]
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg lhs)) then lhs.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg rhs)) then rhs.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <summary>Bounding box overlap of two arrays.
    ///   The overlap is defined as Intersection-over-Union, aka, IOU.
    ///   - lhs: (a_1, a_2, ..., a_n, 4) array
    ///   - rhs: (b_1, b_2, ..., b_n, 4) array
    ///   - output: (a_1, a_2, ..., a_n, b_1, b_2, ..., b_n) array
    /// 
    ///   Note::
    /// 
    ///     Zero gradients are back-propagated in this op for now.
    /// 
    ///   Example::
    /// 
    ///     x = [[0.5, 0.5, 1.0, 1.0], [0.0, 0.0, 0.5, 0.5]]
    ///     y = [[0.25, 0.25, 0.75, 0.75]]
    ///     box_iou(x, y, format=&#39;corner&#39;) = [[0.1428], [0.1428]]
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\contrib\bounding_box.cc:L137</summary>
    /// <param name="lhs">The first input</param>
    /// <param name="rhs">The second input</param>
    /// <param name="format">The box encoding type. 
    ///  &quot;corner&quot; means boxes are encoded as [xmin, ymin, xmax, ymax], &quot;center&quot; means boxes are encodes as [x, y, width, height].</param>
    static member ContribBoxIou([<Optional>] ?lhs : Symbol, [<Optional>] ?rhs : Symbol, [<Optional>] ?format : Format) =
        ContribBoxIou(?lhs = lhs, ?rhs = rhs, ?format = format)


    /// <summary>Compute bipartite matching.
    ///   The matching is performed on score matrix with shape [B, N, M]
    ///   - B: batch_size
    ///   - N: number of rows to match
    ///   - M: number of columns as reference to be matched against.
    /// 
    ///   Returns:
    ///   x : matched column indices. -1 indicating non-matched elements in rows.
    ///   y : matched row indices.
    /// 
    ///   Note::
    /// 
    ///     Zero gradients are back-propagated in this op for now.
    /// 
    ///   Example::
    /// 
    ///     s = [[0.5, 0.6], [0.1, 0.2], [0.3, 0.4]]
    ///     x, y = bipartite_matching(x, threshold=1e-12, is_ascend=False)
    ///     x = [1, -1, 0]
    ///     y = [2, 0]
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\contrib\bounding_box.cc:L183</summary>
    /// <param name="data">The input</param>
    /// <param name="threshold">Ignore matching when score &lt; thresh, if is_ascend=false, or ignore score &gt; thresh, if is_ascend=true.</param>
    /// <param name="isAscend">Use ascend order for scores instead of descending. Please set threshold accordingly.</param>
    /// <param name="topk">Limit the number of matches to topk, set -1 for no limit</param>
    static member ContribBipartiteMatching(data : NDArray, threshold : float, [<Optional; DefaultParameterValue(false)>] isAscend : bool, [<Optional; DefaultParameterValue(-1)>] topk : int) =
        let creator = AtomicSymbolCreator.FromName "_contrib_bipartite_matching"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle|]
                                                 [|"threshold"; "is_ascend"; "topk"|]
                                                 [|string threshold; string isAscend; string topk|]
        (new NDArray(outputs.[0])), (new NDArray(outputs.[1]))
    /// <summary>Compute bipartite matching.
    ///   The matching is performed on score matrix with shape [B, N, M]
    ///   - B: batch_size
    ///   - N: number of rows to match
    ///   - M: number of columns as reference to be matched against.
    /// 
    ///   Returns:
    ///   x : matched column indices. -1 indicating non-matched elements in rows.
    ///   y : matched row indices.
    /// 
    ///   Note::
    /// 
    ///     Zero gradients are back-propagated in this op for now.
    /// 
    ///   Example::
    /// 
    ///     s = [[0.5, 0.6], [0.1, 0.2], [0.3, 0.4]]
    ///     x, y = bipartite_matching(x, threshold=1e-12, is_ascend=False)
    ///     x = [1, -1, 0]
    ///     y = [2, 0]
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\contrib\bounding_box.cc:L183</summary>
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="data">The input</param>
    /// <param name="threshold">Ignore matching when score &lt; thresh, if is_ascend=false, or ignore score &gt; thresh, if is_ascend=true.</param>
    /// <param name="isAscend">Use ascend order for scores instead of descending. Please set threshold accordingly.</param>
    /// <param name="topk">Limit the number of matches to topk, set -1 for no limit</param>
    static member ContribBipartiteMatching(outputArray : NDArray seq, data : NDArray, threshold : float, [<Optional; DefaultParameterValue(false)>] isAscend : bool, [<Optional; DefaultParameterValue(-1)>] topk : int) =
        let creator = AtomicSymbolCreator.FromName "_contrib_bipartite_matching"
        let names = [|"threshold"; "is_ascend"; "topk"|]
        let vals = [|string threshold; string isAscend; string topk|]
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <summary>Compute bipartite matching.
    ///   The matching is performed on score matrix with shape [B, N, M]
    ///   - B: batch_size
    ///   - N: number of rows to match
    ///   - M: number of columns as reference to be matched against.
    /// 
    ///   Returns:
    ///   x : matched column indices. -1 indicating non-matched elements in rows.
    ///   y : matched row indices.
    /// 
    ///   Note::
    /// 
    ///     Zero gradients are back-propagated in this op for now.
    /// 
    ///   Example::
    /// 
    ///     s = [[0.5, 0.6], [0.1, 0.2], [0.3, 0.4]]
    ///     x, y = bipartite_matching(x, threshold=1e-12, is_ascend=False)
    ///     x = [1, -1, 0]
    ///     y = [2, 0]
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\contrib\bounding_box.cc:L183</summary>
    /// <param name="data">The input</param>
    /// <param name="threshold">Ignore matching when score &lt; thresh, if is_ascend=false, or ignore score &gt; thresh, if is_ascend=true.</param>
    /// <param name="isAscend">Use ascend order for scores instead of descending. Please set threshold accordingly.</param>
    /// <param name="topk">Limit the number of matches to topk, set -1 for no limit</param>
    static member ContribBipartiteMatching(data : Symbol, threshold : float, [<Optional>] ?isAscend : bool, [<Optional>] ?topk : int) =
        ContribBipartiteMatching(data, threshold, ?isAscend = isAscend, ?topk = topk)
    /// <summary>Compute bipartite matching.
    ///   The matching is performed on score matrix with shape [B, N, M]
    ///   - B: batch_size
    ///   - N: number of rows to match
    ///   - M: number of columns as reference to be matched against.
    /// 
    ///   Returns:
    ///   x : matched column indices. -1 indicating non-matched elements in rows.
    ///   y : matched row indices.
    /// 
    ///   Note::
    /// 
    ///     Zero gradients are back-propagated in this op for now.
    /// 
    ///   Example::
    /// 
    ///     s = [[0.5, 0.6], [0.1, 0.2], [0.3, 0.4]]
    ///     x, y = bipartite_matching(x, threshold=1e-12, is_ascend=False)
    ///     x = [1, -1, 0]
    ///     y = [2, 0]
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\contrib\bounding_box.cc:L183</summary>
    /// <param name="threshold">Ignore matching when score &lt; thresh, if is_ascend=false, or ignore score &gt; thresh, if is_ascend=true.</param>
    /// <param name="data">The input</param>
    /// <param name="isAscend">Use ascend order for scores instead of descending. Please set threshold accordingly.</param>
    /// <param name="topk">Limit the number of matches to topk, set -1 for no limit</param>
    static member ContribBipartiteMatching(threshold : float, [<Optional>] ?data : Symbol, [<Optional>] ?isAscend : bool, [<Optional>] ?topk : int) =
        ContribBipartiteMatching(threshold, ?data = data, ?isAscend = isAscend, ?topk = topk)


    /// <summary>Encode bounding boxes training target with normalized center offsets.
    ///     Input bounding boxes are using corner type: `x_{min}, y_{min}, x_{max}, y_{max}`.) array
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\contrib\bounding_box.cc:L211</summary>
    /// <param name="samples">(B, N) value +1 (positive), -1 (negative), 0 (ignore)</param>
    /// <param name="matches">(B, N) value range [0, M)</param>
    /// <param name="anchors">(B, N, 4) encoded in corner</param>
    /// <param name="refs">(B, M, 4) encoded in corner</param>
    /// <param name="means">(4,) Mean value to be subtracted from encoded values</param>
    /// <param name="stds">(4,) Std value to be divided from encoded values</param>
    static member ContribBoxEncode(samples : NDArray, 
                                   matches : NDArray, 
                                   anchors : NDArray, 
                                   refs : NDArray, 
                                   means : NDArray, 
                                   stds : NDArray) =
        let creator = AtomicSymbolCreator.FromName "_contrib_box_encode"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg samples)) then samples.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg matches)) then matches.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg anchors)) then anchors.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg refs)) then refs.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg means)) then means.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg stds)) then stds.UnsafeHandle|]
                                                 Array.empty
                                                 Array.empty
        outputs |> Array.map (fun h -> new NDArray(h))
    /// <summary>Encode bounding boxes training target with normalized center offsets.
    ///     Input bounding boxes are using corner type: `x_{min}, y_{min}, x_{max}, y_{max}`.) array
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\contrib\bounding_box.cc:L211</summary>
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="samples">(B, N) value +1 (positive), -1 (negative), 0 (ignore)</param>
    /// <param name="matches">(B, N) value range [0, M)</param>
    /// <param name="anchors">(B, N, 4) encoded in corner</param>
    /// <param name="refs">(B, M, 4) encoded in corner</param>
    /// <param name="means">(4,) Mean value to be subtracted from encoded values</param>
    /// <param name="stds">(4,) Std value to be divided from encoded values</param>
    static member ContribBoxEncode(outputArray : NDArray seq, 
                                   samples : NDArray, 
                                   matches : NDArray, 
                                   anchors : NDArray, 
                                   refs : NDArray, 
                                   means : NDArray, 
                                   stds : NDArray) =
        let creator = AtomicSymbolCreator.FromName "_contrib_box_encode"
        let names = Array.empty
        let vals = Array.empty
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg samples)) then samples.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg matches)) then matches.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg anchors)) then anchors.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg refs)) then refs.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg means)) then means.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg stds)) then stds.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <summary>Encode bounding boxes training target with normalized center offsets.
    ///     Input bounding boxes are using corner type: `x_{min}, y_{min}, x_{max}, y_{max}`.) array
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\contrib\bounding_box.cc:L211</summary>
    /// <param name="samples">(B, N) value +1 (positive), -1 (negative), 0 (ignore)</param>
    /// <param name="matches">(B, N) value range [0, M)</param>
    /// <param name="anchors">(B, N, 4) encoded in corner</param>
    /// <param name="refs">(B, M, 4) encoded in corner</param>
    /// <param name="means">(4,) Mean value to be subtracted from encoded values</param>
    /// <param name="stds">(4,) Std value to be divided from encoded values</param>
    static member ContribBoxEncode([<Optional>] ?samples : Symbol, [<Optional>] ?matches : Symbol, [<Optional>] ?anchors : Symbol, [<Optional>] ?refs : Symbol, [<Optional>] ?means : Symbol, [<Optional>] ?stds : Symbol) =
        ContribBoxEncode(?samples = samples, ?matches = matches, ?anchors = anchors, ?refs = refs, ?means = means, ?stds = stds)

    /// <summary>Decode bounding boxes training target with normalized center offsets.
    ///     Input bounding boxes are using corner type: `x_{min}, y_{min}, x_{max}, y_{max}`
    ///     or center type: `x, y, width, height.) array
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\contrib\bounding_box.cc:L234</summary>
    /// <param name="data">(B, N, 4) predicted bbox offset</param>
    /// <param name="anchors">(1, N, 4) encoded in corner or center</param>
    /// <param name="std0">value to be divided from the 1st encoded values</param>
    /// <param name="std1">value to be divided from the 2nd encoded values</param>
    /// <param name="std2">value to be divided from the 3rd encoded values</param>
    /// <param name="std3">value to be divided from the 4th encoded values</param>
    /// <param name="clip">If larger than 0, bounding box target will be clipped to this value.</param>
    /// <param name="format">The box encoding type. 
    ///  &quot;corner&quot; means boxes are encoded as [xmin, ymin, xmax, ymax], &quot;center&quot; means boxes are encodes as [x, y, width, height].</param>
    static member ContribBoxDecode(data : NDArray, 
                                   anchors : NDArray, 
                                   [<Optional; DefaultParameterValue(1.0)>] std0 : float, 
                                   [<Optional; DefaultParameterValue(1.0)>] std1 : float, 
                                   [<Optional; DefaultParameterValue(1.0)>] std2 : float, 
                                   [<Optional; DefaultParameterValue(1.0)>] std3 : float, 
                                   [<Optional; DefaultParameterValue(-1.0)>] clip : float, 
                                   [<Optional>] format : Format) =
        let creator = AtomicSymbolCreator.FromName "_contrib_box_decode"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg anchors)) then anchors.UnsafeHandle|]
                                                 [|"std0"; "std1"; "std2"; "std3"; "clip"; "format"|]
                                                 [|string std0; string std1; string std2; string std3; string clip; (if isNull (format :> obj) then "center" else string format)|]
        outputs |> Array.map (fun h -> new NDArray(h))
    /// <summary>Decode bounding boxes training target with normalized center offsets.
    ///     Input bounding boxes are using corner type: `x_{min}, y_{min}, x_{max}, y_{max}`
    ///     or center type: `x, y, width, height.) array
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\contrib\bounding_box.cc:L234</summary>
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="data">(B, N, 4) predicted bbox offset</param>
    /// <param name="anchors">(1, N, 4) encoded in corner or center</param>
    /// <param name="std0">value to be divided from the 1st encoded values</param>
    /// <param name="std1">value to be divided from the 2nd encoded values</param>
    /// <param name="std2">value to be divided from the 3rd encoded values</param>
    /// <param name="std3">value to be divided from the 4th encoded values</param>
    /// <param name="clip">If larger than 0, bounding box target will be clipped to this value.</param>
    /// <param name="format">The box encoding type. 
    ///  &quot;corner&quot; means boxes are encoded as [xmin, ymin, xmax, ymax], &quot;center&quot; means boxes are encodes as [x, y, width, height].</param>
    static member ContribBoxDecode(outputArray : NDArray seq, 
                                   data : NDArray, 
                                   anchors : NDArray, 
                                   [<Optional; DefaultParameterValue(1.0)>] std0 : float, 
                                   [<Optional; DefaultParameterValue(1.0)>] std1 : float, 
                                   [<Optional; DefaultParameterValue(1.0)>] std2 : float, 
                                   [<Optional; DefaultParameterValue(1.0)>] std3 : float, 
                                   [<Optional; DefaultParameterValue(-1.0)>] clip : float, 
                                   [<Optional>] format : Format) =
        let creator = AtomicSymbolCreator.FromName "_contrib_box_decode"
        let names = [|"std0"; "std1"; "std2"; "std3"; "clip"; "format"|]
        let vals = [|string std0; string std1; string std2; string std3; string clip; (if isNull (format :> obj) then "center" else string format)|]
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg anchors)) then anchors.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <summary>Decode bounding boxes training target with normalized center offsets.
    ///     Input bounding boxes are using corner type: `x_{min}, y_{min}, x_{max}, y_{max}`
    ///     or center type: `x, y, width, height.) array
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\contrib\bounding_box.cc:L234</summary>
    /// <param name="data">(B, N, 4) predicted bbox offset</param>
    /// <param name="anchors">(1, N, 4) encoded in corner or center</param>
    /// <param name="std0">value to be divided from the 1st encoded values</param>
    /// <param name="std1">value to be divided from the 2nd encoded values</param>
    /// <param name="std2">value to be divided from the 3rd encoded values</param>
    /// <param name="std3">value to be divided from the 4th encoded values</param>
    /// <param name="clip">If larger than 0, bounding box target will be clipped to this value.</param>
    /// <param name="format">The box encoding type. 
    ///  &quot;corner&quot; means boxes are encoded as [xmin, ymin, xmax, ymax], &quot;center&quot; means boxes are encodes as [x, y, width, height].</param>
    static member ContribBoxDecode([<Optional>] ?data : Symbol, [<Optional>] ?anchors : Symbol, [<Optional>] ?std0 : float, [<Optional>] ?std1 : float, [<Optional>] ?std2 : float, [<Optional>] ?std3 : float, [<Optional>] ?clip : float, [<Optional>] ?format : Format) =
        ContribBoxDecode(?data = data, ?anchors = anchors, ?std0 = std0, ?std1 = std1, ?std2 = std2, ?std3 = std3, ?clip = clip, ?format = format)

    /// <summary>This operator samples sub-graphs from a csr graph via an
    /// uniform probability. The operator is designed for DGL.
    /// 
    /// The operator outputs three sets of NDArrays to represent the sampled results
    /// (the number of NDArrays in each set is the same as the number of seed NDArrays):
    /// 1) a set of 1D NDArrays containing the sampled vertices, 2) a set of CSRNDArrays representing
    /// the sampled edges, 3) a set of 1D NDArrays indicating the layer where a vertex is sampled.
    /// The first set of 1D NDArrays have a length of max_num_vertices+1. The last element in an NDArray
    /// indicate the acutal number of vertices in a subgraph. The third set of NDArrays have a length
    /// of max_num_vertices, and the valid number of vertices is the same as the ones in the first set.
    /// 
    /// Example:
    /// 
    ///    .. code:: python
    /// 
    ///   shape = (5, 5)
    ///   data_np = np.array([1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20], dtype=np.int64)
    ///   indices_np = np.array([1,2,3,4,0,2,3,4,0,1,3,4,0,1,2,4,0,1,2,3], dtype=np.int64)
    ///   indptr_np = np.array([0,4,8,12,16,20], dtype=np.int64)
    ///   a = mx.nd.sparse.csr_matrix((data_np, indices_np, indptr_np), shape=shape)
    ///   a.asnumpy()
    ///   seed = mx.nd.array([0,1,2,3,4], dtype=np.int64)
    ///   out = mx.nd.contrib.dgl_csr_neighbor_uniform_sample(a, seed, num_args=2, num_hops=1, num_neighbor=2, max_num_vertices=5)
    /// 
    ///   out[0]
    ///   [0 1 2 3 4 5]
    ///   &lt;NDArray 6 @cpu(0)&gt;
    /// 
    ///   out[1].asnumpy()
    ///   array([[ 0,  1,  0,  3,  0],
    ///          [ 5,  0,  0,  7,  0],
    ///          [ 9,  0,  0, 11,  0],
    ///          [13,  0, 15,  0,  0],
    ///          [17,  0, 19,  0,  0]])
    /// 
    ///   out[2]
    ///   [0 0 0 0 0]
    ///   &lt;NDArray 5 @cpu(0)&gt;
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\contrib\dgl_graph.cc:L784</summary>
    /// <param name="csrMatrix">csr matrix</param>
    /// <param name="seedArrays">seed vertices</param>
    /// <param name="numArgs">Number of input NDArray.</param>
    /// <param name="numHops">Number of hops.</param>
    /// <param name="numNeighbor">Number of neighbor.</param>
    /// <param name="maxNumVertices">Max number of vertices.</param>
    static member ContribDglCsrNeighborUniformSample(csrMatrix : NDArray, 
                                                     [<ParamArray>] seedArrays : NDArray[], 
                                                     [<Optional; DefaultParameterValue(1L)>] numHops : int64, 
                                                     [<Optional; DefaultParameterValue(2L)>] numNeighbor : int64, 
                                                     [<Optional; DefaultParameterValue(100L)>] maxNumVertices : int64) =
        let creator = AtomicSymbolCreator.FromName "_contrib_dgl_csr_neighbor_uniform_sample"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg csrMatrix)) then csrMatrix.UnsafeHandle; yield! (seedArrays |> Seq.map (fun x -> x.UnsafeHandle))|]
                                                 [|"num_args"; "num_hops"; "num_neighbor"; "max_num_vertices"|]
                                                 [|string seedArrays.Length; string numHops; string numNeighbor; string maxNumVertices|]
        outputs |> Array.map (fun h -> new NDArray(h))
    /// <summary>This operator samples sub-graphs from a csr graph via an
    /// uniform probability. The operator is designed for DGL.
    /// 
    /// The operator outputs three sets of NDArrays to represent the sampled results
    /// (the number of NDArrays in each set is the same as the number of seed NDArrays):
    /// 1) a set of 1D NDArrays containing the sampled vertices, 2) a set of CSRNDArrays representing
    /// the sampled edges, 3) a set of 1D NDArrays indicating the layer where a vertex is sampled.
    /// The first set of 1D NDArrays have a length of max_num_vertices+1. The last element in an NDArray
    /// indicate the acutal number of vertices in a subgraph. The third set of NDArrays have a length
    /// of max_num_vertices, and the valid number of vertices is the same as the ones in the first set.
    /// 
    /// Example:
    /// 
    ///    .. code:: python
    /// 
    ///   shape = (5, 5)
    ///   data_np = np.array([1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20], dtype=np.int64)
    ///   indices_np = np.array([1,2,3,4,0,2,3,4,0,1,3,4,0,1,2,4,0,1,2,3], dtype=np.int64)
    ///   indptr_np = np.array([0,4,8,12,16,20], dtype=np.int64)
    ///   a = mx.nd.sparse.csr_matrix((data_np, indices_np, indptr_np), shape=shape)
    ///   a.asnumpy()
    ///   seed = mx.nd.array([0,1,2,3,4], dtype=np.int64)
    ///   out = mx.nd.contrib.dgl_csr_neighbor_uniform_sample(a, seed, num_args=2, num_hops=1, num_neighbor=2, max_num_vertices=5)
    /// 
    ///   out[0]
    ///   [0 1 2 3 4 5]
    ///   &lt;NDArray 6 @cpu(0)&gt;
    /// 
    ///   out[1].asnumpy()
    ///   array([[ 0,  1,  0,  3,  0],
    ///          [ 5,  0,  0,  7,  0],
    ///          [ 9,  0,  0, 11,  0],
    ///          [13,  0, 15,  0,  0],
    ///          [17,  0, 19,  0,  0]])
    /// 
    ///   out[2]
    ///   [0 0 0 0 0]
    ///   &lt;NDArray 5 @cpu(0)&gt;
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\contrib\dgl_graph.cc:L784</summary>
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="csrMatrix">csr matrix</param>
    /// <param name="seedArrays">seed vertices</param>
    /// <param name="numArgs">Number of input NDArray.</param>
    /// <param name="numHops">Number of hops.</param>
    /// <param name="numNeighbor">Number of neighbor.</param>
    /// <param name="maxNumVertices">Max number of vertices.</param>
    static member ContribDglCsrNeighborUniformSample(outputArray : NDArray seq, 
                                                     csrMatrix : NDArray, 
                                                     [<ParamArray>] seedArrays : NDArray[], 
                                                     [<Optional; DefaultParameterValue(1L)>] numHops : int64, 
                                                     [<Optional; DefaultParameterValue(2L)>] numNeighbor : int64, 
                                                     [<Optional; DefaultParameterValue(100L)>] maxNumVertices : int64) =
        let creator = AtomicSymbolCreator.FromName "_contrib_dgl_csr_neighbor_uniform_sample"
        let names = [|"num_args"; "num_hops"; "num_neighbor"; "max_num_vertices"|]
        let vals = [|string seedArrays.Length; string numHops; string numNeighbor; string maxNumVertices|]
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg csrMatrix)) then csrMatrix.UnsafeHandle; yield! (seedArrays |> Seq.map (fun x -> x.UnsafeHandle))|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <summary>This operator samples sub-graphs from a csr graph via an
    /// uniform probability. The operator is designed for DGL.
    /// 
    /// The operator outputs three sets of NDArrays to represent the sampled results
    /// (the number of NDArrays in each set is the same as the number of seed NDArrays):
    /// 1) a set of 1D NDArrays containing the sampled vertices, 2) a set of CSRNDArrays representing
    /// the sampled edges, 3) a set of 1D NDArrays indicating the layer where a vertex is sampled.
    /// The first set of 1D NDArrays have a length of max_num_vertices+1. The last element in an NDArray
    /// indicate the acutal number of vertices in a subgraph. The third set of NDArrays have a length
    /// of max_num_vertices, and the valid number of vertices is the same as the ones in the first set.
    /// 
    /// Example:
    /// 
    ///    .. code:: python
    /// 
    ///   shape = (5, 5)
    ///   data_np = np.array([1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20], dtype=np.int64)
    ///   indices_np = np.array([1,2,3,4,0,2,3,4,0,1,3,4,0,1,2,4,0,1,2,3], dtype=np.int64)
    ///   indptr_np = np.array([0,4,8,12,16,20], dtype=np.int64)
    ///   a = mx.nd.sparse.csr_matrix((data_np, indices_np, indptr_np), shape=shape)
    ///   a.asnumpy()
    ///   seed = mx.nd.array([0,1,2,3,4], dtype=np.int64)
    ///   out = mx.nd.contrib.dgl_csr_neighbor_uniform_sample(a, seed, num_args=2, num_hops=1, num_neighbor=2, max_num_vertices=5)
    /// 
    ///   out[0]
    ///   [0 1 2 3 4 5]
    ///   &lt;NDArray 6 @cpu(0)&gt;
    /// 
    ///   out[1].asnumpy()
    ///   array([[ 0,  1,  0,  3,  0],
    ///          [ 5,  0,  0,  7,  0],
    ///          [ 9,  0,  0, 11,  0],
    ///          [13,  0, 15,  0,  0],
    ///          [17,  0, 19,  0,  0]])
    /// 
    ///   out[2]
    ///   [0 0 0 0 0]
    ///   &lt;NDArray 5 @cpu(0)&gt;
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\contrib\dgl_graph.cc:L784</summary>
    /// <param name="csrMatrix">csr matrix</param>
    /// <param name="seedArrays">seed vertices</param>
    /// <param name="numHops">Number of hops.</param>
    /// <param name="numNeighbor">Number of neighbor.</param>
    /// <param name="maxNumVertices">Max number of vertices.</param>
    static member ContribDglCsrNeighborUniformSample([<Optional>] ?csrMatrix : Symbol, [<Optional>] ?seedArrays : Symbol seq, [<Optional>] ?numHops : int64, [<Optional>] ?numNeighbor : int64, [<Optional>] ?maxNumVertices : int64) =
        ContribDglCsrNeighborUniformSample(?csrMatrix = csrMatrix, ?seedArrays = seedArrays, ?numHops = numHops, ?numNeighbor = numNeighbor, ?maxNumVertices = maxNumVertices)

    /// <summary>This operator samples sub-graph from a csr graph via an
    /// non-uniform probability. The operator is designed for DGL.
    /// 
    /// The operator outputs four sets of NDArrays to represent the sampled results
    /// (the number of NDArrays in each set is the same as the number of seed NDArrays):
    /// 1) a set of 1D NDArrays containing the sampled vertices, 2) a set of CSRNDArrays representing
    /// the sampled edges, 3) a set of 1D NDArrays with the probability that vertices are sampled,
    /// 4) a set of 1D NDArrays indicating the layer where a vertex is sampled.
    /// The first set of 1D NDArrays have a length of max_num_vertices+1. The last element in an NDArray
    /// indicate the acutal number of vertices in a subgraph. The third and fourth set of NDArrays have a length
    /// of max_num_vertices, and the valid number of vertices is the same as the ones in the first set.
    /// 
    /// Example:
    /// 
    ///    .. code:: python
    /// 
    ///   shape = (5, 5)
    ///   prob = mx.nd.array([0.9, 0.8, 0.2, 0.4, 0.1], dtype=np.float32)
    ///   data_np = np.array([1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20], dtype=np.int64)
    ///   indices_np = np.array([1,2,3,4,0,2,3,4,0,1,3,4,0,1,2,4,0,1,2,3], dtype=np.int64)
    ///   indptr_np = np.array([0,4,8,12,16,20], dtype=np.int64)
    ///   a = mx.nd.sparse.csr_matrix((data_np, indices_np, indptr_np), shape=shape)
    ///   seed = mx.nd.array([0,1,2,3,4], dtype=np.int64)
    ///   out = mx.nd.contrib.dgl_csr_neighbor_non_uniform_sample(a, prob, seed, num_args=3, num_hops=1, num_neighbor=2, max_num_vertices=5)
    /// 
    ///   out[0]
    ///   [0 1 2 3 4 5]
    ///   &lt;NDArray 6 @cpu(0)&gt;
    /// 
    ///   out[1].asnumpy()
    ///   array([[ 0,  1,  2,  0,  0],
    ///          [ 5,  0,  6,  0,  0],
    ///          [ 9, 10,  0,  0,  0],
    ///          [13, 14,  0,  0,  0],
    ///          [ 0, 18, 19,  0,  0]])
    /// 
    ///   out[2]
    ///   [0.9 0.8 0.2 0.4 0.1]
    ///   &lt;NDArray 5 @cpu(0)&gt;
    /// 
    ///   out[3]
    ///   [0 0 0 0 0]
    ///   &lt;NDArray 5 @cpu(0)&gt;
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\contrib\dgl_graph.cc:L883</summary>
    /// <param name="csrMatrix">csr matrix</param>
    /// <param name="probability">probability vector</param>
    /// <param name="seedArrays">seed vertices</param>
    /// <param name="numArgs">Number of input NDArray.</param>
    /// <param name="numHops">Number of hops.</param>
    /// <param name="numNeighbor">Number of neighbor.</param>
    /// <param name="maxNumVertices">Max number of vertices.</param>
    static member ContribDglCsrNeighborNonUniformSample(csrMatrix : NDArray, 
                                                        probability : NDArray, 
                                                        [<ParamArray>] seedArrays : NDArray[], 
                                                        [<Optional; DefaultParameterValue(1L)>] numHops : int64, 
                                                        [<Optional; DefaultParameterValue(2L)>] numNeighbor : int64, 
                                                        [<Optional; DefaultParameterValue(100L)>] maxNumVertices : int64) =
        let creator = AtomicSymbolCreator.FromName "_contrib_dgl_csr_neighbor_non_uniform_sample"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg csrMatrix)) then csrMatrix.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg probability)) then probability.UnsafeHandle; yield! (seedArrays |> Seq.map (fun x -> x.UnsafeHandle))|]
                                                 [|"num_args"; "num_hops"; "num_neighbor"; "max_num_vertices"|]
                                                 [|string seedArrays.Length; string numHops; string numNeighbor; string maxNumVertices|]
        outputs |> Array.map (fun h -> new NDArray(h))
    /// <summary>This operator samples sub-graph from a csr graph via an
    /// non-uniform probability. The operator is designed for DGL.
    /// 
    /// The operator outputs four sets of NDArrays to represent the sampled results
    /// (the number of NDArrays in each set is the same as the number of seed NDArrays):
    /// 1) a set of 1D NDArrays containing the sampled vertices, 2) a set of CSRNDArrays representing
    /// the sampled edges, 3) a set of 1D NDArrays with the probability that vertices are sampled,
    /// 4) a set of 1D NDArrays indicating the layer where a vertex is sampled.
    /// The first set of 1D NDArrays have a length of max_num_vertices+1. The last element in an NDArray
    /// indicate the acutal number of vertices in a subgraph. The third and fourth set of NDArrays have a length
    /// of max_num_vertices, and the valid number of vertices is the same as the ones in the first set.
    /// 
    /// Example:
    /// 
    ///    .. code:: python
    /// 
    ///   shape = (5, 5)
    ///   prob = mx.nd.array([0.9, 0.8, 0.2, 0.4, 0.1], dtype=np.float32)
    ///   data_np = np.array([1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20], dtype=np.int64)
    ///   indices_np = np.array([1,2,3,4,0,2,3,4,0,1,3,4,0,1,2,4,0,1,2,3], dtype=np.int64)
    ///   indptr_np = np.array([0,4,8,12,16,20], dtype=np.int64)
    ///   a = mx.nd.sparse.csr_matrix((data_np, indices_np, indptr_np), shape=shape)
    ///   seed = mx.nd.array([0,1,2,3,4], dtype=np.int64)
    ///   out = mx.nd.contrib.dgl_csr_neighbor_non_uniform_sample(a, prob, seed, num_args=3, num_hops=1, num_neighbor=2, max_num_vertices=5)
    /// 
    ///   out[0]
    ///   [0 1 2 3 4 5]
    ///   &lt;NDArray 6 @cpu(0)&gt;
    /// 
    ///   out[1].asnumpy()
    ///   array([[ 0,  1,  2,  0,  0],
    ///          [ 5,  0,  6,  0,  0],
    ///          [ 9, 10,  0,  0,  0],
    ///          [13, 14,  0,  0,  0],
    ///          [ 0, 18, 19,  0,  0]])
    /// 
    ///   out[2]
    ///   [0.9 0.8 0.2 0.4 0.1]
    ///   &lt;NDArray 5 @cpu(0)&gt;
    /// 
    ///   out[3]
    ///   [0 0 0 0 0]
    ///   &lt;NDArray 5 @cpu(0)&gt;
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\contrib\dgl_graph.cc:L883</summary>
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="csrMatrix">csr matrix</param>
    /// <param name="probability">probability vector</param>
    /// <param name="seedArrays">seed vertices</param>
    /// <param name="numArgs">Number of input NDArray.</param>
    /// <param name="numHops">Number of hops.</param>
    /// <param name="numNeighbor">Number of neighbor.</param>
    /// <param name="maxNumVertices">Max number of vertices.</param>
    static member ContribDglCsrNeighborNonUniformSample(outputArray : NDArray seq, 
                                                        csrMatrix : NDArray, 
                                                        probability : NDArray, 
                                                        [<ParamArray>] seedArrays : NDArray[], 
                                                        [<Optional; DefaultParameterValue(1L)>] numHops : int64, 
                                                        [<Optional; DefaultParameterValue(2L)>] numNeighbor : int64, 
                                                        [<Optional; DefaultParameterValue(100L)>] maxNumVertices : int64) =
        let creator = AtomicSymbolCreator.FromName "_contrib_dgl_csr_neighbor_non_uniform_sample"
        let names = [|"num_args"; "num_hops"; "num_neighbor"; "max_num_vertices"|]
        let vals = [|string seedArrays.Length; string numHops; string numNeighbor; string maxNumVertices|]
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg csrMatrix)) then csrMatrix.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg probability)) then probability.UnsafeHandle; yield! (seedArrays |> Seq.map (fun x -> x.UnsafeHandle))|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <summary>This operator samples sub-graph from a csr graph via an
    /// non-uniform probability. The operator is designed for DGL.
    /// 
    /// The operator outputs four sets of NDArrays to represent the sampled results
    /// (the number of NDArrays in each set is the same as the number of seed NDArrays):
    /// 1) a set of 1D NDArrays containing the sampled vertices, 2) a set of CSRNDArrays representing
    /// the sampled edges, 3) a set of 1D NDArrays with the probability that vertices are sampled,
    /// 4) a set of 1D NDArrays indicating the layer where a vertex is sampled.
    /// The first set of 1D NDArrays have a length of max_num_vertices+1. The last element in an NDArray
    /// indicate the acutal number of vertices in a subgraph. The third and fourth set of NDArrays have a length
    /// of max_num_vertices, and the valid number of vertices is the same as the ones in the first set.
    /// 
    /// Example:
    /// 
    ///    .. code:: python
    /// 
    ///   shape = (5, 5)
    ///   prob = mx.nd.array([0.9, 0.8, 0.2, 0.4, 0.1], dtype=np.float32)
    ///   data_np = np.array([1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20], dtype=np.int64)
    ///   indices_np = np.array([1,2,3,4,0,2,3,4,0,1,3,4,0,1,2,4,0,1,2,3], dtype=np.int64)
    ///   indptr_np = np.array([0,4,8,12,16,20], dtype=np.int64)
    ///   a = mx.nd.sparse.csr_matrix((data_np, indices_np, indptr_np), shape=shape)
    ///   seed = mx.nd.array([0,1,2,3,4], dtype=np.int64)
    ///   out = mx.nd.contrib.dgl_csr_neighbor_non_uniform_sample(a, prob, seed, num_args=3, num_hops=1, num_neighbor=2, max_num_vertices=5)
    /// 
    ///   out[0]
    ///   [0 1 2 3 4 5]
    ///   &lt;NDArray 6 @cpu(0)&gt;
    /// 
    ///   out[1].asnumpy()
    ///   array([[ 0,  1,  2,  0,  0],
    ///          [ 5,  0,  6,  0,  0],
    ///          [ 9, 10,  0,  0,  0],
    ///          [13, 14,  0,  0,  0],
    ///          [ 0, 18, 19,  0,  0]])
    /// 
    ///   out[2]
    ///   [0.9 0.8 0.2 0.4 0.1]
    ///   &lt;NDArray 5 @cpu(0)&gt;
    /// 
    ///   out[3]
    ///   [0 0 0 0 0]
    ///   &lt;NDArray 5 @cpu(0)&gt;
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\contrib\dgl_graph.cc:L883</summary>
    /// <param name="csrMatrix">csr matrix</param>
    /// <param name="probability">probability vector</param>
    /// <param name="seedArrays">seed vertices</param>
    /// <param name="numHops">Number of hops.</param>
    /// <param name="numNeighbor">Number of neighbor.</param>
    /// <param name="maxNumVertices">Max number of vertices.</param>
    static member ContribDglCsrNeighborNonUniformSample([<Optional>] ?csrMatrix : Symbol, [<Optional>] ?probability : Symbol, [<Optional>] ?seedArrays : Symbol seq, [<Optional>] ?numHops : int64, [<Optional>] ?numNeighbor : int64, [<Optional>] ?maxNumVertices : int64) =
        ContribDglCsrNeighborNonUniformSample(?csrMatrix = csrMatrix, ?probability = probability, ?seedArrays = seedArrays, ?numHops = numHops, ?numNeighbor = numNeighbor, ?maxNumVertices = maxNumVertices)

    /// <summary>This operator constructs an induced subgraph for
    /// a given set of vertices from a graph. The operator accepts multiple
    /// sets of vertices as input. For each set of vertices, it returns a pair
    /// of CSR matrices if return_mapping is True: the first matrix contains edges
    /// with new edge Ids, the second matrix contains edges with the original
    /// edge Ids.
    /// 
    /// Example:
    /// 
    ///    .. code:: python
    /// 
    ///      x=[[1, 0, 0, 2],
    ///        [3, 0, 4, 0],
    ///        [0, 5, 0, 0],
    ///        [0, 6, 7, 0]]
    ///      v = [0, 1, 2]
    ///      dgl_subgraph(x, v, return_mapping=True) =
    ///        [[1, 0, 0],
    ///         [2, 0, 3],
    ///         [0, 4, 0]],
    ///        [[1, 0, 0],
    ///         [3, 0, 4],
    ///         [0, 5, 0]]
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\contrib\dgl_graph.cc:L1140</summary>
    /// <param name="graph">Input graph where we sample vertices.</param>
    /// <param name="data">The input arrays that include data arrays and states.</param>
    /// <param name="numArgs">Number of input arguments, including all symbol inputs.</param>
    /// <param name="returnMapping">Return mapping of vid and eid between the subgraph and the parent graph.</param>
    static member ContribDglSubgraph(graph : NDArray, [<ParamArray>] data : NDArray[], returnMapping : bool) =
        let creator = AtomicSymbolCreator.FromName "_contrib_dgl_subgraph"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg graph)) then graph.UnsafeHandle; yield! (data |> Seq.map (fun x -> x.UnsafeHandle))|]
                                                 [|"num_args"; "return_mapping"|]
                                                 [|string data.Length; string returnMapping|]
        outputs |> Array.map (fun h -> new NDArray(h))
    /// <summary>This operator constructs an induced subgraph for
    /// a given set of vertices from a graph. The operator accepts multiple
    /// sets of vertices as input. For each set of vertices, it returns a pair
    /// of CSR matrices if return_mapping is True: the first matrix contains edges
    /// with new edge Ids, the second matrix contains edges with the original
    /// edge Ids.
    /// 
    /// Example:
    /// 
    ///    .. code:: python
    /// 
    ///      x=[[1, 0, 0, 2],
    ///        [3, 0, 4, 0],
    ///        [0, 5, 0, 0],
    ///        [0, 6, 7, 0]]
    ///      v = [0, 1, 2]
    ///      dgl_subgraph(x, v, return_mapping=True) =
    ///        [[1, 0, 0],
    ///         [2, 0, 3],
    ///         [0, 4, 0]],
    ///        [[1, 0, 0],
    ///         [3, 0, 4],
    ///         [0, 5, 0]]
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\contrib\dgl_graph.cc:L1140</summary>
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="graph">Input graph where we sample vertices.</param>
    /// <param name="data">The input arrays that include data arrays and states.</param>
    /// <param name="numArgs">Number of input arguments, including all symbol inputs.</param>
    /// <param name="returnMapping">Return mapping of vid and eid between the subgraph and the parent graph.</param>
    static member ContribDglSubgraph(outputArray : NDArray seq, graph : NDArray, [<ParamArray>] data : NDArray[], returnMapping : bool) =
        let creator = AtomicSymbolCreator.FromName "_contrib_dgl_subgraph"
        let names = [|"num_args"; "return_mapping"|]
        let vals = [|string data.Length; string returnMapping|]
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg graph)) then graph.UnsafeHandle; yield! (data |> Seq.map (fun x -> x.UnsafeHandle))|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <summary>This operator constructs an induced subgraph for
    /// a given set of vertices from a graph. The operator accepts multiple
    /// sets of vertices as input. For each set of vertices, it returns a pair
    /// of CSR matrices if return_mapping is True: the first matrix contains edges
    /// with new edge Ids, the second matrix contains edges with the original
    /// edge Ids.
    /// 
    /// Example:
    /// 
    ///    .. code:: python
    /// 
    ///      x=[[1, 0, 0, 2],
    ///        [3, 0, 4, 0],
    ///        [0, 5, 0, 0],
    ///        [0, 6, 7, 0]]
    ///      v = [0, 1, 2]
    ///      dgl_subgraph(x, v, return_mapping=True) =
    ///        [[1, 0, 0],
    ///         [2, 0, 3],
    ///         [0, 4, 0]],
    ///        [[1, 0, 0],
    ///         [3, 0, 4],
    ///         [0, 5, 0]]
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\contrib\dgl_graph.cc:L1140</summary>
    /// <param name="graph">Input graph where we sample vertices.</param>
    /// <param name="data">The input arrays that include data arrays and states.</param>
    /// <param name="returnMapping">Return mapping of vid and eid between the subgraph and the parent graph.</param>
    static member ContribDglSubgraph(graph : Symbol, data : Symbol seq, returnMapping : bool) =
        ContribDglSubgraph(graph, data, returnMapping)
    /// <summary>This operator constructs an induced subgraph for
    /// a given set of vertices from a graph. The operator accepts multiple
    /// sets of vertices as input. For each set of vertices, it returns a pair
    /// of CSR matrices if return_mapping is True: the first matrix contains edges
    /// with new edge Ids, the second matrix contains edges with the original
    /// edge Ids.
    /// 
    /// Example:
    /// 
    ///    .. code:: python
    /// 
    ///      x=[[1, 0, 0, 2],
    ///        [3, 0, 4, 0],
    ///        [0, 5, 0, 0],
    ///        [0, 6, 7, 0]]
    ///      v = [0, 1, 2]
    ///      dgl_subgraph(x, v, return_mapping=True) =
    ///        [[1, 0, 0],
    ///         [2, 0, 3],
    ///         [0, 4, 0]],
    ///        [[1, 0, 0],
    ///         [3, 0, 4],
    ///         [0, 5, 0]]
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\contrib\dgl_graph.cc:L1140</summary>
    /// <param name="returnMapping">Return mapping of vid and eid between the subgraph and the parent graph.</param>
    /// <param name="graph">Input graph where we sample vertices.</param>
    /// <param name="data">The input arrays that include data arrays and states.</param>
    static member ContribDglSubgraph(returnMapping : bool, [<Optional>] ?graph : Symbol, [<Optional>] ?data : Symbol seq) =
        ContribDglSubgraph(returnMapping, ?graph = graph, ?data = data)

    /// <summary>This operator implements the edge_id function for a graph
    /// stored in a CSR matrix (the value of the CSR stores the edge Id of the graph).
    /// output[i] = input[u[i], v[i]] if there is an edge between u[i] and v[i]],
    /// otherwise output[i] will be -1. Both u and v should be 1D vectors.
    /// 
    /// Example:
    /// 
    ///    .. code:: python
    /// 
    ///       x = [[ 1, 0, 0 ],
    ///            [ 0, 2, 0 ],
    ///            [ 0, 0, 3 ]]
    ///       u = [ 0, 0, 1, 1, 2, 2 ]
    ///       v = [ 0, 1, 1, 2, 0, 2 ]
    ///       edge_id(x, u, v) = [ 1, -1, 2, -1, -1, 3 ]
    /// 
    /// The storage type of ``edge_id`` output depends on storage types of inputs
    ///   - edge_id(csr, default, default) = default
    ///   - default and rsp inputs are not supported
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\contrib\dgl_graph.cc:L1321</summary>
    /// <param name="data">Input ndarray</param>
    /// <param name="u">u ndarray</param>
    /// <param name="v">v ndarray</param>
    static member ContribEdgeId(data : NDArray, u : NDArray, v : NDArray) =
        let creator = AtomicSymbolCreator.FromName "_contrib_edge_id"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg u)) then u.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg v)) then v.UnsafeHandle|]
                                                 Array.empty
                                                 Array.empty
        (new NDArray(outputs.[0]))
    /// <summary>This operator implements the edge_id function for a graph
    /// stored in a CSR matrix (the value of the CSR stores the edge Id of the graph).
    /// output[i] = input[u[i], v[i]] if there is an edge between u[i] and v[i]],
    /// otherwise output[i] will be -1. Both u and v should be 1D vectors.
    /// 
    /// Example:
    /// 
    ///    .. code:: python
    /// 
    ///       x = [[ 1, 0, 0 ],
    ///            [ 0, 2, 0 ],
    ///            [ 0, 0, 3 ]]
    ///       u = [ 0, 0, 1, 1, 2, 2 ]
    ///       v = [ 0, 1, 1, 2, 0, 2 ]
    ///       edge_id(x, u, v) = [ 1, -1, 2, -1, -1, 3 ]
    /// 
    /// The storage type of ``edge_id`` output depends on storage types of inputs
    ///   - edge_id(csr, default, default) = default
    ///   - default and rsp inputs are not supported
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\contrib\dgl_graph.cc:L1321</summary>
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="data">Input ndarray</param>
    /// <param name="u">u ndarray</param>
    /// <param name="v">v ndarray</param>
    static member ContribEdgeId(outputArray : NDArray seq, data : NDArray, u : NDArray, v : NDArray) =
        let creator = AtomicSymbolCreator.FromName "_contrib_edge_id"
        let names = Array.empty
        let vals = Array.empty
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg u)) then u.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg v)) then v.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <summary>This operator implements the edge_id function for a graph
    /// stored in a CSR matrix (the value of the CSR stores the edge Id of the graph).
    /// output[i] = input[u[i], v[i]] if there is an edge between u[i] and v[i]],
    /// otherwise output[i] will be -1. Both u and v should be 1D vectors.
    /// 
    /// Example:
    /// 
    ///    .. code:: python
    /// 
    ///       x = [[ 1, 0, 0 ],
    ///            [ 0, 2, 0 ],
    ///            [ 0, 0, 3 ]]
    ///       u = [ 0, 0, 1, 1, 2, 2 ]
    ///       v = [ 0, 1, 1, 2, 0, 2 ]
    ///       edge_id(x, u, v) = [ 1, -1, 2, -1, -1, 3 ]
    /// 
    /// The storage type of ``edge_id`` output depends on storage types of inputs
    ///   - edge_id(csr, default, default) = default
    ///   - default and rsp inputs are not supported
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\contrib\dgl_graph.cc:L1321</summary>
    /// <param name="data">Input ndarray</param>
    /// <param name="u">u ndarray</param>
    /// <param name="v">v ndarray</param>
    static member ContribEdgeId([<Optional>] ?data : Symbol, [<Optional>] ?u : Symbol, [<Optional>] ?v : Symbol) =
        ContribEdgeId(?data = data, ?u = u, ?v = v)

    /// <summary>This operator converts a CSR matrix whose values are edge Ids
    /// to an adjacency matrix whose values are ones. The output CSR matrix always has
    /// the data value of float32.
    /// 
    /// Example:
    /// 
    ///    .. code:: python
    /// 
    ///   x = [[ 1, 0, 0 ],
    ///        [ 0, 2, 0 ],
    ///        [ 0, 0, 3 ]]
    ///   dgl_adjacency(x) =
    ///       [[ 1, 0, 0 ],
    ///        [ 0, 1, 0 ],
    ///        [ 0, 0, 1 ]]
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\contrib\dgl_graph.cc:L1393</summary>
    /// <param name="data">Input ndarray</param>
    static member ContribDglAdjacency(data : NDArray) =
        let creator = AtomicSymbolCreator.FromName "_contrib_dgl_adjacency"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle|]
                                                 Array.empty
                                                 Array.empty
        (new NDArray(outputs.[0]))
    /// <summary>This operator converts a CSR matrix whose values are edge Ids
    /// to an adjacency matrix whose values are ones. The output CSR matrix always has
    /// the data value of float32.
    /// 
    /// Example:
    /// 
    ///    .. code:: python
    /// 
    ///   x = [[ 1, 0, 0 ],
    ///        [ 0, 2, 0 ],
    ///        [ 0, 0, 3 ]]
    ///   dgl_adjacency(x) =
    ///       [[ 1, 0, 0 ],
    ///        [ 0, 1, 0 ],
    ///        [ 0, 0, 1 ]]
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\contrib\dgl_graph.cc:L1393</summary>
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="data">Input ndarray</param>
    static member ContribDglAdjacency(outputArray : NDArray seq, data : NDArray) =
        let creator = AtomicSymbolCreator.FromName "_contrib_dgl_adjacency"
        let names = Array.empty
        let vals = Array.empty
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <summary>This operator converts a CSR matrix whose values are edge Ids
    /// to an adjacency matrix whose values are ones. The output CSR matrix always has
    /// the data value of float32.
    /// 
    /// Example:
    /// 
    ///    .. code:: python
    /// 
    ///   x = [[ 1, 0, 0 ],
    ///        [ 0, 2, 0 ],
    ///        [ 0, 0, 3 ]]
    ///   dgl_adjacency(x) =
    ///       [[ 1, 0, 0 ],
    ///        [ 0, 1, 0 ],
    ///        [ 0, 0, 1 ]]
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\contrib\dgl_graph.cc:L1393</summary>
    /// <param name="data">Input ndarray</param>
    static member ContribDglAdjacency([<Optional>] ?data : Symbol) =
        ContribDglAdjacency(?data = data)

    /// <summary>This operator compacts a CSR matrix generated by
    /// dgl_csr_neighbor_uniform_sample and dgl_csr_neighbor_non_uniform_sample.
    /// The CSR matrices generated by these two operators may have many empty
    /// rows at the end and many empty columns. This operator removes these
    /// empty rows and empty columns.
    /// 
    /// Example:
    /// 
    ///    .. code:: python
    /// 
    ///   shape = (5, 5)
    ///   data_np = np.array([1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20], dtype=np.int64)
    ///   indices_np = np.array([1,2,3,4,0,2,3,4,0,1,3,4,0,1,2,4,0,1,2,3], dtype=np.int64)
    ///   indptr_np = np.array([0,4,8,12,16,20], dtype=np.int64)
    ///   a = mx.nd.sparse.csr_matrix((data_np, indices_np, indptr_np), shape=shape)
    ///   seed = mx.nd.array([0,1,2,3,4], dtype=np.int64)
    ///   out = mx.nd.contrib.dgl_csr_neighbor_uniform_sample(a, seed, num_args=2, num_hops=1,
    ///           num_neighbor=2, max_num_vertices=6)
    ///   subg_v = out[0]
    ///   subg = out[1]
    ///   compact = mx.nd.contrib.dgl_graph_compact(subg, subg_v,
    ///           graph_sizes=(subg_v[-1].asnumpy()[0]), return_mapping=False)
    /// 
    ///   compact.asnumpy()
    ///   array([[0, 0, 0, 1, 0],
    ///          [2, 0, 3, 0, 0],
    ///          [0, 4, 0, 0, 5],
    ///          [0, 6, 0, 0, 7],
    ///          [8, 9, 0, 0, 0]])
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\contrib\dgl_graph.cc:L1582</summary>
    /// <param name="graphData">Input graphs and input vertex Ids.</param>
    /// <param name="numArgs">Number of input arguments.</param>
    /// <param name="returnMapping">Return mapping of vid and eid between the subgraph and the parent graph.</param>
    /// <param name="graphSizes">the number of vertices in each graph.</param>
    static member ContribDglGraphCompact([<ParamArray>] graphData : NDArray[], returnMapping : bool, graphSizes : int64 seq) =
        let creator = AtomicSymbolCreator.FromName "_contrib_dgl_graph_compact"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 (graphData |> Array.map (fun x -> x.UnsafeHandle))
                                                 [|"num_args"; "return_mapping"; "graph_sizes"|]
                                                 [|string graphData.Length; string returnMapping; string graphSizes|]
        outputs |> Array.map (fun h -> new NDArray(h))
    /// <summary>This operator compacts a CSR matrix generated by
    /// dgl_csr_neighbor_uniform_sample and dgl_csr_neighbor_non_uniform_sample.
    /// The CSR matrices generated by these two operators may have many empty
    /// rows at the end and many empty columns. This operator removes these
    /// empty rows and empty columns.
    /// 
    /// Example:
    /// 
    ///    .. code:: python
    /// 
    ///   shape = (5, 5)
    ///   data_np = np.array([1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20], dtype=np.int64)
    ///   indices_np = np.array([1,2,3,4,0,2,3,4,0,1,3,4,0,1,2,4,0,1,2,3], dtype=np.int64)
    ///   indptr_np = np.array([0,4,8,12,16,20], dtype=np.int64)
    ///   a = mx.nd.sparse.csr_matrix((data_np, indices_np, indptr_np), shape=shape)
    ///   seed = mx.nd.array([0,1,2,3,4], dtype=np.int64)
    ///   out = mx.nd.contrib.dgl_csr_neighbor_uniform_sample(a, seed, num_args=2, num_hops=1,
    ///           num_neighbor=2, max_num_vertices=6)
    ///   subg_v = out[0]
    ///   subg = out[1]
    ///   compact = mx.nd.contrib.dgl_graph_compact(subg, subg_v,
    ///           graph_sizes=(subg_v[-1].asnumpy()[0]), return_mapping=False)
    /// 
    ///   compact.asnumpy()
    ///   array([[0, 0, 0, 1, 0],
    ///          [2, 0, 3, 0, 0],
    ///          [0, 4, 0, 0, 5],
    ///          [0, 6, 0, 0, 7],
    ///          [8, 9, 0, 0, 0]])
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\contrib\dgl_graph.cc:L1582</summary>
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="graphData">Input graphs and input vertex Ids.</param>
    /// <param name="numArgs">Number of input arguments.</param>
    /// <param name="returnMapping">Return mapping of vid and eid between the subgraph and the parent graph.</param>
    /// <param name="graphSizes">the number of vertices in each graph.</param>
    static member ContribDglGraphCompact(outputArray : NDArray seq, [<ParamArray>] graphData : NDArray[], returnMapping : bool, graphSizes : int64 seq) =
        let creator = AtomicSymbolCreator.FromName "_contrib_dgl_graph_compact"
        let names = [|"num_args"; "return_mapping"; "graph_sizes"|]
        let vals = [|string graphData.Length; string returnMapping; string graphSizes|]
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     (graphData |> Array.map (fun x -> x.UnsafeHandle))
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <summary>This operator compacts a CSR matrix generated by
    /// dgl_csr_neighbor_uniform_sample and dgl_csr_neighbor_non_uniform_sample.
    /// The CSR matrices generated by these two operators may have many empty
    /// rows at the end and many empty columns. This operator removes these
    /// empty rows and empty columns.
    /// 
    /// Example:
    /// 
    ///    .. code:: python
    /// 
    ///   shape = (5, 5)
    ///   data_np = np.array([1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20], dtype=np.int64)
    ///   indices_np = np.array([1,2,3,4,0,2,3,4,0,1,3,4,0,1,2,4,0,1,2,3], dtype=np.int64)
    ///   indptr_np = np.array([0,4,8,12,16,20], dtype=np.int64)
    ///   a = mx.nd.sparse.csr_matrix((data_np, indices_np, indptr_np), shape=shape)
    ///   seed = mx.nd.array([0,1,2,3,4], dtype=np.int64)
    ///   out = mx.nd.contrib.dgl_csr_neighbor_uniform_sample(a, seed, num_args=2, num_hops=1,
    ///           num_neighbor=2, max_num_vertices=6)
    ///   subg_v = out[0]
    ///   subg = out[1]
    ///   compact = mx.nd.contrib.dgl_graph_compact(subg, subg_v,
    ///           graph_sizes=(subg_v[-1].asnumpy()[0]), return_mapping=False)
    /// 
    ///   compact.asnumpy()
    ///   array([[0, 0, 0, 1, 0],
    ///          [2, 0, 3, 0, 0],
    ///          [0, 4, 0, 0, 5],
    ///          [0, 6, 0, 0, 7],
    ///          [8, 9, 0, 0, 0]])
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\contrib\dgl_graph.cc:L1582</summary>
    /// <param name="graphData">Input graphs and input vertex Ids.</param>
    /// <param name="returnMapping">Return mapping of vid and eid between the subgraph and the parent graph.</param>
    /// <param name="graphSizes">the number of vertices in each graph.</param>
    static member ContribDglGraphCompact(graphData : Symbol seq, returnMapping : bool, graphSizes : int64 seq) =
        ContribDglGraphCompact(graphData, returnMapping, graphSizes)
    /// <summary>This operator compacts a CSR matrix generated by
    /// dgl_csr_neighbor_uniform_sample and dgl_csr_neighbor_non_uniform_sample.
    /// The CSR matrices generated by these two operators may have many empty
    /// rows at the end and many empty columns. This operator removes these
    /// empty rows and empty columns.
    /// 
    /// Example:
    /// 
    ///    .. code:: python
    /// 
    ///   shape = (5, 5)
    ///   data_np = np.array([1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20], dtype=np.int64)
    ///   indices_np = np.array([1,2,3,4,0,2,3,4,0,1,3,4,0,1,2,4,0,1,2,3], dtype=np.int64)
    ///   indptr_np = np.array([0,4,8,12,16,20], dtype=np.int64)
    ///   a = mx.nd.sparse.csr_matrix((data_np, indices_np, indptr_np), shape=shape)
    ///   seed = mx.nd.array([0,1,2,3,4], dtype=np.int64)
    ///   out = mx.nd.contrib.dgl_csr_neighbor_uniform_sample(a, seed, num_args=2, num_hops=1,
    ///           num_neighbor=2, max_num_vertices=6)
    ///   subg_v = out[0]
    ///   subg = out[1]
    ///   compact = mx.nd.contrib.dgl_graph_compact(subg, subg_v,
    ///           graph_sizes=(subg_v[-1].asnumpy()[0]), return_mapping=False)
    /// 
    ///   compact.asnumpy()
    ///   array([[0, 0, 0, 1, 0],
    ///          [2, 0, 3, 0, 0],
    ///          [0, 4, 0, 0, 5],
    ///          [0, 6, 0, 0, 7],
    ///          [8, 9, 0, 0, 0]])
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\contrib\dgl_graph.cc:L1582</summary>
    /// <param name="returnMapping">Return mapping of vid and eid between the subgraph and the parent graph.</param>
    /// <param name="graphSizes">the number of vertices in each graph.</param>
    /// <param name="graphData">Input graphs and input vertex Ids.</param>
    static member ContribDglGraphCompact(returnMapping : bool, graphSizes : int64 seq, [<Optional>] ?graphData : Symbol seq) =
        ContribDglGraphCompact(returnMapping, graphSizes, ?graphData = graphData)
    /// <summary>This operator compacts a CSR matrix generated by
    /// dgl_csr_neighbor_uniform_sample and dgl_csr_neighbor_non_uniform_sample.
    /// The CSR matrices generated by these two operators may have many empty
    /// rows at the end and many empty columns. This operator removes these
    /// empty rows and empty columns.
    /// 
    /// Example:
    /// 
    ///    .. code:: python
    /// 
    ///   shape = (5, 5)
    ///   data_np = np.array([1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20], dtype=np.int64)
    ///   indices_np = np.array([1,2,3,4,0,2,3,4,0,1,3,4,0,1,2,4,0,1,2,3], dtype=np.int64)
    ///   indptr_np = np.array([0,4,8,12,16,20], dtype=np.int64)
    ///   a = mx.nd.sparse.csr_matrix((data_np, indices_np, indptr_np), shape=shape)
    ///   seed = mx.nd.array([0,1,2,3,4], dtype=np.int64)
    ///   out = mx.nd.contrib.dgl_csr_neighbor_uniform_sample(a, seed, num_args=2, num_hops=1,
    ///           num_neighbor=2, max_num_vertices=6)
    ///   subg_v = out[0]
    ///   subg = out[1]
    ///   compact = mx.nd.contrib.dgl_graph_compact(subg, subg_v,
    ///           graph_sizes=(subg_v[-1].asnumpy()[0]), return_mapping=False)
    /// 
    ///   compact.asnumpy()
    ///   array([[0, 0, 0, 1, 0],
    ///          [2, 0, 3, 0, 0],
    ///          [0, 4, 0, 0, 5],
    ///          [0, 6, 0, 0, 7],
    ///          [8, 9, 0, 0, 0]])
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\contrib\dgl_graph.cc:L1582</summary>
    /// <param name="returnMapping">Return mapping of vid and eid between the subgraph and the parent graph.</param>
    /// <param name="graphSizes">the number of vertices in each graph.</param>
    /// <param name="graphData">Input graphs and input vertex Ids.</param>
    static member ContribDglGraphCompact(returnMapping : bool, graphSizes : int64 seq, [<ParamArray>] graphData : Symbol[]) =
        ContribDglGraphCompact(returnMapping, graphSizes, graphData)

    /// <summary>This operator implements the gradient multiplier function.
    /// In forward pass it acts as an identity transform. During backpropagation it
    /// multiplies the gradient from the subsequent level by a scalar factor lambda and passes it to
    /// the preceding layer.
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\contrib\gradient_multiplier_op.cc:L78</summary>
    /// <param name="data">The input array.</param>
    /// <param name="scalar">lambda multiplier</param>
    static member ContribGradientmultiplier(data : NDArray, scalar : float) =
        let creator = AtomicSymbolCreator.FromName "_contrib_gradientmultiplier"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle|]
                                                 [|"scalar"|]
                                                 [|string scalar|]
        (new NDArray(outputs.[0]))
    /// <summary>This operator implements the gradient multiplier function.
    /// In forward pass it acts as an identity transform. During backpropagation it
    /// multiplies the gradient from the subsequent level by a scalar factor lambda and passes it to
    /// the preceding layer.
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\contrib\gradient_multiplier_op.cc:L78</summary>
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="data">The input array.</param>
    /// <param name="scalar">lambda multiplier</param>
    static member ContribGradientmultiplier(outputArray : NDArray seq, data : NDArray, scalar : float) =
        let creator = AtomicSymbolCreator.FromName "_contrib_gradientmultiplier"
        let names = [|"scalar"|]
        let vals = [|string scalar|]
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <summary>This operator implements the gradient multiplier function.
    /// In forward pass it acts as an identity transform. During backpropagation it
    /// multiplies the gradient from the subsequent level by a scalar factor lambda and passes it to
    /// the preceding layer.
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\contrib\gradient_multiplier_op.cc:L78</summary>
    /// <param name="data">The input array.</param>
    /// <param name="scalar">lambda multiplier</param>
    static member ContribGradientmultiplier(data : Symbol, scalar : float) =
        ContribGradientmultiplier(data, scalar)
    /// <summary>This operator implements the gradient multiplier function.
    /// In forward pass it acts as an identity transform. During backpropagation it
    /// multiplies the gradient from the subsequent level by a scalar factor lambda and passes it to
    /// the preceding layer.
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\contrib\gradient_multiplier_op.cc:L78</summary>
    /// <param name="scalar">lambda multiplier</param>
    /// <param name="data">The input array.</param>
    static member ContribGradientmultiplier(scalar : float, [<Optional>] ?data : Symbol) =
        ContribGradientmultiplier(scalar, ?data = data)

    /// <param name="data">source input</param>
    /// <param name="scalar">scalar input</param>
    static member ContribBackwardGradientmultiplier(data : NDArray, scalar : float) =
        let creator = AtomicSymbolCreator.FromName "_contrib_backward_gradientmultiplier"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle|]
                                                 [|"scalar"|]
                                                 [|string scalar|]
        (new NDArray(outputs.[0]))
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="data">source input</param>
    /// <param name="scalar">scalar input</param>
    static member ContribBackwardGradientmultiplier(outputArray : NDArray seq, data : NDArray, scalar : float) =
        let creator = AtomicSymbolCreator.FromName "_contrib_backward_gradientmultiplier"
        let names = [|"scalar"|]
        let vals = [|string scalar|]
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <param name="data">source input</param>
    /// <param name="scalar">scalar input</param>
    static member ContribBackwardGradientmultiplier(data : Symbol, scalar : float) =
        ContribBackwardGradientmultiplier(data, scalar)
    /// <param name="scalar">scalar input</param>
    /// <param name="data">source input</param>
    static member ContribBackwardGradientmultiplier(scalar : float, [<Optional>] ?data : Symbol) =
        ContribBackwardGradientmultiplier(scalar, ?data = data)

    /// <summary>Computes the log likelihood of a univariate Hawkes process.
    /// 
    /// The log likelihood is calculated on point process observations represented
    /// as *ragged* matrices for *lags* (interarrival times w.r.t. the previous point),
    /// and *marks* (identifiers for the process ID). Note that each mark is considered independent,
    /// i.e., computes the joint likelihood of a set of Hawkes processes determined by the conditional intensity:
    /// 
    /// .. math::
    /// 
    ///   \lambda_k^*(t) = \lambda_k + \alpha_k \sum_{\{t_i &lt; t, y_i = k\}} \beta_k \exp(-\beta_k (t - t_i))
    /// 
    /// where :math:`\lambda_k` specifies the background intensity ``lda``, :math:`\alpha_k` specifies the *branching ratio* or ``alpha``, and :math:`\beta_k` the delay density parameter ``beta``.
    /// 
    /// ``lags`` and ``marks`` are two NDArrays of shape (N, T) and correspond to the representation of the point process observation, the first dimension corresponds to the batch index, and the second to the sequence. These are &quot;left-aligned&quot; *ragged* matrices (the first index of the second dimension is the beginning of every sequence. The length of each sequence is given by ``valid_length``, of shape (N,) where ``valid_length[i]`` corresponds to the number of valid points in ``lags[i, :]`` and ``marks[i, :]``.
    /// 
    /// ``max_time`` is the length of the observation period of the point process. That is, specifying ``max_time[i] = 5`` computes the likelihood of the i-th sample as observed on the time interval :math:`(0, 5]`. Naturally, the sum of all valid ``lags[i, :valid_length[i]]`` must be less than or equal to 5.
    /// 
    /// The input ``state`` specifies the *memory* of the Hawkes process. Invoking the memoryless property of exponential decays, we compute the *memory* as
    /// 
    /// .. math::
    /// 
    ///     s_k(t) = \sum_{t_i &lt; t} \exp(-\beta_k (t - t_i)).
    /// 
    /// The ``state`` to be provided is :math:`s_k(0)` and carries the added intensity due to past events before the current batch. :math:`s_k(T)` is returned from the function where :math:`T` is ``max_time[T]``.
    /// 
    /// Example::
    /// 
    ///   # define the Hawkes process parameters
    ///   lda = nd.array([1.5, 2.0, 3.0]).tile((N, 1))
    ///   alpha = nd.array([0.2, 0.3, 0.4])  # branching ratios should be &lt; 1
    ///   beta = nd.array([1.0, 2.0, 3.0])
    /// 
    ///   # the &quot;data&quot;, or observations
    ///   ia_times = nd.array([[6, 7, 8, 9], [1, 2, 3, 4], [3, 4, 5, 6], [8, 9, 10, 11]])
    ///   marks = nd.zeros((N, T)).astype(np.int32)
    /// 
    ///   # starting &quot;state&quot; of the process
    ///   states = nd.zeros((N, K))
    /// 
    ///   valid_length = nd.array([1, 2, 3, 4])  # number of valid points in each sequence
    ///   max_time = nd.ones((N,)) * 100.0  # length of the observation period
    /// 
    ///   A = nd.contrib.hawkesll(
    ///       lda, alpha, beta, states, ia_times, marks, valid_length, max_time
    ///   )
    /// 
    /// References:
    /// 
    /// -  Bacry, E., Mastromatteo, I., &amp; Muzy, J. F. (2015).
    ///    Hawkes processes in finance. Market Microstructure and Liquidity
    ///    , 1(01), 1550005.
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\contrib\hawkes_ll.cc:L84</summary>
    /// <param name="lda">Shape (N, K) The intensity for each of the K processes, for each sample</param>
    /// <param name="alpha">Shape (K,) The infectivity factor (branching ratio) for each process</param>
    /// <param name="beta">Shape (K,) The decay parameter for each process</param>
    /// <param name="state">Shape (N, K) the Hawkes state for each process</param>
    /// <param name="lags">Shape (N, T) the interarrival times</param>
    /// <param name="marks">Shape (N, T) the marks (process ids)</param>
    /// <param name="validLength">The number of valid points in the process</param>
    /// <param name="maxTime">the length of the interval where the processes were sampled</param>
    static member ContribHawkesll(lda : NDArray, 
                                  alpha : NDArray, 
                                  beta : NDArray, 
                                  state : NDArray, 
                                  lags : NDArray, 
                                  marks : NDArray, 
                                  validLength : NDArray, 
                                  maxTime : NDArray) =
        let creator = AtomicSymbolCreator.FromName "_contrib_hawkesll"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg lda)) then lda.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg alpha)) then alpha.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg beta)) then beta.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg state)) then state.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg lags)) then lags.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg marks)) then marks.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg validLength)) then validLength.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg maxTime)) then maxTime.UnsafeHandle|]
                                                 Array.empty
                                                 Array.empty
        outputs |> Array.map (fun h -> new NDArray(h))
    /// <summary>Computes the log likelihood of a univariate Hawkes process.
    /// 
    /// The log likelihood is calculated on point process observations represented
    /// as *ragged* matrices for *lags* (interarrival times w.r.t. the previous point),
    /// and *marks* (identifiers for the process ID). Note that each mark is considered independent,
    /// i.e., computes the joint likelihood of a set of Hawkes processes determined by the conditional intensity:
    /// 
    /// .. math::
    /// 
    ///   \lambda_k^*(t) = \lambda_k + \alpha_k \sum_{\{t_i &lt; t, y_i = k\}} \beta_k \exp(-\beta_k (t - t_i))
    /// 
    /// where :math:`\lambda_k` specifies the background intensity ``lda``, :math:`\alpha_k` specifies the *branching ratio* or ``alpha``, and :math:`\beta_k` the delay density parameter ``beta``.
    /// 
    /// ``lags`` and ``marks`` are two NDArrays of shape (N, T) and correspond to the representation of the point process observation, the first dimension corresponds to the batch index, and the second to the sequence. These are &quot;left-aligned&quot; *ragged* matrices (the first index of the second dimension is the beginning of every sequence. The length of each sequence is given by ``valid_length``, of shape (N,) where ``valid_length[i]`` corresponds to the number of valid points in ``lags[i, :]`` and ``marks[i, :]``.
    /// 
    /// ``max_time`` is the length of the observation period of the point process. That is, specifying ``max_time[i] = 5`` computes the likelihood of the i-th sample as observed on the time interval :math:`(0, 5]`. Naturally, the sum of all valid ``lags[i, :valid_length[i]]`` must be less than or equal to 5.
    /// 
    /// The input ``state`` specifies the *memory* of the Hawkes process. Invoking the memoryless property of exponential decays, we compute the *memory* as
    /// 
    /// .. math::
    /// 
    ///     s_k(t) = \sum_{t_i &lt; t} \exp(-\beta_k (t - t_i)).
    /// 
    /// The ``state`` to be provided is :math:`s_k(0)` and carries the added intensity due to past events before the current batch. :math:`s_k(T)` is returned from the function where :math:`T` is ``max_time[T]``.
    /// 
    /// Example::
    /// 
    ///   # define the Hawkes process parameters
    ///   lda = nd.array([1.5, 2.0, 3.0]).tile((N, 1))
    ///   alpha = nd.array([0.2, 0.3, 0.4])  # branching ratios should be &lt; 1
    ///   beta = nd.array([1.0, 2.0, 3.0])
    /// 
    ///   # the &quot;data&quot;, or observations
    ///   ia_times = nd.array([[6, 7, 8, 9], [1, 2, 3, 4], [3, 4, 5, 6], [8, 9, 10, 11]])
    ///   marks = nd.zeros((N, T)).astype(np.int32)
    /// 
    ///   # starting &quot;state&quot; of the process
    ///   states = nd.zeros((N, K))
    /// 
    ///   valid_length = nd.array([1, 2, 3, 4])  # number of valid points in each sequence
    ///   max_time = nd.ones((N,)) * 100.0  # length of the observation period
    /// 
    ///   A = nd.contrib.hawkesll(
    ///       lda, alpha, beta, states, ia_times, marks, valid_length, max_time
    ///   )
    /// 
    /// References:
    /// 
    /// -  Bacry, E., Mastromatteo, I., &amp; Muzy, J. F. (2015).
    ///    Hawkes processes in finance. Market Microstructure and Liquidity
    ///    , 1(01), 1550005.
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\contrib\hawkes_ll.cc:L84</summary>
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="lda">Shape (N, K) The intensity for each of the K processes, for each sample</param>
    /// <param name="alpha">Shape (K,) The infectivity factor (branching ratio) for each process</param>
    /// <param name="beta">Shape (K,) The decay parameter for each process</param>
    /// <param name="state">Shape (N, K) the Hawkes state for each process</param>
    /// <param name="lags">Shape (N, T) the interarrival times</param>
    /// <param name="marks">Shape (N, T) the marks (process ids)</param>
    /// <param name="validLength">The number of valid points in the process</param>
    /// <param name="maxTime">the length of the interval where the processes were sampled</param>
    static member ContribHawkesll(outputArray : NDArray seq, 
                                  lda : NDArray, 
                                  alpha : NDArray, 
                                  beta : NDArray, 
                                  state : NDArray, 
                                  lags : NDArray, 
                                  marks : NDArray, 
                                  validLength : NDArray, 
                                  maxTime : NDArray) =
        let creator = AtomicSymbolCreator.FromName "_contrib_hawkesll"
        let names = Array.empty
        let vals = Array.empty
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg lda)) then lda.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg alpha)) then alpha.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg beta)) then beta.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg state)) then state.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg lags)) then lags.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg marks)) then marks.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg validLength)) then validLength.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg maxTime)) then maxTime.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <summary>Computes the log likelihood of a univariate Hawkes process.
    /// 
    /// The log likelihood is calculated on point process observations represented
    /// as *ragged* matrices for *lags* (interarrival times w.r.t. the previous point),
    /// and *marks* (identifiers for the process ID). Note that each mark is considered independent,
    /// i.e., computes the joint likelihood of a set of Hawkes processes determined by the conditional intensity:
    /// 
    /// .. math::
    /// 
    ///   \lambda_k^*(t) = \lambda_k + \alpha_k \sum_{\{t_i &lt; t, y_i = k\}} \beta_k \exp(-\beta_k (t - t_i))
    /// 
    /// where :math:`\lambda_k` specifies the background intensity ``lda``, :math:`\alpha_k` specifies the *branching ratio* or ``alpha``, and :math:`\beta_k` the delay density parameter ``beta``.
    /// 
    /// ``lags`` and ``marks`` are two NDArrays of shape (N, T) and correspond to the representation of the point process observation, the first dimension corresponds to the batch index, and the second to the sequence. These are &quot;left-aligned&quot; *ragged* matrices (the first index of the second dimension is the beginning of every sequence. The length of each sequence is given by ``valid_length``, of shape (N,) where ``valid_length[i]`` corresponds to the number of valid points in ``lags[i, :]`` and ``marks[i, :]``.
    /// 
    /// ``max_time`` is the length of the observation period of the point process. That is, specifying ``max_time[i] = 5`` computes the likelihood of the i-th sample as observed on the time interval :math:`(0, 5]`. Naturally, the sum of all valid ``lags[i, :valid_length[i]]`` must be less than or equal to 5.
    /// 
    /// The input ``state`` specifies the *memory* of the Hawkes process. Invoking the memoryless property of exponential decays, we compute the *memory* as
    /// 
    /// .. math::
    /// 
    ///     s_k(t) = \sum_{t_i &lt; t} \exp(-\beta_k (t - t_i)).
    /// 
    /// The ``state`` to be provided is :math:`s_k(0)` and carries the added intensity due to past events before the current batch. :math:`s_k(T)` is returned from the function where :math:`T` is ``max_time[T]``.
    /// 
    /// Example::
    /// 
    ///   # define the Hawkes process parameters
    ///   lda = nd.array([1.5, 2.0, 3.0]).tile((N, 1))
    ///   alpha = nd.array([0.2, 0.3, 0.4])  # branching ratios should be &lt; 1
    ///   beta = nd.array([1.0, 2.0, 3.0])
    /// 
    ///   # the &quot;data&quot;, or observations
    ///   ia_times = nd.array([[6, 7, 8, 9], [1, 2, 3, 4], [3, 4, 5, 6], [8, 9, 10, 11]])
    ///   marks = nd.zeros((N, T)).astype(np.int32)
    /// 
    ///   # starting &quot;state&quot; of the process
    ///   states = nd.zeros((N, K))
    /// 
    ///   valid_length = nd.array([1, 2, 3, 4])  # number of valid points in each sequence
    ///   max_time = nd.ones((N,)) * 100.0  # length of the observation period
    /// 
    ///   A = nd.contrib.hawkesll(
    ///       lda, alpha, beta, states, ia_times, marks, valid_length, max_time
    ///   )
    /// 
    /// References:
    /// 
    /// -  Bacry, E., Mastromatteo, I., &amp; Muzy, J. F. (2015).
    ///    Hawkes processes in finance. Market Microstructure and Liquidity
    ///    , 1(01), 1550005.
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\contrib\hawkes_ll.cc:L84</summary>
    /// <param name="lda">Shape (N, K) The intensity for each of the K processes, for each sample</param>
    /// <param name="alpha">Shape (K,) The infectivity factor (branching ratio) for each process</param>
    /// <param name="beta">Shape (K,) The decay parameter for each process</param>
    /// <param name="state">Shape (N, K) the Hawkes state for each process</param>
    /// <param name="lags">Shape (N, T) the interarrival times</param>
    /// <param name="marks">Shape (N, T) the marks (process ids)</param>
    /// <param name="validLength">The number of valid points in the process</param>
    /// <param name="maxTime">the length of the interval where the processes were sampled</param>
    static member ContribHawkesll([<Optional>] ?lda : Symbol, [<Optional>] ?alpha : Symbol, [<Optional>] ?beta : Symbol, [<Optional>] ?state : Symbol, [<Optional>] ?lags : Symbol, [<Optional>] ?marks : Symbol, [<Optional>] ?validLength : Symbol, [<Optional>] ?maxTime : Symbol) =
        ContribHawkesll(?lda = lda, ?alpha = alpha, ?beta = beta, ?state = state, ?lags = lags, ?marks = marks, ?validLength = validLength, ?maxTime = maxTime)

    static member ContribBackwardHawkesllNDArray() =
        let creator = AtomicSymbolCreator.FromName "_contrib_backward_hawkesll"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 Array.empty
                                                 Array.empty
                                                 Array.empty
        outputs |> Array.map (fun h -> new NDArray(h))
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    static member ContribBackwardHawkesll(outputArray : NDArray seq) =
        let creator = AtomicSymbolCreator.FromName "_contrib_backward_hawkesll"
        let names = Array.empty
        let vals = Array.empty
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     Array.empty
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    static member ContribBackwardHawkesll() =
        ContribBackwardHawkesll()

    /// <summary>Returns an array of indexes of the input array.
    /// 
    /// For an input array with shape  :math:`(d_1, d_2, ..., d_n)`, `index_array` returns a
    /// :math:`(d_1, d_2, ..., d_n, n)` array `idx`, where
    /// :math:`idx[i_1, i_2, ..., i_n, :] = [i_1, i_2, ..., i_n]`.
    /// 
    /// Additionally, when the parameter `axes` is specified, `idx` will be a
    /// :math:`(d_1, d_2, ..., d_n, m)` array where `m` is the length of `axes`, and the following
    /// equality will hold: :math:`idx[i_1, i_2, ..., i_n, j] = i_{axes[j]}`.
    /// 
    /// Examples::
    /// 
    ///     x = mx.nd.ones((3, 2))
    /// 
    ///     mx.nd.contrib.index_array(x) = [[[0 0]
    ///                                      [0 1]]
    /// 
    ///                                     [[1 0]
    ///                                      [1 1]]
    /// 
    ///                                     [[2 0]
    ///                                      [2 1]]]
    /// 
    ///     x = mx.nd.ones((3, 2, 2))
    /// 
    ///     mx.nd.contrib.index_array(x, axes=(1, 0)) = [[[[0 0]
    ///                                                    [0 0]]
    /// 
    ///                                                   [[1 0]
    ///                                                    [1 0]]]
    /// 
    /// 
    ///                                                  [[[0 1]
    ///                                                    [0 1]]
    /// 
    ///                                                   [[1 1]
    ///                                                    [1 1]]]
    /// 
    /// 
    ///                                                  [[[0 2]
    ///                                                    [0 2]]
    /// 
    ///                                                   [[1 2]
    ///                                                    [1 2]]]]
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\contrib\index_array.cc:L118</summary>
    /// <param name="data">Input data</param>
    /// <param name="axes">The axes to include in the index array. Supports negative values.</param>
    static member ContribIndexArray(data : NDArray, [<Optional>] ?axes : int seq) =
        let creator = AtomicSymbolCreator.FromName "_contrib_index_array"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle|]
                                                 [|"axes"|]
                                                 [|(match axes with None -> "None" | Some axes -> (axes |> Seq.map string |> String.concat ", " |> sprintf "[%s]"))|]
        (new NDArray(outputs.[0]))
    /// <summary>Returns an array of indexes of the input array.
    /// 
    /// For an input array with shape  :math:`(d_1, d_2, ..., d_n)`, `index_array` returns a
    /// :math:`(d_1, d_2, ..., d_n, n)` array `idx`, where
    /// :math:`idx[i_1, i_2, ..., i_n, :] = [i_1, i_2, ..., i_n]`.
    /// 
    /// Additionally, when the parameter `axes` is specified, `idx` will be a
    /// :math:`(d_1, d_2, ..., d_n, m)` array where `m` is the length of `axes`, and the following
    /// equality will hold: :math:`idx[i_1, i_2, ..., i_n, j] = i_{axes[j]}`.
    /// 
    /// Examples::
    /// 
    ///     x = mx.nd.ones((3, 2))
    /// 
    ///     mx.nd.contrib.index_array(x) = [[[0 0]
    ///                                      [0 1]]
    /// 
    ///                                     [[1 0]
    ///                                      [1 1]]
    /// 
    ///                                     [[2 0]
    ///                                      [2 1]]]
    /// 
    ///     x = mx.nd.ones((3, 2, 2))
    /// 
    ///     mx.nd.contrib.index_array(x, axes=(1, 0)) = [[[[0 0]
    ///                                                    [0 0]]
    /// 
    ///                                                   [[1 0]
    ///                                                    [1 0]]]
    /// 
    /// 
    ///                                                  [[[0 1]
    ///                                                    [0 1]]
    /// 
    ///                                                   [[1 1]
    ///                                                    [1 1]]]
    /// 
    /// 
    ///                                                  [[[0 2]
    ///                                                    [0 2]]
    /// 
    ///                                                   [[1 2]
    ///                                                    [1 2]]]]
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\contrib\index_array.cc:L118</summary>
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="data">Input data</param>
    /// <param name="axes">The axes to include in the index array. Supports negative values.</param>
    static member ContribIndexArray(outputArray : NDArray seq, data : NDArray, [<Optional>] ?axes : int seq) =
        let creator = AtomicSymbolCreator.FromName "_contrib_index_array"
        let names = [|"axes"|]
        let vals = [|(match axes with None -> "None" | Some axes -> (axes |> Seq.map string |> String.concat ", " |> sprintf "[%s]"))|]
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <summary>Returns an array of indexes of the input array.
    /// 
    /// For an input array with shape  :math:`(d_1, d_2, ..., d_n)`, `index_array` returns a
    /// :math:`(d_1, d_2, ..., d_n, n)` array `idx`, where
    /// :math:`idx[i_1, i_2, ..., i_n, :] = [i_1, i_2, ..., i_n]`.
    /// 
    /// Additionally, when the parameter `axes` is specified, `idx` will be a
    /// :math:`(d_1, d_2, ..., d_n, m)` array where `m` is the length of `axes`, and the following
    /// equality will hold: :math:`idx[i_1, i_2, ..., i_n, j] = i_{axes[j]}`.
    /// 
    /// Examples::
    /// 
    ///     x = mx.nd.ones((3, 2))
    /// 
    ///     mx.nd.contrib.index_array(x) = [[[0 0]
    ///                                      [0 1]]
    /// 
    ///                                     [[1 0]
    ///                                      [1 1]]
    /// 
    ///                                     [[2 0]
    ///                                      [2 1]]]
    /// 
    ///     x = mx.nd.ones((3, 2, 2))
    /// 
    ///     mx.nd.contrib.index_array(x, axes=(1, 0)) = [[[[0 0]
    ///                                                    [0 0]]
    /// 
    ///                                                   [[1 0]
    ///                                                    [1 0]]]
    /// 
    /// 
    ///                                                  [[[0 1]
    ///                                                    [0 1]]
    /// 
    ///                                                   [[1 1]
    ///                                                    [1 1]]]
    /// 
    /// 
    ///                                                  [[[0 2]
    ///                                                    [0 2]]
    /// 
    ///                                                   [[1 2]
    ///                                                    [1 2]]]]
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\contrib\index_array.cc:L118</summary>
    /// <param name="data">Input data</param>
    /// <param name="axes">The axes to include in the index array. Supports negative values.</param>
    static member ContribIndexArray([<Optional>] ?data : Symbol, [<Optional>] ?axes : int seq) =
        ContribIndexArray(?data = data, ?axes = axes)

    /// <summary>Copies the elements of a `new_tensor` into the `old_tensor`.
    /// 
    /// This operator copies the elements by selecting the indices in the order given in `index`.
    /// The output will be a new tensor containing the rest elements of old tensor and
    /// the copied elements of new tensor.
    /// For example, if `index[i] == j`, then the `i` th row of `new_tensor` is copied to the
    /// `j` th row of output.
    /// 
    /// The `index` must be a vector and it must have the same size with the `0` th dimension of
    /// `new_tensor`. Also, the `0` th dimension of old_tensor must `&gt;=` the `0` th dimension of
    /// `new_tensor`, or an error will be raised.
    /// 
    /// Examples::
    /// 
    ///     x = mx.nd.zeros((5,3))
    ///     t = mx.nd.array([[1,2,3],[4,5,6],[7,8,9]])
    ///     index = mx.nd.array([0,4,2])
    /// 
    ///     mx.nd.contrib.index_copy(x, index, t)
    /// 
    ///     [[1. 2. 3.]
    ///      [0. 0. 0.]
    ///      [7. 8. 9.]
    ///      [0. 0. 0.]
    ///      [4. 5. 6.]]
    ///     &lt;NDArray 5x3 @cpu(0)&gt;
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\contrib\index_copy.cc:L183</summary>
    /// <param name="oldTensor">Old tensor</param>
    /// <param name="indexVector">Index vector</param>
    /// <param name="newTensor">New tensor to be copied</param>
    static member ContribIndexCopy(oldTensor : NDArray, indexVector : NDArray, newTensor : NDArray) =
        let creator = AtomicSymbolCreator.FromName "_contrib_index_copy"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg oldTensor)) then oldTensor.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg indexVector)) then indexVector.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg newTensor)) then newTensor.UnsafeHandle|]
                                                 Array.empty
                                                 Array.empty
        (new NDArray(outputs.[0]))
    /// <summary>Copies the elements of a `new_tensor` into the `old_tensor`.
    /// 
    /// This operator copies the elements by selecting the indices in the order given in `index`.
    /// The output will be a new tensor containing the rest elements of old tensor and
    /// the copied elements of new tensor.
    /// For example, if `index[i] == j`, then the `i` th row of `new_tensor` is copied to the
    /// `j` th row of output.
    /// 
    /// The `index` must be a vector and it must have the same size with the `0` th dimension of
    /// `new_tensor`. Also, the `0` th dimension of old_tensor must `&gt;=` the `0` th dimension of
    /// `new_tensor`, or an error will be raised.
    /// 
    /// Examples::
    /// 
    ///     x = mx.nd.zeros((5,3))
    ///     t = mx.nd.array([[1,2,3],[4,5,6],[7,8,9]])
    ///     index = mx.nd.array([0,4,2])
    /// 
    ///     mx.nd.contrib.index_copy(x, index, t)
    /// 
    ///     [[1. 2. 3.]
    ///      [0. 0. 0.]
    ///      [7. 8. 9.]
    ///      [0. 0. 0.]
    ///      [4. 5. 6.]]
    ///     &lt;NDArray 5x3 @cpu(0)&gt;
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\contrib\index_copy.cc:L183</summary>
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="oldTensor">Old tensor</param>
    /// <param name="indexVector">Index vector</param>
    /// <param name="newTensor">New tensor to be copied</param>
    static member ContribIndexCopy(outputArray : NDArray seq, oldTensor : NDArray, indexVector : NDArray, newTensor : NDArray) =
        let creator = AtomicSymbolCreator.FromName "_contrib_index_copy"
        let names = Array.empty
        let vals = Array.empty
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg oldTensor)) then oldTensor.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg indexVector)) then indexVector.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg newTensor)) then newTensor.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <summary>Copies the elements of a `new_tensor` into the `old_tensor`.
    /// 
    /// This operator copies the elements by selecting the indices in the order given in `index`.
    /// The output will be a new tensor containing the rest elements of old tensor and
    /// the copied elements of new tensor.
    /// For example, if `index[i] == j`, then the `i` th row of `new_tensor` is copied to the
    /// `j` th row of output.
    /// 
    /// The `index` must be a vector and it must have the same size with the `0` th dimension of
    /// `new_tensor`. Also, the `0` th dimension of old_tensor must `&gt;=` the `0` th dimension of
    /// `new_tensor`, or an error will be raised.
    /// 
    /// Examples::
    /// 
    ///     x = mx.nd.zeros((5,3))
    ///     t = mx.nd.array([[1,2,3],[4,5,6],[7,8,9]])
    ///     index = mx.nd.array([0,4,2])
    /// 
    ///     mx.nd.contrib.index_copy(x, index, t)
    /// 
    ///     [[1. 2. 3.]
    ///      [0. 0. 0.]
    ///      [7. 8. 9.]
    ///      [0. 0. 0.]
    ///      [4. 5. 6.]]
    ///     &lt;NDArray 5x3 @cpu(0)&gt;
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\contrib\index_copy.cc:L183</summary>
    /// <param name="oldTensor">Old tensor</param>
    /// <param name="indexVector">Index vector</param>
    /// <param name="newTensor">New tensor to be copied</param>
    static member ContribIndexCopy([<Optional>] ?oldTensor : Symbol, [<Optional>] ?indexVector : Symbol, [<Optional>] ?newTensor : Symbol) =
        ContribIndexCopy(?oldTensor = oldTensor, ?indexVector = indexVector, ?newTensor = newTensor)

    static member ContribBackwardIndexCopyNDArray() =
        let creator = AtomicSymbolCreator.FromName "_contrib_backward_index_copy"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 Array.empty
                                                 Array.empty
                                                 Array.empty
        (new NDArray(outputs.[0])), (new NDArray(outputs.[1])), (new NDArray(outputs.[2]))
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    static member ContribBackwardIndexCopy(outputArray : NDArray seq) =
        let creator = AtomicSymbolCreator.FromName "_contrib_backward_index_copy"
        let names = Array.empty
        let vals = Array.empty
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     Array.empty
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    static member ContribBackwardIndexCopy() =
        ContribBackwardIndexCopy()

    /// <summary>Computes the Khatri-Rao product of the input matrices.
    /// 
    /// Given a collection of :math:`n` input matrices,
    /// 
    /// .. math::
    ///    A_1 \in \mathbb{R}^{M_1 \times M}, \ldots, A_n \in \mathbb{R}^{M_n \times N},
    /// 
    /// the (column-wise) Khatri-Rao product is defined as the matrix,
    /// 
    /// .. math::
    ///    X = A_1 \otimes \cdots \otimes A_n \in \mathbb{R}^{(M_1 \cdots M_n) \times N},
    /// 
    /// where the :math:`k` th column is equal to the column-wise outer product
    /// :math:`{A_1}_k \otimes \cdots \otimes {A_n}_k` where :math:`{A_i}_k` is the kth
    /// column of the ith matrix.
    /// 
    /// Example::
    /// 
    ///   &gt;&gt;&gt; A = mx.nd.array([[1, -1],
    ///   &gt;&gt;&gt;                  [2, -3]])
    ///   &gt;&gt;&gt; B = mx.nd.array([[1, 4],
    ///   &gt;&gt;&gt;                  [2, 5],
    ///   &gt;&gt;&gt;                  [3, 6]])
    ///   &gt;&gt;&gt; C = mx.nd.khatri_rao(A, B)
    ///   &gt;&gt;&gt; print(C.asnumpy())
    ///   [[  1.  -4.]
    ///    [  2.  -5.]
    ///    [  3.  -6.]
    ///    [  2. -12.]
    ///    [  4. -15.]
    ///    [  6. -18.]]
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\contrib\krprod.cc:L108</summary>
    /// <param name="args">Positional input matrices</param>
    static member KhatriRao([<ParamArray>] args : NDArray[]) =
        let creator = AtomicSymbolCreator.FromName "khatri_rao"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 (args |> Array.map (fun x -> x.UnsafeHandle))
                                                 Array.empty
                                                 Array.empty
        (new NDArray(outputs.[0]))
    /// <summary>Computes the Khatri-Rao product of the input matrices.
    /// 
    /// Given a collection of :math:`n` input matrices,
    /// 
    /// .. math::
    ///    A_1 \in \mathbb{R}^{M_1 \times M}, \ldots, A_n \in \mathbb{R}^{M_n \times N},
    /// 
    /// the (column-wise) Khatri-Rao product is defined as the matrix,
    /// 
    /// .. math::
    ///    X = A_1 \otimes \cdots \otimes A_n \in \mathbb{R}^{(M_1 \cdots M_n) \times N},
    /// 
    /// where the :math:`k` th column is equal to the column-wise outer product
    /// :math:`{A_1}_k \otimes \cdots \otimes {A_n}_k` where :math:`{A_i}_k` is the kth
    /// column of the ith matrix.
    /// 
    /// Example::
    /// 
    ///   &gt;&gt;&gt; A = mx.nd.array([[1, -1],
    ///   &gt;&gt;&gt;                  [2, -3]])
    ///   &gt;&gt;&gt; B = mx.nd.array([[1, 4],
    ///   &gt;&gt;&gt;                  [2, 5],
    ///   &gt;&gt;&gt;                  [3, 6]])
    ///   &gt;&gt;&gt; C = mx.nd.khatri_rao(A, B)
    ///   &gt;&gt;&gt; print(C.asnumpy())
    ///   [[  1.  -4.]
    ///    [  2.  -5.]
    ///    [  3.  -6.]
    ///    [  2. -12.]
    ///    [  4. -15.]
    ///    [  6. -18.]]
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\contrib\krprod.cc:L108</summary>
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="args">Positional input matrices</param>
    static member KhatriRao(outputArray : NDArray seq, [<ParamArray>] args : NDArray[]) =
        let creator = AtomicSymbolCreator.FromName "khatri_rao"
        let names = Array.empty
        let vals = Array.empty
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     (args |> Array.map (fun x -> x.UnsafeHandle))
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <summary>Computes the Khatri-Rao product of the input matrices.
    /// 
    /// Given a collection of :math:`n` input matrices,
    /// 
    /// .. math::
    ///    A_1 \in \mathbb{R}^{M_1 \times M}, \ldots, A_n \in \mathbb{R}^{M_n \times N},
    /// 
    /// the (column-wise) Khatri-Rao product is defined as the matrix,
    /// 
    /// .. math::
    ///    X = A_1 \otimes \cdots \otimes A_n \in \mathbb{R}^{(M_1 \cdots M_n) \times N},
    /// 
    /// where the :math:`k` th column is equal to the column-wise outer product
    /// :math:`{A_1}_k \otimes \cdots \otimes {A_n}_k` where :math:`{A_i}_k` is the kth
    /// column of the ith matrix.
    /// 
    /// Example::
    /// 
    ///   &gt;&gt;&gt; A = mx.nd.array([[1, -1],
    ///   &gt;&gt;&gt;                  [2, -3]])
    ///   &gt;&gt;&gt; B = mx.nd.array([[1, 4],
    ///   &gt;&gt;&gt;                  [2, 5],
    ///   &gt;&gt;&gt;                  [3, 6]])
    ///   &gt;&gt;&gt; C = mx.nd.khatri_rao(A, B)
    ///   &gt;&gt;&gt; print(C.asnumpy())
    ///   [[  1.  -4.]
    ///    [  2.  -5.]
    ///    [  3.  -6.]
    ///    [  2. -12.]
    ///    [  4. -15.]
    ///    [  6. -18.]]
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\contrib\krprod.cc:L108</summary>
    /// <param name="args">Positional input matrices</param>
    static member KhatriRao([<ParamArray>] args : Symbol[]) =
        KhatriRao(args)

    /// <summary>Compute the LARS coefficients of multiple weights and grads from their sums of square&quot;
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\contrib\multi_lars.cc:L37</summary>
    /// <param name="lrs">Learning rates to scale by LARS coefficient</param>
    /// <param name="weightsSumSq">sum of square of weights arrays</param>
    /// <param name="gradsSumSq">sum of square of gradients arrays</param>
    /// <param name="wds">weight decays</param>
    /// <param name="eta">LARS eta</param>
    /// <param name="eps">LARS eps</param>
    /// <param name="rescaleGrad">Gradient rescaling factor</param>
    static member MultiLars(lrs : NDArray, 
                            weightsSumSq : NDArray, 
                            gradsSumSq : NDArray, 
                            wds : NDArray, 
                            eta : float, 
                            eps : float, 
                            [<Optional; DefaultParameterValue(1.0)>] rescaleGrad : float) =
        let creator = AtomicSymbolCreator.FromName "multi_lars"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg lrs)) then lrs.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg weightsSumSq)) then weightsSumSq.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg gradsSumSq)) then gradsSumSq.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg wds)) then wds.UnsafeHandle|]
                                                 [|"eta"; "eps"; "rescale_grad"|]
                                                 [|string eta; string eps; string rescaleGrad|]
        outputs |> Array.map (fun h -> new NDArray(h))
    /// <summary>Compute the LARS coefficients of multiple weights and grads from their sums of square&quot;
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\contrib\multi_lars.cc:L37</summary>
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="lrs">Learning rates to scale by LARS coefficient</param>
    /// <param name="weightsSumSq">sum of square of weights arrays</param>
    /// <param name="gradsSumSq">sum of square of gradients arrays</param>
    /// <param name="wds">weight decays</param>
    /// <param name="eta">LARS eta</param>
    /// <param name="eps">LARS eps</param>
    /// <param name="rescaleGrad">Gradient rescaling factor</param>
    static member MultiLars(outputArray : NDArray seq, 
                            lrs : NDArray, 
                            weightsSumSq : NDArray, 
                            gradsSumSq : NDArray, 
                            wds : NDArray, 
                            eta : float, 
                            eps : float, 
                            [<Optional; DefaultParameterValue(1.0)>] rescaleGrad : float) =
        let creator = AtomicSymbolCreator.FromName "multi_lars"
        let names = [|"eta"; "eps"; "rescale_grad"|]
        let vals = [|string eta; string eps; string rescaleGrad|]
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg lrs)) then lrs.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg weightsSumSq)) then weightsSumSq.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg gradsSumSq)) then gradsSumSq.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg wds)) then wds.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <summary>Compute the LARS coefficients of multiple weights and grads from their sums of square&quot;
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\contrib\multi_lars.cc:L37</summary>
    /// <param name="lrs">Learning rates to scale by LARS coefficient</param>
    /// <param name="weightsSumSq">sum of square of weights arrays</param>
    /// <param name="gradsSumSq">sum of square of gradients arrays</param>
    /// <param name="wds">weight decays</param>
    /// <param name="eta">LARS eta</param>
    /// <param name="eps">LARS eps</param>
    /// <param name="rescaleGrad">Gradient rescaling factor</param>
    static member MultiLars(lrs : Symbol, weightsSumSq : Symbol, gradsSumSq : Symbol, wds : Symbol, eta : float, eps : float, [<Optional>] ?rescaleGrad : float) =
        MultiLars(lrs, weightsSumSq, gradsSumSq, wds, eta, eps, ?rescaleGrad = rescaleGrad)
    /// <summary>Compute the LARS coefficients of multiple weights and grads from their sums of square&quot;
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\contrib\multi_lars.cc:L37</summary>
    /// <param name="eta">LARS eta</param>
    /// <param name="eps">LARS eps</param>
    /// <param name="lrs">Learning rates to scale by LARS coefficient</param>
    /// <param name="weightsSumSq">sum of square of weights arrays</param>
    /// <param name="gradsSumSq">sum of square of gradients arrays</param>
    /// <param name="wds">weight decays</param>
    /// <param name="rescaleGrad">Gradient rescaling factor</param>
    static member MultiLars(eta : float, eps : float, [<Optional>] ?lrs : Symbol, [<Optional>] ?weightsSumSq : Symbol, [<Optional>] ?gradsSumSq : Symbol, [<Optional>] ?wds : Symbol, [<Optional>] ?rescaleGrad : float) =
        MultiLars(eta, eps, ?lrs = lrs, ?weightsSumSq = weightsSumSq, ?gradsSumSq = gradsSumSq, ?wds = wds, ?rescaleGrad = rescaleGrad)

    /// <summary>Compute the sums of squares of multiple arrays
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\contrib\multi_sum_sq.cc:L36</summary>
    /// <param name="data">Arrays</param>
    /// <param name="numArrays">number of input arrays.</param>
    static member MultiSumSq([<ParamArray>] data : NDArray[], numArrays : int) =
        let creator = AtomicSymbolCreator.FromName "multi_sum_sq"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 (data |> Array.map (fun x -> x.UnsafeHandle))
                                                 [|"num_arrays"|]
                                                 [|string numArrays|]
        outputs |> Array.map (fun h -> new NDArray(h))
    /// <summary>Compute the sums of squares of multiple arrays
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\contrib\multi_sum_sq.cc:L36</summary>
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="data">Arrays</param>
    /// <param name="numArrays">number of input arrays.</param>
    static member MultiSumSq(outputArray : NDArray seq, [<ParamArray>] data : NDArray[], numArrays : int) =
        let creator = AtomicSymbolCreator.FromName "multi_sum_sq"
        let names = [|"num_arrays"|]
        let vals = [|string numArrays|]
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     (data |> Array.map (fun x -> x.UnsafeHandle))
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <summary>Compute the sums of squares of multiple arrays
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\contrib\multi_sum_sq.cc:L36</summary>
    /// <param name="data">Arrays</param>
    /// <param name="numArrays">number of input arrays.</param>
    static member MultiSumSq(data : Symbol seq, numArrays : int) =
        MultiSumSq(data, numArrays)
    /// <summary>Compute the sums of squares of multiple arrays
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\contrib\multi_sum_sq.cc:L36</summary>
    /// <param name="numArrays">number of input arrays.</param>
    /// <param name="data">Arrays</param>
    static member MultiSumSq(numArrays : int, [<Optional>] ?data : Symbol seq) =
        MultiSumSq(numArrays, ?data = data)
    /// <summary>Compute the sums of squares of multiple arrays
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\contrib\multi_sum_sq.cc:L36</summary>
    /// <param name="numArrays">number of input arrays.</param>
    /// <param name="data">Arrays</param>
    static member MultiSumSq(numArrays : int, [<ParamArray>] data : Symbol[]) =
        MultiSumSq(numArrays, data)

    /// <summary>Convert multibox detection predictions.</summary>
    /// <param name="clsProb">Class probabilities.</param>
    /// <param name="locPred">Location regression predictions.</param>
    /// <param name="anchor">Multibox prior anchor boxes</param>
    /// <param name="clip">Clip out-of-boundary boxes.</param>
    /// <param name="threshold">Threshold to be a positive prediction.</param>
    /// <param name="backgroundId">Background id.</param>
    /// <param name="nmsThreshold">Non-maximum suppression threshold.</param>
    /// <param name="forceSuppress">Suppress all detections regardless of class_id.</param>
    /// <param name="variances">Variances to be decoded from box regression output.</param>
    /// <param name="nmsTopk">Keep maximum top k detections before nms, -1 for no limit.</param>
    static member ContribMultiBoxDetection(clsProb : NDArray, 
                                           locPred : NDArray, 
                                           anchor : NDArray, 
                                           [<Optional; DefaultParameterValue(true)>] clip : bool, 
                                           [<Optional; DefaultParameterValue(0.00999999978)>] threshold : float, 
                                           [<Optional; DefaultParameterValue(0)>] backgroundId : int, 
                                           [<Optional; DefaultParameterValue(0.5)>] nmsThreshold : float, 
                                           [<Optional; DefaultParameterValue(false)>] forceSuppress : bool, 
                                           [<Optional>] variances : double seq, 
                                           [<Optional; DefaultParameterValue(-1)>] nmsTopk : int) =
        let creator = AtomicSymbolCreator.FromName "_contrib_MultiBoxDetection"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg clsProb)) then clsProb.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg locPred)) then locPred.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg anchor)) then anchor.UnsafeHandle|]
                                                 [|"clip"; "threshold"; "background_id"; "nms_threshold"; "force_suppress"; "variances"; "nms_topk"|]
                                                 [|string clip; string threshold; string backgroundId; string nmsThreshold; string forceSuppress; (if isNull (variances :> obj) then "[0.1,0.1,0.2,0.2]" else string variances); string nmsTopk|]
        outputs |> Array.map (fun h -> new NDArray(h))
    /// <summary>Convert multibox detection predictions.</summary>
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="clsProb">Class probabilities.</param>
    /// <param name="locPred">Location regression predictions.</param>
    /// <param name="anchor">Multibox prior anchor boxes</param>
    /// <param name="clip">Clip out-of-boundary boxes.</param>
    /// <param name="threshold">Threshold to be a positive prediction.</param>
    /// <param name="backgroundId">Background id.</param>
    /// <param name="nmsThreshold">Non-maximum suppression threshold.</param>
    /// <param name="forceSuppress">Suppress all detections regardless of class_id.</param>
    /// <param name="variances">Variances to be decoded from box regression output.</param>
    /// <param name="nmsTopk">Keep maximum top k detections before nms, -1 for no limit.</param>
    static member ContribMultiBoxDetection(outputArray : NDArray seq, 
                                           clsProb : NDArray, 
                                           locPred : NDArray, 
                                           anchor : NDArray, 
                                           [<Optional; DefaultParameterValue(true)>] clip : bool, 
                                           [<Optional; DefaultParameterValue(0.00999999978)>] threshold : float, 
                                           [<Optional; DefaultParameterValue(0)>] backgroundId : int, 
                                           [<Optional; DefaultParameterValue(0.5)>] nmsThreshold : float, 
                                           [<Optional; DefaultParameterValue(false)>] forceSuppress : bool, 
                                           [<Optional>] variances : double seq, 
                                           [<Optional; DefaultParameterValue(-1)>] nmsTopk : int) =
        let creator = AtomicSymbolCreator.FromName "_contrib_MultiBoxDetection"
        let names = [|"clip"; "threshold"; "background_id"; "nms_threshold"; "force_suppress"; "variances"; "nms_topk"|]
        let vals = [|string clip; string threshold; string backgroundId; string nmsThreshold; string forceSuppress; (if isNull (variances :> obj) then "[0.1,0.1,0.2,0.2]" else string variances); string nmsTopk|]
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg clsProb)) then clsProb.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg locPred)) then locPred.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg anchor)) then anchor.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <summary>Convert multibox detection predictions.</summary>
    /// <param name="clsProb">Class probabilities.</param>
    /// <param name="locPred">Location regression predictions.</param>
    /// <param name="anchor">Multibox prior anchor boxes</param>
    /// <param name="clip">Clip out-of-boundary boxes.</param>
    /// <param name="threshold">Threshold to be a positive prediction.</param>
    /// <param name="backgroundId">Background id.</param>
    /// <param name="nmsThreshold">Non-maximum suppression threshold.</param>
    /// <param name="forceSuppress">Suppress all detections regardless of class_id.</param>
    /// <param name="variances">Variances to be decoded from box regression output.</param>
    /// <param name="nmsTopk">Keep maximum top k detections before nms, -1 for no limit.</param>
    static member ContribMultiBoxDetection([<Optional>] ?clsProb : Symbol, [<Optional>] ?locPred : Symbol, [<Optional>] ?anchor : Symbol, [<Optional>] ?clip : bool, [<Optional>] ?threshold : float, [<Optional>] ?backgroundId : int, [<Optional>] ?nmsThreshold : float, [<Optional>] ?forceSuppress : bool, [<Optional>] ?variances : double seq, [<Optional>] ?nmsTopk : int) =
        ContribMultiBoxDetection(?clsProb = clsProb, ?locPred = locPred, ?anchor = anchor, ?clip = clip, ?threshold = threshold, ?backgroundId = backgroundId, ?nmsThreshold = nmsThreshold, ?forceSuppress = forceSuppress, ?variances = variances, ?nmsTopk = nmsTopk)

    /// <summary>Generate prior(anchor) boxes from data, sizes and ratios.</summary>
    /// <param name="data">Input data.</param>
    /// <param name="sizes">List of sizes of generated MultiBoxPriores.</param>
    /// <param name="ratios">List of aspect ratios of generated MultiBoxPriores.</param>
    /// <param name="clip">Whether to clip out-of-boundary boxes.</param>
    /// <param name="steps">Priorbox step across y and x, -1 for auto calculation.</param>
    /// <param name="offsets">Priorbox center offsets, y and x respectively</param>
    static member ContribMultiBoxPrior(data : NDArray, 
                                       [<Optional>] sizes : double seq, 
                                       [<Optional>] ratios : double seq, 
                                       [<Optional; DefaultParameterValue(false)>] clip : bool, 
                                       [<Optional>] steps : double seq, 
                                       [<Optional>] offsets : double seq) =
        let creator = AtomicSymbolCreator.FromName "_contrib_MultiBoxPrior"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle|]
                                                 [|"sizes"; "ratios"; "clip"; "steps"; "offsets"|]
                                                 [|(if isNull (sizes :> obj) then "[1]" else string sizes); (if isNull (ratios :> obj) then "[1]" else string ratios); string clip; (if isNull (steps :> obj) then "[-1,-1]" else string steps); (if isNull (offsets :> obj) then "[0.5,0.5]" else string offsets)|]
        outputs |> Array.map (fun h -> new NDArray(h))
    /// <summary>Generate prior(anchor) boxes from data, sizes and ratios.</summary>
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="data">Input data.</param>
    /// <param name="sizes">List of sizes of generated MultiBoxPriores.</param>
    /// <param name="ratios">List of aspect ratios of generated MultiBoxPriores.</param>
    /// <param name="clip">Whether to clip out-of-boundary boxes.</param>
    /// <param name="steps">Priorbox step across y and x, -1 for auto calculation.</param>
    /// <param name="offsets">Priorbox center offsets, y and x respectively</param>
    static member ContribMultiBoxPrior(outputArray : NDArray seq, 
                                       data : NDArray, 
                                       [<Optional>] sizes : double seq, 
                                       [<Optional>] ratios : double seq, 
                                       [<Optional; DefaultParameterValue(false)>] clip : bool, 
                                       [<Optional>] steps : double seq, 
                                       [<Optional>] offsets : double seq) =
        let creator = AtomicSymbolCreator.FromName "_contrib_MultiBoxPrior"
        let names = [|"sizes"; "ratios"; "clip"; "steps"; "offsets"|]
        let vals = [|(if isNull (sizes :> obj) then "[1]" else string sizes); (if isNull (ratios :> obj) then "[1]" else string ratios); string clip; (if isNull (steps :> obj) then "[-1,-1]" else string steps); (if isNull (offsets :> obj) then "[0.5,0.5]" else string offsets)|]
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <summary>Generate prior(anchor) boxes from data, sizes and ratios.</summary>
    /// <param name="data">Input data.</param>
    /// <param name="sizes">List of sizes of generated MultiBoxPriores.</param>
    /// <param name="ratios">List of aspect ratios of generated MultiBoxPriores.</param>
    /// <param name="clip">Whether to clip out-of-boundary boxes.</param>
    /// <param name="steps">Priorbox step across y and x, -1 for auto calculation.</param>
    /// <param name="offsets">Priorbox center offsets, y and x respectively</param>
    static member ContribMultiBoxPrior([<Optional>] ?data : Symbol, [<Optional>] ?sizes : double seq, [<Optional>] ?ratios : double seq, [<Optional>] ?clip : bool, [<Optional>] ?steps : double seq, [<Optional>] ?offsets : double seq) =
        ContribMultiBoxPrior(?data = data, ?sizes = sizes, ?ratios = ratios, ?clip = clip, ?steps = steps, ?offsets = offsets)

    /// <summary>Compute Multibox training targets</summary>
    /// <param name="anchor">Generated anchor boxes.</param>
    /// <param name="label">Object detection labels.</param>
    /// <param name="clsPred">Class predictions.</param>
    /// <param name="overlapThreshold">Anchor-GT overlap threshold to be regarded as a positive match.</param>
    /// <param name="ignoreLabel">Label for ignored anchors.</param>
    /// <param name="negativeMiningRatio">Max negative to positive samples ratio, use -1 to disable mining</param>
    /// <param name="negativeMiningThresh">Threshold used for negative mining.</param>
    /// <param name="minimumNegativeSamples">Minimum number of negative samples.</param>
    /// <param name="variances">Variances to be encoded in box regression target.</param>
    static member ContribMultiBoxTarget(anchor : NDArray, 
                                        label : NDArray, 
                                        clsPred : NDArray, 
                                        [<Optional; DefaultParameterValue(0.5)>] overlapThreshold : float, 
                                        [<Optional; DefaultParameterValue(-1.0)>] ignoreLabel : float, 
                                        [<Optional; DefaultParameterValue(-1.0)>] negativeMiningRatio : float, 
                                        [<Optional; DefaultParameterValue(0.5)>] negativeMiningThresh : float, 
                                        [<Optional; DefaultParameterValue(0)>] minimumNegativeSamples : int, 
                                        [<Optional>] variances : double seq) =
        let creator = AtomicSymbolCreator.FromName "_contrib_MultiBoxTarget"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg anchor)) then anchor.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg label)) then label.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg clsPred)) then clsPred.UnsafeHandle|]
                                                 [|"overlap_threshold"; "ignore_label"; "negative_mining_ratio"; "negative_mining_thresh"; "minimum_negative_samples"; "variances"|]
                                                 [|string overlapThreshold; string ignoreLabel; string negativeMiningRatio; string negativeMiningThresh; string minimumNegativeSamples; (if isNull (variances :> obj) then "[0.1,0.1,0.2,0.2]" else string variances)|]
        outputs |> Array.map (fun h -> new NDArray(h))
    /// <summary>Compute Multibox training targets</summary>
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="anchor">Generated anchor boxes.</param>
    /// <param name="label">Object detection labels.</param>
    /// <param name="clsPred">Class predictions.</param>
    /// <param name="overlapThreshold">Anchor-GT overlap threshold to be regarded as a positive match.</param>
    /// <param name="ignoreLabel">Label for ignored anchors.</param>
    /// <param name="negativeMiningRatio">Max negative to positive samples ratio, use -1 to disable mining</param>
    /// <param name="negativeMiningThresh">Threshold used for negative mining.</param>
    /// <param name="minimumNegativeSamples">Minimum number of negative samples.</param>
    /// <param name="variances">Variances to be encoded in box regression target.</param>
    static member ContribMultiBoxTarget(outputArray : NDArray seq, 
                                        anchor : NDArray, 
                                        label : NDArray, 
                                        clsPred : NDArray, 
                                        [<Optional; DefaultParameterValue(0.5)>] overlapThreshold : float, 
                                        [<Optional; DefaultParameterValue(-1.0)>] ignoreLabel : float, 
                                        [<Optional; DefaultParameterValue(-1.0)>] negativeMiningRatio : float, 
                                        [<Optional; DefaultParameterValue(0.5)>] negativeMiningThresh : float, 
                                        [<Optional; DefaultParameterValue(0)>] minimumNegativeSamples : int, 
                                        [<Optional>] variances : double seq) =
        let creator = AtomicSymbolCreator.FromName "_contrib_MultiBoxTarget"
        let names = [|"overlap_threshold"; "ignore_label"; "negative_mining_ratio"; "negative_mining_thresh"; "minimum_negative_samples"; "variances"|]
        let vals = [|string overlapThreshold; string ignoreLabel; string negativeMiningRatio; string negativeMiningThresh; string minimumNegativeSamples; (if isNull (variances :> obj) then "[0.1,0.1,0.2,0.2]" else string variances)|]
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg anchor)) then anchor.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg label)) then label.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg clsPred)) then clsPred.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <summary>Compute Multibox training targets</summary>
    /// <param name="anchor">Generated anchor boxes.</param>
    /// <param name="label">Object detection labels.</param>
    /// <param name="clsPred">Class predictions.</param>
    /// <param name="overlapThreshold">Anchor-GT overlap threshold to be regarded as a positive match.</param>
    /// <param name="ignoreLabel">Label for ignored anchors.</param>
    /// <param name="negativeMiningRatio">Max negative to positive samples ratio, use -1 to disable mining</param>
    /// <param name="negativeMiningThresh">Threshold used for negative mining.</param>
    /// <param name="minimumNegativeSamples">Minimum number of negative samples.</param>
    /// <param name="variances">Variances to be encoded in box regression target.</param>
    static member ContribMultiBoxTarget([<Optional>] ?anchor : Symbol, [<Optional>] ?label : Symbol, [<Optional>] ?clsPred : Symbol, [<Optional>] ?overlapThreshold : float, [<Optional>] ?ignoreLabel : float, [<Optional>] ?negativeMiningRatio : float, [<Optional>] ?negativeMiningThresh : float, [<Optional>] ?minimumNegativeSamples : int, [<Optional>] ?variances : double seq) =
        ContribMultiBoxTarget(?anchor = anchor, ?label = label, ?clsPred = clsPred, ?overlapThreshold = overlapThreshold, ?ignoreLabel = ignoreLabel, ?negativeMiningRatio = negativeMiningRatio, ?negativeMiningThresh = negativeMiningThresh, ?minimumNegativeSamples = minimumNegativeSamples, ?variances = variances)

    /// <summary>Number of stored values for a sparse tensor, including explicit zeros.
    /// 
    /// This operator only supports CSR matrix on CPU.
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\contrib\nnz.cc:L177</summary>
    /// <param name="data">Input</param>
    /// <param name="axis">Select between the number of values across the whole matrix, in each column, or in each row.</param>
    static member ContribGetnnz(data : NDArray, [<Optional>] ?axis : int) =
        let creator = AtomicSymbolCreator.FromName "_contrib_getnnz"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle|]
                                                 [|"axis"|]
                                                 [|(match axis with None -> "None" | Some axis -> string axis)|]
        (new NDArray(outputs.[0]))
    /// <summary>Number of stored values for a sparse tensor, including explicit zeros.
    /// 
    /// This operator only supports CSR matrix on CPU.
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\contrib\nnz.cc:L177</summary>
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="data">Input</param>
    /// <param name="axis">Select between the number of values across the whole matrix, in each column, or in each row.</param>
    static member ContribGetnnz(outputArray : NDArray seq, data : NDArray, [<Optional>] ?axis : int) =
        let creator = AtomicSymbolCreator.FromName "_contrib_getnnz"
        let names = [|"axis"|]
        let vals = [|(match axis with None -> "None" | Some axis -> string axis)|]
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <summary>Number of stored values for a sparse tensor, including explicit zeros.
    /// 
    /// This operator only supports CSR matrix on CPU.
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\contrib\nnz.cc:L177</summary>
    /// <param name="data">Input</param>
    /// <param name="axis">Select between the number of values across the whole matrix, in each column, or in each row.</param>
    static member ContribGetnnz([<Optional>] ?data : Symbol, [<Optional>] ?axis : int) =
        ContribGetnnz(?data = data, ?axis = axis)

    /// <summary>Update function for Group AdaGrad optimizer.
    /// 
    /// Referenced from *Adaptive Subgradient Methods for Online Learning and Stochastic Optimization*,
    /// and available at http://www.jmlr.org/papers/volume12/duchi11a/duchi11a.pdf but
    /// uses only a single learning rate for every row of the parameter array.
    /// 
    /// Updates are applied by::
    /// 
    ///     grad = clip(grad * rescale_grad, clip_gradient)
    ///     history += mean(square(grad), axis=1, keepdims=True)
    ///     div = grad / sqrt(history + float_stable_eps)
    ///     weight -= div * lr
    /// 
    /// Weights are updated lazily if the gradient is sparse.
    /// 
    /// Note that non-zero values for the weight decay option are not supported.
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\contrib\optimizer_op.cc:L71</summary>
    /// <param name="weight">Weight</param>
    /// <param name="grad">Gradient</param>
    /// <param name="history">History</param>
    /// <param name="lr">Learning rate</param>
    /// <param name="rescaleGrad">Rescale gradient to grad = rescale_grad*grad.</param>
    /// <param name="clipGradient">Clip gradient to the range of [-clip_gradient, clip_gradient] If clip_gradient &lt;= 0, gradient clipping is turned off. grad = max(min(grad, clip_gradient), -clip_gradient).</param>
    /// <param name="epsilon">Epsilon for numerical stability</param>
    static member ContribGroupAdagradUpdate(weight : NDArray, 
                                            grad : NDArray, 
                                            history : NDArray, 
                                            lr : float, 
                                            [<Optional; DefaultParameterValue(1.0)>] rescaleGrad : float, 
                                            [<Optional; DefaultParameterValue(-1.0)>] clipGradient : float, 
                                            [<Optional; DefaultParameterValue(9.99999975E-06)>] epsilon : float) =
        let creator = AtomicSymbolCreator.FromName "_contrib_group_adagrad_update"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg weight)) then weight.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg grad)) then grad.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg history)) then history.UnsafeHandle|]
                                                 [|"lr"; "rescale_grad"; "clip_gradient"; "epsilon"|]
                                                 [|string lr; string rescaleGrad; string clipGradient; string epsilon|]
        (new NDArray(outputs.[0]))
    /// <summary>Update function for Group AdaGrad optimizer.
    /// 
    /// Referenced from *Adaptive Subgradient Methods for Online Learning and Stochastic Optimization*,
    /// and available at http://www.jmlr.org/papers/volume12/duchi11a/duchi11a.pdf but
    /// uses only a single learning rate for every row of the parameter array.
    /// 
    /// Updates are applied by::
    /// 
    ///     grad = clip(grad * rescale_grad, clip_gradient)
    ///     history += mean(square(grad), axis=1, keepdims=True)
    ///     div = grad / sqrt(history + float_stable_eps)
    ///     weight -= div * lr
    /// 
    /// Weights are updated lazily if the gradient is sparse.
    /// 
    /// Note that non-zero values for the weight decay option are not supported.
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\contrib\optimizer_op.cc:L71</summary>
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="weight">Weight</param>
    /// <param name="grad">Gradient</param>
    /// <param name="history">History</param>
    /// <param name="lr">Learning rate</param>
    /// <param name="rescaleGrad">Rescale gradient to grad = rescale_grad*grad.</param>
    /// <param name="clipGradient">Clip gradient to the range of [-clip_gradient, clip_gradient] If clip_gradient &lt;= 0, gradient clipping is turned off. grad = max(min(grad, clip_gradient), -clip_gradient).</param>
    /// <param name="epsilon">Epsilon for numerical stability</param>
    static member ContribGroupAdagradUpdate(outputArray : NDArray seq, 
                                            weight : NDArray, 
                                            grad : NDArray, 
                                            history : NDArray, 
                                            lr : float, 
                                            [<Optional; DefaultParameterValue(1.0)>] rescaleGrad : float, 
                                            [<Optional; DefaultParameterValue(-1.0)>] clipGradient : float, 
                                            [<Optional; DefaultParameterValue(9.99999975E-06)>] epsilon : float) =
        let creator = AtomicSymbolCreator.FromName "_contrib_group_adagrad_update"
        let names = [|"lr"; "rescale_grad"; "clip_gradient"; "epsilon"|]
        let vals = [|string lr; string rescaleGrad; string clipGradient; string epsilon|]
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg weight)) then weight.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg grad)) then grad.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg history)) then history.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <summary>Update function for Group AdaGrad optimizer.
    /// 
    /// Referenced from *Adaptive Subgradient Methods for Online Learning and Stochastic Optimization*,
    /// and available at http://www.jmlr.org/papers/volume12/duchi11a/duchi11a.pdf but
    /// uses only a single learning rate for every row of the parameter array.
    /// 
    /// Updates are applied by::
    /// 
    ///     grad = clip(grad * rescale_grad, clip_gradient)
    ///     history += mean(square(grad), axis=1, keepdims=True)
    ///     div = grad / sqrt(history + float_stable_eps)
    ///     weight -= div * lr
    /// 
    /// Weights are updated lazily if the gradient is sparse.
    /// 
    /// Note that non-zero values for the weight decay option are not supported.
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\contrib\optimizer_op.cc:L71</summary>
    /// <param name="weight">Weight</param>
    /// <param name="grad">Gradient</param>
    /// <param name="history">History</param>
    /// <param name="lr">Learning rate</param>
    /// <param name="rescaleGrad">Rescale gradient to grad = rescale_grad*grad.</param>
    /// <param name="clipGradient">Clip gradient to the range of [-clip_gradient, clip_gradient] If clip_gradient &lt;= 0, gradient clipping is turned off. grad = max(min(grad, clip_gradient), -clip_gradient).</param>
    /// <param name="epsilon">Epsilon for numerical stability</param>
    static member ContribGroupAdagradUpdate(weight : Symbol, grad : Symbol, history : Symbol, lr : float, [<Optional>] ?rescaleGrad : float, [<Optional>] ?clipGradient : float, [<Optional>] ?epsilon : float) =
        ContribGroupAdagradUpdate(weight, grad, history, lr, ?rescaleGrad = rescaleGrad, ?clipGradient = clipGradient, ?epsilon = epsilon)
    /// <summary>Update function for Group AdaGrad optimizer.
    /// 
    /// Referenced from *Adaptive Subgradient Methods for Online Learning and Stochastic Optimization*,
    /// and available at http://www.jmlr.org/papers/volume12/duchi11a/duchi11a.pdf but
    /// uses only a single learning rate for every row of the parameter array.
    /// 
    /// Updates are applied by::
    /// 
    ///     grad = clip(grad * rescale_grad, clip_gradient)
    ///     history += mean(square(grad), axis=1, keepdims=True)
    ///     div = grad / sqrt(history + float_stable_eps)
    ///     weight -= div * lr
    /// 
    /// Weights are updated lazily if the gradient is sparse.
    /// 
    /// Note that non-zero values for the weight decay option are not supported.
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\contrib\optimizer_op.cc:L71</summary>
    /// <param name="lr">Learning rate</param>
    /// <param name="weight">Weight</param>
    /// <param name="grad">Gradient</param>
    /// <param name="history">History</param>
    /// <param name="rescaleGrad">Rescale gradient to grad = rescale_grad*grad.</param>
    /// <param name="clipGradient">Clip gradient to the range of [-clip_gradient, clip_gradient] If clip_gradient &lt;= 0, gradient clipping is turned off. grad = max(min(grad, clip_gradient), -clip_gradient).</param>
    /// <param name="epsilon">Epsilon for numerical stability</param>
    static member ContribGroupAdagradUpdate(lr : float, [<Optional>] ?weight : Symbol, [<Optional>] ?grad : Symbol, [<Optional>] ?history : Symbol, [<Optional>] ?rescaleGrad : float, [<Optional>] ?clipGradient : float, [<Optional>] ?epsilon : float) =
        ContribGroupAdagradUpdate(lr, ?weight = weight, ?grad = grad, ?history = history, ?rescaleGrad = rescaleGrad, ?clipGradient = clipGradient, ?epsilon = epsilon)

    /// <summary>Update function for Stochastic Gradient Descent (SDG) optimizer.
    /// 
    /// It updates the weights using::
    /// 
    ///  weight = weight - learning_rate * (gradient + wd * weight)
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\contrib\preloaded_multi_sgd.cc:L42</summary>
    /// <param name="data">Weights, gradients, learning rates and weight decays</param>
    /// <param name="rescaleGrad">Rescale gradient to grad = rescale_grad*grad.</param>
    /// <param name="clipGradient">Clip gradient to the range of [-clip_gradient, clip_gradient] If clip_gradient &lt;= 0, gradient clipping is turned off. grad = max(min(grad, clip_gradient), -clip_gradient).</param>
    /// <param name="numWeights">Number of updated weights.</param>
    static member PreloadedMultiSgdUpdate([<ParamArray>] data : NDArray[], [<Optional; DefaultParameterValue(1.0)>] rescaleGrad : float, [<Optional; DefaultParameterValue(-1.0)>] clipGradient : float, [<Optional; DefaultParameterValue(1)>] numWeights : int) =
        let creator = AtomicSymbolCreator.FromName "preloaded_multi_sgd_update"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 (data |> Array.map (fun x -> x.UnsafeHandle))
                                                 [|"rescale_grad"; "clip_gradient"; "num_weights"|]
                                                 [|string rescaleGrad; string clipGradient; string numWeights|]
        outputs |> Array.map (fun h -> new NDArray(h))
    /// <summary>Update function for Stochastic Gradient Descent (SDG) optimizer.
    /// 
    /// It updates the weights using::
    /// 
    ///  weight = weight - learning_rate * (gradient + wd * weight)
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\contrib\preloaded_multi_sgd.cc:L42</summary>
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="data">Weights, gradients, learning rates and weight decays</param>
    /// <param name="rescaleGrad">Rescale gradient to grad = rescale_grad*grad.</param>
    /// <param name="clipGradient">Clip gradient to the range of [-clip_gradient, clip_gradient] If clip_gradient &lt;= 0, gradient clipping is turned off. grad = max(min(grad, clip_gradient), -clip_gradient).</param>
    /// <param name="numWeights">Number of updated weights.</param>
    static member PreloadedMultiSgdUpdate(outputArray : NDArray seq, [<ParamArray>] data : NDArray[], [<Optional; DefaultParameterValue(1.0)>] rescaleGrad : float, [<Optional; DefaultParameterValue(-1.0)>] clipGradient : float, [<Optional; DefaultParameterValue(1)>] numWeights : int) =
        let creator = AtomicSymbolCreator.FromName "preloaded_multi_sgd_update"
        let names = [|"rescale_grad"; "clip_gradient"; "num_weights"|]
        let vals = [|string rescaleGrad; string clipGradient; string numWeights|]
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     (data |> Array.map (fun x -> x.UnsafeHandle))
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <summary>Update function for Stochastic Gradient Descent (SDG) optimizer.
    /// 
    /// It updates the weights using::
    /// 
    ///  weight = weight - learning_rate * (gradient + wd * weight)
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\contrib\preloaded_multi_sgd.cc:L42</summary>
    /// <param name="data">Weights, gradients, learning rates and weight decays</param>
    /// <param name="rescaleGrad">Rescale gradient to grad = rescale_grad*grad.</param>
    /// <param name="clipGradient">Clip gradient to the range of [-clip_gradient, clip_gradient] If clip_gradient &lt;= 0, gradient clipping is turned off. grad = max(min(grad, clip_gradient), -clip_gradient).</param>
    /// <param name="numWeights">Number of updated weights.</param>
    static member PreloadedMultiSgdUpdate([<Optional>] ?data : Symbol seq, [<Optional>] ?rescaleGrad : float, [<Optional>] ?clipGradient : float, [<Optional>] ?numWeights : int) =
        PreloadedMultiSgdUpdate(?data = data, ?rescaleGrad = rescaleGrad, ?clipGradient = clipGradient, ?numWeights = numWeights)

    /// <summary>Momentum update function for Stochastic Gradient Descent (SGD) optimizer.
    /// 
    /// Momentum update has better convergence rates on neural networks. Mathematically it looks
    /// like below:
    /// 
    /// .. math::
    /// 
    ///   v_1 = \alpha * \nabla J(W_0)\\
    ///   v_t = \gamma v_{t-1} - \alpha * \nabla J(W_{t-1})\\
    ///   W_t = W_{t-1} + v_t
    /// 
    /// It updates the weights using::
    /// 
    ///   v = momentum * v - learning_rate * gradient
    ///   weight += v
    /// 
    /// Where the parameter ``momentum`` is the decay rate of momentum estimates at each epoch.
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\contrib\preloaded_multi_sgd.cc:L91</summary>
    /// <param name="data">Weights, gradients, momentum, learning rates and weight decays</param>
    /// <param name="momentum">The decay rate of momentum estimates at each epoch.</param>
    /// <param name="rescaleGrad">Rescale gradient to grad = rescale_grad*grad.</param>
    /// <param name="clipGradient">Clip gradient to the range of [-clip_gradient, clip_gradient] If clip_gradient &lt;= 0, gradient clipping is turned off. grad = max(min(grad, clip_gradient), -clip_gradient).</param>
    /// <param name="numWeights">Number of updated weights.</param>
    static member PreloadedMultiSgdMomUpdate([<ParamArray>] data : NDArray[], 
                                             [<Optional; DefaultParameterValue(0.0)>] momentum : float, 
                                             [<Optional; DefaultParameterValue(1.0)>] rescaleGrad : float, 
                                             [<Optional; DefaultParameterValue(-1.0)>] clipGradient : float, 
                                             [<Optional; DefaultParameterValue(1)>] numWeights : int) =
        let creator = AtomicSymbolCreator.FromName "preloaded_multi_sgd_mom_update"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 (data |> Array.map (fun x -> x.UnsafeHandle))
                                                 [|"momentum"; "rescale_grad"; "clip_gradient"; "num_weights"|]
                                                 [|string momentum; string rescaleGrad; string clipGradient; string numWeights|]
        outputs |> Array.map (fun h -> new NDArray(h))
    /// <summary>Momentum update function for Stochastic Gradient Descent (SGD) optimizer.
    /// 
    /// Momentum update has better convergence rates on neural networks. Mathematically it looks
    /// like below:
    /// 
    /// .. math::
    /// 
    ///   v_1 = \alpha * \nabla J(W_0)\\
    ///   v_t = \gamma v_{t-1} - \alpha * \nabla J(W_{t-1})\\
    ///   W_t = W_{t-1} + v_t
    /// 
    /// It updates the weights using::
    /// 
    ///   v = momentum * v - learning_rate * gradient
    ///   weight += v
    /// 
    /// Where the parameter ``momentum`` is the decay rate of momentum estimates at each epoch.
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\contrib\preloaded_multi_sgd.cc:L91</summary>
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="data">Weights, gradients, momentum, learning rates and weight decays</param>
    /// <param name="momentum">The decay rate of momentum estimates at each epoch.</param>
    /// <param name="rescaleGrad">Rescale gradient to grad = rescale_grad*grad.</param>
    /// <param name="clipGradient">Clip gradient to the range of [-clip_gradient, clip_gradient] If clip_gradient &lt;= 0, gradient clipping is turned off. grad = max(min(grad, clip_gradient), -clip_gradient).</param>
    /// <param name="numWeights">Number of updated weights.</param>
    static member PreloadedMultiSgdMomUpdate(outputArray : NDArray seq, 
                                             [<ParamArray>] data : NDArray[], 
                                             [<Optional; DefaultParameterValue(0.0)>] momentum : float, 
                                             [<Optional; DefaultParameterValue(1.0)>] rescaleGrad : float, 
                                             [<Optional; DefaultParameterValue(-1.0)>] clipGradient : float, 
                                             [<Optional; DefaultParameterValue(1)>] numWeights : int) =
        let creator = AtomicSymbolCreator.FromName "preloaded_multi_sgd_mom_update"
        let names = [|"momentum"; "rescale_grad"; "clip_gradient"; "num_weights"|]
        let vals = [|string momentum; string rescaleGrad; string clipGradient; string numWeights|]
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     (data |> Array.map (fun x -> x.UnsafeHandle))
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <summary>Momentum update function for Stochastic Gradient Descent (SGD) optimizer.
    /// 
    /// Momentum update has better convergence rates on neural networks. Mathematically it looks
    /// like below:
    /// 
    /// .. math::
    /// 
    ///   v_1 = \alpha * \nabla J(W_0)\\
    ///   v_t = \gamma v_{t-1} - \alpha * \nabla J(W_{t-1})\\
    ///   W_t = W_{t-1} + v_t
    /// 
    /// It updates the weights using::
    /// 
    ///   v = momentum * v - learning_rate * gradient
    ///   weight += v
    /// 
    /// Where the parameter ``momentum`` is the decay rate of momentum estimates at each epoch.
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\contrib\preloaded_multi_sgd.cc:L91</summary>
    /// <param name="data">Weights, gradients, momentum, learning rates and weight decays</param>
    /// <param name="momentum">The decay rate of momentum estimates at each epoch.</param>
    /// <param name="rescaleGrad">Rescale gradient to grad = rescale_grad*grad.</param>
    /// <param name="clipGradient">Clip gradient to the range of [-clip_gradient, clip_gradient] If clip_gradient &lt;= 0, gradient clipping is turned off. grad = max(min(grad, clip_gradient), -clip_gradient).</param>
    /// <param name="numWeights">Number of updated weights.</param>
    static member PreloadedMultiSgdMomUpdate([<Optional>] ?data : Symbol seq, [<Optional>] ?momentum : float, [<Optional>] ?rescaleGrad : float, [<Optional>] ?clipGradient : float, [<Optional>] ?numWeights : int) =
        PreloadedMultiSgdMomUpdate(?data = data, ?momentum = momentum, ?rescaleGrad = rescaleGrad, ?clipGradient = clipGradient, ?numWeights = numWeights)

    /// <summary>Update function for multi-precision Stochastic Gradient Descent (SDG) optimizer.
    /// 
    /// It updates the weights using::
    /// 
    ///  weight = weight - learning_rate * (gradient + wd * weight)
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\contrib\preloaded_multi_sgd.cc:L140</summary>
    /// <param name="data">Weights, gradients, learning rates and weight decays</param>
    /// <param name="rescaleGrad">Rescale gradient to grad = rescale_grad*grad.</param>
    /// <param name="clipGradient">Clip gradient to the range of [-clip_gradient, clip_gradient] If clip_gradient &lt;= 0, gradient clipping is turned off. grad = max(min(grad, clip_gradient), -clip_gradient).</param>
    /// <param name="numWeights">Number of updated weights.</param>
    static member PreloadedMultiMpSgdUpdate([<ParamArray>] data : NDArray[], [<Optional; DefaultParameterValue(1.0)>] rescaleGrad : float, [<Optional; DefaultParameterValue(-1.0)>] clipGradient : float, [<Optional; DefaultParameterValue(1)>] numWeights : int) =
        let creator = AtomicSymbolCreator.FromName "preloaded_multi_mp_sgd_update"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 (data |> Array.map (fun x -> x.UnsafeHandle))
                                                 [|"rescale_grad"; "clip_gradient"; "num_weights"|]
                                                 [|string rescaleGrad; string clipGradient; string numWeights|]
        outputs |> Array.map (fun h -> new NDArray(h))
    /// <summary>Update function for multi-precision Stochastic Gradient Descent (SDG) optimizer.
    /// 
    /// It updates the weights using::
    /// 
    ///  weight = weight - learning_rate * (gradient + wd * weight)
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\contrib\preloaded_multi_sgd.cc:L140</summary>
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="data">Weights, gradients, learning rates and weight decays</param>
    /// <param name="rescaleGrad">Rescale gradient to grad = rescale_grad*grad.</param>
    /// <param name="clipGradient">Clip gradient to the range of [-clip_gradient, clip_gradient] If clip_gradient &lt;= 0, gradient clipping is turned off. grad = max(min(grad, clip_gradient), -clip_gradient).</param>
    /// <param name="numWeights">Number of updated weights.</param>
    static member PreloadedMultiMpSgdUpdate(outputArray : NDArray seq, [<ParamArray>] data : NDArray[], [<Optional; DefaultParameterValue(1.0)>] rescaleGrad : float, [<Optional; DefaultParameterValue(-1.0)>] clipGradient : float, [<Optional; DefaultParameterValue(1)>] numWeights : int) =
        let creator = AtomicSymbolCreator.FromName "preloaded_multi_mp_sgd_update"
        let names = [|"rescale_grad"; "clip_gradient"; "num_weights"|]
        let vals = [|string rescaleGrad; string clipGradient; string numWeights|]
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     (data |> Array.map (fun x -> x.UnsafeHandle))
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <summary>Update function for multi-precision Stochastic Gradient Descent (SDG) optimizer.
    /// 
    /// It updates the weights using::
    /// 
    ///  weight = weight - learning_rate * (gradient + wd * weight)
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\contrib\preloaded_multi_sgd.cc:L140</summary>
    /// <param name="data">Weights, gradients, learning rates and weight decays</param>
    /// <param name="rescaleGrad">Rescale gradient to grad = rescale_grad*grad.</param>
    /// <param name="clipGradient">Clip gradient to the range of [-clip_gradient, clip_gradient] If clip_gradient &lt;= 0, gradient clipping is turned off. grad = max(min(grad, clip_gradient), -clip_gradient).</param>
    /// <param name="numWeights">Number of updated weights.</param>
    static member PreloadedMultiMpSgdUpdate([<Optional>] ?data : Symbol seq, [<Optional>] ?rescaleGrad : float, [<Optional>] ?clipGradient : float, [<Optional>] ?numWeights : int) =
        PreloadedMultiMpSgdUpdate(?data = data, ?rescaleGrad = rescaleGrad, ?clipGradient = clipGradient, ?numWeights = numWeights)

    /// <summary>Momentum update function for multi-precision Stochastic Gradient Descent (SGD) optimizer.
    /// 
    /// Momentum update has better convergence rates on neural networks. Mathematically it looks
    /// like below:
    /// 
    /// .. math::
    /// 
    ///   v_1 = \alpha * \nabla J(W_0)\\
    ///   v_t = \gamma v_{t-1} - \alpha * \nabla J(W_{t-1})\\
    ///   W_t = W_{t-1} + v_t
    /// 
    /// It updates the weights using::
    /// 
    ///   v = momentum * v - learning_rate * gradient
    ///   weight += v
    /// 
    /// Where the parameter ``momentum`` is the decay rate of momentum estimates at each epoch.
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\contrib\preloaded_multi_sgd.cc:L200</summary>
    /// <param name="data">Weights, gradients, momentums, learning rates and weight decays</param>
    /// <param name="momentum">The decay rate of momentum estimates at each epoch.</param>
    /// <param name="rescaleGrad">Rescale gradient to grad = rescale_grad*grad.</param>
    /// <param name="clipGradient">Clip gradient to the range of [-clip_gradient, clip_gradient] If clip_gradient &lt;= 0, gradient clipping is turned off. grad = max(min(grad, clip_gradient), -clip_gradient).</param>
    /// <param name="numWeights">Number of updated weights.</param>
    static member PreloadedMultiMpSgdMomUpdate([<ParamArray>] data : NDArray[], 
                                               [<Optional; DefaultParameterValue(0.0)>] momentum : float, 
                                               [<Optional; DefaultParameterValue(1.0)>] rescaleGrad : float, 
                                               [<Optional; DefaultParameterValue(-1.0)>] clipGradient : float, 
                                               [<Optional; DefaultParameterValue(1)>] numWeights : int) =
        let creator = AtomicSymbolCreator.FromName "preloaded_multi_mp_sgd_mom_update"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 (data |> Array.map (fun x -> x.UnsafeHandle))
                                                 [|"momentum"; "rescale_grad"; "clip_gradient"; "num_weights"|]
                                                 [|string momentum; string rescaleGrad; string clipGradient; string numWeights|]
        outputs |> Array.map (fun h -> new NDArray(h))
    /// <summary>Momentum update function for multi-precision Stochastic Gradient Descent (SGD) optimizer.
    /// 
    /// Momentum update has better convergence rates on neural networks. Mathematically it looks
    /// like below:
    /// 
    /// .. math::
    /// 
    ///   v_1 = \alpha * \nabla J(W_0)\\
    ///   v_t = \gamma v_{t-1} - \alpha * \nabla J(W_{t-1})\\
    ///   W_t = W_{t-1} + v_t
    /// 
    /// It updates the weights using::
    /// 
    ///   v = momentum * v - learning_rate * gradient
    ///   weight += v
    /// 
    /// Where the parameter ``momentum`` is the decay rate of momentum estimates at each epoch.
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\contrib\preloaded_multi_sgd.cc:L200</summary>
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="data">Weights, gradients, momentums, learning rates and weight decays</param>
    /// <param name="momentum">The decay rate of momentum estimates at each epoch.</param>
    /// <param name="rescaleGrad">Rescale gradient to grad = rescale_grad*grad.</param>
    /// <param name="clipGradient">Clip gradient to the range of [-clip_gradient, clip_gradient] If clip_gradient &lt;= 0, gradient clipping is turned off. grad = max(min(grad, clip_gradient), -clip_gradient).</param>
    /// <param name="numWeights">Number of updated weights.</param>
    static member PreloadedMultiMpSgdMomUpdate(outputArray : NDArray seq, 
                                               [<ParamArray>] data : NDArray[], 
                                               [<Optional; DefaultParameterValue(0.0)>] momentum : float, 
                                               [<Optional; DefaultParameterValue(1.0)>] rescaleGrad : float, 
                                               [<Optional; DefaultParameterValue(-1.0)>] clipGradient : float, 
                                               [<Optional; DefaultParameterValue(1)>] numWeights : int) =
        let creator = AtomicSymbolCreator.FromName "preloaded_multi_mp_sgd_mom_update"
        let names = [|"momentum"; "rescale_grad"; "clip_gradient"; "num_weights"|]
        let vals = [|string momentum; string rescaleGrad; string clipGradient; string numWeights|]
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     (data |> Array.map (fun x -> x.UnsafeHandle))
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <summary>Momentum update function for multi-precision Stochastic Gradient Descent (SGD) optimizer.
    /// 
    /// Momentum update has better convergence rates on neural networks. Mathematically it looks
    /// like below:
    /// 
    /// .. math::
    /// 
    ///   v_1 = \alpha * \nabla J(W_0)\\
    ///   v_t = \gamma v_{t-1} - \alpha * \nabla J(W_{t-1})\\
    ///   W_t = W_{t-1} + v_t
    /// 
    /// It updates the weights using::
    /// 
    ///   v = momentum * v - learning_rate * gradient
    ///   weight += v
    /// 
    /// Where the parameter ``momentum`` is the decay rate of momentum estimates at each epoch.
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\contrib\preloaded_multi_sgd.cc:L200</summary>
    /// <param name="data">Weights, gradients, momentums, learning rates and weight decays</param>
    /// <param name="momentum">The decay rate of momentum estimates at each epoch.</param>
    /// <param name="rescaleGrad">Rescale gradient to grad = rescale_grad*grad.</param>
    /// <param name="clipGradient">Clip gradient to the range of [-clip_gradient, clip_gradient] If clip_gradient &lt;= 0, gradient clipping is turned off. grad = max(min(grad, clip_gradient), -clip_gradient).</param>
    /// <param name="numWeights">Number of updated weights.</param>
    static member PreloadedMultiMpSgdMomUpdate([<Optional>] ?data : Symbol seq, [<Optional>] ?momentum : float, [<Optional>] ?rescaleGrad : float, [<Optional>] ?clipGradient : float, [<Optional>] ?numWeights : int) =
        PreloadedMultiMpSgdMomUpdate(?data = data, ?momentum = momentum, ?rescaleGrad = rescaleGrad, ?clipGradient = clipGradient, ?numWeights = numWeights)

    /// <summary>This operators implements the quadratic function.
    /// 
    /// .. math::
    ///     f(x) = ax^2+bx+c
    /// 
    /// where :math:`x` is an input tensor and all operations
    /// in the function are element-wise.
    /// 
    /// Example::
    /// 
    ///   x = [[1, 2], [3, 4]]
    ///   y = quadratic(data=x, a=1, b=2, c=3)
    ///   y = [[6, 11], [18, 27]]
    /// 
    /// The storage type of ``quadratic`` output depends on storage types of inputs
    ///   - quadratic(csr, a, b, 0) = csr
    ///   - quadratic(default, a, b, c) = default
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\contrib\quadratic_op.cc:L50</summary>
    /// <param name="data">Input ndarray</param>
    /// <param name="a">Coefficient of the quadratic term in the quadratic function.</param>
    /// <param name="b">Coefficient of the linear term in the quadratic function.</param>
    /// <param name="c">Constant term in the quadratic function.</param>
    static member ContribQuadratic(data : NDArray, [<Optional; DefaultParameterValue(0.0)>] a : float, [<Optional; DefaultParameterValue(0.0)>] b : float, [<Optional; DefaultParameterValue(0.0)>] c : float) =
        let creator = AtomicSymbolCreator.FromName "_contrib_quadratic"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle|]
                                                 [|"a"; "b"; "c"|]
                                                 [|string a; string b; string c|]
        (new NDArray(outputs.[0]))
    /// <summary>This operators implements the quadratic function.
    /// 
    /// .. math::
    ///     f(x) = ax^2+bx+c
    /// 
    /// where :math:`x` is an input tensor and all operations
    /// in the function are element-wise.
    /// 
    /// Example::
    /// 
    ///   x = [[1, 2], [3, 4]]
    ///   y = quadratic(data=x, a=1, b=2, c=3)
    ///   y = [[6, 11], [18, 27]]
    /// 
    /// The storage type of ``quadratic`` output depends on storage types of inputs
    ///   - quadratic(csr, a, b, 0) = csr
    ///   - quadratic(default, a, b, c) = default
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\contrib\quadratic_op.cc:L50</summary>
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="data">Input ndarray</param>
    /// <param name="a">Coefficient of the quadratic term in the quadratic function.</param>
    /// <param name="b">Coefficient of the linear term in the quadratic function.</param>
    /// <param name="c">Constant term in the quadratic function.</param>
    static member ContribQuadratic(outputArray : NDArray seq, data : NDArray, [<Optional; DefaultParameterValue(0.0)>] a : float, [<Optional; DefaultParameterValue(0.0)>] b : float, [<Optional; DefaultParameterValue(0.0)>] c : float) =
        let creator = AtomicSymbolCreator.FromName "_contrib_quadratic"
        let names = [|"a"; "b"; "c"|]
        let vals = [|string a; string b; string c|]
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <summary>This operators implements the quadratic function.
    /// 
    /// .. math::
    ///     f(x) = ax^2+bx+c
    /// 
    /// where :math:`x` is an input tensor and all operations
    /// in the function are element-wise.
    /// 
    /// Example::
    /// 
    ///   x = [[1, 2], [3, 4]]
    ///   y = quadratic(data=x, a=1, b=2, c=3)
    ///   y = [[6, 11], [18, 27]]
    /// 
    /// The storage type of ``quadratic`` output depends on storage types of inputs
    ///   - quadratic(csr, a, b, 0) = csr
    ///   - quadratic(default, a, b, c) = default
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\contrib\quadratic_op.cc:L50</summary>
    /// <param name="data">Input ndarray</param>
    /// <param name="a">Coefficient of the quadratic term in the quadratic function.</param>
    /// <param name="b">Coefficient of the linear term in the quadratic function.</param>
    /// <param name="c">Constant term in the quadratic function.</param>
    static member ContribQuadratic([<Optional>] ?data : Symbol, [<Optional>] ?a : float, [<Optional>] ?b : float, [<Optional>] ?c : float) =
        ContribQuadratic(?data = data, ?a = a, ?b = b, ?c = c)

    static member ContribBackwardQuadraticNDArray() =
        let creator = AtomicSymbolCreator.FromName "_contrib_backward_quadratic"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 Array.empty
                                                 Array.empty
                                                 Array.empty
        (new NDArray(outputs.[0]))
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    static member ContribBackwardQuadratic(outputArray : NDArray seq) =
        let creator = AtomicSymbolCreator.FromName "_contrib_backward_quadratic"
        let names = Array.empty
        let vals = Array.empty
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     Array.empty
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    static member ContribBackwardQuadratic() =
        ContribBackwardQuadratic()

    /// <summary>Set to zero multiple arrays
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\contrib\reset_arrays.cc:L36</summary>
    /// <param name="data">Arrays</param>
    /// <param name="numArrays">number of input arrays.</param>
    static member ResetArrays([<ParamArray>] data : NDArray[], numArrays : int) =
        let creator = AtomicSymbolCreator.FromName "reset_arrays"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 (data |> Array.map (fun x -> x.UnsafeHandle))
                                                 [|"num_arrays"|]
                                                 [|string numArrays|]
        outputs |> Array.map (fun h -> new NDArray(h))
    /// <summary>Set to zero multiple arrays
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\contrib\reset_arrays.cc:L36</summary>
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="data">Arrays</param>
    /// <param name="numArrays">number of input arrays.</param>
    static member ResetArrays(outputArray : NDArray seq, [<ParamArray>] data : NDArray[], numArrays : int) =
        let creator = AtomicSymbolCreator.FromName "reset_arrays"
        let names = [|"num_arrays"|]
        let vals = [|string numArrays|]
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     (data |> Array.map (fun x -> x.UnsafeHandle))
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <summary>Set to zero multiple arrays
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\contrib\reset_arrays.cc:L36</summary>
    /// <param name="data">Arrays</param>
    /// <param name="numArrays">number of input arrays.</param>
    static member ResetArrays(data : Symbol seq, numArrays : int) =
        ResetArrays(data, numArrays)
    /// <summary>Set to zero multiple arrays
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\contrib\reset_arrays.cc:L36</summary>
    /// <param name="numArrays">number of input arrays.</param>
    /// <param name="data">Arrays</param>
    static member ResetArrays(numArrays : int, [<Optional>] ?data : Symbol seq) =
        ResetArrays(numArrays, ?data = data)
    /// <summary>Set to zero multiple arrays
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\contrib\reset_arrays.cc:L36</summary>
    /// <param name="numArrays">number of input arrays.</param>
    /// <param name="data">Arrays</param>
    static member ResetArrays(numArrays : int, [<ParamArray>] data : Symbol[]) =
        ResetArrays(numArrays, data)

    /// <summary>
    /// This operator takes a 4D feature map as an input array and region proposals as `rois`,
    /// then align the feature map over sub-regions of input and produces a fixed-sized output array.
    /// This operator is typically used in Faster R-CNN &amp; Mask R-CNN networks. If roi batchid is less 
    /// than 0, it will be ignored, and the corresponding output will be set to 0.
    /// 
    /// Different from ROI pooling, ROI Align removes the harsh quantization, properly aligning
    /// the extracted features with the input. RoIAlign computes the value of each sampling point
    /// by bilinear interpolation from the nearby grid points on the feature map. No quantization is
    /// performed on any coordinates involved in the RoI, its bins, or the sampling points.
    /// Bilinear interpolation is used to compute the exact values of the
    /// input features at four regularly sampled locations in each RoI bin.
    /// Then the feature map can be aggregated by avgpooling.
    /// 
    /// 
    /// References
    /// ----------
    /// 
    /// He, Kaiming, et al. &quot;Mask R-CNN.&quot; ICCV, 2017
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\contrib\roi_align.cc:L544</summary>
    /// <param name="data">Input data to the pooling operator, a 4D Feature maps</param>
    /// <param name="rois">Bounding box coordinates, a 2D array, if batchid is less than 0, it will be ignored.</param>
    /// <param name="pooledSize">ROI Align output roi feature map height and width: (h, w)</param>
    /// <param name="spatialScale">Ratio of input feature map height (or w) to raw image height (or w). Equals the reciprocal of total stride in convolutional layers</param>
    /// <param name="sampleRatio">Optional sampling ratio of ROI align, using adaptive size by default.</param>
    /// <param name="positionSensitive">Whether to perform position-sensitive RoI pooling. PSRoIPooling is first proposaled by R-FCN and it can reduce the input channels by ph*pw times, where (ph, pw) is the pooled_size</param>
    static member ContribROIAlign(data : NDArray, 
                                  rois : NDArray, 
                                  pooledSize : int seq, 
                                  spatialScale : float, 
                                  [<Optional; DefaultParameterValue(-1)>] sampleRatio : int, 
                                  [<Optional; DefaultParameterValue(false)>] positionSensitive : bool) =
        let creator = AtomicSymbolCreator.FromName "_contrib_ROIAlign"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg rois)) then rois.UnsafeHandle|]
                                                 [|"pooled_size"; "spatial_scale"; "sample_ratio"; "position_sensitive"|]
                                                 [|(pooledSize |> Seq.map string |> String.concat ", " |> sprintf "[%s]"); string spatialScale; string sampleRatio; string positionSensitive|]
        (new NDArray(outputs.[0]))
    /// <summary>
    /// This operator takes a 4D feature map as an input array and region proposals as `rois`,
    /// then align the feature map over sub-regions of input and produces a fixed-sized output array.
    /// This operator is typically used in Faster R-CNN &amp; Mask R-CNN networks. If roi batchid is less 
    /// than 0, it will be ignored, and the corresponding output will be set to 0.
    /// 
    /// Different from ROI pooling, ROI Align removes the harsh quantization, properly aligning
    /// the extracted features with the input. RoIAlign computes the value of each sampling point
    /// by bilinear interpolation from the nearby grid points on the feature map. No quantization is
    /// performed on any coordinates involved in the RoI, its bins, or the sampling points.
    /// Bilinear interpolation is used to compute the exact values of the
    /// input features at four regularly sampled locations in each RoI bin.
    /// Then the feature map can be aggregated by avgpooling.
    /// 
    /// 
    /// References
    /// ----------
    /// 
    /// He, Kaiming, et al. &quot;Mask R-CNN.&quot; ICCV, 2017
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\contrib\roi_align.cc:L544</summary>
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="data">Input data to the pooling operator, a 4D Feature maps</param>
    /// <param name="rois">Bounding box coordinates, a 2D array, if batchid is less than 0, it will be ignored.</param>
    /// <param name="pooledSize">ROI Align output roi feature map height and width: (h, w)</param>
    /// <param name="spatialScale">Ratio of input feature map height (or w) to raw image height (or w). Equals the reciprocal of total stride in convolutional layers</param>
    /// <param name="sampleRatio">Optional sampling ratio of ROI align, using adaptive size by default.</param>
    /// <param name="positionSensitive">Whether to perform position-sensitive RoI pooling. PSRoIPooling is first proposaled by R-FCN and it can reduce the input channels by ph*pw times, where (ph, pw) is the pooled_size</param>
    static member ContribROIAlign(outputArray : NDArray seq, 
                                  data : NDArray, 
                                  rois : NDArray, 
                                  pooledSize : int seq, 
                                  spatialScale : float, 
                                  [<Optional; DefaultParameterValue(-1)>] sampleRatio : int, 
                                  [<Optional; DefaultParameterValue(false)>] positionSensitive : bool) =
        let creator = AtomicSymbolCreator.FromName "_contrib_ROIAlign"
        let names = [|"pooled_size"; "spatial_scale"; "sample_ratio"; "position_sensitive"|]
        let vals = [|(pooledSize |> Seq.map string |> String.concat ", " |> sprintf "[%s]"); string spatialScale; string sampleRatio; string positionSensitive|]
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg rois)) then rois.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <summary>
    /// This operator takes a 4D feature map as an input array and region proposals as `rois`,
    /// then align the feature map over sub-regions of input and produces a fixed-sized output array.
    /// This operator is typically used in Faster R-CNN &amp; Mask R-CNN networks. If roi batchid is less 
    /// than 0, it will be ignored, and the corresponding output will be set to 0.
    /// 
    /// Different from ROI pooling, ROI Align removes the harsh quantization, properly aligning
    /// the extracted features with the input. RoIAlign computes the value of each sampling point
    /// by bilinear interpolation from the nearby grid points on the feature map. No quantization is
    /// performed on any coordinates involved in the RoI, its bins, or the sampling points.
    /// Bilinear interpolation is used to compute the exact values of the
    /// input features at four regularly sampled locations in each RoI bin.
    /// Then the feature map can be aggregated by avgpooling.
    /// 
    /// 
    /// References
    /// ----------
    /// 
    /// He, Kaiming, et al. &quot;Mask R-CNN.&quot; ICCV, 2017
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\contrib\roi_align.cc:L544</summary>
    /// <param name="data">Input data to the pooling operator, a 4D Feature maps</param>
    /// <param name="rois">Bounding box coordinates, a 2D array, if batchid is less than 0, it will be ignored.</param>
    /// <param name="pooledSize">ROI Align output roi feature map height and width: (h, w)</param>
    /// <param name="spatialScale">Ratio of input feature map height (or w) to raw image height (or w). Equals the reciprocal of total stride in convolutional layers</param>
    /// <param name="sampleRatio">Optional sampling ratio of ROI align, using adaptive size by default.</param>
    /// <param name="positionSensitive">Whether to perform position-sensitive RoI pooling. PSRoIPooling is first proposaled by R-FCN and it can reduce the input channels by ph*pw times, where (ph, pw) is the pooled_size</param>
    static member ContribROIAlign(data : Symbol, rois : Symbol, pooledSize : int seq, spatialScale : float, [<Optional>] ?sampleRatio : int, [<Optional>] ?positionSensitive : bool) =
        ContribROIAlign(data, rois, pooledSize, spatialScale, ?sampleRatio = sampleRatio, ?positionSensitive = positionSensitive)
    /// <summary>
    /// This operator takes a 4D feature map as an input array and region proposals as `rois`,
    /// then align the feature map over sub-regions of input and produces a fixed-sized output array.
    /// This operator is typically used in Faster R-CNN &amp; Mask R-CNN networks. If roi batchid is less 
    /// than 0, it will be ignored, and the corresponding output will be set to 0.
    /// 
    /// Different from ROI pooling, ROI Align removes the harsh quantization, properly aligning
    /// the extracted features with the input. RoIAlign computes the value of each sampling point
    /// by bilinear interpolation from the nearby grid points on the feature map. No quantization is
    /// performed on any coordinates involved in the RoI, its bins, or the sampling points.
    /// Bilinear interpolation is used to compute the exact values of the
    /// input features at four regularly sampled locations in each RoI bin.
    /// Then the feature map can be aggregated by avgpooling.
    /// 
    /// 
    /// References
    /// ----------
    /// 
    /// He, Kaiming, et al. &quot;Mask R-CNN.&quot; ICCV, 2017
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\contrib\roi_align.cc:L544</summary>
    /// <param name="pooledSize">ROI Align output roi feature map height and width: (h, w)</param>
    /// <param name="spatialScale">Ratio of input feature map height (or w) to raw image height (or w). Equals the reciprocal of total stride in convolutional layers</param>
    /// <param name="data">Input data to the pooling operator, a 4D Feature maps</param>
    /// <param name="rois">Bounding box coordinates, a 2D array, if batchid is less than 0, it will be ignored.</param>
    /// <param name="sampleRatio">Optional sampling ratio of ROI align, using adaptive size by default.</param>
    /// <param name="positionSensitive">Whether to perform position-sensitive RoI pooling. PSRoIPooling is first proposaled by R-FCN and it can reduce the input channels by ph*pw times, where (ph, pw) is the pooled_size</param>
    static member ContribROIAlign(pooledSize : int seq, spatialScale : float, [<Optional>] ?data : Symbol, [<Optional>] ?rois : Symbol, [<Optional>] ?sampleRatio : int, [<Optional>] ?positionSensitive : bool) =
        ContribROIAlign(pooledSize, spatialScale, ?data = data, ?rois = rois, ?sampleRatio = sampleRatio, ?positionSensitive = positionSensitive)


    /// <summary>Performs Rotated ROI Align on the input array.
    /// 
    /// This operator takes a 4D feature map as an input array and region proposals as `rois`,
    /// then align the feature map over sub-regions of input and produces a fixed-sized output array.
    /// 
    /// Different from ROI Align, RROI Align uses rotated rois, which is suitable for text detection.
    /// RRoIAlign computes the value of each sampling point by bilinear interpolation from the nearby
    /// grid points on the rotated feature map. No quantization is performed on any coordinates
    /// involved in the RoI, its bins, or the sampling points. Bilinear interpolation is used to
    /// compute the exact values of the input features at four regularly sampled locations in
    /// each RoI bin. Then the feature map can be aggregated by avgpooling.
    /// 
    /// References
    /// ----------
    /// 
    /// Ma, Jianqi, et al. &quot;Arbitrary-Oriented Scene Text Detection via Rotation Proposals.&quot;
    /// IEEE Transactions on Multimedia, 2018.
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\contrib\rroi_align.cc:L274</summary>
    /// <param name="data">Input data to the pooling operator, a 4D Feature maps</param>
    /// <param name="rois">Bounding box coordinates, a 2D array</param>
    /// <param name="pooledSize">RROI align output shape (h,w) </param>
    /// <param name="spatialScale">Ratio of input feature map height (or width) to raw image height (or width). Equals the reciprocal of total stride in convolutional layers</param>
    /// <param name="samplingRatio">Optional sampling ratio of RROI align, using adaptive size by default.</param>
    static member ContribRROIAlign(data : NDArray, 
                                   rois : NDArray, 
                                   pooledSize : int seq, 
                                   spatialScale : float, 
                                   [<Optional; DefaultParameterValue(-1)>] samplingRatio : int) =
        let creator = AtomicSymbolCreator.FromName "_contrib_RROIAlign"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg rois)) then rois.UnsafeHandle|]
                                                 [|"pooled_size"; "spatial_scale"; "sampling_ratio"|]
                                                 [|(pooledSize |> Seq.map string |> String.concat ", " |> sprintf "[%s]"); string spatialScale; string samplingRatio|]
        (new NDArray(outputs.[0]))
    /// <summary>Performs Rotated ROI Align on the input array.
    /// 
    /// This operator takes a 4D feature map as an input array and region proposals as `rois`,
    /// then align the feature map over sub-regions of input and produces a fixed-sized output array.
    /// 
    /// Different from ROI Align, RROI Align uses rotated rois, which is suitable for text detection.
    /// RRoIAlign computes the value of each sampling point by bilinear interpolation from the nearby
    /// grid points on the rotated feature map. No quantization is performed on any coordinates
    /// involved in the RoI, its bins, or the sampling points. Bilinear interpolation is used to
    /// compute the exact values of the input features at four regularly sampled locations in
    /// each RoI bin. Then the feature map can be aggregated by avgpooling.
    /// 
    /// References
    /// ----------
    /// 
    /// Ma, Jianqi, et al. &quot;Arbitrary-Oriented Scene Text Detection via Rotation Proposals.&quot;
    /// IEEE Transactions on Multimedia, 2018.
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\contrib\rroi_align.cc:L274</summary>
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="data">Input data to the pooling operator, a 4D Feature maps</param>
    /// <param name="rois">Bounding box coordinates, a 2D array</param>
    /// <param name="pooledSize">RROI align output shape (h,w) </param>
    /// <param name="spatialScale">Ratio of input feature map height (or width) to raw image height (or width). Equals the reciprocal of total stride in convolutional layers</param>
    /// <param name="samplingRatio">Optional sampling ratio of RROI align, using adaptive size by default.</param>
    static member ContribRROIAlign(outputArray : NDArray seq, 
                                   data : NDArray, 
                                   rois : NDArray, 
                                   pooledSize : int seq, 
                                   spatialScale : float, 
                                   [<Optional; DefaultParameterValue(-1)>] samplingRatio : int) =
        let creator = AtomicSymbolCreator.FromName "_contrib_RROIAlign"
        let names = [|"pooled_size"; "spatial_scale"; "sampling_ratio"|]
        let vals = [|(pooledSize |> Seq.map string |> String.concat ", " |> sprintf "[%s]"); string spatialScale; string samplingRatio|]
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg rois)) then rois.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <summary>Performs Rotated ROI Align on the input array.
    /// 
    /// This operator takes a 4D feature map as an input array and region proposals as `rois`,
    /// then align the feature map over sub-regions of input and produces a fixed-sized output array.
    /// 
    /// Different from ROI Align, RROI Align uses rotated rois, which is suitable for text detection.
    /// RRoIAlign computes the value of each sampling point by bilinear interpolation from the nearby
    /// grid points on the rotated feature map. No quantization is performed on any coordinates
    /// involved in the RoI, its bins, or the sampling points. Bilinear interpolation is used to
    /// compute the exact values of the input features at four regularly sampled locations in
    /// each RoI bin. Then the feature map can be aggregated by avgpooling.
    /// 
    /// References
    /// ----------
    /// 
    /// Ma, Jianqi, et al. &quot;Arbitrary-Oriented Scene Text Detection via Rotation Proposals.&quot;
    /// IEEE Transactions on Multimedia, 2018.
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\contrib\rroi_align.cc:L274</summary>
    /// <param name="data">Input data to the pooling operator, a 4D Feature maps</param>
    /// <param name="rois">Bounding box coordinates, a 2D array</param>
    /// <param name="pooledSize">RROI align output shape (h,w) </param>
    /// <param name="spatialScale">Ratio of input feature map height (or width) to raw image height (or width). Equals the reciprocal of total stride in convolutional layers</param>
    /// <param name="samplingRatio">Optional sampling ratio of RROI align, using adaptive size by default.</param>
    static member ContribRROIAlign(data : Symbol, rois : Symbol, pooledSize : int seq, spatialScale : float, [<Optional>] ?samplingRatio : int) =
        ContribRROIAlign(data, rois, pooledSize, spatialScale, ?samplingRatio = samplingRatio)
    /// <summary>Performs Rotated ROI Align on the input array.
    /// 
    /// This operator takes a 4D feature map as an input array and region proposals as `rois`,
    /// then align the feature map over sub-regions of input and produces a fixed-sized output array.
    /// 
    /// Different from ROI Align, RROI Align uses rotated rois, which is suitable for text detection.
    /// RRoIAlign computes the value of each sampling point by bilinear interpolation from the nearby
    /// grid points on the rotated feature map. No quantization is performed on any coordinates
    /// involved in the RoI, its bins, or the sampling points. Bilinear interpolation is used to
    /// compute the exact values of the input features at four regularly sampled locations in
    /// each RoI bin. Then the feature map can be aggregated by avgpooling.
    /// 
    /// References
    /// ----------
    /// 
    /// Ma, Jianqi, et al. &quot;Arbitrary-Oriented Scene Text Detection via Rotation Proposals.&quot;
    /// IEEE Transactions on Multimedia, 2018.
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\contrib\rroi_align.cc:L274</summary>
    /// <param name="pooledSize">RROI align output shape (h,w) </param>
    /// <param name="spatialScale">Ratio of input feature map height (or width) to raw image height (or width). Equals the reciprocal of total stride in convolutional layers</param>
    /// <param name="data">Input data to the pooling operator, a 4D Feature maps</param>
    /// <param name="rois">Bounding box coordinates, a 2D array</param>
    /// <param name="samplingRatio">Optional sampling ratio of RROI align, using adaptive size by default.</param>
    static member ContribRROIAlign(pooledSize : int seq, spatialScale : float, [<Optional>] ?data : Symbol, [<Optional>] ?rois : Symbol, [<Optional>] ?samplingRatio : int) =
        ContribRROIAlign(pooledSize, spatialScale, ?data = data, ?rois = rois, ?samplingRatio = samplingRatio)


    /// <summary>Straight-through-estimator of `round()`.
    /// 
    /// In forward pass, returns element-wise rounded value to the nearest integer of the input (same as `round()`).
    /// 
    /// In backward pass, returns gradients of ``1`` everywhere (instead of ``0`` everywhere as in `round()`):
    /// :math:`\frac{d}{dx}{round\_ste(x)} = 1` vs. :math:`\frac{d}{dx}{round(x)} = 0`.
    /// This is useful for quantized training.
    /// 
    /// Reference: Estimating or Propagating Gradients Through Stochastic Neurons for Conditional Computation.
    /// 
    /// Example::
    ///   x = round_ste([-1.5, 1.5, -1.9, 1.9, 2.7])
    ///   x.backward()
    ///   x = [-2.,  2., -2.,  2.,  3.]
    ///   x.grad() = [1.,  1., 1.,  1.,  1.]
    /// 
    /// The storage type of ``round_ste`` output depends upon the input storage type:
    ///   - round_ste(default) = default
    ///   - round_ste(row_sparse) = row_sparse
    ///   - round_ste(csr) = csr
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\contrib\stes_op.cc:L55</summary>
    /// <param name="data">The input array.</param>
    static member ContribRoundSte(data : NDArray) =
        let creator = AtomicSymbolCreator.FromName "_contrib_round_ste"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle|]
                                                 Array.empty
                                                 Array.empty
        outputs |> Array.map (fun h -> new NDArray(h))
    /// <summary>Straight-through-estimator of `round()`.
    /// 
    /// In forward pass, returns element-wise rounded value to the nearest integer of the input (same as `round()`).
    /// 
    /// In backward pass, returns gradients of ``1`` everywhere (instead of ``0`` everywhere as in `round()`):
    /// :math:`\frac{d}{dx}{round\_ste(x)} = 1` vs. :math:`\frac{d}{dx}{round(x)} = 0`.
    /// This is useful for quantized training.
    /// 
    /// Reference: Estimating or Propagating Gradients Through Stochastic Neurons for Conditional Computation.
    /// 
    /// Example::
    ///   x = round_ste([-1.5, 1.5, -1.9, 1.9, 2.7])
    ///   x.backward()
    ///   x = [-2.,  2., -2.,  2.,  3.]
    ///   x.grad() = [1.,  1., 1.,  1.,  1.]
    /// 
    /// The storage type of ``round_ste`` output depends upon the input storage type:
    ///   - round_ste(default) = default
    ///   - round_ste(row_sparse) = row_sparse
    ///   - round_ste(csr) = csr
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\contrib\stes_op.cc:L55</summary>
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="data">The input array.</param>
    static member ContribRoundSte(outputArray : NDArray seq, data : NDArray) =
        let creator = AtomicSymbolCreator.FromName "_contrib_round_ste"
        let names = Array.empty
        let vals = Array.empty
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <summary>Straight-through-estimator of `round()`.
    /// 
    /// In forward pass, returns element-wise rounded value to the nearest integer of the input (same as `round()`).
    /// 
    /// In backward pass, returns gradients of ``1`` everywhere (instead of ``0`` everywhere as in `round()`):
    /// :math:`\frac{d}{dx}{round\_ste(x)} = 1` vs. :math:`\frac{d}{dx}{round(x)} = 0`.
    /// This is useful for quantized training.
    /// 
    /// Reference: Estimating or Propagating Gradients Through Stochastic Neurons for Conditional Computation.
    /// 
    /// Example::
    ///   x = round_ste([-1.5, 1.5, -1.9, 1.9, 2.7])
    ///   x.backward()
    ///   x = [-2.,  2., -2.,  2.,  3.]
    ///   x.grad() = [1.,  1., 1.,  1.,  1.]
    /// 
    /// The storage type of ``round_ste`` output depends upon the input storage type:
    ///   - round_ste(default) = default
    ///   - round_ste(row_sparse) = row_sparse
    ///   - round_ste(csr) = csr
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\contrib\stes_op.cc:L55</summary>
    /// <param name="data">The input array.</param>
    static member ContribRoundSte([<Optional>] ?data : Symbol) =
        ContribRoundSte(?data = data)

    /// <summary>Straight-through-estimator of `sign()`.
    /// 
    /// In forward pass, returns element-wise sign of the input (same as `sign()`).
    /// 
    /// In backward pass, returns gradients of ``1`` everywhere (instead of ``0`` everywhere as in ``sign()``):
    /// :math:`\frac{d}{dx}{sign\_ste(x)} = 1` vs. :math:`\frac{d}{dx}{sign(x)} = 0`.
    /// This is useful for quantized training.
    /// 
    /// Reference: Estimating or Propagating Gradients Through Stochastic Neurons for Conditional Computation.
    /// 
    /// Example::
    ///   x = sign_ste([-2, 0, 3])
    ///   x.backward()
    ///   x = [-1.,  0., 1.]
    ///   x.grad() = [1.,  1., 1.]
    /// 
    /// The storage type of ``sign_ste`` output depends upon the input storage type:
    ///   - round_ste(default) = default
    ///   - round_ste(row_sparse) = row_sparse
    ///   - round_ste(csr) = csr
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\contrib\stes_op.cc:L80</summary>
    /// <param name="data">The input array.</param>
    static member ContribSignSte(data : NDArray) =
        let creator = AtomicSymbolCreator.FromName "_contrib_sign_ste"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle|]
                                                 Array.empty
                                                 Array.empty
        outputs |> Array.map (fun h -> new NDArray(h))
    /// <summary>Straight-through-estimator of `sign()`.
    /// 
    /// In forward pass, returns element-wise sign of the input (same as `sign()`).
    /// 
    /// In backward pass, returns gradients of ``1`` everywhere (instead of ``0`` everywhere as in ``sign()``):
    /// :math:`\frac{d}{dx}{sign\_ste(x)} = 1` vs. :math:`\frac{d}{dx}{sign(x)} = 0`.
    /// This is useful for quantized training.
    /// 
    /// Reference: Estimating or Propagating Gradients Through Stochastic Neurons for Conditional Computation.
    /// 
    /// Example::
    ///   x = sign_ste([-2, 0, 3])
    ///   x.backward()
    ///   x = [-1.,  0., 1.]
    ///   x.grad() = [1.,  1., 1.]
    /// 
    /// The storage type of ``sign_ste`` output depends upon the input storage type:
    ///   - round_ste(default) = default
    ///   - round_ste(row_sparse) = row_sparse
    ///   - round_ste(csr) = csr
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\contrib\stes_op.cc:L80</summary>
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="data">The input array.</param>
    static member ContribSignSte(outputArray : NDArray seq, data : NDArray) =
        let creator = AtomicSymbolCreator.FromName "_contrib_sign_ste"
        let names = Array.empty
        let vals = Array.empty
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <summary>Straight-through-estimator of `sign()`.
    /// 
    /// In forward pass, returns element-wise sign of the input (same as `sign()`).
    /// 
    /// In backward pass, returns gradients of ``1`` everywhere (instead of ``0`` everywhere as in ``sign()``):
    /// :math:`\frac{d}{dx}{sign\_ste(x)} = 1` vs. :math:`\frac{d}{dx}{sign(x)} = 0`.
    /// This is useful for quantized training.
    /// 
    /// Reference: Estimating or Propagating Gradients Through Stochastic Neurons for Conditional Computation.
    /// 
    /// Example::
    ///   x = sign_ste([-2, 0, 3])
    ///   x.backward()
    ///   x = [-1.,  0., 1.]
    ///   x.grad() = [1.,  1., 1.]
    /// 
    /// The storage type of ``sign_ste`` output depends upon the input storage type:
    ///   - round_ste(default) = default
    ///   - round_ste(row_sparse) = row_sparse
    ///   - round_ste(csr) = csr
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\contrib\stes_op.cc:L80</summary>
    /// <param name="data">The input array.</param>
    static member ContribSignSte([<Optional>] ?data : Symbol) =
        ContribSignSte(?data = data)

    /// <summary>Batch normalization.
    /// 
    /// Normalizes a data batch by mean and variance, and applies a scale ``gamma`` as
    /// well as offset ``beta``.
    /// Standard BN [1]_ implementation only normalize the data within each device.
    /// SyncBN normalizes the input within the whole mini-batch.
    /// We follow the sync-onece implmentation described in the paper [2]_.
    /// 
    /// Assume the input has more than one dimension and we normalize along axis 1.
    /// We first compute the mean and variance along this axis:
    /// 
    /// .. math::
    /// 
    ///   data\_mean[i] = mean(data[:,i,:,...]) \\
    ///   data\_var[i] = var(data[:,i,:,...])
    /// 
    /// Then compute the normalized output, which has the same shape as input, as following:
    /// 
    /// .. math::
    /// 
    ///   out[:,i,:,...] = \frac{data[:,i,:,...] - data\_mean[i]}{\sqrt{data\_var[i]+\epsilon}} * gamma[i] + beta[i]
    /// 
    /// Both *mean* and *var* returns a scalar by treating the input as a vector.
    /// 
    /// Assume the input has size *k* on axis 1, then both ``gamma`` and ``beta``
    /// have shape *(k,)*. If ``output_mean_var`` is set to be true, then outputs both ``data_mean`` and
    /// ``data_var`` as well, which are needed for the backward pass.
    /// 
    /// Besides the inputs and the outputs, this operator accepts two auxiliary
    /// states, ``moving_mean`` and ``moving_var``, which are *k*-length
    /// vectors. They are global statistics for the whole dataset, which are updated
    /// by::
    /// 
    ///   moving_mean = moving_mean * momentum + data_mean * (1 - momentum)
    ///   moving_var = moving_var * momentum + data_var * (1 - momentum)
    /// 
    /// If ``use_global_stats`` is set to be true, then ``moving_mean`` and
    /// ``moving_var`` are used instead of ``data_mean`` and ``data_var`` to compute
    /// the output. It is often used during inference.
    /// 
    /// Both ``gamma`` and ``beta`` are learnable parameters. But if ``fix_gamma`` is true,
    /// then set ``gamma`` to 1 and its gradient to 0.
    /// 
    /// Reference:
    ///   .. [1] Ioffe, Sergey, and Christian Szegedy. &quot;Batch normalization: Accelerating \
    ///     deep network training by reducing internal covariate shift.&quot; *ICML 2015*
    ///   .. [2] Hang Zhang, Kristin Dana, Jianping Shi, Zhongyue Zhang, Xiaogang Wang, \
    ///     Ambrish Tyagi, and Amit Agrawal. &quot;Context Encoding for Semantic Segmentation.&quot; *CVPR 2018*
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\contrib\sync_batch_norm.cc:L97</summary>
    /// <param name="data">Input data to batch normalization</param>
    /// <param name="gamma">gamma array</param>
    /// <param name="beta">beta array</param>
    /// <param name="movingMean">running mean of input</param>
    /// <param name="movingVar">running variance of input</param>
    /// <param name="key">Hash key for synchronization, please set the same hash key for same layer, Block.prefix is typically used as in :class:`gluon.nn.contrib.SyncBatchNorm`.</param>
    /// <param name="eps">Epsilon to prevent div 0</param>
    /// <param name="momentum">Momentum for moving average</param>
    /// <param name="fixGamma">Fix gamma while training</param>
    /// <param name="useGlobalStats">Whether use global moving statistics instead of local batch-norm. This will force change batch-norm into a scale shift operator.</param>
    /// <param name="outputMeanVar">Output All,normal mean and var</param>
    /// <param name="ndev">The count of GPU devices</param>
    static member ContribSyncBatchNorm(data : NDArray, 
                                       gamma : NDArray, 
                                       beta : NDArray, 
                                       movingMean : NDArray, 
                                       movingVar : NDArray, 
                                       key : string, 
                                       [<Optional; DefaultParameterValue(0.00100000005)>] eps : float, 
                                       [<Optional; DefaultParameterValue(0.899999976)>] momentum : float, 
                                       [<Optional; DefaultParameterValue(true)>] fixGamma : bool, 
                                       [<Optional; DefaultParameterValue(false)>] useGlobalStats : bool, 
                                       [<Optional; DefaultParameterValue(false)>] outputMeanVar : bool, 
                                       [<Optional; DefaultParameterValue(1)>] ndev : int) =
        let creator = AtomicSymbolCreator.FromName "_contrib_SyncBatchNorm"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg gamma)) then gamma.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg beta)) then beta.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg movingMean)) then movingMean.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg movingVar)) then movingVar.UnsafeHandle|]
                                                 [|"key"; "eps"; "momentum"; "fix_gamma"; "use_global_stats"; "output_mean_var"; "ndev"|]
                                                 [|key; string eps; string momentum; string fixGamma; string useGlobalStats; string outputMeanVar; string ndev|]
        outputs |> Array.map (fun h -> new NDArray(h))
    /// <summary>Batch normalization.
    /// 
    /// Normalizes a data batch by mean and variance, and applies a scale ``gamma`` as
    /// well as offset ``beta``.
    /// Standard BN [1]_ implementation only normalize the data within each device.
    /// SyncBN normalizes the input within the whole mini-batch.
    /// We follow the sync-onece implmentation described in the paper [2]_.
    /// 
    /// Assume the input has more than one dimension and we normalize along axis 1.
    /// We first compute the mean and variance along this axis:
    /// 
    /// .. math::
    /// 
    ///   data\_mean[i] = mean(data[:,i,:,...]) \\
    ///   data\_var[i] = var(data[:,i,:,...])
    /// 
    /// Then compute the normalized output, which has the same shape as input, as following:
    /// 
    /// .. math::
    /// 
    ///   out[:,i,:,...] = \frac{data[:,i,:,...] - data\_mean[i]}{\sqrt{data\_var[i]+\epsilon}} * gamma[i] + beta[i]
    /// 
    /// Both *mean* and *var* returns a scalar by treating the input as a vector.
    /// 
    /// Assume the input has size *k* on axis 1, then both ``gamma`` and ``beta``
    /// have shape *(k,)*. If ``output_mean_var`` is set to be true, then outputs both ``data_mean`` and
    /// ``data_var`` as well, which are needed for the backward pass.
    /// 
    /// Besides the inputs and the outputs, this operator accepts two auxiliary
    /// states, ``moving_mean`` and ``moving_var``, which are *k*-length
    /// vectors. They are global statistics for the whole dataset, which are updated
    /// by::
    /// 
    ///   moving_mean = moving_mean * momentum + data_mean * (1 - momentum)
    ///   moving_var = moving_var * momentum + data_var * (1 - momentum)
    /// 
    /// If ``use_global_stats`` is set to be true, then ``moving_mean`` and
    /// ``moving_var`` are used instead of ``data_mean`` and ``data_var`` to compute
    /// the output. It is often used during inference.
    /// 
    /// Both ``gamma`` and ``beta`` are learnable parameters. But if ``fix_gamma`` is true,
    /// then set ``gamma`` to 1 and its gradient to 0.
    /// 
    /// Reference:
    ///   .. [1] Ioffe, Sergey, and Christian Szegedy. &quot;Batch normalization: Accelerating \
    ///     deep network training by reducing internal covariate shift.&quot; *ICML 2015*
    ///   .. [2] Hang Zhang, Kristin Dana, Jianping Shi, Zhongyue Zhang, Xiaogang Wang, \
    ///     Ambrish Tyagi, and Amit Agrawal. &quot;Context Encoding for Semantic Segmentation.&quot; *CVPR 2018*
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\contrib\sync_batch_norm.cc:L97</summary>
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="data">Input data to batch normalization</param>
    /// <param name="gamma">gamma array</param>
    /// <param name="beta">beta array</param>
    /// <param name="movingMean">running mean of input</param>
    /// <param name="movingVar">running variance of input</param>
    /// <param name="key">Hash key for synchronization, please set the same hash key for same layer, Block.prefix is typically used as in :class:`gluon.nn.contrib.SyncBatchNorm`.</param>
    /// <param name="eps">Epsilon to prevent div 0</param>
    /// <param name="momentum">Momentum for moving average</param>
    /// <param name="fixGamma">Fix gamma while training</param>
    /// <param name="useGlobalStats">Whether use global moving statistics instead of local batch-norm. This will force change batch-norm into a scale shift operator.</param>
    /// <param name="outputMeanVar">Output All,normal mean and var</param>
    /// <param name="ndev">The count of GPU devices</param>
    static member ContribSyncBatchNorm(outputArray : NDArray seq, 
                                       data : NDArray, 
                                       gamma : NDArray, 
                                       beta : NDArray, 
                                       movingMean : NDArray, 
                                       movingVar : NDArray, 
                                       key : string, 
                                       [<Optional; DefaultParameterValue(0.00100000005)>] eps : float, 
                                       [<Optional; DefaultParameterValue(0.899999976)>] momentum : float, 
                                       [<Optional; DefaultParameterValue(true)>] fixGamma : bool, 
                                       [<Optional; DefaultParameterValue(false)>] useGlobalStats : bool, 
                                       [<Optional; DefaultParameterValue(false)>] outputMeanVar : bool, 
                                       [<Optional; DefaultParameterValue(1)>] ndev : int) =
        let creator = AtomicSymbolCreator.FromName "_contrib_SyncBatchNorm"
        let names = [|"key"; "eps"; "momentum"; "fix_gamma"; "use_global_stats"; "output_mean_var"; "ndev"|]
        let vals = [|key; string eps; string momentum; string fixGamma; string useGlobalStats; string outputMeanVar; string ndev|]
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg gamma)) then gamma.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg beta)) then beta.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg movingMean)) then movingMean.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg movingVar)) then movingVar.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <summary>Batch normalization.
    /// 
    /// Normalizes a data batch by mean and variance, and applies a scale ``gamma`` as
    /// well as offset ``beta``.
    /// Standard BN [1]_ implementation only normalize the data within each device.
    /// SyncBN normalizes the input within the whole mini-batch.
    /// We follow the sync-onece implmentation described in the paper [2]_.
    /// 
    /// Assume the input has more than one dimension and we normalize along axis 1.
    /// We first compute the mean and variance along this axis:
    /// 
    /// .. math::
    /// 
    ///   data\_mean[i] = mean(data[:,i,:,...]) \\
    ///   data\_var[i] = var(data[:,i,:,...])
    /// 
    /// Then compute the normalized output, which has the same shape as input, as following:
    /// 
    /// .. math::
    /// 
    ///   out[:,i,:,...] = \frac{data[:,i,:,...] - data\_mean[i]}{\sqrt{data\_var[i]+\epsilon}} * gamma[i] + beta[i]
    /// 
    /// Both *mean* and *var* returns a scalar by treating the input as a vector.
    /// 
    /// Assume the input has size *k* on axis 1, then both ``gamma`` and ``beta``
    /// have shape *(k,)*. If ``output_mean_var`` is set to be true, then outputs both ``data_mean`` and
    /// ``data_var`` as well, which are needed for the backward pass.
    /// 
    /// Besides the inputs and the outputs, this operator accepts two auxiliary
    /// states, ``moving_mean`` and ``moving_var``, which are *k*-length
    /// vectors. They are global statistics for the whole dataset, which are updated
    /// by::
    /// 
    ///   moving_mean = moving_mean * momentum + data_mean * (1 - momentum)
    ///   moving_var = moving_var * momentum + data_var * (1 - momentum)
    /// 
    /// If ``use_global_stats`` is set to be true, then ``moving_mean`` and
    /// ``moving_var`` are used instead of ``data_mean`` and ``data_var`` to compute
    /// the output. It is often used during inference.
    /// 
    /// Both ``gamma`` and ``beta`` are learnable parameters. But if ``fix_gamma`` is true,
    /// then set ``gamma`` to 1 and its gradient to 0.
    /// 
    /// Reference:
    ///   .. [1] Ioffe, Sergey, and Christian Szegedy. &quot;Batch normalization: Accelerating \
    ///     deep network training by reducing internal covariate shift.&quot; *ICML 2015*
    ///   .. [2] Hang Zhang, Kristin Dana, Jianping Shi, Zhongyue Zhang, Xiaogang Wang, \
    ///     Ambrish Tyagi, and Amit Agrawal. &quot;Context Encoding for Semantic Segmentation.&quot; *CVPR 2018*
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\contrib\sync_batch_norm.cc:L97</summary>
    /// <param name="data">Input data to batch normalization</param>
    /// <param name="gamma">gamma array</param>
    /// <param name="beta">beta array</param>
    /// <param name="movingMean">running mean of input</param>
    /// <param name="movingVar">running variance of input</param>
    /// <param name="key">Hash key for synchronization, please set the same hash key for same layer, Block.prefix is typically used as in :class:`gluon.nn.contrib.SyncBatchNorm`.</param>
    /// <param name="eps">Epsilon to prevent div 0</param>
    /// <param name="momentum">Momentum for moving average</param>
    /// <param name="fixGamma">Fix gamma while training</param>
    /// <param name="useGlobalStats">Whether use global moving statistics instead of local batch-norm. This will force change batch-norm into a scale shift operator.</param>
    /// <param name="outputMeanVar">Output All,normal mean and var</param>
    /// <param name="ndev">The count of GPU devices</param>
    static member ContribSyncBatchNorm(data : Symbol, gamma : Symbol, beta : Symbol, movingMean : Symbol, movingVar : Symbol, key : string, [<Optional>] ?eps : float, [<Optional>] ?momentum : float, [<Optional>] ?fixGamma : bool, [<Optional>] ?useGlobalStats : bool, [<Optional>] ?outputMeanVar : bool, [<Optional>] ?ndev : int) =
        ContribSyncBatchNorm(data, gamma, beta, movingMean, movingVar, key, ?eps = eps, ?momentum = momentum, ?fixGamma = fixGamma, ?useGlobalStats = useGlobalStats, ?outputMeanVar = outputMeanVar, ?ndev = ndev)
    /// <summary>Batch normalization.
    /// 
    /// Normalizes a data batch by mean and variance, and applies a scale ``gamma`` as
    /// well as offset ``beta``.
    /// Standard BN [1]_ implementation only normalize the data within each device.
    /// SyncBN normalizes the input within the whole mini-batch.
    /// We follow the sync-onece implmentation described in the paper [2]_.
    /// 
    /// Assume the input has more than one dimension and we normalize along axis 1.
    /// We first compute the mean and variance along this axis:
    /// 
    /// .. math::
    /// 
    ///   data\_mean[i] = mean(data[:,i,:,...]) \\
    ///   data\_var[i] = var(data[:,i,:,...])
    /// 
    /// Then compute the normalized output, which has the same shape as input, as following:
    /// 
    /// .. math::
    /// 
    ///   out[:,i,:,...] = \frac{data[:,i,:,...] - data\_mean[i]}{\sqrt{data\_var[i]+\epsilon}} * gamma[i] + beta[i]
    /// 
    /// Both *mean* and *var* returns a scalar by treating the input as a vector.
    /// 
    /// Assume the input has size *k* on axis 1, then both ``gamma`` and ``beta``
    /// have shape *(k,)*. If ``output_mean_var`` is set to be true, then outputs both ``data_mean`` and
    /// ``data_var`` as well, which are needed for the backward pass.
    /// 
    /// Besides the inputs and the outputs, this operator accepts two auxiliary
    /// states, ``moving_mean`` and ``moving_var``, which are *k*-length
    /// vectors. They are global statistics for the whole dataset, which are updated
    /// by::
    /// 
    ///   moving_mean = moving_mean * momentum + data_mean * (1 - momentum)
    ///   moving_var = moving_var * momentum + data_var * (1 - momentum)
    /// 
    /// If ``use_global_stats`` is set to be true, then ``moving_mean`` and
    /// ``moving_var`` are used instead of ``data_mean`` and ``data_var`` to compute
    /// the output. It is often used during inference.
    /// 
    /// Both ``gamma`` and ``beta`` are learnable parameters. But if ``fix_gamma`` is true,
    /// then set ``gamma`` to 1 and its gradient to 0.
    /// 
    /// Reference:
    ///   .. [1] Ioffe, Sergey, and Christian Szegedy. &quot;Batch normalization: Accelerating \
    ///     deep network training by reducing internal covariate shift.&quot; *ICML 2015*
    ///   .. [2] Hang Zhang, Kristin Dana, Jianping Shi, Zhongyue Zhang, Xiaogang Wang, \
    ///     Ambrish Tyagi, and Amit Agrawal. &quot;Context Encoding for Semantic Segmentation.&quot; *CVPR 2018*
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\contrib\sync_batch_norm.cc:L97</summary>
    /// <param name="key">Hash key for synchronization, please set the same hash key for same layer, Block.prefix is typically used as in :class:`gluon.nn.contrib.SyncBatchNorm`.</param>
    /// <param name="data">Input data to batch normalization</param>
    /// <param name="gamma">gamma array</param>
    /// <param name="beta">beta array</param>
    /// <param name="movingMean">running mean of input</param>
    /// <param name="movingVar">running variance of input</param>
    /// <param name="eps">Epsilon to prevent div 0</param>
    /// <param name="momentum">Momentum for moving average</param>
    /// <param name="fixGamma">Fix gamma while training</param>
    /// <param name="useGlobalStats">Whether use global moving statistics instead of local batch-norm. This will force change batch-norm into a scale shift operator.</param>
    /// <param name="outputMeanVar">Output All,normal mean and var</param>
    /// <param name="ndev">The count of GPU devices</param>
    static member ContribSyncBatchNorm(key : string, [<Optional>] ?data : Symbol, [<Optional>] ?gamma : Symbol, [<Optional>] ?beta : Symbol, [<Optional>] ?movingMean : Symbol, [<Optional>] ?movingVar : Symbol, [<Optional>] ?eps : float, [<Optional>] ?momentum : float, [<Optional>] ?fixGamma : bool, [<Optional>] ?useGlobalStats : bool, [<Optional>] ?outputMeanVar : bool, [<Optional>] ?ndev : int) =
        ContribSyncBatchNorm(key, ?data = data, ?gamma = gamma, ?beta = beta, ?movingMean = movingMean, ?movingVar = movingVar, ?eps = eps, ?momentum = momentum, ?fixGamma = fixGamma, ?useGlobalStats = useGlobalStats, ?outputMeanVar = outputMeanVar, ?ndev = ndev)

    /// <summary>Compute the matrix multiplication between the projections of
    /// queries and keys in multihead attention use as self attention.
    /// 
    /// the input must be a single tensor of interleaved projections
    /// of queries, keys and values following the layout:
    /// (seq_length, batch_size, num_heads * head_dim * 3)
    /// 
    /// the equivalent code would be:
    /// tmp = mx.nd.reshape(queries_keys_values, shape=(0, 0, num_heads, 3, -1))
    /// q_proj = mx.nd.transpose(tmp[:,:,:,0,:], axes=(1, 2, 0, 3))
    /// q_proj = mx.nd.reshape(q_proj, shape=(-1, 0, 0), reverse=True)
    /// q_proj = mx.nd.contrib.div_sqrt_dim(q_proj)
    /// k_proj = mx.nd.transpose(tmp[:,:,:,1,:], axes=(1, 2, 0, 3))
    /// k_proj = mx.nd.reshap(k_proj, shape=(-1, 0, 0), reverse=True)
    /// output = mx.nd.batch_dot(q_proj, k_proj, transpose_b=True)
    /// 
    /// This Op is GPU only
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\contrib\transformer.cc:L143</summary>
    /// <param name="queriesKeysValues">Interleaved queries, keys and values</param>
    /// <param name="heads">Set number of heads</param>
    static member ContribInterleavedMatmulSelfattQk(queriesKeysValues : NDArray, heads : int) =
        let creator = AtomicSymbolCreator.FromName "_contrib_interleaved_matmul_selfatt_qk"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg queriesKeysValues)) then queriesKeysValues.UnsafeHandle|]
                                                 [|"heads"|]
                                                 [|string heads|]
        outputs |> Array.map (fun h -> new NDArray(h))
    /// <summary>Compute the matrix multiplication between the projections of
    /// queries and keys in multihead attention use as self attention.
    /// 
    /// the input must be a single tensor of interleaved projections
    /// of queries, keys and values following the layout:
    /// (seq_length, batch_size, num_heads * head_dim * 3)
    /// 
    /// the equivalent code would be:
    /// tmp = mx.nd.reshape(queries_keys_values, shape=(0, 0, num_heads, 3, -1))
    /// q_proj = mx.nd.transpose(tmp[:,:,:,0,:], axes=(1, 2, 0, 3))
    /// q_proj = mx.nd.reshape(q_proj, shape=(-1, 0, 0), reverse=True)
    /// q_proj = mx.nd.contrib.div_sqrt_dim(q_proj)
    /// k_proj = mx.nd.transpose(tmp[:,:,:,1,:], axes=(1, 2, 0, 3))
    /// k_proj = mx.nd.reshap(k_proj, shape=(-1, 0, 0), reverse=True)
    /// output = mx.nd.batch_dot(q_proj, k_proj, transpose_b=True)
    /// 
    /// This Op is GPU only
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\contrib\transformer.cc:L143</summary>
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="queriesKeysValues">Interleaved queries, keys and values</param>
    /// <param name="heads">Set number of heads</param>
    static member ContribInterleavedMatmulSelfattQk(outputArray : NDArray seq, queriesKeysValues : NDArray, heads : int) =
        let creator = AtomicSymbolCreator.FromName "_contrib_interleaved_matmul_selfatt_qk"
        let names = [|"heads"|]
        let vals = [|string heads|]
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg queriesKeysValues)) then queriesKeysValues.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <summary>Compute the matrix multiplication between the projections of
    /// queries and keys in multihead attention use as self attention.
    /// 
    /// the input must be a single tensor of interleaved projections
    /// of queries, keys and values following the layout:
    /// (seq_length, batch_size, num_heads * head_dim * 3)
    /// 
    /// the equivalent code would be:
    /// tmp = mx.nd.reshape(queries_keys_values, shape=(0, 0, num_heads, 3, -1))
    /// q_proj = mx.nd.transpose(tmp[:,:,:,0,:], axes=(1, 2, 0, 3))
    /// q_proj = mx.nd.reshape(q_proj, shape=(-1, 0, 0), reverse=True)
    /// q_proj = mx.nd.contrib.div_sqrt_dim(q_proj)
    /// k_proj = mx.nd.transpose(tmp[:,:,:,1,:], axes=(1, 2, 0, 3))
    /// k_proj = mx.nd.reshap(k_proj, shape=(-1, 0, 0), reverse=True)
    /// output = mx.nd.batch_dot(q_proj, k_proj, transpose_b=True)
    /// 
    /// This Op is GPU only
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\contrib\transformer.cc:L143</summary>
    /// <param name="queriesKeysValues">Interleaved queries, keys and values</param>
    /// <param name="heads">Set number of heads</param>
    static member ContribInterleavedMatmulSelfattQk(queriesKeysValues : Symbol, heads : int) =
        ContribInterleavedMatmulSelfattQk(queriesKeysValues, heads)
    /// <summary>Compute the matrix multiplication between the projections of
    /// queries and keys in multihead attention use as self attention.
    /// 
    /// the input must be a single tensor of interleaved projections
    /// of queries, keys and values following the layout:
    /// (seq_length, batch_size, num_heads * head_dim * 3)
    /// 
    /// the equivalent code would be:
    /// tmp = mx.nd.reshape(queries_keys_values, shape=(0, 0, num_heads, 3, -1))
    /// q_proj = mx.nd.transpose(tmp[:,:,:,0,:], axes=(1, 2, 0, 3))
    /// q_proj = mx.nd.reshape(q_proj, shape=(-1, 0, 0), reverse=True)
    /// q_proj = mx.nd.contrib.div_sqrt_dim(q_proj)
    /// k_proj = mx.nd.transpose(tmp[:,:,:,1,:], axes=(1, 2, 0, 3))
    /// k_proj = mx.nd.reshap(k_proj, shape=(-1, 0, 0), reverse=True)
    /// output = mx.nd.batch_dot(q_proj, k_proj, transpose_b=True)
    /// 
    /// This Op is GPU only
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\contrib\transformer.cc:L143</summary>
    /// <param name="heads">Set number of heads</param>
    /// <param name="queriesKeysValues">Interleaved queries, keys and values</param>
    static member ContribInterleavedMatmulSelfattQk(heads : int, [<Optional>] ?queriesKeysValues : Symbol) =
        ContribInterleavedMatmulSelfattQk(heads, ?queriesKeysValues = queriesKeysValues)


    /// <summary>Compute the matrix multiplication between the projections of
    /// values and the attention weights in multihead attention use as self attention.
    /// 
    /// the inputs must be a tensor of interleaved projections
    /// of queries, keys and values following the layout:
    /// (seq_length, batch_size, num_heads * head_dim * 3)
    /// 
    /// and the attention weights following the layout:
    /// (batch_size, seq_length, seq_length)
    /// 
    /// the equivalent code would be:
    /// tmp = mx.nd.reshape(queries_keys_values, shape=(0, 0, num_heads, 3, -1))
    /// v_proj = mx.nd.transpose(tmp[:,:,:,2,:], axes=(1, 2, 0, 3))
    /// v_proj = mx.nd.reshape(v_proj, shape=(-1, 0, 0), reverse=True)
    /// output = mx.nd.batch_dot(attention, v_proj, transpose_b=True)
    /// output = mx.nd.reshape(output, shape=(-1, num_heads, 0, 0), reverse=True)
    /// output = mx.nd.transpose(output, axes=(0, 2, 1, 3))
    /// output = mx.nd.reshape(output, shape=(0, 0, -1))
    /// 
    /// This Op is GPU only
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\contrib\transformer.cc:L187</summary>
    /// <param name="queriesKeysValues">Queries, keys and values interleaved</param>
    /// <param name="attention">Attention maps</param>
    /// <param name="heads">Set number of heads</param>
    static member ContribInterleavedMatmulSelfattValatt(queriesKeysValues : NDArray, attention : NDArray, heads : int) =
        let creator = AtomicSymbolCreator.FromName "_contrib_interleaved_matmul_selfatt_valatt"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg queriesKeysValues)) then queriesKeysValues.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg attention)) then attention.UnsafeHandle|]
                                                 [|"heads"|]
                                                 [|string heads|]
        outputs |> Array.map (fun h -> new NDArray(h))
    /// <summary>Compute the matrix multiplication between the projections of
    /// values and the attention weights in multihead attention use as self attention.
    /// 
    /// the inputs must be a tensor of interleaved projections
    /// of queries, keys and values following the layout:
    /// (seq_length, batch_size, num_heads * head_dim * 3)
    /// 
    /// and the attention weights following the layout:
    /// (batch_size, seq_length, seq_length)
    /// 
    /// the equivalent code would be:
    /// tmp = mx.nd.reshape(queries_keys_values, shape=(0, 0, num_heads, 3, -1))
    /// v_proj = mx.nd.transpose(tmp[:,:,:,2,:], axes=(1, 2, 0, 3))
    /// v_proj = mx.nd.reshape(v_proj, shape=(-1, 0, 0), reverse=True)
    /// output = mx.nd.batch_dot(attention, v_proj, transpose_b=True)
    /// output = mx.nd.reshape(output, shape=(-1, num_heads, 0, 0), reverse=True)
    /// output = mx.nd.transpose(output, axes=(0, 2, 1, 3))
    /// output = mx.nd.reshape(output, shape=(0, 0, -1))
    /// 
    /// This Op is GPU only
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\contrib\transformer.cc:L187</summary>
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="queriesKeysValues">Queries, keys and values interleaved</param>
    /// <param name="attention">Attention maps</param>
    /// <param name="heads">Set number of heads</param>
    static member ContribInterleavedMatmulSelfattValatt(outputArray : NDArray seq, queriesKeysValues : NDArray, attention : NDArray, heads : int) =
        let creator = AtomicSymbolCreator.FromName "_contrib_interleaved_matmul_selfatt_valatt"
        let names = [|"heads"|]
        let vals = [|string heads|]
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg queriesKeysValues)) then queriesKeysValues.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg attention)) then attention.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <summary>Compute the matrix multiplication between the projections of
    /// values and the attention weights in multihead attention use as self attention.
    /// 
    /// the inputs must be a tensor of interleaved projections
    /// of queries, keys and values following the layout:
    /// (seq_length, batch_size, num_heads * head_dim * 3)
    /// 
    /// and the attention weights following the layout:
    /// (batch_size, seq_length, seq_length)
    /// 
    /// the equivalent code would be:
    /// tmp = mx.nd.reshape(queries_keys_values, shape=(0, 0, num_heads, 3, -1))
    /// v_proj = mx.nd.transpose(tmp[:,:,:,2,:], axes=(1, 2, 0, 3))
    /// v_proj = mx.nd.reshape(v_proj, shape=(-1, 0, 0), reverse=True)
    /// output = mx.nd.batch_dot(attention, v_proj, transpose_b=True)
    /// output = mx.nd.reshape(output, shape=(-1, num_heads, 0, 0), reverse=True)
    /// output = mx.nd.transpose(output, axes=(0, 2, 1, 3))
    /// output = mx.nd.reshape(output, shape=(0, 0, -1))
    /// 
    /// This Op is GPU only
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\contrib\transformer.cc:L187</summary>
    /// <param name="queriesKeysValues">Queries, keys and values interleaved</param>
    /// <param name="attention">Attention maps</param>
    /// <param name="heads">Set number of heads</param>
    static member ContribInterleavedMatmulSelfattValatt(queriesKeysValues : Symbol, attention : Symbol, heads : int) =
        ContribInterleavedMatmulSelfattValatt(queriesKeysValues, attention, heads)
    /// <summary>Compute the matrix multiplication between the projections of
    /// values and the attention weights in multihead attention use as self attention.
    /// 
    /// the inputs must be a tensor of interleaved projections
    /// of queries, keys and values following the layout:
    /// (seq_length, batch_size, num_heads * head_dim * 3)
    /// 
    /// and the attention weights following the layout:
    /// (batch_size, seq_length, seq_length)
    /// 
    /// the equivalent code would be:
    /// tmp = mx.nd.reshape(queries_keys_values, shape=(0, 0, num_heads, 3, -1))
    /// v_proj = mx.nd.transpose(tmp[:,:,:,2,:], axes=(1, 2, 0, 3))
    /// v_proj = mx.nd.reshape(v_proj, shape=(-1, 0, 0), reverse=True)
    /// output = mx.nd.batch_dot(attention, v_proj, transpose_b=True)
    /// output = mx.nd.reshape(output, shape=(-1, num_heads, 0, 0), reverse=True)
    /// output = mx.nd.transpose(output, axes=(0, 2, 1, 3))
    /// output = mx.nd.reshape(output, shape=(0, 0, -1))
    /// 
    /// This Op is GPU only
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\contrib\transformer.cc:L187</summary>
    /// <param name="heads">Set number of heads</param>
    /// <param name="queriesKeysValues">Queries, keys and values interleaved</param>
    /// <param name="attention">Attention maps</param>
    static member ContribInterleavedMatmulSelfattValatt(heads : int, [<Optional>] ?queriesKeysValues : Symbol, [<Optional>] ?attention : Symbol) =
        ContribInterleavedMatmulSelfattValatt(heads, ?queriesKeysValues = queriesKeysValues, ?attention = attention)


    /// <summary>Compute the matrix multiplication between the projections of
    /// queries and keys in multihead attention use as encoder-decoder.
    /// 
    /// the inputs must be a tensor of projections of queries following the layout:
    /// (seq_length, batch_size, num_heads * head_dim)
    /// 
    /// and a tensor of interleaved projections of values and keys following the layout:
    /// (seq_length, batch_size, num_heads * head_dim * 2)
    /// 
    /// the equivalent code would be:
    /// q_proj = mx.nd.transpose(queries, axes=(1, 2, 0, 3))
    /// q_proj = mx.nd.reshape(q_proj, shape=(-1, 0, 0), reverse=True)
    /// q_proj = mx.nd.contrib.div_sqrt_dim(q_proj)
    /// tmp = mx.nd.reshape(keys_values, shape=(0, 0, num_heads, 2, -1))
    /// k_proj = mx.nd.transpose(tmp[:,:,:,0,:], axes=(1, 2, 0, 3))
    /// k_proj = mx.nd.reshap(k_proj, shape=(-1, 0, 0), reverse=True)
    /// output = mx.nd.batch_dot(q_proj, k_proj, transpose_b=True)
    /// 
    /// This Op is GPU only
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\contrib\transformer.cc:L231</summary>
    /// <param name="queries">Queries</param>
    /// <param name="keysValues">Keys and values interleaved</param>
    /// <param name="heads">Set number of heads</param>
    static member ContribInterleavedMatmulEncdecQk(queries : NDArray, keysValues : NDArray, heads : int) =
        let creator = AtomicSymbolCreator.FromName "_contrib_interleaved_matmul_encdec_qk"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg queries)) then queries.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg keysValues)) then keysValues.UnsafeHandle|]
                                                 [|"heads"|]
                                                 [|string heads|]
        outputs |> Array.map (fun h -> new NDArray(h))
    /// <summary>Compute the matrix multiplication between the projections of
    /// queries and keys in multihead attention use as encoder-decoder.
    /// 
    /// the inputs must be a tensor of projections of queries following the layout:
    /// (seq_length, batch_size, num_heads * head_dim)
    /// 
    /// and a tensor of interleaved projections of values and keys following the layout:
    /// (seq_length, batch_size, num_heads * head_dim * 2)
    /// 
    /// the equivalent code would be:
    /// q_proj = mx.nd.transpose(queries, axes=(1, 2, 0, 3))
    /// q_proj = mx.nd.reshape(q_proj, shape=(-1, 0, 0), reverse=True)
    /// q_proj = mx.nd.contrib.div_sqrt_dim(q_proj)
    /// tmp = mx.nd.reshape(keys_values, shape=(0, 0, num_heads, 2, -1))
    /// k_proj = mx.nd.transpose(tmp[:,:,:,0,:], axes=(1, 2, 0, 3))
    /// k_proj = mx.nd.reshap(k_proj, shape=(-1, 0, 0), reverse=True)
    /// output = mx.nd.batch_dot(q_proj, k_proj, transpose_b=True)
    /// 
    /// This Op is GPU only
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\contrib\transformer.cc:L231</summary>
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="queries">Queries</param>
    /// <param name="keysValues">Keys and values interleaved</param>
    /// <param name="heads">Set number of heads</param>
    static member ContribInterleavedMatmulEncdecQk(outputArray : NDArray seq, queries : NDArray, keysValues : NDArray, heads : int) =
        let creator = AtomicSymbolCreator.FromName "_contrib_interleaved_matmul_encdec_qk"
        let names = [|"heads"|]
        let vals = [|string heads|]
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg queries)) then queries.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg keysValues)) then keysValues.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <summary>Compute the matrix multiplication between the projections of
    /// queries and keys in multihead attention use as encoder-decoder.
    /// 
    /// the inputs must be a tensor of projections of queries following the layout:
    /// (seq_length, batch_size, num_heads * head_dim)
    /// 
    /// and a tensor of interleaved projections of values and keys following the layout:
    /// (seq_length, batch_size, num_heads * head_dim * 2)
    /// 
    /// the equivalent code would be:
    /// q_proj = mx.nd.transpose(queries, axes=(1, 2, 0, 3))
    /// q_proj = mx.nd.reshape(q_proj, shape=(-1, 0, 0), reverse=True)
    /// q_proj = mx.nd.contrib.div_sqrt_dim(q_proj)
    /// tmp = mx.nd.reshape(keys_values, shape=(0, 0, num_heads, 2, -1))
    /// k_proj = mx.nd.transpose(tmp[:,:,:,0,:], axes=(1, 2, 0, 3))
    /// k_proj = mx.nd.reshap(k_proj, shape=(-1, 0, 0), reverse=True)
    /// output = mx.nd.batch_dot(q_proj, k_proj, transpose_b=True)
    /// 
    /// This Op is GPU only
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\contrib\transformer.cc:L231</summary>
    /// <param name="queries">Queries</param>
    /// <param name="keysValues">Keys and values interleaved</param>
    /// <param name="heads">Set number of heads</param>
    static member ContribInterleavedMatmulEncdecQk(queries : Symbol, keysValues : Symbol, heads : int) =
        ContribInterleavedMatmulEncdecQk(queries, keysValues, heads)
    /// <summary>Compute the matrix multiplication between the projections of
    /// queries and keys in multihead attention use as encoder-decoder.
    /// 
    /// the inputs must be a tensor of projections of queries following the layout:
    /// (seq_length, batch_size, num_heads * head_dim)
    /// 
    /// and a tensor of interleaved projections of values and keys following the layout:
    /// (seq_length, batch_size, num_heads * head_dim * 2)
    /// 
    /// the equivalent code would be:
    /// q_proj = mx.nd.transpose(queries, axes=(1, 2, 0, 3))
    /// q_proj = mx.nd.reshape(q_proj, shape=(-1, 0, 0), reverse=True)
    /// q_proj = mx.nd.contrib.div_sqrt_dim(q_proj)
    /// tmp = mx.nd.reshape(keys_values, shape=(0, 0, num_heads, 2, -1))
    /// k_proj = mx.nd.transpose(tmp[:,:,:,0,:], axes=(1, 2, 0, 3))
    /// k_proj = mx.nd.reshap(k_proj, shape=(-1, 0, 0), reverse=True)
    /// output = mx.nd.batch_dot(q_proj, k_proj, transpose_b=True)
    /// 
    /// This Op is GPU only
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\contrib\transformer.cc:L231</summary>
    /// <param name="heads">Set number of heads</param>
    /// <param name="queries">Queries</param>
    /// <param name="keysValues">Keys and values interleaved</param>
    static member ContribInterleavedMatmulEncdecQk(heads : int, [<Optional>] ?queries : Symbol, [<Optional>] ?keysValues : Symbol) =
        ContribInterleavedMatmulEncdecQk(heads, ?queries = queries, ?keysValues = keysValues)


    /// <summary>Compute the matrix multiplication between the projections of
    /// values and the attention weights in multihead attention use as encoder-decoder.
    /// 
    /// the inputs must be a tensor of interleaved projections of
    /// keys and values following the layout:
    /// (seq_length, batch_size, num_heads * head_dim * 2)
    /// 
    /// and the attention weights following the layout:
    /// (batch_size, seq_length, seq_length)
    /// 
    /// the equivalent code would be:
    /// 
    /// tmp = mx.nd.reshape(queries_keys_values, shape=(0, 0, num_heads, 3, -1))
    /// v_proj = mx.nd.transpose(tmp[:,:,:,1,:], axes=(1, 2, 0, 3))
    /// v_proj = mx.nd.reshape(v_proj, shape=(-1, 0, 0), reverse=True)
    /// output = mx.nd.batch_dot(attention, v_proj, transpose_b=True)
    /// output = mx.nd.reshape(output, shape=(-1, num_heads, 0, 0), reverse=True)
    /// output = mx.nd.transpose(output, axes=(0, 2, 1, 3))
    /// output = mx.nd.reshape(output, shape=(0, 0, -1))
    /// 
    /// This Op is GPU only
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\contrib\transformer.cc:L277</summary>
    /// <param name="keysValues">Keys and values interleaved</param>
    /// <param name="attention">Attention maps</param>
    /// <param name="heads">Set number of heads</param>
    static member ContribInterleavedMatmulEncdecValatt(keysValues : NDArray, attention : NDArray, heads : int) =
        let creator = AtomicSymbolCreator.FromName "_contrib_interleaved_matmul_encdec_valatt"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg keysValues)) then keysValues.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg attention)) then attention.UnsafeHandle|]
                                                 [|"heads"|]
                                                 [|string heads|]
        outputs |> Array.map (fun h -> new NDArray(h))
    /// <summary>Compute the matrix multiplication between the projections of
    /// values and the attention weights in multihead attention use as encoder-decoder.
    /// 
    /// the inputs must be a tensor of interleaved projections of
    /// keys and values following the layout:
    /// (seq_length, batch_size, num_heads * head_dim * 2)
    /// 
    /// and the attention weights following the layout:
    /// (batch_size, seq_length, seq_length)
    /// 
    /// the equivalent code would be:
    /// 
    /// tmp = mx.nd.reshape(queries_keys_values, shape=(0, 0, num_heads, 3, -1))
    /// v_proj = mx.nd.transpose(tmp[:,:,:,1,:], axes=(1, 2, 0, 3))
    /// v_proj = mx.nd.reshape(v_proj, shape=(-1, 0, 0), reverse=True)
    /// output = mx.nd.batch_dot(attention, v_proj, transpose_b=True)
    /// output = mx.nd.reshape(output, shape=(-1, num_heads, 0, 0), reverse=True)
    /// output = mx.nd.transpose(output, axes=(0, 2, 1, 3))
    /// output = mx.nd.reshape(output, shape=(0, 0, -1))
    /// 
    /// This Op is GPU only
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\contrib\transformer.cc:L277</summary>
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="keysValues">Keys and values interleaved</param>
    /// <param name="attention">Attention maps</param>
    /// <param name="heads">Set number of heads</param>
    static member ContribInterleavedMatmulEncdecValatt(outputArray : NDArray seq, keysValues : NDArray, attention : NDArray, heads : int) =
        let creator = AtomicSymbolCreator.FromName "_contrib_interleaved_matmul_encdec_valatt"
        let names = [|"heads"|]
        let vals = [|string heads|]
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg keysValues)) then keysValues.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg attention)) then attention.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <summary>Compute the matrix multiplication between the projections of
    /// values and the attention weights in multihead attention use as encoder-decoder.
    /// 
    /// the inputs must be a tensor of interleaved projections of
    /// keys and values following the layout:
    /// (seq_length, batch_size, num_heads * head_dim * 2)
    /// 
    /// and the attention weights following the layout:
    /// (batch_size, seq_length, seq_length)
    /// 
    /// the equivalent code would be:
    /// 
    /// tmp = mx.nd.reshape(queries_keys_values, shape=(0, 0, num_heads, 3, -1))
    /// v_proj = mx.nd.transpose(tmp[:,:,:,1,:], axes=(1, 2, 0, 3))
    /// v_proj = mx.nd.reshape(v_proj, shape=(-1, 0, 0), reverse=True)
    /// output = mx.nd.batch_dot(attention, v_proj, transpose_b=True)
    /// output = mx.nd.reshape(output, shape=(-1, num_heads, 0, 0), reverse=True)
    /// output = mx.nd.transpose(output, axes=(0, 2, 1, 3))
    /// output = mx.nd.reshape(output, shape=(0, 0, -1))
    /// 
    /// This Op is GPU only
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\contrib\transformer.cc:L277</summary>
    /// <param name="keysValues">Keys and values interleaved</param>
    /// <param name="attention">Attention maps</param>
    /// <param name="heads">Set number of heads</param>
    static member ContribInterleavedMatmulEncdecValatt(keysValues : Symbol, attention : Symbol, heads : int) =
        ContribInterleavedMatmulEncdecValatt(keysValues, attention, heads)
    /// <summary>Compute the matrix multiplication between the projections of
    /// values and the attention weights in multihead attention use as encoder-decoder.
    /// 
    /// the inputs must be a tensor of interleaved projections of
    /// keys and values following the layout:
    /// (seq_length, batch_size, num_heads * head_dim * 2)
    /// 
    /// and the attention weights following the layout:
    /// (batch_size, seq_length, seq_length)
    /// 
    /// the equivalent code would be:
    /// 
    /// tmp = mx.nd.reshape(queries_keys_values, shape=(0, 0, num_heads, 3, -1))
    /// v_proj = mx.nd.transpose(tmp[:,:,:,1,:], axes=(1, 2, 0, 3))
    /// v_proj = mx.nd.reshape(v_proj, shape=(-1, 0, 0), reverse=True)
    /// output = mx.nd.batch_dot(attention, v_proj, transpose_b=True)
    /// output = mx.nd.reshape(output, shape=(-1, num_heads, 0, 0), reverse=True)
    /// output = mx.nd.transpose(output, axes=(0, 2, 1, 3))
    /// output = mx.nd.reshape(output, shape=(0, 0, -1))
    /// 
    /// This Op is GPU only
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\contrib\transformer.cc:L277</summary>
    /// <param name="heads">Set number of heads</param>
    /// <param name="keysValues">Keys and values interleaved</param>
    /// <param name="attention">Attention maps</param>
    static member ContribInterleavedMatmulEncdecValatt(heads : int, [<Optional>] ?keysValues : Symbol, [<Optional>] ?attention : Symbol) =
        ContribInterleavedMatmulEncdecValatt(heads, ?keysValues = keysValues, ?attention = attention)


    /// <summary>Rescale the input by the square root of the channel dimension.
    /// 
    ///    out = data / sqrt(data.shape[-1])
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\contrib\transformer.cc:L308</summary>
    /// <param name="data">The input array.</param>
    static member ContribDivSqrtDim(data : NDArray) =
        let creator = AtomicSymbolCreator.FromName "_contrib_div_sqrt_dim"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle|]
                                                 Array.empty
                                                 Array.empty
        (new NDArray(outputs.[0]))
    /// <summary>Rescale the input by the square root of the channel dimension.
    /// 
    ///    out = data / sqrt(data.shape[-1])
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\contrib\transformer.cc:L308</summary>
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="data">The input array.</param>
    static member ContribDivSqrtDim(outputArray : NDArray seq, data : NDArray) =
        let creator = AtomicSymbolCreator.FromName "_contrib_div_sqrt_dim"
        let names = Array.empty
        let vals = Array.empty
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <summary>Rescale the input by the square root of the channel dimension.
    /// 
    ///    out = data / sqrt(data.shape[-1])
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\contrib\transformer.cc:L308</summary>
    /// <param name="data">The input array.</param>
    static member ContribDivSqrtDim([<Optional>] ?data : Symbol) =
        ContribDivSqrtDim(?data = data)

    /// <summary>Run a for loop over an NDArray with user-defined computation
    /// 
    /// From:C:\Jenkins\workspace\mxnet\mxnet\src\operator\control_flow.cc:1090</summary>
    /// <param name="fn">Input graph.</param>
    /// <param name="data">The input arrays that include data arrays and states.</param>
    /// <param name="numArgs">Number of inputs.</param>
    /// <param name="numOutputs">The number of outputs of the subgraph.</param>
    /// <param name="numOutData">The number of output data of the subgraph.</param>
    /// <param name="inStateLocs">The locations of loop states among the inputs.</param>
    /// <param name="inDataLocs">The locations of input data among the inputs.</param>
    /// <param name="remainLocs">The locations of remaining data among the inputs.</param>
    static member Foreach(fn : NDArray, 
                          [<ParamArray>] data : NDArray[], 
                          numOutputs : int, 
                          numOutData : int, 
                          inStateLocs : int64 seq, 
                          inDataLocs : int64 seq, 
                          remainLocs : int64 seq) =
        let creator = AtomicSymbolCreator.FromName "_foreach"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 (data |> Array.map (fun x -> x.UnsafeHandle))
                                                 [|"num_args"; "num_outputs"; "num_out_data"; "in_state_locs"; "in_data_locs"; "remain_locs"|]
                                                 [|string data.Length; string numOutputs; string numOutData; string inStateLocs; string inDataLocs; string remainLocs|]
        outputs |> Array.map (fun h -> new NDArray(h))
    /// <summary>Run a for loop over an NDArray with user-defined computation
    /// 
    /// From:C:\Jenkins\workspace\mxnet\mxnet\src\operator\control_flow.cc:1090</summary>
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="fn">Input graph.</param>
    /// <param name="data">The input arrays that include data arrays and states.</param>
    /// <param name="numArgs">Number of inputs.</param>
    /// <param name="numOutputs">The number of outputs of the subgraph.</param>
    /// <param name="numOutData">The number of output data of the subgraph.</param>
    /// <param name="inStateLocs">The locations of loop states among the inputs.</param>
    /// <param name="inDataLocs">The locations of input data among the inputs.</param>
    /// <param name="remainLocs">The locations of remaining data among the inputs.</param>
    static member Foreach(outputArray : NDArray seq, 
                          fn : NDArray, 
                          [<ParamArray>] data : NDArray[], 
                          numOutputs : int, 
                          numOutData : int, 
                          inStateLocs : int64 seq, 
                          inDataLocs : int64 seq, 
                          remainLocs : int64 seq) =
        let creator = AtomicSymbolCreator.FromName "_foreach"
        let names = [|"num_args"; "num_outputs"; "num_out_data"; "in_state_locs"; "in_data_locs"; "remain_locs"|]
        let vals = [|string data.Length; string numOutputs; string numOutData; string inStateLocs; string inDataLocs; string remainLocs|]
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     (data |> Array.map (fun x -> x.UnsafeHandle))
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <summary>Run a for loop over an NDArray with user-defined computation
    /// 
    /// From:C:\Jenkins\workspace\mxnet\mxnet\src\operator\control_flow.cc:1090</summary>
    /// <param name="fn">Input graph.</param>
    /// <param name="data">The input arrays that include data arrays and states.</param>
    /// <param name="numOutputs">The number of outputs of the subgraph.</param>
    /// <param name="numOutData">The number of output data of the subgraph.</param>
    /// <param name="inStateLocs">The locations of loop states among the inputs.</param>
    /// <param name="inDataLocs">The locations of input data among the inputs.</param>
    /// <param name="remainLocs">The locations of remaining data among the inputs.</param>
    static member Foreach(fn : Symbol, data : Symbol seq, numOutputs : int, numOutData : int, inStateLocs : int64 seq, inDataLocs : int64 seq, remainLocs : int64 seq) =
        Foreach(fn, data, numOutputs, numOutData, inStateLocs, inDataLocs, remainLocs)
    /// <summary>Run a for loop over an NDArray with user-defined computation
    /// 
    /// From:C:\Jenkins\workspace\mxnet\mxnet\src\operator\control_flow.cc:1090</summary>
    /// <param name="numOutputs">The number of outputs of the subgraph.</param>
    /// <param name="numOutData">The number of output data of the subgraph.</param>
    /// <param name="inStateLocs">The locations of loop states among the inputs.</param>
    /// <param name="inDataLocs">The locations of input data among the inputs.</param>
    /// <param name="remainLocs">The locations of remaining data among the inputs.</param>
    /// <param name="fn">Input graph.</param>
    /// <param name="data">The input arrays that include data arrays and states.</param>
    static member Foreach(numOutputs : int, numOutData : int, inStateLocs : int64 seq, inDataLocs : int64 seq, remainLocs : int64 seq, [<Optional>] ?fn : Symbol, [<Optional>] ?data : Symbol seq) =
        Foreach(numOutputs, numOutData, inStateLocs, inDataLocs, remainLocs, ?fn = fn, ?data = data)


    /// <summary>Run a while loop over with user-defined condition and computation
    /// 
    /// From:C:\Jenkins\workspace\mxnet\mxnet\src\operator\control_flow.cc:1151</summary>
    /// <param name="cond">Input graph for the loop condition.</param>
    /// <param name="func">Input graph for the loop body.</param>
    /// <param name="data">The input arrays that include data arrays and states.</param>
    /// <param name="numArgs">Number of input arguments, including cond and func as two symbol inputs.</param>
    /// <param name="numOutputs">The number of outputs of the subgraph.</param>
    /// <param name="numOutData">The number of outputs from the function body.</param>
    /// <param name="maxIterations">Maximum number of iterations.</param>
    /// <param name="condInputLocs">The locations of cond&#39;s inputs in the given inputs.</param>
    /// <param name="funcInputLocs">The locations of func&#39;s inputs in the given inputs.</param>
    /// <param name="funcVarLocs">The locations of loop_vars among func&#39;s inputs.</param>
    static member WhileLoop(cond : NDArray, 
                            func : NDArray, 
                            [<ParamArray>] data : NDArray[], 
                            numOutputs : int, 
                            numOutData : int, 
                            maxIterations : int, 
                            condInputLocs : int64 seq, 
                            funcInputLocs : int64 seq, 
                            funcVarLocs : int64 seq) =
        let creator = AtomicSymbolCreator.FromName "_while_loop"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 (data |> Array.map (fun x -> x.UnsafeHandle))
                                                 [|"num_args"; "num_outputs"; "num_out_data"; "max_iterations"; "cond_input_locs"; "func_input_locs"; "func_var_locs"|]
                                                 [|string data.Length; string numOutputs; string numOutData; string maxIterations; string condInputLocs; string funcInputLocs; string funcVarLocs|]
        outputs |> Array.map (fun h -> new NDArray(h))
    /// <summary>Run a while loop over with user-defined condition and computation
    /// 
    /// From:C:\Jenkins\workspace\mxnet\mxnet\src\operator\control_flow.cc:1151</summary>
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="cond">Input graph for the loop condition.</param>
    /// <param name="func">Input graph for the loop body.</param>
    /// <param name="data">The input arrays that include data arrays and states.</param>
    /// <param name="numArgs">Number of input arguments, including cond and func as two symbol inputs.</param>
    /// <param name="numOutputs">The number of outputs of the subgraph.</param>
    /// <param name="numOutData">The number of outputs from the function body.</param>
    /// <param name="maxIterations">Maximum number of iterations.</param>
    /// <param name="condInputLocs">The locations of cond&#39;s inputs in the given inputs.</param>
    /// <param name="funcInputLocs">The locations of func&#39;s inputs in the given inputs.</param>
    /// <param name="funcVarLocs">The locations of loop_vars among func&#39;s inputs.</param>
    static member WhileLoop(outputArray : NDArray seq, 
                            cond : NDArray, 
                            func : NDArray, 
                            [<ParamArray>] data : NDArray[], 
                            numOutputs : int, 
                            numOutData : int, 
                            maxIterations : int, 
                            condInputLocs : int64 seq, 
                            funcInputLocs : int64 seq, 
                            funcVarLocs : int64 seq) =
        let creator = AtomicSymbolCreator.FromName "_while_loop"
        let names = [|"num_args"; "num_outputs"; "num_out_data"; "max_iterations"; "cond_input_locs"; "func_input_locs"; "func_var_locs"|]
        let vals = [|string data.Length; string numOutputs; string numOutData; string maxIterations; string condInputLocs; string funcInputLocs; string funcVarLocs|]
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     (data |> Array.map (fun x -> x.UnsafeHandle))
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <summary>Run a while loop over with user-defined condition and computation
    /// 
    /// From:C:\Jenkins\workspace\mxnet\mxnet\src\operator\control_flow.cc:1151</summary>
    /// <param name="cond">Input graph for the loop condition.</param>
    /// <param name="func">Input graph for the loop body.</param>
    /// <param name="data">The input arrays that include data arrays and states.</param>
    /// <param name="numOutputs">The number of outputs of the subgraph.</param>
    /// <param name="numOutData">The number of outputs from the function body.</param>
    /// <param name="maxIterations">Maximum number of iterations.</param>
    /// <param name="condInputLocs">The locations of cond&#39;s inputs in the given inputs.</param>
    /// <param name="funcInputLocs">The locations of func&#39;s inputs in the given inputs.</param>
    /// <param name="funcVarLocs">The locations of loop_vars among func&#39;s inputs.</param>
    static member WhileLoop(cond : Symbol, func : Symbol, data : Symbol seq, numOutputs : int, numOutData : int, maxIterations : int, condInputLocs : int64 seq, funcInputLocs : int64 seq, funcVarLocs : int64 seq) =
        WhileLoop(cond, func, data, numOutputs, numOutData, maxIterations, condInputLocs, funcInputLocs, funcVarLocs)
    /// <summary>Run a while loop over with user-defined condition and computation
    /// 
    /// From:C:\Jenkins\workspace\mxnet\mxnet\src\operator\control_flow.cc:1151</summary>
    /// <param name="numOutputs">The number of outputs of the subgraph.</param>
    /// <param name="numOutData">The number of outputs from the function body.</param>
    /// <param name="maxIterations">Maximum number of iterations.</param>
    /// <param name="condInputLocs">The locations of cond&#39;s inputs in the given inputs.</param>
    /// <param name="funcInputLocs">The locations of func&#39;s inputs in the given inputs.</param>
    /// <param name="funcVarLocs">The locations of loop_vars among func&#39;s inputs.</param>
    /// <param name="cond">Input graph for the loop condition.</param>
    /// <param name="func">Input graph for the loop body.</param>
    /// <param name="data">The input arrays that include data arrays and states.</param>
    static member WhileLoop(numOutputs : int, numOutData : int, maxIterations : int, condInputLocs : int64 seq, funcInputLocs : int64 seq, funcVarLocs : int64 seq, [<Optional>] ?cond : Symbol, [<Optional>] ?func : Symbol, [<Optional>] ?data : Symbol seq) =
        WhileLoop(numOutputs, numOutData, maxIterations, condInputLocs, funcInputLocs, funcVarLocs, ?cond = cond, ?func = func, ?data = data)


    /// <summary>Run a if-then-else using user-defined condition and computation
    /// 
    /// From:C:\Jenkins\workspace\mxnet\mxnet\src\operator\control_flow.cc:1212</summary>
    /// <param name="cond">Input graph for the condition.</param>
    /// <param name="thenBranch">Input graph for the then branch.</param>
    /// <param name="elseBranch">Input graph for the else branch.</param>
    /// <param name="data">The input arrays that include data arrays and states.</param>
    /// <param name="numArgs">Number of input arguments, including cond, then and else as three symbol inputs.</param>
    /// <param name="numOutputs">The number of outputs of the subgraph.</param>
    /// <param name="condInputLocs">The locations of cond&#39;s inputs in the given inputs.</param>
    /// <param name="thenInputLocs">The locations of then&#39;s inputs in the given inputs.</param>
    /// <param name="elseInputLocs">The locations of else&#39;s inputs in the given inputs.</param>
    static member Cond(cond : NDArray, 
                       thenBranch : NDArray, 
                       elseBranch : NDArray, 
                       [<ParamArray>] data : NDArray[], 
                       numOutputs : int, 
                       condInputLocs : int64 seq, 
                       thenInputLocs : int64 seq, 
                       elseInputLocs : int64 seq) =
        let creator = AtomicSymbolCreator.FromName "_cond"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 (data |> Array.map (fun x -> x.UnsafeHandle))
                                                 [|"num_args"; "num_outputs"; "cond_input_locs"; "then_input_locs"; "else_input_locs"|]
                                                 [|string data.Length; string numOutputs; string condInputLocs; string thenInputLocs; string elseInputLocs|]
        outputs |> Array.map (fun h -> new NDArray(h))
    /// <summary>Run a if-then-else using user-defined condition and computation
    /// 
    /// From:C:\Jenkins\workspace\mxnet\mxnet\src\operator\control_flow.cc:1212</summary>
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="cond">Input graph for the condition.</param>
    /// <param name="thenBranch">Input graph for the then branch.</param>
    /// <param name="elseBranch">Input graph for the else branch.</param>
    /// <param name="data">The input arrays that include data arrays and states.</param>
    /// <param name="numArgs">Number of input arguments, including cond, then and else as three symbol inputs.</param>
    /// <param name="numOutputs">The number of outputs of the subgraph.</param>
    /// <param name="condInputLocs">The locations of cond&#39;s inputs in the given inputs.</param>
    /// <param name="thenInputLocs">The locations of then&#39;s inputs in the given inputs.</param>
    /// <param name="elseInputLocs">The locations of else&#39;s inputs in the given inputs.</param>
    static member Cond(outputArray : NDArray seq, 
                       cond : NDArray, 
                       thenBranch : NDArray, 
                       elseBranch : NDArray, 
                       [<ParamArray>] data : NDArray[], 
                       numOutputs : int, 
                       condInputLocs : int64 seq, 
                       thenInputLocs : int64 seq, 
                       elseInputLocs : int64 seq) =
        let creator = AtomicSymbolCreator.FromName "_cond"
        let names = [|"num_args"; "num_outputs"; "cond_input_locs"; "then_input_locs"; "else_input_locs"|]
        let vals = [|string data.Length; string numOutputs; string condInputLocs; string thenInputLocs; string elseInputLocs|]
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     (data |> Array.map (fun x -> x.UnsafeHandle))
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <summary>Run a if-then-else using user-defined condition and computation
    /// 
    /// From:C:\Jenkins\workspace\mxnet\mxnet\src\operator\control_flow.cc:1212</summary>
    /// <param name="cond">Input graph for the condition.</param>
    /// <param name="thenBranch">Input graph for the then branch.</param>
    /// <param name="elseBranch">Input graph for the else branch.</param>
    /// <param name="data">The input arrays that include data arrays and states.</param>
    /// <param name="numOutputs">The number of outputs of the subgraph.</param>
    /// <param name="condInputLocs">The locations of cond&#39;s inputs in the given inputs.</param>
    /// <param name="thenInputLocs">The locations of then&#39;s inputs in the given inputs.</param>
    /// <param name="elseInputLocs">The locations of else&#39;s inputs in the given inputs.</param>
    static member Cond(cond : Symbol, thenBranch : Symbol, elseBranch : Symbol, data : Symbol seq, numOutputs : int, condInputLocs : int64 seq, thenInputLocs : int64 seq, elseInputLocs : int64 seq) =
        Cond(cond, thenBranch, elseBranch, data, numOutputs, condInputLocs, thenInputLocs, elseInputLocs)
    /// <summary>Run a if-then-else using user-defined condition and computation
    /// 
    /// From:C:\Jenkins\workspace\mxnet\mxnet\src\operator\control_flow.cc:1212</summary>
    /// <param name="numOutputs">The number of outputs of the subgraph.</param>
    /// <param name="condInputLocs">The locations of cond&#39;s inputs in the given inputs.</param>
    /// <param name="thenInputLocs">The locations of then&#39;s inputs in the given inputs.</param>
    /// <param name="elseInputLocs">The locations of else&#39;s inputs in the given inputs.</param>
    /// <param name="cond">Input graph for the condition.</param>
    /// <param name="thenBranch">Input graph for the then branch.</param>
    /// <param name="elseBranch">Input graph for the else branch.</param>
    /// <param name="data">The input arrays that include data arrays and states.</param>
    static member Cond(numOutputs : int, condInputLocs : int64 seq, thenInputLocs : int64 seq, elseInputLocs : int64 seq, [<Optional>] ?cond : Symbol, [<Optional>] ?thenBranch : Symbol, [<Optional>] ?elseBranch : Symbol, [<Optional>] ?data : Symbol seq) =
        Cond(numOutputs, condInputLocs, thenInputLocs, elseInputLocs, ?cond = cond, ?thenBranch = thenBranch, ?elseBranch = elseBranch, ?data = data)


    /// <summary>Apply a custom operator implemented in a frontend language (like Python).
    /// 
    /// Custom operators should override required methods like `forward` and `backward`.
    /// The custom operator must be registered before it can be used.
    /// Please check the tutorial here: https://mxnet.incubator.apache.org/api/faq/new_op
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\custom\custom.cc:L547</summary>
    /// <param name="data">Input data for the custom operator.</param>
    /// <param name="opType">Name of the custom operator. This is the name that is passed to `mx.operator.register` to register the operator.</param>
    static member Custom([<ParamArray>] data : NDArray[], opType : string) =
        let creator = AtomicSymbolCreator.FromName "Custom"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 (data |> Array.map (fun x -> x.UnsafeHandle))
                                                 [|"op_type"|]
                                                 [|opType|]
        outputs |> Array.map (fun h -> new NDArray(h))
    /// <summary>Apply a custom operator implemented in a frontend language (like Python).
    /// 
    /// Custom operators should override required methods like `forward` and `backward`.
    /// The custom operator must be registered before it can be used.
    /// Please check the tutorial here: https://mxnet.incubator.apache.org/api/faq/new_op
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\custom\custom.cc:L547</summary>
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="data">Input data for the custom operator.</param>
    /// <param name="opType">Name of the custom operator. This is the name that is passed to `mx.operator.register` to register the operator.</param>
    static member Custom(outputArray : NDArray seq, [<ParamArray>] data : NDArray[], opType : string) =
        let creator = AtomicSymbolCreator.FromName "Custom"
        let names = [|"op_type"|]
        let vals = [|opType|]
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     (data |> Array.map (fun x -> x.UnsafeHandle))
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <summary>Apply a custom operator implemented in a frontend language (like Python).
    /// 
    /// Custom operators should override required methods like `forward` and `backward`.
    /// The custom operator must be registered before it can be used.
    /// Please check the tutorial here: https://mxnet.incubator.apache.org/api/faq/new_op
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\custom\custom.cc:L547</summary>
    /// <param name="data">Input data for the custom operator.</param>
    /// <param name="opType">Name of the custom operator. This is the name that is passed to `mx.operator.register` to register the operator.</param>
    static member Custom(data : Symbol seq, opType : string) =
        Custom(data, opType)
    /// <summary>Apply a custom operator implemented in a frontend language (like Python).
    /// 
    /// Custom operators should override required methods like `forward` and `backward`.
    /// The custom operator must be registered before it can be used.
    /// Please check the tutorial here: https://mxnet.incubator.apache.org/api/faq/new_op
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\custom\custom.cc:L547</summary>
    /// <param name="opType">Name of the custom operator. This is the name that is passed to `mx.operator.register` to register the operator.</param>
    /// <param name="data">Input data for the custom operator.</param>
    static member Custom(opType : string, [<Optional>] ?data : Symbol seq) =
        Custom(opType, ?data = data)
    /// <summary>Apply a custom operator implemented in a frontend language (like Python).
    /// 
    /// Custom operators should override required methods like `forward` and `backward`.
    /// The custom operator must be registered before it can be used.
    /// Please check the tutorial here: https://mxnet.incubator.apache.org/api/faq/new_op
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\custom\custom.cc:L547</summary>
    /// <param name="opType">Name of the custom operator. This is the name that is passed to `mx.operator.register` to register the operator.</param>
    /// <param name="data">Input data for the custom operator.</param>
    static member Custom(opType : string, [<ParamArray>] data : Symbol[]) =
        Custom(opType, data)


    /// <param name="data">Data</param>
    static member FusedOp([<ParamArray>] data : NDArray[]) =
        let creator = AtomicSymbolCreator.FromName "_FusedOp"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 (data |> Array.map (fun x -> x.UnsafeHandle))
                                                 Array.empty
                                                 Array.empty
        outputs |> Array.map (fun h -> new NDArray(h))
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="data">Data</param>
    static member FusedOp(outputArray : NDArray seq, [<ParamArray>] data : NDArray[]) =
        let creator = AtomicSymbolCreator.FromName "_FusedOp"
        let names = Array.empty
        let vals = Array.empty
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     (data |> Array.map (fun x -> x.UnsafeHandle))
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <param name="data">Data</param>
    static member FusedOp([<ParamArray>] data : Symbol[]) =
        FusedOp(data)

    static member FusedOpHelperNDArray() =
        let creator = AtomicSymbolCreator.FromName "_FusedOpHelper"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 Array.empty
                                                 Array.empty
                                                 Array.empty
        outputs |> Array.map (fun h -> new NDArray(h))
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    static member FusedOpHelper(outputArray : NDArray seq) =
        let creator = AtomicSymbolCreator.FromName "_FusedOpHelper"
        let names = Array.empty
        let vals = Array.empty
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     Array.empty
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    static member FusedOpHelper() =
        FusedOpHelper()

    static member FusedOpOutHelperNDArray() =
        let creator = AtomicSymbolCreator.FromName "_FusedOpOutHelper"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 Array.empty
                                                 Array.empty
                                                 Array.empty
        outputs |> Array.map (fun h -> new NDArray(h))
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    static member FusedOpOutHelper(outputArray : NDArray seq) =
        let creator = AtomicSymbolCreator.FromName "_FusedOpOutHelper"
        let names = Array.empty
        let vals = Array.empty
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     Array.empty
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    static member FusedOpOutHelper() =
        FusedOpOutHelper()

    /// <summary>Apply a sparse regularization to the output a sigmoid activation function.</summary>
    /// <param name="data">Input data.</param>
    /// <param name="sparsenessTarget">The sparseness target</param>
    /// <param name="penalty">The tradeoff parameter for the sparseness penalty</param>
    /// <param name="momentum">The momentum for running average</param>
    static member IdentityAttachKLSparseReg(data : NDArray, [<Optional; DefaultParameterValue(0.100000001)>] sparsenessTarget : float, [<Optional; DefaultParameterValue(0.00100000005)>] penalty : float, [<Optional; DefaultParameterValue(0.899999976)>] momentum : float) =
        let creator = AtomicSymbolCreator.FromName "IdentityAttachKLSparseReg"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle|]
                                                 [|"sparseness_target"; "penalty"; "momentum"|]
                                                 [|string sparsenessTarget; string penalty; string momentum|]
        outputs |> Array.map (fun h -> new NDArray(h))
    /// <summary>Apply a sparse regularization to the output a sigmoid activation function.</summary>
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="data">Input data.</param>
    /// <param name="sparsenessTarget">The sparseness target</param>
    /// <param name="penalty">The tradeoff parameter for the sparseness penalty</param>
    /// <param name="momentum">The momentum for running average</param>
    static member IdentityAttachKLSparseReg(outputArray : NDArray seq, data : NDArray, [<Optional; DefaultParameterValue(0.100000001)>] sparsenessTarget : float, [<Optional; DefaultParameterValue(0.00100000005)>] penalty : float, [<Optional; DefaultParameterValue(0.899999976)>] momentum : float) =
        let creator = AtomicSymbolCreator.FromName "IdentityAttachKLSparseReg"
        let names = [|"sparseness_target"; "penalty"; "momentum"|]
        let vals = [|string sparsenessTarget; string penalty; string momentum|]
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <summary>Apply a sparse regularization to the output a sigmoid activation function.</summary>
    /// <param name="data">Input data.</param>
    /// <param name="sparsenessTarget">The sparseness target</param>
    /// <param name="penalty">The tradeoff parameter for the sparseness penalty</param>
    /// <param name="momentum">The momentum for running average</param>
    static member IdentityAttachKLSparseReg([<Optional>] ?data : Symbol, [<Optional>] ?sparsenessTarget : float, [<Optional>] ?penalty : float, [<Optional>] ?momentum : float) =
        IdentityAttachKLSparseReg(?data = data, ?sparsenessTarget = sparsenessTarget, ?penalty = penalty, ?momentum = momentum)

    /// <summary>Crop an image NDArray of shape (H x W x C) or (N x H x W x C) 
    /// to the given size.
    /// Example:
    ///     .. code-block:: python
    ///         image = mx.nd.random.uniform(0, 255, (4, 2, 3)).astype(dtype=np.uint8)
    ///         mx.nd.image.crop(image, 1, 1, 2, 2)
    ///             [[[144  34   4]
    ///               [ 82 157  38]]
    /// 
    ///              [[156 111 230]
    ///               [177  25  15]]]
    ///             &lt;NDArray 2x2x3 @cpu(0)&gt;
    ///         image = mx.nd.random.uniform(0, 255, (2, 4, 2, 3)).astype(dtype=np.uint8)
    ///         mx.nd.image.crop(image, 1, 1, 2, 2)            
    ///             [[[[ 35 198  50]
    ///                [242  94 168]]
    /// 
    ///               [[223 119 129]
    ///                [249  14 154]]]
    /// 
    /// 
    ///               [[[137 215 106]
    ///                 [ 79 174 133]]
    /// 
    ///                [[116 142 109]
    ///                 [ 35 239  50]]]]
    ///             &lt;NDArray 2x2x2x3 @cpu(0)&gt;
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\image\crop.cc:L66</summary>
    /// <param name="data">The input.</param>
    /// <param name="x">Left boundary of the cropping area.</param>
    /// <param name="y">Top boundary of the cropping area.</param>
    /// <param name="width">Width of the cropping area.</param>
    /// <param name="height">Height of the cropping area.</param>
    static member ImageCrop(data : NDArray, 
                            x : int, 
                            y : int, 
                            width : int, 
                            height : int) =
        let creator = AtomicSymbolCreator.FromName "_image_crop"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle|]
                                                 [|"x"; "y"; "width"; "height"|]
                                                 [|string x; string y; string width; string height|]
        (new NDArray(outputs.[0]))
    /// <summary>Crop an image NDArray of shape (H x W x C) or (N x H x W x C) 
    /// to the given size.
    /// Example:
    ///     .. code-block:: python
    ///         image = mx.nd.random.uniform(0, 255, (4, 2, 3)).astype(dtype=np.uint8)
    ///         mx.nd.image.crop(image, 1, 1, 2, 2)
    ///             [[[144  34   4]
    ///               [ 82 157  38]]
    /// 
    ///              [[156 111 230]
    ///               [177  25  15]]]
    ///             &lt;NDArray 2x2x3 @cpu(0)&gt;
    ///         image = mx.nd.random.uniform(0, 255, (2, 4, 2, 3)).astype(dtype=np.uint8)
    ///         mx.nd.image.crop(image, 1, 1, 2, 2)            
    ///             [[[[ 35 198  50]
    ///                [242  94 168]]
    /// 
    ///               [[223 119 129]
    ///                [249  14 154]]]
    /// 
    /// 
    ///               [[[137 215 106]
    ///                 [ 79 174 133]]
    /// 
    ///                [[116 142 109]
    ///                 [ 35 239  50]]]]
    ///             &lt;NDArray 2x2x2x3 @cpu(0)&gt;
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\image\crop.cc:L66</summary>
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="data">The input.</param>
    /// <param name="x">Left boundary of the cropping area.</param>
    /// <param name="y">Top boundary of the cropping area.</param>
    /// <param name="width">Width of the cropping area.</param>
    /// <param name="height">Height of the cropping area.</param>
    static member ImageCrop(outputArray : NDArray seq, 
                            data : NDArray, 
                            x : int, 
                            y : int, 
                            width : int, 
                            height : int) =
        let creator = AtomicSymbolCreator.FromName "_image_crop"
        let names = [|"x"; "y"; "width"; "height"|]
        let vals = [|string x; string y; string width; string height|]
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <summary>Crop an image NDArray of shape (H x W x C) or (N x H x W x C) 
    /// to the given size.
    /// Example:
    ///     .. code-block:: python
    ///         image = mx.nd.random.uniform(0, 255, (4, 2, 3)).astype(dtype=np.uint8)
    ///         mx.nd.image.crop(image, 1, 1, 2, 2)
    ///             [[[144  34   4]
    ///               [ 82 157  38]]
    /// 
    ///              [[156 111 230]
    ///               [177  25  15]]]
    ///             &lt;NDArray 2x2x3 @cpu(0)&gt;
    ///         image = mx.nd.random.uniform(0, 255, (2, 4, 2, 3)).astype(dtype=np.uint8)
    ///         mx.nd.image.crop(image, 1, 1, 2, 2)            
    ///             [[[[ 35 198  50]
    ///                [242  94 168]]
    /// 
    ///               [[223 119 129]
    ///                [249  14 154]]]
    /// 
    /// 
    ///               [[[137 215 106]
    ///                 [ 79 174 133]]
    /// 
    ///                [[116 142 109]
    ///                 [ 35 239  50]]]]
    ///             &lt;NDArray 2x2x2x3 @cpu(0)&gt;
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\image\crop.cc:L66</summary>
    /// <param name="data">The input.</param>
    /// <param name="x">Left boundary of the cropping area.</param>
    /// <param name="y">Top boundary of the cropping area.</param>
    /// <param name="width">Width of the cropping area.</param>
    /// <param name="height">Height of the cropping area.</param>
    static member ImageCrop(data : Symbol, x : int, y : int, width : int, height : int) =
        ImageCrop(data, x, y, width, height)
    /// <summary>Crop an image NDArray of shape (H x W x C) or (N x H x W x C) 
    /// to the given size.
    /// Example:
    ///     .. code-block:: python
    ///         image = mx.nd.random.uniform(0, 255, (4, 2, 3)).astype(dtype=np.uint8)
    ///         mx.nd.image.crop(image, 1, 1, 2, 2)
    ///             [[[144  34   4]
    ///               [ 82 157  38]]
    /// 
    ///              [[156 111 230]
    ///               [177  25  15]]]
    ///             &lt;NDArray 2x2x3 @cpu(0)&gt;
    ///         image = mx.nd.random.uniform(0, 255, (2, 4, 2, 3)).astype(dtype=np.uint8)
    ///         mx.nd.image.crop(image, 1, 1, 2, 2)            
    ///             [[[[ 35 198  50]
    ///                [242  94 168]]
    /// 
    ///               [[223 119 129]
    ///                [249  14 154]]]
    /// 
    /// 
    ///               [[[137 215 106]
    ///                 [ 79 174 133]]
    /// 
    ///                [[116 142 109]
    ///                 [ 35 239  50]]]]
    ///             &lt;NDArray 2x2x2x3 @cpu(0)&gt;
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\image\crop.cc:L66</summary>
    /// <param name="x">Left boundary of the cropping area.</param>
    /// <param name="y">Top boundary of the cropping area.</param>
    /// <param name="width">Width of the cropping area.</param>
    /// <param name="height">Height of the cropping area.</param>
    /// <param name="data">The input.</param>
    static member ImageCrop(x : int, y : int, width : int, height : int, [<Optional>] ?data : Symbol) =
        ImageCrop(x, y, width, height, ?data = data)


    /// <summary>Converts an image NDArray of shape (H x W x C) or (N x H x W x C) 
    /// with values in the range [0, 255] to a tensor NDArray of shape (C x H x W) or (N x C x H x W)
    /// with values in the range [0, 1]
    /// 
    /// Example:
    ///     .. code-block:: python
    ///         image = mx.nd.random.uniform(0, 255, (4, 2, 3)).astype(dtype=np.uint8)
    ///         to_tensor(image)
    ///             [[[ 0.85490197  0.72156864]
    ///               [ 0.09019608  0.74117649]
    ///               [ 0.61960787  0.92941177]
    ///               [ 0.96470588  0.1882353 ]]
    ///              [[ 0.6156863   0.73725492]
    ///               [ 0.46666667  0.98039216]
    ///               [ 0.44705883  0.45490196]
    ///               [ 0.01960784  0.8509804 ]]
    ///              [[ 0.39607844  0.03137255]
    ///               [ 0.72156864  0.52941179]
    ///               [ 0.16470589  0.7647059 ]
    ///               [ 0.05490196  0.70588237]]]
    ///              &lt;NDArray 3x4x2 @cpu(0)&gt;
    /// 
    ///         image = mx.nd.random.uniform(0, 255, (2, 4, 2, 3)).astype(dtype=np.uint8)
    ///         to_tensor(image)
    ///             [[[[0.11764706 0.5803922 ]
    ///                [0.9411765  0.10588235]
    ///                [0.2627451  0.73333335]
    ///                [0.5647059  0.32156864]]
    ///               [[0.7176471  0.14117648]
    ///                [0.75686276 0.4117647 ]
    ///                [0.18431373 0.45490196]
    ///                [0.13333334 0.6156863 ]]
    ///               [[0.6392157  0.5372549 ]
    ///                [0.52156866 0.47058824]
    ///                [0.77254903 0.21568628]
    ///                [0.01568628 0.14901961]]]
    ///              [[[0.6117647  0.38431373]
    ///                [0.6784314  0.6117647 ]
    ///                [0.69411767 0.96862745]
    ///                [0.67058825 0.35686275]]
    ///               [[0.21960784 0.9411765 ]
    ///                [0.44705883 0.43529412]
    ///                [0.09803922 0.6666667 ]
    ///                [0.16862746 0.1254902 ]]
    ///               [[0.6156863  0.9019608 ]
    ///                [0.35686275 0.9019608 ]
    ///                [0.05882353 0.6509804 ]
    ///                [0.20784314 0.7490196 ]]]]
    ///             &lt;NDArray 2x3x4x2 @cpu(0)&gt;
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\image\image_random.cc:L92</summary>
    /// <param name="data">Input ndarray</param>
    static member ImageToTensor(data : NDArray) =
        let creator = AtomicSymbolCreator.FromName "_image_to_tensor"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle|]
                                                 Array.empty
                                                 Array.empty
        (new NDArray(outputs.[0]))
    /// <summary>Converts an image NDArray of shape (H x W x C) or (N x H x W x C) 
    /// with values in the range [0, 255] to a tensor NDArray of shape (C x H x W) or (N x C x H x W)
    /// with values in the range [0, 1]
    /// 
    /// Example:
    ///     .. code-block:: python
    ///         image = mx.nd.random.uniform(0, 255, (4, 2, 3)).astype(dtype=np.uint8)
    ///         to_tensor(image)
    ///             [[[ 0.85490197  0.72156864]
    ///               [ 0.09019608  0.74117649]
    ///               [ 0.61960787  0.92941177]
    ///               [ 0.96470588  0.1882353 ]]
    ///              [[ 0.6156863   0.73725492]
    ///               [ 0.46666667  0.98039216]
    ///               [ 0.44705883  0.45490196]
    ///               [ 0.01960784  0.8509804 ]]
    ///              [[ 0.39607844  0.03137255]
    ///               [ 0.72156864  0.52941179]
    ///               [ 0.16470589  0.7647059 ]
    ///               [ 0.05490196  0.70588237]]]
    ///              &lt;NDArray 3x4x2 @cpu(0)&gt;
    /// 
    ///         image = mx.nd.random.uniform(0, 255, (2, 4, 2, 3)).astype(dtype=np.uint8)
    ///         to_tensor(image)
    ///             [[[[0.11764706 0.5803922 ]
    ///                [0.9411765  0.10588235]
    ///                [0.2627451  0.73333335]
    ///                [0.5647059  0.32156864]]
    ///               [[0.7176471  0.14117648]
    ///                [0.75686276 0.4117647 ]
    ///                [0.18431373 0.45490196]
    ///                [0.13333334 0.6156863 ]]
    ///               [[0.6392157  0.5372549 ]
    ///                [0.52156866 0.47058824]
    ///                [0.77254903 0.21568628]
    ///                [0.01568628 0.14901961]]]
    ///              [[[0.6117647  0.38431373]
    ///                [0.6784314  0.6117647 ]
    ///                [0.69411767 0.96862745]
    ///                [0.67058825 0.35686275]]
    ///               [[0.21960784 0.9411765 ]
    ///                [0.44705883 0.43529412]
    ///                [0.09803922 0.6666667 ]
    ///                [0.16862746 0.1254902 ]]
    ///               [[0.6156863  0.9019608 ]
    ///                [0.35686275 0.9019608 ]
    ///                [0.05882353 0.6509804 ]
    ///                [0.20784314 0.7490196 ]]]]
    ///             &lt;NDArray 2x3x4x2 @cpu(0)&gt;
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\image\image_random.cc:L92</summary>
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="data">Input ndarray</param>
    static member ImageToTensor(outputArray : NDArray seq, data : NDArray) =
        let creator = AtomicSymbolCreator.FromName "_image_to_tensor"
        let names = Array.empty
        let vals = Array.empty
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <summary>Converts an image NDArray of shape (H x W x C) or (N x H x W x C) 
    /// with values in the range [0, 255] to a tensor NDArray of shape (C x H x W) or (N x C x H x W)
    /// with values in the range [0, 1]
    /// 
    /// Example:
    ///     .. code-block:: python
    ///         image = mx.nd.random.uniform(0, 255, (4, 2, 3)).astype(dtype=np.uint8)
    ///         to_tensor(image)
    ///             [[[ 0.85490197  0.72156864]
    ///               [ 0.09019608  0.74117649]
    ///               [ 0.61960787  0.92941177]
    ///               [ 0.96470588  0.1882353 ]]
    ///              [[ 0.6156863   0.73725492]
    ///               [ 0.46666667  0.98039216]
    ///               [ 0.44705883  0.45490196]
    ///               [ 0.01960784  0.8509804 ]]
    ///              [[ 0.39607844  0.03137255]
    ///               [ 0.72156864  0.52941179]
    ///               [ 0.16470589  0.7647059 ]
    ///               [ 0.05490196  0.70588237]]]
    ///              &lt;NDArray 3x4x2 @cpu(0)&gt;
    /// 
    ///         image = mx.nd.random.uniform(0, 255, (2, 4, 2, 3)).astype(dtype=np.uint8)
    ///         to_tensor(image)
    ///             [[[[0.11764706 0.5803922 ]
    ///                [0.9411765  0.10588235]
    ///                [0.2627451  0.73333335]
    ///                [0.5647059  0.32156864]]
    ///               [[0.7176471  0.14117648]
    ///                [0.75686276 0.4117647 ]
    ///                [0.18431373 0.45490196]
    ///                [0.13333334 0.6156863 ]]
    ///               [[0.6392157  0.5372549 ]
    ///                [0.52156866 0.47058824]
    ///                [0.77254903 0.21568628]
    ///                [0.01568628 0.14901961]]]
    ///              [[[0.6117647  0.38431373]
    ///                [0.6784314  0.6117647 ]
    ///                [0.69411767 0.96862745]
    ///                [0.67058825 0.35686275]]
    ///               [[0.21960784 0.9411765 ]
    ///                [0.44705883 0.43529412]
    ///                [0.09803922 0.6666667 ]
    ///                [0.16862746 0.1254902 ]]
    ///               [[0.6156863  0.9019608 ]
    ///                [0.35686275 0.9019608 ]
    ///                [0.05882353 0.6509804 ]
    ///                [0.20784314 0.7490196 ]]]]
    ///             &lt;NDArray 2x3x4x2 @cpu(0)&gt;
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\image\image_random.cc:L92</summary>
    /// <param name="data">Input ndarray</param>
    static member ImageToTensor([<Optional>] ?data : Symbol) =
        ImageToTensor(?data = data)

    /// <summary>Normalize an tensor of shape (C x H x W) or (N x C x H x W) with mean and
    ///     standard deviation.
    /// 
    ///     Given mean `(m1, ..., mn)` and std `(s\ :sub:`1`\ , ..., s\ :sub:`n`)` for `n` channels,
    ///     this transform normalizes each channel of the input tensor with:
    /// 
    /// .. math::
    /// 
    ///         output[i] = (input[i] - m\ :sub:`i`\ ) / s\ :sub:`i`
    /// 
    ///     If mean or std is scalar, the same value will be applied to all channels.
    /// 
    ///     Default value for mean is 0.0 and stand deviation is 1.0.
    /// 
    /// Example:
    /// 
    ///     .. code-block:: python
    ///         image = mx.nd.random.uniform(0, 1, (3, 4, 2))
    ///         normalize(image, mean=(0, 1, 2), std=(3, 2, 1))
    ///             [[[ 0.18293785  0.19761486]
    ///               [ 0.23839645  0.28142193]
    ///               [ 0.20092112  0.28598186]
    ///               [ 0.18162774  0.28241724]]
    ///              [[-0.2881726  -0.18821815]
    ///               [-0.17705294 -0.30780914]
    ///               [-0.2812064  -0.3512327 ]
    ///               [-0.05411351 -0.4716435 ]]
    ///              [[-1.0363373  -1.7273437 ]
    ///               [-1.6165586  -1.5223348 ]
    ///               [-1.208275   -1.1878313 ]
    ///               [-1.4711051  -1.5200229 ]]]
    ///             &lt;NDArray 3x4x2 @cpu(0)&gt;
    /// 
    ///         image = mx.nd.random.uniform(0, 1, (2, 3, 4, 2))
    ///         normalize(image, mean=(0, 1, 2), std=(3, 2, 1))
    ///             [[[[ 0.18934818  0.13092826]
    ///                [ 0.3085322   0.27869293]
    ///                [ 0.02367868  0.11246539]
    ///                [ 0.0290431   0.2160573 ]]
    ///               [[-0.4898908  -0.31587923]
    ///                [-0.08369008 -0.02142242]
    ///                [-0.11092162 -0.42982462]
    ///                [-0.06499392 -0.06495637]]
    ///               [[-1.0213816  -1.526392  ]
    ///                [-1.2008414  -1.1990893 ]
    ///                [-1.5385206  -1.4795225 ]
    ///                [-1.2194707  -1.3211205 ]]]
    ///              [[[ 0.03942481  0.24021089]
    ///                [ 0.21330701  0.1940066 ]
    ///                [ 0.04778443  0.17912441]
    ///                [ 0.31488964  0.25287187]]
    ///               [[-0.23907584 -0.4470462 ]
    ///                [-0.29266903 -0.2631998 ]
    ///                [-0.3677222  -0.40683383]
    ///                [-0.11288315 -0.13154092]]
    ///               [[-1.5438497  -1.7834496 ]
    ///                [-1.431566   -1.8647819 ]
    ///                [-1.9812102  -1.675859  ]
    ///                [-1.3823645  -1.8503251 ]]]]
    ///             &lt;NDArray 2x3x4x2 @cpu(0)&gt;
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\image\image_random.cc:L167</summary>
    /// <param name="data">Input ndarray</param>
    /// <param name="mean">Sequence of means for each channel. Default value is 0.</param>
    /// <param name="std">Sequence of standard deviations for each channel. Default value is 1.</param>
    static member ImageNormalize(data : NDArray, [<Optional>] mean : double seq, [<Optional>] std : double seq) =
        let creator = AtomicSymbolCreator.FromName "_image_normalize"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle|]
                                                 [|"mean"; "std"|]
                                                 [|(if isNull (mean :> obj) then "[0,0,0,0]" else string mean); (if isNull (std :> obj) then "[1,1,1,1]" else string std)|]
        (new NDArray(outputs.[0]))
    /// <summary>Normalize an tensor of shape (C x H x W) or (N x C x H x W) with mean and
    ///     standard deviation.
    /// 
    ///     Given mean `(m1, ..., mn)` and std `(s\ :sub:`1`\ , ..., s\ :sub:`n`)` for `n` channels,
    ///     this transform normalizes each channel of the input tensor with:
    /// 
    /// .. math::
    /// 
    ///         output[i] = (input[i] - m\ :sub:`i`\ ) / s\ :sub:`i`
    /// 
    ///     If mean or std is scalar, the same value will be applied to all channels.
    /// 
    ///     Default value for mean is 0.0 and stand deviation is 1.0.
    /// 
    /// Example:
    /// 
    ///     .. code-block:: python
    ///         image = mx.nd.random.uniform(0, 1, (3, 4, 2))
    ///         normalize(image, mean=(0, 1, 2), std=(3, 2, 1))
    ///             [[[ 0.18293785  0.19761486]
    ///               [ 0.23839645  0.28142193]
    ///               [ 0.20092112  0.28598186]
    ///               [ 0.18162774  0.28241724]]
    ///              [[-0.2881726  -0.18821815]
    ///               [-0.17705294 -0.30780914]
    ///               [-0.2812064  -0.3512327 ]
    ///               [-0.05411351 -0.4716435 ]]
    ///              [[-1.0363373  -1.7273437 ]
    ///               [-1.6165586  -1.5223348 ]
    ///               [-1.208275   -1.1878313 ]
    ///               [-1.4711051  -1.5200229 ]]]
    ///             &lt;NDArray 3x4x2 @cpu(0)&gt;
    /// 
    ///         image = mx.nd.random.uniform(0, 1, (2, 3, 4, 2))
    ///         normalize(image, mean=(0, 1, 2), std=(3, 2, 1))
    ///             [[[[ 0.18934818  0.13092826]
    ///                [ 0.3085322   0.27869293]
    ///                [ 0.02367868  0.11246539]
    ///                [ 0.0290431   0.2160573 ]]
    ///               [[-0.4898908  -0.31587923]
    ///                [-0.08369008 -0.02142242]
    ///                [-0.11092162 -0.42982462]
    ///                [-0.06499392 -0.06495637]]
    ///               [[-1.0213816  -1.526392  ]
    ///                [-1.2008414  -1.1990893 ]
    ///                [-1.5385206  -1.4795225 ]
    ///                [-1.2194707  -1.3211205 ]]]
    ///              [[[ 0.03942481  0.24021089]
    ///                [ 0.21330701  0.1940066 ]
    ///                [ 0.04778443  0.17912441]
    ///                [ 0.31488964  0.25287187]]
    ///               [[-0.23907584 -0.4470462 ]
    ///                [-0.29266903 -0.2631998 ]
    ///                [-0.3677222  -0.40683383]
    ///                [-0.11288315 -0.13154092]]
    ///               [[-1.5438497  -1.7834496 ]
    ///                [-1.431566   -1.8647819 ]
    ///                [-1.9812102  -1.675859  ]
    ///                [-1.3823645  -1.8503251 ]]]]
    ///             &lt;NDArray 2x3x4x2 @cpu(0)&gt;
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\image\image_random.cc:L167</summary>
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="data">Input ndarray</param>
    /// <param name="mean">Sequence of means for each channel. Default value is 0.</param>
    /// <param name="std">Sequence of standard deviations for each channel. Default value is 1.</param>
    static member ImageNormalize(outputArray : NDArray seq, data : NDArray, [<Optional>] mean : double seq, [<Optional>] std : double seq) =
        let creator = AtomicSymbolCreator.FromName "_image_normalize"
        let names = [|"mean"; "std"|]
        let vals = [|(if isNull (mean :> obj) then "[0,0,0,0]" else string mean); (if isNull (std :> obj) then "[1,1,1,1]" else string std)|]
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <summary>Normalize an tensor of shape (C x H x W) or (N x C x H x W) with mean and
    ///     standard deviation.
    /// 
    ///     Given mean `(m1, ..., mn)` and std `(s\ :sub:`1`\ , ..., s\ :sub:`n`)` for `n` channels,
    ///     this transform normalizes each channel of the input tensor with:
    /// 
    /// .. math::
    /// 
    ///         output[i] = (input[i] - m\ :sub:`i`\ ) / s\ :sub:`i`
    /// 
    ///     If mean or std is scalar, the same value will be applied to all channels.
    /// 
    ///     Default value for mean is 0.0 and stand deviation is 1.0.
    /// 
    /// Example:
    /// 
    ///     .. code-block:: python
    ///         image = mx.nd.random.uniform(0, 1, (3, 4, 2))
    ///         normalize(image, mean=(0, 1, 2), std=(3, 2, 1))
    ///             [[[ 0.18293785  0.19761486]
    ///               [ 0.23839645  0.28142193]
    ///               [ 0.20092112  0.28598186]
    ///               [ 0.18162774  0.28241724]]
    ///              [[-0.2881726  -0.18821815]
    ///               [-0.17705294 -0.30780914]
    ///               [-0.2812064  -0.3512327 ]
    ///               [-0.05411351 -0.4716435 ]]
    ///              [[-1.0363373  -1.7273437 ]
    ///               [-1.6165586  -1.5223348 ]
    ///               [-1.208275   -1.1878313 ]
    ///               [-1.4711051  -1.5200229 ]]]
    ///             &lt;NDArray 3x4x2 @cpu(0)&gt;
    /// 
    ///         image = mx.nd.random.uniform(0, 1, (2, 3, 4, 2))
    ///         normalize(image, mean=(0, 1, 2), std=(3, 2, 1))
    ///             [[[[ 0.18934818  0.13092826]
    ///                [ 0.3085322   0.27869293]
    ///                [ 0.02367868  0.11246539]
    ///                [ 0.0290431   0.2160573 ]]
    ///               [[-0.4898908  -0.31587923]
    ///                [-0.08369008 -0.02142242]
    ///                [-0.11092162 -0.42982462]
    ///                [-0.06499392 -0.06495637]]
    ///               [[-1.0213816  -1.526392  ]
    ///                [-1.2008414  -1.1990893 ]
    ///                [-1.5385206  -1.4795225 ]
    ///                [-1.2194707  -1.3211205 ]]]
    ///              [[[ 0.03942481  0.24021089]
    ///                [ 0.21330701  0.1940066 ]
    ///                [ 0.04778443  0.17912441]
    ///                [ 0.31488964  0.25287187]]
    ///               [[-0.23907584 -0.4470462 ]
    ///                [-0.29266903 -0.2631998 ]
    ///                [-0.3677222  -0.40683383]
    ///                [-0.11288315 -0.13154092]]
    ///               [[-1.5438497  -1.7834496 ]
    ///                [-1.431566   -1.8647819 ]
    ///                [-1.9812102  -1.675859  ]
    ///                [-1.3823645  -1.8503251 ]]]]
    ///             &lt;NDArray 2x3x4x2 @cpu(0)&gt;
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\image\image_random.cc:L167</summary>
    /// <param name="data">Input ndarray</param>
    /// <param name="mean">Sequence of means for each channel. Default value is 0.</param>
    /// <param name="std">Sequence of standard deviations for each channel. Default value is 1.</param>
    static member ImageNormalize([<Optional>] ?data : Symbol, [<Optional>] ?mean : double seq, [<Optional>] ?std : double seq) =
        ImageNormalize(?data = data, ?mean = mean, ?std = std)


    /// <summary>
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\image\image_random.cc:L195</summary>
    /// <param name="data">The input.</param>
    static member ImageFlipLeftRight(data : NDArray) =
        let creator = AtomicSymbolCreator.FromName "_image_flip_left_right"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle|]
                                                 Array.empty
                                                 Array.empty
        outputs |> Array.map (fun h -> new NDArray(h))
    /// <summary>
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\image\image_random.cc:L195</summary>
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="data">The input.</param>
    static member ImageFlipLeftRight(outputArray : NDArray seq, data : NDArray) =
        let creator = AtomicSymbolCreator.FromName "_image_flip_left_right"
        let names = Array.empty
        let vals = Array.empty
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <summary>
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\image\image_random.cc:L195</summary>
    /// <param name="data">The input.</param>
    static member ImageFlipLeftRight([<Optional>] ?data : Symbol) =
        ImageFlipLeftRight(?data = data)

    /// <summary>
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\image\image_random.cc:L200</summary>
    /// <param name="data">The input.</param>
    static member ImageRandomFlipLeftRight(data : NDArray) =
        let creator = AtomicSymbolCreator.FromName "_image_random_flip_left_right"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle|]
                                                 Array.empty
                                                 Array.empty
        outputs |> Array.map (fun h -> new NDArray(h))
    /// <summary>
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\image\image_random.cc:L200</summary>
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="data">The input.</param>
    static member ImageRandomFlipLeftRight(outputArray : NDArray seq, data : NDArray) =
        let creator = AtomicSymbolCreator.FromName "_image_random_flip_left_right"
        let names = Array.empty
        let vals = Array.empty
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <summary>
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\image\image_random.cc:L200</summary>
    /// <param name="data">The input.</param>
    static member ImageRandomFlipLeftRight([<Optional>] ?data : Symbol) =
        ImageRandomFlipLeftRight(?data = data)

    /// <summary>
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\image\image_random.cc:L205</summary>
    /// <param name="data">The input.</param>
    static member ImageFlipTopBottom(data : NDArray) =
        let creator = AtomicSymbolCreator.FromName "_image_flip_top_bottom"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle|]
                                                 Array.empty
                                                 Array.empty
        outputs |> Array.map (fun h -> new NDArray(h))
    /// <summary>
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\image\image_random.cc:L205</summary>
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="data">The input.</param>
    static member ImageFlipTopBottom(outputArray : NDArray seq, data : NDArray) =
        let creator = AtomicSymbolCreator.FromName "_image_flip_top_bottom"
        let names = Array.empty
        let vals = Array.empty
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <summary>
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\image\image_random.cc:L205</summary>
    /// <param name="data">The input.</param>
    static member ImageFlipTopBottom([<Optional>] ?data : Symbol) =
        ImageFlipTopBottom(?data = data)

    /// <summary>
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\image\image_random.cc:L210</summary>
    /// <param name="data">The input.</param>
    static member ImageRandomFlipTopBottom(data : NDArray) =
        let creator = AtomicSymbolCreator.FromName "_image_random_flip_top_bottom"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle|]
                                                 Array.empty
                                                 Array.empty
        outputs |> Array.map (fun h -> new NDArray(h))
    /// <summary>
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\image\image_random.cc:L210</summary>
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="data">The input.</param>
    static member ImageRandomFlipTopBottom(outputArray : NDArray seq, data : NDArray) =
        let creator = AtomicSymbolCreator.FromName "_image_random_flip_top_bottom"
        let names = Array.empty
        let vals = Array.empty
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <summary>
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\image\image_random.cc:L210</summary>
    /// <param name="data">The input.</param>
    static member ImageRandomFlipTopBottom([<Optional>] ?data : Symbol) =
        ImageRandomFlipTopBottom(?data = data)

    /// <summary>
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\image\image_random.cc:L215</summary>
    /// <param name="data">The input.</param>
    /// <param name="minFactor">Minimum factor.</param>
    /// <param name="maxFactor">Maximum factor.</param>
    static member ImageRandomBrightness(data : NDArray, minFactor : float, maxFactor : float) =
        let creator = AtomicSymbolCreator.FromName "_image_random_brightness"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle|]
                                                 [|"min_factor"; "max_factor"|]
                                                 [|string minFactor; string maxFactor|]
        outputs |> Array.map (fun h -> new NDArray(h))
    /// <summary>
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\image\image_random.cc:L215</summary>
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="data">The input.</param>
    /// <param name="minFactor">Minimum factor.</param>
    /// <param name="maxFactor">Maximum factor.</param>
    static member ImageRandomBrightness(outputArray : NDArray seq, data : NDArray, minFactor : float, maxFactor : float) =
        let creator = AtomicSymbolCreator.FromName "_image_random_brightness"
        let names = [|"min_factor"; "max_factor"|]
        let vals = [|string minFactor; string maxFactor|]
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <summary>
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\image\image_random.cc:L215</summary>
    /// <param name="data">The input.</param>
    /// <param name="minFactor">Minimum factor.</param>
    /// <param name="maxFactor">Maximum factor.</param>
    static member ImageRandomBrightness(data : Symbol, minFactor : float, maxFactor : float) =
        ImageRandomBrightness(data, minFactor, maxFactor)
    /// <summary>
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\image\image_random.cc:L215</summary>
    /// <param name="minFactor">Minimum factor.</param>
    /// <param name="maxFactor">Maximum factor.</param>
    /// <param name="data">The input.</param>
    static member ImageRandomBrightness(minFactor : float, maxFactor : float, [<Optional>] ?data : Symbol) =
        ImageRandomBrightness(minFactor, maxFactor, ?data = data)

    /// <summary>
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\image\image_random.cc:L222</summary>
    /// <param name="data">The input.</param>
    /// <param name="minFactor">Minimum factor.</param>
    /// <param name="maxFactor">Maximum factor.</param>
    static member ImageRandomContrast(data : NDArray, minFactor : float, maxFactor : float) =
        let creator = AtomicSymbolCreator.FromName "_image_random_contrast"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle|]
                                                 [|"min_factor"; "max_factor"|]
                                                 [|string minFactor; string maxFactor|]
        outputs |> Array.map (fun h -> new NDArray(h))
    /// <summary>
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\image\image_random.cc:L222</summary>
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="data">The input.</param>
    /// <param name="minFactor">Minimum factor.</param>
    /// <param name="maxFactor">Maximum factor.</param>
    static member ImageRandomContrast(outputArray : NDArray seq, data : NDArray, minFactor : float, maxFactor : float) =
        let creator = AtomicSymbolCreator.FromName "_image_random_contrast"
        let names = [|"min_factor"; "max_factor"|]
        let vals = [|string minFactor; string maxFactor|]
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <summary>
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\image\image_random.cc:L222</summary>
    /// <param name="data">The input.</param>
    /// <param name="minFactor">Minimum factor.</param>
    /// <param name="maxFactor">Maximum factor.</param>
    static member ImageRandomContrast(data : Symbol, minFactor : float, maxFactor : float) =
        ImageRandomContrast(data, minFactor, maxFactor)
    /// <summary>
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\image\image_random.cc:L222</summary>
    /// <param name="minFactor">Minimum factor.</param>
    /// <param name="maxFactor">Maximum factor.</param>
    /// <param name="data">The input.</param>
    static member ImageRandomContrast(minFactor : float, maxFactor : float, [<Optional>] ?data : Symbol) =
        ImageRandomContrast(minFactor, maxFactor, ?data = data)

    /// <summary>
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\image\image_random.cc:L230</summary>
    /// <param name="data">The input.</param>
    /// <param name="minFactor">Minimum factor.</param>
    /// <param name="maxFactor">Maximum factor.</param>
    static member ImageRandomSaturation(data : NDArray, minFactor : float, maxFactor : float) =
        let creator = AtomicSymbolCreator.FromName "_image_random_saturation"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle|]
                                                 [|"min_factor"; "max_factor"|]
                                                 [|string minFactor; string maxFactor|]
        outputs |> Array.map (fun h -> new NDArray(h))
    /// <summary>
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\image\image_random.cc:L230</summary>
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="data">The input.</param>
    /// <param name="minFactor">Minimum factor.</param>
    /// <param name="maxFactor">Maximum factor.</param>
    static member ImageRandomSaturation(outputArray : NDArray seq, data : NDArray, minFactor : float, maxFactor : float) =
        let creator = AtomicSymbolCreator.FromName "_image_random_saturation"
        let names = [|"min_factor"; "max_factor"|]
        let vals = [|string minFactor; string maxFactor|]
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <summary>
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\image\image_random.cc:L230</summary>
    /// <param name="data">The input.</param>
    /// <param name="minFactor">Minimum factor.</param>
    /// <param name="maxFactor">Maximum factor.</param>
    static member ImageRandomSaturation(data : Symbol, minFactor : float, maxFactor : float) =
        ImageRandomSaturation(data, minFactor, maxFactor)
    /// <summary>
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\image\image_random.cc:L230</summary>
    /// <param name="minFactor">Minimum factor.</param>
    /// <param name="maxFactor">Maximum factor.</param>
    /// <param name="data">The input.</param>
    static member ImageRandomSaturation(minFactor : float, maxFactor : float, [<Optional>] ?data : Symbol) =
        ImageRandomSaturation(minFactor, maxFactor, ?data = data)

    /// <summary>
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\image\image_random.cc:L238</summary>
    /// <param name="data">The input.</param>
    /// <param name="minFactor">Minimum factor.</param>
    /// <param name="maxFactor">Maximum factor.</param>
    static member ImageRandomHue(data : NDArray, minFactor : float, maxFactor : float) =
        let creator = AtomicSymbolCreator.FromName "_image_random_hue"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle|]
                                                 [|"min_factor"; "max_factor"|]
                                                 [|string minFactor; string maxFactor|]
        outputs |> Array.map (fun h -> new NDArray(h))
    /// <summary>
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\image\image_random.cc:L238</summary>
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="data">The input.</param>
    /// <param name="minFactor">Minimum factor.</param>
    /// <param name="maxFactor">Maximum factor.</param>
    static member ImageRandomHue(outputArray : NDArray seq, data : NDArray, minFactor : float, maxFactor : float) =
        let creator = AtomicSymbolCreator.FromName "_image_random_hue"
        let names = [|"min_factor"; "max_factor"|]
        let vals = [|string minFactor; string maxFactor|]
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <summary>
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\image\image_random.cc:L238</summary>
    /// <param name="data">The input.</param>
    /// <param name="minFactor">Minimum factor.</param>
    /// <param name="maxFactor">Maximum factor.</param>
    static member ImageRandomHue(data : Symbol, minFactor : float, maxFactor : float) =
        ImageRandomHue(data, minFactor, maxFactor)
    /// <summary>
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\image\image_random.cc:L238</summary>
    /// <param name="minFactor">Minimum factor.</param>
    /// <param name="maxFactor">Maximum factor.</param>
    /// <param name="data">The input.</param>
    static member ImageRandomHue(minFactor : float, maxFactor : float, [<Optional>] ?data : Symbol) =
        ImageRandomHue(minFactor, maxFactor, ?data = data)

    /// <summary>
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\image\image_random.cc:L246</summary>
    /// <param name="data">The input.</param>
    /// <param name="brightness">How much to jitter brightness.</param>
    /// <param name="contrast">How much to jitter contrast.</param>
    /// <param name="saturation">How much to jitter saturation.</param>
    /// <param name="hue">How much to jitter hue.</param>
    static member ImageRandomColorJitter(data : NDArray, 
                                         brightness : float, 
                                         contrast : float, 
                                         saturation : float, 
                                         hue : float) =
        let creator = AtomicSymbolCreator.FromName "_image_random_color_jitter"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle|]
                                                 [|"brightness"; "contrast"; "saturation"; "hue"|]
                                                 [|string brightness; string contrast; string saturation; string hue|]
        outputs |> Array.map (fun h -> new NDArray(h))
    /// <summary>
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\image\image_random.cc:L246</summary>
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="data">The input.</param>
    /// <param name="brightness">How much to jitter brightness.</param>
    /// <param name="contrast">How much to jitter contrast.</param>
    /// <param name="saturation">How much to jitter saturation.</param>
    /// <param name="hue">How much to jitter hue.</param>
    static member ImageRandomColorJitter(outputArray : NDArray seq, 
                                         data : NDArray, 
                                         brightness : float, 
                                         contrast : float, 
                                         saturation : float, 
                                         hue : float) =
        let creator = AtomicSymbolCreator.FromName "_image_random_color_jitter"
        let names = [|"brightness"; "contrast"; "saturation"; "hue"|]
        let vals = [|string brightness; string contrast; string saturation; string hue|]
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <summary>
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\image\image_random.cc:L246</summary>
    /// <param name="data">The input.</param>
    /// <param name="brightness">How much to jitter brightness.</param>
    /// <param name="contrast">How much to jitter contrast.</param>
    /// <param name="saturation">How much to jitter saturation.</param>
    /// <param name="hue">How much to jitter hue.</param>
    static member ImageRandomColorJitter(data : Symbol, brightness : float, contrast : float, saturation : float, hue : float) =
        ImageRandomColorJitter(data, brightness, contrast, saturation, hue)
    /// <summary>
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\image\image_random.cc:L246</summary>
    /// <param name="brightness">How much to jitter brightness.</param>
    /// <param name="contrast">How much to jitter contrast.</param>
    /// <param name="saturation">How much to jitter saturation.</param>
    /// <param name="hue">How much to jitter hue.</param>
    /// <param name="data">The input.</param>
    static member ImageRandomColorJitter(brightness : float, contrast : float, saturation : float, hue : float, [<Optional>] ?data : Symbol) =
        ImageRandomColorJitter(brightness, contrast, saturation, hue, ?data = data)

    /// <summary>Adjust the lighting level of the input. Follow the AlexNet style.
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\image\image_random.cc:L254</summary>
    /// <param name="data">The input.</param>
    /// <param name="alpha">The lighting alphas for the R, G, B channels.</param>
    static member ImageAdjustLighting(data : NDArray, alpha : double seq) =
        let creator = AtomicSymbolCreator.FromName "_image_adjust_lighting"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle|]
                                                 [|"alpha"|]
                                                 [|string alpha|]
        outputs |> Array.map (fun h -> new NDArray(h))
    /// <summary>Adjust the lighting level of the input. Follow the AlexNet style.
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\image\image_random.cc:L254</summary>
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="data">The input.</param>
    /// <param name="alpha">The lighting alphas for the R, G, B channels.</param>
    static member ImageAdjustLighting(outputArray : NDArray seq, data : NDArray, alpha : double seq) =
        let creator = AtomicSymbolCreator.FromName "_image_adjust_lighting"
        let names = [|"alpha"|]
        let vals = [|string alpha|]
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <summary>Adjust the lighting level of the input. Follow the AlexNet style.
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\image\image_random.cc:L254</summary>
    /// <param name="data">The input.</param>
    /// <param name="alpha">The lighting alphas for the R, G, B channels.</param>
    static member ImageAdjustLighting(data : Symbol, alpha : double seq) =
        ImageAdjustLighting(data, alpha)
    /// <summary>Adjust the lighting level of the input. Follow the AlexNet style.
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\image\image_random.cc:L254</summary>
    /// <param name="alpha">The lighting alphas for the R, G, B channels.</param>
    /// <param name="data">The input.</param>
    static member ImageAdjustLighting(alpha : double seq, [<Optional>] ?data : Symbol) =
        ImageAdjustLighting(alpha, ?data = data)

    /// <summary>Randomly add PCA noise. Follow the AlexNet style.
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\image\image_random.cc:L262</summary>
    /// <param name="data">The input.</param>
    /// <param name="alphaStd">Level of the lighting noise.</param>
    static member ImageRandomLighting(data : NDArray, [<Optional; DefaultParameterValue(0.0500000007)>] alphaStd : float) =
        let creator = AtomicSymbolCreator.FromName "_image_random_lighting"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle|]
                                                 [|"alpha_std"|]
                                                 [|string alphaStd|]
        outputs |> Array.map (fun h -> new NDArray(h))
    /// <summary>Randomly add PCA noise. Follow the AlexNet style.
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\image\image_random.cc:L262</summary>
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="data">The input.</param>
    /// <param name="alphaStd">Level of the lighting noise.</param>
    static member ImageRandomLighting(outputArray : NDArray seq, data : NDArray, [<Optional; DefaultParameterValue(0.0500000007)>] alphaStd : float) =
        let creator = AtomicSymbolCreator.FromName "_image_random_lighting"
        let names = [|"alpha_std"|]
        let vals = [|string alphaStd|]
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <summary>Randomly add PCA noise. Follow the AlexNet style.
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\image\image_random.cc:L262</summary>
    /// <param name="data">The input.</param>
    /// <param name="alphaStd">Level of the lighting noise.</param>
    static member ImageRandomLighting([<Optional>] ?data : Symbol, [<Optional>] ?alphaStd : float) =
        ImageRandomLighting(?data = data, ?alphaStd = alphaStd)

    /// <summary>Resize an image NDArray of shape (H x W x C) or (N x H x W x C) 
    /// to the given size
    /// Example:
    ///     .. code-block:: python
    ///         image = mx.nd.random.uniform(0, 255, (4, 2, 3)).astype(dtype=np.uint8)
    ///         mx.nd.image.resize(image, (3, 3))
    ///             [[[124 111 197]
    ///               [158  80 155]
    ///               [193  50 112]]
    /// 
    ///              [[110 100 113]
    ///               [134 165 148]
    ///               [157 231 182]]
    /// 
    ///              [[202 176 134]
    ///               [174 191 149]
    ///               [147 207 164]]]
    ///             &lt;NDArray 3x3x3 @cpu(0)&gt;
    ///         image = mx.nd.random.uniform(0, 255, (2, 4, 2, 3)).astype(dtype=np.uint8)
    ///         mx.nd.image.resize(image, (2, 2))            
    ///             [[[[ 59 133  80]
    ///                [187 114 153]]
    /// 
    ///               [[ 38 142  39]
    ///                [207 131 124]]]
    /// 
    /// 
    ///               [[[117 125 136]
    ///                [191 166 150]]
    /// 
    ///               [[129  63 113]
    ///                [182 109  48]]]]
    ///             &lt;NDArray 2x2x2x3 @cpu(0)&gt;
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\image\resize.cc:L71</summary>
    /// <param name="data">The input.</param>
    /// <param name="size">Size of new image. Could be (width, height) or (size)</param>
    /// <param name="keepRatio">Whether to resize the short edge or both edges to `size`, if size is give as an integer.</param>
    /// <param name="interp">Interpolation method for resizing. By default uses bilinear interpolationOptions are INTER_NEAREST - a nearest-neighbor interpolationINTER_LINEAR - a bilinear interpolationINTER_AREA - resampling using pixel area relationINTER_CUBIC - a bicubic interpolation over 4x4 pixel neighborhoodINTER_LANCZOS4 - a Lanczos interpolation over 8x8 pixel neighborhoodNote that the GPU version only support bilinear interpolation(1)</param>
    static member ImageResize(data : NDArray, [<Optional>] size : int seq, [<Optional; DefaultParameterValue(false)>] keepRatio : bool, [<Optional; DefaultParameterValue(1)>] interp : int) =
        let creator = AtomicSymbolCreator.FromName "_image_resize"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle|]
                                                 [|"size"; "keep_ratio"; "interp"|]
                                                 [|(if isNull (size :> obj) then "[]" else (size |> Seq.map string |> String.concat ", " |> sprintf "[%s]")); string keepRatio; string interp|]
        (new NDArray(outputs.[0]))
    /// <summary>Resize an image NDArray of shape (H x W x C) or (N x H x W x C) 
    /// to the given size
    /// Example:
    ///     .. code-block:: python
    ///         image = mx.nd.random.uniform(0, 255, (4, 2, 3)).astype(dtype=np.uint8)
    ///         mx.nd.image.resize(image, (3, 3))
    ///             [[[124 111 197]
    ///               [158  80 155]
    ///               [193  50 112]]
    /// 
    ///              [[110 100 113]
    ///               [134 165 148]
    ///               [157 231 182]]
    /// 
    ///              [[202 176 134]
    ///               [174 191 149]
    ///               [147 207 164]]]
    ///             &lt;NDArray 3x3x3 @cpu(0)&gt;
    ///         image = mx.nd.random.uniform(0, 255, (2, 4, 2, 3)).astype(dtype=np.uint8)
    ///         mx.nd.image.resize(image, (2, 2))            
    ///             [[[[ 59 133  80]
    ///                [187 114 153]]
    /// 
    ///               [[ 38 142  39]
    ///                [207 131 124]]]
    /// 
    /// 
    ///               [[[117 125 136]
    ///                [191 166 150]]
    /// 
    ///               [[129  63 113]
    ///                [182 109  48]]]]
    ///             &lt;NDArray 2x2x2x3 @cpu(0)&gt;
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\image\resize.cc:L71</summary>
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="data">The input.</param>
    /// <param name="size">Size of new image. Could be (width, height) or (size)</param>
    /// <param name="keepRatio">Whether to resize the short edge or both edges to `size`, if size is give as an integer.</param>
    /// <param name="interp">Interpolation method for resizing. By default uses bilinear interpolationOptions are INTER_NEAREST - a nearest-neighbor interpolationINTER_LINEAR - a bilinear interpolationINTER_AREA - resampling using pixel area relationINTER_CUBIC - a bicubic interpolation over 4x4 pixel neighborhoodINTER_LANCZOS4 - a Lanczos interpolation over 8x8 pixel neighborhoodNote that the GPU version only support bilinear interpolation(1)</param>
    static member ImageResize(outputArray : NDArray seq, data : NDArray, [<Optional>] size : int seq, [<Optional; DefaultParameterValue(false)>] keepRatio : bool, [<Optional; DefaultParameterValue(1)>] interp : int) =
        let creator = AtomicSymbolCreator.FromName "_image_resize"
        let names = [|"size"; "keep_ratio"; "interp"|]
        let vals = [|(if isNull (size :> obj) then "[]" else (size |> Seq.map string |> String.concat ", " |> sprintf "[%s]")); string keepRatio; string interp|]
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <summary>Resize an image NDArray of shape (H x W x C) or (N x H x W x C) 
    /// to the given size
    /// Example:
    ///     .. code-block:: python
    ///         image = mx.nd.random.uniform(0, 255, (4, 2, 3)).astype(dtype=np.uint8)
    ///         mx.nd.image.resize(image, (3, 3))
    ///             [[[124 111 197]
    ///               [158  80 155]
    ///               [193  50 112]]
    /// 
    ///              [[110 100 113]
    ///               [134 165 148]
    ///               [157 231 182]]
    /// 
    ///              [[202 176 134]
    ///               [174 191 149]
    ///               [147 207 164]]]
    ///             &lt;NDArray 3x3x3 @cpu(0)&gt;
    ///         image = mx.nd.random.uniform(0, 255, (2, 4, 2, 3)).astype(dtype=np.uint8)
    ///         mx.nd.image.resize(image, (2, 2))            
    ///             [[[[ 59 133  80]
    ///                [187 114 153]]
    /// 
    ///               [[ 38 142  39]
    ///                [207 131 124]]]
    /// 
    /// 
    ///               [[[117 125 136]
    ///                [191 166 150]]
    /// 
    ///               [[129  63 113]
    ///                [182 109  48]]]]
    ///             &lt;NDArray 2x2x2x3 @cpu(0)&gt;
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\image\resize.cc:L71</summary>
    /// <param name="data">The input.</param>
    /// <param name="size">Size of new image. Could be (width, height) or (size)</param>
    /// <param name="keepRatio">Whether to resize the short edge or both edges to `size`, if size is give as an integer.</param>
    /// <param name="interp">Interpolation method for resizing. By default uses bilinear interpolationOptions are INTER_NEAREST - a nearest-neighbor interpolationINTER_LINEAR - a bilinear interpolationINTER_AREA - resampling using pixel area relationINTER_CUBIC - a bicubic interpolation over 4x4 pixel neighborhoodINTER_LANCZOS4 - a Lanczos interpolation over 8x8 pixel neighborhoodNote that the GPU version only support bilinear interpolation(1)</param>
    static member ImageResize([<Optional>] ?data : Symbol, [<Optional>] ?size : int seq, [<Optional>] ?keepRatio : bool, [<Optional>] ?interp : int) =
        ImageResize(?data = data, ?size = size, ?keepRatio = keepRatio, ?interp = interp)

    /// <summary>Applies Leaky rectified linear unit activation element-wise to the input.
    /// 
    /// Leaky ReLUs attempt to fix the &quot;dying ReLU&quot; problem by allowing a small `slope`
    /// when the input is negative and has a slope of one when input is positive.
    /// 
    /// The following modified ReLU Activation functions are supported:
    /// 
    /// - *elu*: Exponential Linear Unit. `y = x &gt; 0 ? x : slope * (exp(x)-1)`
    /// - *selu*: Scaled Exponential Linear Unit. `y = lambda * (x &gt; 0 ? x : alpha * (exp(x) - 1))` where
    ///   *lambda = 1.0507009873554804934193349852946* and *alpha = 1.6732632423543772848170429916717*.
    /// - *leaky*: Leaky ReLU. `y = x &gt; 0 ? x : slope * x`
    /// - *prelu*: Parametric ReLU. This is same as *leaky* except that `slope` is learnt during training.
    /// - *rrelu*: Randomized ReLU. same as *leaky* but the `slope` is uniformly and randomly chosen from
    ///   *[lower_bound, upper_bound)* for training, while fixed to be
    ///   *(lower_bound+upper_bound)/2* for inference.
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\leaky_relu.cc:L161</summary>
    /// <param name="data">Input data to activation function.</param>
    /// <param name="gamma">Input data to activation function.</param>
    /// <param name="actType">Activation function to be applied.</param>
    /// <param name="slope">Init slope for the activation. (For leaky and elu only)</param>
    /// <param name="lowerBound">Lower bound of random slope. (For rrelu only)</param>
    /// <param name="upperBound">Upper bound of random slope. (For rrelu only)</param>
    static member LeakyReLU(data : NDArray, 
                            gamma : NDArray, 
                            [<Optional>] actType : LeakyReLUType, 
                            [<Optional; DefaultParameterValue(0.25)>] slope : float, 
                            [<Optional; DefaultParameterValue(0.125)>] lowerBound : float, 
                            [<Optional; DefaultParameterValue(0.333999991)>] upperBound : float) =
        let creator = AtomicSymbolCreator.FromName "LeakyReLU"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg gamma)) then gamma.UnsafeHandle|]
                                                 [|"act_type"; "slope"; "lower_bound"; "upper_bound"|]
                                                 [|(if isNull (actType :> obj) then "leaky" else string actType); string slope; string lowerBound; string upperBound|]
        (new NDArray(outputs.[0]))
    /// <summary>Applies Leaky rectified linear unit activation element-wise to the input.
    /// 
    /// Leaky ReLUs attempt to fix the &quot;dying ReLU&quot; problem by allowing a small `slope`
    /// when the input is negative and has a slope of one when input is positive.
    /// 
    /// The following modified ReLU Activation functions are supported:
    /// 
    /// - *elu*: Exponential Linear Unit. `y = x &gt; 0 ? x : slope * (exp(x)-1)`
    /// - *selu*: Scaled Exponential Linear Unit. `y = lambda * (x &gt; 0 ? x : alpha * (exp(x) - 1))` where
    ///   *lambda = 1.0507009873554804934193349852946* and *alpha = 1.6732632423543772848170429916717*.
    /// - *leaky*: Leaky ReLU. `y = x &gt; 0 ? x : slope * x`
    /// - *prelu*: Parametric ReLU. This is same as *leaky* except that `slope` is learnt during training.
    /// - *rrelu*: Randomized ReLU. same as *leaky* but the `slope` is uniformly and randomly chosen from
    ///   *[lower_bound, upper_bound)* for training, while fixed to be
    ///   *(lower_bound+upper_bound)/2* for inference.
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\leaky_relu.cc:L161</summary>
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="data">Input data to activation function.</param>
    /// <param name="gamma">Input data to activation function.</param>
    /// <param name="actType">Activation function to be applied.</param>
    /// <param name="slope">Init slope for the activation. (For leaky and elu only)</param>
    /// <param name="lowerBound">Lower bound of random slope. (For rrelu only)</param>
    /// <param name="upperBound">Upper bound of random slope. (For rrelu only)</param>
    static member LeakyReLU(outputArray : NDArray seq, 
                            data : NDArray, 
                            gamma : NDArray, 
                            [<Optional>] actType : LeakyReLUType, 
                            [<Optional; DefaultParameterValue(0.25)>] slope : float, 
                            [<Optional; DefaultParameterValue(0.125)>] lowerBound : float, 
                            [<Optional; DefaultParameterValue(0.333999991)>] upperBound : float) =
        let creator = AtomicSymbolCreator.FromName "LeakyReLU"
        let names = [|"act_type"; "slope"; "lower_bound"; "upper_bound"|]
        let vals = [|(if isNull (actType :> obj) then "leaky" else string actType); string slope; string lowerBound; string upperBound|]
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg gamma)) then gamma.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <summary>Applies Leaky rectified linear unit activation element-wise to the input.
    /// 
    /// Leaky ReLUs attempt to fix the &quot;dying ReLU&quot; problem by allowing a small `slope`
    /// when the input is negative and has a slope of one when input is positive.
    /// 
    /// The following modified ReLU Activation functions are supported:
    /// 
    /// - *elu*: Exponential Linear Unit. `y = x &gt; 0 ? x : slope * (exp(x)-1)`
    /// - *selu*: Scaled Exponential Linear Unit. `y = lambda * (x &gt; 0 ? x : alpha * (exp(x) - 1))` where
    ///   *lambda = 1.0507009873554804934193349852946* and *alpha = 1.6732632423543772848170429916717*.
    /// - *leaky*: Leaky ReLU. `y = x &gt; 0 ? x : slope * x`
    /// - *prelu*: Parametric ReLU. This is same as *leaky* except that `slope` is learnt during training.
    /// - *rrelu*: Randomized ReLU. same as *leaky* but the `slope` is uniformly and randomly chosen from
    ///   *[lower_bound, upper_bound)* for training, while fixed to be
    ///   *(lower_bound+upper_bound)/2* for inference.
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\leaky_relu.cc:L161</summary>
    /// <param name="data">Input data to activation function.</param>
    /// <param name="gamma">Input data to activation function.</param>
    /// <param name="actType">Activation function to be applied.</param>
    /// <param name="slope">Init slope for the activation. (For leaky and elu only)</param>
    /// <param name="lowerBound">Lower bound of random slope. (For rrelu only)</param>
    /// <param name="upperBound">Upper bound of random slope. (For rrelu only)</param>
    static member LeakyReLU([<Optional>] ?data : Symbol, [<Optional>] ?gamma : Symbol, [<Optional>] ?actType : LeakyReLUType, [<Optional>] ?slope : float, [<Optional>] ?lowerBound : float, [<Optional>] ?upperBound : float) =
        LeakyReLU(?data = data, ?gamma = gamma, ?actType = actType, ?slope = slope, ?lowerBound = lowerBound, ?upperBound = upperBound)


    /// <summary>Calculate cross entropy of softmax output and one-hot label.
    /// 
    /// - This operator computes the cross entropy in two steps:
    ///   - Applies softmax function on the input array.
    ///   - Computes and returns the cross entropy loss between the softmax output and the labels.
    /// 
    /// - The softmax function and cross entropy loss is given by:
    /// 
    ///   - Softmax Function:
    /// 
    ///   .. math:: \text{softmax}(x)_i = \frac{exp(x_i)}{\sum_j exp(x_j)}
    /// 
    ///   - Cross Entropy Function:
    /// 
    ///   .. math:: \text{CE(label, output)} = - \sum_i \text{label}_i \log(\text{output}_i)
    /// 
    /// Example::
    /// 
    ///   x = [[1, 2, 3],
    ///        [11, 7, 5]]
    /// 
    ///   label = [2, 0]
    /// 
    ///   softmax(x) = [[0.09003057, 0.24472848, 0.66524094],
    ///                 [0.97962922, 0.01794253, 0.00242826]]
    /// 
    ///   softmax_cross_entropy(data, label) = - log(0.66524084) - log(0.97962922) = 0.4281871
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\loss_binary_op.cc:L59</summary>
    /// <param name="data">Input data</param>
    /// <param name="label">Input label</param>
    static member SoftmaxCrossEntropy(data : NDArray, label : NDArray) =
        let creator = AtomicSymbolCreator.FromName "softmax_cross_entropy"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg label)) then label.UnsafeHandle|]
                                                 Array.empty
                                                 Array.empty
        (new NDArray(outputs.[0]))
    /// <summary>Calculate cross entropy of softmax output and one-hot label.
    /// 
    /// - This operator computes the cross entropy in two steps:
    ///   - Applies softmax function on the input array.
    ///   - Computes and returns the cross entropy loss between the softmax output and the labels.
    /// 
    /// - The softmax function and cross entropy loss is given by:
    /// 
    ///   - Softmax Function:
    /// 
    ///   .. math:: \text{softmax}(x)_i = \frac{exp(x_i)}{\sum_j exp(x_j)}
    /// 
    ///   - Cross Entropy Function:
    /// 
    ///   .. math:: \text{CE(label, output)} = - \sum_i \text{label}_i \log(\text{output}_i)
    /// 
    /// Example::
    /// 
    ///   x = [[1, 2, 3],
    ///        [11, 7, 5]]
    /// 
    ///   label = [2, 0]
    /// 
    ///   softmax(x) = [[0.09003057, 0.24472848, 0.66524094],
    ///                 [0.97962922, 0.01794253, 0.00242826]]
    /// 
    ///   softmax_cross_entropy(data, label) = - log(0.66524084) - log(0.97962922) = 0.4281871
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\loss_binary_op.cc:L59</summary>
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="data">Input data</param>
    /// <param name="label">Input label</param>
    static member SoftmaxCrossEntropy(outputArray : NDArray seq, data : NDArray, label : NDArray) =
        let creator = AtomicSymbolCreator.FromName "softmax_cross_entropy"
        let names = Array.empty
        let vals = Array.empty
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg label)) then label.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <summary>Calculate cross entropy of softmax output and one-hot label.
    /// 
    /// - This operator computes the cross entropy in two steps:
    ///   - Applies softmax function on the input array.
    ///   - Computes and returns the cross entropy loss between the softmax output and the labels.
    /// 
    /// - The softmax function and cross entropy loss is given by:
    /// 
    ///   - Softmax Function:
    /// 
    ///   .. math:: \text{softmax}(x)_i = \frac{exp(x_i)}{\sum_j exp(x_j)}
    /// 
    ///   - Cross Entropy Function:
    /// 
    ///   .. math:: \text{CE(label, output)} = - \sum_i \text{label}_i \log(\text{output}_i)
    /// 
    /// Example::
    /// 
    ///   x = [[1, 2, 3],
    ///        [11, 7, 5]]
    /// 
    ///   label = [2, 0]
    /// 
    ///   softmax(x) = [[0.09003057, 0.24472848, 0.66524094],
    ///                 [0.97962922, 0.01794253, 0.00242826]]
    /// 
    ///   softmax_cross_entropy(data, label) = - log(0.66524084) - log(0.97962922) = 0.4281871
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\loss_binary_op.cc:L59</summary>
    /// <param name="data">Input data</param>
    /// <param name="label">Input label</param>
    static member SoftmaxCrossEntropy([<Optional>] ?data : Symbol, [<Optional>] ?label : Symbol) =
        SoftmaxCrossEntropy(?data = data, ?label = label)


    /// <summary>Applies an activation function element-wise to the input.
    /// 
    /// The following activation functions are supported:
    /// 
    /// - `relu`: Rectified Linear Unit, :math:`y = max(x, 0)`
    /// - `sigmoid`: :math:`y = \frac{1}{1 + exp(-x)}`
    /// - `tanh`: Hyperbolic tangent, :math:`y = \frac{exp(x) - exp(-x)}{exp(x) + exp(-x)}`
    /// - `softrelu`: Soft ReLU, or SoftPlus, :math:`y = log(1 + exp(x))`
    /// - `softsign`: :math:`y = \frac{x}{1 + abs(x)}`
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\nn\activation.cc:L168</summary>
    /// <param name="data">The input array.</param>
    /// <param name="actType">Activation function to be applied.</param>
    static member Activation(data : NDArray, actType : ActType) =
        let creator = AtomicSymbolCreator.FromName "Activation"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle|]
                                                 [|"act_type"|]
                                                 [|string actType|]
        (new NDArray(outputs.[0]))
    /// <summary>Applies an activation function element-wise to the input.
    /// 
    /// The following activation functions are supported:
    /// 
    /// - `relu`: Rectified Linear Unit, :math:`y = max(x, 0)`
    /// - `sigmoid`: :math:`y = \frac{1}{1 + exp(-x)}`
    /// - `tanh`: Hyperbolic tangent, :math:`y = \frac{exp(x) - exp(-x)}{exp(x) + exp(-x)}`
    /// - `softrelu`: Soft ReLU, or SoftPlus, :math:`y = log(1 + exp(x))`
    /// - `softsign`: :math:`y = \frac{x}{1 + abs(x)}`
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\nn\activation.cc:L168</summary>
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="data">The input array.</param>
    /// <param name="actType">Activation function to be applied.</param>
    static member Activation(outputArray : NDArray seq, data : NDArray, actType : ActType) =
        let creator = AtomicSymbolCreator.FromName "Activation"
        let names = [|"act_type"|]
        let vals = [|string actType|]
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <summary>Applies an activation function element-wise to the input.
    /// 
    /// The following activation functions are supported:
    /// 
    /// - `relu`: Rectified Linear Unit, :math:`y = max(x, 0)`
    /// - `sigmoid`: :math:`y = \frac{1}{1 + exp(-x)}`
    /// - `tanh`: Hyperbolic tangent, :math:`y = \frac{exp(x) - exp(-x)}{exp(x) + exp(-x)}`
    /// - `softrelu`: Soft ReLU, or SoftPlus, :math:`y = log(1 + exp(x))`
    /// - `softsign`: :math:`y = \frac{x}{1 + abs(x)}`
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\nn\activation.cc:L168</summary>
    /// <param name="data">The input array.</param>
    /// <param name="actType">Activation function to be applied.</param>
    static member Activation(data : Symbol, actType : ActType) =
        Activation(data, actType)
    /// <summary>Applies an activation function element-wise to the input.
    /// 
    /// The following activation functions are supported:
    /// 
    /// - `relu`: Rectified Linear Unit, :math:`y = max(x, 0)`
    /// - `sigmoid`: :math:`y = \frac{1}{1 + exp(-x)}`
    /// - `tanh`: Hyperbolic tangent, :math:`y = \frac{exp(x) - exp(-x)}{exp(x) + exp(-x)}`
    /// - `softrelu`: Soft ReLU, or SoftPlus, :math:`y = log(1 + exp(x))`
    /// - `softsign`: :math:`y = \frac{x}{1 + abs(x)}`
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\nn\activation.cc:L168</summary>
    /// <param name="actType">Activation function to be applied.</param>
    /// <param name="data">The input array.</param>
    static member Activation(actType : ActType, [<Optional>] ?data : Symbol) =
        Activation(actType, ?data = data)


    /// <summary>Batch normalization.
    /// 
    /// Normalizes a data batch by mean and variance, and applies a scale ``gamma`` as
    /// well as offset ``beta``.
    /// 
    /// Assume the input has more than one dimension and we normalize along axis 1.
    /// We first compute the mean and variance along this axis:
    /// 
    /// .. math::
    /// 
    ///   data\_mean[i] = mean(data[:,i,:,...]) \\
    ///   data\_var[i] = var(data[:,i,:,...])
    /// 
    /// Then compute the normalized output, which has the same shape as input, as following:
    /// 
    /// .. math::
    /// 
    ///   out[:,i,:,...] = \frac{data[:,i,:,...] - data\_mean[i]}{\sqrt{data\_var[i]+\epsilon}} * gamma[i] + beta[i]
    /// 
    /// Both *mean* and *var* returns a scalar by treating the input as a vector.
    /// 
    /// Assume the input has size *k* on axis 1, then both ``gamma`` and ``beta``
    /// have shape *(k,)*. If ``output_mean_var`` is set to be true, then outputs both ``data_mean`` and
    /// the inverse of ``data_var``, which are needed for the backward pass. Note that gradient of these
    /// two outputs are blocked.
    /// 
    /// Besides the inputs and the outputs, this operator accepts two auxiliary
    /// states, ``moving_mean`` and ``moving_var``, which are *k*-length
    /// vectors. They are global statistics for the whole dataset, which are updated
    /// by::
    /// 
    ///   moving_mean = moving_mean * momentum + data_mean * (1 - momentum)
    ///   moving_var = moving_var * momentum + data_var * (1 - momentum)
    /// 
    /// If ``use_global_stats`` is set to be true, then ``moving_mean`` and
    /// ``moving_var`` are used instead of ``data_mean`` and ``data_var`` to compute
    /// the output. It is often used during inference.
    /// 
    /// The parameter ``axis`` specifies which axis of the input shape denotes
    /// the &#39;channel&#39; (separately normalized groups).  The default is 1.  Specifying -1 sets the channel
    /// axis to be the last item in the input shape.
    /// 
    /// Both ``gamma`` and ``beta`` are learnable parameters. But if ``fix_gamma`` is true,
    /// then set ``gamma`` to 1 and its gradient to 0.
    /// 
    /// .. Note::
    ///   When ``fix_gamma`` is set to True, no sparse support is provided. If ``fix_gamma is`` set to False,
    ///   the sparse tensors will fallback.
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\nn\batch_norm.cc:L571</summary>
    /// <param name="data">Input data to batch normalization</param>
    /// <param name="gamma">gamma array</param>
    /// <param name="beta">beta array</param>
    /// <param name="movingMean">running mean of input</param>
    /// <param name="movingVar">running variance of input</param>
    /// <param name="eps">Epsilon to prevent div 0. Must be no less than CUDNN_BN_MIN_EPSILON defined in cudnn.h when using cudnn (usually 1e-5)</param>
    /// <param name="momentum">Momentum for moving average</param>
    /// <param name="fixGamma">Fix gamma while training</param>
    /// <param name="useGlobalStats">Whether use global moving statistics instead of local batch-norm. This will force change batch-norm into a scale shift operator.</param>
    /// <param name="outputMeanVar">Output the mean and inverse std </param>
    /// <param name="axis">Specify which shape axis the channel is specified</param>
    /// <param name="cudnnOff">Do not select CUDNN operator, if available</param>
    /// <param name="minCalibRange">The minimum scalar value in the form of float32 obtained through calibration. If present, it will be used to by quantized batch norm op to calculate primitive scale.Note: this calib_range is to calib bn output.</param>
    /// <param name="maxCalibRange">The maximum scalar value in the form of float32 obtained through calibration. If present, it will be used to by quantized batch norm op to calculate primitive scale.Note: this calib_range is to calib bn output.</param>
    static member BatchNorm(data : NDArray, 
                            gamma : NDArray, 
                            beta : NDArray, 
                            movingMean : NDArray, 
                            movingVar : NDArray, 
                            [<Optional>] ?eps : double, 
                            [<Optional>] ?momentum : float, 
                            [<Optional>] ?fixGamma : bool, 
                            [<Optional>] ?useGlobalStats : bool, 
                            [<Optional>] ?outputMeanVar : bool, 
                            [<Optional>] ?axis : int, 
                            [<Optional>] ?cudnnOff : bool, 
                            [<Optional>] ?minCalibRange : float, 
                            [<Optional>] ?maxCalibRange : float) =
        let creator = AtomicSymbolCreator.FromName "BatchNorm"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg gamma)) then gamma.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg beta)) then beta.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg movingMean)) then movingMean.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg movingVar)) then movingVar.UnsafeHandle|]
                                                 [|"eps"; "momentum"; "fix_gamma"; "use_global_stats"; "output_mean_var"; "axis"; "cudnn_off"; "min_calib_range"; "max_calib_range"|]
                                                 [|(match eps with None -> "0.00100000004749745" | Some eps -> string eps); (match momentum with None -> "0.899999976" | Some momentum -> string momentum); (match fixGamma with None -> "true" | Some fixGamma -> string fixGamma); (match useGlobalStats with None -> "false" | Some useGlobalStats -> string useGlobalStats); (match outputMeanVar with None -> "false" | Some outputMeanVar -> string outputMeanVar); (match axis with None -> "1" | Some axis -> string axis); (match cudnnOff with None -> "false" | Some cudnnOff -> string cudnnOff); (match minCalibRange with None -> "None" | Some minCalibRange -> string minCalibRange); (match maxCalibRange with None -> "None" | Some maxCalibRange -> string maxCalibRange)|]
        outputs |> Array.map (fun h -> new NDArray(h))
    /// <summary>Batch normalization.
    /// 
    /// Normalizes a data batch by mean and variance, and applies a scale ``gamma`` as
    /// well as offset ``beta``.
    /// 
    /// Assume the input has more than one dimension and we normalize along axis 1.
    /// We first compute the mean and variance along this axis:
    /// 
    /// .. math::
    /// 
    ///   data\_mean[i] = mean(data[:,i,:,...]) \\
    ///   data\_var[i] = var(data[:,i,:,...])
    /// 
    /// Then compute the normalized output, which has the same shape as input, as following:
    /// 
    /// .. math::
    /// 
    ///   out[:,i,:,...] = \frac{data[:,i,:,...] - data\_mean[i]}{\sqrt{data\_var[i]+\epsilon}} * gamma[i] + beta[i]
    /// 
    /// Both *mean* and *var* returns a scalar by treating the input as a vector.
    /// 
    /// Assume the input has size *k* on axis 1, then both ``gamma`` and ``beta``
    /// have shape *(k,)*. If ``output_mean_var`` is set to be true, then outputs both ``data_mean`` and
    /// the inverse of ``data_var``, which are needed for the backward pass. Note that gradient of these
    /// two outputs are blocked.
    /// 
    /// Besides the inputs and the outputs, this operator accepts two auxiliary
    /// states, ``moving_mean`` and ``moving_var``, which are *k*-length
    /// vectors. They are global statistics for the whole dataset, which are updated
    /// by::
    /// 
    ///   moving_mean = moving_mean * momentum + data_mean * (1 - momentum)
    ///   moving_var = moving_var * momentum + data_var * (1 - momentum)
    /// 
    /// If ``use_global_stats`` is set to be true, then ``moving_mean`` and
    /// ``moving_var`` are used instead of ``data_mean`` and ``data_var`` to compute
    /// the output. It is often used during inference.
    /// 
    /// The parameter ``axis`` specifies which axis of the input shape denotes
    /// the &#39;channel&#39; (separately normalized groups).  The default is 1.  Specifying -1 sets the channel
    /// axis to be the last item in the input shape.
    /// 
    /// Both ``gamma`` and ``beta`` are learnable parameters. But if ``fix_gamma`` is true,
    /// then set ``gamma`` to 1 and its gradient to 0.
    /// 
    /// .. Note::
    ///   When ``fix_gamma`` is set to True, no sparse support is provided. If ``fix_gamma is`` set to False,
    ///   the sparse tensors will fallback.
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\nn\batch_norm.cc:L571</summary>
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="data">Input data to batch normalization</param>
    /// <param name="gamma">gamma array</param>
    /// <param name="beta">beta array</param>
    /// <param name="movingMean">running mean of input</param>
    /// <param name="movingVar">running variance of input</param>
    /// <param name="eps">Epsilon to prevent div 0. Must be no less than CUDNN_BN_MIN_EPSILON defined in cudnn.h when using cudnn (usually 1e-5)</param>
    /// <param name="momentum">Momentum for moving average</param>
    /// <param name="fixGamma">Fix gamma while training</param>
    /// <param name="useGlobalStats">Whether use global moving statistics instead of local batch-norm. This will force change batch-norm into a scale shift operator.</param>
    /// <param name="outputMeanVar">Output the mean and inverse std </param>
    /// <param name="axis">Specify which shape axis the channel is specified</param>
    /// <param name="cudnnOff">Do not select CUDNN operator, if available</param>
    /// <param name="minCalibRange">The minimum scalar value in the form of float32 obtained through calibration. If present, it will be used to by quantized batch norm op to calculate primitive scale.Note: this calib_range is to calib bn output.</param>
    /// <param name="maxCalibRange">The maximum scalar value in the form of float32 obtained through calibration. If present, it will be used to by quantized batch norm op to calculate primitive scale.Note: this calib_range is to calib bn output.</param>
    static member BatchNorm(outputArray : NDArray seq, 
                            data : NDArray, 
                            gamma : NDArray, 
                            beta : NDArray, 
                            movingMean : NDArray, 
                            movingVar : NDArray, 
                            [<Optional>] ?eps : double, 
                            [<Optional>] ?momentum : float, 
                            [<Optional>] ?fixGamma : bool, 
                            [<Optional>] ?useGlobalStats : bool, 
                            [<Optional>] ?outputMeanVar : bool, 
                            [<Optional>] ?axis : int, 
                            [<Optional>] ?cudnnOff : bool, 
                            [<Optional>] ?minCalibRange : float, 
                            [<Optional>] ?maxCalibRange : float) =
        let creator = AtomicSymbolCreator.FromName "BatchNorm"
        let names = [|"eps"; "momentum"; "fix_gamma"; "use_global_stats"; "output_mean_var"; "axis"; "cudnn_off"; "min_calib_range"; "max_calib_range"|]
        let vals = [|(match eps with None -> "0.00100000004749745" | Some eps -> string eps); (match momentum with None -> "0.899999976" | Some momentum -> string momentum); (match fixGamma with None -> "true" | Some fixGamma -> string fixGamma); (match useGlobalStats with None -> "false" | Some useGlobalStats -> string useGlobalStats); (match outputMeanVar with None -> "false" | Some outputMeanVar -> string outputMeanVar); (match axis with None -> "1" | Some axis -> string axis); (match cudnnOff with None -> "false" | Some cudnnOff -> string cudnnOff); (match minCalibRange with None -> "None" | Some minCalibRange -> string minCalibRange); (match maxCalibRange with None -> "None" | Some maxCalibRange -> string maxCalibRange)|]
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg gamma)) then gamma.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg beta)) then beta.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg movingMean)) then movingMean.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg movingVar)) then movingVar.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <summary>Batch normalization.
    /// 
    /// Normalizes a data batch by mean and variance, and applies a scale ``gamma`` as
    /// well as offset ``beta``.
    /// 
    /// Assume the input has more than one dimension and we normalize along axis 1.
    /// We first compute the mean and variance along this axis:
    /// 
    /// .. math::
    /// 
    ///   data\_mean[i] = mean(data[:,i,:,...]) \\
    ///   data\_var[i] = var(data[:,i,:,...])
    /// 
    /// Then compute the normalized output, which has the same shape as input, as following:
    /// 
    /// .. math::
    /// 
    ///   out[:,i,:,...] = \frac{data[:,i,:,...] - data\_mean[i]}{\sqrt{data\_var[i]+\epsilon}} * gamma[i] + beta[i]
    /// 
    /// Both *mean* and *var* returns a scalar by treating the input as a vector.
    /// 
    /// Assume the input has size *k* on axis 1, then both ``gamma`` and ``beta``
    /// have shape *(k,)*. If ``output_mean_var`` is set to be true, then outputs both ``data_mean`` and
    /// the inverse of ``data_var``, which are needed for the backward pass. Note that gradient of these
    /// two outputs are blocked.
    /// 
    /// Besides the inputs and the outputs, this operator accepts two auxiliary
    /// states, ``moving_mean`` and ``moving_var``, which are *k*-length
    /// vectors. They are global statistics for the whole dataset, which are updated
    /// by::
    /// 
    ///   moving_mean = moving_mean * momentum + data_mean * (1 - momentum)
    ///   moving_var = moving_var * momentum + data_var * (1 - momentum)
    /// 
    /// If ``use_global_stats`` is set to be true, then ``moving_mean`` and
    /// ``moving_var`` are used instead of ``data_mean`` and ``data_var`` to compute
    /// the output. It is often used during inference.
    /// 
    /// The parameter ``axis`` specifies which axis of the input shape denotes
    /// the &#39;channel&#39; (separately normalized groups).  The default is 1.  Specifying -1 sets the channel
    /// axis to be the last item in the input shape.
    /// 
    /// Both ``gamma`` and ``beta`` are learnable parameters. But if ``fix_gamma`` is true,
    /// then set ``gamma`` to 1 and its gradient to 0.
    /// 
    /// .. Note::
    ///   When ``fix_gamma`` is set to True, no sparse support is provided. If ``fix_gamma is`` set to False,
    ///   the sparse tensors will fallback.
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\nn\batch_norm.cc:L571</summary>
    /// <param name="data">Input data to batch normalization</param>
    /// <param name="gamma">gamma array</param>
    /// <param name="beta">beta array</param>
    /// <param name="movingMean">running mean of input</param>
    /// <param name="movingVar">running variance of input</param>
    /// <param name="eps">Epsilon to prevent div 0. Must be no less than CUDNN_BN_MIN_EPSILON defined in cudnn.h when using cudnn (usually 1e-5)</param>
    /// <param name="momentum">Momentum for moving average</param>
    /// <param name="fixGamma">Fix gamma while training</param>
    /// <param name="useGlobalStats">Whether use global moving statistics instead of local batch-norm. This will force change batch-norm into a scale shift operator.</param>
    /// <param name="outputMeanVar">Output the mean and inverse std </param>
    /// <param name="axis">Specify which shape axis the channel is specified</param>
    /// <param name="cudnnOff">Do not select CUDNN operator, if available</param>
    /// <param name="minCalibRange">The minimum scalar value in the form of float32 obtained through calibration. If present, it will be used to by quantized batch norm op to calculate primitive scale.Note: this calib_range is to calib bn output.</param>
    /// <param name="maxCalibRange">The maximum scalar value in the form of float32 obtained through calibration. If present, it will be used to by quantized batch norm op to calculate primitive scale.Note: this calib_range is to calib bn output.</param>
    static member BatchNorm([<Optional>] ?data : Symbol, [<Optional>] ?gamma : Symbol, [<Optional>] ?beta : Symbol, [<Optional>] ?movingMean : Symbol, [<Optional>] ?movingVar : Symbol, [<Optional>] ?eps : double, [<Optional>] ?momentum : float, [<Optional>] ?fixGamma : bool, [<Optional>] ?useGlobalStats : bool, [<Optional>] ?outputMeanVar : bool, [<Optional>] ?axis : int, [<Optional>] ?cudnnOff : bool, [<Optional>] ?minCalibRange : float, [<Optional>] ?maxCalibRange : float) =
        BatchNorm(?data = data, ?gamma = gamma, ?beta = beta, ?movingMean = movingMean, ?movingVar = movingVar, ?eps = eps, ?momentum = momentum, ?fixGamma = fixGamma, ?useGlobalStats = useGlobalStats, ?outputMeanVar = outputMeanVar, ?axis = axis, ?cudnnOff = cudnnOff, ?minCalibRange = minCalibRange, ?maxCalibRange = maxCalibRange)


    /// <summary>Joins input arrays along a given axis.
    /// 
    /// .. note:: `Concat` is deprecated. Use `concat` instead.
    /// 
    /// The dimensions of the input arrays should be the same except the axis along
    /// which they will be concatenated.
    /// The dimension of the output array along the concatenated axis will be equal
    /// to the sum of the corresponding dimensions of the input arrays.
    /// 
    /// The storage type of ``concat`` output depends on storage types of inputs
    /// 
    /// - concat(csr, csr, ..., csr, dim=0) = csr
    /// - otherwise, ``concat`` generates output with default storage
    /// 
    /// Example::
    /// 
    ///    x = [[1,1],[2,2]]
    ///    y = [[3,3],[4,4],[5,5]]
    ///    z = [[6,6], [7,7],[8,8]]
    /// 
    ///    concat(x,y,z,dim=0) = [[ 1.,  1.],
    ///                           [ 2.,  2.],
    ///                           [ 3.,  3.],
    ///                           [ 4.,  4.],
    ///                           [ 5.,  5.],
    ///                           [ 6.,  6.],
    ///                           [ 7.,  7.],
    ///                           [ 8.,  8.]]
    /// 
    ///    Note that you cannot concat x,y,z along dimension 1 since dimension
    ///    0 is not the same for all the input arrays.
    /// 
    ///    concat(y,z,dim=1) = [[ 3.,  3.,  6.,  6.],
    ///                          [ 4.,  4.,  7.,  7.],
    ///                          [ 5.,  5.,  8.,  8.]]
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\nn\concat.cc:L383</summary>
    /// <param name="data">List of arrays to concatenate</param>
    /// <param name="numArgs">Number of inputs to be concated.</param>
    /// <param name="dim">the dimension to be concated.</param>
    static member Concat([<ParamArray>] data : NDArray[], [<Optional; DefaultParameterValue(1)>] dim : int) =
        let creator = AtomicSymbolCreator.FromName "Concat"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 (data |> Array.map (fun x -> x.UnsafeHandle))
                                                 [|"num_args"; "dim"|]
                                                 [|string data.Length; string dim|]
        (new NDArray(outputs.[0]))
    /// <summary>Joins input arrays along a given axis.
    /// 
    /// .. note:: `Concat` is deprecated. Use `concat` instead.
    /// 
    /// The dimensions of the input arrays should be the same except the axis along
    /// which they will be concatenated.
    /// The dimension of the output array along the concatenated axis will be equal
    /// to the sum of the corresponding dimensions of the input arrays.
    /// 
    /// The storage type of ``concat`` output depends on storage types of inputs
    /// 
    /// - concat(csr, csr, ..., csr, dim=0) = csr
    /// - otherwise, ``concat`` generates output with default storage
    /// 
    /// Example::
    /// 
    ///    x = [[1,1],[2,2]]
    ///    y = [[3,3],[4,4],[5,5]]
    ///    z = [[6,6], [7,7],[8,8]]
    /// 
    ///    concat(x,y,z,dim=0) = [[ 1.,  1.],
    ///                           [ 2.,  2.],
    ///                           [ 3.,  3.],
    ///                           [ 4.,  4.],
    ///                           [ 5.,  5.],
    ///                           [ 6.,  6.],
    ///                           [ 7.,  7.],
    ///                           [ 8.,  8.]]
    /// 
    ///    Note that you cannot concat x,y,z along dimension 1 since dimension
    ///    0 is not the same for all the input arrays.
    /// 
    ///    concat(y,z,dim=1) = [[ 3.,  3.,  6.,  6.],
    ///                          [ 4.,  4.,  7.,  7.],
    ///                          [ 5.,  5.,  8.,  8.]]
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\nn\concat.cc:L383</summary>
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="data">List of arrays to concatenate</param>
    /// <param name="numArgs">Number of inputs to be concated.</param>
    /// <param name="dim">the dimension to be concated.</param>
    static member Concat(outputArray : NDArray seq, [<ParamArray>] data : NDArray[], [<Optional; DefaultParameterValue(1)>] dim : int) =
        let creator = AtomicSymbolCreator.FromName "Concat"
        let names = [|"num_args"; "dim"|]
        let vals = [|string data.Length; string dim|]
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     (data |> Array.map (fun x -> x.UnsafeHandle))
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <summary>Joins input arrays along a given axis.
    /// 
    /// .. note:: `Concat` is deprecated. Use `concat` instead.
    /// 
    /// The dimensions of the input arrays should be the same except the axis along
    /// which they will be concatenated.
    /// The dimension of the output array along the concatenated axis will be equal
    /// to the sum of the corresponding dimensions of the input arrays.
    /// 
    /// The storage type of ``concat`` output depends on storage types of inputs
    /// 
    /// - concat(csr, csr, ..., csr, dim=0) = csr
    /// - otherwise, ``concat`` generates output with default storage
    /// 
    /// Example::
    /// 
    ///    x = [[1,1],[2,2]]
    ///    y = [[3,3],[4,4],[5,5]]
    ///    z = [[6,6], [7,7],[8,8]]
    /// 
    ///    concat(x,y,z,dim=0) = [[ 1.,  1.],
    ///                           [ 2.,  2.],
    ///                           [ 3.,  3.],
    ///                           [ 4.,  4.],
    ///                           [ 5.,  5.],
    ///                           [ 6.,  6.],
    ///                           [ 7.,  7.],
    ///                           [ 8.,  8.]]
    /// 
    ///    Note that you cannot concat x,y,z along dimension 1 since dimension
    ///    0 is not the same for all the input arrays.
    /// 
    ///    concat(y,z,dim=1) = [[ 3.,  3.,  6.,  6.],
    ///                          [ 4.,  4.,  7.,  7.],
    ///                          [ 5.,  5.,  8.,  8.]]
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\nn\concat.cc:L383</summary>
    /// <param name="data">List of arrays to concatenate</param>
    /// <param name="dim">the dimension to be concated.</param>
    static member Concat([<Optional>] ?data : Symbol seq, [<Optional>] ?dim : int) =
        Concat(?data = data, ?dim = dim)


    /// <param name="data">List of arrays to concatenate</param>
    /// <param name="numArgs">Number of inputs to be concated.</param>
    /// <param name="dim">the dimension to be concated.</param>
    static member RnnParamConcat([<ParamArray>] data : NDArray[], [<Optional; DefaultParameterValue(1)>] dim : int) =
        let creator = AtomicSymbolCreator.FromName "_rnn_param_concat"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 (data |> Array.map (fun x -> x.UnsafeHandle))
                                                 [|"num_args"; "dim"|]
                                                 [|string data.Length; string dim|]
        outputs |> Array.map (fun h -> new NDArray(h))
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="data">List of arrays to concatenate</param>
    /// <param name="numArgs">Number of inputs to be concated.</param>
    /// <param name="dim">the dimension to be concated.</param>
    static member RnnParamConcat(outputArray : NDArray seq, [<ParamArray>] data : NDArray[], [<Optional; DefaultParameterValue(1)>] dim : int) =
        let creator = AtomicSymbolCreator.FromName "_rnn_param_concat"
        let names = [|"num_args"; "dim"|]
        let vals = [|string data.Length; string dim|]
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     (data |> Array.map (fun x -> x.UnsafeHandle))
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <param name="data">List of arrays to concatenate</param>
    /// <param name="dim">the dimension to be concated.</param>
    static member RnnParamConcat([<Optional>] ?data : Symbol seq, [<Optional>] ?dim : int) =
        RnnParamConcat(?data = data, ?dim = dim)

    /// <summary>Compute *N*-D convolution on *(N+2)*-D input.
    /// 
    /// In the 2-D convolution, given input data with shape *(batch_size,
    /// channel, height, width)*, the output is computed by
    /// 
    /// .. math::
    /// 
    ///    out[n,i,:,:] = bias[i] + \sum_{j=0}^{channel} data[n,j,:,:] \star
    ///    weight[i,j,:,:]
    /// 
    /// where :math:`\star` is the 2-D cross-correlation operator.
    /// 
    /// For general 2-D convolution, the shapes are
    /// 
    /// - **data**: *(batch_size, channel, height, width)*
    /// - **weight**: *(num_filter, channel, kernel[0], kernel[1])*
    /// - **bias**: *(num_filter,)*
    /// - **out**: *(batch_size, num_filter, out_height, out_width)*.
    /// 
    /// Define::
    /// 
    ///   f(x,k,p,s,d) = floor((x+2*p-d*(k-1)-1)/s)+1
    /// 
    /// then we have::
    /// 
    ///   out_height=f(height, kernel[0], pad[0], stride[0], dilate[0])
    ///   out_width=f(width, kernel[1], pad[1], stride[1], dilate[1])
    /// 
    /// If ``no_bias`` is set to be true, then the ``bias`` term is ignored.
    /// 
    /// The default data ``layout`` is *NCHW*, namely *(batch_size, channel, height,
    /// width)*. We can choose other layouts such as *NWC*.
    /// 
    /// If ``num_group`` is larger than 1, denoted by *g*, then split the input ``data``
    /// evenly into *g* parts along the channel axis, and also evenly split ``weight``
    /// along the first dimension. Next compute the convolution on the *i*-th part of
    /// the data with the *i*-th weight part. The output is obtained by concatenating all
    /// the *g* results.
    /// 
    /// 1-D convolution does not have *height* dimension but only *width* in space.
    /// 
    /// - **data**: *(batch_size, channel, width)*
    /// - **weight**: *(num_filter, channel, kernel[0])*
    /// - **bias**: *(num_filter,)*
    /// - **out**: *(batch_size, num_filter, out_width)*.
    /// 
    /// 3-D convolution adds an additional *depth* dimension besides *height* and
    /// *width*. The shapes are
    /// 
    /// - **data**: *(batch_size, channel, depth, height, width)*
    /// - **weight**: *(num_filter, channel, kernel[0], kernel[1], kernel[2])*
    /// - **bias**: *(num_filter,)*
    /// - **out**: *(batch_size, num_filter, out_depth, out_height, out_width)*.
    /// 
    /// Both ``weight`` and ``bias`` are learnable parameters.
    /// 
    /// There are other options to tune the performance.
    /// 
    /// - **cudnn_tune**: enable this option leads to higher startup time but may give
    ///   faster speed. Options are
    /// 
    ///   - **off**: no tuning
    ///   - **limited_workspace**:run test and pick the fastest algorithm that doesn&#39;t
    ///     exceed workspace limit.
    ///   - **fastest**: pick the fastest algorithm and ignore workspace limit.
    ///   - **None** (default): the behavior is determined by environment variable
    ///     ``MXNET_CUDNN_AUTOTUNE_DEFAULT``. 0 for off, 1 for limited workspace
    ///     (default), 2 for fastest.
    /// 
    /// - **workspace**: A large number leads to more (GPU) memory usage but may improve
    ///   the performance.
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\nn\convolution.cc:L473</summary>
    /// <param name="data">Input data to the ConvolutionOp.</param>
    /// <param name="weight">Weight matrix.</param>
    /// <param name="bias">Bias parameter.</param>
    /// <param name="kernel">Convolution kernel size: (w,), (h, w) or (d, h, w)</param>
    /// <param name="numFilter">Convolution filter(channel) number</param>
    /// <param name="stride">Convolution stride: (w,), (h, w) or (d, h, w). Defaults to 1 for each dimension.</param>
    /// <param name="dilate">Convolution dilate: (w,), (h, w) or (d, h, w). Defaults to 1 for each dimension.</param>
    /// <param name="pad">Zero pad for convolution: (w,), (h, w) or (d, h, w). Defaults to no padding.</param>
    /// <param name="numGroup">Number of group partitions.</param>
    /// <param name="workspace">Maximum temporary workspace allowed (MB) in convolution.This parameter has two usages. When CUDNN is not used, it determines the effective batch size of the convolution kernel. When CUDNN is used, it controls the maximum temporary storage used for tuning the best CUDNN kernel when `limited_workspace` strategy is used.</param>
    /// <param name="noBias">Whether to disable bias parameter.</param>
    /// <param name="cudnnTune">Whether to pick convolution algo by running performance test.</param>
    /// <param name="cudnnOff">Turn off cudnn for this layer.</param>
    /// <param name="layout">Set layout for input, output and weight. Empty for
    ///     default layout: NCW for 1d, NCHW for 2d and NCDHW for 3d.NHWC and NDHWC are only supported on GPU.</param>
    static member Convolution(data : NDArray, 
                              weight : NDArray, 
                              bias : NDArray, 
                              kernel : int seq, 
                              numFilter : int, 
                              [<Optional>] stride : int seq, 
                              [<Optional>] dilate : int seq, 
                              [<Optional>] pad : int seq, 
                              [<Optional; DefaultParameterValue(1)>] numGroup : int, 
                              [<Optional; DefaultParameterValue(1024L)>] workspace : int64, 
                              [<Optional; DefaultParameterValue(false)>] noBias : bool, 
                              [<Optional>] cudnnTune : CudnnTune, 
                              [<Optional; DefaultParameterValue(false)>] cudnnOff : bool, 
                              [<Optional>] layout : ConvolutionLayout) =
        let creator = AtomicSymbolCreator.FromName "Convolution"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg weight)) then weight.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg bias)) then bias.UnsafeHandle|]
                                                 [|"kernel"; "num_filter"; "stride"; "dilate"; "pad"; "num_group"; "workspace"; "no_bias"; "cudnn_tune"; "cudnn_off"; "layout"|]
                                                 [|(kernel |> Seq.map string |> String.concat ", " |> sprintf "[%s]"); string numFilter; (if isNull (stride :> obj) then "[]" else (stride |> Seq.map string |> String.concat ", " |> sprintf "[%s]")); (if isNull (dilate :> obj) then "[]" else (dilate |> Seq.map string |> String.concat ", " |> sprintf "[%s]")); (if isNull (pad :> obj) then "[]" else (pad |> Seq.map string |> String.concat ", " |> sprintf "[%s]")); string numGroup; string workspace; string noBias; (if isNull (cudnnTune :> obj) then "None" else string cudnnTune); string cudnnOff; (if isNull (layout :> obj) then "None" else string layout)|]
        (new NDArray(outputs.[0]))
    /// <summary>Compute *N*-D convolution on *(N+2)*-D input.
    /// 
    /// In the 2-D convolution, given input data with shape *(batch_size,
    /// channel, height, width)*, the output is computed by
    /// 
    /// .. math::
    /// 
    ///    out[n,i,:,:] = bias[i] + \sum_{j=0}^{channel} data[n,j,:,:] \star
    ///    weight[i,j,:,:]
    /// 
    /// where :math:`\star` is the 2-D cross-correlation operator.
    /// 
    /// For general 2-D convolution, the shapes are
    /// 
    /// - **data**: *(batch_size, channel, height, width)*
    /// - **weight**: *(num_filter, channel, kernel[0], kernel[1])*
    /// - **bias**: *(num_filter,)*
    /// - **out**: *(batch_size, num_filter, out_height, out_width)*.
    /// 
    /// Define::
    /// 
    ///   f(x,k,p,s,d) = floor((x+2*p-d*(k-1)-1)/s)+1
    /// 
    /// then we have::
    /// 
    ///   out_height=f(height, kernel[0], pad[0], stride[0], dilate[0])
    ///   out_width=f(width, kernel[1], pad[1], stride[1], dilate[1])
    /// 
    /// If ``no_bias`` is set to be true, then the ``bias`` term is ignored.
    /// 
    /// The default data ``layout`` is *NCHW*, namely *(batch_size, channel, height,
    /// width)*. We can choose other layouts such as *NWC*.
    /// 
    /// If ``num_group`` is larger than 1, denoted by *g*, then split the input ``data``
    /// evenly into *g* parts along the channel axis, and also evenly split ``weight``
    /// along the first dimension. Next compute the convolution on the *i*-th part of
    /// the data with the *i*-th weight part. The output is obtained by concatenating all
    /// the *g* results.
    /// 
    /// 1-D convolution does not have *height* dimension but only *width* in space.
    /// 
    /// - **data**: *(batch_size, channel, width)*
    /// - **weight**: *(num_filter, channel, kernel[0])*
    /// - **bias**: *(num_filter,)*
    /// - **out**: *(batch_size, num_filter, out_width)*.
    /// 
    /// 3-D convolution adds an additional *depth* dimension besides *height* and
    /// *width*. The shapes are
    /// 
    /// - **data**: *(batch_size, channel, depth, height, width)*
    /// - **weight**: *(num_filter, channel, kernel[0], kernel[1], kernel[2])*
    /// - **bias**: *(num_filter,)*
    /// - **out**: *(batch_size, num_filter, out_depth, out_height, out_width)*.
    /// 
    /// Both ``weight`` and ``bias`` are learnable parameters.
    /// 
    /// There are other options to tune the performance.
    /// 
    /// - **cudnn_tune**: enable this option leads to higher startup time but may give
    ///   faster speed. Options are
    /// 
    ///   - **off**: no tuning
    ///   - **limited_workspace**:run test and pick the fastest algorithm that doesn&#39;t
    ///     exceed workspace limit.
    ///   - **fastest**: pick the fastest algorithm and ignore workspace limit.
    ///   - **None** (default): the behavior is determined by environment variable
    ///     ``MXNET_CUDNN_AUTOTUNE_DEFAULT``. 0 for off, 1 for limited workspace
    ///     (default), 2 for fastest.
    /// 
    /// - **workspace**: A large number leads to more (GPU) memory usage but may improve
    ///   the performance.
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\nn\convolution.cc:L473</summary>
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="data">Input data to the ConvolutionOp.</param>
    /// <param name="weight">Weight matrix.</param>
    /// <param name="bias">Bias parameter.</param>
    /// <param name="kernel">Convolution kernel size: (w,), (h, w) or (d, h, w)</param>
    /// <param name="numFilter">Convolution filter(channel) number</param>
    /// <param name="stride">Convolution stride: (w,), (h, w) or (d, h, w). Defaults to 1 for each dimension.</param>
    /// <param name="dilate">Convolution dilate: (w,), (h, w) or (d, h, w). Defaults to 1 for each dimension.</param>
    /// <param name="pad">Zero pad for convolution: (w,), (h, w) or (d, h, w). Defaults to no padding.</param>
    /// <param name="numGroup">Number of group partitions.</param>
    /// <param name="workspace">Maximum temporary workspace allowed (MB) in convolution.This parameter has two usages. When CUDNN is not used, it determines the effective batch size of the convolution kernel. When CUDNN is used, it controls the maximum temporary storage used for tuning the best CUDNN kernel when `limited_workspace` strategy is used.</param>
    /// <param name="noBias">Whether to disable bias parameter.</param>
    /// <param name="cudnnTune">Whether to pick convolution algo by running performance test.</param>
    /// <param name="cudnnOff">Turn off cudnn for this layer.</param>
    /// <param name="layout">Set layout for input, output and weight. Empty for
    ///     default layout: NCW for 1d, NCHW for 2d and NCDHW for 3d.NHWC and NDHWC are only supported on GPU.</param>
    static member Convolution(outputArray : NDArray seq, 
                              data : NDArray, 
                              weight : NDArray, 
                              bias : NDArray, 
                              kernel : int seq, 
                              numFilter : int, 
                              [<Optional>] stride : int seq, 
                              [<Optional>] dilate : int seq, 
                              [<Optional>] pad : int seq, 
                              [<Optional; DefaultParameterValue(1)>] numGroup : int, 
                              [<Optional; DefaultParameterValue(1024L)>] workspace : int64, 
                              [<Optional; DefaultParameterValue(false)>] noBias : bool, 
                              [<Optional>] cudnnTune : CudnnTune, 
                              [<Optional; DefaultParameterValue(false)>] cudnnOff : bool, 
                              [<Optional>] layout : ConvolutionLayout) =
        let creator = AtomicSymbolCreator.FromName "Convolution"
        let names = [|"kernel"; "num_filter"; "stride"; "dilate"; "pad"; "num_group"; "workspace"; "no_bias"; "cudnn_tune"; "cudnn_off"; "layout"|]
        let vals = [|(kernel |> Seq.map string |> String.concat ", " |> sprintf "[%s]"); string numFilter; (if isNull (stride :> obj) then "[]" else (stride |> Seq.map string |> String.concat ", " |> sprintf "[%s]")); (if isNull (dilate :> obj) then "[]" else (dilate |> Seq.map string |> String.concat ", " |> sprintf "[%s]")); (if isNull (pad :> obj) then "[]" else (pad |> Seq.map string |> String.concat ", " |> sprintf "[%s]")); string numGroup; string workspace; string noBias; (if isNull (cudnnTune :> obj) then "None" else string cudnnTune); string cudnnOff; (if isNull (layout :> obj) then "None" else string layout)|]
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg weight)) then weight.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg bias)) then bias.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <summary>Compute *N*-D convolution on *(N+2)*-D input.
    /// 
    /// In the 2-D convolution, given input data with shape *(batch_size,
    /// channel, height, width)*, the output is computed by
    /// 
    /// .. math::
    /// 
    ///    out[n,i,:,:] = bias[i] + \sum_{j=0}^{channel} data[n,j,:,:] \star
    ///    weight[i,j,:,:]
    /// 
    /// where :math:`\star` is the 2-D cross-correlation operator.
    /// 
    /// For general 2-D convolution, the shapes are
    /// 
    /// - **data**: *(batch_size, channel, height, width)*
    /// - **weight**: *(num_filter, channel, kernel[0], kernel[1])*
    /// - **bias**: *(num_filter,)*
    /// - **out**: *(batch_size, num_filter, out_height, out_width)*.
    /// 
    /// Define::
    /// 
    ///   f(x,k,p,s,d) = floor((x+2*p-d*(k-1)-1)/s)+1
    /// 
    /// then we have::
    /// 
    ///   out_height=f(height, kernel[0], pad[0], stride[0], dilate[0])
    ///   out_width=f(width, kernel[1], pad[1], stride[1], dilate[1])
    /// 
    /// If ``no_bias`` is set to be true, then the ``bias`` term is ignored.
    /// 
    /// The default data ``layout`` is *NCHW*, namely *(batch_size, channel, height,
    /// width)*. We can choose other layouts such as *NWC*.
    /// 
    /// If ``num_group`` is larger than 1, denoted by *g*, then split the input ``data``
    /// evenly into *g* parts along the channel axis, and also evenly split ``weight``
    /// along the first dimension. Next compute the convolution on the *i*-th part of
    /// the data with the *i*-th weight part. The output is obtained by concatenating all
    /// the *g* results.
    /// 
    /// 1-D convolution does not have *height* dimension but only *width* in space.
    /// 
    /// - **data**: *(batch_size, channel, width)*
    /// - **weight**: *(num_filter, channel, kernel[0])*
    /// - **bias**: *(num_filter,)*
    /// - **out**: *(batch_size, num_filter, out_width)*.
    /// 
    /// 3-D convolution adds an additional *depth* dimension besides *height* and
    /// *width*. The shapes are
    /// 
    /// - **data**: *(batch_size, channel, depth, height, width)*
    /// - **weight**: *(num_filter, channel, kernel[0], kernel[1], kernel[2])*
    /// - **bias**: *(num_filter,)*
    /// - **out**: *(batch_size, num_filter, out_depth, out_height, out_width)*.
    /// 
    /// Both ``weight`` and ``bias`` are learnable parameters.
    /// 
    /// There are other options to tune the performance.
    /// 
    /// - **cudnn_tune**: enable this option leads to higher startup time but may give
    ///   faster speed. Options are
    /// 
    ///   - **off**: no tuning
    ///   - **limited_workspace**:run test and pick the fastest algorithm that doesn&#39;t
    ///     exceed workspace limit.
    ///   - **fastest**: pick the fastest algorithm and ignore workspace limit.
    ///   - **None** (default): the behavior is determined by environment variable
    ///     ``MXNET_CUDNN_AUTOTUNE_DEFAULT``. 0 for off, 1 for limited workspace
    ///     (default), 2 for fastest.
    /// 
    /// - **workspace**: A large number leads to more (GPU) memory usage but may improve
    ///   the performance.
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\nn\convolution.cc:L473</summary>
    /// <param name="data">Input data to the ConvolutionOp.</param>
    /// <param name="weight">Weight matrix.</param>
    /// <param name="bias">Bias parameter.</param>
    /// <param name="kernel">Convolution kernel size: (w,), (h, w) or (d, h, w)</param>
    /// <param name="numFilter">Convolution filter(channel) number</param>
    /// <param name="stride">Convolution stride: (w,), (h, w) or (d, h, w). Defaults to 1 for each dimension.</param>
    /// <param name="dilate">Convolution dilate: (w,), (h, w) or (d, h, w). Defaults to 1 for each dimension.</param>
    /// <param name="pad">Zero pad for convolution: (w,), (h, w) or (d, h, w). Defaults to no padding.</param>
    /// <param name="numGroup">Number of group partitions.</param>
    /// <param name="workspace">Maximum temporary workspace allowed (MB) in convolution.This parameter has two usages. When CUDNN is not used, it determines the effective batch size of the convolution kernel. When CUDNN is used, it controls the maximum temporary storage used for tuning the best CUDNN kernel when `limited_workspace` strategy is used.</param>
    /// <param name="noBias">Whether to disable bias parameter.</param>
    /// <param name="cudnnTune">Whether to pick convolution algo by running performance test.</param>
    /// <param name="cudnnOff">Turn off cudnn for this layer.</param>
    /// <param name="layout">Set layout for input, output and weight. Empty for
    ///     default layout: NCW for 1d, NCHW for 2d and NCDHW for 3d.NHWC and NDHWC are only supported on GPU.</param>
    static member Convolution(data : Symbol, weight : Symbol, bias : Symbol, kernel : int seq, numFilter : int, [<Optional>] ?stride : int seq, [<Optional>] ?dilate : int seq, [<Optional>] ?pad : int seq, [<Optional>] ?numGroup : int, [<Optional>] ?workspace : int64, [<Optional>] ?noBias : bool, [<Optional>] ?cudnnTune : CudnnTune, [<Optional>] ?cudnnOff : bool, [<Optional>] ?layout : ConvolutionLayout) =
        Convolution(data, weight, bias, kernel, numFilter, ?stride = stride, ?dilate = dilate, ?pad = pad, ?numGroup = numGroup, ?workspace = workspace, ?noBias = noBias, ?cudnnTune = cudnnTune, ?cudnnOff = cudnnOff, ?layout = layout)
    /// <summary>Compute *N*-D convolution on *(N+2)*-D input.
    /// 
    /// In the 2-D convolution, given input data with shape *(batch_size,
    /// channel, height, width)*, the output is computed by
    /// 
    /// .. math::
    /// 
    ///    out[n,i,:,:] = bias[i] + \sum_{j=0}^{channel} data[n,j,:,:] \star
    ///    weight[i,j,:,:]
    /// 
    /// where :math:`\star` is the 2-D cross-correlation operator.
    /// 
    /// For general 2-D convolution, the shapes are
    /// 
    /// - **data**: *(batch_size, channel, height, width)*
    /// - **weight**: *(num_filter, channel, kernel[0], kernel[1])*
    /// - **bias**: *(num_filter,)*
    /// - **out**: *(batch_size, num_filter, out_height, out_width)*.
    /// 
    /// Define::
    /// 
    ///   f(x,k,p,s,d) = floor((x+2*p-d*(k-1)-1)/s)+1
    /// 
    /// then we have::
    /// 
    ///   out_height=f(height, kernel[0], pad[0], stride[0], dilate[0])
    ///   out_width=f(width, kernel[1], pad[1], stride[1], dilate[1])
    /// 
    /// If ``no_bias`` is set to be true, then the ``bias`` term is ignored.
    /// 
    /// The default data ``layout`` is *NCHW*, namely *(batch_size, channel, height,
    /// width)*. We can choose other layouts such as *NWC*.
    /// 
    /// If ``num_group`` is larger than 1, denoted by *g*, then split the input ``data``
    /// evenly into *g* parts along the channel axis, and also evenly split ``weight``
    /// along the first dimension. Next compute the convolution on the *i*-th part of
    /// the data with the *i*-th weight part. The output is obtained by concatenating all
    /// the *g* results.
    /// 
    /// 1-D convolution does not have *height* dimension but only *width* in space.
    /// 
    /// - **data**: *(batch_size, channel, width)*
    /// - **weight**: *(num_filter, channel, kernel[0])*
    /// - **bias**: *(num_filter,)*
    /// - **out**: *(batch_size, num_filter, out_width)*.
    /// 
    /// 3-D convolution adds an additional *depth* dimension besides *height* and
    /// *width*. The shapes are
    /// 
    /// - **data**: *(batch_size, channel, depth, height, width)*
    /// - **weight**: *(num_filter, channel, kernel[0], kernel[1], kernel[2])*
    /// - **bias**: *(num_filter,)*
    /// - **out**: *(batch_size, num_filter, out_depth, out_height, out_width)*.
    /// 
    /// Both ``weight`` and ``bias`` are learnable parameters.
    /// 
    /// There are other options to tune the performance.
    /// 
    /// - **cudnn_tune**: enable this option leads to higher startup time but may give
    ///   faster speed. Options are
    /// 
    ///   - **off**: no tuning
    ///   - **limited_workspace**:run test and pick the fastest algorithm that doesn&#39;t
    ///     exceed workspace limit.
    ///   - **fastest**: pick the fastest algorithm and ignore workspace limit.
    ///   - **None** (default): the behavior is determined by environment variable
    ///     ``MXNET_CUDNN_AUTOTUNE_DEFAULT``. 0 for off, 1 for limited workspace
    ///     (default), 2 for fastest.
    /// 
    /// - **workspace**: A large number leads to more (GPU) memory usage but may improve
    ///   the performance.
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\nn\convolution.cc:L473</summary>
    /// <param name="kernel">Convolution kernel size: (w,), (h, w) or (d, h, w)</param>
    /// <param name="numFilter">Convolution filter(channel) number</param>
    /// <param name="data">Input data to the ConvolutionOp.</param>
    /// <param name="weight">Weight matrix.</param>
    /// <param name="bias">Bias parameter.</param>
    /// <param name="stride">Convolution stride: (w,), (h, w) or (d, h, w). Defaults to 1 for each dimension.</param>
    /// <param name="dilate">Convolution dilate: (w,), (h, w) or (d, h, w). Defaults to 1 for each dimension.</param>
    /// <param name="pad">Zero pad for convolution: (w,), (h, w) or (d, h, w). Defaults to no padding.</param>
    /// <param name="numGroup">Number of group partitions.</param>
    /// <param name="workspace">Maximum temporary workspace allowed (MB) in convolution.This parameter has two usages. When CUDNN is not used, it determines the effective batch size of the convolution kernel. When CUDNN is used, it controls the maximum temporary storage used for tuning the best CUDNN kernel when `limited_workspace` strategy is used.</param>
    /// <param name="noBias">Whether to disable bias parameter.</param>
    /// <param name="cudnnTune">Whether to pick convolution algo by running performance test.</param>
    /// <param name="cudnnOff">Turn off cudnn for this layer.</param>
    /// <param name="layout">Set layout for input, output and weight. Empty for
    ///     default layout: NCW for 1d, NCHW for 2d and NCDHW for 3d.NHWC and NDHWC are only supported on GPU.</param>
    static member Convolution(kernel : int seq, numFilter : int, [<Optional>] ?data : Symbol, [<Optional>] ?weight : Symbol, [<Optional>] ?bias : Symbol, [<Optional>] ?stride : int seq, [<Optional>] ?dilate : int seq, [<Optional>] ?pad : int seq, [<Optional>] ?numGroup : int, [<Optional>] ?workspace : int64, [<Optional>] ?noBias : bool, [<Optional>] ?cudnnTune : CudnnTune, [<Optional>] ?cudnnOff : bool, [<Optional>] ?layout : ConvolutionLayout) =
        Convolution(kernel, numFilter, ?data = data, ?weight = weight, ?bias = bias, ?stride = stride, ?dilate = dilate, ?pad = pad, ?numGroup = numGroup, ?workspace = workspace, ?noBias = noBias, ?cudnnTune = cudnnTune, ?cudnnOff = cudnnOff, ?layout = layout)


    /// <summary>Connectionist Temporal Classification Loss.
    /// 
    /// .. note:: The existing alias ``contrib_CTCLoss`` is deprecated.
    /// 
    /// The shapes of the inputs and outputs:
    /// 
    /// - **data**: `(sequence_length, batch_size, alphabet_size)`
    /// - **label**: `(batch_size, label_sequence_length)`
    /// - **out**: `(batch_size)`
    /// 
    /// The `data` tensor consists of sequences of activation vectors (without applying softmax),
    /// with i-th channel in the last dimension corresponding to i-th label
    /// for i between 0 and alphabet_size-1 (i.e always 0-indexed).
    /// Alphabet size should include one additional value reserved for blank label.
    /// When `blank_label` is ``&quot;first&quot;``, the ``0``-th channel is be reserved for
    /// activation of blank label, or otherwise if it is &quot;last&quot;, ``(alphabet_size-1)``-th channel should be
    /// reserved for blank label.
    /// 
    /// ``label`` is an index matrix of integers. When `blank_label` is ``&quot;first&quot;``,
    /// the value 0 is then reserved for blank label, and should not be passed in this matrix. Otherwise,
    /// when `blank_label` is ``&quot;last&quot;``, the value `(alphabet_size-1)` is reserved for blank label.
    /// 
    /// If a sequence of labels is shorter than *label_sequence_length*, use the special
    /// padding value at the end of the sequence to conform it to the correct
    /// length. The padding value is `0` when `blank_label` is ``&quot;first&quot;``, and `-1` otherwise.
    /// 
    /// For example, suppose the vocabulary is `[a, b, c]`, and in one batch we have three sequences
    /// &#39;ba&#39;, &#39;cbb&#39;, and &#39;abac&#39;. When `blank_label` is ``&quot;first&quot;``, we can index the labels as
    /// `{&#39;a&#39;: 1, &#39;b&#39;: 2, &#39;c&#39;: 3}`, and we reserve the 0-th channel for blank label in data tensor.
    /// The resulting `label` tensor should be padded to be::
    /// 
    ///   [[2, 1, 0, 0], [3, 2, 2, 0], [1, 2, 1, 3]]
    /// 
    /// When `blank_label` is ``&quot;last&quot;``, we can index the labels as
    /// `{&#39;a&#39;: 0, &#39;b&#39;: 1, &#39;c&#39;: 2}`, and we reserve the channel index 3 for blank label in data tensor.
    /// The resulting `label` tensor should be padded to be::
    /// 
    ///   [[1, 0, -1, -1], [2, 1, 1, -1], [0, 1, 0, 2]]
    /// 
    /// ``out`` is a list of CTC loss values, one per example in the batch.
    /// 
    /// See *Connectionist Temporal Classification: Labelling Unsegmented
    /// Sequence Data with Recurrent Neural Networks*, A. Graves *et al*. for more
    /// information on the definition and the algorithm.
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\nn\ctc_loss.cc:L100</summary>
    /// <param name="data">Input ndarray</param>
    /// <param name="label">Ground-truth labels for the loss.</param>
    /// <param name="dataLengths">Lengths of data for each of the samples. Only required when use_data_lengths is true.</param>
    /// <param name="labelLengths">Lengths of labels for each of the samples. Only required when use_label_lengths is true.</param>
    /// <param name="useDataLengths">Whether the data lenghts are decided by `data_lengths`. If false, the lengths are equal to the max sequence length.</param>
    /// <param name="useLabelLengths">Whether the label lenghts are decided by `label_lengths`, or derived from `padding_mask`. If false, the lengths are derived from the first occurrence of the value of `padding_mask`. The value of `padding_mask` is ``0`` when first CTC label is reserved for blank, and ``-1`` when last label is reserved for blank. See `blank_label`.</param>
    /// <param name="blankLabel">Set the label that is reserved for blank label.If &quot;first&quot;, 0-th label is reserved, and label values for tokens in the vocabulary are between ``1`` and ``alphabet_size-1``, and the padding mask is ``-1``. If &quot;last&quot;, last label value ``alphabet_size-1`` is reserved for blank label instead, and label values for tokens in the vocabulary are between ``0`` and ``alphabet_size-2``, and the padding mask is ``0``.</param>
    static member CTCLoss(data : NDArray, 
                          label : NDArray, 
                          dataLengths : NDArray, 
                          labelLengths : NDArray, 
                          [<Optional; DefaultParameterValue(false)>] useDataLengths : bool, 
                          [<Optional; DefaultParameterValue(false)>] useLabelLengths : bool, 
                          [<Optional>] blankLabel : BlankLabel) =
        let creator = AtomicSymbolCreator.FromName "CTCLoss"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg label)) then label.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg dataLengths)) then dataLengths.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg labelLengths)) then labelLengths.UnsafeHandle|]
                                                 [|"use_data_lengths"; "use_label_lengths"; "blank_label"|]
                                                 [|string useDataLengths; string useLabelLengths; (if isNull (blankLabel :> obj) then "first" else string blankLabel)|]
        (new NDArray(outputs.[0]))
    /// <summary>Connectionist Temporal Classification Loss.
    /// 
    /// .. note:: The existing alias ``contrib_CTCLoss`` is deprecated.
    /// 
    /// The shapes of the inputs and outputs:
    /// 
    /// - **data**: `(sequence_length, batch_size, alphabet_size)`
    /// - **label**: `(batch_size, label_sequence_length)`
    /// - **out**: `(batch_size)`
    /// 
    /// The `data` tensor consists of sequences of activation vectors (without applying softmax),
    /// with i-th channel in the last dimension corresponding to i-th label
    /// for i between 0 and alphabet_size-1 (i.e always 0-indexed).
    /// Alphabet size should include one additional value reserved for blank label.
    /// When `blank_label` is ``&quot;first&quot;``, the ``0``-th channel is be reserved for
    /// activation of blank label, or otherwise if it is &quot;last&quot;, ``(alphabet_size-1)``-th channel should be
    /// reserved for blank label.
    /// 
    /// ``label`` is an index matrix of integers. When `blank_label` is ``&quot;first&quot;``,
    /// the value 0 is then reserved for blank label, and should not be passed in this matrix. Otherwise,
    /// when `blank_label` is ``&quot;last&quot;``, the value `(alphabet_size-1)` is reserved for blank label.
    /// 
    /// If a sequence of labels is shorter than *label_sequence_length*, use the special
    /// padding value at the end of the sequence to conform it to the correct
    /// length. The padding value is `0` when `blank_label` is ``&quot;first&quot;``, and `-1` otherwise.
    /// 
    /// For example, suppose the vocabulary is `[a, b, c]`, and in one batch we have three sequences
    /// &#39;ba&#39;, &#39;cbb&#39;, and &#39;abac&#39;. When `blank_label` is ``&quot;first&quot;``, we can index the labels as
    /// `{&#39;a&#39;: 1, &#39;b&#39;: 2, &#39;c&#39;: 3}`, and we reserve the 0-th channel for blank label in data tensor.
    /// The resulting `label` tensor should be padded to be::
    /// 
    ///   [[2, 1, 0, 0], [3, 2, 2, 0], [1, 2, 1, 3]]
    /// 
    /// When `blank_label` is ``&quot;last&quot;``, we can index the labels as
    /// `{&#39;a&#39;: 0, &#39;b&#39;: 1, &#39;c&#39;: 2}`, and we reserve the channel index 3 for blank label in data tensor.
    /// The resulting `label` tensor should be padded to be::
    /// 
    ///   [[1, 0, -1, -1], [2, 1, 1, -1], [0, 1, 0, 2]]
    /// 
    /// ``out`` is a list of CTC loss values, one per example in the batch.
    /// 
    /// See *Connectionist Temporal Classification: Labelling Unsegmented
    /// Sequence Data with Recurrent Neural Networks*, A. Graves *et al*. for more
    /// information on the definition and the algorithm.
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\nn\ctc_loss.cc:L100</summary>
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="data">Input ndarray</param>
    /// <param name="label">Ground-truth labels for the loss.</param>
    /// <param name="dataLengths">Lengths of data for each of the samples. Only required when use_data_lengths is true.</param>
    /// <param name="labelLengths">Lengths of labels for each of the samples. Only required when use_label_lengths is true.</param>
    /// <param name="useDataLengths">Whether the data lenghts are decided by `data_lengths`. If false, the lengths are equal to the max sequence length.</param>
    /// <param name="useLabelLengths">Whether the label lenghts are decided by `label_lengths`, or derived from `padding_mask`. If false, the lengths are derived from the first occurrence of the value of `padding_mask`. The value of `padding_mask` is ``0`` when first CTC label is reserved for blank, and ``-1`` when last label is reserved for blank. See `blank_label`.</param>
    /// <param name="blankLabel">Set the label that is reserved for blank label.If &quot;first&quot;, 0-th label is reserved, and label values for tokens in the vocabulary are between ``1`` and ``alphabet_size-1``, and the padding mask is ``-1``. If &quot;last&quot;, last label value ``alphabet_size-1`` is reserved for blank label instead, and label values for tokens in the vocabulary are between ``0`` and ``alphabet_size-2``, and the padding mask is ``0``.</param>
    static member CTCLoss(outputArray : NDArray seq, 
                          data : NDArray, 
                          label : NDArray, 
                          dataLengths : NDArray, 
                          labelLengths : NDArray, 
                          [<Optional; DefaultParameterValue(false)>] useDataLengths : bool, 
                          [<Optional; DefaultParameterValue(false)>] useLabelLengths : bool, 
                          [<Optional>] blankLabel : BlankLabel) =
        let creator = AtomicSymbolCreator.FromName "CTCLoss"
        let names = [|"use_data_lengths"; "use_label_lengths"; "blank_label"|]
        let vals = [|string useDataLengths; string useLabelLengths; (if isNull (blankLabel :> obj) then "first" else string blankLabel)|]
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg label)) then label.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg dataLengths)) then dataLengths.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg labelLengths)) then labelLengths.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <summary>Connectionist Temporal Classification Loss.
    /// 
    /// .. note:: The existing alias ``contrib_CTCLoss`` is deprecated.
    /// 
    /// The shapes of the inputs and outputs:
    /// 
    /// - **data**: `(sequence_length, batch_size, alphabet_size)`
    /// - **label**: `(batch_size, label_sequence_length)`
    /// - **out**: `(batch_size)`
    /// 
    /// The `data` tensor consists of sequences of activation vectors (without applying softmax),
    /// with i-th channel in the last dimension corresponding to i-th label
    /// for i between 0 and alphabet_size-1 (i.e always 0-indexed).
    /// Alphabet size should include one additional value reserved for blank label.
    /// When `blank_label` is ``&quot;first&quot;``, the ``0``-th channel is be reserved for
    /// activation of blank label, or otherwise if it is &quot;last&quot;, ``(alphabet_size-1)``-th channel should be
    /// reserved for blank label.
    /// 
    /// ``label`` is an index matrix of integers. When `blank_label` is ``&quot;first&quot;``,
    /// the value 0 is then reserved for blank label, and should not be passed in this matrix. Otherwise,
    /// when `blank_label` is ``&quot;last&quot;``, the value `(alphabet_size-1)` is reserved for blank label.
    /// 
    /// If a sequence of labels is shorter than *label_sequence_length*, use the special
    /// padding value at the end of the sequence to conform it to the correct
    /// length. The padding value is `0` when `blank_label` is ``&quot;first&quot;``, and `-1` otherwise.
    /// 
    /// For example, suppose the vocabulary is `[a, b, c]`, and in one batch we have three sequences
    /// &#39;ba&#39;, &#39;cbb&#39;, and &#39;abac&#39;. When `blank_label` is ``&quot;first&quot;``, we can index the labels as
    /// `{&#39;a&#39;: 1, &#39;b&#39;: 2, &#39;c&#39;: 3}`, and we reserve the 0-th channel for blank label in data tensor.
    /// The resulting `label` tensor should be padded to be::
    /// 
    ///   [[2, 1, 0, 0], [3, 2, 2, 0], [1, 2, 1, 3]]
    /// 
    /// When `blank_label` is ``&quot;last&quot;``, we can index the labels as
    /// `{&#39;a&#39;: 0, &#39;b&#39;: 1, &#39;c&#39;: 2}`, and we reserve the channel index 3 for blank label in data tensor.
    /// The resulting `label` tensor should be padded to be::
    /// 
    ///   [[1, 0, -1, -1], [2, 1, 1, -1], [0, 1, 0, 2]]
    /// 
    /// ``out`` is a list of CTC loss values, one per example in the batch.
    /// 
    /// See *Connectionist Temporal Classification: Labelling Unsegmented
    /// Sequence Data with Recurrent Neural Networks*, A. Graves *et al*. for more
    /// information on the definition and the algorithm.
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\nn\ctc_loss.cc:L100</summary>
    /// <param name="data">Input ndarray</param>
    /// <param name="label">Ground-truth labels for the loss.</param>
    /// <param name="dataLengths">Lengths of data for each of the samples. Only required when use_data_lengths is true.</param>
    /// <param name="labelLengths">Lengths of labels for each of the samples. Only required when use_label_lengths is true.</param>
    /// <param name="useDataLengths">Whether the data lenghts are decided by `data_lengths`. If false, the lengths are equal to the max sequence length.</param>
    /// <param name="useLabelLengths">Whether the label lenghts are decided by `label_lengths`, or derived from `padding_mask`. If false, the lengths are derived from the first occurrence of the value of `padding_mask`. The value of `padding_mask` is ``0`` when first CTC label is reserved for blank, and ``-1`` when last label is reserved for blank. See `blank_label`.</param>
    /// <param name="blankLabel">Set the label that is reserved for blank label.If &quot;first&quot;, 0-th label is reserved, and label values for tokens in the vocabulary are between ``1`` and ``alphabet_size-1``, and the padding mask is ``-1``. If &quot;last&quot;, last label value ``alphabet_size-1`` is reserved for blank label instead, and label values for tokens in the vocabulary are between ``0`` and ``alphabet_size-2``, and the padding mask is ``0``.</param>
    static member CTCLoss([<Optional>] ?data : Symbol, [<Optional>] ?label : Symbol, [<Optional>] ?dataLengths : Symbol, [<Optional>] ?labelLengths : Symbol, [<Optional>] ?useDataLengths : bool, [<Optional>] ?useLabelLengths : bool, [<Optional>] ?blankLabel : BlankLabel) =
        CTCLoss(?data = data, ?label = label, ?dataLengths = dataLengths, ?labelLengths = labelLengths, ?useDataLengths = useDataLengths, ?useLabelLengths = useLabelLengths, ?blankLabel = blankLabel)


    /// <summary>Apply batch normalization to input.</summary>
    /// <param name="data">Input data to batch normalization</param>
    /// <param name="gamma">gamma array</param>
    /// <param name="beta">beta array</param>
    /// <param name="movingMean">running mean of input</param>
    /// <param name="movingVar">running variance of input</param>
    /// <param name="eps">Epsilon to prevent div 0. Must be no less than CUDNN_BN_MIN_EPSILON defined in cudnn.h when using cudnn (usually 1e-5)</param>
    /// <param name="momentum">Momentum for moving average</param>
    /// <param name="fixGamma">Fix gamma while training</param>
    /// <param name="useGlobalStats">Whether use global moving statistics instead of local batch-norm. This will force change batch-norm into a scale shift operator.</param>
    /// <param name="outputMeanVar">Output the mean and inverse std </param>
    /// <param name="axis">Specify which shape axis the channel is specified</param>
    /// <param name="cudnnOff">Do not select CUDNN operator, if available</param>
    /// <param name="minCalibRange">The minimum scalar value in the form of float32 obtained through calibration. If present, it will be used to by quantized batch norm op to calculate primitive scale.Note: this calib_range is to calib bn output.</param>
    /// <param name="maxCalibRange">The maximum scalar value in the form of float32 obtained through calibration. If present, it will be used to by quantized batch norm op to calculate primitive scale.Note: this calib_range is to calib bn output.</param>
    static member CuDNNBatchNorm(data : NDArray, 
                                 gamma : NDArray, 
                                 beta : NDArray, 
                                 movingMean : NDArray, 
                                 movingVar : NDArray, 
                                 [<Optional>] ?eps : double, 
                                 [<Optional>] ?momentum : float, 
                                 [<Optional>] ?fixGamma : bool, 
                                 [<Optional>] ?useGlobalStats : bool, 
                                 [<Optional>] ?outputMeanVar : bool, 
                                 [<Optional>] ?axis : int, 
                                 [<Optional>] ?cudnnOff : bool, 
                                 [<Optional>] ?minCalibRange : float, 
                                 [<Optional>] ?maxCalibRange : float) =
        let creator = AtomicSymbolCreator.FromName "CuDNNBatchNorm"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg gamma)) then gamma.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg beta)) then beta.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg movingMean)) then movingMean.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg movingVar)) then movingVar.UnsafeHandle|]
                                                 [|"eps"; "momentum"; "fix_gamma"; "use_global_stats"; "output_mean_var"; "axis"; "cudnn_off"; "min_calib_range"; "max_calib_range"|]
                                                 [|(match eps with None -> "0.00100000004749745" | Some eps -> string eps); (match momentum with None -> "0.899999976" | Some momentum -> string momentum); (match fixGamma with None -> "true" | Some fixGamma -> string fixGamma); (match useGlobalStats with None -> "false" | Some useGlobalStats -> string useGlobalStats); (match outputMeanVar with None -> "false" | Some outputMeanVar -> string outputMeanVar); (match axis with None -> "1" | Some axis -> string axis); (match cudnnOff with None -> "false" | Some cudnnOff -> string cudnnOff); (match minCalibRange with None -> "None" | Some minCalibRange -> string minCalibRange); (match maxCalibRange with None -> "None" | Some maxCalibRange -> string maxCalibRange)|]
        (new NDArray(outputs.[0]))
    /// <summary>Apply batch normalization to input.</summary>
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="data">Input data to batch normalization</param>
    /// <param name="gamma">gamma array</param>
    /// <param name="beta">beta array</param>
    /// <param name="movingMean">running mean of input</param>
    /// <param name="movingVar">running variance of input</param>
    /// <param name="eps">Epsilon to prevent div 0. Must be no less than CUDNN_BN_MIN_EPSILON defined in cudnn.h when using cudnn (usually 1e-5)</param>
    /// <param name="momentum">Momentum for moving average</param>
    /// <param name="fixGamma">Fix gamma while training</param>
    /// <param name="useGlobalStats">Whether use global moving statistics instead of local batch-norm. This will force change batch-norm into a scale shift operator.</param>
    /// <param name="outputMeanVar">Output the mean and inverse std </param>
    /// <param name="axis">Specify which shape axis the channel is specified</param>
    /// <param name="cudnnOff">Do not select CUDNN operator, if available</param>
    /// <param name="minCalibRange">The minimum scalar value in the form of float32 obtained through calibration. If present, it will be used to by quantized batch norm op to calculate primitive scale.Note: this calib_range is to calib bn output.</param>
    /// <param name="maxCalibRange">The maximum scalar value in the form of float32 obtained through calibration. If present, it will be used to by quantized batch norm op to calculate primitive scale.Note: this calib_range is to calib bn output.</param>
    static member CuDNNBatchNorm(outputArray : NDArray seq, 
                                 data : NDArray, 
                                 gamma : NDArray, 
                                 beta : NDArray, 
                                 movingMean : NDArray, 
                                 movingVar : NDArray, 
                                 [<Optional>] ?eps : double, 
                                 [<Optional>] ?momentum : float, 
                                 [<Optional>] ?fixGamma : bool, 
                                 [<Optional>] ?useGlobalStats : bool, 
                                 [<Optional>] ?outputMeanVar : bool, 
                                 [<Optional>] ?axis : int, 
                                 [<Optional>] ?cudnnOff : bool, 
                                 [<Optional>] ?minCalibRange : float, 
                                 [<Optional>] ?maxCalibRange : float) =
        let creator = AtomicSymbolCreator.FromName "CuDNNBatchNorm"
        let names = [|"eps"; "momentum"; "fix_gamma"; "use_global_stats"; "output_mean_var"; "axis"; "cudnn_off"; "min_calib_range"; "max_calib_range"|]
        let vals = [|(match eps with None -> "0.00100000004749745" | Some eps -> string eps); (match momentum with None -> "0.899999976" | Some momentum -> string momentum); (match fixGamma with None -> "true" | Some fixGamma -> string fixGamma); (match useGlobalStats with None -> "false" | Some useGlobalStats -> string useGlobalStats); (match outputMeanVar with None -> "false" | Some outputMeanVar -> string outputMeanVar); (match axis with None -> "1" | Some axis -> string axis); (match cudnnOff with None -> "false" | Some cudnnOff -> string cudnnOff); (match minCalibRange with None -> "None" | Some minCalibRange -> string minCalibRange); (match maxCalibRange with None -> "None" | Some maxCalibRange -> string maxCalibRange)|]
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg gamma)) then gamma.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg beta)) then beta.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg movingMean)) then movingMean.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg movingVar)) then movingVar.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <summary>Apply batch normalization to input.</summary>
    /// <param name="data">Input data to batch normalization</param>
    /// <param name="gamma">gamma array</param>
    /// <param name="beta">beta array</param>
    /// <param name="movingMean">running mean of input</param>
    /// <param name="movingVar">running variance of input</param>
    /// <param name="eps">Epsilon to prevent div 0. Must be no less than CUDNN_BN_MIN_EPSILON defined in cudnn.h when using cudnn (usually 1e-5)</param>
    /// <param name="momentum">Momentum for moving average</param>
    /// <param name="fixGamma">Fix gamma while training</param>
    /// <param name="useGlobalStats">Whether use global moving statistics instead of local batch-norm. This will force change batch-norm into a scale shift operator.</param>
    /// <param name="outputMeanVar">Output the mean and inverse std </param>
    /// <param name="axis">Specify which shape axis the channel is specified</param>
    /// <param name="cudnnOff">Do not select CUDNN operator, if available</param>
    /// <param name="minCalibRange">The minimum scalar value in the form of float32 obtained through calibration. If present, it will be used to by quantized batch norm op to calculate primitive scale.Note: this calib_range is to calib bn output.</param>
    /// <param name="maxCalibRange">The maximum scalar value in the form of float32 obtained through calibration. If present, it will be used to by quantized batch norm op to calculate primitive scale.Note: this calib_range is to calib bn output.</param>
    static member CuDNNBatchNorm([<Optional>] ?data : Symbol, [<Optional>] ?gamma : Symbol, [<Optional>] ?beta : Symbol, [<Optional>] ?movingMean : Symbol, [<Optional>] ?movingVar : Symbol, [<Optional>] ?eps : double, [<Optional>] ?momentum : float, [<Optional>] ?fixGamma : bool, [<Optional>] ?useGlobalStats : bool, [<Optional>] ?outputMeanVar : bool, [<Optional>] ?axis : int, [<Optional>] ?cudnnOff : bool, [<Optional>] ?minCalibRange : float, [<Optional>] ?maxCalibRange : float) =
        CuDNNBatchNorm(?data = data, ?gamma = gamma, ?beta = beta, ?movingMean = movingMean, ?movingVar = movingVar, ?eps = eps, ?momentum = momentum, ?fixGamma = fixGamma, ?useGlobalStats = useGlobalStats, ?outputMeanVar = outputMeanVar, ?axis = axis, ?cudnnOff = cudnnOff, ?minCalibRange = minCalibRange, ?maxCalibRange = maxCalibRange)


    /// <summary>Computes 1D or 2D transposed convolution (aka fractionally strided convolution) of the input tensor. This operation can be seen as the gradient of Convolution operation with respect to its input. Convolution usually reduces the size of the input. Transposed convolution works the other way, going from a smaller input to a larger output while preserving the connectivity pattern.</summary>
    /// <param name="data">Input tensor to the deconvolution operation.</param>
    /// <param name="weight">Weights representing the kernel.</param>
    /// <param name="bias">Bias added to the result after the deconvolution operation.</param>
    /// <param name="kernel">Deconvolution kernel size: (w,), (h, w) or (d, h, w). This is same as the kernel size used for the corresponding convolution</param>
    /// <param name="numFilter">Number of output filters.</param>
    /// <param name="stride">The stride used for the corresponding convolution: (w,), (h, w) or (d, h, w). Defaults to 1 for each dimension.</param>
    /// <param name="dilate">Dilation factor for each dimension of the input: (w,), (h, w) or (d, h, w). Defaults to 1 for each dimension.</param>
    /// <param name="pad">The amount of implicit zero padding added during convolution for each dimension of the input: (w,), (h, w) or (d, h, w). ``(kernel-1)/2`` is usually a good choice. If `target_shape` is set, `pad` will be ignored and a padding that will generate the target shape will be used. Defaults to no padding.</param>
    /// <param name="adj">Adjustment for output shape: (w,), (h, w) or (d, h, w). If `target_shape` is set, `adj` will be ignored and computed accordingly.</param>
    /// <param name="targetShape">Shape of the output tensor: (w,), (h, w) or (d, h, w).</param>
    /// <param name="numGroup">Number of groups partition.</param>
    /// <param name="workspace">Maximum temporary workspace allowed (MB) in deconvolution.This parameter has two usages. When CUDNN is not used, it determines the effective batch size of the deconvolution kernel. When CUDNN is used, it controls the maximum temporary storage used for tuning the best CUDNN kernel when `limited_workspace` strategy is used.</param>
    /// <param name="noBias">Whether to disable bias parameter.</param>
    /// <param name="cudnnTune">Whether to pick convolution algorithm by running performance test.</param>
    /// <param name="cudnnOff">Turn off cudnn for this layer.</param>
    /// <param name="layout">Set layout for input, output and weight. Empty for default layout, NCW for 1d, NCHW for 2d and NCDHW for 3d.NHWC and NDHWC are only supported on GPU.</param>
    static member Deconvolution(data : NDArray, 
                                weight : NDArray, 
                                bias : NDArray, 
                                kernel : int seq, 
                                numFilter : int, 
                                [<Optional>] stride : int seq, 
                                [<Optional>] dilate : int seq, 
                                [<Optional>] pad : int seq, 
                                [<Optional>] adj : int seq, 
                                [<Optional>] targetShape : int seq, 
                                [<Optional; DefaultParameterValue(1)>] numGroup : int, 
                                [<Optional; DefaultParameterValue(512L)>] workspace : int64, 
                                [<Optional; DefaultParameterValue(true)>] noBias : bool, 
                                [<Optional>] cudnnTune : CudnnTune, 
                                [<Optional; DefaultParameterValue(false)>] cudnnOff : bool, 
                                [<Optional>] layout : DeconvolutionLayout) =
        let creator = AtomicSymbolCreator.FromName "Deconvolution"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg weight)) then weight.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg bias)) then bias.UnsafeHandle|]
                                                 [|"kernel"; "num_filter"; "stride"; "dilate"; "pad"; "adj"; "target_shape"; "num_group"; "workspace"; "no_bias"; "cudnn_tune"; "cudnn_off"; "layout"|]
                                                 [|(kernel |> Seq.map string |> String.concat ", " |> sprintf "[%s]"); string numFilter; (if isNull (stride :> obj) then "[]" else (stride |> Seq.map string |> String.concat ", " |> sprintf "[%s]")); (if isNull (dilate :> obj) then "[]" else (dilate |> Seq.map string |> String.concat ", " |> sprintf "[%s]")); (if isNull (pad :> obj) then "[]" else (pad |> Seq.map string |> String.concat ", " |> sprintf "[%s]")); (if isNull (adj :> obj) then "[]" else (adj |> Seq.map string |> String.concat ", " |> sprintf "[%s]")); (if isNull (targetShape :> obj) then "[]" else (targetShape |> Seq.map string |> String.concat ", " |> sprintf "[%s]")); string numGroup; string workspace; string noBias; (if isNull (cudnnTune :> obj) then "None" else string cudnnTune); string cudnnOff; (if isNull (layout :> obj) then "None" else string layout)|]
        (new NDArray(outputs.[0]))
    /// <summary>Computes 1D or 2D transposed convolution (aka fractionally strided convolution) of the input tensor. This operation can be seen as the gradient of Convolution operation with respect to its input. Convolution usually reduces the size of the input. Transposed convolution works the other way, going from a smaller input to a larger output while preserving the connectivity pattern.</summary>
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="data">Input tensor to the deconvolution operation.</param>
    /// <param name="weight">Weights representing the kernel.</param>
    /// <param name="bias">Bias added to the result after the deconvolution operation.</param>
    /// <param name="kernel">Deconvolution kernel size: (w,), (h, w) or (d, h, w). This is same as the kernel size used for the corresponding convolution</param>
    /// <param name="numFilter">Number of output filters.</param>
    /// <param name="stride">The stride used for the corresponding convolution: (w,), (h, w) or (d, h, w). Defaults to 1 for each dimension.</param>
    /// <param name="dilate">Dilation factor for each dimension of the input: (w,), (h, w) or (d, h, w). Defaults to 1 for each dimension.</param>
    /// <param name="pad">The amount of implicit zero padding added during convolution for each dimension of the input: (w,), (h, w) or (d, h, w). ``(kernel-1)/2`` is usually a good choice. If `target_shape` is set, `pad` will be ignored and a padding that will generate the target shape will be used. Defaults to no padding.</param>
    /// <param name="adj">Adjustment for output shape: (w,), (h, w) or (d, h, w). If `target_shape` is set, `adj` will be ignored and computed accordingly.</param>
    /// <param name="targetShape">Shape of the output tensor: (w,), (h, w) or (d, h, w).</param>
    /// <param name="numGroup">Number of groups partition.</param>
    /// <param name="workspace">Maximum temporary workspace allowed (MB) in deconvolution.This parameter has two usages. When CUDNN is not used, it determines the effective batch size of the deconvolution kernel. When CUDNN is used, it controls the maximum temporary storage used for tuning the best CUDNN kernel when `limited_workspace` strategy is used.</param>
    /// <param name="noBias">Whether to disable bias parameter.</param>
    /// <param name="cudnnTune">Whether to pick convolution algorithm by running performance test.</param>
    /// <param name="cudnnOff">Turn off cudnn for this layer.</param>
    /// <param name="layout">Set layout for input, output and weight. Empty for default layout, NCW for 1d, NCHW for 2d and NCDHW for 3d.NHWC and NDHWC are only supported on GPU.</param>
    static member Deconvolution(outputArray : NDArray seq, 
                                data : NDArray, 
                                weight : NDArray, 
                                bias : NDArray, 
                                kernel : int seq, 
                                numFilter : int, 
                                [<Optional>] stride : int seq, 
                                [<Optional>] dilate : int seq, 
                                [<Optional>] pad : int seq, 
                                [<Optional>] adj : int seq, 
                                [<Optional>] targetShape : int seq, 
                                [<Optional; DefaultParameterValue(1)>] numGroup : int, 
                                [<Optional; DefaultParameterValue(512L)>] workspace : int64, 
                                [<Optional; DefaultParameterValue(true)>] noBias : bool, 
                                [<Optional>] cudnnTune : CudnnTune, 
                                [<Optional; DefaultParameterValue(false)>] cudnnOff : bool, 
                                [<Optional>] layout : DeconvolutionLayout) =
        let creator = AtomicSymbolCreator.FromName "Deconvolution"
        let names = [|"kernel"; "num_filter"; "stride"; "dilate"; "pad"; "adj"; "target_shape"; "num_group"; "workspace"; "no_bias"; "cudnn_tune"; "cudnn_off"; "layout"|]
        let vals = [|(kernel |> Seq.map string |> String.concat ", " |> sprintf "[%s]"); string numFilter; (if isNull (stride :> obj) then "[]" else (stride |> Seq.map string |> String.concat ", " |> sprintf "[%s]")); (if isNull (dilate :> obj) then "[]" else (dilate |> Seq.map string |> String.concat ", " |> sprintf "[%s]")); (if isNull (pad :> obj) then "[]" else (pad |> Seq.map string |> String.concat ", " |> sprintf "[%s]")); (if isNull (adj :> obj) then "[]" else (adj |> Seq.map string |> String.concat ", " |> sprintf "[%s]")); (if isNull (targetShape :> obj) then "[]" else (targetShape |> Seq.map string |> String.concat ", " |> sprintf "[%s]")); string numGroup; string workspace; string noBias; (if isNull (cudnnTune :> obj) then "None" else string cudnnTune); string cudnnOff; (if isNull (layout :> obj) then "None" else string layout)|]
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg weight)) then weight.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg bias)) then bias.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <summary>Computes 1D or 2D transposed convolution (aka fractionally strided convolution) of the input tensor. This operation can be seen as the gradient of Convolution operation with respect to its input. Convolution usually reduces the size of the input. Transposed convolution works the other way, going from a smaller input to a larger output while preserving the connectivity pattern.</summary>
    /// <param name="data">Input tensor to the deconvolution operation.</param>
    /// <param name="weight">Weights representing the kernel.</param>
    /// <param name="bias">Bias added to the result after the deconvolution operation.</param>
    /// <param name="kernel">Deconvolution kernel size: (w,), (h, w) or (d, h, w). This is same as the kernel size used for the corresponding convolution</param>
    /// <param name="numFilter">Number of output filters.</param>
    /// <param name="stride">The stride used for the corresponding convolution: (w,), (h, w) or (d, h, w). Defaults to 1 for each dimension.</param>
    /// <param name="dilate">Dilation factor for each dimension of the input: (w,), (h, w) or (d, h, w). Defaults to 1 for each dimension.</param>
    /// <param name="pad">The amount of implicit zero padding added during convolution for each dimension of the input: (w,), (h, w) or (d, h, w). ``(kernel-1)/2`` is usually a good choice. If `target_shape` is set, `pad` will be ignored and a padding that will generate the target shape will be used. Defaults to no padding.</param>
    /// <param name="adj">Adjustment for output shape: (w,), (h, w) or (d, h, w). If `target_shape` is set, `adj` will be ignored and computed accordingly.</param>
    /// <param name="targetShape">Shape of the output tensor: (w,), (h, w) or (d, h, w).</param>
    /// <param name="numGroup">Number of groups partition.</param>
    /// <param name="workspace">Maximum temporary workspace allowed (MB) in deconvolution.This parameter has two usages. When CUDNN is not used, it determines the effective batch size of the deconvolution kernel. When CUDNN is used, it controls the maximum temporary storage used for tuning the best CUDNN kernel when `limited_workspace` strategy is used.</param>
    /// <param name="noBias">Whether to disable bias parameter.</param>
    /// <param name="cudnnTune">Whether to pick convolution algorithm by running performance test.</param>
    /// <param name="cudnnOff">Turn off cudnn for this layer.</param>
    /// <param name="layout">Set layout for input, output and weight. Empty for default layout, NCW for 1d, NCHW for 2d and NCDHW for 3d.NHWC and NDHWC are only supported on GPU.</param>
    static member Deconvolution(data : Symbol, weight : Symbol, bias : Symbol, kernel : int seq, numFilter : int, [<Optional>] ?stride : int seq, [<Optional>] ?dilate : int seq, [<Optional>] ?pad : int seq, [<Optional>] ?adj : int seq, [<Optional>] ?targetShape : int seq, [<Optional>] ?numGroup : int, [<Optional>] ?workspace : int64, [<Optional>] ?noBias : bool, [<Optional>] ?cudnnTune : CudnnTune, [<Optional>] ?cudnnOff : bool, [<Optional>] ?layout : DeconvolutionLayout) =
        Deconvolution(data, weight, bias, kernel, numFilter, ?stride = stride, ?dilate = dilate, ?pad = pad, ?adj = adj, ?targetShape = targetShape, ?numGroup = numGroup, ?workspace = workspace, ?noBias = noBias, ?cudnnTune = cudnnTune, ?cudnnOff = cudnnOff, ?layout = layout)
    /// <summary>Computes 1D or 2D transposed convolution (aka fractionally strided convolution) of the input tensor. This operation can be seen as the gradient of Convolution operation with respect to its input. Convolution usually reduces the size of the input. Transposed convolution works the other way, going from a smaller input to a larger output while preserving the connectivity pattern.</summary>
    /// <param name="kernel">Deconvolution kernel size: (w,), (h, w) or (d, h, w). This is same as the kernel size used for the corresponding convolution</param>
    /// <param name="numFilter">Number of output filters.</param>
    /// <param name="data">Input tensor to the deconvolution operation.</param>
    /// <param name="weight">Weights representing the kernel.</param>
    /// <param name="bias">Bias added to the result after the deconvolution operation.</param>
    /// <param name="stride">The stride used for the corresponding convolution: (w,), (h, w) or (d, h, w). Defaults to 1 for each dimension.</param>
    /// <param name="dilate">Dilation factor for each dimension of the input: (w,), (h, w) or (d, h, w). Defaults to 1 for each dimension.</param>
    /// <param name="pad">The amount of implicit zero padding added during convolution for each dimension of the input: (w,), (h, w) or (d, h, w). ``(kernel-1)/2`` is usually a good choice. If `target_shape` is set, `pad` will be ignored and a padding that will generate the target shape will be used. Defaults to no padding.</param>
    /// <param name="adj">Adjustment for output shape: (w,), (h, w) or (d, h, w). If `target_shape` is set, `adj` will be ignored and computed accordingly.</param>
    /// <param name="targetShape">Shape of the output tensor: (w,), (h, w) or (d, h, w).</param>
    /// <param name="numGroup">Number of groups partition.</param>
    /// <param name="workspace">Maximum temporary workspace allowed (MB) in deconvolution.This parameter has two usages. When CUDNN is not used, it determines the effective batch size of the deconvolution kernel. When CUDNN is used, it controls the maximum temporary storage used for tuning the best CUDNN kernel when `limited_workspace` strategy is used.</param>
    /// <param name="noBias">Whether to disable bias parameter.</param>
    /// <param name="cudnnTune">Whether to pick convolution algorithm by running performance test.</param>
    /// <param name="cudnnOff">Turn off cudnn for this layer.</param>
    /// <param name="layout">Set layout for input, output and weight. Empty for default layout, NCW for 1d, NCHW for 2d and NCDHW for 3d.NHWC and NDHWC are only supported on GPU.</param>
    static member Deconvolution(kernel : int seq, numFilter : int, [<Optional>] ?data : Symbol, [<Optional>] ?weight : Symbol, [<Optional>] ?bias : Symbol, [<Optional>] ?stride : int seq, [<Optional>] ?dilate : int seq, [<Optional>] ?pad : int seq, [<Optional>] ?adj : int seq, [<Optional>] ?targetShape : int seq, [<Optional>] ?numGroup : int, [<Optional>] ?workspace : int64, [<Optional>] ?noBias : bool, [<Optional>] ?cudnnTune : CudnnTune, [<Optional>] ?cudnnOff : bool, [<Optional>] ?layout : DeconvolutionLayout) =
        Deconvolution(kernel, numFilter, ?data = data, ?weight = weight, ?bias = bias, ?stride = stride, ?dilate = dilate, ?pad = pad, ?adj = adj, ?targetShape = targetShape, ?numGroup = numGroup, ?workspace = workspace, ?noBias = noBias, ?cudnnTune = cudnnTune, ?cudnnOff = cudnnOff, ?layout = layout)


    /// <summary>Applies dropout operation to input array.
    /// 
    /// - During training, each element of the input is set to zero with probability p.
    ///   The whole array is rescaled by :math:`1/(1-p)` to keep the expected
    ///   sum of the input unchanged.
    /// 
    /// - During testing, this operator does not change the input if mode is &#39;training&#39;.
    ///   If mode is &#39;always&#39;, the same computaion as during training will be applied.
    /// 
    /// Example::
    /// 
    ///   random.seed(998)
    ///   input_array = array([[3., 0.5,  -0.5,  2., 7.],
    ///                       [2., -0.4,   7.,  3., 0.2]])
    ///   a = symbol.Variable(&#39;a&#39;)
    ///   dropout = symbol.Dropout(a, p = 0.2)
    ///   executor = dropout.simple_bind(a = input_array.shape)
    /// 
    ///   ## If training
    ///   executor.forward(is_train = True, a = input_array)
    ///   executor.outputs
    ///   [[ 3.75   0.625 -0.     2.5    8.75 ]
    ///    [ 2.5   -0.5    8.75   3.75   0.   ]]
    /// 
    ///   ## If testing
    ///   executor.forward(is_train = False, a = input_array)
    ///   executor.outputs
    ///   [[ 3.     0.5   -0.5    2.     7.   ]
    ///    [ 2.    -0.4    7.     3.     0.2  ]]
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\nn\dropout.cc:L96</summary>
    /// <param name="data">Input array to which dropout will be applied.</param>
    /// <param name="p">Fraction of the input that gets dropped out during training time.</param>
    /// <param name="mode">Whether to only turn on dropout during training or to also turn on for inference.</param>
    /// <param name="axes">Axes for variational dropout kernel.</param>
    /// <param name="cudnnOff">Whether to turn off cudnn in dropout operator. This option is ignored if axes is specified.</param>
    static member Dropout(data : NDArray, 
                          [<Optional>] ?p : float, 
                          [<Optional>] ?mode : DropoutMode, 
                          [<Optional>] ?axes : int seq, 
                          [<Optional>] ?cudnnOff : bool) =
        let creator = AtomicSymbolCreator.FromName "Dropout"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle|]
                                                 [|"p"; "mode"; "axes"; "cudnn_off"|]
                                                 [|(match p with None -> "0.5" | Some p -> string p); (match mode with None -> "training" | Some mode -> string mode); (match axes with None -> "[]" | Some axes -> (axes |> Seq.map string |> String.concat ", " |> sprintf "[%s]")); (match cudnnOff with None -> "None" | Some cudnnOff -> string cudnnOff)|]
        (new NDArray(outputs.[0]))
    /// <summary>Applies dropout operation to input array.
    /// 
    /// - During training, each element of the input is set to zero with probability p.
    ///   The whole array is rescaled by :math:`1/(1-p)` to keep the expected
    ///   sum of the input unchanged.
    /// 
    /// - During testing, this operator does not change the input if mode is &#39;training&#39;.
    ///   If mode is &#39;always&#39;, the same computaion as during training will be applied.
    /// 
    /// Example::
    /// 
    ///   random.seed(998)
    ///   input_array = array([[3., 0.5,  -0.5,  2., 7.],
    ///                       [2., -0.4,   7.,  3., 0.2]])
    ///   a = symbol.Variable(&#39;a&#39;)
    ///   dropout = symbol.Dropout(a, p = 0.2)
    ///   executor = dropout.simple_bind(a = input_array.shape)
    /// 
    ///   ## If training
    ///   executor.forward(is_train = True, a = input_array)
    ///   executor.outputs
    ///   [[ 3.75   0.625 -0.     2.5    8.75 ]
    ///    [ 2.5   -0.5    8.75   3.75   0.   ]]
    /// 
    ///   ## If testing
    ///   executor.forward(is_train = False, a = input_array)
    ///   executor.outputs
    ///   [[ 3.     0.5   -0.5    2.     7.   ]
    ///    [ 2.    -0.4    7.     3.     0.2  ]]
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\nn\dropout.cc:L96</summary>
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="data">Input array to which dropout will be applied.</param>
    /// <param name="p">Fraction of the input that gets dropped out during training time.</param>
    /// <param name="mode">Whether to only turn on dropout during training or to also turn on for inference.</param>
    /// <param name="axes">Axes for variational dropout kernel.</param>
    /// <param name="cudnnOff">Whether to turn off cudnn in dropout operator. This option is ignored if axes is specified.</param>
    static member Dropout(outputArray : NDArray seq, 
                          data : NDArray, 
                          [<Optional>] ?p : float, 
                          [<Optional>] ?mode : DropoutMode, 
                          [<Optional>] ?axes : int seq, 
                          [<Optional>] ?cudnnOff : bool) =
        let creator = AtomicSymbolCreator.FromName "Dropout"
        let names = [|"p"; "mode"; "axes"; "cudnn_off"|]
        let vals = [|(match p with None -> "0.5" | Some p -> string p); (match mode with None -> "training" | Some mode -> string mode); (match axes with None -> "[]" | Some axes -> (axes |> Seq.map string |> String.concat ", " |> sprintf "[%s]")); (match cudnnOff with None -> "None" | Some cudnnOff -> string cudnnOff)|]
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <summary>Applies dropout operation to input array.
    /// 
    /// - During training, each element of the input is set to zero with probability p.
    ///   The whole array is rescaled by :math:`1/(1-p)` to keep the expected
    ///   sum of the input unchanged.
    /// 
    /// - During testing, this operator does not change the input if mode is &#39;training&#39;.
    ///   If mode is &#39;always&#39;, the same computaion as during training will be applied.
    /// 
    /// Example::
    /// 
    ///   random.seed(998)
    ///   input_array = array([[3., 0.5,  -0.5,  2., 7.],
    ///                       [2., -0.4,   7.,  3., 0.2]])
    ///   a = symbol.Variable(&#39;a&#39;)
    ///   dropout = symbol.Dropout(a, p = 0.2)
    ///   executor = dropout.simple_bind(a = input_array.shape)
    /// 
    ///   ## If training
    ///   executor.forward(is_train = True, a = input_array)
    ///   executor.outputs
    ///   [[ 3.75   0.625 -0.     2.5    8.75 ]
    ///    [ 2.5   -0.5    8.75   3.75   0.   ]]
    /// 
    ///   ## If testing
    ///   executor.forward(is_train = False, a = input_array)
    ///   executor.outputs
    ///   [[ 3.     0.5   -0.5    2.     7.   ]
    ///    [ 2.    -0.4    7.     3.     0.2  ]]
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\nn\dropout.cc:L96</summary>
    /// <param name="data">Input array to which dropout will be applied.</param>
    /// <param name="p">Fraction of the input that gets dropped out during training time.</param>
    /// <param name="mode">Whether to only turn on dropout during training or to also turn on for inference.</param>
    /// <param name="axes">Axes for variational dropout kernel.</param>
    /// <param name="cudnnOff">Whether to turn off cudnn in dropout operator. This option is ignored if axes is specified.</param>
    static member Dropout([<Optional>] ?data : Symbol, [<Optional>] ?p : float, [<Optional>] ?mode : DropoutMode, [<Optional>] ?axes : int seq, [<Optional>] ?cudnnOff : bool) =
        Dropout(?data = data, ?p = p, ?mode = mode, ?axes = axes, ?cudnnOff = cudnnOff)


    /// <summary>Applies a linear transformation: :math:`Y = XW^T + b`.
    /// 
    /// If ``flatten`` is set to be true, then the shapes are:
    /// 
    /// - **data**: `(batch_size, x1, x2, ..., xn)`
    /// - **weight**: `(num_hidden, x1 * x2 * ... * xn)`
    /// - **bias**: `(num_hidden,)`
    /// - **out**: `(batch_size, num_hidden)`
    /// 
    /// If ``flatten`` is set to be false, then the shapes are:
    /// 
    /// - **data**: `(x1, x2, ..., xn, input_dim)`
    /// - **weight**: `(num_hidden, input_dim)`
    /// - **bias**: `(num_hidden,)`
    /// - **out**: `(x1, x2, ..., xn, num_hidden)`
    /// 
    /// The learnable parameters include both ``weight`` and ``bias``.
    /// 
    /// If ``no_bias`` is set to be true, then the ``bias`` term is ignored.
    /// 
    /// .. Note::
    /// 
    ///     The sparse support for FullyConnected is limited to forward evaluation with `row_sparse`
    ///     weight and bias, where the length of `weight.indices` and `bias.indices` must be equal
    ///     to `num_hidden`. This could be useful for model inference with `row_sparse` weights
    ///     trained with importance sampling or noise contrastive estimation.
    /// 
    ///     To compute linear transformation with &#39;csr&#39; sparse data, sparse.dot is recommended instead
    ///     of sparse.FullyConnected.
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\nn\fully_connected.cc:L291</summary>
    /// <param name="data">Input data.</param>
    /// <param name="weight">Weight matrix.</param>
    /// <param name="bias">Bias parameter.</param>
    /// <param name="numHidden">Number of hidden nodes of the output.</param>
    /// <param name="noBias">Whether to disable bias parameter.</param>
    /// <param name="flatten">Whether to collapse all but the first axis of the input data tensor.</param>
    static member FullyConnected(data : NDArray, 
                                 weight : NDArray, 
                                 bias : NDArray, 
                                 numHidden : int, 
                                 [<Optional; DefaultParameterValue(false)>] noBias : bool, 
                                 [<Optional; DefaultParameterValue(true)>] flatten : bool) =
        let creator = AtomicSymbolCreator.FromName "FullyConnected"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg weight)) then weight.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg bias)) then bias.UnsafeHandle|]
                                                 [|"num_hidden"; "no_bias"; "flatten"|]
                                                 [|string numHidden; string noBias; string flatten|]
        (new NDArray(outputs.[0]))
    /// <summary>Applies a linear transformation: :math:`Y = XW^T + b`.
    /// 
    /// If ``flatten`` is set to be true, then the shapes are:
    /// 
    /// - **data**: `(batch_size, x1, x2, ..., xn)`
    /// - **weight**: `(num_hidden, x1 * x2 * ... * xn)`
    /// - **bias**: `(num_hidden,)`
    /// - **out**: `(batch_size, num_hidden)`
    /// 
    /// If ``flatten`` is set to be false, then the shapes are:
    /// 
    /// - **data**: `(x1, x2, ..., xn, input_dim)`
    /// - **weight**: `(num_hidden, input_dim)`
    /// - **bias**: `(num_hidden,)`
    /// - **out**: `(x1, x2, ..., xn, num_hidden)`
    /// 
    /// The learnable parameters include both ``weight`` and ``bias``.
    /// 
    /// If ``no_bias`` is set to be true, then the ``bias`` term is ignored.
    /// 
    /// .. Note::
    /// 
    ///     The sparse support for FullyConnected is limited to forward evaluation with `row_sparse`
    ///     weight and bias, where the length of `weight.indices` and `bias.indices` must be equal
    ///     to `num_hidden`. This could be useful for model inference with `row_sparse` weights
    ///     trained with importance sampling or noise contrastive estimation.
    /// 
    ///     To compute linear transformation with &#39;csr&#39; sparse data, sparse.dot is recommended instead
    ///     of sparse.FullyConnected.
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\nn\fully_connected.cc:L291</summary>
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="data">Input data.</param>
    /// <param name="weight">Weight matrix.</param>
    /// <param name="bias">Bias parameter.</param>
    /// <param name="numHidden">Number of hidden nodes of the output.</param>
    /// <param name="noBias">Whether to disable bias parameter.</param>
    /// <param name="flatten">Whether to collapse all but the first axis of the input data tensor.</param>
    static member FullyConnected(outputArray : NDArray seq, 
                                 data : NDArray, 
                                 weight : NDArray, 
                                 bias : NDArray, 
                                 numHidden : int, 
                                 [<Optional; DefaultParameterValue(false)>] noBias : bool, 
                                 [<Optional; DefaultParameterValue(true)>] flatten : bool) =
        let creator = AtomicSymbolCreator.FromName "FullyConnected"
        let names = [|"num_hidden"; "no_bias"; "flatten"|]
        let vals = [|string numHidden; string noBias; string flatten|]
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg weight)) then weight.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg bias)) then bias.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <summary>Applies a linear transformation: :math:`Y = XW^T + b`.
    /// 
    /// If ``flatten`` is set to be true, then the shapes are:
    /// 
    /// - **data**: `(batch_size, x1, x2, ..., xn)`
    /// - **weight**: `(num_hidden, x1 * x2 * ... * xn)`
    /// - **bias**: `(num_hidden,)`
    /// - **out**: `(batch_size, num_hidden)`
    /// 
    /// If ``flatten`` is set to be false, then the shapes are:
    /// 
    /// - **data**: `(x1, x2, ..., xn, input_dim)`
    /// - **weight**: `(num_hidden, input_dim)`
    /// - **bias**: `(num_hidden,)`
    /// - **out**: `(x1, x2, ..., xn, num_hidden)`
    /// 
    /// The learnable parameters include both ``weight`` and ``bias``.
    /// 
    /// If ``no_bias`` is set to be true, then the ``bias`` term is ignored.
    /// 
    /// .. Note::
    /// 
    ///     The sparse support for FullyConnected is limited to forward evaluation with `row_sparse`
    ///     weight and bias, where the length of `weight.indices` and `bias.indices` must be equal
    ///     to `num_hidden`. This could be useful for model inference with `row_sparse` weights
    ///     trained with importance sampling or noise contrastive estimation.
    /// 
    ///     To compute linear transformation with &#39;csr&#39; sparse data, sparse.dot is recommended instead
    ///     of sparse.FullyConnected.
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\nn\fully_connected.cc:L291</summary>
    /// <param name="data">Input data.</param>
    /// <param name="weight">Weight matrix.</param>
    /// <param name="bias">Bias parameter.</param>
    /// <param name="numHidden">Number of hidden nodes of the output.</param>
    /// <param name="noBias">Whether to disable bias parameter.</param>
    /// <param name="flatten">Whether to collapse all but the first axis of the input data tensor.</param>
    static member FullyConnected(data : Symbol, weight : Symbol, bias : Symbol, numHidden : int, [<Optional>] ?noBias : bool, [<Optional>] ?flatten : bool) =
        FullyConnected(data, weight, bias, numHidden, ?noBias = noBias, ?flatten = flatten)
    /// <summary>Applies a linear transformation: :math:`Y = XW^T + b`.
    /// 
    /// If ``flatten`` is set to be true, then the shapes are:
    /// 
    /// - **data**: `(batch_size, x1, x2, ..., xn)`
    /// - **weight**: `(num_hidden, x1 * x2 * ... * xn)`
    /// - **bias**: `(num_hidden,)`
    /// - **out**: `(batch_size, num_hidden)`
    /// 
    /// If ``flatten`` is set to be false, then the shapes are:
    /// 
    /// - **data**: `(x1, x2, ..., xn, input_dim)`
    /// - **weight**: `(num_hidden, input_dim)`
    /// - **bias**: `(num_hidden,)`
    /// - **out**: `(x1, x2, ..., xn, num_hidden)`
    /// 
    /// The learnable parameters include both ``weight`` and ``bias``.
    /// 
    /// If ``no_bias`` is set to be true, then the ``bias`` term is ignored.
    /// 
    /// .. Note::
    /// 
    ///     The sparse support for FullyConnected is limited to forward evaluation with `row_sparse`
    ///     weight and bias, where the length of `weight.indices` and `bias.indices` must be equal
    ///     to `num_hidden`. This could be useful for model inference with `row_sparse` weights
    ///     trained with importance sampling or noise contrastive estimation.
    /// 
    ///     To compute linear transformation with &#39;csr&#39; sparse data, sparse.dot is recommended instead
    ///     of sparse.FullyConnected.
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\nn\fully_connected.cc:L291</summary>
    /// <param name="numHidden">Number of hidden nodes of the output.</param>
    /// <param name="data">Input data.</param>
    /// <param name="weight">Weight matrix.</param>
    /// <param name="bias">Bias parameter.</param>
    /// <param name="noBias">Whether to disable bias parameter.</param>
    /// <param name="flatten">Whether to collapse all but the first axis of the input data tensor.</param>
    static member FullyConnected(numHidden : int, [<Optional>] ?data : Symbol, [<Optional>] ?weight : Symbol, [<Optional>] ?bias : Symbol, [<Optional>] ?noBias : bool, [<Optional>] ?flatten : bool) =
        FullyConnected(numHidden, ?data = data, ?weight = weight, ?bias = bias, ?noBias = noBias, ?flatten = flatten)



    /// <summary>Group normalization.
    /// 
    /// The input channels are separated into ``num_groups`` groups, each containing ``num_channels / num_groups`` channels.
    /// The mean and standard-deviation are calculated separately over the each group.
    /// 
    /// .. math::
    /// 
    ///   data = data.reshape((N, num_groups, C // num_groups, ...))
    ///   out = \frac{data - mean(data, axis)}{\sqrt{var(data, axis) + \epsilon}} * gamma + beta
    /// 
    /// Both ``gamma`` and ``beta`` are learnable parameters.
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\nn\group_norm.cc:L77</summary>
    /// <param name="data">Input data</param>
    /// <param name="gamma">gamma array</param>
    /// <param name="beta">beta array</param>
    /// <param name="numGroups">Total number of groups.</param>
    /// <param name="eps">An `epsilon` parameter to prevent division by 0.</param>
    /// <param name="outputMeanVar">Output the mean and std calculated along the given axis.</param>
    static member GroupNorm(data : NDArray, 
                            gamma : NDArray, 
                            beta : NDArray, 
                            [<Optional; DefaultParameterValue(1)>] numGroups : int, 
                            [<Optional; DefaultParameterValue(9.99999975E-06)>] eps : float, 
                            [<Optional; DefaultParameterValue(false)>] outputMeanVar : bool) =
        let creator = AtomicSymbolCreator.FromName "GroupNorm"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg gamma)) then gamma.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg beta)) then beta.UnsafeHandle|]
                                                 [|"num_groups"; "eps"; "output_mean_var"|]
                                                 [|string numGroups; string eps; string outputMeanVar|]
        outputs |> Array.map (fun h -> new NDArray(h))
    /// <summary>Group normalization.
    /// 
    /// The input channels are separated into ``num_groups`` groups, each containing ``num_channels / num_groups`` channels.
    /// The mean and standard-deviation are calculated separately over the each group.
    /// 
    /// .. math::
    /// 
    ///   data = data.reshape((N, num_groups, C // num_groups, ...))
    ///   out = \frac{data - mean(data, axis)}{\sqrt{var(data, axis) + \epsilon}} * gamma + beta
    /// 
    /// Both ``gamma`` and ``beta`` are learnable parameters.
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\nn\group_norm.cc:L77</summary>
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="data">Input data</param>
    /// <param name="gamma">gamma array</param>
    /// <param name="beta">beta array</param>
    /// <param name="numGroups">Total number of groups.</param>
    /// <param name="eps">An `epsilon` parameter to prevent division by 0.</param>
    /// <param name="outputMeanVar">Output the mean and std calculated along the given axis.</param>
    static member GroupNorm(outputArray : NDArray seq, 
                            data : NDArray, 
                            gamma : NDArray, 
                            beta : NDArray, 
                            [<Optional; DefaultParameterValue(1)>] numGroups : int, 
                            [<Optional; DefaultParameterValue(9.99999975E-06)>] eps : float, 
                            [<Optional; DefaultParameterValue(false)>] outputMeanVar : bool) =
        let creator = AtomicSymbolCreator.FromName "GroupNorm"
        let names = [|"num_groups"; "eps"; "output_mean_var"|]
        let vals = [|string numGroups; string eps; string outputMeanVar|]
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg gamma)) then gamma.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg beta)) then beta.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <summary>Group normalization.
    /// 
    /// The input channels are separated into ``num_groups`` groups, each containing ``num_channels / num_groups`` channels.
    /// The mean and standard-deviation are calculated separately over the each group.
    /// 
    /// .. math::
    /// 
    ///   data = data.reshape((N, num_groups, C // num_groups, ...))
    ///   out = \frac{data - mean(data, axis)}{\sqrt{var(data, axis) + \epsilon}} * gamma + beta
    /// 
    /// Both ``gamma`` and ``beta`` are learnable parameters.
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\nn\group_norm.cc:L77</summary>
    /// <param name="data">Input data</param>
    /// <param name="gamma">gamma array</param>
    /// <param name="beta">beta array</param>
    /// <param name="numGroups">Total number of groups.</param>
    /// <param name="eps">An `epsilon` parameter to prevent division by 0.</param>
    /// <param name="outputMeanVar">Output the mean and std calculated along the given axis.</param>
    static member GroupNorm([<Optional>] ?data : Symbol, [<Optional>] ?gamma : Symbol, [<Optional>] ?beta : Symbol, [<Optional>] ?numGroups : int, [<Optional>] ?eps : float, [<Optional>] ?outputMeanVar : bool) =
        GroupNorm(?data = data, ?gamma = gamma, ?beta = beta, ?numGroups = numGroups, ?eps = eps, ?outputMeanVar = outputMeanVar)


    /// <summary>Layer normalization.
    /// 
    /// Normalizes the channels of the input tensor by mean and variance, and applies a scale ``gamma`` as
    /// well as offset ``beta``.
    /// 
    /// Assume the input has more than one dimension and we normalize along axis 1.
    /// We first compute the mean and variance along this axis and then 
    /// compute the normalized output, which has the same shape as input, as following:
    /// 
    /// .. math::
    /// 
    ///   out = \frac{data - mean(data, axis)}{\sqrt{var(data, axis) + \epsilon}} * gamma + beta
    /// 
    /// Both ``gamma`` and ``beta`` are learnable parameters.
    /// 
    /// Unlike BatchNorm and InstanceNorm,  the *mean* and *var* are computed along the channel dimension.
    /// 
    /// Assume the input has size *k* on axis 1, then both ``gamma`` and ``beta``
    /// have shape *(k,)*. If ``output_mean_var`` is set to be true, then outputs both ``data_mean`` and
    /// ``data_std``. Note that no gradient will be passed through these two outputs.
    /// 
    /// The parameter ``axis`` specifies which axis of the input shape denotes
    /// the &#39;channel&#39; (separately normalized groups).  The default is -1, which sets the channel
    /// axis to be the last item in the input shape.
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\nn\layer_norm.cc:L156</summary>
    /// <param name="data">Input data to layer normalization</param>
    /// <param name="gamma">gamma array</param>
    /// <param name="beta">beta array</param>
    /// <param name="axis">The axis to perform layer normalization. Usually, this should be be axis of the channel dimension. Negative values means indexing from right to left.</param>
    /// <param name="eps">An `epsilon` parameter to prevent division by 0.</param>
    /// <param name="outputMeanVar">Output the mean and std calculated along the given axis.</param>
    static member LayerNorm(data : NDArray, 
                            gamma : NDArray, 
                            beta : NDArray, 
                            [<Optional; DefaultParameterValue(-1)>] axis : int, 
                            [<Optional; DefaultParameterValue(9.99999975E-06)>] eps : float, 
                            [<Optional; DefaultParameterValue(false)>] outputMeanVar : bool) =
        let creator = AtomicSymbolCreator.FromName "LayerNorm"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg gamma)) then gamma.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg beta)) then beta.UnsafeHandle|]
                                                 [|"axis"; "eps"; "output_mean_var"|]
                                                 [|string axis; string eps; string outputMeanVar|]
        outputs |> Array.map (fun h -> new NDArray(h))
    /// <summary>Layer normalization.
    /// 
    /// Normalizes the channels of the input tensor by mean and variance, and applies a scale ``gamma`` as
    /// well as offset ``beta``.
    /// 
    /// Assume the input has more than one dimension and we normalize along axis 1.
    /// We first compute the mean and variance along this axis and then 
    /// compute the normalized output, which has the same shape as input, as following:
    /// 
    /// .. math::
    /// 
    ///   out = \frac{data - mean(data, axis)}{\sqrt{var(data, axis) + \epsilon}} * gamma + beta
    /// 
    /// Both ``gamma`` and ``beta`` are learnable parameters.
    /// 
    /// Unlike BatchNorm and InstanceNorm,  the *mean* and *var* are computed along the channel dimension.
    /// 
    /// Assume the input has size *k* on axis 1, then both ``gamma`` and ``beta``
    /// have shape *(k,)*. If ``output_mean_var`` is set to be true, then outputs both ``data_mean`` and
    /// ``data_std``. Note that no gradient will be passed through these two outputs.
    /// 
    /// The parameter ``axis`` specifies which axis of the input shape denotes
    /// the &#39;channel&#39; (separately normalized groups).  The default is -1, which sets the channel
    /// axis to be the last item in the input shape.
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\nn\layer_norm.cc:L156</summary>
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="data">Input data to layer normalization</param>
    /// <param name="gamma">gamma array</param>
    /// <param name="beta">beta array</param>
    /// <param name="axis">The axis to perform layer normalization. Usually, this should be be axis of the channel dimension. Negative values means indexing from right to left.</param>
    /// <param name="eps">An `epsilon` parameter to prevent division by 0.</param>
    /// <param name="outputMeanVar">Output the mean and std calculated along the given axis.</param>
    static member LayerNorm(outputArray : NDArray seq, 
                            data : NDArray, 
                            gamma : NDArray, 
                            beta : NDArray, 
                            [<Optional; DefaultParameterValue(-1)>] axis : int, 
                            [<Optional; DefaultParameterValue(9.99999975E-06)>] eps : float, 
                            [<Optional; DefaultParameterValue(false)>] outputMeanVar : bool) =
        let creator = AtomicSymbolCreator.FromName "LayerNorm"
        let names = [|"axis"; "eps"; "output_mean_var"|]
        let vals = [|string axis; string eps; string outputMeanVar|]
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg gamma)) then gamma.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg beta)) then beta.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <summary>Layer normalization.
    /// 
    /// Normalizes the channels of the input tensor by mean and variance, and applies a scale ``gamma`` as
    /// well as offset ``beta``.
    /// 
    /// Assume the input has more than one dimension and we normalize along axis 1.
    /// We first compute the mean and variance along this axis and then 
    /// compute the normalized output, which has the same shape as input, as following:
    /// 
    /// .. math::
    /// 
    ///   out = \frac{data - mean(data, axis)}{\sqrt{var(data, axis) + \epsilon}} * gamma + beta
    /// 
    /// Both ``gamma`` and ``beta`` are learnable parameters.
    /// 
    /// Unlike BatchNorm and InstanceNorm,  the *mean* and *var* are computed along the channel dimension.
    /// 
    /// Assume the input has size *k* on axis 1, then both ``gamma`` and ``beta``
    /// have shape *(k,)*. If ``output_mean_var`` is set to be true, then outputs both ``data_mean`` and
    /// ``data_std``. Note that no gradient will be passed through these two outputs.
    /// 
    /// The parameter ``axis`` specifies which axis of the input shape denotes
    /// the &#39;channel&#39; (separately normalized groups).  The default is -1, which sets the channel
    /// axis to be the last item in the input shape.
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\nn\layer_norm.cc:L156</summary>
    /// <param name="data">Input data to layer normalization</param>
    /// <param name="gamma">gamma array</param>
    /// <param name="beta">beta array</param>
    /// <param name="axis">The axis to perform layer normalization. Usually, this should be be axis of the channel dimension. Negative values means indexing from right to left.</param>
    /// <param name="eps">An `epsilon` parameter to prevent division by 0.</param>
    /// <param name="outputMeanVar">Output the mean and std calculated along the given axis.</param>
    static member LayerNorm([<Optional>] ?data : Symbol, [<Optional>] ?gamma : Symbol, [<Optional>] ?beta : Symbol, [<Optional>] ?axis : int, [<Optional>] ?eps : float, [<Optional>] ?outputMeanVar : bool) =
        LayerNorm(?data = data, ?gamma = gamma, ?beta = beta, ?axis = axis, ?eps = eps, ?outputMeanVar = outputMeanVar)


    /// <summary>Computes the log softmax of the input.
    /// This is equivalent to computing softmax followed by log.
    /// 
    /// Examples::
    /// 
    ///   &gt;&gt;&gt; x = mx.nd.array([1, 2, .1])
    ///   &gt;&gt;&gt; mx.nd.log_softmax(x).asnumpy()
    ///   array([-1.41702998, -0.41702995, -2.31702995], dtype=float32)
    /// 
    ///   &gt;&gt;&gt; x = mx.nd.array( [[1, 2, .1],[.1, 2, 1]] )
    ///   &gt;&gt;&gt; mx.nd.log_softmax(x, axis=0).asnumpy()
    ///   array([[-0.34115392, -0.69314718, -1.24115396],
    ///          [-1.24115396, -0.69314718, -0.34115392]], dtype=float32)
    /// 
    /// 
    /// </summary>
    /// <param name="data">The input array.</param>
    /// <param name="axis">The axis along which to compute softmax.</param>
    /// <param name="temperature">Temperature parameter in softmax</param>
    /// <param name="dtype">DType of the output in case this can&#39;t be inferred. Defaults to the same as input&#39;s dtype if not defined (dtype=None).</param>
    /// <param name="useLength">Whether to use the length input as a mask over the data input.</param>
    static member LogSoftmax(data : NDArray, 
                             [<Optional>] ?axis : int, 
                             [<Optional>] ?temperature : float, 
                             [<Optional>] ?dtype : FloatDType, 
                             [<Optional>] ?useLength : bool) =
        let creator = AtomicSymbolCreator.FromName "log_softmax"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle|]
                                                 [|"axis"; "temperature"; "dtype"; "use_length"|]
                                                 [|(match axis with None -> "-1" | Some axis -> string axis); (match temperature with None -> "None" | Some temperature -> string temperature); (match dtype with None -> "None" | Some dtype -> string dtype); (match useLength with None -> "None" | Some useLength -> string useLength)|]
        (new NDArray(outputs.[0]))
    /// <summary>Computes the log softmax of the input.
    /// This is equivalent to computing softmax followed by log.
    /// 
    /// Examples::
    /// 
    ///   &gt;&gt;&gt; x = mx.nd.array([1, 2, .1])
    ///   &gt;&gt;&gt; mx.nd.log_softmax(x).asnumpy()
    ///   array([-1.41702998, -0.41702995, -2.31702995], dtype=float32)
    /// 
    ///   &gt;&gt;&gt; x = mx.nd.array( [[1, 2, .1],[.1, 2, 1]] )
    ///   &gt;&gt;&gt; mx.nd.log_softmax(x, axis=0).asnumpy()
    ///   array([[-0.34115392, -0.69314718, -1.24115396],
    ///          [-1.24115396, -0.69314718, -0.34115392]], dtype=float32)
    /// 
    /// 
    /// </summary>
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="data">The input array.</param>
    /// <param name="axis">The axis along which to compute softmax.</param>
    /// <param name="temperature">Temperature parameter in softmax</param>
    /// <param name="dtype">DType of the output in case this can&#39;t be inferred. Defaults to the same as input&#39;s dtype if not defined (dtype=None).</param>
    /// <param name="useLength">Whether to use the length input as a mask over the data input.</param>
    static member LogSoftmax(outputArray : NDArray seq, 
                             data : NDArray, 
                             [<Optional>] ?axis : int, 
                             [<Optional>] ?temperature : float, 
                             [<Optional>] ?dtype : FloatDType, 
                             [<Optional>] ?useLength : bool) =
        let creator = AtomicSymbolCreator.FromName "log_softmax"
        let names = [|"axis"; "temperature"; "dtype"; "use_length"|]
        let vals = [|(match axis with None -> "-1" | Some axis -> string axis); (match temperature with None -> "None" | Some temperature -> string temperature); (match dtype with None -> "None" | Some dtype -> string dtype); (match useLength with None -> "None" | Some useLength -> string useLength)|]
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <summary>Computes the log softmax of the input.
    /// This is equivalent to computing softmax followed by log.
    /// 
    /// Examples::
    /// 
    ///   &gt;&gt;&gt; x = mx.nd.array([1, 2, .1])
    ///   &gt;&gt;&gt; mx.nd.log_softmax(x).asnumpy()
    ///   array([-1.41702998, -0.41702995, -2.31702995], dtype=float32)
    /// 
    ///   &gt;&gt;&gt; x = mx.nd.array( [[1, 2, .1],[.1, 2, 1]] )
    ///   &gt;&gt;&gt; mx.nd.log_softmax(x, axis=0).asnumpy()
    ///   array([[-0.34115392, -0.69314718, -1.24115396],
    ///          [-1.24115396, -0.69314718, -0.34115392]], dtype=float32)
    /// 
    /// 
    /// </summary>
    /// <param name="data">The input array.</param>
    /// <param name="axis">The axis along which to compute softmax.</param>
    /// <param name="temperature">Temperature parameter in softmax</param>
    /// <param name="dtype">DType of the output in case this can&#39;t be inferred. Defaults to the same as input&#39;s dtype if not defined (dtype=None).</param>
    /// <param name="useLength">Whether to use the length input as a mask over the data input.</param>
    static member LogSoftmax([<Optional>] ?data : Symbol, [<Optional>] ?axis : int, [<Optional>] ?temperature : float, [<Optional>] ?dtype : FloatDType, [<Optional>] ?useLength : bool) =
        LogSoftmax(?data = data, ?axis = axis, ?temperature = temperature, ?dtype = dtype, ?useLength = useLength)


    /// <summary>Applies local response normalization to the input.
    /// 
    /// The local response normalization layer performs &quot;lateral inhibition&quot; by normalizing
    /// over local input regions.
    /// 
    /// If :math:`a_{x,y}^{i}` is the activity of a neuron computed by applying kernel :math:`i` at position
    /// :math:`(x, y)` and then applying the ReLU nonlinearity, the response-normalized
    /// activity :math:`b_{x,y}^{i}` is given by the expression:
    /// 
    /// .. math::
    ///    b_{x,y}^{i} = \frac{a_{x,y}^{i}}{\Bigg({k + \frac{\alpha}{n} \sum_{j=max(0, i-\frac{n}{2})}^{min(N-1, i+\frac{n}{2})} (a_{x,y}^{j})^{2}}\Bigg)^{\beta}}
    /// 
    /// where the sum runs over :math:`n` &quot;adjacent&quot; kernel maps at the same spatial position, and :math:`N` is the total
    /// number of kernels in the layer.
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\nn\lrn.cc:L164</summary>
    /// <param name="data">Input data to LRN</param>
    /// <param name="nsize">normalization window width in elements.</param>
    /// <param name="alpha">The variance scaling parameter :math:`lpha` in the LRN expression.</param>
    /// <param name="beta">The power parameter :math:`eta` in the LRN expression.</param>
    /// <param name="knorm">The parameter :math:`k` in the LRN expression.</param>
    static member LRN(data : NDArray, 
                      nsize : int, 
                      [<Optional; DefaultParameterValue(9.99999975E-05)>] alpha : float, 
                      [<Optional; DefaultParameterValue(0.75)>] beta : float, 
                      [<Optional; DefaultParameterValue(2.0)>] knorm : float) =
        let creator = AtomicSymbolCreator.FromName "LRN"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle|]
                                                 [|"nsize"; "alpha"; "beta"; "knorm"|]
                                                 [|string nsize; string alpha; string beta; string knorm|]
        (new NDArray(outputs.[0])), (new NDArray(outputs.[1]))
    /// <summary>Applies local response normalization to the input.
    /// 
    /// The local response normalization layer performs &quot;lateral inhibition&quot; by normalizing
    /// over local input regions.
    /// 
    /// If :math:`a_{x,y}^{i}` is the activity of a neuron computed by applying kernel :math:`i` at position
    /// :math:`(x, y)` and then applying the ReLU nonlinearity, the response-normalized
    /// activity :math:`b_{x,y}^{i}` is given by the expression:
    /// 
    /// .. math::
    ///    b_{x,y}^{i} = \frac{a_{x,y}^{i}}{\Bigg({k + \frac{\alpha}{n} \sum_{j=max(0, i-\frac{n}{2})}^{min(N-1, i+\frac{n}{2})} (a_{x,y}^{j})^{2}}\Bigg)^{\beta}}
    /// 
    /// where the sum runs over :math:`n` &quot;adjacent&quot; kernel maps at the same spatial position, and :math:`N` is the total
    /// number of kernels in the layer.
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\nn\lrn.cc:L164</summary>
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="data">Input data to LRN</param>
    /// <param name="nsize">normalization window width in elements.</param>
    /// <param name="alpha">The variance scaling parameter :math:`lpha` in the LRN expression.</param>
    /// <param name="beta">The power parameter :math:`eta` in the LRN expression.</param>
    /// <param name="knorm">The parameter :math:`k` in the LRN expression.</param>
    static member LRN(outputArray : NDArray seq, 
                      data : NDArray, 
                      nsize : int, 
                      [<Optional; DefaultParameterValue(9.99999975E-05)>] alpha : float, 
                      [<Optional; DefaultParameterValue(0.75)>] beta : float, 
                      [<Optional; DefaultParameterValue(2.0)>] knorm : float) =
        let creator = AtomicSymbolCreator.FromName "LRN"
        let names = [|"nsize"; "alpha"; "beta"; "knorm"|]
        let vals = [|string nsize; string alpha; string beta; string knorm|]
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <summary>Applies local response normalization to the input.
    /// 
    /// The local response normalization layer performs &quot;lateral inhibition&quot; by normalizing
    /// over local input regions.
    /// 
    /// If :math:`a_{x,y}^{i}` is the activity of a neuron computed by applying kernel :math:`i` at position
    /// :math:`(x, y)` and then applying the ReLU nonlinearity, the response-normalized
    /// activity :math:`b_{x,y}^{i}` is given by the expression:
    /// 
    /// .. math::
    ///    b_{x,y}^{i} = \frac{a_{x,y}^{i}}{\Bigg({k + \frac{\alpha}{n} \sum_{j=max(0, i-\frac{n}{2})}^{min(N-1, i+\frac{n}{2})} (a_{x,y}^{j})^{2}}\Bigg)^{\beta}}
    /// 
    /// where the sum runs over :math:`n` &quot;adjacent&quot; kernel maps at the same spatial position, and :math:`N` is the total
    /// number of kernels in the layer.
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\nn\lrn.cc:L164</summary>
    /// <param name="data">Input data to LRN</param>
    /// <param name="nsize">normalization window width in elements.</param>
    /// <param name="alpha">The variance scaling parameter :math:`lpha` in the LRN expression.</param>
    /// <param name="beta">The power parameter :math:`eta` in the LRN expression.</param>
    /// <param name="knorm">The parameter :math:`k` in the LRN expression.</param>
    static member LRN(data : Symbol, nsize : int, [<Optional>] ?alpha : float, [<Optional>] ?beta : float, [<Optional>] ?knorm : float) =
        LRN(data, nsize, ?alpha = alpha, ?beta = beta, ?knorm = knorm)
    /// <summary>Applies local response normalization to the input.
    /// 
    /// The local response normalization layer performs &quot;lateral inhibition&quot; by normalizing
    /// over local input regions.
    /// 
    /// If :math:`a_{x,y}^{i}` is the activity of a neuron computed by applying kernel :math:`i` at position
    /// :math:`(x, y)` and then applying the ReLU nonlinearity, the response-normalized
    /// activity :math:`b_{x,y}^{i}` is given by the expression:
    /// 
    /// .. math::
    ///    b_{x,y}^{i} = \frac{a_{x,y}^{i}}{\Bigg({k + \frac{\alpha}{n} \sum_{j=max(0, i-\frac{n}{2})}^{min(N-1, i+\frac{n}{2})} (a_{x,y}^{j})^{2}}\Bigg)^{\beta}}
    /// 
    /// where the sum runs over :math:`n` &quot;adjacent&quot; kernel maps at the same spatial position, and :math:`N` is the total
    /// number of kernels in the layer.
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\nn\lrn.cc:L164</summary>
    /// <param name="nsize">normalization window width in elements.</param>
    /// <param name="data">Input data to LRN</param>
    /// <param name="alpha">The variance scaling parameter :math:`lpha` in the LRN expression.</param>
    /// <param name="beta">The power parameter :math:`eta` in the LRN expression.</param>
    /// <param name="knorm">The parameter :math:`k` in the LRN expression.</param>
    static member LRN(nsize : int, [<Optional>] ?data : Symbol, [<Optional>] ?alpha : float, [<Optional>] ?beta : float, [<Optional>] ?knorm : float) =
        LRN(nsize, ?data = data, ?alpha = alpha, ?beta = beta, ?knorm = knorm)


    /// <summary>
    /// Calculate the mean and variance of `data`.
    /// 
    /// The mean and variance are calculated by aggregating the contents of data across axes.
    /// If x is 1-D and axes = [0] this is just the mean and variance of a vector.
    /// 
    /// Example:
    /// 
    ///      x = [[1, 2, 3], [4, 5, 6]]
    ///      mean, var = moments(data=x, axes=[0])
    ///      mean = [2.5, 3.5, 4.5]
    ///      var = [2.25, 2.25, 2.25]
    ///      mean, var = moments(data=x, axes=[1])
    ///      mean = [2.0, 5.0]
    ///      var = [0.66666667, 0.66666667]
    ///      mean, var = moments(data=x, axis=[0, 1])
    ///      mean = [3.5]
    ///      var = [2.9166667]
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\nn\moments.cc:L54</summary>
    /// <param name="data">Input ndarray</param>
    /// <param name="axes">Array of ints. Axes along which to compute mean and variance.</param>
    /// <param name="keepdims">produce moments with the same dimensionality as the input.</param>
    static member Moments(data : NDArray, [<Optional>] ?axes : int seq, [<Optional>] ?keepdims : bool) =
        let creator = AtomicSymbolCreator.FromName "moments"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle|]
                                                 [|"axes"; "keepdims"|]
                                                 [|(match axes with None -> "None" | Some axes -> (axes |> Seq.map string |> String.concat ", " |> sprintf "[%s]")); (match keepdims with None -> "false" | Some keepdims -> string keepdims)|]
        (new NDArray(outputs.[0])), (new NDArray(outputs.[1]))
    /// <summary>
    /// Calculate the mean and variance of `data`.
    /// 
    /// The mean and variance are calculated by aggregating the contents of data across axes.
    /// If x is 1-D and axes = [0] this is just the mean and variance of a vector.
    /// 
    /// Example:
    /// 
    ///      x = [[1, 2, 3], [4, 5, 6]]
    ///      mean, var = moments(data=x, axes=[0])
    ///      mean = [2.5, 3.5, 4.5]
    ///      var = [2.25, 2.25, 2.25]
    ///      mean, var = moments(data=x, axes=[1])
    ///      mean = [2.0, 5.0]
    ///      var = [0.66666667, 0.66666667]
    ///      mean, var = moments(data=x, axis=[0, 1])
    ///      mean = [3.5]
    ///      var = [2.9166667]
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\nn\moments.cc:L54</summary>
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="data">Input ndarray</param>
    /// <param name="axes">Array of ints. Axes along which to compute mean and variance.</param>
    /// <param name="keepdims">produce moments with the same dimensionality as the input.</param>
    static member Moments(outputArray : NDArray seq, data : NDArray, [<Optional>] ?axes : int seq, [<Optional>] ?keepdims : bool) =
        let creator = AtomicSymbolCreator.FromName "moments"
        let names = [|"axes"; "keepdims"|]
        let vals = [|(match axes with None -> "None" | Some axes -> (axes |> Seq.map string |> String.concat ", " |> sprintf "[%s]")); (match keepdims with None -> "false" | Some keepdims -> string keepdims)|]
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <summary>
    /// Calculate the mean and variance of `data`.
    /// 
    /// The mean and variance are calculated by aggregating the contents of data across axes.
    /// If x is 1-D and axes = [0] this is just the mean and variance of a vector.
    /// 
    /// Example:
    /// 
    ///      x = [[1, 2, 3], [4, 5, 6]]
    ///      mean, var = moments(data=x, axes=[0])
    ///      mean = [2.5, 3.5, 4.5]
    ///      var = [2.25, 2.25, 2.25]
    ///      mean, var = moments(data=x, axes=[1])
    ///      mean = [2.0, 5.0]
    ///      var = [0.66666667, 0.66666667]
    ///      mean, var = moments(data=x, axis=[0, 1])
    ///      mean = [3.5]
    ///      var = [2.9166667]
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\nn\moments.cc:L54</summary>
    /// <param name="data">Input ndarray</param>
    /// <param name="axes">Array of ints. Axes along which to compute mean and variance.</param>
    /// <param name="keepdims">produce moments with the same dimensionality as the input.</param>
    static member Moments([<Optional>] ?data : Symbol, [<Optional>] ?axes : int seq, [<Optional>] ?keepdims : bool) =
        Moments(?data = data, ?axes = axes, ?keepdims = keepdims)


    /// <summary>Performs pooling on the input.
    /// 
    /// The shapes for 1-D pooling are
    /// 
    /// - **data** and **out**: *(batch_size, channel, width)* (NCW layout) or
    ///   *(batch_size, width, channel)* (NWC layout),
    /// 
    /// The shapes for 2-D pooling are
    /// 
    /// - **data** and **out**: *(batch_size, channel, height, width)* (NCHW layout) or
    ///   *(batch_size, height, width, channel)* (NHWC layout),
    /// 
    ///     out_height = f(height, kernel[0], pad[0], stride[0])
    ///     out_width = f(width, kernel[1], pad[1], stride[1])
    /// 
    /// The definition of *f* depends on ``pooling_convention``, which has two options:
    /// 
    /// - **valid** (default)::
    /// 
    ///     f(x, k, p, s) = floor((x+2*p-k)/s)+1
    /// 
    /// - **full**, which is compatible with Caffe::
    /// 
    ///     f(x, k, p, s) = ceil((x+2*p-k)/s)+1
    /// 
    /// When ``global_pool`` is set to be true, then global pooling is performed. It will reset
    /// ``kernel=(height, width)`` and set the appropiate padding to 0.
    /// 
    /// Three pooling options are supported by ``pool_type``:
    /// 
    /// - **avg**: average pooling
    /// - **max**: max pooling
    /// - **sum**: sum pooling
    /// - **lp**: Lp pooling
    /// 
    /// For 3-D pooling, an additional *depth* dimension is added before
    /// *height*. Namely the input data and output will have shape *(batch_size, channel, depth,
    /// height, width)* (NCDHW layout) or *(batch_size, depth, height, width, channel)* (NDHWC layout).
    /// 
    /// Notes on Lp pooling:
    /// 
    /// Lp pooling was first introduced by this paper: https://arxiv.org/pdf/1204.3968.pdf.
    /// L-1 pooling is simply sum pooling, while L-inf pooling is simply max pooling.
    /// We can see that Lp pooling stands between those two, in practice the most common value for p is 2.
    /// 
    /// For each window ``X``, the mathematical expression for Lp pooling is:
    /// 
    /// :math:`f(X) = \sqrt[p]{\sum_{x}^{X} x^p}`
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\nn\pooling.cc:L417</summary>
    /// <param name="data">Input data to the pooling operator.</param>
    /// <param name="kernel">Pooling kernel size: (y, x) or (d, y, x)</param>
    /// <param name="poolType">Pooling type to be applied.</param>
    /// <param name="globalPool">Ignore kernel size, do global pooling based on current input feature map. </param>
    /// <param name="cudnnOff">Turn off cudnn pooling and use MXNet pooling operator. </param>
    /// <param name="poolingConvention">Pooling convention to be applied.</param>
    /// <param name="stride">Stride: for pooling (y, x) or (d, y, x). Defaults to 1 for each dimension.</param>
    /// <param name="pad">Pad for pooling: (y, x) or (d, y, x). Defaults to no padding.</param>
    /// <param name="pValue">Value of p for Lp pooling, can be 1 or 2, required for Lp Pooling.</param>
    /// <param name="countIncludePad">Only used for AvgPool, specify whether to count padding elements for averagecalculation. For example, with a 5*5 kernel on a 3*3 corner of a image,the sum of the 9 valid elements will be divided by 25 if this is set to true,or it will be divided by 9 if this is set to false. Defaults to true.</param>
    /// <param name="layout">Set layout for input and output. Empty for
    ///     default layout: NCW for 1d, NCHW for 2d and NCDHW for 3d.</param>
    static member Pooling(data : NDArray, 
                          [<Optional>] ?kernel : int seq, 
                          [<Optional>] ?poolType : PoolType, 
                          [<Optional>] ?globalPool : bool, 
                          [<Optional>] ?cudnnOff : bool, 
                          [<Optional>] ?poolingConvention : PoolingConvention, 
                          [<Optional>] ?stride : int seq, 
                          [<Optional>] ?pad : int seq, 
                          [<Optional>] ?pValue : int, 
                          [<Optional>] ?countIncludePad : bool, 
                          [<Optional>] ?layout : PoolingLayout) =
        let creator = AtomicSymbolCreator.FromName "Pooling"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle|]
                                                 [|"kernel"; "pool_type"; "global_pool"; "cudnn_off"; "pooling_convention"; "stride"; "pad"; "p_value"; "count_include_pad"; "layout"|]
                                                 [|(match kernel with None -> "[]" | Some kernel -> (kernel |> Seq.map string |> String.concat ", " |> sprintf "[%s]")); (match poolType with None -> "max" | Some poolType -> string poolType); (match globalPool with None -> "false" | Some globalPool -> string globalPool); (match cudnnOff with None -> "false" | Some cudnnOff -> string cudnnOff); (match poolingConvention with None -> "valid" | Some poolingConvention -> string poolingConvention); (match stride with None -> "[]" | Some stride -> (stride |> Seq.map string |> String.concat ", " |> sprintf "[%s]")); (match pad with None -> "[]" | Some pad -> (pad |> Seq.map string |> String.concat ", " |> sprintf "[%s]")); (match pValue with None -> "None" | Some pValue -> string pValue); (match countIncludePad with None -> "None" | Some countIncludePad -> string countIncludePad); (match layout with None -> "None" | Some layout -> string layout)|]
        (new NDArray(outputs.[0]))
    /// <summary>Performs pooling on the input.
    /// 
    /// The shapes for 1-D pooling are
    /// 
    /// - **data** and **out**: *(batch_size, channel, width)* (NCW layout) or
    ///   *(batch_size, width, channel)* (NWC layout),
    /// 
    /// The shapes for 2-D pooling are
    /// 
    /// - **data** and **out**: *(batch_size, channel, height, width)* (NCHW layout) or
    ///   *(batch_size, height, width, channel)* (NHWC layout),
    /// 
    ///     out_height = f(height, kernel[0], pad[0], stride[0])
    ///     out_width = f(width, kernel[1], pad[1], stride[1])
    /// 
    /// The definition of *f* depends on ``pooling_convention``, which has two options:
    /// 
    /// - **valid** (default)::
    /// 
    ///     f(x, k, p, s) = floor((x+2*p-k)/s)+1
    /// 
    /// - **full**, which is compatible with Caffe::
    /// 
    ///     f(x, k, p, s) = ceil((x+2*p-k)/s)+1
    /// 
    /// When ``global_pool`` is set to be true, then global pooling is performed. It will reset
    /// ``kernel=(height, width)`` and set the appropiate padding to 0.
    /// 
    /// Three pooling options are supported by ``pool_type``:
    /// 
    /// - **avg**: average pooling
    /// - **max**: max pooling
    /// - **sum**: sum pooling
    /// - **lp**: Lp pooling
    /// 
    /// For 3-D pooling, an additional *depth* dimension is added before
    /// *height*. Namely the input data and output will have shape *(batch_size, channel, depth,
    /// height, width)* (NCDHW layout) or *(batch_size, depth, height, width, channel)* (NDHWC layout).
    /// 
    /// Notes on Lp pooling:
    /// 
    /// Lp pooling was first introduced by this paper: https://arxiv.org/pdf/1204.3968.pdf.
    /// L-1 pooling is simply sum pooling, while L-inf pooling is simply max pooling.
    /// We can see that Lp pooling stands between those two, in practice the most common value for p is 2.
    /// 
    /// For each window ``X``, the mathematical expression for Lp pooling is:
    /// 
    /// :math:`f(X) = \sqrt[p]{\sum_{x}^{X} x^p}`
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\nn\pooling.cc:L417</summary>
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="data">Input data to the pooling operator.</param>
    /// <param name="kernel">Pooling kernel size: (y, x) or (d, y, x)</param>
    /// <param name="poolType">Pooling type to be applied.</param>
    /// <param name="globalPool">Ignore kernel size, do global pooling based on current input feature map. </param>
    /// <param name="cudnnOff">Turn off cudnn pooling and use MXNet pooling operator. </param>
    /// <param name="poolingConvention">Pooling convention to be applied.</param>
    /// <param name="stride">Stride: for pooling (y, x) or (d, y, x). Defaults to 1 for each dimension.</param>
    /// <param name="pad">Pad for pooling: (y, x) or (d, y, x). Defaults to no padding.</param>
    /// <param name="pValue">Value of p for Lp pooling, can be 1 or 2, required for Lp Pooling.</param>
    /// <param name="countIncludePad">Only used for AvgPool, specify whether to count padding elements for averagecalculation. For example, with a 5*5 kernel on a 3*3 corner of a image,the sum of the 9 valid elements will be divided by 25 if this is set to true,or it will be divided by 9 if this is set to false. Defaults to true.</param>
    /// <param name="layout">Set layout for input and output. Empty for
    ///     default layout: NCW for 1d, NCHW for 2d and NCDHW for 3d.</param>
    static member Pooling(outputArray : NDArray seq, 
                          data : NDArray, 
                          [<Optional>] ?kernel : int seq, 
                          [<Optional>] ?poolType : PoolType, 
                          [<Optional>] ?globalPool : bool, 
                          [<Optional>] ?cudnnOff : bool, 
                          [<Optional>] ?poolingConvention : PoolingConvention, 
                          [<Optional>] ?stride : int seq, 
                          [<Optional>] ?pad : int seq, 
                          [<Optional>] ?pValue : int, 
                          [<Optional>] ?countIncludePad : bool, 
                          [<Optional>] ?layout : PoolingLayout) =
        let creator = AtomicSymbolCreator.FromName "Pooling"
        let names = [|"kernel"; "pool_type"; "global_pool"; "cudnn_off"; "pooling_convention"; "stride"; "pad"; "p_value"; "count_include_pad"; "layout"|]
        let vals = [|(match kernel with None -> "[]" | Some kernel -> (kernel |> Seq.map string |> String.concat ", " |> sprintf "[%s]")); (match poolType with None -> "max" | Some poolType -> string poolType); (match globalPool with None -> "false" | Some globalPool -> string globalPool); (match cudnnOff with None -> "false" | Some cudnnOff -> string cudnnOff); (match poolingConvention with None -> "valid" | Some poolingConvention -> string poolingConvention); (match stride with None -> "[]" | Some stride -> (stride |> Seq.map string |> String.concat ", " |> sprintf "[%s]")); (match pad with None -> "[]" | Some pad -> (pad |> Seq.map string |> String.concat ", " |> sprintf "[%s]")); (match pValue with None -> "None" | Some pValue -> string pValue); (match countIncludePad with None -> "None" | Some countIncludePad -> string countIncludePad); (match layout with None -> "None" | Some layout -> string layout)|]
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <summary>Performs pooling on the input.
    /// 
    /// The shapes for 1-D pooling are
    /// 
    /// - **data** and **out**: *(batch_size, channel, width)* (NCW layout) or
    ///   *(batch_size, width, channel)* (NWC layout),
    /// 
    /// The shapes for 2-D pooling are
    /// 
    /// - **data** and **out**: *(batch_size, channel, height, width)* (NCHW layout) or
    ///   *(batch_size, height, width, channel)* (NHWC layout),
    /// 
    ///     out_height = f(height, kernel[0], pad[0], stride[0])
    ///     out_width = f(width, kernel[1], pad[1], stride[1])
    /// 
    /// The definition of *f* depends on ``pooling_convention``, which has two options:
    /// 
    /// - **valid** (default)::
    /// 
    ///     f(x, k, p, s) = floor((x+2*p-k)/s)+1
    /// 
    /// - **full**, which is compatible with Caffe::
    /// 
    ///     f(x, k, p, s) = ceil((x+2*p-k)/s)+1
    /// 
    /// When ``global_pool`` is set to be true, then global pooling is performed. It will reset
    /// ``kernel=(height, width)`` and set the appropiate padding to 0.
    /// 
    /// Three pooling options are supported by ``pool_type``:
    /// 
    /// - **avg**: average pooling
    /// - **max**: max pooling
    /// - **sum**: sum pooling
    /// - **lp**: Lp pooling
    /// 
    /// For 3-D pooling, an additional *depth* dimension is added before
    /// *height*. Namely the input data and output will have shape *(batch_size, channel, depth,
    /// height, width)* (NCDHW layout) or *(batch_size, depth, height, width, channel)* (NDHWC layout).
    /// 
    /// Notes on Lp pooling:
    /// 
    /// Lp pooling was first introduced by this paper: https://arxiv.org/pdf/1204.3968.pdf.
    /// L-1 pooling is simply sum pooling, while L-inf pooling is simply max pooling.
    /// We can see that Lp pooling stands between those two, in practice the most common value for p is 2.
    /// 
    /// For each window ``X``, the mathematical expression for Lp pooling is:
    /// 
    /// :math:`f(X) = \sqrt[p]{\sum_{x}^{X} x^p}`
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\nn\pooling.cc:L417</summary>
    /// <param name="data">Input data to the pooling operator.</param>
    /// <param name="kernel">Pooling kernel size: (y, x) or (d, y, x)</param>
    /// <param name="poolType">Pooling type to be applied.</param>
    /// <param name="globalPool">Ignore kernel size, do global pooling based on current input feature map. </param>
    /// <param name="cudnnOff">Turn off cudnn pooling and use MXNet pooling operator. </param>
    /// <param name="poolingConvention">Pooling convention to be applied.</param>
    /// <param name="stride">Stride: for pooling (y, x) or (d, y, x). Defaults to 1 for each dimension.</param>
    /// <param name="pad">Pad for pooling: (y, x) or (d, y, x). Defaults to no padding.</param>
    /// <param name="pValue">Value of p for Lp pooling, can be 1 or 2, required for Lp Pooling.</param>
    /// <param name="countIncludePad">Only used for AvgPool, specify whether to count padding elements for averagecalculation. For example, with a 5*5 kernel on a 3*3 corner of a image,the sum of the 9 valid elements will be divided by 25 if this is set to true,or it will be divided by 9 if this is set to false. Defaults to true.</param>
    /// <param name="layout">Set layout for input and output. Empty for
    ///     default layout: NCW for 1d, NCHW for 2d and NCDHW for 3d.</param>
    static member Pooling([<Optional>] ?data : Symbol, [<Optional>] ?kernel : int seq, [<Optional>] ?poolType : PoolType, [<Optional>] ?globalPool : bool, [<Optional>] ?cudnnOff : bool, [<Optional>] ?poolingConvention : PoolingConvention, [<Optional>] ?stride : int seq, [<Optional>] ?pad : int seq, [<Optional>] ?pValue : int, [<Optional>] ?countIncludePad : bool, [<Optional>] ?layout : PoolingLayout) =
        Pooling(?data = data, ?kernel = kernel, ?poolType = poolType, ?globalPool = globalPool, ?cudnnOff = cudnnOff, ?poolingConvention = poolingConvention, ?stride = stride, ?pad = pad, ?pValue = pValue, ?countIncludePad = countIncludePad, ?layout = layout)


    /// <summary>Applies the softmax function.
    /// 
    /// The resulting array contains elements in the range (0,1) and the elements along the given axis sum up to 1.
    /// 
    /// .. math::
    ///    softmax(\mathbf{z/t})_j = \frac{e^{z_j/t}}{\sum_{k=1}^K e^{z_k/t}}
    /// 
    /// for :math:`j = 1, ..., K`
    /// 
    /// t is the temperature parameter in softmax function. By default, t equals 1.0
    /// 
    /// Example::
    /// 
    ///   x = [[ 1.  1.  1.]
    ///        [ 1.  1.  1.]]
    /// 
    ///   softmax(x,axis=0) = [[ 0.5  0.5  0.5]
    ///                        [ 0.5  0.5  0.5]]
    /// 
    ///   softmax(x,axis=1) = [[ 0.33333334,  0.33333334,  0.33333334],
    ///                        [ 0.33333334,  0.33333334,  0.33333334]]
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\nn\softmax.cc:L103</summary>
    /// <param name="data">The input array.</param>
    /// <param name="length">The length array.</param>
    /// <param name="axis">The axis along which to compute softmax.</param>
    /// <param name="temperature">Temperature parameter in softmax</param>
    /// <param name="dtype">DType of the output in case this can&#39;t be inferred. Defaults to the same as input&#39;s dtype if not defined (dtype=None).</param>
    /// <param name="useLength">Whether to use the length input as a mask over the data input.</param>
    static member Softmax(data : NDArray, 
                          length : NDArray, 
                          [<Optional>] ?axis : int, 
                          [<Optional>] ?temperature : float, 
                          [<Optional>] ?dtype : FloatDType, 
                          [<Optional>] ?useLength : bool) =
        let creator = AtomicSymbolCreator.FromName "softmax"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg length)) then length.UnsafeHandle|]
                                                 [|"axis"; "temperature"; "dtype"; "use_length"|]
                                                 [|(match axis with None -> "-1" | Some axis -> string axis); (match temperature with None -> "None" | Some temperature -> string temperature); (match dtype with None -> "None" | Some dtype -> string dtype); (match useLength with None -> "None" | Some useLength -> string useLength)|]
        (new NDArray(outputs.[0]))
    /// <summary>Applies the softmax function.
    /// 
    /// The resulting array contains elements in the range (0,1) and the elements along the given axis sum up to 1.
    /// 
    /// .. math::
    ///    softmax(\mathbf{z/t})_j = \frac{e^{z_j/t}}{\sum_{k=1}^K e^{z_k/t}}
    /// 
    /// for :math:`j = 1, ..., K`
    /// 
    /// t is the temperature parameter in softmax function. By default, t equals 1.0
    /// 
    /// Example::
    /// 
    ///   x = [[ 1.  1.  1.]
    ///        [ 1.  1.  1.]]
    /// 
    ///   softmax(x,axis=0) = [[ 0.5  0.5  0.5]
    ///                        [ 0.5  0.5  0.5]]
    /// 
    ///   softmax(x,axis=1) = [[ 0.33333334,  0.33333334,  0.33333334],
    ///                        [ 0.33333334,  0.33333334,  0.33333334]]
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\nn\softmax.cc:L103</summary>
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="data">The input array.</param>
    /// <param name="length">The length array.</param>
    /// <param name="axis">The axis along which to compute softmax.</param>
    /// <param name="temperature">Temperature parameter in softmax</param>
    /// <param name="dtype">DType of the output in case this can&#39;t be inferred. Defaults to the same as input&#39;s dtype if not defined (dtype=None).</param>
    /// <param name="useLength">Whether to use the length input as a mask over the data input.</param>
    static member Softmax(outputArray : NDArray seq, 
                          data : NDArray, 
                          length : NDArray, 
                          [<Optional>] ?axis : int, 
                          [<Optional>] ?temperature : float, 
                          [<Optional>] ?dtype : FloatDType, 
                          [<Optional>] ?useLength : bool) =
        let creator = AtomicSymbolCreator.FromName "softmax"
        let names = [|"axis"; "temperature"; "dtype"; "use_length"|]
        let vals = [|(match axis with None -> "-1" | Some axis -> string axis); (match temperature with None -> "None" | Some temperature -> string temperature); (match dtype with None -> "None" | Some dtype -> string dtype); (match useLength with None -> "None" | Some useLength -> string useLength)|]
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg length)) then length.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <summary>Applies the softmax function.
    /// 
    /// The resulting array contains elements in the range (0,1) and the elements along the given axis sum up to 1.
    /// 
    /// .. math::
    ///    softmax(\mathbf{z/t})_j = \frac{e^{z_j/t}}{\sum_{k=1}^K e^{z_k/t}}
    /// 
    /// for :math:`j = 1, ..., K`
    /// 
    /// t is the temperature parameter in softmax function. By default, t equals 1.0
    /// 
    /// Example::
    /// 
    ///   x = [[ 1.  1.  1.]
    ///        [ 1.  1.  1.]]
    /// 
    ///   softmax(x,axis=0) = [[ 0.5  0.5  0.5]
    ///                        [ 0.5  0.5  0.5]]
    /// 
    ///   softmax(x,axis=1) = [[ 0.33333334,  0.33333334,  0.33333334],
    ///                        [ 0.33333334,  0.33333334,  0.33333334]]
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\nn\softmax.cc:L103</summary>
    /// <param name="data">The input array.</param>
    /// <param name="length">The length array.</param>
    /// <param name="axis">The axis along which to compute softmax.</param>
    /// <param name="temperature">Temperature parameter in softmax</param>
    /// <param name="dtype">DType of the output in case this can&#39;t be inferred. Defaults to the same as input&#39;s dtype if not defined (dtype=None).</param>
    /// <param name="useLength">Whether to use the length input as a mask over the data input.</param>
    static member Softmax([<Optional>] ?data : Symbol, [<Optional>] ?length : Symbol, [<Optional>] ?axis : int, [<Optional>] ?temperature : float, [<Optional>] ?dtype : FloatDType, [<Optional>] ?useLength : bool) =
        Softmax(?data = data, ?length = length, ?axis = axis, ?temperature = temperature, ?dtype = dtype, ?useLength = useLength)


    /// <summary>Applies softmax activation to input. This is intended for internal layers.
    /// 
    /// .. note::
    /// 
    ///   This operator has been deprecated, please use `softmax`.
    /// 
    /// If `mode` = ``instance``, this operator will compute a softmax for each instance in the batch.
    /// This is the default mode.
    /// 
    /// If `mode` = ``channel``, this operator will compute a k-class softmax at each position
    /// of each instance, where `k` = ``num_channel``. This mode can only be used when the input array
    /// has at least 3 dimensions.
    /// This can be used for `fully convolutional network`, `image segmentation`, etc.
    /// 
    /// Example::
    /// 
    ///   &gt;&gt;&gt; input_array = mx.nd.array([[3., 0.5, -0.5, 2., 7.],
    ///   &gt;&gt;&gt;                            [2., -.4, 7.,   3., 0.2]])
    ///   &gt;&gt;&gt; softmax_act = mx.nd.SoftmaxActivation(input_array)
    ///   &gt;&gt;&gt; print softmax_act.asnumpy()
    ///   [[  1.78322066e-02   1.46375655e-03   5.38485940e-04   6.56010211e-03   9.73605454e-01]
    ///    [  6.56221947e-03   5.95310994e-04   9.73919690e-01   1.78379621e-02   1.08472735e-03]]
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\nn\softmax_activation.cc:L59</summary>
    /// <param name="data">The input array.</param>
    /// <param name="mode">Specifies how to compute the softmax. If set to ``instance``, it computes softmax for each instance. If set to ``channel``, It computes cross channel softmax for each position of each instance.</param>
    static member SoftmaxActivation(data : NDArray, [<Optional>] mode : SoftmaxActivationMode) =
        let creator = AtomicSymbolCreator.FromName "SoftmaxActivation"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle|]
                                                 [|"mode"|]
                                                 [|(if isNull (mode :> obj) then "instance" else string mode)|]
        (new NDArray(outputs.[0]))
    /// <summary>Applies softmax activation to input. This is intended for internal layers.
    /// 
    /// .. note::
    /// 
    ///   This operator has been deprecated, please use `softmax`.
    /// 
    /// If `mode` = ``instance``, this operator will compute a softmax for each instance in the batch.
    /// This is the default mode.
    /// 
    /// If `mode` = ``channel``, this operator will compute a k-class softmax at each position
    /// of each instance, where `k` = ``num_channel``. This mode can only be used when the input array
    /// has at least 3 dimensions.
    /// This can be used for `fully convolutional network`, `image segmentation`, etc.
    /// 
    /// Example::
    /// 
    ///   &gt;&gt;&gt; input_array = mx.nd.array([[3., 0.5, -0.5, 2., 7.],
    ///   &gt;&gt;&gt;                            [2., -.4, 7.,   3., 0.2]])
    ///   &gt;&gt;&gt; softmax_act = mx.nd.SoftmaxActivation(input_array)
    ///   &gt;&gt;&gt; print softmax_act.asnumpy()
    ///   [[  1.78322066e-02   1.46375655e-03   5.38485940e-04   6.56010211e-03   9.73605454e-01]
    ///    [  6.56221947e-03   5.95310994e-04   9.73919690e-01   1.78379621e-02   1.08472735e-03]]
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\nn\softmax_activation.cc:L59</summary>
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="data">The input array.</param>
    /// <param name="mode">Specifies how to compute the softmax. If set to ``instance``, it computes softmax for each instance. If set to ``channel``, It computes cross channel softmax for each position of each instance.</param>
    static member SoftmaxActivation(outputArray : NDArray seq, data : NDArray, [<Optional>] mode : SoftmaxActivationMode) =
        let creator = AtomicSymbolCreator.FromName "SoftmaxActivation"
        let names = [|"mode"|]
        let vals = [|(if isNull (mode :> obj) then "instance" else string mode)|]
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <summary>Applies softmax activation to input. This is intended for internal layers.
    /// 
    /// .. note::
    /// 
    ///   This operator has been deprecated, please use `softmax`.
    /// 
    /// If `mode` = ``instance``, this operator will compute a softmax for each instance in the batch.
    /// This is the default mode.
    /// 
    /// If `mode` = ``channel``, this operator will compute a k-class softmax at each position
    /// of each instance, where `k` = ``num_channel``. This mode can only be used when the input array
    /// has at least 3 dimensions.
    /// This can be used for `fully convolutional network`, `image segmentation`, etc.
    /// 
    /// Example::
    /// 
    ///   &gt;&gt;&gt; input_array = mx.nd.array([[3., 0.5, -0.5, 2., 7.],
    ///   &gt;&gt;&gt;                            [2., -.4, 7.,   3., 0.2]])
    ///   &gt;&gt;&gt; softmax_act = mx.nd.SoftmaxActivation(input_array)
    ///   &gt;&gt;&gt; print softmax_act.asnumpy()
    ///   [[  1.78322066e-02   1.46375655e-03   5.38485940e-04   6.56010211e-03   9.73605454e-01]
    ///    [  6.56221947e-03   5.95310994e-04   9.73919690e-01   1.78379621e-02   1.08472735e-03]]
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\nn\softmax_activation.cc:L59</summary>
    /// <param name="data">The input array.</param>
    /// <param name="mode">Specifies how to compute the softmax. If set to ``instance``, it computes softmax for each instance. If set to ``channel``, It computes cross channel softmax for each position of each instance.</param>
    static member SoftmaxActivation([<Optional>] ?data : Symbol, [<Optional>] ?mode : SoftmaxActivationMode) =
        SoftmaxActivation(?data = data, ?mode = mode)


    /// <summary>Applies the softmin function.
    /// 
    /// The resulting array contains elements in the range (0,1) and the elements along the given axis sum
    /// up to 1.
    /// 
    /// .. math::
    ///    softmin(\mathbf{z/t})_j = \frac{e^{-z_j/t}}{\sum_{k=1}^K e^{-z_k/t}}
    /// 
    /// for :math:`j = 1, ..., K`
    /// 
    /// t is the temperature parameter in softmax function. By default, t equals 1.0
    /// 
    /// Example::
    /// 
    ///   x = [[ 1.  2.  3.]
    ///        [ 3.  2.  1.]]
    /// 
    ///   softmin(x,axis=0) = [[ 0.88079703,  0.5,  0.11920292],
    ///                        [ 0.11920292,  0.5,  0.88079703]]
    /// 
    ///   softmin(x,axis=1) = [[ 0.66524094,  0.24472848,  0.09003057],
    ///                        [ 0.09003057,  0.24472848,  0.66524094]]
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\nn\softmin.cc:L57</summary>
    /// <param name="data">The input array.</param>
    /// <param name="axis">The axis along which to compute softmax.</param>
    /// <param name="temperature">Temperature parameter in softmax</param>
    /// <param name="dtype">DType of the output in case this can&#39;t be inferred. Defaults to the same as input&#39;s dtype if not defined (dtype=None).</param>
    /// <param name="useLength">Whether to use the length input as a mask over the data input.</param>
    static member Softmin(data : NDArray, 
                          [<Optional>] ?axis : int, 
                          [<Optional>] ?temperature : float, 
                          [<Optional>] ?dtype : FloatDType, 
                          [<Optional>] ?useLength : bool) =
        let creator = AtomicSymbolCreator.FromName "softmin"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle|]
                                                 [|"axis"; "temperature"; "dtype"; "use_length"|]
                                                 [|(match axis with None -> "-1" | Some axis -> string axis); (match temperature with None -> "None" | Some temperature -> string temperature); (match dtype with None -> "None" | Some dtype -> string dtype); (match useLength with None -> "None" | Some useLength -> string useLength)|]
        (new NDArray(outputs.[0]))
    /// <summary>Applies the softmin function.
    /// 
    /// The resulting array contains elements in the range (0,1) and the elements along the given axis sum
    /// up to 1.
    /// 
    /// .. math::
    ///    softmin(\mathbf{z/t})_j = \frac{e^{-z_j/t}}{\sum_{k=1}^K e^{-z_k/t}}
    /// 
    /// for :math:`j = 1, ..., K`
    /// 
    /// t is the temperature parameter in softmax function. By default, t equals 1.0
    /// 
    /// Example::
    /// 
    ///   x = [[ 1.  2.  3.]
    ///        [ 3.  2.  1.]]
    /// 
    ///   softmin(x,axis=0) = [[ 0.88079703,  0.5,  0.11920292],
    ///                        [ 0.11920292,  0.5,  0.88079703]]
    /// 
    ///   softmin(x,axis=1) = [[ 0.66524094,  0.24472848,  0.09003057],
    ///                        [ 0.09003057,  0.24472848,  0.66524094]]
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\nn\softmin.cc:L57</summary>
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="data">The input array.</param>
    /// <param name="axis">The axis along which to compute softmax.</param>
    /// <param name="temperature">Temperature parameter in softmax</param>
    /// <param name="dtype">DType of the output in case this can&#39;t be inferred. Defaults to the same as input&#39;s dtype if not defined (dtype=None).</param>
    /// <param name="useLength">Whether to use the length input as a mask over the data input.</param>
    static member Softmin(outputArray : NDArray seq, 
                          data : NDArray, 
                          [<Optional>] ?axis : int, 
                          [<Optional>] ?temperature : float, 
                          [<Optional>] ?dtype : FloatDType, 
                          [<Optional>] ?useLength : bool) =
        let creator = AtomicSymbolCreator.FromName "softmin"
        let names = [|"axis"; "temperature"; "dtype"; "use_length"|]
        let vals = [|(match axis with None -> "-1" | Some axis -> string axis); (match temperature with None -> "None" | Some temperature -> string temperature); (match dtype with None -> "None" | Some dtype -> string dtype); (match useLength with None -> "None" | Some useLength -> string useLength)|]
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <summary>Applies the softmin function.
    /// 
    /// The resulting array contains elements in the range (0,1) and the elements along the given axis sum
    /// up to 1.
    /// 
    /// .. math::
    ///    softmin(\mathbf{z/t})_j = \frac{e^{-z_j/t}}{\sum_{k=1}^K e^{-z_k/t}}
    /// 
    /// for :math:`j = 1, ..., K`
    /// 
    /// t is the temperature parameter in softmax function. By default, t equals 1.0
    /// 
    /// Example::
    /// 
    ///   x = [[ 1.  2.  3.]
    ///        [ 3.  2.  1.]]
    /// 
    ///   softmin(x,axis=0) = [[ 0.88079703,  0.5,  0.11920292],
    ///                        [ 0.11920292,  0.5,  0.88079703]]
    /// 
    ///   softmin(x,axis=1) = [[ 0.66524094,  0.24472848,  0.09003057],
    ///                        [ 0.09003057,  0.24472848,  0.66524094]]
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\nn\softmin.cc:L57</summary>
    /// <param name="data">The input array.</param>
    /// <param name="axis">The axis along which to compute softmax.</param>
    /// <param name="temperature">Temperature parameter in softmax</param>
    /// <param name="dtype">DType of the output in case this can&#39;t be inferred. Defaults to the same as input&#39;s dtype if not defined (dtype=None).</param>
    /// <param name="useLength">Whether to use the length input as a mask over the data input.</param>
    static member Softmin([<Optional>] ?data : Symbol, [<Optional>] ?axis : int, [<Optional>] ?temperature : float, [<Optional>] ?dtype : FloatDType, [<Optional>] ?useLength : bool) =
        Softmin(?data = data, ?axis = axis, ?temperature = temperature, ?dtype = dtype, ?useLength = useLength)


    /// <summary>Upsamples the given input data.
    /// 
    /// Two algorithms (``sample_type``) are available for upsampling:
    /// 
    /// - Nearest Neighbor
    /// - Bilinear
    /// 
    /// **Nearest Neighbor Upsampling**
    /// 
    /// Input data is expected to be NCHW.
    /// 
    /// Example::
    /// 
    ///   x = [[[[1. 1. 1.]
    ///          [1. 1. 1.]
    ///          [1. 1. 1.]]]]
    /// 
    ///   UpSampling(x, scale=2, sample_type=&#39;nearest&#39;) = [[[[1. 1. 1. 1. 1. 1.]
    ///                                                      [1. 1. 1. 1. 1. 1.]
    ///                                                      [1. 1. 1. 1. 1. 1.]
    ///                                                      [1. 1. 1. 1. 1. 1.]
    ///                                                      [1. 1. 1. 1. 1. 1.]
    ///                                                      [1. 1. 1. 1. 1. 1.]]]]
    /// 
    /// **Bilinear Upsampling**
    /// 
    /// Uses `deconvolution` algorithm under the hood. You need provide both input data and the kernel.
    /// 
    /// Input data is expected to be NCHW.
    /// 
    /// `num_filter` is expected to be same as the number of channels.
    /// 
    /// Example::
    /// 
    ///   x = [[[[1. 1. 1.]
    ///          [1. 1. 1.]
    ///          [1. 1. 1.]]]]
    /// 
    ///   w = [[[[1. 1. 1. 1.]
    ///          [1. 1. 1. 1.]
    ///          [1. 1. 1. 1.]
    ///          [1. 1. 1. 1.]]]]
    ///   
    ///   UpSampling(x, w, scale=2, sample_type=&#39;bilinear&#39;, num_filter=1) = [[[[1. 2. 2. 2. 2. 1.]
    ///                                                                        [2. 4. 4. 4. 4. 2.]
    ///                                                                        [2. 4. 4. 4. 4. 2.]
    ///                                                                        [2. 4. 4. 4. 4. 2.]
    ///                                                                        [2. 4. 4. 4. 4. 2.]
    ///                                                                        [1. 2. 2. 2. 2. 1.]]]]
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\nn\upsampling.cc:L173</summary>
    /// <param name="data">Array of tensors to upsample. For bilinear upsampling, there should be 2 inputs - 1 data and 1 weight.</param>
    /// <param name="scale">Up sampling scale</param>
    /// <param name="sampleType">upsampling method</param>
    /// <param name="numArgs">Number of inputs to be upsampled. For nearest neighbor upsampling, this can be 1-N; the size of output will be(scale*h_0,scale*w_0) and all other inputs will be upsampled to thesame size. For bilinear upsampling this must be 2; 1 input and 1 weight.</param>
    /// <param name="numFilter">Input filter. Only used by bilinear sample_type.Since bilinear upsampling uses deconvolution, num_filters is set to the number of channels.</param>
    /// <param name="multiInputMode">How to handle multiple input. concat means concatenate upsampled images along the channel dimension. sum means add all images together, only available for nearest neighbor upsampling.</param>
    /// <param name="workspace">Tmp workspace for deconvolution (MB)</param>
    static member UpSampling([<ParamArray>] data : NDArray[], 
                             scale : int, 
                             sampleType : SampleType, 
                             [<Optional; DefaultParameterValue(0)>] numFilter : int, 
                             [<Optional>] multiInputMode : MultiInputMode, 
                             [<Optional; DefaultParameterValue(512L)>] workspace : int64) =
        let creator = AtomicSymbolCreator.FromName "UpSampling"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 (data |> Array.map (fun x -> x.UnsafeHandle))
                                                 [|"scale"; "sample_type"; "num_args"; "num_filter"; "multi_input_mode"; "workspace"|]
                                                 [|string scale; string sampleType; string data.Length; string numFilter; (if isNull (multiInputMode :> obj) then "concat" else string multiInputMode); string workspace|]
        (new NDArray(outputs.[0]))
    /// <summary>Upsamples the given input data.
    /// 
    /// Two algorithms (``sample_type``) are available for upsampling:
    /// 
    /// - Nearest Neighbor
    /// - Bilinear
    /// 
    /// **Nearest Neighbor Upsampling**
    /// 
    /// Input data is expected to be NCHW.
    /// 
    /// Example::
    /// 
    ///   x = [[[[1. 1. 1.]
    ///          [1. 1. 1.]
    ///          [1. 1. 1.]]]]
    /// 
    ///   UpSampling(x, scale=2, sample_type=&#39;nearest&#39;) = [[[[1. 1. 1. 1. 1. 1.]
    ///                                                      [1. 1. 1. 1. 1. 1.]
    ///                                                      [1. 1. 1. 1. 1. 1.]
    ///                                                      [1. 1. 1. 1. 1. 1.]
    ///                                                      [1. 1. 1. 1. 1. 1.]
    ///                                                      [1. 1. 1. 1. 1. 1.]]]]
    /// 
    /// **Bilinear Upsampling**
    /// 
    /// Uses `deconvolution` algorithm under the hood. You need provide both input data and the kernel.
    /// 
    /// Input data is expected to be NCHW.
    /// 
    /// `num_filter` is expected to be same as the number of channels.
    /// 
    /// Example::
    /// 
    ///   x = [[[[1. 1. 1.]
    ///          [1. 1. 1.]
    ///          [1. 1. 1.]]]]
    /// 
    ///   w = [[[[1. 1. 1. 1.]
    ///          [1. 1. 1. 1.]
    ///          [1. 1. 1. 1.]
    ///          [1. 1. 1. 1.]]]]
    ///   
    ///   UpSampling(x, w, scale=2, sample_type=&#39;bilinear&#39;, num_filter=1) = [[[[1. 2. 2. 2. 2. 1.]
    ///                                                                        [2. 4. 4. 4. 4. 2.]
    ///                                                                        [2. 4. 4. 4. 4. 2.]
    ///                                                                        [2. 4. 4. 4. 4. 2.]
    ///                                                                        [2. 4. 4. 4. 4. 2.]
    ///                                                                        [1. 2. 2. 2. 2. 1.]]]]
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\nn\upsampling.cc:L173</summary>
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="data">Array of tensors to upsample. For bilinear upsampling, there should be 2 inputs - 1 data and 1 weight.</param>
    /// <param name="scale">Up sampling scale</param>
    /// <param name="sampleType">upsampling method</param>
    /// <param name="numArgs">Number of inputs to be upsampled. For nearest neighbor upsampling, this can be 1-N; the size of output will be(scale*h_0,scale*w_0) and all other inputs will be upsampled to thesame size. For bilinear upsampling this must be 2; 1 input and 1 weight.</param>
    /// <param name="numFilter">Input filter. Only used by bilinear sample_type.Since bilinear upsampling uses deconvolution, num_filters is set to the number of channels.</param>
    /// <param name="multiInputMode">How to handle multiple input. concat means concatenate upsampled images along the channel dimension. sum means add all images together, only available for nearest neighbor upsampling.</param>
    /// <param name="workspace">Tmp workspace for deconvolution (MB)</param>
    static member UpSampling(outputArray : NDArray seq, 
                             [<ParamArray>] data : NDArray[], 
                             scale : int, 
                             sampleType : SampleType, 
                             [<Optional; DefaultParameterValue(0)>] numFilter : int, 
                             [<Optional>] multiInputMode : MultiInputMode, 
                             [<Optional; DefaultParameterValue(512L)>] workspace : int64) =
        let creator = AtomicSymbolCreator.FromName "UpSampling"
        let names = [|"scale"; "sample_type"; "num_args"; "num_filter"; "multi_input_mode"; "workspace"|]
        let vals = [|string scale; string sampleType; string data.Length; string numFilter; (if isNull (multiInputMode :> obj) then "concat" else string multiInputMode); string workspace|]
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     (data |> Array.map (fun x -> x.UnsafeHandle))
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <summary>Upsamples the given input data.
    /// 
    /// Two algorithms (``sample_type``) are available for upsampling:
    /// 
    /// - Nearest Neighbor
    /// - Bilinear
    /// 
    /// **Nearest Neighbor Upsampling**
    /// 
    /// Input data is expected to be NCHW.
    /// 
    /// Example::
    /// 
    ///   x = [[[[1. 1. 1.]
    ///          [1. 1. 1.]
    ///          [1. 1. 1.]]]]
    /// 
    ///   UpSampling(x, scale=2, sample_type=&#39;nearest&#39;) = [[[[1. 1. 1. 1. 1. 1.]
    ///                                                      [1. 1. 1. 1. 1. 1.]
    ///                                                      [1. 1. 1. 1. 1. 1.]
    ///                                                      [1. 1. 1. 1. 1. 1.]
    ///                                                      [1. 1. 1. 1. 1. 1.]
    ///                                                      [1. 1. 1. 1. 1. 1.]]]]
    /// 
    /// **Bilinear Upsampling**
    /// 
    /// Uses `deconvolution` algorithm under the hood. You need provide both input data and the kernel.
    /// 
    /// Input data is expected to be NCHW.
    /// 
    /// `num_filter` is expected to be same as the number of channels.
    /// 
    /// Example::
    /// 
    ///   x = [[[[1. 1. 1.]
    ///          [1. 1. 1.]
    ///          [1. 1. 1.]]]]
    /// 
    ///   w = [[[[1. 1. 1. 1.]
    ///          [1. 1. 1. 1.]
    ///          [1. 1. 1. 1.]
    ///          [1. 1. 1. 1.]]]]
    ///   
    ///   UpSampling(x, w, scale=2, sample_type=&#39;bilinear&#39;, num_filter=1) = [[[[1. 2. 2. 2. 2. 1.]
    ///                                                                        [2. 4. 4. 4. 4. 2.]
    ///                                                                        [2. 4. 4. 4. 4. 2.]
    ///                                                                        [2. 4. 4. 4. 4. 2.]
    ///                                                                        [2. 4. 4. 4. 4. 2.]
    ///                                                                        [1. 2. 2. 2. 2. 1.]]]]
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\nn\upsampling.cc:L173</summary>
    /// <param name="data">Array of tensors to upsample. For bilinear upsampling, there should be 2 inputs - 1 data and 1 weight.</param>
    /// <param name="scale">Up sampling scale</param>
    /// <param name="sampleType">upsampling method</param>
    /// <param name="numFilter">Input filter. Only used by bilinear sample_type.Since bilinear upsampling uses deconvolution, num_filters is set to the number of channels.</param>
    /// <param name="multiInputMode">How to handle multiple input. concat means concatenate upsampled images along the channel dimension. sum means add all images together, only available for nearest neighbor upsampling.</param>
    /// <param name="workspace">Tmp workspace for deconvolution (MB)</param>
    static member UpSampling(data : Symbol seq, scale : int, sampleType : SampleType, [<Optional>] ?numFilter : int, [<Optional>] ?multiInputMode : MultiInputMode, [<Optional>] ?workspace : int64) =
        UpSampling(data, scale, sampleType, ?numFilter = numFilter, ?multiInputMode = multiInputMode, ?workspace = workspace)
    /// <summary>Upsamples the given input data.
    /// 
    /// Two algorithms (``sample_type``) are available for upsampling:
    /// 
    /// - Nearest Neighbor
    /// - Bilinear
    /// 
    /// **Nearest Neighbor Upsampling**
    /// 
    /// Input data is expected to be NCHW.
    /// 
    /// Example::
    /// 
    ///   x = [[[[1. 1. 1.]
    ///          [1. 1. 1.]
    ///          [1. 1. 1.]]]]
    /// 
    ///   UpSampling(x, scale=2, sample_type=&#39;nearest&#39;) = [[[[1. 1. 1. 1. 1. 1.]
    ///                                                      [1. 1. 1. 1. 1. 1.]
    ///                                                      [1. 1. 1. 1. 1. 1.]
    ///                                                      [1. 1. 1. 1. 1. 1.]
    ///                                                      [1. 1. 1. 1. 1. 1.]
    ///                                                      [1. 1. 1. 1. 1. 1.]]]]
    /// 
    /// **Bilinear Upsampling**
    /// 
    /// Uses `deconvolution` algorithm under the hood. You need provide both input data and the kernel.
    /// 
    /// Input data is expected to be NCHW.
    /// 
    /// `num_filter` is expected to be same as the number of channels.
    /// 
    /// Example::
    /// 
    ///   x = [[[[1. 1. 1.]
    ///          [1. 1. 1.]
    ///          [1. 1. 1.]]]]
    /// 
    ///   w = [[[[1. 1. 1. 1.]
    ///          [1. 1. 1. 1.]
    ///          [1. 1. 1. 1.]
    ///          [1. 1. 1. 1.]]]]
    ///   
    ///   UpSampling(x, w, scale=2, sample_type=&#39;bilinear&#39;, num_filter=1) = [[[[1. 2. 2. 2. 2. 1.]
    ///                                                                        [2. 4. 4. 4. 4. 2.]
    ///                                                                        [2. 4. 4. 4. 4. 2.]
    ///                                                                        [2. 4. 4. 4. 4. 2.]
    ///                                                                        [2. 4. 4. 4. 4. 2.]
    ///                                                                        [1. 2. 2. 2. 2. 1.]]]]
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\nn\upsampling.cc:L173</summary>
    /// <param name="scale">Up sampling scale</param>
    /// <param name="sampleType">upsampling method</param>
    /// <param name="data">Array of tensors to upsample. For bilinear upsampling, there should be 2 inputs - 1 data and 1 weight.</param>
    /// <param name="numFilter">Input filter. Only used by bilinear sample_type.Since bilinear upsampling uses deconvolution, num_filters is set to the number of channels.</param>
    /// <param name="multiInputMode">How to handle multiple input. concat means concatenate upsampled images along the channel dimension. sum means add all images together, only available for nearest neighbor upsampling.</param>
    /// <param name="workspace">Tmp workspace for deconvolution (MB)</param>
    static member UpSampling(scale : int, sampleType : SampleType, [<Optional>] ?data : Symbol seq, [<Optional>] ?numFilter : int, [<Optional>] ?multiInputMode : MultiInputMode, [<Optional>] ?workspace : int64) =
        UpSampling(scale, sampleType, ?data = data, ?numFilter = numFilter, ?multiInputMode = multiInputMode, ?workspace = workspace)


    /// <summary>
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\numpy\linalg\np_gesvd.cc:L93</summary>
    /// <param name="A">Input matrices to be factorized</param>
    static member NpiSvd(A : NDArray) =
        let creator = AtomicSymbolCreator.FromName "_npi_svd"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg A)) then A.UnsafeHandle|]
                                                 Array.empty
                                                 Array.empty
        outputs |> Array.map (fun h -> new NDArray(h))
    /// <summary>
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\numpy\linalg\np_gesvd.cc:L93</summary>
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="A">Input matrices to be factorized</param>
    static member NpiSvd(outputArray : NDArray seq, A : NDArray) =
        let creator = AtomicSymbolCreator.FromName "_npi_svd"
        let names = Array.empty
        let vals = Array.empty
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg A)) then A.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <summary>
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\numpy\linalg\np_gesvd.cc:L93</summary>
    /// <param name="A">Input matrices to be factorized</param>
    static member NpiSvd([<Optional>] ?A : Symbol) =
        NpiSvd(?A = A)


    /// <summary>
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\numpy\linalg\np_potrf.cc:L47</summary>
    /// <param name="A">Tensor of input matrices to be decomposed</param>
    static member NpiCholesky(A : NDArray) =
        let creator = AtomicSymbolCreator.FromName "_npi_cholesky"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg A)) then A.UnsafeHandle|]
                                                 Array.empty
                                                 Array.empty
        outputs |> Array.map (fun h -> new NDArray(h))
    /// <summary>
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\numpy\linalg\np_potrf.cc:L47</summary>
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="A">Tensor of input matrices to be decomposed</param>
    static member NpiCholesky(outputArray : NDArray seq, A : NDArray) =
        let creator = AtomicSymbolCreator.FromName "_npi_cholesky"
        let names = Array.empty
        let vals = Array.empty
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg A)) then A.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <summary>
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\numpy\linalg\np_potrf.cc:L47</summary>
    /// <param name="A">Tensor of input matrices to be decomposed</param>
    static member NpiCholesky([<Optional>] ?A : Symbol) =
        NpiCholesky(?A = A)

    /// <summary>Scalar version of boolean assign
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\numpy\np_boolean_mask_assign.cc:L222</summary>
    /// <param name="data">input</param>
    /// <param name="mask">mask</param>
    /// <param name="value">value to be assigned to masked positions</param>
    static member NpiBooleanMaskAssignScalar(data : NDArray, mask : NDArray, value : float) =
        let creator = AtomicSymbolCreator.FromName "_npi_boolean_mask_assign_scalar"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg mask)) then mask.UnsafeHandle|]
                                                 [|"value"|]
                                                 [|string value|]
        outputs |> Array.map (fun h -> new NDArray(h))
    /// <summary>Scalar version of boolean assign
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\numpy\np_boolean_mask_assign.cc:L222</summary>
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="data">input</param>
    /// <param name="mask">mask</param>
    /// <param name="value">value to be assigned to masked positions</param>
    static member NpiBooleanMaskAssignScalar(outputArray : NDArray seq, data : NDArray, mask : NDArray, value : float) =
        let creator = AtomicSymbolCreator.FromName "_npi_boolean_mask_assign_scalar"
        let names = [|"value"|]
        let vals = [|string value|]
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg mask)) then mask.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <summary>Scalar version of boolean assign
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\numpy\np_boolean_mask_assign.cc:L222</summary>
    /// <param name="data">input</param>
    /// <param name="mask">mask</param>
    /// <param name="value">value to be assigned to masked positions</param>
    static member NpiBooleanMaskAssignScalar(data : Symbol, mask : Symbol, value : float) =
        NpiBooleanMaskAssignScalar(data, mask, value)
    /// <summary>Scalar version of boolean assign
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\numpy\np_boolean_mask_assign.cc:L222</summary>
    /// <param name="value">value to be assigned to masked positions</param>
    /// <param name="data">input</param>
    /// <param name="mask">mask</param>
    static member NpiBooleanMaskAssignScalar(value : float, [<Optional>] ?data : Symbol, [<Optional>] ?mask : Symbol) =
        NpiBooleanMaskAssignScalar(value, ?data = data, ?mask = mask)

    /// <summary>Tensor version of boolean assign
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\numpy\np_boolean_mask_assign.cc:L246</summary>
    /// <param name="data">input</param>
    /// <param name="mask">mask</param>
    /// <param name="value">assignment</param>
    static member NpiBooleanMaskAssignTensor(data : NDArray, mask : NDArray, value : NDArray) =
        let creator = AtomicSymbolCreator.FromName "_npi_boolean_mask_assign_tensor"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg mask)) then mask.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg value)) then value.UnsafeHandle|]
                                                 Array.empty
                                                 Array.empty
        outputs |> Array.map (fun h -> new NDArray(h))
    /// <summary>Tensor version of boolean assign
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\numpy\np_boolean_mask_assign.cc:L246</summary>
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="data">input</param>
    /// <param name="mask">mask</param>
    /// <param name="value">assignment</param>
    static member NpiBooleanMaskAssignTensor(outputArray : NDArray seq, data : NDArray, mask : NDArray, value : NDArray) =
        let creator = AtomicSymbolCreator.FromName "_npi_boolean_mask_assign_tensor"
        let names = Array.empty
        let vals = Array.empty
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg mask)) then mask.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg value)) then value.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <summary>Tensor version of boolean assign
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\numpy\np_boolean_mask_assign.cc:L246</summary>
    /// <param name="data">input</param>
    /// <param name="mask">mask</param>
    /// <param name="value">assignment</param>
    static member NpiBooleanMaskAssignTensor([<Optional>] ?data : Symbol, [<Optional>] ?mask : Symbol, [<Optional>] ?value : Symbol) =
        NpiBooleanMaskAssignTensor(?data = data, ?mask = mask, ?value = value)

    /// <param name="data">The input</param>
    /// <param name="axis">The axis along which to perform the reduction. Negative values means indexing from right to left. ``Requires axis to be set as int, because global reduction is not supported yet.``</param>
    /// <param name="keepdims">If this is set to `True`, the reduced axis is left in the result as dimension with size one.</param>
    static member NpiArgmax(data : NDArray, [<Optional>] ?axis : int, [<Optional>] ?keepdims : bool) =
        let creator = AtomicSymbolCreator.FromName "_npi_argmax"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle|]
                                                 [|"axis"; "keepdims"|]
                                                 [|(match axis with None -> "None" | Some axis -> string axis); (match keepdims with None -> "false" | Some keepdims -> string keepdims)|]
        (new NDArray(outputs.[0]))
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="data">The input</param>
    /// <param name="axis">The axis along which to perform the reduction. Negative values means indexing from right to left. ``Requires axis to be set as int, because global reduction is not supported yet.``</param>
    /// <param name="keepdims">If this is set to `True`, the reduced axis is left in the result as dimension with size one.</param>
    static member NpiArgmax(outputArray : NDArray seq, data : NDArray, [<Optional>] ?axis : int, [<Optional>] ?keepdims : bool) =
        let creator = AtomicSymbolCreator.FromName "_npi_argmax"
        let names = [|"axis"; "keepdims"|]
        let vals = [|(match axis with None -> "None" | Some axis -> string axis); (match keepdims with None -> "false" | Some keepdims -> string keepdims)|]
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <param name="data">The input</param>
    /// <param name="axis">The axis along which to perform the reduction. Negative values means indexing from right to left. ``Requires axis to be set as int, because global reduction is not supported yet.``</param>
    /// <param name="keepdims">If this is set to `True`, the reduced axis is left in the result as dimension with size one.</param>
    static member NpiArgmax([<Optional>] ?data : Symbol, [<Optional>] ?axis : int, [<Optional>] ?keepdims : bool) =
        NpiArgmax(?data = data, ?axis = axis, ?keepdims = keepdims)

    /// <param name="data">The input</param>
    /// <param name="axis">The axis along which to perform the reduction. Negative values means indexing from right to left. ``Requires axis to be set as int, because global reduction is not supported yet.``</param>
    /// <param name="keepdims">If this is set to `True`, the reduced axis is left in the result as dimension with size one.</param>
    static member NpiArgmin(data : NDArray, [<Optional>] ?axis : int, [<Optional>] ?keepdims : bool) =
        let creator = AtomicSymbolCreator.FromName "_npi_argmin"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle|]
                                                 [|"axis"; "keepdims"|]
                                                 [|(match axis with None -> "None" | Some axis -> string axis); (match keepdims with None -> "false" | Some keepdims -> string keepdims)|]
        outputs |> Array.map (fun h -> new NDArray(h))
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="data">The input</param>
    /// <param name="axis">The axis along which to perform the reduction. Negative values means indexing from right to left. ``Requires axis to be set as int, because global reduction is not supported yet.``</param>
    /// <param name="keepdims">If this is set to `True`, the reduced axis is left in the result as dimension with size one.</param>
    static member NpiArgmin(outputArray : NDArray seq, data : NDArray, [<Optional>] ?axis : int, [<Optional>] ?keepdims : bool) =
        let creator = AtomicSymbolCreator.FromName "_npi_argmin"
        let names = [|"axis"; "keepdims"|]
        let vals = [|(match axis with None -> "None" | Some axis -> string axis); (match keepdims with None -> "false" | Some keepdims -> string keepdims)|]
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <param name="data">The input</param>
    /// <param name="axis">The axis along which to perform the reduction. Negative values means indexing from right to left. ``Requires axis to be set as int, because global reduction is not supported yet.``</param>
    /// <param name="keepdims">If this is set to `True`, the reduced axis is left in the result as dimension with size one.</param>
    static member NpiArgmin([<Optional>] ?data : Symbol, [<Optional>] ?axis : int, [<Optional>] ?keepdims : bool) =
        NpiArgmin(?data = data, ?axis = axis, ?keepdims = keepdims)

    /// <summary>
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\numpy\np_broadcast_reduce_op_value.cc:L124</summary>
    /// <param name="a">The input</param>
    /// <param name="axis">Axis or axes along which a sum is performed. The default, axis=None, will sum all of the elements of the input array. If axis is negative it counts from the last to the first axis.</param>
    /// <param name="dtype">The type of the returned array and of the accumulator in which the elements are summed. The dtype of a is used by default unless a has an integer dtype of less precision than the default platform integer. In that case, if a is signed then the platform integer is used while if a is unsigned then an unsigned integer of the same precision as the platform integer is used.</param>
    /// <param name="keepdims">If this is set to `True`, the reduced axes are left in the result as dimension with size one.</param>
    /// <param name="initial">Starting value for the sum.</param>
    static member NpSum(a : NDArray, 
                        [<Optional>] ?axis : int seq, 
                        [<Optional>] ?dtype : DataType, 
                        [<Optional>] ?keepdims : bool, 
                        [<Optional>] ?initial : float) =
        let creator = AtomicSymbolCreator.FromName "_np_sum"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg a)) then a.UnsafeHandle|]
                                                 [|"axis"; "dtype"; "keepdims"; "initial"|]
                                                 [|(match axis with None -> "None" | Some axis -> (axis |> Seq.map string |> String.concat ", " |> sprintf "[%s]")); (match dtype with None -> "None" | Some dtype -> string dtype); (match keepdims with None -> "false" | Some keepdims -> string keepdims); (match initial with None -> "None" | Some initial -> string initial)|]
        (new NDArray(outputs.[0]))
    /// <summary>
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\numpy\np_broadcast_reduce_op_value.cc:L124</summary>
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="a">The input</param>
    /// <param name="axis">Axis or axes along which a sum is performed. The default, axis=None, will sum all of the elements of the input array. If axis is negative it counts from the last to the first axis.</param>
    /// <param name="dtype">The type of the returned array and of the accumulator in which the elements are summed. The dtype of a is used by default unless a has an integer dtype of less precision than the default platform integer. In that case, if a is signed then the platform integer is used while if a is unsigned then an unsigned integer of the same precision as the platform integer is used.</param>
    /// <param name="keepdims">If this is set to `True`, the reduced axes are left in the result as dimension with size one.</param>
    /// <param name="initial">Starting value for the sum.</param>
    static member NpSum(outputArray : NDArray seq, 
                        a : NDArray, 
                        [<Optional>] ?axis : int seq, 
                        [<Optional>] ?dtype : DataType, 
                        [<Optional>] ?keepdims : bool, 
                        [<Optional>] ?initial : float) =
        let creator = AtomicSymbolCreator.FromName "_np_sum"
        let names = [|"axis"; "dtype"; "keepdims"; "initial"|]
        let vals = [|(match axis with None -> "None" | Some axis -> (axis |> Seq.map string |> String.concat ", " |> sprintf "[%s]")); (match dtype with None -> "None" | Some dtype -> string dtype); (match keepdims with None -> "false" | Some keepdims -> string keepdims); (match initial with None -> "None" | Some initial -> string initial)|]
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg a)) then a.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <summary>
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\numpy\np_broadcast_reduce_op_value.cc:L124</summary>
    /// <param name="a">The input</param>
    /// <param name="axis">Axis or axes along which a sum is performed. The default, axis=None, will sum all of the elements of the input array. If axis is negative it counts from the last to the first axis.</param>
    /// <param name="dtype">The type of the returned array and of the accumulator in which the elements are summed. The dtype of a is used by default unless a has an integer dtype of less precision than the default platform integer. In that case, if a is signed then the platform integer is used while if a is unsigned then an unsigned integer of the same precision as the platform integer is used.</param>
    /// <param name="keepdims">If this is set to `True`, the reduced axes are left in the result as dimension with size one.</param>
    /// <param name="initial">Starting value for the sum.</param>
    static member NpSum([<Optional>] ?a : Symbol, [<Optional>] ?axis : int seq, [<Optional>] ?dtype : DataType, [<Optional>] ?keepdims : bool, [<Optional>] ?initial : float) =
        NpSum(?a = a, ?axis = axis, ?dtype = dtype, ?keepdims = keepdims, ?initial = initial)


    /// <summary>
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\numpy\np_broadcast_reduce_op_value.cc:L163</summary>
    /// <param name="a">The input</param>
    /// <param name="axis">Axis or axes along which a sum is performed. The default, axis=None, will sum all of the elements of the input array. If axis is negative it counts from the last to the first axis.</param>
    /// <param name="keepdims">If this is set to `True`, the reduced axes are left in the result as dimension with size one.</param>
    /// <param name="initial">Starting value for the sum.</param>
    static member NpMax(a : NDArray, [<Optional>] ?axis : int seq, [<Optional>] ?keepdims : bool, [<Optional>] ?initial : float) =
        let creator = AtomicSymbolCreator.FromName "_np_max"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg a)) then a.UnsafeHandle|]
                                                 [|"axis"; "keepdims"; "initial"|]
                                                 [|(match axis with None -> "None" | Some axis -> (axis |> Seq.map string |> String.concat ", " |> sprintf "[%s]")); (match keepdims with None -> "false" | Some keepdims -> string keepdims); (match initial with None -> "None" | Some initial -> string initial)|]
        (new NDArray(outputs.[0]))
    /// <summary>
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\numpy\np_broadcast_reduce_op_value.cc:L163</summary>
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="a">The input</param>
    /// <param name="axis">Axis or axes along which a sum is performed. The default, axis=None, will sum all of the elements of the input array. If axis is negative it counts from the last to the first axis.</param>
    /// <param name="keepdims">If this is set to `True`, the reduced axes are left in the result as dimension with size one.</param>
    /// <param name="initial">Starting value for the sum.</param>
    static member NpMax(outputArray : NDArray seq, a : NDArray, [<Optional>] ?axis : int seq, [<Optional>] ?keepdims : bool, [<Optional>] ?initial : float) =
        let creator = AtomicSymbolCreator.FromName "_np_max"
        let names = [|"axis"; "keepdims"; "initial"|]
        let vals = [|(match axis with None -> "None" | Some axis -> (axis |> Seq.map string |> String.concat ", " |> sprintf "[%s]")); (match keepdims with None -> "false" | Some keepdims -> string keepdims); (match initial with None -> "None" | Some initial -> string initial)|]
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg a)) then a.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <summary>
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\numpy\np_broadcast_reduce_op_value.cc:L163</summary>
    /// <param name="a">The input</param>
    /// <param name="axis">Axis or axes along which a sum is performed. The default, axis=None, will sum all of the elements of the input array. If axis is negative it counts from the last to the first axis.</param>
    /// <param name="keepdims">If this is set to `True`, the reduced axes are left in the result as dimension with size one.</param>
    /// <param name="initial">Starting value for the sum.</param>
    static member NpMax([<Optional>] ?a : Symbol, [<Optional>] ?axis : int seq, [<Optional>] ?keepdims : bool, [<Optional>] ?initial : float) =
        NpMax(?a = a, ?axis = axis, ?keepdims = keepdims, ?initial = initial)


    /// <summary>
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\numpy\np_broadcast_reduce_op_value.cc:L191</summary>
    /// <param name="a">The input</param>
    /// <param name="axis">Axis or axes along which a sum is performed. The default, axis=None, will sum all of the elements of the input array. If axis is negative it counts from the last to the first axis.</param>
    /// <param name="keepdims">If this is set to `True`, the reduced axes are left in the result as dimension with size one.</param>
    /// <param name="initial">Starting value for the sum.</param>
    static member NpMin(a : NDArray, [<Optional>] ?axis : int seq, [<Optional>] ?keepdims : bool, [<Optional>] ?initial : float) =
        let creator = AtomicSymbolCreator.FromName "_np_min"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg a)) then a.UnsafeHandle|]
                                                 [|"axis"; "keepdims"; "initial"|]
                                                 [|(match axis with None -> "None" | Some axis -> (axis |> Seq.map string |> String.concat ", " |> sprintf "[%s]")); (match keepdims with None -> "false" | Some keepdims -> string keepdims); (match initial with None -> "None" | Some initial -> string initial)|]
        (new NDArray(outputs.[0]))
    /// <summary>
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\numpy\np_broadcast_reduce_op_value.cc:L191</summary>
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="a">The input</param>
    /// <param name="axis">Axis or axes along which a sum is performed. The default, axis=None, will sum all of the elements of the input array. If axis is negative it counts from the last to the first axis.</param>
    /// <param name="keepdims">If this is set to `True`, the reduced axes are left in the result as dimension with size one.</param>
    /// <param name="initial">Starting value for the sum.</param>
    static member NpMin(outputArray : NDArray seq, a : NDArray, [<Optional>] ?axis : int seq, [<Optional>] ?keepdims : bool, [<Optional>] ?initial : float) =
        let creator = AtomicSymbolCreator.FromName "_np_min"
        let names = [|"axis"; "keepdims"; "initial"|]
        let vals = [|(match axis with None -> "None" | Some axis -> (axis |> Seq.map string |> String.concat ", " |> sprintf "[%s]")); (match keepdims with None -> "false" | Some keepdims -> string keepdims); (match initial with None -> "None" | Some initial -> string initial)|]
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg a)) then a.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <summary>
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\numpy\np_broadcast_reduce_op_value.cc:L191</summary>
    /// <param name="a">The input</param>
    /// <param name="axis">Axis or axes along which a sum is performed. The default, axis=None, will sum all of the elements of the input array. If axis is negative it counts from the last to the first axis.</param>
    /// <param name="keepdims">If this is set to `True`, the reduced axes are left in the result as dimension with size one.</param>
    /// <param name="initial">Starting value for the sum.</param>
    static member NpMin([<Optional>] ?a : Symbol, [<Optional>] ?axis : int seq, [<Optional>] ?keepdims : bool, [<Optional>] ?initial : float) =
        NpMin(?a = a, ?axis = axis, ?keepdims = keepdims, ?initial = initial)


    /// <param name="a">The input</param>
    /// <param name="axis">Axis or axes along which a sum is performed. The default, axis=None, will sum all of the elements of the input array. If axis is negative it counts from the last to the first axis.</param>
    /// <param name="dtype">The type of the returned array and of the accumulator in which the elements are summed. The dtype of a is used by default unless a has an integer dtype of less precision than the default platform integer. In that case, if a is signed then the platform integer is used while if a is unsigned then an unsigned integer of the same precision as the platform integer is used.</param>
    /// <param name="keepdims">If this is set to `True`, the reduced axes are left in the result as dimension with size one.</param>
    /// <param name="initial">Starting value for the sum.</param>
    static member NpProd(a : NDArray, 
                         [<Optional>] ?axis : int seq, 
                         [<Optional>] ?dtype : DataType, 
                         [<Optional>] ?keepdims : bool, 
                         [<Optional>] ?initial : float) =
        let creator = AtomicSymbolCreator.FromName "_np_prod"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg a)) then a.UnsafeHandle|]
                                                 [|"axis"; "dtype"; "keepdims"; "initial"|]
                                                 [|(match axis with None -> "None" | Some axis -> (axis |> Seq.map string |> String.concat ", " |> sprintf "[%s]")); (match dtype with None -> "None" | Some dtype -> string dtype); (match keepdims with None -> "false" | Some keepdims -> string keepdims); (match initial with None -> "None" | Some initial -> string initial)|]
        (new NDArray(outputs.[0]))
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="a">The input</param>
    /// <param name="axis">Axis or axes along which a sum is performed. The default, axis=None, will sum all of the elements of the input array. If axis is negative it counts from the last to the first axis.</param>
    /// <param name="dtype">The type of the returned array and of the accumulator in which the elements are summed. The dtype of a is used by default unless a has an integer dtype of less precision than the default platform integer. In that case, if a is signed then the platform integer is used while if a is unsigned then an unsigned integer of the same precision as the platform integer is used.</param>
    /// <param name="keepdims">If this is set to `True`, the reduced axes are left in the result as dimension with size one.</param>
    /// <param name="initial">Starting value for the sum.</param>
    static member NpProd(outputArray : NDArray seq, 
                         a : NDArray, 
                         [<Optional>] ?axis : int seq, 
                         [<Optional>] ?dtype : DataType, 
                         [<Optional>] ?keepdims : bool, 
                         [<Optional>] ?initial : float) =
        let creator = AtomicSymbolCreator.FromName "_np_prod"
        let names = [|"axis"; "dtype"; "keepdims"; "initial"|]
        let vals = [|(match axis with None -> "None" | Some axis -> (axis |> Seq.map string |> String.concat ", " |> sprintf "[%s]")); (match dtype with None -> "None" | Some dtype -> string dtype); (match keepdims with None -> "false" | Some keepdims -> string keepdims); (match initial with None -> "None" | Some initial -> string initial)|]
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg a)) then a.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <param name="a">The input</param>
    /// <param name="axis">Axis or axes along which a sum is performed. The default, axis=None, will sum all of the elements of the input array. If axis is negative it counts from the last to the first axis.</param>
    /// <param name="dtype">The type of the returned array and of the accumulator in which the elements are summed. The dtype of a is used by default unless a has an integer dtype of less precision than the default platform integer. In that case, if a is signed then the platform integer is used while if a is unsigned then an unsigned integer of the same precision as the platform integer is used.</param>
    /// <param name="keepdims">If this is set to `True`, the reduced axes are left in the result as dimension with size one.</param>
    /// <param name="initial">Starting value for the sum.</param>
    static member NpProd([<Optional>] ?a : Symbol, [<Optional>] ?axis : int seq, [<Optional>] ?dtype : DataType, [<Optional>] ?keepdims : bool, [<Optional>] ?initial : float) =
        NpProd(?a = a, ?axis = axis, ?dtype = dtype, ?keepdims = keepdims, ?initial = initial)


    /// <param name="a">The input</param>
    /// <param name="axis">Axis or axes along which a sum is performed. The default, axis=None, will sum all of the elements of the input array. If axis is negative it counts from the last to the first axis.</param>
    /// <param name="dtype">The type of the returned array and of the accumulator in which the elements are summed. The dtype of a is used by default unless a has an integer dtype of less precision than the default platform integer. In that case, if a is signed then the platform integer is used while if a is unsigned then an unsigned integer of the same precision as the platform integer is used.</param>
    /// <param name="keepdims">If this is set to `True`, the reduced axes are left in the result as dimension with size one.</param>
    /// <param name="initial">Starting value for the sum.</param>
    static member NpiMean(a : NDArray, 
                          [<Optional>] ?axis : int seq, 
                          [<Optional>] ?dtype : DataType, 
                          [<Optional>] ?keepdims : bool, 
                          [<Optional>] ?initial : float) =
        let creator = AtomicSymbolCreator.FromName "_npi_mean"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg a)) then a.UnsafeHandle|]
                                                 [|"axis"; "dtype"; "keepdims"; "initial"|]
                                                 [|(match axis with None -> "None" | Some axis -> (axis |> Seq.map string |> String.concat ", " |> sprintf "[%s]")); (match dtype with None -> "None" | Some dtype -> string dtype); (match keepdims with None -> "false" | Some keepdims -> string keepdims); (match initial with None -> "None" | Some initial -> string initial)|]
        (new NDArray(outputs.[0]))
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="a">The input</param>
    /// <param name="axis">Axis or axes along which a sum is performed. The default, axis=None, will sum all of the elements of the input array. If axis is negative it counts from the last to the first axis.</param>
    /// <param name="dtype">The type of the returned array and of the accumulator in which the elements are summed. The dtype of a is used by default unless a has an integer dtype of less precision than the default platform integer. In that case, if a is signed then the platform integer is used while if a is unsigned then an unsigned integer of the same precision as the platform integer is used.</param>
    /// <param name="keepdims">If this is set to `True`, the reduced axes are left in the result as dimension with size one.</param>
    /// <param name="initial">Starting value for the sum.</param>
    static member NpiMean(outputArray : NDArray seq, 
                          a : NDArray, 
                          [<Optional>] ?axis : int seq, 
                          [<Optional>] ?dtype : DataType, 
                          [<Optional>] ?keepdims : bool, 
                          [<Optional>] ?initial : float) =
        let creator = AtomicSymbolCreator.FromName "_npi_mean"
        let names = [|"axis"; "dtype"; "keepdims"; "initial"|]
        let vals = [|(match axis with None -> "None" | Some axis -> (axis |> Seq.map string |> String.concat ", " |> sprintf "[%s]")); (match dtype with None -> "None" | Some dtype -> string dtype); (match keepdims with None -> "false" | Some keepdims -> string keepdims); (match initial with None -> "None" | Some initial -> string initial)|]
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg a)) then a.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <param name="a">The input</param>
    /// <param name="axis">Axis or axes along which a sum is performed. The default, axis=None, will sum all of the elements of the input array. If axis is negative it counts from the last to the first axis.</param>
    /// <param name="dtype">The type of the returned array and of the accumulator in which the elements are summed. The dtype of a is used by default unless a has an integer dtype of less precision than the default platform integer. In that case, if a is signed then the platform integer is used while if a is unsigned then an unsigned integer of the same precision as the platform integer is used.</param>
    /// <param name="keepdims">If this is set to `True`, the reduced axes are left in the result as dimension with size one.</param>
    /// <param name="initial">Starting value for the sum.</param>
    static member NpiMean([<Optional>] ?a : Symbol, [<Optional>] ?axis : int seq, [<Optional>] ?dtype : DataType, [<Optional>] ?keepdims : bool, [<Optional>] ?initial : float) =
        NpiMean(?a = a, ?axis = axis, ?dtype = dtype, ?keepdims = keepdims, ?initial = initial)


    /// <param name="a">The input</param>
    /// <param name="axis">Axis or axes along which a sum is performed. The default, axis=None, will sum all of the elements of the input array. If axis is negative it counts from the last to the first axis.</param>
    /// <param name="dtype">The type of the returned array and of the accumulator in which the elements are summed. The dtype of a is used by default unless a has an integer dtype of less precision than the default platform integer. In that case, if a is signed then the platform integer is used while if a is unsigned then an unsigned integer of the same precision as the platform integer is used.</param>
    /// <param name="ddof">Starting value for the sum.</param>
    /// <param name="keepdims">If this is set to `True`, the reduced axes are left in the result as dimension with size one.</param>
    static member NpiStd(a : NDArray, 
                         [<Optional>] ?axis : int seq, 
                         [<Optional>] ?dtype : DataType, 
                         [<Optional>] ?ddof : int, 
                         [<Optional>] ?keepdims : bool) =
        let creator = AtomicSymbolCreator.FromName "_npi_std"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg a)) then a.UnsafeHandle|]
                                                 [|"axis"; "dtype"; "ddof"; "keepdims"|]
                                                 [|(match axis with None -> "None" | Some axis -> (axis |> Seq.map string |> String.concat ", " |> sprintf "[%s]")); (match dtype with None -> "None" | Some dtype -> string dtype); (match ddof with None -> "0" | Some ddof -> string ddof); (match keepdims with None -> "false" | Some keepdims -> string keepdims)|]
        (new NDArray(outputs.[0]))
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="a">The input</param>
    /// <param name="axis">Axis or axes along which a sum is performed. The default, axis=None, will sum all of the elements of the input array. If axis is negative it counts from the last to the first axis.</param>
    /// <param name="dtype">The type of the returned array and of the accumulator in which the elements are summed. The dtype of a is used by default unless a has an integer dtype of less precision than the default platform integer. In that case, if a is signed then the platform integer is used while if a is unsigned then an unsigned integer of the same precision as the platform integer is used.</param>
    /// <param name="ddof">Starting value for the sum.</param>
    /// <param name="keepdims">If this is set to `True`, the reduced axes are left in the result as dimension with size one.</param>
    static member NpiStd(outputArray : NDArray seq, 
                         a : NDArray, 
                         [<Optional>] ?axis : int seq, 
                         [<Optional>] ?dtype : DataType, 
                         [<Optional>] ?ddof : int, 
                         [<Optional>] ?keepdims : bool) =
        let creator = AtomicSymbolCreator.FromName "_npi_std"
        let names = [|"axis"; "dtype"; "ddof"; "keepdims"|]
        let vals = [|(match axis with None -> "None" | Some axis -> (axis |> Seq.map string |> String.concat ", " |> sprintf "[%s]")); (match dtype with None -> "None" | Some dtype -> string dtype); (match ddof with None -> "0" | Some ddof -> string ddof); (match keepdims with None -> "false" | Some keepdims -> string keepdims)|]
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg a)) then a.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <param name="a">The input</param>
    /// <param name="axis">Axis or axes along which a sum is performed. The default, axis=None, will sum all of the elements of the input array. If axis is negative it counts from the last to the first axis.</param>
    /// <param name="dtype">The type of the returned array and of the accumulator in which the elements are summed. The dtype of a is used by default unless a has an integer dtype of less precision than the default platform integer. In that case, if a is signed then the platform integer is used while if a is unsigned then an unsigned integer of the same precision as the platform integer is used.</param>
    /// <param name="ddof">Starting value for the sum.</param>
    /// <param name="keepdims">If this is set to `True`, the reduced axes are left in the result as dimension with size one.</param>
    static member NpiStd([<Optional>] ?a : Symbol, [<Optional>] ?axis : int seq, [<Optional>] ?dtype : DataType, [<Optional>] ?ddof : int, [<Optional>] ?keepdims : bool) =
        NpiStd(?a = a, ?axis = axis, ?dtype = dtype, ?ddof = ddof, ?keepdims = keepdims)

    /// <param name="a">The input</param>
    /// <param name="axis">Axis or axes along which a sum is performed. The default, axis=None, will sum all of the elements of the input array. If axis is negative it counts from the last to the first axis.</param>
    /// <param name="dtype">The type of the returned array and of the accumulator in which the elements are summed. The dtype of a is used by default unless a has an integer dtype of less precision than the default platform integer. In that case, if a is signed then the platform integer is used while if a is unsigned then an unsigned integer of the same precision as the platform integer is used.</param>
    /// <param name="ddof">Starting value for the sum.</param>
    /// <param name="keepdims">If this is set to `True`, the reduced axes are left in the result as dimension with size one.</param>
    static member NpiVar(a : NDArray, 
                         [<Optional>] ?axis : int seq, 
                         [<Optional>] ?dtype : DataType, 
                         [<Optional>] ?ddof : int, 
                         [<Optional>] ?keepdims : bool) =
        let creator = AtomicSymbolCreator.FromName "_npi_var"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg a)) then a.UnsafeHandle|]
                                                 [|"axis"; "dtype"; "ddof"; "keepdims"|]
                                                 [|(match axis with None -> "None" | Some axis -> (axis |> Seq.map string |> String.concat ", " |> sprintf "[%s]")); (match dtype with None -> "None" | Some dtype -> string dtype); (match ddof with None -> "0" | Some ddof -> string ddof); (match keepdims with None -> "false" | Some keepdims -> string keepdims)|]
        (new NDArray(outputs.[0]))
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="a">The input</param>
    /// <param name="axis">Axis or axes along which a sum is performed. The default, axis=None, will sum all of the elements of the input array. If axis is negative it counts from the last to the first axis.</param>
    /// <param name="dtype">The type of the returned array and of the accumulator in which the elements are summed. The dtype of a is used by default unless a has an integer dtype of less precision than the default platform integer. In that case, if a is signed then the platform integer is used while if a is unsigned then an unsigned integer of the same precision as the platform integer is used.</param>
    /// <param name="ddof">Starting value for the sum.</param>
    /// <param name="keepdims">If this is set to `True`, the reduced axes are left in the result as dimension with size one.</param>
    static member NpiVar(outputArray : NDArray seq, 
                         a : NDArray, 
                         [<Optional>] ?axis : int seq, 
                         [<Optional>] ?dtype : DataType, 
                         [<Optional>] ?ddof : int, 
                         [<Optional>] ?keepdims : bool) =
        let creator = AtomicSymbolCreator.FromName "_npi_var"
        let names = [|"axis"; "dtype"; "ddof"; "keepdims"|]
        let vals = [|(match axis with None -> "None" | Some axis -> (axis |> Seq.map string |> String.concat ", " |> sprintf "[%s]")); (match dtype with None -> "None" | Some dtype -> string dtype); (match ddof with None -> "0" | Some ddof -> string ddof); (match keepdims with None -> "false" | Some keepdims -> string keepdims)|]
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg a)) then a.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <param name="a">The input</param>
    /// <param name="axis">Axis or axes along which a sum is performed. The default, axis=None, will sum all of the elements of the input array. If axis is negative it counts from the last to the first axis.</param>
    /// <param name="dtype">The type of the returned array and of the accumulator in which the elements are summed. The dtype of a is used by default unless a has an integer dtype of less precision than the default platform integer. In that case, if a is signed then the platform integer is used while if a is unsigned then an unsigned integer of the same precision as the platform integer is used.</param>
    /// <param name="ddof">Starting value for the sum.</param>
    /// <param name="keepdims">If this is set to `True`, the reduced axes are left in the result as dimension with size one.</param>
    static member NpiVar([<Optional>] ?a : Symbol, [<Optional>] ?axis : int seq, [<Optional>] ?dtype : DataType, [<Optional>] ?ddof : int, [<Optional>] ?keepdims : bool) =
        NpiVar(?a = a, ?axis = axis, ?dtype = dtype, ?ddof = ddof, ?keepdims = keepdims)

    /// <param name="array">The input</param>
    /// <param name="shape">The shape of the desired array. We can set the dim to zero if it&#39;s same as the original. E.g `A = broadcast_to(B, shape=(10, 0, 0))` has the same meaning as `A = broadcast_axis(B, axis=0, size=10)`.</param>
    static member NpBroadcastTo(array : NDArray, [<Optional>] shape : int seq) =
        let creator = AtomicSymbolCreator.FromName "_np_broadcast_to"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg array)) then array.UnsafeHandle|]
                                                 [|"shape"|]
                                                 [|(if isNull (shape :> obj) then "[]" else (shape |> Seq.map string |> String.concat ", " |> sprintf "[%s]"))|]
        (new NDArray(outputs.[0]))
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="array">The input</param>
    /// <param name="shape">The shape of the desired array. We can set the dim to zero if it&#39;s same as the original. E.g `A = broadcast_to(B, shape=(10, 0, 0))` has the same meaning as `A = broadcast_axis(B, axis=0, size=10)`.</param>
    static member NpBroadcastTo(outputArray : NDArray seq, array : NDArray, [<Optional>] shape : int seq) =
        let creator = AtomicSymbolCreator.FromName "_np_broadcast_to"
        let names = [|"shape"|]
        let vals = [|(if isNull (shape :> obj) then "[]" else (shape |> Seq.map string |> String.concat ", " |> sprintf "[%s]"))|]
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg array)) then array.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <param name="array">The input</param>
    /// <param name="shape">The shape of the desired array. We can set the dim to zero if it&#39;s same as the original. E.g `A = broadcast_to(B, shape=(10, 0, 0))` has the same meaning as `A = broadcast_axis(B, axis=0, size=10)`.</param>
    static member NpBroadcastTo([<Optional>] ?array : Symbol, [<Optional>] ?shape : int seq) =
        NpBroadcastTo(?array = array, ?shape = shape)


    /// <summary>Return the cumulative sum of the elements along a given axis.
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\numpy\np_cumsum.cc:L70</summary>
    /// <param name="a">Input ndarray</param>
    /// <param name="axis">Axis along which the cumulative sum is computed. The default (None) is to compute the cumsum over the flattened array.</param>
    /// <param name="dtype">Type of the returned array and of the accumulator in which the elements are summed. If dtype is not specified, it defaults to the dtype of a, unless a has an integer dtype with a precision less than that of the default platform integer. In that case, the default platform integer is used.</param>
    static member NpCumsum(a : NDArray, [<Optional>] ?axis : int, [<Optional>] ?dtype : DataType) =
        let creator = AtomicSymbolCreator.FromName "_np_cumsum"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg a)) then a.UnsafeHandle|]
                                                 [|"axis"; "dtype"|]
                                                 [|(match axis with None -> "None" | Some axis -> string axis); (match dtype with None -> "None" | Some dtype -> string dtype)|]
        (new NDArray(outputs.[0]))
    /// <summary>Return the cumulative sum of the elements along a given axis.
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\numpy\np_cumsum.cc:L70</summary>
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="a">Input ndarray</param>
    /// <param name="axis">Axis along which the cumulative sum is computed. The default (None) is to compute the cumsum over the flattened array.</param>
    /// <param name="dtype">Type of the returned array and of the accumulator in which the elements are summed. If dtype is not specified, it defaults to the dtype of a, unless a has an integer dtype with a precision less than that of the default platform integer. In that case, the default platform integer is used.</param>
    static member NpCumsum(outputArray : NDArray seq, a : NDArray, [<Optional>] ?axis : int, [<Optional>] ?dtype : DataType) =
        let creator = AtomicSymbolCreator.FromName "_np_cumsum"
        let names = [|"axis"; "dtype"|]
        let vals = [|(match axis with None -> "None" | Some axis -> string axis); (match dtype with None -> "None" | Some dtype -> string dtype)|]
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg a)) then a.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <summary>Return the cumulative sum of the elements along a given axis.
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\numpy\np_cumsum.cc:L70</summary>
    /// <param name="a">Input ndarray</param>
    /// <param name="axis">Axis along which the cumulative sum is computed. The default (None) is to compute the cumsum over the flattened array.</param>
    /// <param name="dtype">Type of the returned array and of the accumulator in which the elements are summed. If dtype is not specified, it defaults to the dtype of a, unless a has an integer dtype with a precision less than that of the default platform integer. In that case, the default platform integer is used.</param>
    static member NpCumsum([<Optional>] ?a : Symbol, [<Optional>] ?axis : int, [<Optional>] ?dtype : DataType) =
        NpCumsum(?a = a, ?axis = axis, ?dtype = dtype)


    /// <param name="a">Input ndarray</param>
    /// <param name="n">The number of times values are differenced. If zero, the input is returned as-is.</param>
    /// <param name="axis">Axis along which the cumulative sum is computed. The default (None) is to compute the diff over the flattened array.</param>
    static member NpiDiff(a : NDArray, [<Optional; DefaultParameterValue(1)>] n : int, [<Optional; DefaultParameterValue(-1)>] axis : int) =
        let creator = AtomicSymbolCreator.FromName "_npi_diff"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg a)) then a.UnsafeHandle|]
                                                 [|"n"; "axis"|]
                                                 [|string n; string axis|]
        outputs |> Array.map (fun h -> new NDArray(h))
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="a">Input ndarray</param>
    /// <param name="n">The number of times values are differenced. If zero, the input is returned as-is.</param>
    /// <param name="axis">Axis along which the cumulative sum is computed. The default (None) is to compute the diff over the flattened array.</param>
    static member NpiDiff(outputArray : NDArray seq, a : NDArray, [<Optional; DefaultParameterValue(1)>] n : int, [<Optional; DefaultParameterValue(-1)>] axis : int) =
        let creator = AtomicSymbolCreator.FromName "_npi_diff"
        let names = [|"n"; "axis"|]
        let vals = [|string n; string axis|]
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg a)) then a.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <param name="a">Input ndarray</param>
    /// <param name="n">The number of times values are differenced. If zero, the input is returned as-is.</param>
    /// <param name="axis">Axis along which the cumulative sum is computed. The default (None) is to compute the diff over the flattened array.</param>
    static member NpiDiff([<Optional>] ?a : Symbol, [<Optional>] ?n : int, [<Optional>] ?axis : int) =
        NpiDiff(?a = a, ?n = n, ?axis = axis)


    /// <summary>Dot product of two arrays. Specifically,
    /// 
    /// - If both a and b are 1-D arrays, it is inner product of vectors.
    /// 
    /// - If both a and b are 2-D arrays, it is matrix multiplication.
    /// 
    /// - If either a or b is 0-D (scalar), it is equivalent to multiply and using numpy.multiply(a, b) or a * b is preferred.
    /// 
    /// - If a is an N-D array and b is a 1-D array, it is a sum product over the last axis of a and b.
    /// 
    /// - If a is an N-D array and b is an M-D array (where M&gt;=2), it is a sum product over the last axis of a and the second-to-last axis of b:
    /// 
    ///   Example ::
    /// 
    ///     dot(a, b)[i,j,k,m] = sum(a[i,j,:] * b[k,:,m])
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\numpy\np_dot.cc:L121</summary>
    /// <param name="a">First input</param>
    /// <param name="b">Second input</param>
    static member NpDot(a : NDArray, b : NDArray) =
        let creator = AtomicSymbolCreator.FromName "_np_dot"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg a)) then a.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg b)) then b.UnsafeHandle|]
                                                 Array.empty
                                                 Array.empty
        (new NDArray(outputs.[0]))
    /// <summary>Dot product of two arrays. Specifically,
    /// 
    /// - If both a and b are 1-D arrays, it is inner product of vectors.
    /// 
    /// - If both a and b are 2-D arrays, it is matrix multiplication.
    /// 
    /// - If either a or b is 0-D (scalar), it is equivalent to multiply and using numpy.multiply(a, b) or a * b is preferred.
    /// 
    /// - If a is an N-D array and b is a 1-D array, it is a sum product over the last axis of a and b.
    /// 
    /// - If a is an N-D array and b is an M-D array (where M&gt;=2), it is a sum product over the last axis of a and the second-to-last axis of b:
    /// 
    ///   Example ::
    /// 
    ///     dot(a, b)[i,j,k,m] = sum(a[i,j,:] * b[k,:,m])
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\numpy\np_dot.cc:L121</summary>
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="a">First input</param>
    /// <param name="b">Second input</param>
    static member NpDot(outputArray : NDArray seq, a : NDArray, b : NDArray) =
        let creator = AtomicSymbolCreator.FromName "_np_dot"
        let names = Array.empty
        let vals = Array.empty
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg a)) then a.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg b)) then b.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <summary>Dot product of two arrays. Specifically,
    /// 
    /// - If both a and b are 1-D arrays, it is inner product of vectors.
    /// 
    /// - If both a and b are 2-D arrays, it is matrix multiplication.
    /// 
    /// - If either a or b is 0-D (scalar), it is equivalent to multiply and using numpy.multiply(a, b) or a * b is preferred.
    /// 
    /// - If a is an N-D array and b is a 1-D array, it is a sum product over the last axis of a and b.
    /// 
    /// - If a is an N-D array and b is an M-D array (where M&gt;=2), it is a sum product over the last axis of a and the second-to-last axis of b:
    /// 
    ///   Example ::
    /// 
    ///     dot(a, b)[i,j,k,m] = sum(a[i,j,:] * b[k,:,m])
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\numpy\np_dot.cc:L121</summary>
    /// <param name="a">First input</param>
    /// <param name="b">Second input</param>
    static member NpDot([<Optional>] ?a : Symbol, [<Optional>] ?b : Symbol) =
        NpDot(?a = a, ?b = b)


    /// <summary>
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\numpy\np_einsum_op.cc:L333</summary>
    /// <param name="data">List of eimsum operands</param>
    /// <param name="numArgs">Number of input arrays.</param>
    /// <param name="subscripts">Specifies the subscripts for summation as comma separated list of subscript labels. An implicit (classical Einstein summation) calculation is performed unless the explicit indicator &#39;-&gt;&#39; is included as well as subscript labels of the precise output form.</param>
    /// <param name="optimize"></param>
    static member NpiEinsum([<ParamArray>] data : NDArray[], [<Optional; DefaultParameterValue("")>] subscripts : string, [<Optional; DefaultParameterValue(0)>] optimize : int) =
        let creator = AtomicSymbolCreator.FromName "_npi_einsum"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 (data |> Array.map (fun x -> x.UnsafeHandle))
                                                 [|"num_args"; "subscripts"; "optimize"|]
                                                 [|string data.Length; subscripts; string optimize|]
        outputs |> Array.map (fun h -> new NDArray(h))
    /// <summary>
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\numpy\np_einsum_op.cc:L333</summary>
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="data">List of eimsum operands</param>
    /// <param name="numArgs">Number of input arrays.</param>
    /// <param name="subscripts">Specifies the subscripts for summation as comma separated list of subscript labels. An implicit (classical Einstein summation) calculation is performed unless the explicit indicator &#39;-&gt;&#39; is included as well as subscript labels of the precise output form.</param>
    /// <param name="optimize"></param>
    static member NpiEinsum(outputArray : NDArray seq, [<ParamArray>] data : NDArray[], [<Optional; DefaultParameterValue("")>] subscripts : string, [<Optional; DefaultParameterValue(0)>] optimize : int) =
        let creator = AtomicSymbolCreator.FromName "_npi_einsum"
        let names = [|"num_args"; "subscripts"; "optimize"|]
        let vals = [|string data.Length; subscripts; string optimize|]
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     (data |> Array.map (fun x -> x.UnsafeHandle))
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <summary>
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\numpy\np_einsum_op.cc:L333</summary>
    /// <param name="data">List of eimsum operands</param>
    /// <param name="subscripts">Specifies the subscripts for summation as comma separated list of subscript labels. An implicit (classical Einstein summation) calculation is performed unless the explicit indicator &#39;-&gt;&#39; is included as well as subscript labels of the precise output form.</param>
    /// <param name="optimize"></param>
    static member NpiEinsum([<Optional>] ?data : Symbol seq, [<Optional>] ?subscripts : string, [<Optional>] ?optimize : int) =
        NpiEinsum(?data = data, ?subscripts = subscripts, ?optimize = optimize)


    /// <param name="lhs">First input to the function</param>
    /// <param name="rhs">Second input to the function</param>
    static member NpiEqual(lhs : NDArray, rhs : NDArray) =
        let creator = AtomicSymbolCreator.FromName "_npi_equal"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg lhs)) then lhs.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg rhs)) then rhs.UnsafeHandle|]
                                                 Array.empty
                                                 Array.empty
        outputs |> Array.map (fun h -> new NDArray(h))
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="lhs">First input to the function</param>
    /// <param name="rhs">Second input to the function</param>
    static member NpiEqual(outputArray : NDArray seq, lhs : NDArray, rhs : NDArray) =
        let creator = AtomicSymbolCreator.FromName "_npi_equal"
        let names = Array.empty
        let vals = Array.empty
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg lhs)) then lhs.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg rhs)) then rhs.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <param name="lhs">First input to the function</param>
    /// <param name="rhs">Second input to the function</param>
    static member NpiEqual([<Optional>] ?lhs : Symbol, [<Optional>] ?rhs : Symbol) =
        NpiEqual(?lhs = lhs, ?rhs = rhs)

    /// <param name="lhs">First input to the function</param>
    /// <param name="rhs">Second input to the function</param>
    static member NpiNotEqual(lhs : NDArray, rhs : NDArray) =
        let creator = AtomicSymbolCreator.FromName "_npi_not_equal"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg lhs)) then lhs.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg rhs)) then rhs.UnsafeHandle|]
                                                 Array.empty
                                                 Array.empty
        outputs |> Array.map (fun h -> new NDArray(h))
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="lhs">First input to the function</param>
    /// <param name="rhs">Second input to the function</param>
    static member NpiNotEqual(outputArray : NDArray seq, lhs : NDArray, rhs : NDArray) =
        let creator = AtomicSymbolCreator.FromName "_npi_not_equal"
        let names = Array.empty
        let vals = Array.empty
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg lhs)) then lhs.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg rhs)) then rhs.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <param name="lhs">First input to the function</param>
    /// <param name="rhs">Second input to the function</param>
    static member NpiNotEqual([<Optional>] ?lhs : Symbol, [<Optional>] ?rhs : Symbol) =
        NpiNotEqual(?lhs = lhs, ?rhs = rhs)

    /// <param name="lhs">First input to the function</param>
    /// <param name="rhs">Second input to the function</param>
    static member NpiGreater(lhs : NDArray, rhs : NDArray) =
        let creator = AtomicSymbolCreator.FromName "_npi_greater"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg lhs)) then lhs.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg rhs)) then rhs.UnsafeHandle|]
                                                 Array.empty
                                                 Array.empty
        outputs |> Array.map (fun h -> new NDArray(h))
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="lhs">First input to the function</param>
    /// <param name="rhs">Second input to the function</param>
    static member NpiGreater(outputArray : NDArray seq, lhs : NDArray, rhs : NDArray) =
        let creator = AtomicSymbolCreator.FromName "_npi_greater"
        let names = Array.empty
        let vals = Array.empty
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg lhs)) then lhs.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg rhs)) then rhs.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <param name="lhs">First input to the function</param>
    /// <param name="rhs">Second input to the function</param>
    static member NpiGreater([<Optional>] ?lhs : Symbol, [<Optional>] ?rhs : Symbol) =
        NpiGreater(?lhs = lhs, ?rhs = rhs)

    /// <param name="lhs">First input to the function</param>
    /// <param name="rhs">Second input to the function</param>
    static member NpiLess(lhs : NDArray, rhs : NDArray) =
        let creator = AtomicSymbolCreator.FromName "_npi_less"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg lhs)) then lhs.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg rhs)) then rhs.UnsafeHandle|]
                                                 Array.empty
                                                 Array.empty
        outputs |> Array.map (fun h -> new NDArray(h))
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="lhs">First input to the function</param>
    /// <param name="rhs">Second input to the function</param>
    static member NpiLess(outputArray : NDArray seq, lhs : NDArray, rhs : NDArray) =
        let creator = AtomicSymbolCreator.FromName "_npi_less"
        let names = Array.empty
        let vals = Array.empty
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg lhs)) then lhs.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg rhs)) then rhs.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <param name="lhs">First input to the function</param>
    /// <param name="rhs">Second input to the function</param>
    static member NpiLess([<Optional>] ?lhs : Symbol, [<Optional>] ?rhs : Symbol) =
        NpiLess(?lhs = lhs, ?rhs = rhs)

    /// <param name="lhs">First input to the function</param>
    /// <param name="rhs">Second input to the function</param>
    static member NpiGreaterEqual(lhs : NDArray, rhs : NDArray) =
        let creator = AtomicSymbolCreator.FromName "_npi_greater_equal"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg lhs)) then lhs.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg rhs)) then rhs.UnsafeHandle|]
                                                 Array.empty
                                                 Array.empty
        outputs |> Array.map (fun h -> new NDArray(h))
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="lhs">First input to the function</param>
    /// <param name="rhs">Second input to the function</param>
    static member NpiGreaterEqual(outputArray : NDArray seq, lhs : NDArray, rhs : NDArray) =
        let creator = AtomicSymbolCreator.FromName "_npi_greater_equal"
        let names = Array.empty
        let vals = Array.empty
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg lhs)) then lhs.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg rhs)) then rhs.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <param name="lhs">First input to the function</param>
    /// <param name="rhs">Second input to the function</param>
    static member NpiGreaterEqual([<Optional>] ?lhs : Symbol, [<Optional>] ?rhs : Symbol) =
        NpiGreaterEqual(?lhs = lhs, ?rhs = rhs)

    /// <param name="lhs">First input to the function</param>
    /// <param name="rhs">Second input to the function</param>
    static member NpiLessEqual(lhs : NDArray, rhs : NDArray) =
        let creator = AtomicSymbolCreator.FromName "_npi_less_equal"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg lhs)) then lhs.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg rhs)) then rhs.UnsafeHandle|]
                                                 Array.empty
                                                 Array.empty
        outputs |> Array.map (fun h -> new NDArray(h))
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="lhs">First input to the function</param>
    /// <param name="rhs">Second input to the function</param>
    static member NpiLessEqual(outputArray : NDArray seq, lhs : NDArray, rhs : NDArray) =
        let creator = AtomicSymbolCreator.FromName "_npi_less_equal"
        let names = Array.empty
        let vals = Array.empty
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg lhs)) then lhs.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg rhs)) then rhs.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <param name="lhs">First input to the function</param>
    /// <param name="rhs">Second input to the function</param>
    static member NpiLessEqual([<Optional>] ?lhs : Symbol, [<Optional>] ?rhs : Symbol) =
        NpiLessEqual(?lhs = lhs, ?rhs = rhs)

    /// <param name="data">First input to the function</param>
    /// <param name="scalar">scalar input</param>
    static member NpiEqualScalar(data : NDArray, scalar : float) =
        let creator = AtomicSymbolCreator.FromName "_npi_equal_scalar"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle|]
                                                 [|"scalar"|]
                                                 [|string scalar|]
        outputs |> Array.map (fun h -> new NDArray(h))
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="data">First input to the function</param>
    /// <param name="scalar">scalar input</param>
    static member NpiEqualScalar(outputArray : NDArray seq, data : NDArray, scalar : float) =
        let creator = AtomicSymbolCreator.FromName "_npi_equal_scalar"
        let names = [|"scalar"|]
        let vals = [|string scalar|]
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <param name="data">First input to the function</param>
    /// <param name="scalar">scalar input</param>
    static member NpiEqualScalar(data : Symbol, scalar : float) =
        NpiEqualScalar(data, scalar)
    /// <param name="scalar">scalar input</param>
    /// <param name="data">First input to the function</param>
    static member NpiEqualScalar(scalar : float, [<Optional>] ?data : Symbol) =
        NpiEqualScalar(scalar, ?data = data)

    /// <param name="data">First input to the function</param>
    /// <param name="scalar">scalar input</param>
    static member NpiNotEqualScalar(data : NDArray, scalar : float) =
        let creator = AtomicSymbolCreator.FromName "_npi_not_equal_scalar"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle|]
                                                 [|"scalar"|]
                                                 [|string scalar|]
        outputs |> Array.map (fun h -> new NDArray(h))
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="data">First input to the function</param>
    /// <param name="scalar">scalar input</param>
    static member NpiNotEqualScalar(outputArray : NDArray seq, data : NDArray, scalar : float) =
        let creator = AtomicSymbolCreator.FromName "_npi_not_equal_scalar"
        let names = [|"scalar"|]
        let vals = [|string scalar|]
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <param name="data">First input to the function</param>
    /// <param name="scalar">scalar input</param>
    static member NpiNotEqualScalar(data : Symbol, scalar : float) =
        NpiNotEqualScalar(data, scalar)
    /// <param name="scalar">scalar input</param>
    /// <param name="data">First input to the function</param>
    static member NpiNotEqualScalar(scalar : float, [<Optional>] ?data : Symbol) =
        NpiNotEqualScalar(scalar, ?data = data)

    /// <param name="data">First input to the function</param>
    /// <param name="scalar">scalar input</param>
    static member NpiGreaterScalar(data : NDArray, scalar : float) =
        let creator = AtomicSymbolCreator.FromName "_npi_greater_scalar"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle|]
                                                 [|"scalar"|]
                                                 [|string scalar|]
        outputs |> Array.map (fun h -> new NDArray(h))
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="data">First input to the function</param>
    /// <param name="scalar">scalar input</param>
    static member NpiGreaterScalar(outputArray : NDArray seq, data : NDArray, scalar : float) =
        let creator = AtomicSymbolCreator.FromName "_npi_greater_scalar"
        let names = [|"scalar"|]
        let vals = [|string scalar|]
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <param name="data">First input to the function</param>
    /// <param name="scalar">scalar input</param>
    static member NpiGreaterScalar(data : Symbol, scalar : float) =
        NpiGreaterScalar(data, scalar)
    /// <param name="scalar">scalar input</param>
    /// <param name="data">First input to the function</param>
    static member NpiGreaterScalar(scalar : float, [<Optional>] ?data : Symbol) =
        NpiGreaterScalar(scalar, ?data = data)

    /// <param name="data">First input to the function</param>
    /// <param name="scalar">scalar input</param>
    static member NpiLessScalar(data : NDArray, scalar : float) =
        let creator = AtomicSymbolCreator.FromName "_npi_less_scalar"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle|]
                                                 [|"scalar"|]
                                                 [|string scalar|]
        outputs |> Array.map (fun h -> new NDArray(h))
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="data">First input to the function</param>
    /// <param name="scalar">scalar input</param>
    static member NpiLessScalar(outputArray : NDArray seq, data : NDArray, scalar : float) =
        let creator = AtomicSymbolCreator.FromName "_npi_less_scalar"
        let names = [|"scalar"|]
        let vals = [|string scalar|]
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <param name="data">First input to the function</param>
    /// <param name="scalar">scalar input</param>
    static member NpiLessScalar(data : Symbol, scalar : float) =
        NpiLessScalar(data, scalar)
    /// <param name="scalar">scalar input</param>
    /// <param name="data">First input to the function</param>
    static member NpiLessScalar(scalar : float, [<Optional>] ?data : Symbol) =
        NpiLessScalar(scalar, ?data = data)

    /// <param name="data">First input to the function</param>
    /// <param name="scalar">scalar input</param>
    static member NpiGreaterEqualScalar(data : NDArray, scalar : float) =
        let creator = AtomicSymbolCreator.FromName "_npi_greater_equal_scalar"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle|]
                                                 [|"scalar"|]
                                                 [|string scalar|]
        outputs |> Array.map (fun h -> new NDArray(h))
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="data">First input to the function</param>
    /// <param name="scalar">scalar input</param>
    static member NpiGreaterEqualScalar(outputArray : NDArray seq, data : NDArray, scalar : float) =
        let creator = AtomicSymbolCreator.FromName "_npi_greater_equal_scalar"
        let names = [|"scalar"|]
        let vals = [|string scalar|]
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <param name="data">First input to the function</param>
    /// <param name="scalar">scalar input</param>
    static member NpiGreaterEqualScalar(data : Symbol, scalar : float) =
        NpiGreaterEqualScalar(data, scalar)
    /// <param name="scalar">scalar input</param>
    /// <param name="data">First input to the function</param>
    static member NpiGreaterEqualScalar(scalar : float, [<Optional>] ?data : Symbol) =
        NpiGreaterEqualScalar(scalar, ?data = data)

    /// <param name="data">First input to the function</param>
    /// <param name="scalar">scalar input</param>
    static member NpiLessEqualScalar(data : NDArray, scalar : float) =
        let creator = AtomicSymbolCreator.FromName "_npi_less_equal_scalar"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle|]
                                                 [|"scalar"|]
                                                 [|string scalar|]
        outputs |> Array.map (fun h -> new NDArray(h))
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="data">First input to the function</param>
    /// <param name="scalar">scalar input</param>
    static member NpiLessEqualScalar(outputArray : NDArray seq, data : NDArray, scalar : float) =
        let creator = AtomicSymbolCreator.FromName "_npi_less_equal_scalar"
        let names = [|"scalar"|]
        let vals = [|string scalar|]
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <param name="data">First input to the function</param>
    /// <param name="scalar">scalar input</param>
    static member NpiLessEqualScalar(data : Symbol, scalar : float) =
        NpiLessEqualScalar(data, scalar)
    /// <param name="scalar">scalar input</param>
    /// <param name="data">First input to the function</param>
    static member NpiLessEqualScalar(scalar : float, [<Optional>] ?data : Symbol) =
        NpiLessEqualScalar(scalar, ?data = data)

    /// <param name="lhs">First input to the function</param>
    /// <param name="rhs">Second input to the function</param>
    static member NpiAdd(lhs : NDArray, rhs : NDArray) =
        let creator = AtomicSymbolCreator.FromName "_npi_add"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg lhs)) then lhs.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg rhs)) then rhs.UnsafeHandle|]
                                                 Array.empty
                                                 Array.empty
        (new NDArray(outputs.[0]))
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="lhs">First input to the function</param>
    /// <param name="rhs">Second input to the function</param>
    static member NpiAdd(outputArray : NDArray seq, lhs : NDArray, rhs : NDArray) =
        let creator = AtomicSymbolCreator.FromName "_npi_add"
        let names = Array.empty
        let vals = Array.empty
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg lhs)) then lhs.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg rhs)) then rhs.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <param name="lhs">First input to the function</param>
    /// <param name="rhs">Second input to the function</param>
    static member NpiAdd([<Optional>] ?lhs : Symbol, [<Optional>] ?rhs : Symbol) =
        NpiAdd(?lhs = lhs, ?rhs = rhs)

    /// <param name="lhs">First input to the function</param>
    /// <param name="rhs">Second input to the function</param>
    static member NpiSubtract(lhs : NDArray, rhs : NDArray) =
        let creator = AtomicSymbolCreator.FromName "_npi_subtract"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg lhs)) then lhs.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg rhs)) then rhs.UnsafeHandle|]
                                                 Array.empty
                                                 Array.empty
        (new NDArray(outputs.[0]))
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="lhs">First input to the function</param>
    /// <param name="rhs">Second input to the function</param>
    static member NpiSubtract(outputArray : NDArray seq, lhs : NDArray, rhs : NDArray) =
        let creator = AtomicSymbolCreator.FromName "_npi_subtract"
        let names = Array.empty
        let vals = Array.empty
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg lhs)) then lhs.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg rhs)) then rhs.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <param name="lhs">First input to the function</param>
    /// <param name="rhs">Second input to the function</param>
    static member NpiSubtract([<Optional>] ?lhs : Symbol, [<Optional>] ?rhs : Symbol) =
        NpiSubtract(?lhs = lhs, ?rhs = rhs)

    /// <param name="lhs">First input to the function</param>
    /// <param name="rhs">Second input to the function</param>
    static member NpiMultiply(lhs : NDArray, rhs : NDArray) =
        let creator = AtomicSymbolCreator.FromName "_npi_multiply"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg lhs)) then lhs.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg rhs)) then rhs.UnsafeHandle|]
                                                 Array.empty
                                                 Array.empty
        (new NDArray(outputs.[0]))
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="lhs">First input to the function</param>
    /// <param name="rhs">Second input to the function</param>
    static member NpiMultiply(outputArray : NDArray seq, lhs : NDArray, rhs : NDArray) =
        let creator = AtomicSymbolCreator.FromName "_npi_multiply"
        let names = Array.empty
        let vals = Array.empty
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg lhs)) then lhs.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg rhs)) then rhs.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <param name="lhs">First input to the function</param>
    /// <param name="rhs">Second input to the function</param>
    static member NpiMultiply([<Optional>] ?lhs : Symbol, [<Optional>] ?rhs : Symbol) =
        NpiMultiply(?lhs = lhs, ?rhs = rhs)


    /// <param name="lhs">First input to the function</param>
    /// <param name="rhs">Second input to the function</param>
    static member NpiMod(lhs : NDArray, rhs : NDArray) =
        let creator = AtomicSymbolCreator.FromName "_npi_mod"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg lhs)) then lhs.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg rhs)) then rhs.UnsafeHandle|]
                                                 Array.empty
                                                 Array.empty
        (new NDArray(outputs.[0]))
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="lhs">First input to the function</param>
    /// <param name="rhs">Second input to the function</param>
    static member NpiMod(outputArray : NDArray seq, lhs : NDArray, rhs : NDArray) =
        let creator = AtomicSymbolCreator.FromName "_npi_mod"
        let names = Array.empty
        let vals = Array.empty
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg lhs)) then lhs.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg rhs)) then rhs.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <param name="lhs">First input to the function</param>
    /// <param name="rhs">Second input to the function</param>
    static member NpiMod([<Optional>] ?lhs : Symbol, [<Optional>] ?rhs : Symbol) =
        NpiMod(?lhs = lhs, ?rhs = rhs)

    /// <param name="lhs">First input to the function</param>
    /// <param name="rhs">Second input to the function</param>
    static member NpiPower(lhs : NDArray, rhs : NDArray) =
        let creator = AtomicSymbolCreator.FromName "_npi_power"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg lhs)) then lhs.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg rhs)) then rhs.UnsafeHandle|]
                                                 Array.empty
                                                 Array.empty
        (new NDArray(outputs.[0]))
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="lhs">First input to the function</param>
    /// <param name="rhs">Second input to the function</param>
    static member NpiPower(outputArray : NDArray seq, lhs : NDArray, rhs : NDArray) =
        let creator = AtomicSymbolCreator.FromName "_npi_power"
        let names = Array.empty
        let vals = Array.empty
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg lhs)) then lhs.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg rhs)) then rhs.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <param name="lhs">First input to the function</param>
    /// <param name="rhs">Second input to the function</param>
    static member NpiPower([<Optional>] ?lhs : Symbol, [<Optional>] ?rhs : Symbol) =
        NpiPower(?lhs = lhs, ?rhs = rhs)

    /// <param name="data">source input</param>
    /// <param name="scalar">scalar input</param>
    static member NpiAddScalar(data : NDArray, scalar : float) =
        let creator = AtomicSymbolCreator.FromName "_npi_add_scalar"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle|]
                                                 [|"scalar"|]
                                                 [|string scalar|]
        (new NDArray(outputs.[0]))
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="data">source input</param>
    /// <param name="scalar">scalar input</param>
    static member NpiAddScalar(outputArray : NDArray seq, data : NDArray, scalar : float) =
        let creator = AtomicSymbolCreator.FromName "_npi_add_scalar"
        let names = [|"scalar"|]
        let vals = [|string scalar|]
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <param name="data">source input</param>
    /// <param name="scalar">scalar input</param>
    static member NpiAddScalar(data : Symbol, scalar : float) =
        NpiAddScalar(data, scalar)
    /// <param name="scalar">scalar input</param>
    /// <param name="data">source input</param>
    static member NpiAddScalar(scalar : float, [<Optional>] ?data : Symbol) =
        NpiAddScalar(scalar, ?data = data)

    /// <param name="data">source input</param>
    /// <param name="scalar">scalar input</param>
    static member NpiSubtractScalar(data : NDArray, scalar : float) =
        let creator = AtomicSymbolCreator.FromName "_npi_subtract_scalar"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle|]
                                                 [|"scalar"|]
                                                 [|string scalar|]
        (new NDArray(outputs.[0]))
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="data">source input</param>
    /// <param name="scalar">scalar input</param>
    static member NpiSubtractScalar(outputArray : NDArray seq, data : NDArray, scalar : float) =
        let creator = AtomicSymbolCreator.FromName "_npi_subtract_scalar"
        let names = [|"scalar"|]
        let vals = [|string scalar|]
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <param name="data">source input</param>
    /// <param name="scalar">scalar input</param>
    static member NpiSubtractScalar(data : Symbol, scalar : float) =
        NpiSubtractScalar(data, scalar)
    /// <param name="scalar">scalar input</param>
    /// <param name="data">source input</param>
    static member NpiSubtractScalar(scalar : float, [<Optional>] ?data : Symbol) =
        NpiSubtractScalar(scalar, ?data = data)

    /// <param name="data">source input</param>
    /// <param name="scalar">scalar input</param>
    static member NpiRsubtractScalar(data : NDArray, scalar : float) =
        let creator = AtomicSymbolCreator.FromName "_npi_rsubtract_scalar"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle|]
                                                 [|"scalar"|]
                                                 [|string scalar|]
        (new NDArray(outputs.[0]))
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="data">source input</param>
    /// <param name="scalar">scalar input</param>
    static member NpiRsubtractScalar(outputArray : NDArray seq, data : NDArray, scalar : float) =
        let creator = AtomicSymbolCreator.FromName "_npi_rsubtract_scalar"
        let names = [|"scalar"|]
        let vals = [|string scalar|]
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <param name="data">source input</param>
    /// <param name="scalar">scalar input</param>
    static member NpiRsubtractScalar(data : Symbol, scalar : float) =
        NpiRsubtractScalar(data, scalar)
    /// <param name="scalar">scalar input</param>
    /// <param name="data">source input</param>
    static member NpiRsubtractScalar(scalar : float, [<Optional>] ?data : Symbol) =
        NpiRsubtractScalar(scalar, ?data = data)

    /// <param name="data">source input</param>
    /// <param name="scalar">scalar input</param>
    static member NpiMultiplyScalar(data : NDArray, scalar : float) =
        let creator = AtomicSymbolCreator.FromName "_npi_multiply_scalar"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle|]
                                                 [|"scalar"|]
                                                 [|string scalar|]
        (new NDArray(outputs.[0]))
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="data">source input</param>
    /// <param name="scalar">scalar input</param>
    static member NpiMultiplyScalar(outputArray : NDArray seq, data : NDArray, scalar : float) =
        let creator = AtomicSymbolCreator.FromName "_npi_multiply_scalar"
        let names = [|"scalar"|]
        let vals = [|string scalar|]
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <param name="data">source input</param>
    /// <param name="scalar">scalar input</param>
    static member NpiMultiplyScalar(data : Symbol, scalar : float) =
        NpiMultiplyScalar(data, scalar)
    /// <param name="scalar">scalar input</param>
    /// <param name="data">source input</param>
    static member NpiMultiplyScalar(scalar : float, [<Optional>] ?data : Symbol) =
        NpiMultiplyScalar(scalar, ?data = data)

    /// <param name="data">source input</param>
    /// <param name="scalar">scalar input</param>
    static member NpiModScalar(data : NDArray, scalar : float) =
        let creator = AtomicSymbolCreator.FromName "_npi_mod_scalar"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle|]
                                                 [|"scalar"|]
                                                 [|string scalar|]
        (new NDArray(outputs.[0]))
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="data">source input</param>
    /// <param name="scalar">scalar input</param>
    static member NpiModScalar(outputArray : NDArray seq, data : NDArray, scalar : float) =
        let creator = AtomicSymbolCreator.FromName "_npi_mod_scalar"
        let names = [|"scalar"|]
        let vals = [|string scalar|]
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <param name="data">source input</param>
    /// <param name="scalar">scalar input</param>
    static member NpiModScalar(data : Symbol, scalar : float) =
        NpiModScalar(data, scalar)
    /// <param name="scalar">scalar input</param>
    /// <param name="data">source input</param>
    static member NpiModScalar(scalar : float, [<Optional>] ?data : Symbol) =
        NpiModScalar(scalar, ?data = data)

    /// <param name="data">source input</param>
    /// <param name="scalar">scalar input</param>
    static member NpiRmodScalar(data : NDArray, scalar : float) =
        let creator = AtomicSymbolCreator.FromName "_npi_rmod_scalar"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle|]
                                                 [|"scalar"|]
                                                 [|string scalar|]
        (new NDArray(outputs.[0]))
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="data">source input</param>
    /// <param name="scalar">scalar input</param>
    static member NpiRmodScalar(outputArray : NDArray seq, data : NDArray, scalar : float) =
        let creator = AtomicSymbolCreator.FromName "_npi_rmod_scalar"
        let names = [|"scalar"|]
        let vals = [|string scalar|]
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <param name="data">source input</param>
    /// <param name="scalar">scalar input</param>
    static member NpiRmodScalar(data : Symbol, scalar : float) =
        NpiRmodScalar(data, scalar)
    /// <param name="scalar">scalar input</param>
    /// <param name="data">source input</param>
    static member NpiRmodScalar(scalar : float, [<Optional>] ?data : Symbol) =
        NpiRmodScalar(scalar, ?data = data)

    /// <param name="data">source input</param>
    /// <param name="scalar">scalar input</param>
    static member NpiPowerScalar(data : NDArray, scalar : float) =
        let creator = AtomicSymbolCreator.FromName "_npi_power_scalar"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle|]
                                                 [|"scalar"|]
                                                 [|string scalar|]
        (new NDArray(outputs.[0]))
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="data">source input</param>
    /// <param name="scalar">scalar input</param>
    static member NpiPowerScalar(outputArray : NDArray seq, data : NDArray, scalar : float) =
        let creator = AtomicSymbolCreator.FromName "_npi_power_scalar"
        let names = [|"scalar"|]
        let vals = [|string scalar|]
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <param name="data">source input</param>
    /// <param name="scalar">scalar input</param>
    static member NpiPowerScalar(data : Symbol, scalar : float) =
        NpiPowerScalar(data, scalar)
    /// <param name="scalar">scalar input</param>
    /// <param name="data">source input</param>
    static member NpiPowerScalar(scalar : float, [<Optional>] ?data : Symbol) =
        NpiPowerScalar(scalar, ?data = data)

    /// <param name="data">source input</param>
    /// <param name="scalar">scalar input</param>
    static member NpiRpowerScalar(data : NDArray, scalar : float) =
        let creator = AtomicSymbolCreator.FromName "_npi_rpower_scalar"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle|]
                                                 [|"scalar"|]
                                                 [|string scalar|]
        (new NDArray(outputs.[0]))
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="data">source input</param>
    /// <param name="scalar">scalar input</param>
    static member NpiRpowerScalar(outputArray : NDArray seq, data : NDArray, scalar : float) =
        let creator = AtomicSymbolCreator.FromName "_npi_rpower_scalar"
        let names = [|"scalar"|]
        let vals = [|string scalar|]
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <param name="data">source input</param>
    /// <param name="scalar">scalar input</param>
    static member NpiRpowerScalar(data : Symbol, scalar : float) =
        NpiRpowerScalar(data, scalar)
    /// <param name="scalar">scalar input</param>
    /// <param name="data">source input</param>
    static member NpiRpowerScalar(scalar : float, [<Optional>] ?data : Symbol) =
        NpiRpowerScalar(scalar, ?data = data)

    /// <summary>
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\numpy\np_elemwise_broadcast_op_extended.cc:L49</summary>
    /// <param name="lhs">First input to the function</param>
    /// <param name="rhs">Second input to the function</param>
    static member NpiCopysign(lhs : NDArray, rhs : NDArray) =
        let creator = AtomicSymbolCreator.FromName "_npi_copysign"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg lhs)) then lhs.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg rhs)) then rhs.UnsafeHandle|]
                                                 Array.empty
                                                 Array.empty
        (new NDArray(outputs.[0]))
    /// <summary>
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\numpy\np_elemwise_broadcast_op_extended.cc:L49</summary>
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="lhs">First input to the function</param>
    /// <param name="rhs">Second input to the function</param>
    static member NpiCopysign(outputArray : NDArray seq, lhs : NDArray, rhs : NDArray) =
        let creator = AtomicSymbolCreator.FromName "_npi_copysign"
        let names = Array.empty
        let vals = Array.empty
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg lhs)) then lhs.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg rhs)) then rhs.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <summary>
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\numpy\np_elemwise_broadcast_op_extended.cc:L49</summary>
    /// <param name="lhs">First input to the function</param>
    /// <param name="rhs">Second input to the function</param>
    static member NpiCopysign([<Optional>] ?lhs : Symbol, [<Optional>] ?rhs : Symbol) =
        NpiCopysign(?lhs = lhs, ?rhs = rhs)


    /// <param name="lhs">First input to the function</param>
    /// <param name="rhs">Second input to the function</param>
    static member NpiLcm(lhs : NDArray, rhs : NDArray) =
        let creator = AtomicSymbolCreator.FromName "_npi_lcm"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg lhs)) then lhs.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg rhs)) then rhs.UnsafeHandle|]
                                                 Array.empty
                                                 Array.empty
        (new NDArray(outputs.[0]))
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="lhs">First input to the function</param>
    /// <param name="rhs">Second input to the function</param>
    static member NpiLcm(outputArray : NDArray seq, lhs : NDArray, rhs : NDArray) =
        let creator = AtomicSymbolCreator.FromName "_npi_lcm"
        let names = Array.empty
        let vals = Array.empty
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg lhs)) then lhs.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg rhs)) then rhs.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <param name="lhs">First input to the function</param>
    /// <param name="rhs">Second input to the function</param>
    static member NpiLcm([<Optional>] ?lhs : Symbol, [<Optional>] ?rhs : Symbol) =
        NpiLcm(?lhs = lhs, ?rhs = rhs)

    /// <param name="data">source input</param>
    /// <param name="scalar">scalar input</param>
    static member NpiLcmScalar(data : NDArray, scalar : int) =
        let creator = AtomicSymbolCreator.FromName "_npi_lcm_scalar"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle|]
                                                 [|"scalar"|]
                                                 [|string scalar|]
        (new NDArray(outputs.[0]))
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="data">source input</param>
    /// <param name="scalar">scalar input</param>
    static member NpiLcmScalar(outputArray : NDArray seq, data : NDArray, scalar : int) =
        let creator = AtomicSymbolCreator.FromName "_npi_lcm_scalar"
        let names = [|"scalar"|]
        let vals = [|string scalar|]
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <param name="data">source input</param>
    /// <param name="scalar">scalar input</param>
    static member NpiLcmScalar(data : Symbol, scalar : int) =
        NpiLcmScalar(data, scalar)
    /// <param name="scalar">scalar input</param>
    /// <param name="data">source input</param>
    static member NpiLcmScalar(scalar : int, [<Optional>] ?data : Symbol) =
        NpiLcmScalar(scalar, ?data = data)

    /// <param name="lhs">First input to the function</param>
    /// <param name="rhs">Second input to the function</param>
    static member NpiBitwiseXor(lhs : NDArray, rhs : NDArray) =
        let creator = AtomicSymbolCreator.FromName "_npi_bitwise_xor"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg lhs)) then lhs.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg rhs)) then rhs.UnsafeHandle|]
                                                 Array.empty
                                                 Array.empty
        outputs |> Array.map (fun h -> new NDArray(h))
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="lhs">First input to the function</param>
    /// <param name="rhs">Second input to the function</param>
    static member NpiBitwiseXor(outputArray : NDArray seq, lhs : NDArray, rhs : NDArray) =
        let creator = AtomicSymbolCreator.FromName "_npi_bitwise_xor"
        let names = Array.empty
        let vals = Array.empty
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg lhs)) then lhs.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg rhs)) then rhs.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <param name="lhs">First input to the function</param>
    /// <param name="rhs">Second input to the function</param>
    static member NpiBitwiseXor([<Optional>] ?lhs : Symbol, [<Optional>] ?rhs : Symbol) =
        NpiBitwiseXor(?lhs = lhs, ?rhs = rhs)

    /// <param name="lhs">First input to the function</param>
    /// <param name="rhs">Second input to the function</param>
    static member NpiBitwiseOr(lhs : NDArray, rhs : NDArray) =
        let creator = AtomicSymbolCreator.FromName "_npi_bitwise_or"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg lhs)) then lhs.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg rhs)) then rhs.UnsafeHandle|]
                                                 Array.empty
                                                 Array.empty
        outputs |> Array.map (fun h -> new NDArray(h))
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="lhs">First input to the function</param>
    /// <param name="rhs">Second input to the function</param>
    static member NpiBitwiseOr(outputArray : NDArray seq, lhs : NDArray, rhs : NDArray) =
        let creator = AtomicSymbolCreator.FromName "_npi_bitwise_or"
        let names = Array.empty
        let vals = Array.empty
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg lhs)) then lhs.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg rhs)) then rhs.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <param name="lhs">First input to the function</param>
    /// <param name="rhs">Second input to the function</param>
    static member NpiBitwiseOr([<Optional>] ?lhs : Symbol, [<Optional>] ?rhs : Symbol) =
        NpiBitwiseOr(?lhs = lhs, ?rhs = rhs)

    /// <param name="data">source input</param>
    /// <param name="scalar">scalar input</param>
    static member NpiBitwiseXorScalar(data : NDArray, scalar : int) =
        let creator = AtomicSymbolCreator.FromName "_npi_bitwise_xor_scalar"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle|]
                                                 [|"scalar"|]
                                                 [|string scalar|]
        outputs |> Array.map (fun h -> new NDArray(h))
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="data">source input</param>
    /// <param name="scalar">scalar input</param>
    static member NpiBitwiseXorScalar(outputArray : NDArray seq, data : NDArray, scalar : int) =
        let creator = AtomicSymbolCreator.FromName "_npi_bitwise_xor_scalar"
        let names = [|"scalar"|]
        let vals = [|string scalar|]
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <param name="data">source input</param>
    /// <param name="scalar">scalar input</param>
    static member NpiBitwiseXorScalar(data : Symbol, scalar : int) =
        NpiBitwiseXorScalar(data, scalar)
    /// <param name="scalar">scalar input</param>
    /// <param name="data">source input</param>
    static member NpiBitwiseXorScalar(scalar : int, [<Optional>] ?data : Symbol) =
        NpiBitwiseXorScalar(scalar, ?data = data)

    /// <param name="data">source input</param>
    /// <param name="scalar">scalar input</param>
    static member NpiBitwiseOrScalar(data : NDArray, scalar : int) =
        let creator = AtomicSymbolCreator.FromName "_npi_bitwise_or_scalar"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle|]
                                                 [|"scalar"|]
                                                 [|string scalar|]
        outputs |> Array.map (fun h -> new NDArray(h))
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="data">source input</param>
    /// <param name="scalar">scalar input</param>
    static member NpiBitwiseOrScalar(outputArray : NDArray seq, data : NDArray, scalar : int) =
        let creator = AtomicSymbolCreator.FromName "_npi_bitwise_or_scalar"
        let names = [|"scalar"|]
        let vals = [|string scalar|]
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <param name="data">source input</param>
    /// <param name="scalar">scalar input</param>
    static member NpiBitwiseOrScalar(data : Symbol, scalar : int) =
        NpiBitwiseOrScalar(data, scalar)
    /// <param name="scalar">scalar input</param>
    /// <param name="data">source input</param>
    static member NpiBitwiseOrScalar(scalar : int, [<Optional>] ?data : Symbol) =
        NpiBitwiseOrScalar(scalar, ?data = data)

    /// <param name="data">source input</param>
    /// <param name="scalar">scalar input</param>
    static member NpiCopysignScalar(data : NDArray, scalar : float) =
        let creator = AtomicSymbolCreator.FromName "_npi_copysign_scalar"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle|]
                                                 [|"scalar"|]
                                                 [|string scalar|]
        (new NDArray(outputs.[0]))
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="data">source input</param>
    /// <param name="scalar">scalar input</param>
    static member NpiCopysignScalar(outputArray : NDArray seq, data : NDArray, scalar : float) =
        let creator = AtomicSymbolCreator.FromName "_npi_copysign_scalar"
        let names = [|"scalar"|]
        let vals = [|string scalar|]
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <param name="data">source input</param>
    /// <param name="scalar">scalar input</param>
    static member NpiCopysignScalar(data : Symbol, scalar : float) =
        NpiCopysignScalar(data, scalar)
    /// <param name="scalar">scalar input</param>
    /// <param name="data">source input</param>
    static member NpiCopysignScalar(scalar : float, [<Optional>] ?data : Symbol) =
        NpiCopysignScalar(scalar, ?data = data)

    /// <param name="data">source input</param>
    /// <param name="scalar">scalar input</param>
    static member NpiRcopysignScalar(data : NDArray, scalar : float) =
        let creator = AtomicSymbolCreator.FromName "_npi_rcopysign_scalar"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle|]
                                                 [|"scalar"|]
                                                 [|string scalar|]
        (new NDArray(outputs.[0]))
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="data">source input</param>
    /// <param name="scalar">scalar input</param>
    static member NpiRcopysignScalar(outputArray : NDArray seq, data : NDArray, scalar : float) =
        let creator = AtomicSymbolCreator.FromName "_npi_rcopysign_scalar"
        let names = [|"scalar"|]
        let vals = [|string scalar|]
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <param name="data">source input</param>
    /// <param name="scalar">scalar input</param>
    static member NpiRcopysignScalar(data : Symbol, scalar : float) =
        NpiRcopysignScalar(data, scalar)
    /// <param name="scalar">scalar input</param>
    /// <param name="data">source input</param>
    static member NpiRcopysignScalar(scalar : float, [<Optional>] ?data : Symbol) =
        NpiRcopysignScalar(scalar, ?data = data)



    /// <param name="x1">The input array</param>
    /// <param name="x2">The input array</param>
    static member NpiArctan2(x1 : NDArray, x2 : NDArray) =
        let creator = AtomicSymbolCreator.FromName "_npi_arctan2"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg x1)) then x1.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg x2)) then x2.UnsafeHandle|]
                                                 Array.empty
                                                 Array.empty
        (new NDArray(outputs.[0]))
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="x1">The input array</param>
    /// <param name="x2">The input array</param>
    static member NpiArctan2(outputArray : NDArray seq, x1 : NDArray, x2 : NDArray) =
        let creator = AtomicSymbolCreator.FromName "_npi_arctan2"
        let names = Array.empty
        let vals = Array.empty
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg x1)) then x1.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg x2)) then x2.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <param name="x1">The input array</param>
    /// <param name="x2">The input array</param>
    static member NpiArctan2([<Optional>] ?x1 : Symbol, [<Optional>] ?x2 : Symbol) =
        NpiArctan2(?x1 = x1, ?x2 = x2)


    /// <param name="data">source input</param>
    /// <param name="scalar">scalar input</param>
    static member NpiArctan2Scalar(data : NDArray, scalar : float) =
        let creator = AtomicSymbolCreator.FromName "_npi_arctan2_scalar"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle|]
                                                 [|"scalar"|]
                                                 [|string scalar|]
        (new NDArray(outputs.[0]))
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="data">source input</param>
    /// <param name="scalar">scalar input</param>
    static member NpiArctan2Scalar(outputArray : NDArray seq, data : NDArray, scalar : float) =
        let creator = AtomicSymbolCreator.FromName "_npi_arctan2_scalar"
        let names = [|"scalar"|]
        let vals = [|string scalar|]
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <param name="data">source input</param>
    /// <param name="scalar">scalar input</param>
    static member NpiArctan2Scalar(data : Symbol, scalar : float) =
        NpiArctan2Scalar(data, scalar)
    /// <param name="scalar">scalar input</param>
    /// <param name="data">source input</param>
    static member NpiArctan2Scalar(scalar : float, [<Optional>] ?data : Symbol) =
        NpiArctan2Scalar(scalar, ?data = data)

    /// <param name="data">source input</param>
    /// <param name="scalar">scalar input</param>
    static member NpiRarctan2Scalar(data : NDArray, scalar : float) =
        let creator = AtomicSymbolCreator.FromName "_npi_rarctan2_scalar"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle|]
                                                 [|"scalar"|]
                                                 [|string scalar|]
        (new NDArray(outputs.[0]))
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="data">source input</param>
    /// <param name="scalar">scalar input</param>
    static member NpiRarctan2Scalar(outputArray : NDArray seq, data : NDArray, scalar : float) =
        let creator = AtomicSymbolCreator.FromName "_npi_rarctan2_scalar"
        let names = [|"scalar"|]
        let vals = [|string scalar|]
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <param name="data">source input</param>
    /// <param name="scalar">scalar input</param>
    static member NpiRarctan2Scalar(data : Symbol, scalar : float) =
        NpiRarctan2Scalar(data, scalar)
    /// <param name="scalar">scalar input</param>
    /// <param name="data">source input</param>
    static member NpiRarctan2Scalar(scalar : float, [<Optional>] ?data : Symbol) =
        NpiRarctan2Scalar(scalar, ?data = data)



    /// <param name="x1">The input array</param>
    /// <param name="x2">The input array</param>
    static member NpiHypot(x1 : NDArray, x2 : NDArray) =
        let creator = AtomicSymbolCreator.FromName "_npi_hypot"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg x1)) then x1.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg x2)) then x2.UnsafeHandle|]
                                                 Array.empty
                                                 Array.empty
        (new NDArray(outputs.[0]))
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="x1">The input array</param>
    /// <param name="x2">The input array</param>
    static member NpiHypot(outputArray : NDArray seq, x1 : NDArray, x2 : NDArray) =
        let creator = AtomicSymbolCreator.FromName "_npi_hypot"
        let names = Array.empty
        let vals = Array.empty
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg x1)) then x1.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg x2)) then x2.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <param name="x1">The input array</param>
    /// <param name="x2">The input array</param>
    static member NpiHypot([<Optional>] ?x1 : Symbol, [<Optional>] ?x2 : Symbol) =
        NpiHypot(?x1 = x1, ?x2 = x2)


    /// <param name="lhs">First input to the function</param>
    /// <param name="rhs">Second input to the function</param>
    static member NpiLdexp(lhs : NDArray, rhs : NDArray) =
        let creator = AtomicSymbolCreator.FromName "_npi_ldexp"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg lhs)) then lhs.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg rhs)) then rhs.UnsafeHandle|]
                                                 Array.empty
                                                 Array.empty
        outputs |> Array.map (fun h -> new NDArray(h))
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="lhs">First input to the function</param>
    /// <param name="rhs">Second input to the function</param>
    static member NpiLdexp(outputArray : NDArray seq, lhs : NDArray, rhs : NDArray) =
        let creator = AtomicSymbolCreator.FromName "_npi_ldexp"
        let names = Array.empty
        let vals = Array.empty
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg lhs)) then lhs.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg rhs)) then rhs.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <param name="lhs">First input to the function</param>
    /// <param name="rhs">Second input to the function</param>
    static member NpiLdexp([<Optional>] ?lhs : Symbol, [<Optional>] ?rhs : Symbol) =
        NpiLdexp(?lhs = lhs, ?rhs = rhs)

    /// <param name="data">source input</param>
    /// <param name="scalar">scalar input</param>
    static member NpiLdexpScalar(data : NDArray, scalar : float) =
        let creator = AtomicSymbolCreator.FromName "_npi_ldexp_scalar"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle|]
                                                 [|"scalar"|]
                                                 [|string scalar|]
        outputs |> Array.map (fun h -> new NDArray(h))
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="data">source input</param>
    /// <param name="scalar">scalar input</param>
    static member NpiLdexpScalar(outputArray : NDArray seq, data : NDArray, scalar : float) =
        let creator = AtomicSymbolCreator.FromName "_npi_ldexp_scalar"
        let names = [|"scalar"|]
        let vals = [|string scalar|]
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <param name="data">source input</param>
    /// <param name="scalar">scalar input</param>
    static member NpiLdexpScalar(data : Symbol, scalar : float) =
        NpiLdexpScalar(data, scalar)
    /// <param name="scalar">scalar input</param>
    /// <param name="data">source input</param>
    static member NpiLdexpScalar(scalar : float, [<Optional>] ?data : Symbol) =
        NpiLdexpScalar(scalar, ?data = data)

    /// <param name="data">source input</param>
    /// <param name="scalar">scalar input</param>
    static member NpiRldexpScalar(data : NDArray, scalar : float) =
        let creator = AtomicSymbolCreator.FromName "_npi_rldexp_scalar"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle|]
                                                 [|"scalar"|]
                                                 [|string scalar|]
        outputs |> Array.map (fun h -> new NDArray(h))
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="data">source input</param>
    /// <param name="scalar">scalar input</param>
    static member NpiRldexpScalar(outputArray : NDArray seq, data : NDArray, scalar : float) =
        let creator = AtomicSymbolCreator.FromName "_npi_rldexp_scalar"
        let names = [|"scalar"|]
        let vals = [|string scalar|]
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <param name="data">source input</param>
    /// <param name="scalar">scalar input</param>
    static member NpiRldexpScalar(data : Symbol, scalar : float) =
        NpiRldexpScalar(data, scalar)
    /// <param name="scalar">scalar input</param>
    /// <param name="data">source input</param>
    static member NpiRldexpScalar(scalar : float, [<Optional>] ?data : Symbol) =
        NpiRldexpScalar(scalar, ?data = data)




    /// <summary>Computes rectified linear activation.
    /// .. math::
    ///    max(features, 0)
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\numpy\np_elemwise_unary_op_basic.cc:L34</summary>
    /// <param name="data">The input array.</param>
    static member NpxRelu(data : NDArray) =
        let creator = AtomicSymbolCreator.FromName "_npx_relu"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle|]
                                                 Array.empty
                                                 Array.empty
        (new NDArray(outputs.[0]))
    /// <summary>Computes rectified linear activation.
    /// .. math::
    ///    max(features, 0)
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\numpy\np_elemwise_unary_op_basic.cc:L34</summary>
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="data">The input array.</param>
    static member NpxRelu(outputArray : NDArray seq, data : NDArray) =
        let creator = AtomicSymbolCreator.FromName "_npx_relu"
        let names = Array.empty
        let vals = Array.empty
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <summary>Computes rectified linear activation.
    /// .. math::
    ///    max(features, 0)
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\numpy\np_elemwise_unary_op_basic.cc:L34</summary>
    /// <param name="data">The input array.</param>
    static member NpxRelu([<Optional>] ?data : Symbol) =
        NpxRelu(?data = data)

    /// <summary>Computes sigmoid of x element-wise.
    /// .. math::
    ///    y = 1 / (1 + exp(-x))
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\numpy\np_elemwise_unary_op_basic.cc:L42</summary>
    /// <param name="data">The input array.</param>
    static member NpxSigmoid(data : NDArray) =
        let creator = AtomicSymbolCreator.FromName "_npx_sigmoid"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle|]
                                                 Array.empty
                                                 Array.empty
        (new NDArray(outputs.[0]))
    /// <summary>Computes sigmoid of x element-wise.
    /// .. math::
    ///    y = 1 / (1 + exp(-x))
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\numpy\np_elemwise_unary_op_basic.cc:L42</summary>
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="data">The input array.</param>
    static member NpxSigmoid(outputArray : NDArray seq, data : NDArray) =
        let creator = AtomicSymbolCreator.FromName "_npx_sigmoid"
        let names = Array.empty
        let vals = Array.empty
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <summary>Computes sigmoid of x element-wise.
    /// .. math::
    ///    y = 1 / (1 + exp(-x))
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\numpy\np_elemwise_unary_op_basic.cc:L42</summary>
    /// <param name="data">The input array.</param>
    static member NpxSigmoid([<Optional>] ?data : Symbol) =
        NpxSigmoid(?data = data)

    /// <summary>Return an array copy of the given object.
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\numpy\np_elemwise_unary_op_basic.cc:L47</summary>
    /// <param name="a">The input</param>
    static member NpCopy(a : NDArray) =
        let creator = AtomicSymbolCreator.FromName "_np_copy"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg a)) then a.UnsafeHandle|]
                                                 Array.empty
                                                 Array.empty
        (new NDArray(outputs.[0]))
    /// <summary>Return an array copy of the given object.
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\numpy\np_elemwise_unary_op_basic.cc:L47</summary>
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="a">The input</param>
    static member NpCopy(outputArray : NDArray seq, a : NDArray) =
        let creator = AtomicSymbolCreator.FromName "_np_copy"
        let names = Array.empty
        let vals = Array.empty
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg a)) then a.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <summary>Return an array copy of the given object.
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\numpy\np_elemwise_unary_op_basic.cc:L47</summary>
    /// <param name="a">The input</param>
    static member NpCopy([<Optional>] ?a : Symbol) =
        NpCopy(?a = a)

    /// <summary>Numerical negative, element-wise.
    /// Example::
    ///     negative([1.,  -1.]) = [-1.,  1.]
    /// </summary>
    /// <param name="x">The input array.</param>
    static member NpiNegative(x : NDArray) =
        let creator = AtomicSymbolCreator.FromName "_npi_negative"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg x)) then x.UnsafeHandle|]
                                                 Array.empty
                                                 Array.empty
        (new NDArray(outputs.[0]))
    /// <summary>Numerical negative, element-wise.
    /// Example::
    ///     negative([1.,  -1.]) = [-1.,  1.]
    /// </summary>
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="x">The input array.</param>
    static member NpiNegative(outputArray : NDArray seq, x : NDArray) =
        let creator = AtomicSymbolCreator.FromName "_npi_negative"
        let names = Array.empty
        let vals = Array.empty
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg x)) then x.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <summary>Numerical negative, element-wise.
    /// Example::
    ///     negative([1.,  -1.]) = [-1.,  1.]
    /// </summary>
    /// <param name="x">The input array.</param>
    static member NpiNegative([<Optional>] ?x : Symbol) =
        NpiNegative(?x = x)

    /// <summary>Return the reciprocal of the argument, element-wise.
    /// Example::
    ///     reciprocal([-2, 1, 3, 1.6, 0.2]) = [-0.5, 1.0, 0.33333334, 0.625, 5.0]
    /// </summary>
    /// <param name="x">The input array.</param>
    static member NpiReciprocal(x : NDArray) =
        let creator = AtomicSymbolCreator.FromName "_npi_reciprocal"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg x)) then x.UnsafeHandle|]
                                                 Array.empty
                                                 Array.empty
        (new NDArray(outputs.[0]))
    /// <summary>Return the reciprocal of the argument, element-wise.
    /// Example::
    ///     reciprocal([-2, 1, 3, 1.6, 0.2]) = [-0.5, 1.0, 0.33333334, 0.625, 5.0]
    /// </summary>
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="x">The input array.</param>
    static member NpiReciprocal(outputArray : NDArray seq, x : NDArray) =
        let creator = AtomicSymbolCreator.FromName "_npi_reciprocal"
        let names = Array.empty
        let vals = Array.empty
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg x)) then x.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <summary>Return the reciprocal of the argument, element-wise.
    /// Example::
    ///     reciprocal([-2, 1, 3, 1.6, 0.2]) = [-0.5, 1.0, 0.33333334, 0.625, 5.0]
    /// </summary>
    /// <param name="x">The input array.</param>
    static member NpiReciprocal([<Optional>] ?x : Symbol) =
        NpiReciprocal(?x = x)

    /// <summary>Returns element-wise absolute value of the input.
    /// Example::
    ///    absolute([-2, 0, 3]) = [2, 0, 3]
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\numpy\np_elemwise_unary_op_basic.cc:L134</summary>
    /// <param name="x">The input array.</param>
    static member NpiAbsolute(x : NDArray) =
        let creator = AtomicSymbolCreator.FromName "_npi_absolute"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg x)) then x.UnsafeHandle|]
                                                 Array.empty
                                                 Array.empty
        (new NDArray(outputs.[0]))
    /// <summary>Returns element-wise absolute value of the input.
    /// Example::
    ///    absolute([-2, 0, 3]) = [2, 0, 3]
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\numpy\np_elemwise_unary_op_basic.cc:L134</summary>
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="x">The input array.</param>
    static member NpiAbsolute(outputArray : NDArray seq, x : NDArray) =
        let creator = AtomicSymbolCreator.FromName "_npi_absolute"
        let names = Array.empty
        let vals = Array.empty
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg x)) then x.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <summary>Returns element-wise absolute value of the input.
    /// Example::
    ///    absolute([-2, 0, 3]) = [2, 0, 3]
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\numpy\np_elemwise_unary_op_basic.cc:L134</summary>
    /// <param name="x">The input array.</param>
    static member NpiAbsolute([<Optional>] ?x : Symbol) =
        NpiAbsolute(?x = x)

    /// <summary>Returns an element-wise indication of the sign of a number.
    /// The sign function returns -1 if x &lt; 0, 0 if x==0, 1 if x &gt; 0.
    /// Example::
    ///    sign([-2, 0, 3]) = [-1, 0, 1]
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\numpy\np_elemwise_unary_op_basic.cc:L143</summary>
    /// <param name="x">The input array.</param>
    static member NpiSign(x : NDArray) =
        let creator = AtomicSymbolCreator.FromName "_npi_sign"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg x)) then x.UnsafeHandle|]
                                                 Array.empty
                                                 Array.empty
        (new NDArray(outputs.[0]))
    /// <summary>Returns an element-wise indication of the sign of a number.
    /// The sign function returns -1 if x &lt; 0, 0 if x==0, 1 if x &gt; 0.
    /// Example::
    ///    sign([-2, 0, 3]) = [-1, 0, 1]
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\numpy\np_elemwise_unary_op_basic.cc:L143</summary>
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="x">The input array.</param>
    static member NpiSign(outputArray : NDArray seq, x : NDArray) =
        let creator = AtomicSymbolCreator.FromName "_npi_sign"
        let names = Array.empty
        let vals = Array.empty
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg x)) then x.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <summary>Returns an element-wise indication of the sign of a number.
    /// The sign function returns -1 if x &lt; 0, 0 if x==0, 1 if x &gt; 0.
    /// Example::
    ///    sign([-2, 0, 3]) = [-1, 0, 1]
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\numpy\np_elemwise_unary_op_basic.cc:L143</summary>
    /// <param name="x">The input array.</param>
    static member NpiSign([<Optional>] ?x : Symbol) =
        NpiSign(?x = x)

    /// <summary>Round elements of the array to the nearest integer.
    /// Example::
    ///    rint([-1.7, -1.5, -0.2, 0.2, 1.5, 1.7, 2.0]) = [-2., -2., -0.,  0.,  2.,  2.,  2.]
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\numpy\np_elemwise_unary_op_basic.cc:L151</summary>
    /// <param name="x">The input array.</param>
    static member NpiRint(x : NDArray) =
        let creator = AtomicSymbolCreator.FromName "_npi_rint"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg x)) then x.UnsafeHandle|]
                                                 Array.empty
                                                 Array.empty
        (new NDArray(outputs.[0]))
    /// <summary>Round elements of the array to the nearest integer.
    /// Example::
    ///    rint([-1.7, -1.5, -0.2, 0.2, 1.5, 1.7, 2.0]) = [-2., -2., -0.,  0.,  2.,  2.,  2.]
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\numpy\np_elemwise_unary_op_basic.cc:L151</summary>
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="x">The input array.</param>
    static member NpiRint(outputArray : NDArray seq, x : NDArray) =
        let creator = AtomicSymbolCreator.FromName "_npi_rint"
        let names = Array.empty
        let vals = Array.empty
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg x)) then x.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <summary>Round elements of the array to the nearest integer.
    /// Example::
    ///    rint([-1.7, -1.5, -0.2, 0.2, 1.5, 1.7, 2.0]) = [-2., -2., -0.,  0.,  2.,  2.,  2.]
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\numpy\np_elemwise_unary_op_basic.cc:L151</summary>
    /// <param name="x">The input array.</param>
    static member NpiRint([<Optional>] ?x : Symbol) =
        NpiRint(?x = x)

    /// <summary>Return the ceiling of the input, element-wise.
    /// The ceil of the scalar x is the smallest integer i, such that i &gt;= x.
    /// Example::
    ///    ceil([-1.7, -1.5, -0.2, 0.2, 1.5, 1.7, 2.0]) = [-1., -1., -0.,  1.,  2.,  2.,  2.]
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\numpy\np_elemwise_unary_op_basic.cc:L160</summary>
    /// <param name="x">The input array.</param>
    static member NpiCeil(x : NDArray) =
        let creator = AtomicSymbolCreator.FromName "_npi_ceil"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg x)) then x.UnsafeHandle|]
                                                 Array.empty
                                                 Array.empty
        (new NDArray(outputs.[0]))
    /// <summary>Return the ceiling of the input, element-wise.
    /// The ceil of the scalar x is the smallest integer i, such that i &gt;= x.
    /// Example::
    ///    ceil([-1.7, -1.5, -0.2, 0.2, 1.5, 1.7, 2.0]) = [-1., -1., -0.,  1.,  2.,  2.,  2.]
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\numpy\np_elemwise_unary_op_basic.cc:L160</summary>
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="x">The input array.</param>
    static member NpiCeil(outputArray : NDArray seq, x : NDArray) =
        let creator = AtomicSymbolCreator.FromName "_npi_ceil"
        let names = Array.empty
        let vals = Array.empty
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg x)) then x.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <summary>Return the ceiling of the input, element-wise.
    /// The ceil of the scalar x is the smallest integer i, such that i &gt;= x.
    /// Example::
    ///    ceil([-1.7, -1.5, -0.2, 0.2, 1.5, 1.7, 2.0]) = [-1., -1., -0.,  1.,  2.,  2.,  2.]
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\numpy\np_elemwise_unary_op_basic.cc:L160</summary>
    /// <param name="x">The input array.</param>
    static member NpiCeil([<Optional>] ?x : Symbol) =
        NpiCeil(?x = x)

    /// <summary>Return the floor of the input, element-wise.
    /// The floor of the scalar x is the largest integer i, such that i &lt;= x.
    /// Example::
    ///    floor([-1.7, -1.5, -0.2, 0.2, 1.5, 1.7, 2.0]) = [-2., -2., -1.,  0.,  1.,  1.,  2.]
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\numpy\np_elemwise_unary_op_basic.cc:L169</summary>
    /// <param name="x">The input array.</param>
    static member NpiFloor(x : NDArray) =
        let creator = AtomicSymbolCreator.FromName "_npi_floor"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg x)) then x.UnsafeHandle|]
                                                 Array.empty
                                                 Array.empty
        (new NDArray(outputs.[0]))
    /// <summary>Return the floor of the input, element-wise.
    /// The floor of the scalar x is the largest integer i, such that i &lt;= x.
    /// Example::
    ///    floor([-1.7, -1.5, -0.2, 0.2, 1.5, 1.7, 2.0]) = [-2., -2., -1.,  0.,  1.,  1.,  2.]
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\numpy\np_elemwise_unary_op_basic.cc:L169</summary>
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="x">The input array.</param>
    static member NpiFloor(outputArray : NDArray seq, x : NDArray) =
        let creator = AtomicSymbolCreator.FromName "_npi_floor"
        let names = Array.empty
        let vals = Array.empty
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg x)) then x.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <summary>Return the floor of the input, element-wise.
    /// The floor of the scalar x is the largest integer i, such that i &lt;= x.
    /// Example::
    ///    floor([-1.7, -1.5, -0.2, 0.2, 1.5, 1.7, 2.0]) = [-2., -2., -1.,  0.,  1.,  1.,  2.]
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\numpy\np_elemwise_unary_op_basic.cc:L169</summary>
    /// <param name="x">The input array.</param>
    static member NpiFloor([<Optional>] ?x : Symbol) =
        NpiFloor(?x = x)

    /// <summary>Return the truncated value of the input, element-wise.
    /// The truncated value of the scalar x is the nearest integer i which is closer to
    /// zero than x is. In short, the fractional part of the signed number x is discarded.
    /// Example::
    ///    trunc([-1.7, -1.5, -0.2, 0.2, 1.5, 1.7, 2.0]) = [-1., -1., -0.,  0.,  1.,  1.,  2.]
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\numpy\np_elemwise_unary_op_basic.cc:L179</summary>
    /// <param name="x">The input array.</param>
    static member NpiTrunc(x : NDArray) =
        let creator = AtomicSymbolCreator.FromName "_npi_trunc"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg x)) then x.UnsafeHandle|]
                                                 Array.empty
                                                 Array.empty
        (new NDArray(outputs.[0]))
    /// <summary>Return the truncated value of the input, element-wise.
    /// The truncated value of the scalar x is the nearest integer i which is closer to
    /// zero than x is. In short, the fractional part of the signed number x is discarded.
    /// Example::
    ///    trunc([-1.7, -1.5, -0.2, 0.2, 1.5, 1.7, 2.0]) = [-1., -1., -0.,  0.,  1.,  1.,  2.]
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\numpy\np_elemwise_unary_op_basic.cc:L179</summary>
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="x">The input array.</param>
    static member NpiTrunc(outputArray : NDArray seq, x : NDArray) =
        let creator = AtomicSymbolCreator.FromName "_npi_trunc"
        let names = Array.empty
        let vals = Array.empty
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg x)) then x.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <summary>Return the truncated value of the input, element-wise.
    /// The truncated value of the scalar x is the nearest integer i which is closer to
    /// zero than x is. In short, the fractional part of the signed number x is discarded.
    /// Example::
    ///    trunc([-1.7, -1.5, -0.2, 0.2, 1.5, 1.7, 2.0]) = [-1., -1., -0.,  0.,  1.,  1.,  2.]
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\numpy\np_elemwise_unary_op_basic.cc:L179</summary>
    /// <param name="x">The input array.</param>
    static member NpiTrunc([<Optional>] ?x : Symbol) =
        NpiTrunc(?x = x)

    /// <summary>Round to nearest integer towards zero.
    /// Round an array of floats element-wise to nearest integer towards zero.
    /// The rounded values are returned as floats.
    /// Example::
    ///    fix([-2.1, -1.9, 1.9, 2.1]) = [-2., -1.,  1., 2.]
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\numpy\np_elemwise_unary_op_basic.cc:L189</summary>
    /// <param name="x">The input array.</param>
    static member NpiFix(x : NDArray) =
        let creator = AtomicSymbolCreator.FromName "_npi_fix"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg x)) then x.UnsafeHandle|]
                                                 Array.empty
                                                 Array.empty
        (new NDArray(outputs.[0]))
    /// <summary>Round to nearest integer towards zero.
    /// Round an array of floats element-wise to nearest integer towards zero.
    /// The rounded values are returned as floats.
    /// Example::
    ///    fix([-2.1, -1.9, 1.9, 2.1]) = [-2., -1.,  1., 2.]
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\numpy\np_elemwise_unary_op_basic.cc:L189</summary>
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="x">The input array.</param>
    static member NpiFix(outputArray : NDArray seq, x : NDArray) =
        let creator = AtomicSymbolCreator.FromName "_npi_fix"
        let names = Array.empty
        let vals = Array.empty
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg x)) then x.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <summary>Round to nearest integer towards zero.
    /// Round an array of floats element-wise to nearest integer towards zero.
    /// The rounded values are returned as floats.
    /// Example::
    ///    fix([-2.1, -1.9, 1.9, 2.1]) = [-2., -1.,  1., 2.]
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\numpy\np_elemwise_unary_op_basic.cc:L189</summary>
    /// <param name="x">The input array.</param>
    static member NpiFix([<Optional>] ?x : Symbol) =
        NpiFix(?x = x)

    /// <summary>Return the element-wise square of the input.
    /// Example::
    ///    square([2, 3, 4]) = [4, 9, 16]
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\numpy\np_elemwise_unary_op_basic.cc:L197</summary>
    /// <param name="x">The input array.</param>
    static member NpiSquare(x : NDArray) =
        let creator = AtomicSymbolCreator.FromName "_npi_square"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg x)) then x.UnsafeHandle|]
                                                 Array.empty
                                                 Array.empty
        (new NDArray(outputs.[0]))
    /// <summary>Return the element-wise square of the input.
    /// Example::
    ///    square([2, 3, 4]) = [4, 9, 16]
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\numpy\np_elemwise_unary_op_basic.cc:L197</summary>
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="x">The input array.</param>
    static member NpiSquare(outputArray : NDArray seq, x : NDArray) =
        let creator = AtomicSymbolCreator.FromName "_npi_square"
        let names = Array.empty
        let vals = Array.empty
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg x)) then x.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <summary>Return the element-wise square of the input.
    /// Example::
    ///    square([2, 3, 4]) = [4, 9, 16]
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\numpy\np_elemwise_unary_op_basic.cc:L197</summary>
    /// <param name="x">The input array.</param>
    static member NpiSquare([<Optional>] ?x : Symbol) =
        NpiSquare(?x = x)

    /// <summary>Return the non-negative square-root of an array, element-wise.
    /// Example::
    ///    sqrt([4, 9, 16]) = [2, 3, 4]
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\numpy\np_elemwise_unary_op_basic.cc:L205</summary>
    /// <param name="x">The input array.</param>
    static member NpiSqrt(x : NDArray) =
        let creator = AtomicSymbolCreator.FromName "_npi_sqrt"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg x)) then x.UnsafeHandle|]
                                                 Array.empty
                                                 Array.empty
        (new NDArray(outputs.[0]))
    /// <summary>Return the non-negative square-root of an array, element-wise.
    /// Example::
    ///    sqrt([4, 9, 16]) = [2, 3, 4]
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\numpy\np_elemwise_unary_op_basic.cc:L205</summary>
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="x">The input array.</param>
    static member NpiSqrt(outputArray : NDArray seq, x : NDArray) =
        let creator = AtomicSymbolCreator.FromName "_npi_sqrt"
        let names = Array.empty
        let vals = Array.empty
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg x)) then x.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <summary>Return the non-negative square-root of an array, element-wise.
    /// Example::
    ///    sqrt([4, 9, 16]) = [2, 3, 4]
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\numpy\np_elemwise_unary_op_basic.cc:L205</summary>
    /// <param name="x">The input array.</param>
    static member NpiSqrt([<Optional>] ?x : Symbol) =
        NpiSqrt(?x = x)

    /// <summary>Return the cube-root of an array, element-wise.
    /// Example::
    ///    cbrt([1, 8, -125]) = [1, 2, -5]
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\numpy\np_elemwise_unary_op_basic.cc:L213</summary>
    /// <param name="x">The input array.</param>
    static member NpiCbrt(x : NDArray) =
        let creator = AtomicSymbolCreator.FromName "_npi_cbrt"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg x)) then x.UnsafeHandle|]
                                                 Array.empty
                                                 Array.empty
        (new NDArray(outputs.[0]))
    /// <summary>Return the cube-root of an array, element-wise.
    /// Example::
    ///    cbrt([1, 8, -125]) = [1, 2, -5]
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\numpy\np_elemwise_unary_op_basic.cc:L213</summary>
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="x">The input array.</param>
    static member NpiCbrt(outputArray : NDArray seq, x : NDArray) =
        let creator = AtomicSymbolCreator.FromName "_npi_cbrt"
        let names = Array.empty
        let vals = Array.empty
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg x)) then x.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <summary>Return the cube-root of an array, element-wise.
    /// Example::
    ///    cbrt([1, 8, -125]) = [1, 2, -5]
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\numpy\np_elemwise_unary_op_basic.cc:L213</summary>
    /// <param name="x">The input array.</param>
    static member NpiCbrt([<Optional>] ?x : Symbol) =
        NpiCbrt(?x = x)

    /// <summary>Calculate the exponential of all elements in the input array.
    /// Example::
    ///    exp([0, 1, 2]) = [1., 2.71828175, 7.38905621]
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\numpy\np_elemwise_unary_op_basic.cc:L221</summary>
    /// <param name="x">The input array.</param>
    static member NpiExp(x : NDArray) =
        let creator = AtomicSymbolCreator.FromName "_npi_exp"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg x)) then x.UnsafeHandle|]
                                                 Array.empty
                                                 Array.empty
        (new NDArray(outputs.[0]))
    /// <summary>Calculate the exponential of all elements in the input array.
    /// Example::
    ///    exp([0, 1, 2]) = [1., 2.71828175, 7.38905621]
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\numpy\np_elemwise_unary_op_basic.cc:L221</summary>
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="x">The input array.</param>
    static member NpiExp(outputArray : NDArray seq, x : NDArray) =
        let creator = AtomicSymbolCreator.FromName "_npi_exp"
        let names = Array.empty
        let vals = Array.empty
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg x)) then x.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <summary>Calculate the exponential of all elements in the input array.
    /// Example::
    ///    exp([0, 1, 2]) = [1., 2.71828175, 7.38905621]
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\numpy\np_elemwise_unary_op_basic.cc:L221</summary>
    /// <param name="x">The input array.</param>
    static member NpiExp([<Optional>] ?x : Symbol) =
        NpiExp(?x = x)

    /// <summary>Returns element-wise Natural logarithmic value of the input.
    /// The natural logarithm is logarithm in base *e*, so that ``log(exp(x)) = x``
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\numpy\np_elemwise_unary_op_basic.cc:L228</summary>
    /// <param name="x">The input array.</param>
    static member NpiLog(x : NDArray) =
        let creator = AtomicSymbolCreator.FromName "_npi_log"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg x)) then x.UnsafeHandle|]
                                                 Array.empty
                                                 Array.empty
        (new NDArray(outputs.[0]))
    /// <summary>Returns element-wise Natural logarithmic value of the input.
    /// The natural logarithm is logarithm in base *e*, so that ``log(exp(x)) = x``
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\numpy\np_elemwise_unary_op_basic.cc:L228</summary>
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="x">The input array.</param>
    static member NpiLog(outputArray : NDArray seq, x : NDArray) =
        let creator = AtomicSymbolCreator.FromName "_npi_log"
        let names = Array.empty
        let vals = Array.empty
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg x)) then x.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <summary>Returns element-wise Natural logarithmic value of the input.
    /// The natural logarithm is logarithm in base *e*, so that ``log(exp(x)) = x``
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\numpy\np_elemwise_unary_op_basic.cc:L228</summary>
    /// <param name="x">The input array.</param>
    static member NpiLog([<Optional>] ?x : Symbol) =
        NpiLog(?x = x)

    /// <summary>Returns element-wise Base-10 logarithmic value of the input.
    /// ``10**log10(x) = x``
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\numpy\np_elemwise_unary_op_basic.cc:L249</summary>
    /// <param name="x">The input array.</param>
    static member NpiLog10(x : NDArray) =
        let creator = AtomicSymbolCreator.FromName "_npi_log10"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg x)) then x.UnsafeHandle|]
                                                 Array.empty
                                                 Array.empty
        (new NDArray(outputs.[0]))
    /// <summary>Returns element-wise Base-10 logarithmic value of the input.
    /// ``10**log10(x) = x``
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\numpy\np_elemwise_unary_op_basic.cc:L249</summary>
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="x">The input array.</param>
    static member NpiLog10(outputArray : NDArray seq, x : NDArray) =
        let creator = AtomicSymbolCreator.FromName "_npi_log10"
        let names = Array.empty
        let vals = Array.empty
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg x)) then x.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <summary>Returns element-wise Base-10 logarithmic value of the input.
    /// ``10**log10(x) = x``
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\numpy\np_elemwise_unary_op_basic.cc:L249</summary>
    /// <param name="x">The input array.</param>
    static member NpiLog10([<Optional>] ?x : Symbol) =
        NpiLog10(?x = x)

    /// <summary>Returns element-wise Base-2 logarithmic value of the input.
    /// ``2**log2(x) = x``
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\numpy\np_elemwise_unary_op_basic.cc:L256</summary>
    /// <param name="x">The input array.</param>
    static member NpiLog2(x : NDArray) =
        let creator = AtomicSymbolCreator.FromName "_npi_log2"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg x)) then x.UnsafeHandle|]
                                                 Array.empty
                                                 Array.empty
        (new NDArray(outputs.[0]))
    /// <summary>Returns element-wise Base-2 logarithmic value of the input.
    /// ``2**log2(x) = x``
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\numpy\np_elemwise_unary_op_basic.cc:L256</summary>
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="x">The input array.</param>
    static member NpiLog2(outputArray : NDArray seq, x : NDArray) =
        let creator = AtomicSymbolCreator.FromName "_npi_log2"
        let names = Array.empty
        let vals = Array.empty
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg x)) then x.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <summary>Returns element-wise Base-2 logarithmic value of the input.
    /// ``2**log2(x) = x``
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\numpy\np_elemwise_unary_op_basic.cc:L256</summary>
    /// <param name="x">The input array.</param>
    static member NpiLog2([<Optional>] ?x : Symbol) =
        NpiLog2(?x = x)

    /// <summary>Return the natural logarithm of one plus the input array, element-wise.
    /// Calculates ``log(1 + x)``.
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\numpy\np_elemwise_unary_op_basic.cc:L263</summary>
    /// <param name="x">The input array.</param>
    static member NpiLog1p(x : NDArray) =
        let creator = AtomicSymbolCreator.FromName "_npi_log1p"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg x)) then x.UnsafeHandle|]
                                                 Array.empty
                                                 Array.empty
        (new NDArray(outputs.[0]))
    /// <summary>Return the natural logarithm of one plus the input array, element-wise.
    /// Calculates ``log(1 + x)``.
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\numpy\np_elemwise_unary_op_basic.cc:L263</summary>
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="x">The input array.</param>
    static member NpiLog1p(outputArray : NDArray seq, x : NDArray) =
        let creator = AtomicSymbolCreator.FromName "_npi_log1p"
        let names = Array.empty
        let vals = Array.empty
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg x)) then x.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <summary>Return the natural logarithm of one plus the input array, element-wise.
    /// Calculates ``log(1 + x)``.
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\numpy\np_elemwise_unary_op_basic.cc:L263</summary>
    /// <param name="x">The input array.</param>
    static member NpiLog1p([<Optional>] ?x : Symbol) =
        NpiLog1p(?x = x)

    /// <summary>Calculate ``exp(x) - 1`` for all elements in the array.
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\numpy\np_elemwise_unary_op_basic.cc:L268</summary>
    /// <param name="x">The input array.</param>
    static member NpiExpm1(x : NDArray) =
        let creator = AtomicSymbolCreator.FromName "_npi_expm1"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg x)) then x.UnsafeHandle|]
                                                 Array.empty
                                                 Array.empty
        (new NDArray(outputs.[0]))
    /// <summary>Calculate ``exp(x) - 1`` for all elements in the array.
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\numpy\np_elemwise_unary_op_basic.cc:L268</summary>
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="x">The input array.</param>
    static member NpiExpm1(outputArray : NDArray seq, x : NDArray) =
        let creator = AtomicSymbolCreator.FromName "_npi_expm1"
        let names = Array.empty
        let vals = Array.empty
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg x)) then x.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <summary>Calculate ``exp(x) - 1`` for all elements in the array.
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\numpy\np_elemwise_unary_op_basic.cc:L268</summary>
    /// <param name="x">The input array.</param>
    static member NpiExpm1([<Optional>] ?x : Symbol) =
        NpiExpm1(?x = x)

    /// <param name="x">The input array.</param>
    static member NpiLogicalNot(x : NDArray) =
        let creator = AtomicSymbolCreator.FromName "_npi_logical_not"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg x)) then x.UnsafeHandle|]
                                                 Array.empty
                                                 Array.empty
        (new NDArray(outputs.[0]))
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="x">The input array.</param>
    static member NpiLogicalNot(outputArray : NDArray seq, x : NDArray) =
        let creator = AtomicSymbolCreator.FromName "_npi_logical_not"
        let names = Array.empty
        let vals = Array.empty
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg x)) then x.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <param name="x">The input array.</param>
    static member NpiLogicalNot([<Optional>] ?x : Symbol) =
        NpiLogicalNot(?x = x)

    /// <summary>Trigonometric sine, element-wise.
    /// .. math::
    ///    sin([0, \pi/4, \pi/2]) = [0, 0.707, 1]
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\numpy\np_elemwise_unary_op_basic.cc:L281</summary>
    /// <param name="x">The input array.</param>
    static member NpiSin(x : NDArray) =
        let creator = AtomicSymbolCreator.FromName "_npi_sin"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg x)) then x.UnsafeHandle|]
                                                 Array.empty
                                                 Array.empty
        (new NDArray(outputs.[0]))
    /// <summary>Trigonometric sine, element-wise.
    /// .. math::
    ///    sin([0, \pi/4, \pi/2]) = [0, 0.707, 1]
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\numpy\np_elemwise_unary_op_basic.cc:L281</summary>
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="x">The input array.</param>
    static member NpiSin(outputArray : NDArray seq, x : NDArray) =
        let creator = AtomicSymbolCreator.FromName "_npi_sin"
        let names = Array.empty
        let vals = Array.empty
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg x)) then x.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <summary>Trigonometric sine, element-wise.
    /// .. math::
    ///    sin([0, \pi/4, \pi/2]) = [0, 0.707, 1]
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\numpy\np_elemwise_unary_op_basic.cc:L281</summary>
    /// <param name="x">The input array.</param>
    static member NpiSin([<Optional>] ?x : Symbol) =
        NpiSin(?x = x)

    /// <summary>Computes the element-wise cosine of the input array.
    /// .. math::
    ///    cos([0, \pi/4, \pi/2]) = [1, 0.707, 0]
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\numpy\np_elemwise_unary_op_basic.cc:L289</summary>
    /// <param name="x">The input array.</param>
    static member NpiCos(x : NDArray) =
        let creator = AtomicSymbolCreator.FromName "_npi_cos"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg x)) then x.UnsafeHandle|]
                                                 Array.empty
                                                 Array.empty
        (new NDArray(outputs.[0]))
    /// <summary>Computes the element-wise cosine of the input array.
    /// .. math::
    ///    cos([0, \pi/4, \pi/2]) = [1, 0.707, 0]
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\numpy\np_elemwise_unary_op_basic.cc:L289</summary>
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="x">The input array.</param>
    static member NpiCos(outputArray : NDArray seq, x : NDArray) =
        let creator = AtomicSymbolCreator.FromName "_npi_cos"
        let names = Array.empty
        let vals = Array.empty
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg x)) then x.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <summary>Computes the element-wise cosine of the input array.
    /// .. math::
    ///    cos([0, \pi/4, \pi/2]) = [1, 0.707, 0]
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\numpy\np_elemwise_unary_op_basic.cc:L289</summary>
    /// <param name="x">The input array.</param>
    static member NpiCos([<Optional>] ?x : Symbol) =
        NpiCos(?x = x)

    /// <summary>Computes the element-wise tangent of the input array.
    /// .. math::
    ///    tan([0, \pi/4, \pi/2]) = [0, 1, -inf]
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\numpy\np_elemwise_unary_op_basic.cc:L297</summary>
    /// <param name="x">The input array.</param>
    static member NpiTan(x : NDArray) =
        let creator = AtomicSymbolCreator.FromName "_npi_tan"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg x)) then x.UnsafeHandle|]
                                                 Array.empty
                                                 Array.empty
        (new NDArray(outputs.[0]))
    /// <summary>Computes the element-wise tangent of the input array.
    /// .. math::
    ///    tan([0, \pi/4, \pi/2]) = [0, 1, -inf]
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\numpy\np_elemwise_unary_op_basic.cc:L297</summary>
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="x">The input array.</param>
    static member NpiTan(outputArray : NDArray seq, x : NDArray) =
        let creator = AtomicSymbolCreator.FromName "_npi_tan"
        let names = Array.empty
        let vals = Array.empty
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg x)) then x.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <summary>Computes the element-wise tangent of the input array.
    /// .. math::
    ///    tan([0, \pi/4, \pi/2]) = [0, 1, -inf]
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\numpy\np_elemwise_unary_op_basic.cc:L297</summary>
    /// <param name="x">The input array.</param>
    static member NpiTan([<Optional>] ?x : Symbol) =
        NpiTan(?x = x)

    /// <summary>Returns element-wise inverse sine of the input array.
    /// .. math::
    ///    arcsin([-1, -.707, 0, .707, 1]) = [-\pi/2, -\pi/4, 0, \pi/4, \pi/2]
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\numpy\np_elemwise_unary_op_basic.cc:L305</summary>
    /// <param name="x">The input array.</param>
    static member NpiArcsin(x : NDArray) =
        let creator = AtomicSymbolCreator.FromName "_npi_arcsin"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg x)) then x.UnsafeHandle|]
                                                 Array.empty
                                                 Array.empty
        (new NDArray(outputs.[0]))
    /// <summary>Returns element-wise inverse sine of the input array.
    /// .. math::
    ///    arcsin([-1, -.707, 0, .707, 1]) = [-\pi/2, -\pi/4, 0, \pi/4, \pi/2]
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\numpy\np_elemwise_unary_op_basic.cc:L305</summary>
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="x">The input array.</param>
    static member NpiArcsin(outputArray : NDArray seq, x : NDArray) =
        let creator = AtomicSymbolCreator.FromName "_npi_arcsin"
        let names = Array.empty
        let vals = Array.empty
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg x)) then x.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <summary>Returns element-wise inverse sine of the input array.
    /// .. math::
    ///    arcsin([-1, -.707, 0, .707, 1]) = [-\pi/2, -\pi/4, 0, \pi/4, \pi/2]
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\numpy\np_elemwise_unary_op_basic.cc:L305</summary>
    /// <param name="x">The input array.</param>
    static member NpiArcsin([<Optional>] ?x : Symbol) =
        NpiArcsin(?x = x)

    /// <summary>Returns element-wise inverse cosine of the input array.
    /// The input should be in range `[-1, 1]`.
    /// The output is in the closed interval :math:`[0, \pi]`
    /// .. math::
    ///    arccos([-1, -.707, 0, .707, 1]) = [\pi, 3\pi/4, \pi/2, \pi/4, 0]
    /// The storage type of ``arccos`` output is always dense
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\numpy\np_elemwise_unary_op_basic.cc:L316</summary>
    /// <param name="x">The input array.</param>
    static member NpiArccos(x : NDArray) =
        let creator = AtomicSymbolCreator.FromName "_npi_arccos"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg x)) then x.UnsafeHandle|]
                                                 Array.empty
                                                 Array.empty
        (new NDArray(outputs.[0]))
    /// <summary>Returns element-wise inverse cosine of the input array.
    /// The input should be in range `[-1, 1]`.
    /// The output is in the closed interval :math:`[0, \pi]`
    /// .. math::
    ///    arccos([-1, -.707, 0, .707, 1]) = [\pi, 3\pi/4, \pi/2, \pi/4, 0]
    /// The storage type of ``arccos`` output is always dense
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\numpy\np_elemwise_unary_op_basic.cc:L316</summary>
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="x">The input array.</param>
    static member NpiArccos(outputArray : NDArray seq, x : NDArray) =
        let creator = AtomicSymbolCreator.FromName "_npi_arccos"
        let names = Array.empty
        let vals = Array.empty
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg x)) then x.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <summary>Returns element-wise inverse cosine of the input array.
    /// The input should be in range `[-1, 1]`.
    /// The output is in the closed interval :math:`[0, \pi]`
    /// .. math::
    ///    arccos([-1, -.707, 0, .707, 1]) = [\pi, 3\pi/4, \pi/2, \pi/4, 0]
    /// The storage type of ``arccos`` output is always dense
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\numpy\np_elemwise_unary_op_basic.cc:L316</summary>
    /// <param name="x">The input array.</param>
    static member NpiArccos([<Optional>] ?x : Symbol) =
        NpiArccos(?x = x)

    /// <summary>Returns element-wise inverse tangent of the input array.
    /// .. math::
    ///    arctan([-1, 0, 1]) = [-\pi/4, 0, \pi/4]
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\numpy\np_elemwise_unary_op_basic.cc:L324</summary>
    /// <param name="x">The input array.</param>
    static member NpiArctan(x : NDArray) =
        let creator = AtomicSymbolCreator.FromName "_npi_arctan"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg x)) then x.UnsafeHandle|]
                                                 Array.empty
                                                 Array.empty
        (new NDArray(outputs.[0]))
    /// <summary>Returns element-wise inverse tangent of the input array.
    /// .. math::
    ///    arctan([-1, 0, 1]) = [-\pi/4, 0, \pi/4]
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\numpy\np_elemwise_unary_op_basic.cc:L324</summary>
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="x">The input array.</param>
    static member NpiArctan(outputArray : NDArray seq, x : NDArray) =
        let creator = AtomicSymbolCreator.FromName "_npi_arctan"
        let names = Array.empty
        let vals = Array.empty
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg x)) then x.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <summary>Returns element-wise inverse tangent of the input array.
    /// .. math::
    ///    arctan([-1, 0, 1]) = [-\pi/4, 0, \pi/4]
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\numpy\np_elemwise_unary_op_basic.cc:L324</summary>
    /// <param name="x">The input array.</param>
    static member NpiArctan([<Optional>] ?x : Symbol) =
        NpiArctan(?x = x)

    /// <summary>Converts each element of the input array from radians to degrees.
    /// .. math::
    ///    degrees([0, \pi/2, \pi, 3\pi/2, 2\pi]) = [0, 90, 180, 270, 360]
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\numpy\np_elemwise_unary_op_basic.cc:L332</summary>
    /// <param name="x">The input array.</param>
    static member NpiDegrees(x : NDArray) =
        let creator = AtomicSymbolCreator.FromName "_npi_degrees"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg x)) then x.UnsafeHandle|]
                                                 Array.empty
                                                 Array.empty
        (new NDArray(outputs.[0]))
    /// <summary>Converts each element of the input array from radians to degrees.
    /// .. math::
    ///    degrees([0, \pi/2, \pi, 3\pi/2, 2\pi]) = [0, 90, 180, 270, 360]
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\numpy\np_elemwise_unary_op_basic.cc:L332</summary>
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="x">The input array.</param>
    static member NpiDegrees(outputArray : NDArray seq, x : NDArray) =
        let creator = AtomicSymbolCreator.FromName "_npi_degrees"
        let names = Array.empty
        let vals = Array.empty
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg x)) then x.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <summary>Converts each element of the input array from radians to degrees.
    /// .. math::
    ///    degrees([0, \pi/2, \pi, 3\pi/2, 2\pi]) = [0, 90, 180, 270, 360]
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\numpy\np_elemwise_unary_op_basic.cc:L332</summary>
    /// <param name="x">The input array.</param>
    static member NpiDegrees([<Optional>] ?x : Symbol) =
        NpiDegrees(?x = x)

    /// <summary>Converts each element of the input array from degrees to radians.
    /// .. math::
    ///    radians([0, 90, 180, 270, 360]) = [0, \pi/2, \pi, 3\pi/2, 2\pi]
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\numpy\np_elemwise_unary_op_basic.cc:L340</summary>
    /// <param name="x">The input array.</param>
    static member NpiRadians(x : NDArray) =
        let creator = AtomicSymbolCreator.FromName "_npi_radians"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg x)) then x.UnsafeHandle|]
                                                 Array.empty
                                                 Array.empty
        (new NDArray(outputs.[0]))
    /// <summary>Converts each element of the input array from degrees to radians.
    /// .. math::
    ///    radians([0, 90, 180, 270, 360]) = [0, \pi/2, \pi, 3\pi/2, 2\pi]
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\numpy\np_elemwise_unary_op_basic.cc:L340</summary>
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="x">The input array.</param>
    static member NpiRadians(outputArray : NDArray seq, x : NDArray) =
        let creator = AtomicSymbolCreator.FromName "_npi_radians"
        let names = Array.empty
        let vals = Array.empty
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg x)) then x.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <summary>Converts each element of the input array from degrees to radians.
    /// .. math::
    ///    radians([0, 90, 180, 270, 360]) = [0, \pi/2, \pi, 3\pi/2, 2\pi]
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\numpy\np_elemwise_unary_op_basic.cc:L340</summary>
    /// <param name="x">The input array.</param>
    static member NpiRadians([<Optional>] ?x : Symbol) =
        NpiRadians(?x = x)

    /// <summary>Returns the hyperbolic sine of the input array, computed element-wise.
    /// .. math::
    ///    sinh(x) = 0.5\times(exp(x) - exp(-x))
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\numpy\np_elemwise_unary_op_basic.cc:L348</summary>
    /// <param name="x">The input array.</param>
    static member NpiSinh(x : NDArray) =
        let creator = AtomicSymbolCreator.FromName "_npi_sinh"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg x)) then x.UnsafeHandle|]
                                                 Array.empty
                                                 Array.empty
        (new NDArray(outputs.[0]))
    /// <summary>Returns the hyperbolic sine of the input array, computed element-wise.
    /// .. math::
    ///    sinh(x) = 0.5\times(exp(x) - exp(-x))
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\numpy\np_elemwise_unary_op_basic.cc:L348</summary>
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="x">The input array.</param>
    static member NpiSinh(outputArray : NDArray seq, x : NDArray) =
        let creator = AtomicSymbolCreator.FromName "_npi_sinh"
        let names = Array.empty
        let vals = Array.empty
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg x)) then x.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <summary>Returns the hyperbolic sine of the input array, computed element-wise.
    /// .. math::
    ///    sinh(x) = 0.5\times(exp(x) - exp(-x))
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\numpy\np_elemwise_unary_op_basic.cc:L348</summary>
    /// <param name="x">The input array.</param>
    static member NpiSinh([<Optional>] ?x : Symbol) =
        NpiSinh(?x = x)

    /// <summary>Returns the hyperbolic cosine  of the input array, computed element-wise.
    /// .. math::
    ///    cosh(x) = 0.5\times(exp(x) + exp(-x))
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\numpy\np_elemwise_unary_op_basic.cc:L356</summary>
    /// <param name="x">The input array.</param>
    static member NpiCosh(x : NDArray) =
        let creator = AtomicSymbolCreator.FromName "_npi_cosh"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg x)) then x.UnsafeHandle|]
                                                 Array.empty
                                                 Array.empty
        (new NDArray(outputs.[0]))
    /// <summary>Returns the hyperbolic cosine  of the input array, computed element-wise.
    /// .. math::
    ///    cosh(x) = 0.5\times(exp(x) + exp(-x))
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\numpy\np_elemwise_unary_op_basic.cc:L356</summary>
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="x">The input array.</param>
    static member NpiCosh(outputArray : NDArray seq, x : NDArray) =
        let creator = AtomicSymbolCreator.FromName "_npi_cosh"
        let names = Array.empty
        let vals = Array.empty
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg x)) then x.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <summary>Returns the hyperbolic cosine  of the input array, computed element-wise.
    /// .. math::
    ///    cosh(x) = 0.5\times(exp(x) + exp(-x))
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\numpy\np_elemwise_unary_op_basic.cc:L356</summary>
    /// <param name="x">The input array.</param>
    static member NpiCosh([<Optional>] ?x : Symbol) =
        NpiCosh(?x = x)

    /// <summary>Returns the hyperbolic tangent of the input array, computed element-wise.
    /// .. math::
    ///    tanh(x) = sinh(x) / cosh(x)
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\numpy\np_elemwise_unary_op_basic.cc:L364</summary>
    /// <param name="x">The input array.</param>
    static member NpiTanh(x : NDArray) =
        let creator = AtomicSymbolCreator.FromName "_npi_tanh"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg x)) then x.UnsafeHandle|]
                                                 Array.empty
                                                 Array.empty
        (new NDArray(outputs.[0]))
    /// <summary>Returns the hyperbolic tangent of the input array, computed element-wise.
    /// .. math::
    ///    tanh(x) = sinh(x) / cosh(x)
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\numpy\np_elemwise_unary_op_basic.cc:L364</summary>
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="x">The input array.</param>
    static member NpiTanh(outputArray : NDArray seq, x : NDArray) =
        let creator = AtomicSymbolCreator.FromName "_npi_tanh"
        let names = Array.empty
        let vals = Array.empty
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg x)) then x.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <summary>Returns the hyperbolic tangent of the input array, computed element-wise.
    /// .. math::
    ///    tanh(x) = sinh(x) / cosh(x)
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\numpy\np_elemwise_unary_op_basic.cc:L364</summary>
    /// <param name="x">The input array.</param>
    static member NpiTanh([<Optional>] ?x : Symbol) =
        NpiTanh(?x = x)

    /// <summary>Returns the element-wise inverse hyperbolic sine of the input array, \
    /// computed element-wise.
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\numpy\np_elemwise_unary_op_basic.cc:L371</summary>
    /// <param name="x">The input array.</param>
    static member NpiArcsinh(x : NDArray) =
        let creator = AtomicSymbolCreator.FromName "_npi_arcsinh"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg x)) then x.UnsafeHandle|]
                                                 Array.empty
                                                 Array.empty
        (new NDArray(outputs.[0]))
    /// <summary>Returns the element-wise inverse hyperbolic sine of the input array, \
    /// computed element-wise.
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\numpy\np_elemwise_unary_op_basic.cc:L371</summary>
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="x">The input array.</param>
    static member NpiArcsinh(outputArray : NDArray seq, x : NDArray) =
        let creator = AtomicSymbolCreator.FromName "_npi_arcsinh"
        let names = Array.empty
        let vals = Array.empty
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg x)) then x.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <summary>Returns the element-wise inverse hyperbolic sine of the input array, \
    /// computed element-wise.
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\numpy\np_elemwise_unary_op_basic.cc:L371</summary>
    /// <param name="x">The input array.</param>
    static member NpiArcsinh([<Optional>] ?x : Symbol) =
        NpiArcsinh(?x = x)

    /// <summary>Returns the element-wise inverse hyperbolic cosine of the input array, \
    /// computed element-wise.
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\numpy\np_elemwise_unary_op_basic.cc:L378</summary>
    /// <param name="x">The input array.</param>
    static member NpiArccosh(x : NDArray) =
        let creator = AtomicSymbolCreator.FromName "_npi_arccosh"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg x)) then x.UnsafeHandle|]
                                                 Array.empty
                                                 Array.empty
        (new NDArray(outputs.[0]))
    /// <summary>Returns the element-wise inverse hyperbolic cosine of the input array, \
    /// computed element-wise.
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\numpy\np_elemwise_unary_op_basic.cc:L378</summary>
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="x">The input array.</param>
    static member NpiArccosh(outputArray : NDArray seq, x : NDArray) =
        let creator = AtomicSymbolCreator.FromName "_npi_arccosh"
        let names = Array.empty
        let vals = Array.empty
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg x)) then x.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <summary>Returns the element-wise inverse hyperbolic cosine of the input array, \
    /// computed element-wise.
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\numpy\np_elemwise_unary_op_basic.cc:L378</summary>
    /// <param name="x">The input array.</param>
    static member NpiArccosh([<Optional>] ?x : Symbol) =
        NpiArccosh(?x = x)

    /// <summary>Returns the element-wise inverse hyperbolic tangent of the input array, \
    /// computed element-wise.
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\numpy\np_elemwise_unary_op_basic.cc:L385</summary>
    /// <param name="x">The input array.</param>
    static member NpiArctanh(x : NDArray) =
        let creator = AtomicSymbolCreator.FromName "_npi_arctanh"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg x)) then x.UnsafeHandle|]
                                                 Array.empty
                                                 Array.empty
        (new NDArray(outputs.[0]))
    /// <summary>Returns the element-wise inverse hyperbolic tangent of the input array, \
    /// computed element-wise.
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\numpy\np_elemwise_unary_op_basic.cc:L385</summary>
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="x">The input array.</param>
    static member NpiArctanh(outputArray : NDArray seq, x : NDArray) =
        let creator = AtomicSymbolCreator.FromName "_npi_arctanh"
        let names = Array.empty
        let vals = Array.empty
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg x)) then x.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <summary>Returns the element-wise inverse hyperbolic tangent of the input array, \
    /// computed element-wise.
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\numpy\np_elemwise_unary_op_basic.cc:L385</summary>
    /// <param name="x">The input array.</param>
    static member NpiArctanh([<Optional>] ?x : Symbol) =
        NpiArctanh(?x = x)

    /// <param name="x">Input ndarray</param>
    /// <param name="decimals">Number of decimal places to round to.</param>
    static member NpiAround(x : NDArray, [<Optional; DefaultParameterValue(0)>] decimals : int) =
        let creator = AtomicSymbolCreator.FromName "_npi_around"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg x)) then x.UnsafeHandle|]
                                                 [|"decimals"|]
                                                 [|string decimals|]
        (new NDArray(outputs.[0]))
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="x">Input ndarray</param>
    /// <param name="decimals">Number of decimal places to round to.</param>
    static member NpiAround(outputArray : NDArray seq, x : NDArray, [<Optional; DefaultParameterValue(0)>] decimals : int) =
        let creator = AtomicSymbolCreator.FromName "_npi_around"
        let names = [|"decimals"|]
        let vals = [|string decimals|]
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg x)) then x.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <param name="x">Input ndarray</param>
    /// <param name="decimals">Number of decimal places to round to.</param>
    static member NpiAround([<Optional>] ?x : Symbol, [<Optional>] ?decimals : int) =
        NpiAround(?x = x, ?decimals = decimals)

    /// <summary>
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\numpy\np_elemwise_unary_op_basic.cc:L425</summary>
    /// <param name="data">Input ndarray</param>
    /// <param name="copy">Whether to create a copy of `x` (True) or to replace valuesin-place (False). The in-place operation only occurs ifcasting to an array does not require a copy.Default is True.</param>
    /// <param name="nan">Value to be used to fill NaN values. If no value is passedthen NaN values will be replaced with 0.0.</param>
    /// <param name="posinf">Value to be used to fill positive infinity values.If no value is passed then positive infinity values will bereplaced with a very large number.</param>
    /// <param name="neginf">Value to be used to fill negative infinity values.If no value is passed then negative infinity valueswill be replaced with a very small (or negative) number.</param>
    static member NpiNanToNum(data : NDArray, 
                              [<Optional>] ?copy : bool, 
                              [<Optional>] ?nan : double, 
                              [<Optional>] ?posinf : float, 
                              [<Optional>] ?neginf : float) =
        let creator = AtomicSymbolCreator.FromName "_npi_nan_to_num"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle|]
                                                 [|"copy"; "nan"; "posinf"; "neginf"|]
                                                 [|(match copy with None -> "true" | Some copy -> string copy); (match nan with None -> "0.0" | Some nan -> string nan); (match posinf with None -> "None" | Some posinf -> string posinf); (match neginf with None -> "None" | Some neginf -> string neginf)|]
        outputs |> Array.map (fun h -> new NDArray(h))
    /// <summary>
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\numpy\np_elemwise_unary_op_basic.cc:L425</summary>
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="data">Input ndarray</param>
    /// <param name="copy">Whether to create a copy of `x` (True) or to replace valuesin-place (False). The in-place operation only occurs ifcasting to an array does not require a copy.Default is True.</param>
    /// <param name="nan">Value to be used to fill NaN values. If no value is passedthen NaN values will be replaced with 0.0.</param>
    /// <param name="posinf">Value to be used to fill positive infinity values.If no value is passed then positive infinity values will bereplaced with a very large number.</param>
    /// <param name="neginf">Value to be used to fill negative infinity values.If no value is passed then negative infinity valueswill be replaced with a very small (or negative) number.</param>
    static member NpiNanToNum(outputArray : NDArray seq, 
                              data : NDArray, 
                              [<Optional>] ?copy : bool, 
                              [<Optional>] ?nan : double, 
                              [<Optional>] ?posinf : float, 
                              [<Optional>] ?neginf : float) =
        let creator = AtomicSymbolCreator.FromName "_npi_nan_to_num"
        let names = [|"copy"; "nan"; "posinf"; "neginf"|]
        let vals = [|(match copy with None -> "true" | Some copy -> string copy); (match nan with None -> "0.0" | Some nan -> string nan); (match posinf with None -> "None" | Some posinf -> string posinf); (match neginf with None -> "None" | Some neginf -> string neginf)|]
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <summary>
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\numpy\np_elemwise_unary_op_basic.cc:L425</summary>
    /// <param name="data">Input ndarray</param>
    /// <param name="copy">Whether to create a copy of `x` (True) or to replace valuesin-place (False). The in-place operation only occurs ifcasting to an array does not require a copy.Default is True.</param>
    /// <param name="nan">Value to be used to fill NaN values. If no value is passedthen NaN values will be replaced with 0.0.</param>
    /// <param name="posinf">Value to be used to fill positive infinity values.If no value is passed then positive infinity values will bereplaced with a very large number.</param>
    /// <param name="neginf">Value to be used to fill negative infinity values.If no value is passed then negative infinity valueswill be replaced with a very small (or negative) number.</param>
    static member NpiNanToNum([<Optional>] ?data : Symbol, [<Optional>] ?copy : bool, [<Optional>] ?nan : double, [<Optional>] ?posinf : float, [<Optional>] ?neginf : float) =
        NpiNanToNum(?data = data, ?copy = copy, ?nan = nan, ?posinf = posinf, ?neginf = neginf)

    static member NpiBackwardNanToNumNDArray() =
        let creator = AtomicSymbolCreator.FromName "_npi_backward_nan_to_num"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 Array.empty
                                                 Array.empty
                                                 Array.empty
        outputs |> Array.map (fun h -> new NDArray(h))
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    static member NpiBackwardNanToNum(outputArray : NDArray seq) =
        let creator = AtomicSymbolCreator.FromName "_npi_backward_nan_to_num"
        let names = Array.empty
        let vals = Array.empty
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     Array.empty
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    static member NpiBackwardNanToNum() =
        NpiBackwardNanToNum()

    /// <param name="ctx">Context of output, in format [cpu|gpu|cpu_pinned](n).Only used for imperative calls.</param>
    /// <param name="shape">The shape of the output</param>
    /// <param name="dtype">Target data type.</param>
    static member NpiZerosNDArray(ctx : Context, [<Optional>] shape : int seq, [<Optional>] dtype : DataType) =
        let creator = AtomicSymbolCreator.FromName "_npi_zeros"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 Array.empty
                                                 [|"ctx"; "shape"; "dtype"|]
                                                 [|string ctx; (if isNull (shape :> obj) then "[]" else (shape |> Seq.map string |> String.concat ", " |> sprintf "[%s]")); (if isNull (dtype :> obj) then "float32" else string dtype)|]
        (new NDArray(outputs.[0]))
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="ctx">Context of output, in format [cpu|gpu|cpu_pinned](n).Only used for imperative calls.</param>
    /// <param name="shape">The shape of the output</param>
    /// <param name="dtype">Target data type.</param>
    static member NpiZeros(outputArray : NDArray seq, ctx : Context, [<Optional>] shape : int seq, [<Optional>] dtype : DataType) =
        let creator = AtomicSymbolCreator.FromName "_npi_zeros"
        let names = [|"ctx"; "shape"; "dtype"|]
        let vals = [|string ctx; (if isNull (shape :> obj) then "[]" else (shape |> Seq.map string |> String.concat ", " |> sprintf "[%s]")); (if isNull (dtype :> obj) then "float32" else string dtype)|]
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     Array.empty
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <param name="shape">The shape of the output</param>
    /// <param name="dtype">Target data type.</param>
    static member NpiZeros([<Optional>] ?shape : int seq, [<Optional>] ?dtype : DataType) =
        NpiZeros(?shape = shape, ?dtype = dtype)

    /// <summary>Return a new array of given shape, type, and context, filled with ones.</summary>
    /// <param name="ctx">Context of output, in format [cpu|gpu|cpu_pinned](n).Only used for imperative calls.</param>
    /// <param name="shape">The shape of the output</param>
    /// <param name="dtype">Target data type.</param>
    static member NpiOnesNDArray(ctx : Context, [<Optional>] shape : int seq, [<Optional>] dtype : DataType) =
        let creator = AtomicSymbolCreator.FromName "_npi_ones"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 Array.empty
                                                 [|"ctx"; "shape"; "dtype"|]
                                                 [|string ctx; (if isNull (shape :> obj) then "[]" else (shape |> Seq.map string |> String.concat ", " |> sprintf "[%s]")); (if isNull (dtype :> obj) then "float32" else string dtype)|]
        (new NDArray(outputs.[0]))
    /// <summary>Return a new array of given shape, type, and context, filled with ones.</summary>
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="ctx">Context of output, in format [cpu|gpu|cpu_pinned](n).Only used for imperative calls.</param>
    /// <param name="shape">The shape of the output</param>
    /// <param name="dtype">Target data type.</param>
    static member NpiOnes(outputArray : NDArray seq, ctx : Context, [<Optional>] shape : int seq, [<Optional>] dtype : DataType) =
        let creator = AtomicSymbolCreator.FromName "_npi_ones"
        let names = [|"ctx"; "shape"; "dtype"|]
        let vals = [|string ctx; (if isNull (shape :> obj) then "[]" else (shape |> Seq.map string |> String.concat ", " |> sprintf "[%s]")); (if isNull (dtype :> obj) then "float32" else string dtype)|]
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     Array.empty
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <summary>Return a new array of given shape, type, and context, filled with ones.</summary>
    /// <param name="shape">The shape of the output</param>
    /// <param name="dtype">Target data type.</param>
    static member NpiOnes([<Optional>] ?shape : int seq, [<Optional>] ?dtype : DataType) =
        NpiOnes(?shape = shape, ?dtype = dtype)

    /// <summary>Return a new identity array of given shape, type, and context.</summary>
    /// <param name="ctx">Context of output, in format [cpu|gpu|cpu_pinned](n).Only used for imperative calls.</param>
    /// <param name="shape">The shape of the output</param>
    /// <param name="dtype">Target data type.</param>
    static member NpiIdentityNDArray(ctx : Context, [<Optional>] shape : int seq, [<Optional>] dtype : DataType) =
        let creator = AtomicSymbolCreator.FromName "_npi_identity"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 Array.empty
                                                 [|"ctx"; "shape"; "dtype"|]
                                                 [|string ctx; (if isNull (shape :> obj) then "[]" else (shape |> Seq.map string |> String.concat ", " |> sprintf "[%s]")); (if isNull (dtype :> obj) then "float32" else string dtype)|]
        (new NDArray(outputs.[0]))
    /// <summary>Return a new identity array of given shape, type, and context.</summary>
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="ctx">Context of output, in format [cpu|gpu|cpu_pinned](n).Only used for imperative calls.</param>
    /// <param name="shape">The shape of the output</param>
    /// <param name="dtype">Target data type.</param>
    static member NpiIdentity(outputArray : NDArray seq, ctx : Context, [<Optional>] shape : int seq, [<Optional>] dtype : DataType) =
        let creator = AtomicSymbolCreator.FromName "_npi_identity"
        let names = [|"ctx"; "shape"; "dtype"|]
        let vals = [|string ctx; (if isNull (shape :> obj) then "[]" else (shape |> Seq.map string |> String.concat ", " |> sprintf "[%s]")); (if isNull (dtype :> obj) then "float32" else string dtype)|]
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     Array.empty
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <summary>Return a new identity array of given shape, type, and context.</summary>
    /// <param name="shape">The shape of the output</param>
    /// <param name="dtype">Target data type.</param>
    static member NpiIdentity([<Optional>] ?shape : int seq, [<Optional>] ?dtype : DataType) =
        NpiIdentity(?shape = shape, ?dtype = dtype)

    /// <param name="a">The shape and data-type of a define these same attributes of the returned array.</param>
    static member NpZerosLike(a : NDArray) =
        let creator = AtomicSymbolCreator.FromName "_np_zeros_like"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg a)) then a.UnsafeHandle|]
                                                 Array.empty
                                                 Array.empty
        (new NDArray(outputs.[0]))
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="a">The shape and data-type of a define these same attributes of the returned array.</param>
    static member NpZerosLike(outputArray : NDArray seq, a : NDArray) =
        let creator = AtomicSymbolCreator.FromName "_np_zeros_like"
        let names = Array.empty
        let vals = Array.empty
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg a)) then a.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <param name="a">The shape and data-type of a define these same attributes of the returned array.</param>
    static member NpZerosLike([<Optional>] ?a : Symbol) =
        NpZerosLike(?a = a)

    /// <param name="a">The shape and data-type of a define these same attributes of the returned array.</param>
    static member NpOnesLike(a : NDArray) =
        let creator = AtomicSymbolCreator.FromName "_np_ones_like"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg a)) then a.UnsafeHandle|]
                                                 Array.empty
                                                 Array.empty
        (new NDArray(outputs.[0]))
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="a">The shape and data-type of a define these same attributes of the returned array.</param>
    static member NpOnesLike(outputArray : NDArray seq, a : NDArray) =
        let creator = AtomicSymbolCreator.FromName "_np_ones_like"
        let names = Array.empty
        let vals = Array.empty
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg a)) then a.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <param name="a">The shape and data-type of a define these same attributes of the returned array.</param>
    static member NpOnesLike([<Optional>] ?a : Symbol) =
        NpOnesLike(?a = a)

    /// <param name="start">Start of interval. The interval includes this value. The default start value is 0.</param>
    /// <param name="ctx">Context of output, in format [cpu|gpu|cpu_pinned](n).Only used for imperative calls.</param>
    /// <param name="stop">End of interval. The interval does not include this value, except in some cases where step is not an integer and floating point round-off affects the length of out.</param>
    /// <param name="step">Spacing between values.</param>
    /// <param name="repeat">The repeating time of all elements. E.g repeat=3, the element a will be repeated three times --&gt; a, a, a.</param>
    /// <param name="inferRange">When set to True, infer the stop position from the start, step, repeat, and output tensor size.</param>
    /// <param name="dtype">Target data type.</param>
    static member NpiArangeNDArray(start : double, 
                                   ctx : Context, 
                                   [<Optional>] ?stop : float, 
                                   [<Optional>] ?step : double, 
                                   [<Optional>] ?repeat : int, 
                                   [<Optional>] ?inferRange : bool, 
                                   [<Optional>] ?dtype : DataType) =
        let creator = AtomicSymbolCreator.FromName "_npi_arange"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 Array.empty
                                                 [|"start"; "ctx"; "stop"; "step"; "repeat"; "infer_range"; "dtype"|]
                                                 [|string start; string ctx; (match stop with None -> "None" | Some stop -> string stop); (match step with None -> "1.0" | Some step -> string step); (match repeat with None -> "1" | Some repeat -> string repeat); (match inferRange with None -> "false" | Some inferRange -> string inferRange); (match dtype with None -> "float32" | Some dtype -> string dtype)|]
        (new NDArray(outputs.[0]))
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="start">Start of interval. The interval includes this value. The default start value is 0.</param>
    /// <param name="ctx">Context of output, in format [cpu|gpu|cpu_pinned](n).Only used for imperative calls.</param>
    /// <param name="stop">End of interval. The interval does not include this value, except in some cases where step is not an integer and floating point round-off affects the length of out.</param>
    /// <param name="step">Spacing between values.</param>
    /// <param name="repeat">The repeating time of all elements. E.g repeat=3, the element a will be repeated three times --&gt; a, a, a.</param>
    /// <param name="inferRange">When set to True, infer the stop position from the start, step, repeat, and output tensor size.</param>
    /// <param name="dtype">Target data type.</param>
    static member NpiArange(outputArray : NDArray seq, 
                            start : double, 
                            ctx : Context, 
                            [<Optional>] ?stop : float, 
                            [<Optional>] ?step : double, 
                            [<Optional>] ?repeat : int, 
                            [<Optional>] ?inferRange : bool, 
                            [<Optional>] ?dtype : DataType) =
        let creator = AtomicSymbolCreator.FromName "_npi_arange"
        let names = [|"start"; "ctx"; "stop"; "step"; "repeat"; "infer_range"; "dtype"|]
        let vals = [|string start; string ctx; (match stop with None -> "None" | Some stop -> string stop); (match step with None -> "1.0" | Some step -> string step); (match repeat with None -> "1" | Some repeat -> string repeat); (match inferRange with None -> "false" | Some inferRange -> string inferRange); (match dtype with None -> "float32" | Some dtype -> string dtype)|]
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     Array.empty
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <param name="start">Start of interval. The interval includes this value. The default start value is 0.</param>
    /// <param name="stop">End of interval. The interval does not include this value, except in some cases where step is not an integer and floating point round-off affects the length of out.</param>
    /// <param name="step">Spacing between values.</param>
    /// <param name="repeat">The repeating time of all elements. E.g repeat=3, the element a will be repeated three times --&gt; a, a, a.</param>
    /// <param name="inferRange">When set to True, infer the stop position from the start, step, repeat, and output tensor size.</param>
    /// <param name="dtype">Target data type.</param>
    static member NpiArange(start : double, [<Optional>] ?stop : float, [<Optional>] ?step : double, [<Optional>] ?repeat : int, [<Optional>] ?inferRange : bool, [<Optional>] ?dtype : DataType) =
        NpiArange(start, ?stop = stop, ?step = step, ?repeat = repeat, ?inferRange = inferRange, ?dtype = dtype)

    /// <summary>Return a 2-D array with ones on the diagonal and zeros elsewhere.</summary>
    /// <param name="N">Number of rows in the output.</param>
    /// <param name="M">Number of columns in the output. If None, defaults to N.</param>
    /// <param name="ctx">Context of output, in format [cpu|gpu|cpu_pinned](n).Only used for imperative calls.</param>
    /// <param name="k">Index of the diagonal. 0 (the default) refers to the main diagonal,a positive value refers to an upper diagonal.and a negative value to a lower diagonal.</param>
    /// <param name="dtype">Data-type of the returned array.</param>
    static member NpiEyeNDArray(N : int64, 
                                M : int64, 
                                ctx : Context, 
                                [<Optional; DefaultParameterValue(0L)>] k : int64, 
                                [<Optional>] dtype : DataType) =
        let creator = AtomicSymbolCreator.FromName "_npi_eye"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 Array.empty
                                                 [|"N"; "M"; "ctx"; "k"; "dtype"|]
                                                 [|string N; string M; string ctx; string k; (if isNull (dtype :> obj) then "float32" else string dtype)|]
        outputs |> Array.map (fun h -> new NDArray(h))
    /// <summary>Return a 2-D array with ones on the diagonal and zeros elsewhere.</summary>
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="N">Number of rows in the output.</param>
    /// <param name="M">Number of columns in the output. If None, defaults to N.</param>
    /// <param name="ctx">Context of output, in format [cpu|gpu|cpu_pinned](n).Only used for imperative calls.</param>
    /// <param name="k">Index of the diagonal. 0 (the default) refers to the main diagonal,a positive value refers to an upper diagonal.and a negative value to a lower diagonal.</param>
    /// <param name="dtype">Data-type of the returned array.</param>
    static member NpiEye(outputArray : NDArray seq, 
                         N : int64, 
                         M : int64, 
                         ctx : Context, 
                         [<Optional; DefaultParameterValue(0L)>] k : int64, 
                         [<Optional>] dtype : DataType) =
        let creator = AtomicSymbolCreator.FromName "_npi_eye"
        let names = [|"N"; "M"; "ctx"; "k"; "dtype"|]
        let vals = [|string N; string M; string ctx; string k; (if isNull (dtype :> obj) then "float32" else string dtype)|]
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     Array.empty
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <summary>Return a 2-D array with ones on the diagonal and zeros elsewhere.</summary>
    /// <param name="N">Number of rows in the output.</param>
    /// <param name="M">Number of columns in the output. If None, defaults to N.</param>
    /// <param name="k">Index of the diagonal. 0 (the default) refers to the main diagonal,a positive value refers to an upper diagonal.and a negative value to a lower diagonal.</param>
    /// <param name="dtype">Data-type of the returned array.</param>
    static member NpiEye(N : int64, M : int64, [<Optional>] ?k : int64, [<Optional>] ?dtype : DataType) =
        NpiEye(N, M, ?k = k, ?dtype = dtype)

    /// <summary>Return an array representing the indices of a grid.</summary>
    /// <param name="dimensions">The shape of the grid.</param>
    /// <param name="ctx">Context of output, in format [cpu|gpu|cpu_pinned](n).Only used for imperative calls.</param>
    /// <param name="dtype">Target data type.</param>
    static member NpiIndicesNDArray(dimensions : int seq, ctx : Context, [<Optional>] dtype : DataType) =
        let creator = AtomicSymbolCreator.FromName "_npi_indices"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 Array.empty
                                                 [|"dimensions"; "ctx"; "dtype"|]
                                                 [|(dimensions |> Seq.map string |> String.concat ", " |> sprintf "[%s]"); string ctx; (if isNull (dtype :> obj) then "int32" else string dtype)|]
        (new NDArray(outputs.[0]))
    /// <summary>Return an array representing the indices of a grid.</summary>
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="dimensions">The shape of the grid.</param>
    /// <param name="ctx">Context of output, in format [cpu|gpu|cpu_pinned](n).Only used for imperative calls.</param>
    /// <param name="dtype">Target data type.</param>
    static member NpiIndices(outputArray : NDArray seq, dimensions : int seq, ctx : Context, [<Optional>] dtype : DataType) =
        let creator = AtomicSymbolCreator.FromName "_npi_indices"
        let names = [|"dimensions"; "ctx"; "dtype"|]
        let vals = [|(dimensions |> Seq.map string |> String.concat ", " |> sprintf "[%s]"); string ctx; (if isNull (dtype :> obj) then "int32" else string dtype)|]
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     Array.empty
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <summary>Return an array representing the indices of a grid.</summary>
    /// <param name="dimensions">The shape of the grid.</param>
    /// <param name="dtype">Target data type.</param>
    static member NpiIndices(dimensions : int seq, [<Optional>] ?dtype : DataType) =
        NpiIndices(dimensions, ?dtype = dtype)

    /// <summary>Return numbers spaced evenly on a log scale.</summary>
    /// <param name="start">The starting value of the sequence.</param>
    /// <param name="stop">The ending value of the sequence</param>
    /// <param name="num">Number of samples to generate. Must be non-negative.</param>
    /// <param name="ctx">Context of output, in format [cpu|gpu|cpu_pinned](n).Only used for imperative calls.</param>
    /// <param name="endpoint">If True, stop is the last sample. Otherwise, it is not included.</param>
    /// <param name="lbase">The base of the log space. The step size between the elements in ln(samples) / ln(base) (or log_base(samples)) is uniform.</param>
    /// <param name="dtype">Target data type.</param>
    static member NpiLogspaceNDArray(start : double, 
                                     stop : double, 
                                     num : int, 
                                     ctx : Context, 
                                     [<Optional; DefaultParameterValue(true)>] endpoint : bool, 
                                     [<Optional; DefaultParameterValue(10.0)>] lbase : double, 
                                     [<Optional>] dtype : DataType) =
        let creator = AtomicSymbolCreator.FromName "_npi_logspace"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 Array.empty
                                                 [|"start"; "stop"; "num"; "ctx"; "endpoint"; "base"; "dtype"|]
                                                 [|string start; string stop; string num; string ctx; string endpoint; string lbase; (if isNull (dtype :> obj) then "float32" else string dtype)|]
        outputs |> Array.map (fun h -> new NDArray(h))
    /// <summary>Return numbers spaced evenly on a log scale.</summary>
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="start">The starting value of the sequence.</param>
    /// <param name="stop">The ending value of the sequence</param>
    /// <param name="num">Number of samples to generate. Must be non-negative.</param>
    /// <param name="ctx">Context of output, in format [cpu|gpu|cpu_pinned](n).Only used for imperative calls.</param>
    /// <param name="endpoint">If True, stop is the last sample. Otherwise, it is not included.</param>
    /// <param name="lbase">The base of the log space. The step size between the elements in ln(samples) / ln(base) (or log_base(samples)) is uniform.</param>
    /// <param name="dtype">Target data type.</param>
    static member NpiLogspace(outputArray : NDArray seq, 
                              start : double, 
                              stop : double, 
                              num : int, 
                              ctx : Context, 
                              [<Optional; DefaultParameterValue(true)>] endpoint : bool, 
                              [<Optional; DefaultParameterValue(10.0)>] lbase : double, 
                              [<Optional>] dtype : DataType) =
        let creator = AtomicSymbolCreator.FromName "_npi_logspace"
        let names = [|"start"; "stop"; "num"; "ctx"; "endpoint"; "base"; "dtype"|]
        let vals = [|string start; string stop; string num; string ctx; string endpoint; string lbase; (if isNull (dtype :> obj) then "float32" else string dtype)|]
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     Array.empty
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <summary>Return numbers spaced evenly on a log scale.</summary>
    /// <param name="start">The starting value of the sequence.</param>
    /// <param name="stop">The ending value of the sequence</param>
    /// <param name="num">Number of samples to generate. Must be non-negative.</param>
    /// <param name="endpoint">If True, stop is the last sample. Otherwise, it is not included.</param>
    /// <param name="lbase">The base of the log space. The step size between the elements in ln(samples) / ln(base) (or log_base(samples)) is uniform.</param>
    /// <param name="dtype">Target data type.</param>
    static member NpiLogspace(start : double, stop : double, num : int, [<Optional>] ?endpoint : bool, [<Optional>] ?lbase : double, [<Optional>] ?dtype : DataType) =
        NpiLogspace(start, stop, num, ?endpoint = endpoint, ?lbase = lbase, ?dtype = dtype)

    /// <param name="a">Source input</param>
    /// <param name="axes">By default, reverse the dimensions, otherwise permute the axes according to the values given.</param>
    static member NpTranspose(a : NDArray, [<Optional>] axes : int seq) =
        let creator = AtomicSymbolCreator.FromName "_np_transpose"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg a)) then a.UnsafeHandle|]
                                                 [|"axes"|]
                                                 [|(if isNull (axes :> obj) then null else (axes |> Seq.map string |> String.concat ", " |> sprintf "[%s]"))|]
        (new NDArray(outputs.[0]))
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="a">Source input</param>
    /// <param name="axes">By default, reverse the dimensions, otherwise permute the axes according to the values given.</param>
    static member NpTranspose(outputArray : NDArray seq, a : NDArray, [<Optional>] axes : int seq) =
        let creator = AtomicSymbolCreator.FromName "_np_transpose"
        let names = [|"axes"|]
        let vals = [|(if isNull (axes :> obj) then null else (axes |> Seq.map string |> String.concat ", " |> sprintf "[%s]"))|]
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg a)) then a.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <param name="a">Source input</param>
    /// <param name="axes">By default, reverse the dimensions, otherwise permute the axes according to the values given.</param>
    static member NpTranspose([<Optional>] ?a : Symbol, [<Optional>] ?axes : int seq) =
        NpTranspose(?a = a, ?axes = axes)

    /// <summary>
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\numpy\np_matrix_op.cc:L349</summary>
    /// <param name="a">Array to be reshaped.</param>
    /// <param name="newshape">The new shape should be compatible with the original shape. If an integer, then the result will be a 1-D array of that length. One shape dimension can be -1. In this case, the value is inferred from the length of the array and remaining dimensions.</param>
    /// <param name="order">Read the elements of a using this index order, and place the elements into the reshaped array using this index order. &#39;C&#39; means to read/write the elements using C-like index order, with the last axis index changing fastest, back to the first axis index changing slowest. Note that currently only C-like order is supported</param>
    static member NpReshape(a : NDArray, newshape : int seq, [<Optional; DefaultParameterValue("C")>] order : string) =
        let creator = AtomicSymbolCreator.FromName "_np_reshape"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg a)) then a.UnsafeHandle|]
                                                 [|"newshape"; "order"|]
                                                 [|(newshape |> Seq.map string |> String.concat ", " |> sprintf "[%s]"); order|]
        (new NDArray(outputs.[0]))
    /// <summary>
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\numpy\np_matrix_op.cc:L349</summary>
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="a">Array to be reshaped.</param>
    /// <param name="newshape">The new shape should be compatible with the original shape. If an integer, then the result will be a 1-D array of that length. One shape dimension can be -1. In this case, the value is inferred from the length of the array and remaining dimensions.</param>
    /// <param name="order">Read the elements of a using this index order, and place the elements into the reshaped array using this index order. &#39;C&#39; means to read/write the elements using C-like index order, with the last axis index changing fastest, back to the first axis index changing slowest. Note that currently only C-like order is supported</param>
    static member NpReshape(outputArray : NDArray seq, a : NDArray, newshape : int seq, [<Optional; DefaultParameterValue("C")>] order : string) =
        let creator = AtomicSymbolCreator.FromName "_np_reshape"
        let names = [|"newshape"; "order"|]
        let vals = [|(newshape |> Seq.map string |> String.concat ", " |> sprintf "[%s]"); order|]
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg a)) then a.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <summary>
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\numpy\np_matrix_op.cc:L349</summary>
    /// <param name="a">Array to be reshaped.</param>
    /// <param name="newshape">The new shape should be compatible with the original shape. If an integer, then the result will be a 1-D array of that length. One shape dimension can be -1. In this case, the value is inferred from the length of the array and remaining dimensions.</param>
    /// <param name="order">Read the elements of a using this index order, and place the elements into the reshaped array using this index order. &#39;C&#39; means to read/write the elements using C-like index order, with the last axis index changing fastest, back to the first axis index changing slowest. Note that currently only C-like order is supported</param>
    static member NpReshape(a : Symbol, newshape : int seq, [<Optional>] ?order : string) =
        NpReshape(a, newshape, ?order = order)
    /// <summary>
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\numpy\np_matrix_op.cc:L349</summary>
    /// <param name="newshape">The new shape should be compatible with the original shape. If an integer, then the result will be a 1-D array of that length. One shape dimension can be -1. In this case, the value is inferred from the length of the array and remaining dimensions.</param>
    /// <param name="a">Array to be reshaped.</param>
    /// <param name="order">Read the elements of a using this index order, and place the elements into the reshaped array using this index order. &#39;C&#39; means to read/write the elements using C-like index order, with the last axis index changing fastest, back to the first axis index changing slowest. Note that currently only C-like order is supported</param>
    static member NpReshape(newshape : int seq, [<Optional>] ?a : Symbol, [<Optional>] ?order : string) =
        NpReshape(newshape, ?a = a, ?order = order)

    /// <summary>
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\numpy\np_matrix_op.cc:L375</summary>
    /// <param name="a">Array to be reshaped.</param>
    /// <param name="newshape">The new shape should be compatible with the original shape. If an integer, then the result will be a 1-D array of that length. One shape dimension can be -1. In this case, the value is inferred from the length of the array and remaining dimensions. -2 to -6 are used for data manipulation. -2 copy this dimension from the input to the output shape. -3 will skip current dimension if and only if the current dim size is one. -4 copy all remain of the input dimensions to the output shape. -5 use the product of two consecutive dimensions of the input shape as the output. -6 split one dimension of the input into two dimensions passed subsequent to -6 in the new shape.</param>
    /// <param name="reverse">If true then the special values are inferred from right to left</param>
    /// <param name="order">Read the elements of a using this index order, and place the elements into the reshaped array using this index order. &#39;C&#39; means to read/write the elements using C-like index order, with the last axis index changing fastest, back to the first axis index changing slowest. Note that currently only C-like order is supported</param>
    static member NpxReshape(a : NDArray, newshape : int seq, [<Optional; DefaultParameterValue(false)>] reverse : bool, [<Optional; DefaultParameterValue("C")>] order : string) =
        let creator = AtomicSymbolCreator.FromName "_npx_reshape"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg a)) then a.UnsafeHandle|]
                                                 [|"newshape"; "reverse"; "order"|]
                                                 [|(newshape |> Seq.map string |> String.concat ", " |> sprintf "[%s]"); string reverse; order|]
        outputs |> Array.map (fun h -> new NDArray(h))
    /// <summary>
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\numpy\np_matrix_op.cc:L375</summary>
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="a">Array to be reshaped.</param>
    /// <param name="newshape">The new shape should be compatible with the original shape. If an integer, then the result will be a 1-D array of that length. One shape dimension can be -1. In this case, the value is inferred from the length of the array and remaining dimensions. -2 to -6 are used for data manipulation. -2 copy this dimension from the input to the output shape. -3 will skip current dimension if and only if the current dim size is one. -4 copy all remain of the input dimensions to the output shape. -5 use the product of two consecutive dimensions of the input shape as the output. -6 split one dimension of the input into two dimensions passed subsequent to -6 in the new shape.</param>
    /// <param name="reverse">If true then the special values are inferred from right to left</param>
    /// <param name="order">Read the elements of a using this index order, and place the elements into the reshaped array using this index order. &#39;C&#39; means to read/write the elements using C-like index order, with the last axis index changing fastest, back to the first axis index changing slowest. Note that currently only C-like order is supported</param>
    static member NpxReshape(outputArray : NDArray seq, a : NDArray, newshape : int seq, [<Optional; DefaultParameterValue(false)>] reverse : bool, [<Optional; DefaultParameterValue("C")>] order : string) =
        let creator = AtomicSymbolCreator.FromName "_npx_reshape"
        let names = [|"newshape"; "reverse"; "order"|]
        let vals = [|(newshape |> Seq.map string |> String.concat ", " |> sprintf "[%s]"); string reverse; order|]
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg a)) then a.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <summary>
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\numpy\np_matrix_op.cc:L375</summary>
    /// <param name="a">Array to be reshaped.</param>
    /// <param name="newshape">The new shape should be compatible with the original shape. If an integer, then the result will be a 1-D array of that length. One shape dimension can be -1. In this case, the value is inferred from the length of the array and remaining dimensions. -2 to -6 are used for data manipulation. -2 copy this dimension from the input to the output shape. -3 will skip current dimension if and only if the current dim size is one. -4 copy all remain of the input dimensions to the output shape. -5 use the product of two consecutive dimensions of the input shape as the output. -6 split one dimension of the input into two dimensions passed subsequent to -6 in the new shape.</param>
    /// <param name="reverse">If true then the special values are inferred from right to left</param>
    /// <param name="order">Read the elements of a using this index order, and place the elements into the reshaped array using this index order. &#39;C&#39; means to read/write the elements using C-like index order, with the last axis index changing fastest, back to the first axis index changing slowest. Note that currently only C-like order is supported</param>
    static member NpxReshape(a : Symbol, newshape : int seq, [<Optional>] ?reverse : bool, [<Optional>] ?order : string) =
        NpxReshape(a, newshape, ?reverse = reverse, ?order = order)
    /// <summary>
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\numpy\np_matrix_op.cc:L375</summary>
    /// <param name="newshape">The new shape should be compatible with the original shape. If an integer, then the result will be a 1-D array of that length. One shape dimension can be -1. In this case, the value is inferred from the length of the array and remaining dimensions. -2 to -6 are used for data manipulation. -2 copy this dimension from the input to the output shape. -3 will skip current dimension if and only if the current dim size is one. -4 copy all remain of the input dimensions to the output shape. -5 use the product of two consecutive dimensions of the input shape as the output. -6 split one dimension of the input into two dimensions passed subsequent to -6 in the new shape.</param>
    /// <param name="a">Array to be reshaped.</param>
    /// <param name="reverse">If true then the special values are inferred from right to left</param>
    /// <param name="order">Read the elements of a using this index order, and place the elements into the reshaped array using this index order. &#39;C&#39; means to read/write the elements using C-like index order, with the last axis index changing fastest, back to the first axis index changing slowest. Note that currently only C-like order is supported</param>
    static member NpxReshape(newshape : int seq, [<Optional>] ?a : Symbol, [<Optional>] ?reverse : bool, [<Optional>] ?order : string) =
        NpxReshape(newshape, ?a = a, ?reverse = reverse, ?order = order)

    /// <param name="a">data to squeeze</param>
    /// <param name="axis">Selects a subset of the single-dimensional entries in the shape. If an axis is selected with shape entry greater than one, an error is raised.</param>
    static member NpSqueeze(a : NDArray, [<Optional>] ?axis : int seq) =
        let creator = AtomicSymbolCreator.FromName "_np_squeeze"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg a)) then a.UnsafeHandle|]
                                                 [|"axis"|]
                                                 [|(match axis with None -> "None" | Some axis -> (axis |> Seq.map string |> String.concat ", " |> sprintf "[%s]"))|]
        (new NDArray(outputs.[0]))
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="a">data to squeeze</param>
    /// <param name="axis">Selects a subset of the single-dimensional entries in the shape. If an axis is selected with shape entry greater than one, an error is raised.</param>
    static member NpSqueeze(outputArray : NDArray seq, a : NDArray, [<Optional>] ?axis : int seq) =
        let creator = AtomicSymbolCreator.FromName "_np_squeeze"
        let names = [|"axis"|]
        let vals = [|(match axis with None -> "None" | Some axis -> (axis |> Seq.map string |> String.concat ", " |> sprintf "[%s]"))|]
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg a)) then a.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <param name="a">data to squeeze</param>
    /// <param name="axis">Selects a subset of the single-dimensional entries in the shape. If an axis is selected with shape entry greater than one, an error is raised.</param>
    static member NpSqueeze([<Optional>] ?a : Symbol, [<Optional>] ?axis : int seq) =
        NpSqueeze(?a = a, ?axis = axis)

    /// <summary>Join a sequence of arrays along an existing axis.
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\numpy\np_matrix_op.cc:L617</summary>
    /// <param name="data">List of arrays to concatenate</param>
    /// <param name="numArgs">Number of inputs to be concated.</param>
    /// <param name="dim">the dimension to be concated.</param>
    static member NpiConcatenate([<ParamArray>] data : NDArray[], [<Optional; DefaultParameterValue(1)>] dim : int) =
        let creator = AtomicSymbolCreator.FromName "_npi_concatenate"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 (data |> Array.map (fun x -> x.UnsafeHandle))
                                                 [|"num_args"; "dim"|]
                                                 [|string data.Length; string dim|]
        (new NDArray(outputs.[0]))
    /// <summary>Join a sequence of arrays along an existing axis.
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\numpy\np_matrix_op.cc:L617</summary>
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="data">List of arrays to concatenate</param>
    /// <param name="numArgs">Number of inputs to be concated.</param>
    /// <param name="dim">the dimension to be concated.</param>
    static member NpiConcatenate(outputArray : NDArray seq, [<ParamArray>] data : NDArray[], [<Optional; DefaultParameterValue(1)>] dim : int) =
        let creator = AtomicSymbolCreator.FromName "_npi_concatenate"
        let names = [|"num_args"; "dim"|]
        let vals = [|string data.Length; string dim|]
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     (data |> Array.map (fun x -> x.UnsafeHandle))
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <summary>Join a sequence of arrays along an existing axis.
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\numpy\np_matrix_op.cc:L617</summary>
    /// <param name="data">List of arrays to concatenate</param>
    /// <param name="dim">the dimension to be concated.</param>
    static member NpiConcatenate([<Optional>] ?data : Symbol seq, [<Optional>] ?dim : int) =
        NpiConcatenate(?data = data, ?dim = dim)


    /// <summary>Join a sequence of arrays along a new axis.
    /// 
    /// The axis parameter specifies the index of the new axis in the dimensions of the
    /// result. For example, if axis=0 it will be the first dimension and if axis=-1 it
    /// will be the last dimension.
    /// 
    /// Examples::
    /// 
    ///   x = [1, 2]
    ///   y = [3, 4]
    /// 
    ///   stack(x, y) = [[1, 2],
    ///                  [3, 4]]
    ///   stack(x, y, axis=1) = [[1, 3],
    ///                          [2, 4]]
    /// </summary>
    /// <param name="data">List of arrays to stack</param>
    /// <param name="numArgs">Number of inputs to be stacked.</param>
    /// <param name="axis">The axis in the result array along which the input arrays are stacked.</param>
    static member NpiStack([<ParamArray>] data : NDArray[], [<Optional; DefaultParameterValue(0)>] axis : int) =
        let creator = AtomicSymbolCreator.FromName "_npi_stack"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 (data |> Array.map (fun x -> x.UnsafeHandle))
                                                 [|"num_args"; "axis"|]
                                                 [|string data.Length; string axis|]
        (new NDArray(outputs.[0]))
    /// <summary>Join a sequence of arrays along a new axis.
    /// 
    /// The axis parameter specifies the index of the new axis in the dimensions of the
    /// result. For example, if axis=0 it will be the first dimension and if axis=-1 it
    /// will be the last dimension.
    /// 
    /// Examples::
    /// 
    ///   x = [1, 2]
    ///   y = [3, 4]
    /// 
    ///   stack(x, y) = [[1, 2],
    ///                  [3, 4]]
    ///   stack(x, y, axis=1) = [[1, 3],
    ///                          [2, 4]]
    /// </summary>
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="data">List of arrays to stack</param>
    /// <param name="numArgs">Number of inputs to be stacked.</param>
    /// <param name="axis">The axis in the result array along which the input arrays are stacked.</param>
    static member NpiStack(outputArray : NDArray seq, [<ParamArray>] data : NDArray[], [<Optional; DefaultParameterValue(0)>] axis : int) =
        let creator = AtomicSymbolCreator.FromName "_npi_stack"
        let names = [|"num_args"; "axis"|]
        let vals = [|string data.Length; string axis|]
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     (data |> Array.map (fun x -> x.UnsafeHandle))
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <summary>Join a sequence of arrays along a new axis.
    /// 
    /// The axis parameter specifies the index of the new axis in the dimensions of the
    /// result. For example, if axis=0 it will be the first dimension and if axis=-1 it
    /// will be the last dimension.
    /// 
    /// Examples::
    /// 
    ///   x = [1, 2]
    ///   y = [3, 4]
    /// 
    ///   stack(x, y) = [[1, 2],
    ///                  [3, 4]]
    ///   stack(x, y, axis=1) = [[1, 3],
    ///                          [2, 4]]
    /// </summary>
    /// <param name="data">List of arrays to stack</param>
    /// <param name="axis">The axis in the result array along which the input arrays are stacked.</param>
    static member NpiStack([<Optional>] ?data : Symbol seq, [<Optional>] ?axis : int) =
        NpiStack(?data = data, ?axis = axis)

    /// <summary>
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\numpy\np_matrix_op.cc:L805</summary>
    /// <param name="data">List of arrays to column_stack</param>
    /// <param name="numArgs">Number of inputs to be column stacked</param>
    static member NpiColumnStack([<ParamArray>] data : NDArray[]) =
        let creator = AtomicSymbolCreator.FromName "_npi_column_stack"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 (data |> Array.map (fun x -> x.UnsafeHandle))
                                                 [|"num_args"|]
                                                 [|string data.Length|]
        outputs |> Array.map (fun h -> new NDArray(h))
    /// <summary>
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\numpy\np_matrix_op.cc:L805</summary>
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="data">List of arrays to column_stack</param>
    /// <param name="numArgs">Number of inputs to be column stacked</param>
    static member NpiColumnStack(outputArray : NDArray seq, [<ParamArray>] data : NDArray[]) =
        let creator = AtomicSymbolCreator.FromName "_npi_column_stack"
        let names = [|"num_args"|]
        let vals = [|string data.Length|]
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     (data |> Array.map (fun x -> x.UnsafeHandle))
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <summary>
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\numpy\np_matrix_op.cc:L805</summary>
    /// <param name="data">List of arrays to column_stack</param>
    static member NpiColumnStack([<ParamArray>] data : Symbol[]) =
        NpiColumnStack(data)


    /// <summary>
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\numpy\np_matrix_op.cc:L947</summary>
    /// <param name="data">List of arrays to vstack</param>
    /// <param name="numArgs">Number of inputs to be vstacked.</param>
    static member NpiVstack([<ParamArray>] data : NDArray[]) =
        let creator = AtomicSymbolCreator.FromName "_npi_vstack"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 (data |> Array.map (fun x -> x.UnsafeHandle))
                                                 [|"num_args"|]
                                                 [|string data.Length|]
        (new NDArray(outputs.[0]))
    /// <summary>
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\numpy\np_matrix_op.cc:L947</summary>
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="data">List of arrays to vstack</param>
    /// <param name="numArgs">Number of inputs to be vstacked.</param>
    static member NpiVstack(outputArray : NDArray seq, [<ParamArray>] data : NDArray[]) =
        let creator = AtomicSymbolCreator.FromName "_npi_vstack"
        let names = [|"num_args"|]
        let vals = [|string data.Length|]
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     (data |> Array.map (fun x -> x.UnsafeHandle))
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <summary>
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\numpy\np_matrix_op.cc:L947</summary>
    /// <param name="data">List of arrays to vstack</param>
    static member NpiVstack([<ParamArray>] data : Symbol[]) =
        NpiVstack(data)


    /// <summary>Stack tensors in sequence depthwise (in third dimension)
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\numpy\np_matrix_op.cc:L982</summary>
    /// <param name="data">List of arrays to concatenate</param>
    /// <param name="numArgs">Number of inputs to be concated.</param>
    /// <param name="dim">the dimension to be concated.</param>
    static member NpiDstack([<ParamArray>] data : NDArray[], [<Optional; DefaultParameterValue(1)>] dim : int) =
        let creator = AtomicSymbolCreator.FromName "_npi_dstack"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 (data |> Array.map (fun x -> x.UnsafeHandle))
                                                 [|"num_args"; "dim"|]
                                                 [|string data.Length; string dim|]
        outputs |> Array.map (fun h -> new NDArray(h))
    /// <summary>Stack tensors in sequence depthwise (in third dimension)
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\numpy\np_matrix_op.cc:L982</summary>
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="data">List of arrays to concatenate</param>
    /// <param name="numArgs">Number of inputs to be concated.</param>
    /// <param name="dim">the dimension to be concated.</param>
    static member NpiDstack(outputArray : NDArray seq, [<ParamArray>] data : NDArray[], [<Optional; DefaultParameterValue(1)>] dim : int) =
        let creator = AtomicSymbolCreator.FromName "_npi_dstack"
        let names = [|"num_args"; "dim"|]
        let vals = [|string data.Length; string dim|]
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     (data |> Array.map (fun x -> x.UnsafeHandle))
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <summary>Stack tensors in sequence depthwise (in third dimension)
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\numpy\np_matrix_op.cc:L982</summary>
    /// <param name="data">List of arrays to concatenate</param>
    /// <param name="dim">the dimension to be concated.</param>
    static member NpiDstack([<Optional>] ?data : Symbol seq, [<Optional>] ?dim : int) =
        NpiDstack(?data = data, ?dim = dim)


    /// <param name="data">Input ndarray</param>
    /// <param name="shift">The number of places by which elements are shifted. If a tuple,then axis must be a tuple of the same size, and each of the given axes is shiftedby the corresponding number. If an int while axis is a tuple of ints, then the same value is used for all given axes.</param>
    /// <param name="axis">Axis or axes along which elements are shifted. By default, the array is flattenedbefore shifting, after which the original shape is restored.</param>
    static member NpRoll(data : NDArray, [<Optional>] ?shift : int seq, [<Optional>] ?axis : int seq) =
        let creator = AtomicSymbolCreator.FromName "_np_roll"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle|]
                                                 [|"shift"; "axis"|]
                                                 [|(match shift with None -> "None" | Some shift -> (shift |> Seq.map string |> String.concat ", " |> sprintf "[%s]")); (match axis with None -> "None" | Some axis -> (axis |> Seq.map string |> String.concat ", " |> sprintf "[%s]"))|]
        (new NDArray(outputs.[0]))
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="data">Input ndarray</param>
    /// <param name="shift">The number of places by which elements are shifted. If a tuple,then axis must be a tuple of the same size, and each of the given axes is shiftedby the corresponding number. If an int while axis is a tuple of ints, then the same value is used for all given axes.</param>
    /// <param name="axis">Axis or axes along which elements are shifted. By default, the array is flattenedbefore shifting, after which the original shape is restored.</param>
    static member NpRoll(outputArray : NDArray seq, data : NDArray, [<Optional>] ?shift : int seq, [<Optional>] ?axis : int seq) =
        let creator = AtomicSymbolCreator.FromName "_np_roll"
        let names = [|"shift"; "axis"|]
        let vals = [|(match shift with None -> "None" | Some shift -> (shift |> Seq.map string |> String.concat ", " |> sprintf "[%s]")); (match axis with None -> "None" | Some axis -> (axis |> Seq.map string |> String.concat ", " |> sprintf "[%s]"))|]
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <param name="data">Input ndarray</param>
    /// <param name="shift">The number of places by which elements are shifted. If a tuple,then axis must be a tuple of the same size, and each of the given axes is shiftedby the corresponding number. If an int while axis is a tuple of ints, then the same value is used for all given axes.</param>
    /// <param name="axis">Axis or axes along which elements are shifted. By default, the array is flattenedbefore shifting, after which the original shape is restored.</param>
    static member NpRoll([<Optional>] ?data : Symbol, [<Optional>] ?shift : int seq, [<Optional>] ?axis : int seq) =
        NpRoll(?data = data, ?shift = shift, ?axis = axis)

    /// <param name="data">Input data array</param>
    /// <param name="axis">The axis which to flip elements.</param>
    static member NpiFlip(data : NDArray, axis : int seq) =
        let creator = AtomicSymbolCreator.FromName "_npi_flip"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle|]
                                                 [|"axis"|]
                                                 [|(axis |> Seq.map string |> String.concat ", " |> sprintf "[%s]")|]
        (new NDArray(outputs.[0]))
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="data">Input data array</param>
    /// <param name="axis">The axis which to flip elements.</param>
    static member NpiFlip(outputArray : NDArray seq, data : NDArray, axis : int seq) =
        let creator = AtomicSymbolCreator.FromName "_npi_flip"
        let names = [|"axis"|]
        let vals = [|(axis |> Seq.map string |> String.concat ", " |> sprintf "[%s]")|]
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <param name="data">Input data array</param>
    /// <param name="axis">The axis which to flip elements.</param>
    static member NpiFlip(data : Symbol, axis : int seq) =
        NpiFlip(data, axis)
    /// <param name="axis">The axis which to flip elements.</param>
    /// <param name="data">Input data array</param>
    static member NpiFlip(axis : int seq, [<Optional>] ?data : Symbol) =
        NpiFlip(axis, ?data = data)


    /// <summary>Move axes of an array to new positions.
    /// Other axes remain in their original order.
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\numpy\np_matrix_op.cc:L1165</summary>
    /// <param name="a">Source input</param>
    /// <param name="source">Original positions of the axes to move. These must be unique.</param>
    /// <param name="destination">Destination positions for each of the original axes. These must also be unique.</param>
    static member NpMoveaxis(a : NDArray, source : int seq, destination : int seq) =
        let creator = AtomicSymbolCreator.FromName "_np_moveaxis"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg a)) then a.UnsafeHandle|]
                                                 [|"source"; "destination"|]
                                                 [|(source |> Seq.map string |> String.concat ", " |> sprintf "[%s]"); (destination |> Seq.map string |> String.concat ", " |> sprintf "[%s]")|]
        outputs |> Array.map (fun h -> new NDArray(h))
    /// <summary>Move axes of an array to new positions.
    /// Other axes remain in their original order.
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\numpy\np_matrix_op.cc:L1165</summary>
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="a">Source input</param>
    /// <param name="source">Original positions of the axes to move. These must be unique.</param>
    /// <param name="destination">Destination positions for each of the original axes. These must also be unique.</param>
    static member NpMoveaxis(outputArray : NDArray seq, a : NDArray, source : int seq, destination : int seq) =
        let creator = AtomicSymbolCreator.FromName "_np_moveaxis"
        let names = [|"source"; "destination"|]
        let vals = [|(source |> Seq.map string |> String.concat ", " |> sprintf "[%s]"); (destination |> Seq.map string |> String.concat ", " |> sprintf "[%s]")|]
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg a)) then a.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <summary>Move axes of an array to new positions.
    /// Other axes remain in their original order.
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\numpy\np_matrix_op.cc:L1165</summary>
    /// <param name="a">Source input</param>
    /// <param name="source">Original positions of the axes to move. These must be unique.</param>
    /// <param name="destination">Destination positions for each of the original axes. These must also be unique.</param>
    static member NpMoveaxis(a : Symbol, source : int seq, destination : int seq) =
        NpMoveaxis(a, source, destination)
    /// <summary>Move axes of an array to new positions.
    /// Other axes remain in their original order.
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\numpy\np_matrix_op.cc:L1165</summary>
    /// <param name="source">Original positions of the axes to move. These must be unique.</param>
    /// <param name="destination">Destination positions for each of the original axes. These must also be unique.</param>
    /// <param name="a">Source input</param>
    static member NpMoveaxis(source : int seq, destination : int seq, [<Optional>] ?a : Symbol) =
        NpMoveaxis(source, destination, ?a = a)

    /// <param name="data">Input ndarray</param>
    /// <param name="k">Number of times the array is rotated by 90 degrees.</param>
    /// <param name="axes"> The array is rotated in the plane defined by the axes. Axes must be different.</param>
    static member NpiRot90(data : NDArray, [<Optional>] ?k : int, [<Optional>] ?axes : int seq) =
        let creator = AtomicSymbolCreator.FromName "_npi_rot90"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle|]
                                                 [|"k"; "axes"|]
                                                 [|(match k with None -> "1" | Some k -> string k); (match axes with None -> "None" | Some axes -> (axes |> Seq.map string |> String.concat ", " |> sprintf "[%s]"))|]
        outputs |> Array.map (fun h -> new NDArray(h))
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="data">Input ndarray</param>
    /// <param name="k">Number of times the array is rotated by 90 degrees.</param>
    /// <param name="axes"> The array is rotated in the plane defined by the axes. Axes must be different.</param>
    static member NpiRot90(outputArray : NDArray seq, data : NDArray, [<Optional>] ?k : int, [<Optional>] ?axes : int seq) =
        let creator = AtomicSymbolCreator.FromName "_npi_rot90"
        let names = [|"k"; "axes"|]
        let vals = [|(match k with None -> "1" | Some k -> string k); (match axes with None -> "None" | Some axes -> (axes |> Seq.map string |> String.concat ", " |> sprintf "[%s]"))|]
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <param name="data">Input ndarray</param>
    /// <param name="k">Number of times the array is rotated by 90 degrees.</param>
    /// <param name="axes"> The array is rotated in the plane defined by the axes. Axes must be different.</param>
    static member NpiRot90([<Optional>] ?data : Symbol, [<Optional>] ?k : int, [<Optional>] ?axes : int seq) =
        NpiRot90(?data = data, ?k = k, ?axes = axes)

    /// <param name="data">The input</param>
    /// <param name="indices">Indices of splits. The elements should denote the boundaries of at which split is performed along the `axis`.</param>
    /// <param name="axis">Axis along which to split.</param>
    /// <param name="squeezeAxis">If true, Removes the axis with length 1 from the shapes of the output arrays. **Note** that setting `squeeze_axis` to ``true`` removes axis with length 1 only along the `axis` which it is split. Also `squeeze_axis` can be set to ``true`` only if ``input.shape[axis] == num_outputs``.</param>
    /// <param name="sections">Number of sections if equally splitted. Default to 0 which means split by indices.</param>
    static member NpiHsplit(data : NDArray, 
                            indices : int seq, 
                            [<Optional; DefaultParameterValue(1)>] axis : int, 
                            [<Optional; DefaultParameterValue(false)>] squeezeAxis : bool, 
                            [<Optional; DefaultParameterValue(0)>] sections : int) =
        let creator = AtomicSymbolCreator.FromName "_npi_hsplit"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle|]
                                                 [|"indices"; "axis"; "squeeze_axis"; "sections"|]
                                                 [|(indices |> Seq.map string |> String.concat ", " |> sprintf "[%s]"); string axis; string squeezeAxis; string sections|]
        outputs |> Array.map (fun h -> new NDArray(h))
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="data">The input</param>
    /// <param name="indices">Indices of splits. The elements should denote the boundaries of at which split is performed along the `axis`.</param>
    /// <param name="axis">Axis along which to split.</param>
    /// <param name="squeezeAxis">If true, Removes the axis with length 1 from the shapes of the output arrays. **Note** that setting `squeeze_axis` to ``true`` removes axis with length 1 only along the `axis` which it is split. Also `squeeze_axis` can be set to ``true`` only if ``input.shape[axis] == num_outputs``.</param>
    /// <param name="sections">Number of sections if equally splitted. Default to 0 which means split by indices.</param>
    static member NpiHsplit(outputArray : NDArray seq, 
                            data : NDArray, 
                            indices : int seq, 
                            [<Optional; DefaultParameterValue(1)>] axis : int, 
                            [<Optional; DefaultParameterValue(false)>] squeezeAxis : bool, 
                            [<Optional; DefaultParameterValue(0)>] sections : int) =
        let creator = AtomicSymbolCreator.FromName "_npi_hsplit"
        let names = [|"indices"; "axis"; "squeeze_axis"; "sections"|]
        let vals = [|(indices |> Seq.map string |> String.concat ", " |> sprintf "[%s]"); string axis; string squeezeAxis; string sections|]
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <param name="data">The input</param>
    /// <param name="indices">Indices of splits. The elements should denote the boundaries of at which split is performed along the `axis`.</param>
    /// <param name="axis">Axis along which to split.</param>
    /// <param name="squeezeAxis">If true, Removes the axis with length 1 from the shapes of the output arrays. **Note** that setting `squeeze_axis` to ``true`` removes axis with length 1 only along the `axis` which it is split. Also `squeeze_axis` can be set to ``true`` only if ``input.shape[axis] == num_outputs``.</param>
    /// <param name="sections">Number of sections if equally splitted. Default to 0 which means split by indices.</param>
    static member NpiHsplit(data : Symbol, indices : int seq, [<Optional>] ?axis : int, [<Optional>] ?squeezeAxis : bool, [<Optional>] ?sections : int) =
        NpiHsplit(data, indices, ?axis = axis, ?squeezeAxis = squeezeAxis, ?sections = sections)
    /// <param name="indices">Indices of splits. The elements should denote the boundaries of at which split is performed along the `axis`.</param>
    /// <param name="data">The input</param>
    /// <param name="axis">Axis along which to split.</param>
    /// <param name="squeezeAxis">If true, Removes the axis with length 1 from the shapes of the output arrays. **Note** that setting `squeeze_axis` to ``true`` removes axis with length 1 only along the `axis` which it is split. Also `squeeze_axis` can be set to ``true`` only if ``input.shape[axis] == num_outputs``.</param>
    /// <param name="sections">Number of sections if equally splitted. Default to 0 which means split by indices.</param>
    static member NpiHsplit(indices : int seq, [<Optional>] ?data : Symbol, [<Optional>] ?axis : int, [<Optional>] ?squeezeAxis : bool, [<Optional>] ?sections : int) =
        NpiHsplit(indices, ?data = data, ?axis = axis, ?squeezeAxis = squeezeAxis, ?sections = sections)

    static member NpiHsplitBackwardNDArray() =
        let creator = AtomicSymbolCreator.FromName "_npi_hsplit_backward"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 Array.empty
                                                 Array.empty
                                                 Array.empty
        outputs |> Array.map (fun h -> new NDArray(h))
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    static member NpiHsplitBackward(outputArray : NDArray seq) =
        let creator = AtomicSymbolCreator.FromName "_npi_hsplit_backward"
        let names = Array.empty
        let vals = Array.empty
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     Array.empty
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    static member NpiHsplitBackward() =
        NpiHsplitBackward()

    /// <param name="data">Input ndarray</param>
    /// <param name="k">Diagonal in question. The default is 0. Use k&gt;0 for diagonals above the main diagonal, and k&lt;0 for diagonals below the main diagonal. </param>
    static member NpDiag(data : NDArray, [<Optional; DefaultParameterValue(0)>] k : int) =
        let creator = AtomicSymbolCreator.FromName "_np_diag"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle|]
                                                 [|"k"|]
                                                 [|string k|]
        outputs |> Array.map (fun h -> new NDArray(h))
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="data">Input ndarray</param>
    /// <param name="k">Diagonal in question. The default is 0. Use k&gt;0 for diagonals above the main diagonal, and k&lt;0 for diagonals below the main diagonal. </param>
    static member NpDiag(outputArray : NDArray seq, data : NDArray, [<Optional; DefaultParameterValue(0)>] k : int) =
        let creator = AtomicSymbolCreator.FromName "_np_diag"
        let names = [|"k"|]
        let vals = [|string k|]
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <param name="data">Input ndarray</param>
    /// <param name="k">Diagonal in question. The default is 0. Use k&gt;0 for diagonals above the main diagonal, and k&lt;0 for diagonals below the main diagonal. </param>
    static member NpDiag([<Optional>] ?data : Symbol, [<Optional>] ?k : int) =
        NpDiag(?data = data, ?k = k)


    /// <param name="data">Input ndarray</param>
    /// <param name="k">Diagonal in question. The default is 0. Use k&gt;0 for diagonals above the main diagonal, and k&lt;0 for diagonals below the main diagonal. </param>
    static member NpDiagflat(data : NDArray, [<Optional; DefaultParameterValue(0)>] k : int) =
        let creator = AtomicSymbolCreator.FromName "_np_diagflat"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle|]
                                                 [|"k"|]
                                                 [|string k|]
        outputs |> Array.map (fun h -> new NDArray(h))
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="data">Input ndarray</param>
    /// <param name="k">Diagonal in question. The default is 0. Use k&gt;0 for diagonals above the main diagonal, and k&lt;0 for diagonals below the main diagonal. </param>
    static member NpDiagflat(outputArray : NDArray seq, data : NDArray, [<Optional; DefaultParameterValue(0)>] k : int) =
        let creator = AtomicSymbolCreator.FromName "_np_diagflat"
        let names = [|"k"|]
        let vals = [|string k|]
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <param name="data">Input ndarray</param>
    /// <param name="k">Diagonal in question. The default is 0. Use k&gt;0 for diagonals above the main diagonal, and k&lt;0 for diagonals below the main diagonal. </param>
    static member NpDiagflat([<Optional>] ?data : Symbol, [<Optional>] ?k : int) =
        NpDiagflat(?data = data, ?k = k)


    /// <param name="a">First input</param>
    /// <param name="b">Second input</param>
    static member NpiShareMemory(a : NDArray, b : NDArray) =
        let creator = AtomicSymbolCreator.FromName "_npi_share_memory"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg a)) then a.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg b)) then b.UnsafeHandle|]
                                                 Array.empty
                                                 Array.empty
        outputs |> Array.map (fun h -> new NDArray(h))
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="a">First input</param>
    /// <param name="b">Second input</param>
    static member NpiShareMemory(outputArray : NDArray seq, a : NDArray, b : NDArray) =
        let creator = AtomicSymbolCreator.FromName "_npi_share_memory"
        let names = Array.empty
        let vals = Array.empty
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg a)) then a.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg b)) then b.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <param name="a">First input</param>
    /// <param name="b">Second input</param>
    static member NpiShareMemory([<Optional>] ?a : Symbol, [<Optional>] ?b : Symbol) =
        NpiShareMemory(?a = a, ?b = b)

    /// <param name="x">The input array.</param>
    static member NpxNonzero(x : NDArray) =
        let creator = AtomicSymbolCreator.FromName "_npx_nonzero"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg x)) then x.UnsafeHandle|]
                                                 Array.empty
                                                 Array.empty
        (new NDArray(outputs.[0]))
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="x">The input array.</param>
    static member NpxNonzero(outputArray : NDArray seq, x : NDArray) =
        let creator = AtomicSymbolCreator.FromName "_npx_nonzero"
        let names = Array.empty
        let vals = Array.empty
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg x)) then x.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <param name="x">The input array.</param>
    static member NpxNonzero([<Optional>] ?x : Symbol) =
        NpxNonzero(?x = x)

    /// <param name="a">First input</param>
    /// <param name="b">Second input</param>
    /// <param name="aAxesSummed"></param>
    /// <param name="bAxesSummed"></param>
    static member NpiTensordot(a : NDArray, b : NDArray, aAxesSummed : int seq, bAxesSummed : int seq) =
        let creator = AtomicSymbolCreator.FromName "_npi_tensordot"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg a)) then a.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg b)) then b.UnsafeHandle|]
                                                 [|"a_axes_summed"; "b_axes_summed"|]
                                                 [|(aAxesSummed |> Seq.map string |> String.concat ", " |> sprintf "[%s]"); (bAxesSummed |> Seq.map string |> String.concat ", " |> sprintf "[%s]")|]
        (new NDArray(outputs.[0]))
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="a">First input</param>
    /// <param name="b">Second input</param>
    /// <param name="aAxesSummed"></param>
    /// <param name="bAxesSummed"></param>
    static member NpiTensordot(outputArray : NDArray seq, a : NDArray, b : NDArray, aAxesSummed : int seq, bAxesSummed : int seq) =
        let creator = AtomicSymbolCreator.FromName "_npi_tensordot"
        let names = [|"a_axes_summed"; "b_axes_summed"|]
        let vals = [|(aAxesSummed |> Seq.map string |> String.concat ", " |> sprintf "[%s]"); (bAxesSummed |> Seq.map string |> String.concat ", " |> sprintf "[%s]")|]
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg a)) then a.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg b)) then b.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <param name="a">First input</param>
    /// <param name="b">Second input</param>
    /// <param name="aAxesSummed"></param>
    /// <param name="bAxesSummed"></param>
    static member NpiTensordot(a : Symbol, b : Symbol, aAxesSummed : int seq, bAxesSummed : int seq) =
        NpiTensordot(a, b, aAxesSummed, bAxesSummed)
    /// <param name="aAxesSummed"></param>
    /// <param name="bAxesSummed"></param>
    /// <param name="a">First input</param>
    /// <param name="b">Second input</param>
    static member NpiTensordot(aAxesSummed : int seq, bAxesSummed : int seq, [<Optional>] ?a : Symbol, [<Optional>] ?b : Symbol) =
        NpiTensordot(aAxesSummed, bAxesSummed, ?a = a, ?b = b)


    /// <param name="a">First input</param>
    /// <param name="b">Second input</param>
    /// <param name="axes"></param>
    static member NpiTensordotIntAxes(a : NDArray, b : NDArray, axes : int) =
        let creator = AtomicSymbolCreator.FromName "_npi_tensordot_int_axes"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg a)) then a.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg b)) then b.UnsafeHandle|]
                                                 [|"axes"|]
                                                 [|string axes|]
        (new NDArray(outputs.[0]))
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="a">First input</param>
    /// <param name="b">Second input</param>
    /// <param name="axes"></param>
    static member NpiTensordotIntAxes(outputArray : NDArray seq, a : NDArray, b : NDArray, axes : int) =
        let creator = AtomicSymbolCreator.FromName "_npi_tensordot_int_axes"
        let names = [|"axes"|]
        let vals = [|string axes|]
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg a)) then a.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg b)) then b.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <param name="a">First input</param>
    /// <param name="b">Second input</param>
    /// <param name="axes"></param>
    static member NpiTensordotIntAxes(a : Symbol, b : Symbol, axes : int) =
        NpiTensordotIntAxes(a, b, axes)
    /// <param name="axes"></param>
    /// <param name="a">First input</param>
    /// <param name="b">Second input</param>
    static member NpiTensordotIntAxes(axes : int, [<Optional>] ?a : Symbol, [<Optional>] ?b : Symbol) =
        NpiTensordotIntAxes(axes, ?a = a, ?b = b)


    /// <summary>Computes the sum of the diagonal elements of a matrix.
    /// Input is a tensor *A* of dimension *n &gt;= 2*.
    /// 
    /// If *n=2*, we sum the diagonal elements. The result has shape ().
    /// 
    /// If *n&gt;2*, *trace* is performed separately on the matrix defined by *axis1* and *axis2* for all
    /// inputs (batch mode).
    /// 
    /// Examples::
    /// 
    ///    // Single matrix reduction
    ///    A = [[1.0, 1.0], [1.0, 7.0]]
    ///    trace(A) = 8.0
    /// 
    ///    // Batch matrix reduction
    ///    A = [[[1.0, 1.0], [1.0, 7.0]], [[3.0, 0], [0, 17.0]]]
    ///    trace(A) = [1.0, 18.0]
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\numpy\np_trace_op.cc:L75</summary>
    /// <param name="data">Input ndarray</param>
    /// <param name="offset">Offset of the diagonal from the main diagonal. Can be both positive and negative. Defaults to 0.</param>
    /// <param name="axis1">Axes to be used as the first axis of the 2-D sub-arrays from which the diagonals should be taken. Defaults to 0.</param>
    /// <param name="axis2">Axes to be used as the second axis of the 2-D sub-arrays from which the diagonals should be taken. Defaults to 1.</param>
    static member NpTrace(data : NDArray, [<Optional; DefaultParameterValue(0)>] offset : int, [<Optional; DefaultParameterValue(0)>] axis1 : int, [<Optional; DefaultParameterValue(1)>] axis2 : int) =
        let creator = AtomicSymbolCreator.FromName "_np_trace"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle|]
                                                 [|"offset"; "axis1"; "axis2"|]
                                                 [|string offset; string axis1; string axis2|]
        (new NDArray(outputs.[0]))
    /// <summary>Computes the sum of the diagonal elements of a matrix.
    /// Input is a tensor *A* of dimension *n &gt;= 2*.
    /// 
    /// If *n=2*, we sum the diagonal elements. The result has shape ().
    /// 
    /// If *n&gt;2*, *trace* is performed separately on the matrix defined by *axis1* and *axis2* for all
    /// inputs (batch mode).
    /// 
    /// Examples::
    /// 
    ///    // Single matrix reduction
    ///    A = [[1.0, 1.0], [1.0, 7.0]]
    ///    trace(A) = 8.0
    /// 
    ///    // Batch matrix reduction
    ///    A = [[[1.0, 1.0], [1.0, 7.0]], [[3.0, 0], [0, 17.0]]]
    ///    trace(A) = [1.0, 18.0]
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\numpy\np_trace_op.cc:L75</summary>
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="data">Input ndarray</param>
    /// <param name="offset">Offset of the diagonal from the main diagonal. Can be both positive and negative. Defaults to 0.</param>
    /// <param name="axis1">Axes to be used as the first axis of the 2-D sub-arrays from which the diagonals should be taken. Defaults to 0.</param>
    /// <param name="axis2">Axes to be used as the second axis of the 2-D sub-arrays from which the diagonals should be taken. Defaults to 1.</param>
    static member NpTrace(outputArray : NDArray seq, data : NDArray, [<Optional; DefaultParameterValue(0)>] offset : int, [<Optional; DefaultParameterValue(0)>] axis1 : int, [<Optional; DefaultParameterValue(1)>] axis2 : int) =
        let creator = AtomicSymbolCreator.FromName "_np_trace"
        let names = [|"offset"; "axis1"; "axis2"|]
        let vals = [|string offset; string axis1; string axis2|]
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <summary>Computes the sum of the diagonal elements of a matrix.
    /// Input is a tensor *A* of dimension *n &gt;= 2*.
    /// 
    /// If *n=2*, we sum the diagonal elements. The result has shape ().
    /// 
    /// If *n&gt;2*, *trace* is performed separately on the matrix defined by *axis1* and *axis2* for all
    /// inputs (batch mode).
    /// 
    /// Examples::
    /// 
    ///    // Single matrix reduction
    ///    A = [[1.0, 1.0], [1.0, 7.0]]
    ///    trace(A) = 8.0
    /// 
    ///    // Batch matrix reduction
    ///    A = [[[1.0, 1.0], [1.0, 7.0]], [[3.0, 0], [0, 17.0]]]
    ///    trace(A) = [1.0, 18.0]
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\numpy\np_trace_op.cc:L75</summary>
    /// <param name="data">Input ndarray</param>
    /// <param name="offset">Offset of the diagonal from the main diagonal. Can be both positive and negative. Defaults to 0.</param>
    /// <param name="axis1">Axes to be used as the first axis of the 2-D sub-arrays from which the diagonals should be taken. Defaults to 0.</param>
    /// <param name="axis2">Axes to be used as the second axis of the 2-D sub-arrays from which the diagonals should be taken. Defaults to 1.</param>
    static member NpTrace([<Optional>] ?data : Symbol, [<Optional>] ?offset : int, [<Optional>] ?axis1 : int, [<Optional>] ?axis2 : int) =
        NpTrace(?data = data, ?offset = offset, ?axis1 = axis1, ?axis2 = axis2)


    /// <param name="data">Input ndarray</param>
    /// <param name="k">Diagonal in question. The default is 0. Use k&gt;0 for diagonals above the main diagonal, and k&lt;0 for diagonals below the main diagonal. If input has shape (S0 S1) k must be between -S0 and S1</param>
    static member NpiTril(data : NDArray, [<Optional; DefaultParameterValue(0)>] k : int) =
        let creator = AtomicSymbolCreator.FromName "_npi_tril"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle|]
                                                 [|"k"|]
                                                 [|string k|]
        outputs |> Array.map (fun h -> new NDArray(h))
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="data">Input ndarray</param>
    /// <param name="k">Diagonal in question. The default is 0. Use k&gt;0 for diagonals above the main diagonal, and k&lt;0 for diagonals below the main diagonal. If input has shape (S0 S1) k must be between -S0 and S1</param>
    static member NpiTril(outputArray : NDArray seq, data : NDArray, [<Optional; DefaultParameterValue(0)>] k : int) =
        let creator = AtomicSymbolCreator.FromName "_npi_tril"
        let names = [|"k"|]
        let vals = [|string k|]
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <param name="data">Input ndarray</param>
    /// <param name="k">Diagonal in question. The default is 0. Use k&gt;0 for diagonals above the main diagonal, and k&lt;0 for diagonals below the main diagonal. If input has shape (S0 S1) k must be between -S0 and S1</param>
    static member NpiTril([<Optional>] ?data : Symbol, [<Optional>] ?k : int) =
        NpiTril(?data = data, ?k = k)


    /// <param name="lhs">Dividend array</param>
    /// <param name="rhs">Divisor array</param>
    static member NpiTrueDivide(lhs : NDArray, rhs : NDArray) =
        let creator = AtomicSymbolCreator.FromName "_npi_true_divide"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg lhs)) then lhs.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg rhs)) then rhs.UnsafeHandle|]
                                                 Array.empty
                                                 Array.empty
        (new NDArray(outputs.[0]))
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="lhs">Dividend array</param>
    /// <param name="rhs">Divisor array</param>
    static member NpiTrueDivide(outputArray : NDArray seq, lhs : NDArray, rhs : NDArray) =
        let creator = AtomicSymbolCreator.FromName "_npi_true_divide"
        let names = Array.empty
        let vals = Array.empty
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg lhs)) then lhs.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg rhs)) then rhs.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <param name="lhs">Dividend array</param>
    /// <param name="rhs">Divisor array</param>
    static member NpiTrueDivide([<Optional>] ?lhs : Symbol, [<Optional>] ?rhs : Symbol) =
        NpiTrueDivide(?lhs = lhs, ?rhs = rhs)

    /// <param name="data">source input</param>
    /// <param name="scalar">scalar input</param>
    static member NpiTrueDivideScalar(data : NDArray, scalar : float) =
        let creator = AtomicSymbolCreator.FromName "_npi_true_divide_scalar"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle|]
                                                 [|"scalar"|]
                                                 [|string scalar|]
        (new NDArray(outputs.[0]))
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="data">source input</param>
    /// <param name="scalar">scalar input</param>
    static member NpiTrueDivideScalar(outputArray : NDArray seq, data : NDArray, scalar : float) =
        let creator = AtomicSymbolCreator.FromName "_npi_true_divide_scalar"
        let names = [|"scalar"|]
        let vals = [|string scalar|]
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <param name="data">source input</param>
    /// <param name="scalar">scalar input</param>
    static member NpiTrueDivideScalar(data : Symbol, scalar : float) =
        NpiTrueDivideScalar(data, scalar)
    /// <param name="scalar">scalar input</param>
    /// <param name="data">source input</param>
    static member NpiTrueDivideScalar(scalar : float, [<Optional>] ?data : Symbol) =
        NpiTrueDivideScalar(scalar, ?data = data)

    /// <param name="data">source input</param>
    /// <param name="scalar">scalar input</param>
    static member NpiRtrueDivideScalar(data : NDArray, scalar : float) =
        let creator = AtomicSymbolCreator.FromName "_npi_rtrue_divide_scalar"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle|]
                                                 [|"scalar"|]
                                                 [|string scalar|]
        (new NDArray(outputs.[0]))
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="data">source input</param>
    /// <param name="scalar">scalar input</param>
    static member NpiRtrueDivideScalar(outputArray : NDArray seq, data : NDArray, scalar : float) =
        let creator = AtomicSymbolCreator.FromName "_npi_rtrue_divide_scalar"
        let names = [|"scalar"|]
        let vals = [|string scalar|]
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <param name="data">source input</param>
    /// <param name="scalar">scalar input</param>
    static member NpiRtrueDivideScalar(data : Symbol, scalar : float) =
        NpiRtrueDivideScalar(data, scalar)
    /// <param name="scalar">scalar input</param>
    /// <param name="data">source input</param>
    static member NpiRtrueDivideScalar(scalar : float, [<Optional>] ?data : Symbol) =
        NpiRtrueDivideScalar(scalar, ?data = data)

    /// <param name="data">The input array</param>
    /// <param name="returnIndex">If true, return the indices of the input.</param>
    /// <param name="returnInverse">If true, return the indices of the input.</param>
    /// <param name="returnCounts">If true, return the number of times each unique item appears in input.</param>
    /// <param name="axis">An integer that represents the axis to operator on.</param>
    static member NpiUnique(data : NDArray, 
                            [<Optional>] ?returnIndex : bool, 
                            [<Optional>] ?returnInverse : bool, 
                            [<Optional>] ?returnCounts : bool, 
                            [<Optional>] ?axis : int) =
        let creator = AtomicSymbolCreator.FromName "_npi_unique"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle|]
                                                 [|"return_index"; "return_inverse"; "return_counts"; "axis"|]
                                                 [|(match returnIndex with None -> "false" | Some returnIndex -> string returnIndex); (match returnInverse with None -> "false" | Some returnInverse -> string returnInverse); (match returnCounts with None -> "false" | Some returnCounts -> string returnCounts); (match axis with None -> "None" | Some axis -> string axis)|]
        outputs |> Array.map (fun h -> new NDArray(h))
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="data">The input array</param>
    /// <param name="returnIndex">If true, return the indices of the input.</param>
    /// <param name="returnInverse">If true, return the indices of the input.</param>
    /// <param name="returnCounts">If true, return the number of times each unique item appears in input.</param>
    /// <param name="axis">An integer that represents the axis to operator on.</param>
    static member NpiUnique(outputArray : NDArray seq, 
                            data : NDArray, 
                            [<Optional>] ?returnIndex : bool, 
                            [<Optional>] ?returnInverse : bool, 
                            [<Optional>] ?returnCounts : bool, 
                            [<Optional>] ?axis : int) =
        let creator = AtomicSymbolCreator.FromName "_npi_unique"
        let names = [|"return_index"; "return_inverse"; "return_counts"; "axis"|]
        let vals = [|(match returnIndex with None -> "false" | Some returnIndex -> string returnIndex); (match returnInverse with None -> "false" | Some returnInverse -> string returnInverse); (match returnCounts with None -> "false" | Some returnCounts -> string returnCounts); (match axis with None -> "None" | Some axis -> string axis)|]
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <param name="data">The input array</param>
    /// <param name="returnIndex">If true, return the indices of the input.</param>
    /// <param name="returnInverse">If true, return the indices of the input.</param>
    /// <param name="returnCounts">If true, return the number of times each unique item appears in input.</param>
    /// <param name="axis">An integer that represents the axis to operator on.</param>
    static member NpiUnique([<Optional>] ?data : Symbol, [<Optional>] ?returnIndex : bool, [<Optional>] ?returnInverse : bool, [<Optional>] ?returnCounts : bool, [<Optional>] ?axis : int) =
        NpiUnique(?data = data, ?returnIndex = returnIndex, ?returnInverse = returnInverse, ?returnCounts = returnCounts, ?axis = axis)

    /// <param name="condition">condition array</param>
    /// <param name="x">input x</param>
    /// <param name="y">input y</param>
    static member NpiWhere(condition : NDArray, x : NDArray, y : NDArray) =
        let creator = AtomicSymbolCreator.FromName "_npi_where"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg condition)) then condition.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg x)) then x.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg y)) then y.UnsafeHandle|]
                                                 Array.empty
                                                 Array.empty
        outputs |> Array.map (fun h -> new NDArray(h))
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="condition">condition array</param>
    /// <param name="x">input x</param>
    /// <param name="y">input y</param>
    static member NpiWhere(outputArray : NDArray seq, condition : NDArray, x : NDArray, y : NDArray) =
        let creator = AtomicSymbolCreator.FromName "_npi_where"
        let names = Array.empty
        let vals = Array.empty
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg condition)) then condition.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg x)) then x.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg y)) then y.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <param name="condition">condition array</param>
    /// <param name="x">input x</param>
    /// <param name="y">input y</param>
    static member NpiWhere([<Optional>] ?condition : Symbol, [<Optional>] ?x : Symbol, [<Optional>] ?y : Symbol) =
        NpiWhere(?condition = condition, ?x = x, ?y = y)


    /// <summary>Return the Hanning window.The Hanning window is a taper formed by using a weighted cosine.</summary>
    /// <param name="M">Number of points in the output window. If zero or less, an empty array is returned.</param>
    /// <param name="ctx">Context of output, in format [cpu|gpu|cpu_pinned](n).Only used for imperative calls.</param>
    /// <param name="dtype">Data-type of the returned array.</param>
    static member NpiHanningNDArray(M : int, ctx : Context, [<Optional>] dtype : DataType) =
        let creator = AtomicSymbolCreator.FromName "_npi_hanning"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 Array.empty
                                                 [|"M"; "ctx"; "dtype"|]
                                                 [|string M; string ctx; (if isNull (dtype :> obj) then "float32" else string dtype)|]
        (new NDArray(outputs.[0]))
    /// <summary>Return the Hanning window.The Hanning window is a taper formed by using a weighted cosine.</summary>
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="M">Number of points in the output window. If zero or less, an empty array is returned.</param>
    /// <param name="ctx">Context of output, in format [cpu|gpu|cpu_pinned](n).Only used for imperative calls.</param>
    /// <param name="dtype">Data-type of the returned array.</param>
    static member NpiHanning(outputArray : NDArray seq, M : int, ctx : Context, [<Optional>] dtype : DataType) =
        let creator = AtomicSymbolCreator.FromName "_npi_hanning"
        let names = [|"M"; "ctx"; "dtype"|]
        let vals = [|string M; string ctx; (if isNull (dtype :> obj) then "float32" else string dtype)|]
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     Array.empty
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <summary>Return the Hanning window.The Hanning window is a taper formed by using a weighted cosine.</summary>
    /// <param name="M">Number of points in the output window. If zero or less, an empty array is returned.</param>
    /// <param name="dtype">Data-type of the returned array.</param>
    static member NpiHanning(M : int, [<Optional>] ?dtype : DataType) =
        NpiHanning(M, ?dtype = dtype)

    /// <summary>Return the Hamming window.The Hamming window is a taper formed by using a weighted cosine.</summary>
    /// <param name="M">Number of points in the output window. If zero or less, an empty array is returned.</param>
    /// <param name="ctx">Context of output, in format [cpu|gpu|cpu_pinned](n).Only used for imperative calls.</param>
    /// <param name="dtype">Data-type of the returned array.</param>
    static member NpiHammingNDArray(M : int, ctx : Context, [<Optional>] dtype : DataType) =
        let creator = AtomicSymbolCreator.FromName "_npi_hamming"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 Array.empty
                                                 [|"M"; "ctx"; "dtype"|]
                                                 [|string M; string ctx; (if isNull (dtype :> obj) then "float32" else string dtype)|]
        (new NDArray(outputs.[0]))
    /// <summary>Return the Hamming window.The Hamming window is a taper formed by using a weighted cosine.</summary>
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="M">Number of points in the output window. If zero or less, an empty array is returned.</param>
    /// <param name="ctx">Context of output, in format [cpu|gpu|cpu_pinned](n).Only used for imperative calls.</param>
    /// <param name="dtype">Data-type of the returned array.</param>
    static member NpiHamming(outputArray : NDArray seq, M : int, ctx : Context, [<Optional>] dtype : DataType) =
        let creator = AtomicSymbolCreator.FromName "_npi_hamming"
        let names = [|"M"; "ctx"; "dtype"|]
        let vals = [|string M; string ctx; (if isNull (dtype :> obj) then "float32" else string dtype)|]
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     Array.empty
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <summary>Return the Hamming window.The Hamming window is a taper formed by using a weighted cosine.</summary>
    /// <param name="M">Number of points in the output window. If zero or less, an empty array is returned.</param>
    /// <param name="dtype">Data-type of the returned array.</param>
    static member NpiHamming(M : int, [<Optional>] ?dtype : DataType) =
        NpiHamming(M, ?dtype = dtype)

    /// <summary>Return the Blackman window.The Blackman window is a taper formed by using a weighted cosine.</summary>
    /// <param name="M">Number of points in the output window. If zero or less, an empty array is returned.</param>
    /// <param name="ctx">Context of output, in format [cpu|gpu|cpu_pinned](n).Only used for imperative calls.</param>
    /// <param name="dtype">Data-type of the returned array.</param>
    static member NpiBlackmanNDArray(M : int, ctx : Context, [<Optional>] dtype : DataType) =
        let creator = AtomicSymbolCreator.FromName "_npi_blackman"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 Array.empty
                                                 [|"M"; "ctx"; "dtype"|]
                                                 [|string M; string ctx; (if isNull (dtype :> obj) then "float32" else string dtype)|]
        (new NDArray(outputs.[0]))
    /// <summary>Return the Blackman window.The Blackman window is a taper formed by using a weighted cosine.</summary>
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="M">Number of points in the output window. If zero or less, an empty array is returned.</param>
    /// <param name="ctx">Context of output, in format [cpu|gpu|cpu_pinned](n).Only used for imperative calls.</param>
    /// <param name="dtype">Data-type of the returned array.</param>
    static member NpiBlackman(outputArray : NDArray seq, M : int, ctx : Context, [<Optional>] dtype : DataType) =
        let creator = AtomicSymbolCreator.FromName "_npi_blackman"
        let names = [|"M"; "ctx"; "dtype"|]
        let vals = [|string M; string ctx; (if isNull (dtype :> obj) then "float32" else string dtype)|]
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     Array.empty
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <summary>Return the Blackman window.The Blackman window is a taper formed by using a weighted cosine.</summary>
    /// <param name="M">Number of points in the output window. If zero or less, an empty array is returned.</param>
    /// <param name="dtype">Data-type of the returned array.</param>
    static member NpiBlackman(M : int, [<Optional>] ?dtype : DataType) =
        NpiBlackman(M, ?dtype = dtype)

    /// <param name="input1">Source input</param>
    /// <param name="ctx">Context of output, in format [cpu|gpu|cpu_pinned](n). Only used for imperative calls.</param>
    /// <param name="isLogit"></param>
    /// <param name="prob"></param>
    /// <param name="logit"></param>
    /// <param name="size">Output shape. If the given shape is, e.g., (m, n, k), then m * n * k samples are drawn. Default is None, in which case a single value is returned.</param>
    /// <param name="dtype">DType of the output in case this can&#39;t be inferred. Defaults to float32 if not defined (dtype=None).</param>
    static member NpiBernoulli(input1 : NDArray, 
                               ctx : Context, 
                               isLogit : bool, 
                               [<Optional>] ?prob : float, 
                               [<Optional>] ?logit : float, 
                               [<Optional>] ?size : int seq, 
                               [<Optional>] ?dtype : DataType) =
        let creator = AtomicSymbolCreator.FromName "_npi_bernoulli"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg input1)) then input1.UnsafeHandle|]
                                                 [|"ctx"; "is_logit"; "prob"; "logit"; "size"; "dtype"|]
                                                 [|string ctx; string isLogit; (match prob with None -> "None" | Some prob -> string prob); (match logit with None -> "None" | Some logit -> string logit); (match size with None -> "None" | Some size -> (size |> Seq.map string |> String.concat ", " |> sprintf "[%s]")); (match dtype with None -> "float32" | Some dtype -> string dtype)|]
        outputs |> Array.map (fun h -> new NDArray(h))
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="input1">Source input</param>
    /// <param name="ctx">Context of output, in format [cpu|gpu|cpu_pinned](n). Only used for imperative calls.</param>
    /// <param name="isLogit"></param>
    /// <param name="prob"></param>
    /// <param name="logit"></param>
    /// <param name="size">Output shape. If the given shape is, e.g., (m, n, k), then m * n * k samples are drawn. Default is None, in which case a single value is returned.</param>
    /// <param name="dtype">DType of the output in case this can&#39;t be inferred. Defaults to float32 if not defined (dtype=None).</param>
    static member NpiBernoulli(outputArray : NDArray seq, 
                               input1 : NDArray, 
                               ctx : Context, 
                               isLogit : bool, 
                               [<Optional>] ?prob : float, 
                               [<Optional>] ?logit : float, 
                               [<Optional>] ?size : int seq, 
                               [<Optional>] ?dtype : DataType) =
        let creator = AtomicSymbolCreator.FromName "_npi_bernoulli"
        let names = [|"ctx"; "is_logit"; "prob"; "logit"; "size"; "dtype"|]
        let vals = [|string ctx; string isLogit; (match prob with None -> "None" | Some prob -> string prob); (match logit with None -> "None" | Some logit -> string logit); (match size with None -> "None" | Some size -> (size |> Seq.map string |> String.concat ", " |> sprintf "[%s]")); (match dtype with None -> "float32" | Some dtype -> string dtype)|]
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg input1)) then input1.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <param name="input1">Source input</param>
    /// <param name="isLogit"></param>
    /// <param name="prob"></param>
    /// <param name="logit"></param>
    /// <param name="size">Output shape. If the given shape is, e.g., (m, n, k), then m * n * k samples are drawn. Default is None, in which case a single value is returned.</param>
    /// <param name="dtype">DType of the output in case this can&#39;t be inferred. Defaults to float32 if not defined (dtype=None).</param>
    static member NpiBernoulli(input1 : Symbol, isLogit : bool, [<Optional>] ?prob : float, [<Optional>] ?logit : float, [<Optional>] ?size : int seq, [<Optional>] ?dtype : DataType) =
        NpiBernoulli(input1, isLogit, ?prob = prob, ?logit = logit, ?size = size, ?dtype = dtype)
    /// <param name="isLogit"></param>
    /// <param name="input1">Source input</param>
    /// <param name="prob"></param>
    /// <param name="logit"></param>
    /// <param name="size">Output shape. If the given shape is, e.g., (m, n, k), then m * n * k samples are drawn. Default is None, in which case a single value is returned.</param>
    /// <param name="dtype">DType of the output in case this can&#39;t be inferred. Defaults to float32 if not defined (dtype=None).</param>
    static member NpiBernoulli(isLogit : bool, [<Optional>] ?input1 : Symbol, [<Optional>] ?prob : float, [<Optional>] ?logit : float, [<Optional>] ?size : int seq, [<Optional>] ?dtype : DataType) =
        NpiBernoulli(isLogit, ?input1 = input1, ?prob = prob, ?logit = logit, ?size = size, ?dtype = dtype)

    /// <summary>random choice</summary>
    /// <param name="input1">Source input</param>
    /// <param name="input2">Source input</param>
    /// <param name="a"></param>
    /// <param name="size"></param>
    /// <param name="ctx"></param>
    /// <param name="replace"></param>
    /// <param name="weighted"></param>
    static member NpiChoice(input1 : NDArray, 
                            input2 : NDArray, 
                            a : int64, 
                            size : int seq, 
                            ctx : Context, 
                            [<Optional; DefaultParameterValue(true)>] replace : bool, 
                            [<Optional; DefaultParameterValue(false)>] weighted : bool) =
        let creator = AtomicSymbolCreator.FromName "_npi_choice"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg input1)) then input1.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg input2)) then input2.UnsafeHandle|]
                                                 [|"a"; "size"; "ctx"; "replace"; "weighted"|]
                                                 [|string a; (size |> Seq.map string |> String.concat ", " |> sprintf "[%s]"); string ctx; string replace; string weighted|]
        (new NDArray(outputs.[0]))
    /// <summary>random choice</summary>
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="input1">Source input</param>
    /// <param name="input2">Source input</param>
    /// <param name="a"></param>
    /// <param name="size"></param>
    /// <param name="ctx"></param>
    /// <param name="replace"></param>
    /// <param name="weighted"></param>
    static member NpiChoice(outputArray : NDArray seq, 
                            input1 : NDArray, 
                            input2 : NDArray, 
                            a : int64, 
                            size : int seq, 
                            ctx : Context, 
                            [<Optional; DefaultParameterValue(true)>] replace : bool, 
                            [<Optional; DefaultParameterValue(false)>] weighted : bool) =
        let creator = AtomicSymbolCreator.FromName "_npi_choice"
        let names = [|"a"; "size"; "ctx"; "replace"; "weighted"|]
        let vals = [|string a; (size |> Seq.map string |> String.concat ", " |> sprintf "[%s]"); string ctx; string replace; string weighted|]
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg input1)) then input1.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg input2)) then input2.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <summary>random choice</summary>
    /// <param name="input1">Source input</param>
    /// <param name="input2">Source input</param>
    /// <param name="a"></param>
    /// <param name="size"></param>
    /// <param name="replace"></param>
    /// <param name="weighted"></param>
    static member NpiChoice(input1 : Symbol, input2 : Symbol, a : int64, size : int seq, [<Optional>] ?replace : bool, [<Optional>] ?weighted : bool) =
        NpiChoice(input1, input2, a, size, ?replace = replace, ?weighted = weighted)
    /// <summary>random choice</summary>
    /// <param name="a"></param>
    /// <param name="size"></param>
    /// <param name="input1">Source input</param>
    /// <param name="input2">Source input</param>
    /// <param name="replace"></param>
    /// <param name="weighted"></param>
    static member NpiChoice(a : int64, size : int seq, [<Optional>] ?input1 : Symbol, [<Optional>] ?input2 : Symbol, [<Optional>] ?replace : bool, [<Optional>] ?weighted : bool) =
        NpiChoice(a, size, ?input1 = input1, ?input2 = input2, ?replace = replace, ?weighted = weighted)

    /// <summary>Draw samples from a multinomial distribution. &quot;
    /// &quot;The multinomial distribution is a multivariate generalisation of the binomial distribution. &quot;
    /// &quot;Take an experiment with one of p possible outcomes. &quot;
    /// &quot;An example of such an experiment is throwing a dice, where the outcome can be 1 through 6. &quot;
    /// &quot;Each sample drawn from the distribution represents n such experiments. &quot;
    /// &quot;Its values, X_i = [X_0, X_1, ..., X_p], represent the number of times the outcome was i.
    /// </summary>
    /// <param name="a">Source input</param>
    /// <param name="n">Number of experiments.</param>
    /// <param name="pvals">Probabilities of each of the p different outcomes. These should sum to 1 (however, the last element is always assumed to account for the remaining probability, as long as sum(pvals[:-1]) &lt;= 1)Note that this is for internal usage only. This operator will only have either input mx.ndarray or this list of pvals</param>
    /// <param name="size">Output shape. If the given shape is, e.g., (m, n, k), then m * n * k samples are drawn. Default is None, in which case a single value is returned.</param>
    static member NpiMultinomial(a : NDArray, n : int, pvals : double seq, [<Optional>] ?size : int seq) =
        let creator = AtomicSymbolCreator.FromName "_npi_multinomial"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg a)) then a.UnsafeHandle|]
                                                 [|"n"; "pvals"; "size"|]
                                                 [|string n; string pvals; (match size with None -> "None" | Some size -> (size |> Seq.map string |> String.concat ", " |> sprintf "[%s]"))|]
        (new NDArray(outputs.[0]))
    /// <summary>Draw samples from a multinomial distribution. &quot;
    /// &quot;The multinomial distribution is a multivariate generalisation of the binomial distribution. &quot;
    /// &quot;Take an experiment with one of p possible outcomes. &quot;
    /// &quot;An example of such an experiment is throwing a dice, where the outcome can be 1 through 6. &quot;
    /// &quot;Each sample drawn from the distribution represents n such experiments. &quot;
    /// &quot;Its values, X_i = [X_0, X_1, ..., X_p], represent the number of times the outcome was i.
    /// </summary>
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="a">Source input</param>
    /// <param name="n">Number of experiments.</param>
    /// <param name="pvals">Probabilities of each of the p different outcomes. These should sum to 1 (however, the last element is always assumed to account for the remaining probability, as long as sum(pvals[:-1]) &lt;= 1)Note that this is for internal usage only. This operator will only have either input mx.ndarray or this list of pvals</param>
    /// <param name="size">Output shape. If the given shape is, e.g., (m, n, k), then m * n * k samples are drawn. Default is None, in which case a single value is returned.</param>
    static member NpiMultinomial(outputArray : NDArray seq, a : NDArray, n : int, pvals : double seq, [<Optional>] ?size : int seq) =
        let creator = AtomicSymbolCreator.FromName "_npi_multinomial"
        let names = [|"n"; "pvals"; "size"|]
        let vals = [|string n; string pvals; (match size with None -> "None" | Some size -> (size |> Seq.map string |> String.concat ", " |> sprintf "[%s]"))|]
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg a)) then a.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <summary>Draw samples from a multinomial distribution. &quot;
    /// &quot;The multinomial distribution is a multivariate generalisation of the binomial distribution. &quot;
    /// &quot;Take an experiment with one of p possible outcomes. &quot;
    /// &quot;An example of such an experiment is throwing a dice, where the outcome can be 1 through 6. &quot;
    /// &quot;Each sample drawn from the distribution represents n such experiments. &quot;
    /// &quot;Its values, X_i = [X_0, X_1, ..., X_p], represent the number of times the outcome was i.
    /// </summary>
    /// <param name="a">Source input</param>
    /// <param name="n">Number of experiments.</param>
    /// <param name="pvals">Probabilities of each of the p different outcomes. These should sum to 1 (however, the last element is always assumed to account for the remaining probability, as long as sum(pvals[:-1]) &lt;= 1)Note that this is for internal usage only. This operator will only have either input mx.ndarray or this list of pvals</param>
    /// <param name="size">Output shape. If the given shape is, e.g., (m, n, k), then m * n * k samples are drawn. Default is None, in which case a single value is returned.</param>
    static member NpiMultinomial(a : Symbol, n : int, pvals : double seq, [<Optional>] ?size : int seq) =
        NpiMultinomial(a, n, pvals, ?size = size)
    /// <summary>Draw samples from a multinomial distribution. &quot;
    /// &quot;The multinomial distribution is a multivariate generalisation of the binomial distribution. &quot;
    /// &quot;Take an experiment with one of p possible outcomes. &quot;
    /// &quot;An example of such an experiment is throwing a dice, where the outcome can be 1 through 6. &quot;
    /// &quot;Each sample drawn from the distribution represents n such experiments. &quot;
    /// &quot;Its values, X_i = [X_0, X_1, ..., X_p], represent the number of times the outcome was i.
    /// </summary>
    /// <param name="n">Number of experiments.</param>
    /// <param name="pvals">Probabilities of each of the p different outcomes. These should sum to 1 (however, the last element is always assumed to account for the remaining probability, as long as sum(pvals[:-1]) &lt;= 1)Note that this is for internal usage only. This operator will only have either input mx.ndarray or this list of pvals</param>
    /// <param name="a">Source input</param>
    /// <param name="size">Output shape. If the given shape is, e.g., (m, n, k), then m * n * k samples are drawn. Default is None, in which case a single value is returned.</param>
    static member NpiMultinomial(n : int, pvals : double seq, [<Optional>] ?a : Symbol, [<Optional>] ?size : int seq) =
        NpiMultinomial(n, pvals, ?a = a, ?size = size)

    /// <summary>Numpy behavior normal</summary>
    /// <param name="input1">Source input</param>
    /// <param name="input2">Source input</param>
    /// <param name="ctx">Context of output, in format [cpu|gpu|cpu_pinned](n). Only used for imperative calls.</param>
    /// <param name="loc"></param>
    /// <param name="scale"></param>
    /// <param name="size">Output shape. If the given shape is, e.g., (m, n, k), then m * n * k samples are drawn. Default is None, in which case a single value is returned.</param>
    /// <param name="dtype">DType of the output in case this can&#39;t be inferred. Defaults to float32 if not defined (dtype=None).</param>
    static member NpiNormal(input1 : NDArray, 
                            input2 : NDArray, 
                            ctx : Context, 
                            [<Optional>] ?loc : float, 
                            [<Optional>] ?scale : float, 
                            [<Optional>] ?size : int seq, 
                            [<Optional>] ?dtype : FloatDType) =
        let creator = AtomicSymbolCreator.FromName "_npi_normal"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg input1)) then input1.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg input2)) then input2.UnsafeHandle|]
                                                 [|"ctx"; "loc"; "scale"; "size"; "dtype"|]
                                                 [|string ctx; (match loc with None -> "None" | Some loc -> string loc); (match scale with None -> "None" | Some scale -> string scale); (match size with None -> "None" | Some size -> (size |> Seq.map string |> String.concat ", " |> sprintf "[%s]")); (match dtype with None -> "float32" | Some dtype -> string dtype)|]
        (new NDArray(outputs.[0]))
    /// <summary>Numpy behavior normal</summary>
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="input1">Source input</param>
    /// <param name="input2">Source input</param>
    /// <param name="ctx">Context of output, in format [cpu|gpu|cpu_pinned](n). Only used for imperative calls.</param>
    /// <param name="loc"></param>
    /// <param name="scale"></param>
    /// <param name="size">Output shape. If the given shape is, e.g., (m, n, k), then m * n * k samples are drawn. Default is None, in which case a single value is returned.</param>
    /// <param name="dtype">DType of the output in case this can&#39;t be inferred. Defaults to float32 if not defined (dtype=None).</param>
    static member NpiNormal(outputArray : NDArray seq, 
                            input1 : NDArray, 
                            input2 : NDArray, 
                            ctx : Context, 
                            [<Optional>] ?loc : float, 
                            [<Optional>] ?scale : float, 
                            [<Optional>] ?size : int seq, 
                            [<Optional>] ?dtype : FloatDType) =
        let creator = AtomicSymbolCreator.FromName "_npi_normal"
        let names = [|"ctx"; "loc"; "scale"; "size"; "dtype"|]
        let vals = [|string ctx; (match loc with None -> "None" | Some loc -> string loc); (match scale with None -> "None" | Some scale -> string scale); (match size with None -> "None" | Some size -> (size |> Seq.map string |> String.concat ", " |> sprintf "[%s]")); (match dtype with None -> "float32" | Some dtype -> string dtype)|]
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg input1)) then input1.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg input2)) then input2.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <summary>Numpy behavior normal</summary>
    /// <param name="input1">Source input</param>
    /// <param name="input2">Source input</param>
    /// <param name="loc"></param>
    /// <param name="scale"></param>
    /// <param name="size">Output shape. If the given shape is, e.g., (m, n, k), then m * n * k samples are drawn. Default is None, in which case a single value is returned.</param>
    /// <param name="dtype">DType of the output in case this can&#39;t be inferred. Defaults to float32 if not defined (dtype=None).</param>
    static member NpiNormal([<Optional>] ?input1 : Symbol, [<Optional>] ?input2 : Symbol, [<Optional>] ?loc : float, [<Optional>] ?scale : float, [<Optional>] ?size : int seq, [<Optional>] ?dtype : FloatDType) =
        NpiNormal(?input1 = input1, ?input2 = input2, ?loc = loc, ?scale = scale, ?size = size, ?dtype = dtype)

    /// <summary>Ndarray behavior normal</summary>
    /// <param name="input1">Source input</param>
    /// <param name="input2">Source input</param>
    /// <param name="ctx">Context of output, in format [cpu|gpu|cpu_pinned](n). Only used for imperative calls.</param>
    /// <param name="loc"></param>
    /// <param name="scale"></param>
    /// <param name="size">Output shape. If the given shape is, e.g., (m, n, k), then m * n * k samples are drawn. Default is None, in which case a single value is returned.</param>
    /// <param name="dtype">DType of the output in case this can&#39;t be inferred. Defaults to float32 if not defined (dtype=None).</param>
    static member NpiNormalN(input1 : NDArray, 
                             input2 : NDArray, 
                             ctx : Context, 
                             [<Optional>] ?loc : float, 
                             [<Optional>] ?scale : float, 
                             [<Optional>] ?size : int seq, 
                             [<Optional>] ?dtype : FloatDType) =
        let creator = AtomicSymbolCreator.FromName "_npi_normal_n"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg input1)) then input1.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg input2)) then input2.UnsafeHandle|]
                                                 [|"ctx"; "loc"; "scale"; "size"; "dtype"|]
                                                 [|string ctx; (match loc with None -> "None" | Some loc -> string loc); (match scale with None -> "None" | Some scale -> string scale); (match size with None -> "None" | Some size -> (size |> Seq.map string |> String.concat ", " |> sprintf "[%s]")); (match dtype with None -> "float32" | Some dtype -> string dtype)|]
        outputs |> Array.map (fun h -> new NDArray(h))
    /// <summary>Ndarray behavior normal</summary>
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="input1">Source input</param>
    /// <param name="input2">Source input</param>
    /// <param name="ctx">Context of output, in format [cpu|gpu|cpu_pinned](n). Only used for imperative calls.</param>
    /// <param name="loc"></param>
    /// <param name="scale"></param>
    /// <param name="size">Output shape. If the given shape is, e.g., (m, n, k), then m * n * k samples are drawn. Default is None, in which case a single value is returned.</param>
    /// <param name="dtype">DType of the output in case this can&#39;t be inferred. Defaults to float32 if not defined (dtype=None).</param>
    static member NpiNormalN(outputArray : NDArray seq, 
                             input1 : NDArray, 
                             input2 : NDArray, 
                             ctx : Context, 
                             [<Optional>] ?loc : float, 
                             [<Optional>] ?scale : float, 
                             [<Optional>] ?size : int seq, 
                             [<Optional>] ?dtype : FloatDType) =
        let creator = AtomicSymbolCreator.FromName "_npi_normal_n"
        let names = [|"ctx"; "loc"; "scale"; "size"; "dtype"|]
        let vals = [|string ctx; (match loc with None -> "None" | Some loc -> string loc); (match scale with None -> "None" | Some scale -> string scale); (match size with None -> "None" | Some size -> (size |> Seq.map string |> String.concat ", " |> sprintf "[%s]")); (match dtype with None -> "float32" | Some dtype -> string dtype)|]
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg input1)) then input1.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg input2)) then input2.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <summary>Ndarray behavior normal</summary>
    /// <param name="input1">Source input</param>
    /// <param name="input2">Source input</param>
    /// <param name="loc"></param>
    /// <param name="scale"></param>
    /// <param name="size">Output shape. If the given shape is, e.g., (m, n, k), then m * n * k samples are drawn. Default is None, in which case a single value is returned.</param>
    /// <param name="dtype">DType of the output in case this can&#39;t be inferred. Defaults to float32 if not defined (dtype=None).</param>
    static member NpiNormalN([<Optional>] ?input1 : Symbol, [<Optional>] ?input2 : Symbol, [<Optional>] ?loc : float, [<Optional>] ?scale : float, [<Optional>] ?size : int seq, [<Optional>] ?dtype : FloatDType) =
        NpiNormalN(?input1 = input1, ?input2 = input2, ?loc = loc, ?scale = scale, ?size = size, ?dtype = dtype)


    /// <summary>numpy behavior uniform</summary>
    /// <param name="input1">Source input</param>
    /// <param name="input2">Source input</param>
    /// <param name="ctx">Context of output, in format [cpu|gpu|cpu_pinned](n). Only used for imperative calls.</param>
    /// <param name="low"></param>
    /// <param name="high"></param>
    /// <param name="size">Output shape. If the given shape is, e.g., (m, n, k), then m * n * k samples are drawn. Default is None, in which case a single value is returned.</param>
    /// <param name="dtype">DType of the output in case this can&#39;t be inferred. Defaults to float32 if not defined (dtype=None).</param>
    static member NpiUniform(input1 : NDArray, 
                             input2 : NDArray, 
                             ctx : Context, 
                             [<Optional>] ?low : float, 
                             [<Optional>] ?high : float, 
                             [<Optional>] ?size : int seq, 
                             [<Optional>] ?dtype : FloatDType) =
        let creator = AtomicSymbolCreator.FromName "_npi_uniform"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg input1)) then input1.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg input2)) then input2.UnsafeHandle|]
                                                 [|"ctx"; "low"; "high"; "size"; "dtype"|]
                                                 [|string ctx; (match low with None -> "None" | Some low -> string low); (match high with None -> "None" | Some high -> string high); (match size with None -> "None" | Some size -> (size |> Seq.map string |> String.concat ", " |> sprintf "[%s]")); (match dtype with None -> "float32" | Some dtype -> string dtype)|]
        (new NDArray(outputs.[0]))
    /// <summary>numpy behavior uniform</summary>
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="input1">Source input</param>
    /// <param name="input2">Source input</param>
    /// <param name="ctx">Context of output, in format [cpu|gpu|cpu_pinned](n). Only used for imperative calls.</param>
    /// <param name="low"></param>
    /// <param name="high"></param>
    /// <param name="size">Output shape. If the given shape is, e.g., (m, n, k), then m * n * k samples are drawn. Default is None, in which case a single value is returned.</param>
    /// <param name="dtype">DType of the output in case this can&#39;t be inferred. Defaults to float32 if not defined (dtype=None).</param>
    static member NpiUniform(outputArray : NDArray seq, 
                             input1 : NDArray, 
                             input2 : NDArray, 
                             ctx : Context, 
                             [<Optional>] ?low : float, 
                             [<Optional>] ?high : float, 
                             [<Optional>] ?size : int seq, 
                             [<Optional>] ?dtype : FloatDType) =
        let creator = AtomicSymbolCreator.FromName "_npi_uniform"
        let names = [|"ctx"; "low"; "high"; "size"; "dtype"|]
        let vals = [|string ctx; (match low with None -> "None" | Some low -> string low); (match high with None -> "None" | Some high -> string high); (match size with None -> "None" | Some size -> (size |> Seq.map string |> String.concat ", " |> sprintf "[%s]")); (match dtype with None -> "float32" | Some dtype -> string dtype)|]
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg input1)) then input1.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg input2)) then input2.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <summary>numpy behavior uniform</summary>
    /// <param name="input1">Source input</param>
    /// <param name="input2">Source input</param>
    /// <param name="low"></param>
    /// <param name="high"></param>
    /// <param name="size">Output shape. If the given shape is, e.g., (m, n, k), then m * n * k samples are drawn. Default is None, in which case a single value is returned.</param>
    /// <param name="dtype">DType of the output in case this can&#39;t be inferred. Defaults to float32 if not defined (dtype=None).</param>
    static member NpiUniform([<Optional>] ?input1 : Symbol, [<Optional>] ?input2 : Symbol, [<Optional>] ?low : float, [<Optional>] ?high : float, [<Optional>] ?size : int seq, [<Optional>] ?dtype : FloatDType) =
        NpiUniform(?input1 = input1, ?input2 = input2, ?low = low, ?high = high, ?size = size, ?dtype = dtype)

    /// <summary>numpy behavior uniform</summary>
    /// <param name="input1">Source input</param>
    /// <param name="input2">Source input</param>
    /// <param name="ctx">Context of output, in format [cpu|gpu|cpu_pinned](n). Only used for imperative calls.</param>
    /// <param name="low"></param>
    /// <param name="high"></param>
    /// <param name="size">Output shape. If the given shape is, e.g., (m, n, k), then m * n * k samples are drawn. Default is None, in which case a single value is returned.</param>
    /// <param name="dtype">DType of the output in case this can&#39;t be inferred. Defaults to float32 if not defined (dtype=None).</param>
    static member NpiUniformN(input1 : NDArray, 
                              input2 : NDArray, 
                              ctx : Context, 
                              [<Optional>] ?low : float, 
                              [<Optional>] ?high : float, 
                              [<Optional>] ?size : int seq, 
                              [<Optional>] ?dtype : FloatDType) =
        let creator = AtomicSymbolCreator.FromName "_npi_uniform_n"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg input1)) then input1.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg input2)) then input2.UnsafeHandle|]
                                                 [|"ctx"; "low"; "high"; "size"; "dtype"|]
                                                 [|string ctx; (match low with None -> "None" | Some low -> string low); (match high with None -> "None" | Some high -> string high); (match size with None -> "None" | Some size -> (size |> Seq.map string |> String.concat ", " |> sprintf "[%s]")); (match dtype with None -> "float32" | Some dtype -> string dtype)|]
        outputs |> Array.map (fun h -> new NDArray(h))
    /// <summary>numpy behavior uniform</summary>
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="input1">Source input</param>
    /// <param name="input2">Source input</param>
    /// <param name="ctx">Context of output, in format [cpu|gpu|cpu_pinned](n). Only used for imperative calls.</param>
    /// <param name="low"></param>
    /// <param name="high"></param>
    /// <param name="size">Output shape. If the given shape is, e.g., (m, n, k), then m * n * k samples are drawn. Default is None, in which case a single value is returned.</param>
    /// <param name="dtype">DType of the output in case this can&#39;t be inferred. Defaults to float32 if not defined (dtype=None).</param>
    static member NpiUniformN(outputArray : NDArray seq, 
                              input1 : NDArray, 
                              input2 : NDArray, 
                              ctx : Context, 
                              [<Optional>] ?low : float, 
                              [<Optional>] ?high : float, 
                              [<Optional>] ?size : int seq, 
                              [<Optional>] ?dtype : FloatDType) =
        let creator = AtomicSymbolCreator.FromName "_npi_uniform_n"
        let names = [|"ctx"; "low"; "high"; "size"; "dtype"|]
        let vals = [|string ctx; (match low with None -> "None" | Some low -> string low); (match high with None -> "None" | Some high -> string high); (match size with None -> "None" | Some size -> (size |> Seq.map string |> String.concat ", " |> sprintf "[%s]")); (match dtype with None -> "float32" | Some dtype -> string dtype)|]
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg input1)) then input1.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg input2)) then input2.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <summary>numpy behavior uniform</summary>
    /// <param name="input1">Source input</param>
    /// <param name="input2">Source input</param>
    /// <param name="low"></param>
    /// <param name="high"></param>
    /// <param name="size">Output shape. If the given shape is, e.g., (m, n, k), then m * n * k samples are drawn. Default is None, in which case a single value is returned.</param>
    /// <param name="dtype">DType of the output in case this can&#39;t be inferred. Defaults to float32 if not defined (dtype=None).</param>
    static member NpiUniformN([<Optional>] ?input1 : Symbol, [<Optional>] ?input2 : Symbol, [<Optional>] ?low : float, [<Optional>] ?high : float, [<Optional>] ?size : int seq, [<Optional>] ?dtype : FloatDType) =
        NpiUniformN(?input1 = input1, ?input2 = input2, ?low = low, ?high = high, ?size = size, ?dtype = dtype)

    /// <summary>Update function for SignSGD optimizer.
    /// 
    /// .. math::
    /// 
    ///  g_t = \nabla J(W_{t-1})\\
    ///  W_t = W_{t-1} - \eta_t \text{sign}(g_t)
    /// 
    /// It updates the weights using::
    /// 
    ///  weight = weight - learning_rate * sign(gradient)
    /// 
    /// .. note::
    ///    - sparse ndarray not supported for this optimizer yet.
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\optimizer_op.cc:L63</summary>
    /// <param name="weight">Weight</param>
    /// <param name="grad">Gradient</param>
    /// <param name="lr">Learning rate</param>
    /// <param name="wd">Weight decay augments the objective function with a regularization term that penalizes large weights. The penalty scales with the square of the magnitude of each weight.</param>
    /// <param name="rescaleGrad">Rescale gradient to grad = rescale_grad*grad.</param>
    /// <param name="clipGradient">Clip gradient to the range of [-clip_gradient, clip_gradient] If clip_gradient &lt;= 0, gradient clipping is turned off. grad = max(min(grad, clip_gradient), -clip_gradient).</param>
    static member SignsgdUpdate(weight : NDArray, 
                                grad : NDArray, 
                                lr : float, 
                                [<Optional; DefaultParameterValue(0.0)>] wd : float, 
                                [<Optional; DefaultParameterValue(1.0)>] rescaleGrad : float, 
                                [<Optional; DefaultParameterValue(-1.0)>] clipGradient : float) =
        let creator = AtomicSymbolCreator.FromName "signsgd_update"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg weight)) then weight.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg grad)) then grad.UnsafeHandle|]
                                                 [|"lr"; "wd"; "rescale_grad"; "clip_gradient"|]
                                                 [|string lr; string wd; string rescaleGrad; string clipGradient|]
        (new NDArray(outputs.[0]))
    /// <summary>Update function for SignSGD optimizer.
    /// 
    /// .. math::
    /// 
    ///  g_t = \nabla J(W_{t-1})\\
    ///  W_t = W_{t-1} - \eta_t \text{sign}(g_t)
    /// 
    /// It updates the weights using::
    /// 
    ///  weight = weight - learning_rate * sign(gradient)
    /// 
    /// .. note::
    ///    - sparse ndarray not supported for this optimizer yet.
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\optimizer_op.cc:L63</summary>
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="weight">Weight</param>
    /// <param name="grad">Gradient</param>
    /// <param name="lr">Learning rate</param>
    /// <param name="wd">Weight decay augments the objective function with a regularization term that penalizes large weights. The penalty scales with the square of the magnitude of each weight.</param>
    /// <param name="rescaleGrad">Rescale gradient to grad = rescale_grad*grad.</param>
    /// <param name="clipGradient">Clip gradient to the range of [-clip_gradient, clip_gradient] If clip_gradient &lt;= 0, gradient clipping is turned off. grad = max(min(grad, clip_gradient), -clip_gradient).</param>
    static member SignsgdUpdate(outputArray : NDArray seq, 
                                weight : NDArray, 
                                grad : NDArray, 
                                lr : float, 
                                [<Optional; DefaultParameterValue(0.0)>] wd : float, 
                                [<Optional; DefaultParameterValue(1.0)>] rescaleGrad : float, 
                                [<Optional; DefaultParameterValue(-1.0)>] clipGradient : float) =
        let creator = AtomicSymbolCreator.FromName "signsgd_update"
        let names = [|"lr"; "wd"; "rescale_grad"; "clip_gradient"|]
        let vals = [|string lr; string wd; string rescaleGrad; string clipGradient|]
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg weight)) then weight.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg grad)) then grad.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <summary>Update function for SignSGD optimizer.
    /// 
    /// .. math::
    /// 
    ///  g_t = \nabla J(W_{t-1})\\
    ///  W_t = W_{t-1} - \eta_t \text{sign}(g_t)
    /// 
    /// It updates the weights using::
    /// 
    ///  weight = weight - learning_rate * sign(gradient)
    /// 
    /// .. note::
    ///    - sparse ndarray not supported for this optimizer yet.
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\optimizer_op.cc:L63</summary>
    /// <param name="weight">Weight</param>
    /// <param name="grad">Gradient</param>
    /// <param name="lr">Learning rate</param>
    /// <param name="wd">Weight decay augments the objective function with a regularization term that penalizes large weights. The penalty scales with the square of the magnitude of each weight.</param>
    /// <param name="rescaleGrad">Rescale gradient to grad = rescale_grad*grad.</param>
    /// <param name="clipGradient">Clip gradient to the range of [-clip_gradient, clip_gradient] If clip_gradient &lt;= 0, gradient clipping is turned off. grad = max(min(grad, clip_gradient), -clip_gradient).</param>
    static member SignsgdUpdate(weight : Symbol, grad : Symbol, lr : float, [<Optional>] ?wd : float, [<Optional>] ?rescaleGrad : float, [<Optional>] ?clipGradient : float) =
        SignsgdUpdate(weight, grad, lr, ?wd = wd, ?rescaleGrad = rescaleGrad, ?clipGradient = clipGradient)
    /// <summary>Update function for SignSGD optimizer.
    /// 
    /// .. math::
    /// 
    ///  g_t = \nabla J(W_{t-1})\\
    ///  W_t = W_{t-1} - \eta_t \text{sign}(g_t)
    /// 
    /// It updates the weights using::
    /// 
    ///  weight = weight - learning_rate * sign(gradient)
    /// 
    /// .. note::
    ///    - sparse ndarray not supported for this optimizer yet.
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\optimizer_op.cc:L63</summary>
    /// <param name="lr">Learning rate</param>
    /// <param name="weight">Weight</param>
    /// <param name="grad">Gradient</param>
    /// <param name="wd">Weight decay augments the objective function with a regularization term that penalizes large weights. The penalty scales with the square of the magnitude of each weight.</param>
    /// <param name="rescaleGrad">Rescale gradient to grad = rescale_grad*grad.</param>
    /// <param name="clipGradient">Clip gradient to the range of [-clip_gradient, clip_gradient] If clip_gradient &lt;= 0, gradient clipping is turned off. grad = max(min(grad, clip_gradient), -clip_gradient).</param>
    static member SignsgdUpdate(lr : float, [<Optional>] ?weight : Symbol, [<Optional>] ?grad : Symbol, [<Optional>] ?wd : float, [<Optional>] ?rescaleGrad : float, [<Optional>] ?clipGradient : float) =
        SignsgdUpdate(lr, ?weight = weight, ?grad = grad, ?wd = wd, ?rescaleGrad = rescaleGrad, ?clipGradient = clipGradient)

    /// <summary>SIGN momentUM (Signum) optimizer.
    /// 
    /// .. math::
    /// 
    ///  g_t = \nabla J(W_{t-1})\\
    ///  m_t = \beta m_{t-1} + (1 - \beta) g_t\\
    ///  W_t = W_{t-1} - \eta_t \text{sign}(m_t)
    /// 
    /// It updates the weights using::
    ///  state = momentum * state + (1-momentum) * gradient
    ///  weight = weight - learning_rate * sign(state)
    /// 
    /// Where the parameter ``momentum`` is the decay rate of momentum estimates at each epoch.
    /// 
    /// .. note::
    ///    - sparse ndarray not supported for this optimizer yet.
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\optimizer_op.cc:L92</summary>
    /// <param name="weight">Weight</param>
    /// <param name="grad">Gradient</param>
    /// <param name="mom">Momentum</param>
    /// <param name="lr">Learning rate</param>
    /// <param name="momentum">The decay rate of momentum estimates at each epoch.</param>
    /// <param name="wd">Weight decay augments the objective function with a regularization term that penalizes large weights. The penalty scales with the square of the magnitude of each weight.</param>
    /// <param name="rescaleGrad">Rescale gradient to grad = rescale_grad*grad.</param>
    /// <param name="clipGradient">Clip gradient to the range of [-clip_gradient, clip_gradient] If clip_gradient &lt;= 0, gradient clipping is turned off. grad = max(min(grad, clip_gradient), -clip_gradient).</param>
    /// <param name="wdLh">The amount of weight decay that does not go into gradient/momentum calculationsotherwise do weight decay algorithmically only.</param>
    static member SignumUpdate(weight : NDArray, 
                               grad : NDArray, 
                               mom : NDArray, 
                               lr : float, 
                               [<Optional; DefaultParameterValue(0.0)>] momentum : float, 
                               [<Optional; DefaultParameterValue(0.0)>] wd : float, 
                               [<Optional; DefaultParameterValue(1.0)>] rescaleGrad : float, 
                               [<Optional; DefaultParameterValue(-1.0)>] clipGradient : float, 
                               [<Optional; DefaultParameterValue(0.0)>] wdLh : float) =
        let creator = AtomicSymbolCreator.FromName "signum_update"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg weight)) then weight.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg grad)) then grad.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg mom)) then mom.UnsafeHandle|]
                                                 [|"lr"; "momentum"; "wd"; "rescale_grad"; "clip_gradient"; "wd_lh"|]
                                                 [|string lr; string momentum; string wd; string rescaleGrad; string clipGradient; string wdLh|]
        (new NDArray(outputs.[0]))
    /// <summary>SIGN momentUM (Signum) optimizer.
    /// 
    /// .. math::
    /// 
    ///  g_t = \nabla J(W_{t-1})\\
    ///  m_t = \beta m_{t-1} + (1 - \beta) g_t\\
    ///  W_t = W_{t-1} - \eta_t \text{sign}(m_t)
    /// 
    /// It updates the weights using::
    ///  state = momentum * state + (1-momentum) * gradient
    ///  weight = weight - learning_rate * sign(state)
    /// 
    /// Where the parameter ``momentum`` is the decay rate of momentum estimates at each epoch.
    /// 
    /// .. note::
    ///    - sparse ndarray not supported for this optimizer yet.
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\optimizer_op.cc:L92</summary>
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="weight">Weight</param>
    /// <param name="grad">Gradient</param>
    /// <param name="mom">Momentum</param>
    /// <param name="lr">Learning rate</param>
    /// <param name="momentum">The decay rate of momentum estimates at each epoch.</param>
    /// <param name="wd">Weight decay augments the objective function with a regularization term that penalizes large weights. The penalty scales with the square of the magnitude of each weight.</param>
    /// <param name="rescaleGrad">Rescale gradient to grad = rescale_grad*grad.</param>
    /// <param name="clipGradient">Clip gradient to the range of [-clip_gradient, clip_gradient] If clip_gradient &lt;= 0, gradient clipping is turned off. grad = max(min(grad, clip_gradient), -clip_gradient).</param>
    /// <param name="wdLh">The amount of weight decay that does not go into gradient/momentum calculationsotherwise do weight decay algorithmically only.</param>
    static member SignumUpdate(outputArray : NDArray seq, 
                               weight : NDArray, 
                               grad : NDArray, 
                               mom : NDArray, 
                               lr : float, 
                               [<Optional; DefaultParameterValue(0.0)>] momentum : float, 
                               [<Optional; DefaultParameterValue(0.0)>] wd : float, 
                               [<Optional; DefaultParameterValue(1.0)>] rescaleGrad : float, 
                               [<Optional; DefaultParameterValue(-1.0)>] clipGradient : float, 
                               [<Optional; DefaultParameterValue(0.0)>] wdLh : float) =
        let creator = AtomicSymbolCreator.FromName "signum_update"
        let names = [|"lr"; "momentum"; "wd"; "rescale_grad"; "clip_gradient"; "wd_lh"|]
        let vals = [|string lr; string momentum; string wd; string rescaleGrad; string clipGradient; string wdLh|]
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg weight)) then weight.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg grad)) then grad.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg mom)) then mom.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <summary>SIGN momentUM (Signum) optimizer.
    /// 
    /// .. math::
    /// 
    ///  g_t = \nabla J(W_{t-1})\\
    ///  m_t = \beta m_{t-1} + (1 - \beta) g_t\\
    ///  W_t = W_{t-1} - \eta_t \text{sign}(m_t)
    /// 
    /// It updates the weights using::
    ///  state = momentum * state + (1-momentum) * gradient
    ///  weight = weight - learning_rate * sign(state)
    /// 
    /// Where the parameter ``momentum`` is the decay rate of momentum estimates at each epoch.
    /// 
    /// .. note::
    ///    - sparse ndarray not supported for this optimizer yet.
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\optimizer_op.cc:L92</summary>
    /// <param name="weight">Weight</param>
    /// <param name="grad">Gradient</param>
    /// <param name="mom">Momentum</param>
    /// <param name="lr">Learning rate</param>
    /// <param name="momentum">The decay rate of momentum estimates at each epoch.</param>
    /// <param name="wd">Weight decay augments the objective function with a regularization term that penalizes large weights. The penalty scales with the square of the magnitude of each weight.</param>
    /// <param name="rescaleGrad">Rescale gradient to grad = rescale_grad*grad.</param>
    /// <param name="clipGradient">Clip gradient to the range of [-clip_gradient, clip_gradient] If clip_gradient &lt;= 0, gradient clipping is turned off. grad = max(min(grad, clip_gradient), -clip_gradient).</param>
    /// <param name="wdLh">The amount of weight decay that does not go into gradient/momentum calculationsotherwise do weight decay algorithmically only.</param>
    static member SignumUpdate(weight : Symbol, grad : Symbol, mom : Symbol, lr : float, [<Optional>] ?momentum : float, [<Optional>] ?wd : float, [<Optional>] ?rescaleGrad : float, [<Optional>] ?clipGradient : float, [<Optional>] ?wdLh : float) =
        SignumUpdate(weight, grad, mom, lr, ?momentum = momentum, ?wd = wd, ?rescaleGrad = rescaleGrad, ?clipGradient = clipGradient, ?wdLh = wdLh)
    /// <summary>SIGN momentUM (Signum) optimizer.
    /// 
    /// .. math::
    /// 
    ///  g_t = \nabla J(W_{t-1})\\
    ///  m_t = \beta m_{t-1} + (1 - \beta) g_t\\
    ///  W_t = W_{t-1} - \eta_t \text{sign}(m_t)
    /// 
    /// It updates the weights using::
    ///  state = momentum * state + (1-momentum) * gradient
    ///  weight = weight - learning_rate * sign(state)
    /// 
    /// Where the parameter ``momentum`` is the decay rate of momentum estimates at each epoch.
    /// 
    /// .. note::
    ///    - sparse ndarray not supported for this optimizer yet.
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\optimizer_op.cc:L92</summary>
    /// <param name="lr">Learning rate</param>
    /// <param name="weight">Weight</param>
    /// <param name="grad">Gradient</param>
    /// <param name="mom">Momentum</param>
    /// <param name="momentum">The decay rate of momentum estimates at each epoch.</param>
    /// <param name="wd">Weight decay augments the objective function with a regularization term that penalizes large weights. The penalty scales with the square of the magnitude of each weight.</param>
    /// <param name="rescaleGrad">Rescale gradient to grad = rescale_grad*grad.</param>
    /// <param name="clipGradient">Clip gradient to the range of [-clip_gradient, clip_gradient] If clip_gradient &lt;= 0, gradient clipping is turned off. grad = max(min(grad, clip_gradient), -clip_gradient).</param>
    /// <param name="wdLh">The amount of weight decay that does not go into gradient/momentum calculationsotherwise do weight decay algorithmically only.</param>
    static member SignumUpdate(lr : float, [<Optional>] ?weight : Symbol, [<Optional>] ?grad : Symbol, [<Optional>] ?mom : Symbol, [<Optional>] ?momentum : float, [<Optional>] ?wd : float, [<Optional>] ?rescaleGrad : float, [<Optional>] ?clipGradient : float, [<Optional>] ?wdLh : float) =
        SignumUpdate(lr, ?weight = weight, ?grad = grad, ?mom = mom, ?momentum = momentum, ?wd = wd, ?rescaleGrad = rescaleGrad, ?clipGradient = clipGradient, ?wdLh = wdLh)

    /// <summary>Update function for Stochastic Gradient Descent (SDG) optimizer.
    /// 
    /// It updates the weights using::
    /// 
    ///  weight = weight - learning_rate * (gradient + wd * weight)
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\optimizer_op.cc:L329</summary>
    /// <param name="data">Weights</param>
    /// <param name="lrs">Learning rates.</param>
    /// <param name="wds">Weight decay augments the objective function with a regularization term that penalizes large weights. The penalty scales with the square of the magnitude of each weight.</param>
    /// <param name="rescaleGrad">Rescale gradient to grad = rescale_grad*grad.</param>
    /// <param name="clipGradient">Clip gradient to the range of [-clip_gradient, clip_gradient] If clip_gradient &lt;= 0, gradient clipping is turned off. grad = max(min(grad, clip_gradient), -clip_gradient).</param>
    /// <param name="numWeights">Number of updated weights.</param>
    static member MultiSgdUpdate([<ParamArray>] data : NDArray[], 
                                 lrs : double seq, 
                                 wds : double seq, 
                                 [<Optional; DefaultParameterValue(1.0)>] rescaleGrad : float, 
                                 [<Optional; DefaultParameterValue(-1.0)>] clipGradient : float, 
                                 [<Optional; DefaultParameterValue(1)>] numWeights : int) =
        let creator = AtomicSymbolCreator.FromName "multi_sgd_update"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 (data |> Array.map (fun x -> x.UnsafeHandle))
                                                 [|"lrs"; "wds"; "rescale_grad"; "clip_gradient"; "num_weights"|]
                                                 [|string lrs; string wds; string rescaleGrad; string clipGradient; string numWeights|]
        outputs |> Array.map (fun h -> new NDArray(h))
    /// <summary>Update function for Stochastic Gradient Descent (SDG) optimizer.
    /// 
    /// It updates the weights using::
    /// 
    ///  weight = weight - learning_rate * (gradient + wd * weight)
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\optimizer_op.cc:L329</summary>
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="data">Weights</param>
    /// <param name="lrs">Learning rates.</param>
    /// <param name="wds">Weight decay augments the objective function with a regularization term that penalizes large weights. The penalty scales with the square of the magnitude of each weight.</param>
    /// <param name="rescaleGrad">Rescale gradient to grad = rescale_grad*grad.</param>
    /// <param name="clipGradient">Clip gradient to the range of [-clip_gradient, clip_gradient] If clip_gradient &lt;= 0, gradient clipping is turned off. grad = max(min(grad, clip_gradient), -clip_gradient).</param>
    /// <param name="numWeights">Number of updated weights.</param>
    static member MultiSgdUpdate(outputArray : NDArray seq, 
                                 [<ParamArray>] data : NDArray[], 
                                 lrs : double seq, 
                                 wds : double seq, 
                                 [<Optional; DefaultParameterValue(1.0)>] rescaleGrad : float, 
                                 [<Optional; DefaultParameterValue(-1.0)>] clipGradient : float, 
                                 [<Optional; DefaultParameterValue(1)>] numWeights : int) =
        let creator = AtomicSymbolCreator.FromName "multi_sgd_update"
        let names = [|"lrs"; "wds"; "rescale_grad"; "clip_gradient"; "num_weights"|]
        let vals = [|string lrs; string wds; string rescaleGrad; string clipGradient; string numWeights|]
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     (data |> Array.map (fun x -> x.UnsafeHandle))
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <summary>Update function for Stochastic Gradient Descent (SDG) optimizer.
    /// 
    /// It updates the weights using::
    /// 
    ///  weight = weight - learning_rate * (gradient + wd * weight)
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\optimizer_op.cc:L329</summary>
    /// <param name="data">Weights</param>
    /// <param name="lrs">Learning rates.</param>
    /// <param name="wds">Weight decay augments the objective function with a regularization term that penalizes large weights. The penalty scales with the square of the magnitude of each weight.</param>
    /// <param name="rescaleGrad">Rescale gradient to grad = rescale_grad*grad.</param>
    /// <param name="clipGradient">Clip gradient to the range of [-clip_gradient, clip_gradient] If clip_gradient &lt;= 0, gradient clipping is turned off. grad = max(min(grad, clip_gradient), -clip_gradient).</param>
    /// <param name="numWeights">Number of updated weights.</param>
    static member MultiSgdUpdate(data : Symbol seq, lrs : double seq, wds : double seq, [<Optional>] ?rescaleGrad : float, [<Optional>] ?clipGradient : float, [<Optional>] ?numWeights : int) =
        MultiSgdUpdate(data, lrs, wds, ?rescaleGrad = rescaleGrad, ?clipGradient = clipGradient, ?numWeights = numWeights)
    /// <summary>Update function for Stochastic Gradient Descent (SDG) optimizer.
    /// 
    /// It updates the weights using::
    /// 
    ///  weight = weight - learning_rate * (gradient + wd * weight)
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\optimizer_op.cc:L329</summary>
    /// <param name="lrs">Learning rates.</param>
    /// <param name="wds">Weight decay augments the objective function with a regularization term that penalizes large weights. The penalty scales with the square of the magnitude of each weight.</param>
    /// <param name="data">Weights</param>
    /// <param name="rescaleGrad">Rescale gradient to grad = rescale_grad*grad.</param>
    /// <param name="clipGradient">Clip gradient to the range of [-clip_gradient, clip_gradient] If clip_gradient &lt;= 0, gradient clipping is turned off. grad = max(min(grad, clip_gradient), -clip_gradient).</param>
    /// <param name="numWeights">Number of updated weights.</param>
    static member MultiSgdUpdate(lrs : double seq, wds : double seq, [<Optional>] ?data : Symbol seq, [<Optional>] ?rescaleGrad : float, [<Optional>] ?clipGradient : float, [<Optional>] ?numWeights : int) =
        MultiSgdUpdate(lrs, wds, ?data = data, ?rescaleGrad = rescaleGrad, ?clipGradient = clipGradient, ?numWeights = numWeights)

    /// <summary>Momentum update function for Stochastic Gradient Descent (SGD) optimizer.
    /// 
    /// Momentum update has better convergence rates on neural networks. Mathematically it looks
    /// like below:
    /// 
    /// .. math::
    /// 
    ///   v_1 = \alpha * \nabla J(W_0)\\
    ///   v_t = \gamma v_{t-1} - \alpha * \nabla J(W_{t-1})\\
    ///   W_t = W_{t-1} + v_t
    /// 
    /// It updates the weights using::
    /// 
    ///   v = momentum * v - learning_rate * gradient
    ///   weight += v
    /// 
    /// Where the parameter ``momentum`` is the decay rate of momentum estimates at each epoch.
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\optimizer_op.cc:L374</summary>
    /// <param name="data">Weights, gradients and momentum</param>
    /// <param name="lrs">Learning rates.</param>
    /// <param name="wds">Weight decay augments the objective function with a regularization term that penalizes large weights. The penalty scales with the square of the magnitude of each weight.</param>
    /// <param name="momentum">The decay rate of momentum estimates at each epoch.</param>
    /// <param name="rescaleGrad">Rescale gradient to grad = rescale_grad*grad.</param>
    /// <param name="clipGradient">Clip gradient to the range of [-clip_gradient, clip_gradient] If clip_gradient &lt;= 0, gradient clipping is turned off. grad = max(min(grad, clip_gradient), -clip_gradient).</param>
    /// <param name="numWeights">Number of updated weights.</param>
    static member MultiSgdMomUpdate([<ParamArray>] data : NDArray[], 
                                    lrs : double seq, 
                                    wds : double seq, 
                                    [<Optional; DefaultParameterValue(0.0)>] momentum : float, 
                                    [<Optional; DefaultParameterValue(1.0)>] rescaleGrad : float, 
                                    [<Optional; DefaultParameterValue(-1.0)>] clipGradient : float, 
                                    [<Optional; DefaultParameterValue(1)>] numWeights : int) =
        let creator = AtomicSymbolCreator.FromName "multi_sgd_mom_update"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 (data |> Array.map (fun x -> x.UnsafeHandle))
                                                 [|"lrs"; "wds"; "momentum"; "rescale_grad"; "clip_gradient"; "num_weights"|]
                                                 [|string lrs; string wds; string momentum; string rescaleGrad; string clipGradient; string numWeights|]
        outputs |> Array.map (fun h -> new NDArray(h))
    /// <summary>Momentum update function for Stochastic Gradient Descent (SGD) optimizer.
    /// 
    /// Momentum update has better convergence rates on neural networks. Mathematically it looks
    /// like below:
    /// 
    /// .. math::
    /// 
    ///   v_1 = \alpha * \nabla J(W_0)\\
    ///   v_t = \gamma v_{t-1} - \alpha * \nabla J(W_{t-1})\\
    ///   W_t = W_{t-1} + v_t
    /// 
    /// It updates the weights using::
    /// 
    ///   v = momentum * v - learning_rate * gradient
    ///   weight += v
    /// 
    /// Where the parameter ``momentum`` is the decay rate of momentum estimates at each epoch.
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\optimizer_op.cc:L374</summary>
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="data">Weights, gradients and momentum</param>
    /// <param name="lrs">Learning rates.</param>
    /// <param name="wds">Weight decay augments the objective function with a regularization term that penalizes large weights. The penalty scales with the square of the magnitude of each weight.</param>
    /// <param name="momentum">The decay rate of momentum estimates at each epoch.</param>
    /// <param name="rescaleGrad">Rescale gradient to grad = rescale_grad*grad.</param>
    /// <param name="clipGradient">Clip gradient to the range of [-clip_gradient, clip_gradient] If clip_gradient &lt;= 0, gradient clipping is turned off. grad = max(min(grad, clip_gradient), -clip_gradient).</param>
    /// <param name="numWeights">Number of updated weights.</param>
    static member MultiSgdMomUpdate(outputArray : NDArray seq, 
                                    [<ParamArray>] data : NDArray[], 
                                    lrs : double seq, 
                                    wds : double seq, 
                                    [<Optional; DefaultParameterValue(0.0)>] momentum : float, 
                                    [<Optional; DefaultParameterValue(1.0)>] rescaleGrad : float, 
                                    [<Optional; DefaultParameterValue(-1.0)>] clipGradient : float, 
                                    [<Optional; DefaultParameterValue(1)>] numWeights : int) =
        let creator = AtomicSymbolCreator.FromName "multi_sgd_mom_update"
        let names = [|"lrs"; "wds"; "momentum"; "rescale_grad"; "clip_gradient"; "num_weights"|]
        let vals = [|string lrs; string wds; string momentum; string rescaleGrad; string clipGradient; string numWeights|]
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     (data |> Array.map (fun x -> x.UnsafeHandle))
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <summary>Momentum update function for Stochastic Gradient Descent (SGD) optimizer.
    /// 
    /// Momentum update has better convergence rates on neural networks. Mathematically it looks
    /// like below:
    /// 
    /// .. math::
    /// 
    ///   v_1 = \alpha * \nabla J(W_0)\\
    ///   v_t = \gamma v_{t-1} - \alpha * \nabla J(W_{t-1})\\
    ///   W_t = W_{t-1} + v_t
    /// 
    /// It updates the weights using::
    /// 
    ///   v = momentum * v - learning_rate * gradient
    ///   weight += v
    /// 
    /// Where the parameter ``momentum`` is the decay rate of momentum estimates at each epoch.
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\optimizer_op.cc:L374</summary>
    /// <param name="data">Weights, gradients and momentum</param>
    /// <param name="lrs">Learning rates.</param>
    /// <param name="wds">Weight decay augments the objective function with a regularization term that penalizes large weights. The penalty scales with the square of the magnitude of each weight.</param>
    /// <param name="momentum">The decay rate of momentum estimates at each epoch.</param>
    /// <param name="rescaleGrad">Rescale gradient to grad = rescale_grad*grad.</param>
    /// <param name="clipGradient">Clip gradient to the range of [-clip_gradient, clip_gradient] If clip_gradient &lt;= 0, gradient clipping is turned off. grad = max(min(grad, clip_gradient), -clip_gradient).</param>
    /// <param name="numWeights">Number of updated weights.</param>
    static member MultiSgdMomUpdate(data : Symbol seq, lrs : double seq, wds : double seq, [<Optional>] ?momentum : float, [<Optional>] ?rescaleGrad : float, [<Optional>] ?clipGradient : float, [<Optional>] ?numWeights : int) =
        MultiSgdMomUpdate(data, lrs, wds, ?momentum = momentum, ?rescaleGrad = rescaleGrad, ?clipGradient = clipGradient, ?numWeights = numWeights)
    /// <summary>Momentum update function for Stochastic Gradient Descent (SGD) optimizer.
    /// 
    /// Momentum update has better convergence rates on neural networks. Mathematically it looks
    /// like below:
    /// 
    /// .. math::
    /// 
    ///   v_1 = \alpha * \nabla J(W_0)\\
    ///   v_t = \gamma v_{t-1} - \alpha * \nabla J(W_{t-1})\\
    ///   W_t = W_{t-1} + v_t
    /// 
    /// It updates the weights using::
    /// 
    ///   v = momentum * v - learning_rate * gradient
    ///   weight += v
    /// 
    /// Where the parameter ``momentum`` is the decay rate of momentum estimates at each epoch.
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\optimizer_op.cc:L374</summary>
    /// <param name="lrs">Learning rates.</param>
    /// <param name="wds">Weight decay augments the objective function with a regularization term that penalizes large weights. The penalty scales with the square of the magnitude of each weight.</param>
    /// <param name="data">Weights, gradients and momentum</param>
    /// <param name="momentum">The decay rate of momentum estimates at each epoch.</param>
    /// <param name="rescaleGrad">Rescale gradient to grad = rescale_grad*grad.</param>
    /// <param name="clipGradient">Clip gradient to the range of [-clip_gradient, clip_gradient] If clip_gradient &lt;= 0, gradient clipping is turned off. grad = max(min(grad, clip_gradient), -clip_gradient).</param>
    /// <param name="numWeights">Number of updated weights.</param>
    static member MultiSgdMomUpdate(lrs : double seq, wds : double seq, [<Optional>] ?data : Symbol seq, [<Optional>] ?momentum : float, [<Optional>] ?rescaleGrad : float, [<Optional>] ?clipGradient : float, [<Optional>] ?numWeights : int) =
        MultiSgdMomUpdate(lrs, wds, ?data = data, ?momentum = momentum, ?rescaleGrad = rescaleGrad, ?clipGradient = clipGradient, ?numWeights = numWeights)

    /// <summary>Update function for multi-precision Stochastic Gradient Descent (SDG) optimizer.
    /// 
    /// It updates the weights using::
    /// 
    ///  weight = weight - learning_rate * (gradient + wd * weight)
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\optimizer_op.cc:L417</summary>
    /// <param name="data">Weights</param>
    /// <param name="lrs">Learning rates.</param>
    /// <param name="wds">Weight decay augments the objective function with a regularization term that penalizes large weights. The penalty scales with the square of the magnitude of each weight.</param>
    /// <param name="rescaleGrad">Rescale gradient to grad = rescale_grad*grad.</param>
    /// <param name="clipGradient">Clip gradient to the range of [-clip_gradient, clip_gradient] If clip_gradient &lt;= 0, gradient clipping is turned off. grad = max(min(grad, clip_gradient), -clip_gradient).</param>
    /// <param name="numWeights">Number of updated weights.</param>
    static member MultiMpSgdUpdate([<ParamArray>] data : NDArray[], 
                                   lrs : double seq, 
                                   wds : double seq, 
                                   [<Optional; DefaultParameterValue(1.0)>] rescaleGrad : float, 
                                   [<Optional; DefaultParameterValue(-1.0)>] clipGradient : float, 
                                   [<Optional; DefaultParameterValue(1)>] numWeights : int) =
        let creator = AtomicSymbolCreator.FromName "multi_mp_sgd_update"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 (data |> Array.map (fun x -> x.UnsafeHandle))
                                                 [|"lrs"; "wds"; "rescale_grad"; "clip_gradient"; "num_weights"|]
                                                 [|string lrs; string wds; string rescaleGrad; string clipGradient; string numWeights|]
        outputs |> Array.map (fun h -> new NDArray(h))
    /// <summary>Update function for multi-precision Stochastic Gradient Descent (SDG) optimizer.
    /// 
    /// It updates the weights using::
    /// 
    ///  weight = weight - learning_rate * (gradient + wd * weight)
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\optimizer_op.cc:L417</summary>
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="data">Weights</param>
    /// <param name="lrs">Learning rates.</param>
    /// <param name="wds">Weight decay augments the objective function with a regularization term that penalizes large weights. The penalty scales with the square of the magnitude of each weight.</param>
    /// <param name="rescaleGrad">Rescale gradient to grad = rescale_grad*grad.</param>
    /// <param name="clipGradient">Clip gradient to the range of [-clip_gradient, clip_gradient] If clip_gradient &lt;= 0, gradient clipping is turned off. grad = max(min(grad, clip_gradient), -clip_gradient).</param>
    /// <param name="numWeights">Number of updated weights.</param>
    static member MultiMpSgdUpdate(outputArray : NDArray seq, 
                                   [<ParamArray>] data : NDArray[], 
                                   lrs : double seq, 
                                   wds : double seq, 
                                   [<Optional; DefaultParameterValue(1.0)>] rescaleGrad : float, 
                                   [<Optional; DefaultParameterValue(-1.0)>] clipGradient : float, 
                                   [<Optional; DefaultParameterValue(1)>] numWeights : int) =
        let creator = AtomicSymbolCreator.FromName "multi_mp_sgd_update"
        let names = [|"lrs"; "wds"; "rescale_grad"; "clip_gradient"; "num_weights"|]
        let vals = [|string lrs; string wds; string rescaleGrad; string clipGradient; string numWeights|]
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     (data |> Array.map (fun x -> x.UnsafeHandle))
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <summary>Update function for multi-precision Stochastic Gradient Descent (SDG) optimizer.
    /// 
    /// It updates the weights using::
    /// 
    ///  weight = weight - learning_rate * (gradient + wd * weight)
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\optimizer_op.cc:L417</summary>
    /// <param name="data">Weights</param>
    /// <param name="lrs">Learning rates.</param>
    /// <param name="wds">Weight decay augments the objective function with a regularization term that penalizes large weights. The penalty scales with the square of the magnitude of each weight.</param>
    /// <param name="rescaleGrad">Rescale gradient to grad = rescale_grad*grad.</param>
    /// <param name="clipGradient">Clip gradient to the range of [-clip_gradient, clip_gradient] If clip_gradient &lt;= 0, gradient clipping is turned off. grad = max(min(grad, clip_gradient), -clip_gradient).</param>
    /// <param name="numWeights">Number of updated weights.</param>
    static member MultiMpSgdUpdate(data : Symbol seq, lrs : double seq, wds : double seq, [<Optional>] ?rescaleGrad : float, [<Optional>] ?clipGradient : float, [<Optional>] ?numWeights : int) =
        MultiMpSgdUpdate(data, lrs, wds, ?rescaleGrad = rescaleGrad, ?clipGradient = clipGradient, ?numWeights = numWeights)
    /// <summary>Update function for multi-precision Stochastic Gradient Descent (SDG) optimizer.
    /// 
    /// It updates the weights using::
    /// 
    ///  weight = weight - learning_rate * (gradient + wd * weight)
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\optimizer_op.cc:L417</summary>
    /// <param name="lrs">Learning rates.</param>
    /// <param name="wds">Weight decay augments the objective function with a regularization term that penalizes large weights. The penalty scales with the square of the magnitude of each weight.</param>
    /// <param name="data">Weights</param>
    /// <param name="rescaleGrad">Rescale gradient to grad = rescale_grad*grad.</param>
    /// <param name="clipGradient">Clip gradient to the range of [-clip_gradient, clip_gradient] If clip_gradient &lt;= 0, gradient clipping is turned off. grad = max(min(grad, clip_gradient), -clip_gradient).</param>
    /// <param name="numWeights">Number of updated weights.</param>
    static member MultiMpSgdUpdate(lrs : double seq, wds : double seq, [<Optional>] ?data : Symbol seq, [<Optional>] ?rescaleGrad : float, [<Optional>] ?clipGradient : float, [<Optional>] ?numWeights : int) =
        MultiMpSgdUpdate(lrs, wds, ?data = data, ?rescaleGrad = rescaleGrad, ?clipGradient = clipGradient, ?numWeights = numWeights)

    /// <summary>Momentum update function for multi-precision Stochastic Gradient Descent (SGD) optimizer.
    /// 
    /// Momentum update has better convergence rates on neural networks. Mathematically it looks
    /// like below:
    /// 
    /// .. math::
    /// 
    ///   v_1 = \alpha * \nabla J(W_0)\\
    ///   v_t = \gamma v_{t-1} - \alpha * \nabla J(W_{t-1})\\
    ///   W_t = W_{t-1} + v_t
    /// 
    /// It updates the weights using::
    /// 
    ///   v = momentum * v - learning_rate * gradient
    ///   weight += v
    /// 
    /// Where the parameter ``momentum`` is the decay rate of momentum estimates at each epoch.
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\optimizer_op.cc:L472</summary>
    /// <param name="data">Weights</param>
    /// <param name="lrs">Learning rates.</param>
    /// <param name="wds">Weight decay augments the objective function with a regularization term that penalizes large weights. The penalty scales with the square of the magnitude of each weight.</param>
    /// <param name="momentum">The decay rate of momentum estimates at each epoch.</param>
    /// <param name="rescaleGrad">Rescale gradient to grad = rescale_grad*grad.</param>
    /// <param name="clipGradient">Clip gradient to the range of [-clip_gradient, clip_gradient] If clip_gradient &lt;= 0, gradient clipping is turned off. grad = max(min(grad, clip_gradient), -clip_gradient).</param>
    /// <param name="numWeights">Number of updated weights.</param>
    static member MultiMpSgdMomUpdate([<ParamArray>] data : NDArray[], 
                                      lrs : double seq, 
                                      wds : double seq, 
                                      [<Optional; DefaultParameterValue(0.0)>] momentum : float, 
                                      [<Optional; DefaultParameterValue(1.0)>] rescaleGrad : float, 
                                      [<Optional; DefaultParameterValue(-1.0)>] clipGradient : float, 
                                      [<Optional; DefaultParameterValue(1)>] numWeights : int) =
        let creator = AtomicSymbolCreator.FromName "multi_mp_sgd_mom_update"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 (data |> Array.map (fun x -> x.UnsafeHandle))
                                                 [|"lrs"; "wds"; "momentum"; "rescale_grad"; "clip_gradient"; "num_weights"|]
                                                 [|string lrs; string wds; string momentum; string rescaleGrad; string clipGradient; string numWeights|]
        outputs |> Array.map (fun h -> new NDArray(h))
    /// <summary>Momentum update function for multi-precision Stochastic Gradient Descent (SGD) optimizer.
    /// 
    /// Momentum update has better convergence rates on neural networks. Mathematically it looks
    /// like below:
    /// 
    /// .. math::
    /// 
    ///   v_1 = \alpha * \nabla J(W_0)\\
    ///   v_t = \gamma v_{t-1} - \alpha * \nabla J(W_{t-1})\\
    ///   W_t = W_{t-1} + v_t
    /// 
    /// It updates the weights using::
    /// 
    ///   v = momentum * v - learning_rate * gradient
    ///   weight += v
    /// 
    /// Where the parameter ``momentum`` is the decay rate of momentum estimates at each epoch.
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\optimizer_op.cc:L472</summary>
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="data">Weights</param>
    /// <param name="lrs">Learning rates.</param>
    /// <param name="wds">Weight decay augments the objective function with a regularization term that penalizes large weights. The penalty scales with the square of the magnitude of each weight.</param>
    /// <param name="momentum">The decay rate of momentum estimates at each epoch.</param>
    /// <param name="rescaleGrad">Rescale gradient to grad = rescale_grad*grad.</param>
    /// <param name="clipGradient">Clip gradient to the range of [-clip_gradient, clip_gradient] If clip_gradient &lt;= 0, gradient clipping is turned off. grad = max(min(grad, clip_gradient), -clip_gradient).</param>
    /// <param name="numWeights">Number of updated weights.</param>
    static member MultiMpSgdMomUpdate(outputArray : NDArray seq, 
                                      [<ParamArray>] data : NDArray[], 
                                      lrs : double seq, 
                                      wds : double seq, 
                                      [<Optional; DefaultParameterValue(0.0)>] momentum : float, 
                                      [<Optional; DefaultParameterValue(1.0)>] rescaleGrad : float, 
                                      [<Optional; DefaultParameterValue(-1.0)>] clipGradient : float, 
                                      [<Optional; DefaultParameterValue(1)>] numWeights : int) =
        let creator = AtomicSymbolCreator.FromName "multi_mp_sgd_mom_update"
        let names = [|"lrs"; "wds"; "momentum"; "rescale_grad"; "clip_gradient"; "num_weights"|]
        let vals = [|string lrs; string wds; string momentum; string rescaleGrad; string clipGradient; string numWeights|]
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     (data |> Array.map (fun x -> x.UnsafeHandle))
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <summary>Momentum update function for multi-precision Stochastic Gradient Descent (SGD) optimizer.
    /// 
    /// Momentum update has better convergence rates on neural networks. Mathematically it looks
    /// like below:
    /// 
    /// .. math::
    /// 
    ///   v_1 = \alpha * \nabla J(W_0)\\
    ///   v_t = \gamma v_{t-1} - \alpha * \nabla J(W_{t-1})\\
    ///   W_t = W_{t-1} + v_t
    /// 
    /// It updates the weights using::
    /// 
    ///   v = momentum * v - learning_rate * gradient
    ///   weight += v
    /// 
    /// Where the parameter ``momentum`` is the decay rate of momentum estimates at each epoch.
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\optimizer_op.cc:L472</summary>
    /// <param name="data">Weights</param>
    /// <param name="lrs">Learning rates.</param>
    /// <param name="wds">Weight decay augments the objective function with a regularization term that penalizes large weights. The penalty scales with the square of the magnitude of each weight.</param>
    /// <param name="momentum">The decay rate of momentum estimates at each epoch.</param>
    /// <param name="rescaleGrad">Rescale gradient to grad = rescale_grad*grad.</param>
    /// <param name="clipGradient">Clip gradient to the range of [-clip_gradient, clip_gradient] If clip_gradient &lt;= 0, gradient clipping is turned off. grad = max(min(grad, clip_gradient), -clip_gradient).</param>
    /// <param name="numWeights">Number of updated weights.</param>
    static member MultiMpSgdMomUpdate(data : Symbol seq, lrs : double seq, wds : double seq, [<Optional>] ?momentum : float, [<Optional>] ?rescaleGrad : float, [<Optional>] ?clipGradient : float, [<Optional>] ?numWeights : int) =
        MultiMpSgdMomUpdate(data, lrs, wds, ?momentum = momentum, ?rescaleGrad = rescaleGrad, ?clipGradient = clipGradient, ?numWeights = numWeights)
    /// <summary>Momentum update function for multi-precision Stochastic Gradient Descent (SGD) optimizer.
    /// 
    /// Momentum update has better convergence rates on neural networks. Mathematically it looks
    /// like below:
    /// 
    /// .. math::
    /// 
    ///   v_1 = \alpha * \nabla J(W_0)\\
    ///   v_t = \gamma v_{t-1} - \alpha * \nabla J(W_{t-1})\\
    ///   W_t = W_{t-1} + v_t
    /// 
    /// It updates the weights using::
    /// 
    ///   v = momentum * v - learning_rate * gradient
    ///   weight += v
    /// 
    /// Where the parameter ``momentum`` is the decay rate of momentum estimates at each epoch.
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\optimizer_op.cc:L472</summary>
    /// <param name="lrs">Learning rates.</param>
    /// <param name="wds">Weight decay augments the objective function with a regularization term that penalizes large weights. The penalty scales with the square of the magnitude of each weight.</param>
    /// <param name="data">Weights</param>
    /// <param name="momentum">The decay rate of momentum estimates at each epoch.</param>
    /// <param name="rescaleGrad">Rescale gradient to grad = rescale_grad*grad.</param>
    /// <param name="clipGradient">Clip gradient to the range of [-clip_gradient, clip_gradient] If clip_gradient &lt;= 0, gradient clipping is turned off. grad = max(min(grad, clip_gradient), -clip_gradient).</param>
    /// <param name="numWeights">Number of updated weights.</param>
    static member MultiMpSgdMomUpdate(lrs : double seq, wds : double seq, [<Optional>] ?data : Symbol seq, [<Optional>] ?momentum : float, [<Optional>] ?rescaleGrad : float, [<Optional>] ?clipGradient : float, [<Optional>] ?numWeights : int) =
        MultiMpSgdMomUpdate(lrs, wds, ?data = data, ?momentum = momentum, ?rescaleGrad = rescaleGrad, ?clipGradient = clipGradient, ?numWeights = numWeights)

    /// <summary>Update function for Stochastic Gradient Descent (SGD) optimizer.
    /// 
    /// It updates the weights using::
    /// 
    ///  weight = weight - learning_rate * (gradient + wd * weight)
    /// 
    /// However, if gradient is of ``row_sparse`` storage type and ``lazy_update`` is True,
    /// only the row slices whose indices appear in grad.indices are updated::
    /// 
    ///  for row in gradient.indices:
    ///      weight[row] = weight[row] - learning_rate * (gradient[row] + wd * weight[row])
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\optimizer_op.cc:L524</summary>
    /// <param name="weight">Weight</param>
    /// <param name="grad">Gradient</param>
    /// <param name="lr">Learning rate</param>
    /// <param name="wd">Weight decay augments the objective function with a regularization term that penalizes large weights. The penalty scales with the square of the magnitude of each weight.</param>
    /// <param name="rescaleGrad">Rescale gradient to grad = rescale_grad*grad.</param>
    /// <param name="clipGradient">Clip gradient to the range of [-clip_gradient, clip_gradient] If clip_gradient &lt;= 0, gradient clipping is turned off. grad = max(min(grad, clip_gradient), -clip_gradient).</param>
    /// <param name="lazyUpdate">If true, lazy updates are applied if gradient&#39;s stype is row_sparse.</param>
    static member SgdUpdate(weight : NDArray, 
                            grad : NDArray, 
                            lr : float, 
                            [<Optional; DefaultParameterValue(0.0)>] wd : float, 
                            [<Optional; DefaultParameterValue(1.0)>] rescaleGrad : float, 
                            [<Optional; DefaultParameterValue(-1.0)>] clipGradient : float, 
                            [<Optional; DefaultParameterValue(true)>] lazyUpdate : bool) =
        let creator = AtomicSymbolCreator.FromName "sgd_update"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg weight)) then weight.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg grad)) then grad.UnsafeHandle|]
                                                 [|"lr"; "wd"; "rescale_grad"; "clip_gradient"; "lazy_update"|]
                                                 [|string lr; string wd; string rescaleGrad; string clipGradient; string lazyUpdate|]
        (new NDArray(outputs.[0]))
    /// <summary>Update function for Stochastic Gradient Descent (SGD) optimizer.
    /// 
    /// It updates the weights using::
    /// 
    ///  weight = weight - learning_rate * (gradient + wd * weight)
    /// 
    /// However, if gradient is of ``row_sparse`` storage type and ``lazy_update`` is True,
    /// only the row slices whose indices appear in grad.indices are updated::
    /// 
    ///  for row in gradient.indices:
    ///      weight[row] = weight[row] - learning_rate * (gradient[row] + wd * weight[row])
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\optimizer_op.cc:L524</summary>
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="weight">Weight</param>
    /// <param name="grad">Gradient</param>
    /// <param name="lr">Learning rate</param>
    /// <param name="wd">Weight decay augments the objective function with a regularization term that penalizes large weights. The penalty scales with the square of the magnitude of each weight.</param>
    /// <param name="rescaleGrad">Rescale gradient to grad = rescale_grad*grad.</param>
    /// <param name="clipGradient">Clip gradient to the range of [-clip_gradient, clip_gradient] If clip_gradient &lt;= 0, gradient clipping is turned off. grad = max(min(grad, clip_gradient), -clip_gradient).</param>
    /// <param name="lazyUpdate">If true, lazy updates are applied if gradient&#39;s stype is row_sparse.</param>
    static member SgdUpdate(outputArray : NDArray seq, 
                            weight : NDArray, 
                            grad : NDArray, 
                            lr : float, 
                            [<Optional; DefaultParameterValue(0.0)>] wd : float, 
                            [<Optional; DefaultParameterValue(1.0)>] rescaleGrad : float, 
                            [<Optional; DefaultParameterValue(-1.0)>] clipGradient : float, 
                            [<Optional; DefaultParameterValue(true)>] lazyUpdate : bool) =
        let creator = AtomicSymbolCreator.FromName "sgd_update"
        let names = [|"lr"; "wd"; "rescale_grad"; "clip_gradient"; "lazy_update"|]
        let vals = [|string lr; string wd; string rescaleGrad; string clipGradient; string lazyUpdate|]
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg weight)) then weight.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg grad)) then grad.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <summary>Update function for Stochastic Gradient Descent (SGD) optimizer.
    /// 
    /// It updates the weights using::
    /// 
    ///  weight = weight - learning_rate * (gradient + wd * weight)
    /// 
    /// However, if gradient is of ``row_sparse`` storage type and ``lazy_update`` is True,
    /// only the row slices whose indices appear in grad.indices are updated::
    /// 
    ///  for row in gradient.indices:
    ///      weight[row] = weight[row] - learning_rate * (gradient[row] + wd * weight[row])
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\optimizer_op.cc:L524</summary>
    /// <param name="weight">Weight</param>
    /// <param name="grad">Gradient</param>
    /// <param name="lr">Learning rate</param>
    /// <param name="wd">Weight decay augments the objective function with a regularization term that penalizes large weights. The penalty scales with the square of the magnitude of each weight.</param>
    /// <param name="rescaleGrad">Rescale gradient to grad = rescale_grad*grad.</param>
    /// <param name="clipGradient">Clip gradient to the range of [-clip_gradient, clip_gradient] If clip_gradient &lt;= 0, gradient clipping is turned off. grad = max(min(grad, clip_gradient), -clip_gradient).</param>
    /// <param name="lazyUpdate">If true, lazy updates are applied if gradient&#39;s stype is row_sparse.</param>
    static member SgdUpdate(weight : Symbol, grad : Symbol, lr : float, [<Optional>] ?wd : float, [<Optional>] ?rescaleGrad : float, [<Optional>] ?clipGradient : float, [<Optional>] ?lazyUpdate : bool) =
        SgdUpdate(weight, grad, lr, ?wd = wd, ?rescaleGrad = rescaleGrad, ?clipGradient = clipGradient, ?lazyUpdate = lazyUpdate)
    /// <summary>Update function for Stochastic Gradient Descent (SGD) optimizer.
    /// 
    /// It updates the weights using::
    /// 
    ///  weight = weight - learning_rate * (gradient + wd * weight)
    /// 
    /// However, if gradient is of ``row_sparse`` storage type and ``lazy_update`` is True,
    /// only the row slices whose indices appear in grad.indices are updated::
    /// 
    ///  for row in gradient.indices:
    ///      weight[row] = weight[row] - learning_rate * (gradient[row] + wd * weight[row])
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\optimizer_op.cc:L524</summary>
    /// <param name="lr">Learning rate</param>
    /// <param name="weight">Weight</param>
    /// <param name="grad">Gradient</param>
    /// <param name="wd">Weight decay augments the objective function with a regularization term that penalizes large weights. The penalty scales with the square of the magnitude of each weight.</param>
    /// <param name="rescaleGrad">Rescale gradient to grad = rescale_grad*grad.</param>
    /// <param name="clipGradient">Clip gradient to the range of [-clip_gradient, clip_gradient] If clip_gradient &lt;= 0, gradient clipping is turned off. grad = max(min(grad, clip_gradient), -clip_gradient).</param>
    /// <param name="lazyUpdate">If true, lazy updates are applied if gradient&#39;s stype is row_sparse.</param>
    static member SgdUpdate(lr : float, [<Optional>] ?weight : Symbol, [<Optional>] ?grad : Symbol, [<Optional>] ?wd : float, [<Optional>] ?rescaleGrad : float, [<Optional>] ?clipGradient : float, [<Optional>] ?lazyUpdate : bool) =
        SgdUpdate(lr, ?weight = weight, ?grad = grad, ?wd = wd, ?rescaleGrad = rescaleGrad, ?clipGradient = clipGradient, ?lazyUpdate = lazyUpdate)

    /// <summary>Momentum update function for Stochastic Gradient Descent (SGD) optimizer.
    /// 
    /// Momentum update has better convergence rates on neural networks. Mathematically it looks
    /// like below:
    /// 
    /// .. math::
    /// 
    ///   v_1 = \alpha * \nabla J(W_0)\\
    ///   v_t = \gamma v_{t-1} - \alpha * \nabla J(W_{t-1})\\
    ///   W_t = W_{t-1} + v_t
    /// 
    /// It updates the weights using::
    /// 
    ///   v = momentum * v - learning_rate * gradient
    ///   weight += v
    /// 
    /// Where the parameter ``momentum`` is the decay rate of momentum estimates at each epoch.
    /// 
    /// However, if grad&#39;s storage type is ``row_sparse``, ``lazy_update`` is True and weight&#39;s storage
    /// type is the same as momentum&#39;s storage type,
    /// only the row slices whose indices appear in grad.indices are updated (for both weight and momentum)::
    /// 
    ///   for row in gradient.indices:
    ///       v[row] = momentum[row] * v[row] - learning_rate * gradient[row]
    ///       weight[row] += v[row]
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\optimizer_op.cc:L565</summary>
    /// <param name="weight">Weight</param>
    /// <param name="grad">Gradient</param>
    /// <param name="mom">Momentum</param>
    /// <param name="lr">Learning rate</param>
    /// <param name="momentum">The decay rate of momentum estimates at each epoch.</param>
    /// <param name="wd">Weight decay augments the objective function with a regularization term that penalizes large weights. The penalty scales with the square of the magnitude of each weight.</param>
    /// <param name="rescaleGrad">Rescale gradient to grad = rescale_grad*grad.</param>
    /// <param name="clipGradient">Clip gradient to the range of [-clip_gradient, clip_gradient] If clip_gradient &lt;= 0, gradient clipping is turned off. grad = max(min(grad, clip_gradient), -clip_gradient).</param>
    /// <param name="lazyUpdate">If true, lazy updates are applied if gradient&#39;s stype is row_sparse and both weight and momentum have the same stype</param>
    static member SgdMomUpdate(weight : NDArray, 
                               grad : NDArray, 
                               mom : NDArray, 
                               lr : float, 
                               [<Optional; DefaultParameterValue(0.0)>] momentum : float, 
                               [<Optional; DefaultParameterValue(0.0)>] wd : float, 
                               [<Optional; DefaultParameterValue(1.0)>] rescaleGrad : float, 
                               [<Optional; DefaultParameterValue(-1.0)>] clipGradient : float, 
                               [<Optional; DefaultParameterValue(true)>] lazyUpdate : bool) =
        let creator = AtomicSymbolCreator.FromName "sgd_mom_update"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg weight)) then weight.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg grad)) then grad.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg mom)) then mom.UnsafeHandle|]
                                                 [|"lr"; "momentum"; "wd"; "rescale_grad"; "clip_gradient"; "lazy_update"|]
                                                 [|string lr; string momentum; string wd; string rescaleGrad; string clipGradient; string lazyUpdate|]
        (new NDArray(outputs.[0]))
    /// <summary>Momentum update function for Stochastic Gradient Descent (SGD) optimizer.
    /// 
    /// Momentum update has better convergence rates on neural networks. Mathematically it looks
    /// like below:
    /// 
    /// .. math::
    /// 
    ///   v_1 = \alpha * \nabla J(W_0)\\
    ///   v_t = \gamma v_{t-1} - \alpha * \nabla J(W_{t-1})\\
    ///   W_t = W_{t-1} + v_t
    /// 
    /// It updates the weights using::
    /// 
    ///   v = momentum * v - learning_rate * gradient
    ///   weight += v
    /// 
    /// Where the parameter ``momentum`` is the decay rate of momentum estimates at each epoch.
    /// 
    /// However, if grad&#39;s storage type is ``row_sparse``, ``lazy_update`` is True and weight&#39;s storage
    /// type is the same as momentum&#39;s storage type,
    /// only the row slices whose indices appear in grad.indices are updated (for both weight and momentum)::
    /// 
    ///   for row in gradient.indices:
    ///       v[row] = momentum[row] * v[row] - learning_rate * gradient[row]
    ///       weight[row] += v[row]
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\optimizer_op.cc:L565</summary>
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="weight">Weight</param>
    /// <param name="grad">Gradient</param>
    /// <param name="mom">Momentum</param>
    /// <param name="lr">Learning rate</param>
    /// <param name="momentum">The decay rate of momentum estimates at each epoch.</param>
    /// <param name="wd">Weight decay augments the objective function with a regularization term that penalizes large weights. The penalty scales with the square of the magnitude of each weight.</param>
    /// <param name="rescaleGrad">Rescale gradient to grad = rescale_grad*grad.</param>
    /// <param name="clipGradient">Clip gradient to the range of [-clip_gradient, clip_gradient] If clip_gradient &lt;= 0, gradient clipping is turned off. grad = max(min(grad, clip_gradient), -clip_gradient).</param>
    /// <param name="lazyUpdate">If true, lazy updates are applied if gradient&#39;s stype is row_sparse and both weight and momentum have the same stype</param>
    static member SgdMomUpdate(outputArray : NDArray seq, 
                               weight : NDArray, 
                               grad : NDArray, 
                               mom : NDArray, 
                               lr : float, 
                               [<Optional; DefaultParameterValue(0.0)>] momentum : float, 
                               [<Optional; DefaultParameterValue(0.0)>] wd : float, 
                               [<Optional; DefaultParameterValue(1.0)>] rescaleGrad : float, 
                               [<Optional; DefaultParameterValue(-1.0)>] clipGradient : float, 
                               [<Optional; DefaultParameterValue(true)>] lazyUpdate : bool) =
        let creator = AtomicSymbolCreator.FromName "sgd_mom_update"
        let names = [|"lr"; "momentum"; "wd"; "rescale_grad"; "clip_gradient"; "lazy_update"|]
        let vals = [|string lr; string momentum; string wd; string rescaleGrad; string clipGradient; string lazyUpdate|]
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg weight)) then weight.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg grad)) then grad.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg mom)) then mom.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <summary>Momentum update function for Stochastic Gradient Descent (SGD) optimizer.
    /// 
    /// Momentum update has better convergence rates on neural networks. Mathematically it looks
    /// like below:
    /// 
    /// .. math::
    /// 
    ///   v_1 = \alpha * \nabla J(W_0)\\
    ///   v_t = \gamma v_{t-1} - \alpha * \nabla J(W_{t-1})\\
    ///   W_t = W_{t-1} + v_t
    /// 
    /// It updates the weights using::
    /// 
    ///   v = momentum * v - learning_rate * gradient
    ///   weight += v
    /// 
    /// Where the parameter ``momentum`` is the decay rate of momentum estimates at each epoch.
    /// 
    /// However, if grad&#39;s storage type is ``row_sparse``, ``lazy_update`` is True and weight&#39;s storage
    /// type is the same as momentum&#39;s storage type,
    /// only the row slices whose indices appear in grad.indices are updated (for both weight and momentum)::
    /// 
    ///   for row in gradient.indices:
    ///       v[row] = momentum[row] * v[row] - learning_rate * gradient[row]
    ///       weight[row] += v[row]
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\optimizer_op.cc:L565</summary>
    /// <param name="weight">Weight</param>
    /// <param name="grad">Gradient</param>
    /// <param name="mom">Momentum</param>
    /// <param name="lr">Learning rate</param>
    /// <param name="momentum">The decay rate of momentum estimates at each epoch.</param>
    /// <param name="wd">Weight decay augments the objective function with a regularization term that penalizes large weights. The penalty scales with the square of the magnitude of each weight.</param>
    /// <param name="rescaleGrad">Rescale gradient to grad = rescale_grad*grad.</param>
    /// <param name="clipGradient">Clip gradient to the range of [-clip_gradient, clip_gradient] If clip_gradient &lt;= 0, gradient clipping is turned off. grad = max(min(grad, clip_gradient), -clip_gradient).</param>
    /// <param name="lazyUpdate">If true, lazy updates are applied if gradient&#39;s stype is row_sparse and both weight and momentum have the same stype</param>
    static member SgdMomUpdate(weight : Symbol, grad : Symbol, mom : Symbol, lr : float, [<Optional>] ?momentum : float, [<Optional>] ?wd : float, [<Optional>] ?rescaleGrad : float, [<Optional>] ?clipGradient : float, [<Optional>] ?lazyUpdate : bool) =
        SgdMomUpdate(weight, grad, mom, lr, ?momentum = momentum, ?wd = wd, ?rescaleGrad = rescaleGrad, ?clipGradient = clipGradient, ?lazyUpdate = lazyUpdate)
    /// <summary>Momentum update function for Stochastic Gradient Descent (SGD) optimizer.
    /// 
    /// Momentum update has better convergence rates on neural networks. Mathematically it looks
    /// like below:
    /// 
    /// .. math::
    /// 
    ///   v_1 = \alpha * \nabla J(W_0)\\
    ///   v_t = \gamma v_{t-1} - \alpha * \nabla J(W_{t-1})\\
    ///   W_t = W_{t-1} + v_t
    /// 
    /// It updates the weights using::
    /// 
    ///   v = momentum * v - learning_rate * gradient
    ///   weight += v
    /// 
    /// Where the parameter ``momentum`` is the decay rate of momentum estimates at each epoch.
    /// 
    /// However, if grad&#39;s storage type is ``row_sparse``, ``lazy_update`` is True and weight&#39;s storage
    /// type is the same as momentum&#39;s storage type,
    /// only the row slices whose indices appear in grad.indices are updated (for both weight and momentum)::
    /// 
    ///   for row in gradient.indices:
    ///       v[row] = momentum[row] * v[row] - learning_rate * gradient[row]
    ///       weight[row] += v[row]
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\optimizer_op.cc:L565</summary>
    /// <param name="lr">Learning rate</param>
    /// <param name="weight">Weight</param>
    /// <param name="grad">Gradient</param>
    /// <param name="mom">Momentum</param>
    /// <param name="momentum">The decay rate of momentum estimates at each epoch.</param>
    /// <param name="wd">Weight decay augments the objective function with a regularization term that penalizes large weights. The penalty scales with the square of the magnitude of each weight.</param>
    /// <param name="rescaleGrad">Rescale gradient to grad = rescale_grad*grad.</param>
    /// <param name="clipGradient">Clip gradient to the range of [-clip_gradient, clip_gradient] If clip_gradient &lt;= 0, gradient clipping is turned off. grad = max(min(grad, clip_gradient), -clip_gradient).</param>
    /// <param name="lazyUpdate">If true, lazy updates are applied if gradient&#39;s stype is row_sparse and both weight and momentum have the same stype</param>
    static member SgdMomUpdate(lr : float, [<Optional>] ?weight : Symbol, [<Optional>] ?grad : Symbol, [<Optional>] ?mom : Symbol, [<Optional>] ?momentum : float, [<Optional>] ?wd : float, [<Optional>] ?rescaleGrad : float, [<Optional>] ?clipGradient : float, [<Optional>] ?lazyUpdate : bool) =
        SgdMomUpdate(lr, ?weight = weight, ?grad = grad, ?mom = mom, ?momentum = momentum, ?wd = wd, ?rescaleGrad = rescaleGrad, ?clipGradient = clipGradient, ?lazyUpdate = lazyUpdate)

    /// <summary>Updater function for multi-precision sgd optimizer</summary>
    /// <param name="weight">Weight</param>
    /// <param name="grad">gradient</param>
    /// <param name="weight32">Weight32</param>
    /// <param name="lr">Learning rate</param>
    /// <param name="wd">Weight decay augments the objective function with a regularization term that penalizes large weights. The penalty scales with the square of the magnitude of each weight.</param>
    /// <param name="rescaleGrad">Rescale gradient to grad = rescale_grad*grad.</param>
    /// <param name="clipGradient">Clip gradient to the range of [-clip_gradient, clip_gradient] If clip_gradient &lt;= 0, gradient clipping is turned off. grad = max(min(grad, clip_gradient), -clip_gradient).</param>
    /// <param name="lazyUpdate">If true, lazy updates are applied if gradient&#39;s stype is row_sparse.</param>
    static member MpSgdUpdate(weight : NDArray, 
                              grad : NDArray, 
                              weight32 : NDArray, 
                              lr : float, 
                              [<Optional; DefaultParameterValue(0.0)>] wd : float, 
                              [<Optional; DefaultParameterValue(1.0)>] rescaleGrad : float, 
                              [<Optional; DefaultParameterValue(-1.0)>] clipGradient : float, 
                              [<Optional; DefaultParameterValue(true)>] lazyUpdate : bool) =
        let creator = AtomicSymbolCreator.FromName "mp_sgd_update"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg weight)) then weight.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg grad)) then grad.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg weight32)) then weight32.UnsafeHandle|]
                                                 [|"lr"; "wd"; "rescale_grad"; "clip_gradient"; "lazy_update"|]
                                                 [|string lr; string wd; string rescaleGrad; string clipGradient; string lazyUpdate|]
        (new NDArray(outputs.[0]))
    /// <summary>Updater function for multi-precision sgd optimizer</summary>
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="weight">Weight</param>
    /// <param name="grad">gradient</param>
    /// <param name="weight32">Weight32</param>
    /// <param name="lr">Learning rate</param>
    /// <param name="wd">Weight decay augments the objective function with a regularization term that penalizes large weights. The penalty scales with the square of the magnitude of each weight.</param>
    /// <param name="rescaleGrad">Rescale gradient to grad = rescale_grad*grad.</param>
    /// <param name="clipGradient">Clip gradient to the range of [-clip_gradient, clip_gradient] If clip_gradient &lt;= 0, gradient clipping is turned off. grad = max(min(grad, clip_gradient), -clip_gradient).</param>
    /// <param name="lazyUpdate">If true, lazy updates are applied if gradient&#39;s stype is row_sparse.</param>
    static member MpSgdUpdate(outputArray : NDArray seq, 
                              weight : NDArray, 
                              grad : NDArray, 
                              weight32 : NDArray, 
                              lr : float, 
                              [<Optional; DefaultParameterValue(0.0)>] wd : float, 
                              [<Optional; DefaultParameterValue(1.0)>] rescaleGrad : float, 
                              [<Optional; DefaultParameterValue(-1.0)>] clipGradient : float, 
                              [<Optional; DefaultParameterValue(true)>] lazyUpdate : bool) =
        let creator = AtomicSymbolCreator.FromName "mp_sgd_update"
        let names = [|"lr"; "wd"; "rescale_grad"; "clip_gradient"; "lazy_update"|]
        let vals = [|string lr; string wd; string rescaleGrad; string clipGradient; string lazyUpdate|]
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg weight)) then weight.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg grad)) then grad.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg weight32)) then weight32.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <summary>Updater function for multi-precision sgd optimizer</summary>
    /// <param name="weight">Weight</param>
    /// <param name="grad">gradient</param>
    /// <param name="weight32">Weight32</param>
    /// <param name="lr">Learning rate</param>
    /// <param name="wd">Weight decay augments the objective function with a regularization term that penalizes large weights. The penalty scales with the square of the magnitude of each weight.</param>
    /// <param name="rescaleGrad">Rescale gradient to grad = rescale_grad*grad.</param>
    /// <param name="clipGradient">Clip gradient to the range of [-clip_gradient, clip_gradient] If clip_gradient &lt;= 0, gradient clipping is turned off. grad = max(min(grad, clip_gradient), -clip_gradient).</param>
    /// <param name="lazyUpdate">If true, lazy updates are applied if gradient&#39;s stype is row_sparse.</param>
    static member MpSgdUpdate(weight : Symbol, grad : Symbol, weight32 : Symbol, lr : float, [<Optional>] ?wd : float, [<Optional>] ?rescaleGrad : float, [<Optional>] ?clipGradient : float, [<Optional>] ?lazyUpdate : bool) =
        MpSgdUpdate(weight, grad, weight32, lr, ?wd = wd, ?rescaleGrad = rescaleGrad, ?clipGradient = clipGradient, ?lazyUpdate = lazyUpdate)
    /// <summary>Updater function for multi-precision sgd optimizer</summary>
    /// <param name="lr">Learning rate</param>
    /// <param name="weight">Weight</param>
    /// <param name="grad">gradient</param>
    /// <param name="weight32">Weight32</param>
    /// <param name="wd">Weight decay augments the objective function with a regularization term that penalizes large weights. The penalty scales with the square of the magnitude of each weight.</param>
    /// <param name="rescaleGrad">Rescale gradient to grad = rescale_grad*grad.</param>
    /// <param name="clipGradient">Clip gradient to the range of [-clip_gradient, clip_gradient] If clip_gradient &lt;= 0, gradient clipping is turned off. grad = max(min(grad, clip_gradient), -clip_gradient).</param>
    /// <param name="lazyUpdate">If true, lazy updates are applied if gradient&#39;s stype is row_sparse.</param>
    static member MpSgdUpdate(lr : float, [<Optional>] ?weight : Symbol, [<Optional>] ?grad : Symbol, [<Optional>] ?weight32 : Symbol, [<Optional>] ?wd : float, [<Optional>] ?rescaleGrad : float, [<Optional>] ?clipGradient : float, [<Optional>] ?lazyUpdate : bool) =
        MpSgdUpdate(lr, ?weight = weight, ?grad = grad, ?weight32 = weight32, ?wd = wd, ?rescaleGrad = rescaleGrad, ?clipGradient = clipGradient, ?lazyUpdate = lazyUpdate)

    /// <summary>Updater function for multi-precision sgd optimizer</summary>
    /// <param name="weight">Weight</param>
    /// <param name="grad">Gradient</param>
    /// <param name="mom">Momentum</param>
    /// <param name="weight32">Weight32</param>
    /// <param name="lr">Learning rate</param>
    /// <param name="momentum">The decay rate of momentum estimates at each epoch.</param>
    /// <param name="wd">Weight decay augments the objective function with a regularization term that penalizes large weights. The penalty scales with the square of the magnitude of each weight.</param>
    /// <param name="rescaleGrad">Rescale gradient to grad = rescale_grad*grad.</param>
    /// <param name="clipGradient">Clip gradient to the range of [-clip_gradient, clip_gradient] If clip_gradient &lt;= 0, gradient clipping is turned off. grad = max(min(grad, clip_gradient), -clip_gradient).</param>
    /// <param name="lazyUpdate">If true, lazy updates are applied if gradient&#39;s stype is row_sparse and both weight and momentum have the same stype</param>
    static member MpSgdMomUpdate(weight : NDArray, 
                                 grad : NDArray, 
                                 mom : NDArray, 
                                 weight32 : NDArray, 
                                 lr : float, 
                                 [<Optional; DefaultParameterValue(0.0)>] momentum : float, 
                                 [<Optional; DefaultParameterValue(0.0)>] wd : float, 
                                 [<Optional; DefaultParameterValue(1.0)>] rescaleGrad : float, 
                                 [<Optional; DefaultParameterValue(-1.0)>] clipGradient : float, 
                                 [<Optional; DefaultParameterValue(true)>] lazyUpdate : bool) =
        let creator = AtomicSymbolCreator.FromName "mp_sgd_mom_update"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg weight)) then weight.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg grad)) then grad.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg mom)) then mom.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg weight32)) then weight32.UnsafeHandle|]
                                                 [|"lr"; "momentum"; "wd"; "rescale_grad"; "clip_gradient"; "lazy_update"|]
                                                 [|string lr; string momentum; string wd; string rescaleGrad; string clipGradient; string lazyUpdate|]
        (new NDArray(outputs.[0]))
    /// <summary>Updater function for multi-precision sgd optimizer</summary>
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="weight">Weight</param>
    /// <param name="grad">Gradient</param>
    /// <param name="mom">Momentum</param>
    /// <param name="weight32">Weight32</param>
    /// <param name="lr">Learning rate</param>
    /// <param name="momentum">The decay rate of momentum estimates at each epoch.</param>
    /// <param name="wd">Weight decay augments the objective function with a regularization term that penalizes large weights. The penalty scales with the square of the magnitude of each weight.</param>
    /// <param name="rescaleGrad">Rescale gradient to grad = rescale_grad*grad.</param>
    /// <param name="clipGradient">Clip gradient to the range of [-clip_gradient, clip_gradient] If clip_gradient &lt;= 0, gradient clipping is turned off. grad = max(min(grad, clip_gradient), -clip_gradient).</param>
    /// <param name="lazyUpdate">If true, lazy updates are applied if gradient&#39;s stype is row_sparse and both weight and momentum have the same stype</param>
    static member MpSgdMomUpdate(outputArray : NDArray seq, 
                                 weight : NDArray, 
                                 grad : NDArray, 
                                 mom : NDArray, 
                                 weight32 : NDArray, 
                                 lr : float, 
                                 [<Optional; DefaultParameterValue(0.0)>] momentum : float, 
                                 [<Optional; DefaultParameterValue(0.0)>] wd : float, 
                                 [<Optional; DefaultParameterValue(1.0)>] rescaleGrad : float, 
                                 [<Optional; DefaultParameterValue(-1.0)>] clipGradient : float, 
                                 [<Optional; DefaultParameterValue(true)>] lazyUpdate : bool) =
        let creator = AtomicSymbolCreator.FromName "mp_sgd_mom_update"
        let names = [|"lr"; "momentum"; "wd"; "rescale_grad"; "clip_gradient"; "lazy_update"|]
        let vals = [|string lr; string momentum; string wd; string rescaleGrad; string clipGradient; string lazyUpdate|]
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg weight)) then weight.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg grad)) then grad.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg mom)) then mom.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg weight32)) then weight32.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <summary>Updater function for multi-precision sgd optimizer</summary>
    /// <param name="weight">Weight</param>
    /// <param name="grad">Gradient</param>
    /// <param name="mom">Momentum</param>
    /// <param name="weight32">Weight32</param>
    /// <param name="lr">Learning rate</param>
    /// <param name="momentum">The decay rate of momentum estimates at each epoch.</param>
    /// <param name="wd">Weight decay augments the objective function with a regularization term that penalizes large weights. The penalty scales with the square of the magnitude of each weight.</param>
    /// <param name="rescaleGrad">Rescale gradient to grad = rescale_grad*grad.</param>
    /// <param name="clipGradient">Clip gradient to the range of [-clip_gradient, clip_gradient] If clip_gradient &lt;= 0, gradient clipping is turned off. grad = max(min(grad, clip_gradient), -clip_gradient).</param>
    /// <param name="lazyUpdate">If true, lazy updates are applied if gradient&#39;s stype is row_sparse and both weight and momentum have the same stype</param>
    static member MpSgdMomUpdate(weight : Symbol, grad : Symbol, mom : Symbol, weight32 : Symbol, lr : float, [<Optional>] ?momentum : float, [<Optional>] ?wd : float, [<Optional>] ?rescaleGrad : float, [<Optional>] ?clipGradient : float, [<Optional>] ?lazyUpdate : bool) =
        MpSgdMomUpdate(weight, grad, mom, weight32, lr, ?momentum = momentum, ?wd = wd, ?rescaleGrad = rescaleGrad, ?clipGradient = clipGradient, ?lazyUpdate = lazyUpdate)
    /// <summary>Updater function for multi-precision sgd optimizer</summary>
    /// <param name="lr">Learning rate</param>
    /// <param name="weight">Weight</param>
    /// <param name="grad">Gradient</param>
    /// <param name="mom">Momentum</param>
    /// <param name="weight32">Weight32</param>
    /// <param name="momentum">The decay rate of momentum estimates at each epoch.</param>
    /// <param name="wd">Weight decay augments the objective function with a regularization term that penalizes large weights. The penalty scales with the square of the magnitude of each weight.</param>
    /// <param name="rescaleGrad">Rescale gradient to grad = rescale_grad*grad.</param>
    /// <param name="clipGradient">Clip gradient to the range of [-clip_gradient, clip_gradient] If clip_gradient &lt;= 0, gradient clipping is turned off. grad = max(min(grad, clip_gradient), -clip_gradient).</param>
    /// <param name="lazyUpdate">If true, lazy updates are applied if gradient&#39;s stype is row_sparse and both weight and momentum have the same stype</param>
    static member MpSgdMomUpdate(lr : float, [<Optional>] ?weight : Symbol, [<Optional>] ?grad : Symbol, [<Optional>] ?mom : Symbol, [<Optional>] ?weight32 : Symbol, [<Optional>] ?momentum : float, [<Optional>] ?wd : float, [<Optional>] ?rescaleGrad : float, [<Optional>] ?clipGradient : float, [<Optional>] ?lazyUpdate : bool) =
        MpSgdMomUpdate(lr, ?weight = weight, ?grad = grad, ?mom = mom, ?weight32 = weight32, ?momentum = momentum, ?wd = wd, ?rescaleGrad = rescaleGrad, ?clipGradient = clipGradient, ?lazyUpdate = lazyUpdate)

    /// <summary>The FTML optimizer described in
    /// *FTML - Follow the Moving Leader in Deep Learning*,
    /// available at http://proceedings.mlr.press/v70/zheng17a/zheng17a.pdf.
    /// 
    /// .. math::
    /// 
    ///  g_t = \nabla J(W_{t-1})\\
    ///  v_t = \beta_2 v_{t-1} + (1 - \beta_2) g_t^2\\
    ///  d_t = \frac{ 1 - \beta_1^t }{ \eta_t } (\sqrt{ \frac{ v_t }{ 1 - \beta_2^t } } + \epsilon)
    ///  \sigma_t = d_t - \beta_1 d_{t-1}
    ///  z_t = \beta_1 z_{ t-1 } + (1 - \beta_1^t) g_t - \sigma_t W_{t-1}
    ///  W_t = - \frac{ z_t }{ d_t }
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\optimizer_op.cc:L640</summary>
    /// <param name="weight">Weight</param>
    /// <param name="grad">Gradient</param>
    /// <param name="d">Internal state ``d_t``</param>
    /// <param name="v">Internal state ``v_t``</param>
    /// <param name="z">Internal state ``z_t``</param>
    /// <param name="lr">Learning rate.</param>
    /// <param name="t">Number of update.</param>
    /// <param name="beta1">Generally close to 0.5.</param>
    /// <param name="beta2">Generally close to 1.</param>
    /// <param name="epsilon">Epsilon to prevent div 0.</param>
    /// <param name="wd">Weight decay augments the objective function with a regularization term that penalizes large weights. The penalty scales with the square of the magnitude of each weight.</param>
    /// <param name="rescaleGrad">Rescale gradient to grad = rescale_grad*grad.</param>
    /// <param name="clipGrad">Clip gradient to the range of [-clip_gradient, clip_gradient] If clip_gradient &lt;= 0, gradient clipping is turned off. grad = max(min(grad, clip_gradient), -clip_gradient).</param>
    static member FtmlUpdate(weight : NDArray, 
                             grad : NDArray, 
                             d : NDArray, 
                             v : NDArray, 
                             z : NDArray, 
                             lr : float, 
                             t : int, 
                             [<Optional; DefaultParameterValue(0.600000024)>] beta1 : float, 
                             [<Optional; DefaultParameterValue(0.999000013)>] beta2 : float, 
                             [<Optional; DefaultParameterValue(9.99999993922529E-09)>] epsilon : double, 
                             [<Optional; DefaultParameterValue(0.0)>] wd : float, 
                             [<Optional; DefaultParameterValue(1.0)>] rescaleGrad : float, 
                             [<Optional; DefaultParameterValue(-1.0)>] clipGrad : float) =
        let creator = AtomicSymbolCreator.FromName "ftml_update"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg weight)) then weight.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg grad)) then grad.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg d)) then d.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg v)) then v.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg z)) then z.UnsafeHandle|]
                                                 [|"lr"; "t"; "beta1"; "beta2"; "epsilon"; "wd"; "rescale_grad"; "clip_grad"|]
                                                 [|string lr; string t; string beta1; string beta2; string epsilon; string wd; string rescaleGrad; string clipGrad|]
        (new NDArray(outputs.[0]))
    /// <summary>The FTML optimizer described in
    /// *FTML - Follow the Moving Leader in Deep Learning*,
    /// available at http://proceedings.mlr.press/v70/zheng17a/zheng17a.pdf.
    /// 
    /// .. math::
    /// 
    ///  g_t = \nabla J(W_{t-1})\\
    ///  v_t = \beta_2 v_{t-1} + (1 - \beta_2) g_t^2\\
    ///  d_t = \frac{ 1 - \beta_1^t }{ \eta_t } (\sqrt{ \frac{ v_t }{ 1 - \beta_2^t } } + \epsilon)
    ///  \sigma_t = d_t - \beta_1 d_{t-1}
    ///  z_t = \beta_1 z_{ t-1 } + (1 - \beta_1^t) g_t - \sigma_t W_{t-1}
    ///  W_t = - \frac{ z_t }{ d_t }
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\optimizer_op.cc:L640</summary>
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="weight">Weight</param>
    /// <param name="grad">Gradient</param>
    /// <param name="d">Internal state ``d_t``</param>
    /// <param name="v">Internal state ``v_t``</param>
    /// <param name="z">Internal state ``z_t``</param>
    /// <param name="lr">Learning rate.</param>
    /// <param name="t">Number of update.</param>
    /// <param name="beta1">Generally close to 0.5.</param>
    /// <param name="beta2">Generally close to 1.</param>
    /// <param name="epsilon">Epsilon to prevent div 0.</param>
    /// <param name="wd">Weight decay augments the objective function with a regularization term that penalizes large weights. The penalty scales with the square of the magnitude of each weight.</param>
    /// <param name="rescaleGrad">Rescale gradient to grad = rescale_grad*grad.</param>
    /// <param name="clipGrad">Clip gradient to the range of [-clip_gradient, clip_gradient] If clip_gradient &lt;= 0, gradient clipping is turned off. grad = max(min(grad, clip_gradient), -clip_gradient).</param>
    static member FtmlUpdate(outputArray : NDArray seq, 
                             weight : NDArray, 
                             grad : NDArray, 
                             d : NDArray, 
                             v : NDArray, 
                             z : NDArray, 
                             lr : float, 
                             t : int, 
                             [<Optional; DefaultParameterValue(0.600000024)>] beta1 : float, 
                             [<Optional; DefaultParameterValue(0.999000013)>] beta2 : float, 
                             [<Optional; DefaultParameterValue(9.99999993922529E-09)>] epsilon : double, 
                             [<Optional; DefaultParameterValue(0.0)>] wd : float, 
                             [<Optional; DefaultParameterValue(1.0)>] rescaleGrad : float, 
                             [<Optional; DefaultParameterValue(-1.0)>] clipGrad : float) =
        let creator = AtomicSymbolCreator.FromName "ftml_update"
        let names = [|"lr"; "t"; "beta1"; "beta2"; "epsilon"; "wd"; "rescale_grad"; "clip_grad"|]
        let vals = [|string lr; string t; string beta1; string beta2; string epsilon; string wd; string rescaleGrad; string clipGrad|]
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg weight)) then weight.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg grad)) then grad.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg d)) then d.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg v)) then v.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg z)) then z.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <summary>The FTML optimizer described in
    /// *FTML - Follow the Moving Leader in Deep Learning*,
    /// available at http://proceedings.mlr.press/v70/zheng17a/zheng17a.pdf.
    /// 
    /// .. math::
    /// 
    ///  g_t = \nabla J(W_{t-1})\\
    ///  v_t = \beta_2 v_{t-1} + (1 - \beta_2) g_t^2\\
    ///  d_t = \frac{ 1 - \beta_1^t }{ \eta_t } (\sqrt{ \frac{ v_t }{ 1 - \beta_2^t } } + \epsilon)
    ///  \sigma_t = d_t - \beta_1 d_{t-1}
    ///  z_t = \beta_1 z_{ t-1 } + (1 - \beta_1^t) g_t - \sigma_t W_{t-1}
    ///  W_t = - \frac{ z_t }{ d_t }
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\optimizer_op.cc:L640</summary>
    /// <param name="weight">Weight</param>
    /// <param name="grad">Gradient</param>
    /// <param name="d">Internal state ``d_t``</param>
    /// <param name="v">Internal state ``v_t``</param>
    /// <param name="z">Internal state ``z_t``</param>
    /// <param name="lr">Learning rate.</param>
    /// <param name="t">Number of update.</param>
    /// <param name="beta1">Generally close to 0.5.</param>
    /// <param name="beta2">Generally close to 1.</param>
    /// <param name="epsilon">Epsilon to prevent div 0.</param>
    /// <param name="wd">Weight decay augments the objective function with a regularization term that penalizes large weights. The penalty scales with the square of the magnitude of each weight.</param>
    /// <param name="rescaleGrad">Rescale gradient to grad = rescale_grad*grad.</param>
    /// <param name="clipGrad">Clip gradient to the range of [-clip_gradient, clip_gradient] If clip_gradient &lt;= 0, gradient clipping is turned off. grad = max(min(grad, clip_gradient), -clip_gradient).</param>
    static member FtmlUpdate(weight : Symbol, grad : Symbol, d : Symbol, v : Symbol, z : Symbol, lr : float, t : int, [<Optional>] ?beta1 : float, [<Optional>] ?beta2 : float, [<Optional>] ?epsilon : double, [<Optional>] ?wd : float, [<Optional>] ?rescaleGrad : float, [<Optional>] ?clipGrad : float) =
        FtmlUpdate(weight, grad, d, v, z, lr, t, ?beta1 = beta1, ?beta2 = beta2, ?epsilon = epsilon, ?wd = wd, ?rescaleGrad = rescaleGrad, ?clipGrad = clipGrad)
    /// <summary>The FTML optimizer described in
    /// *FTML - Follow the Moving Leader in Deep Learning*,
    /// available at http://proceedings.mlr.press/v70/zheng17a/zheng17a.pdf.
    /// 
    /// .. math::
    /// 
    ///  g_t = \nabla J(W_{t-1})\\
    ///  v_t = \beta_2 v_{t-1} + (1 - \beta_2) g_t^2\\
    ///  d_t = \frac{ 1 - \beta_1^t }{ \eta_t } (\sqrt{ \frac{ v_t }{ 1 - \beta_2^t } } + \epsilon)
    ///  \sigma_t = d_t - \beta_1 d_{t-1}
    ///  z_t = \beta_1 z_{ t-1 } + (1 - \beta_1^t) g_t - \sigma_t W_{t-1}
    ///  W_t = - \frac{ z_t }{ d_t }
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\optimizer_op.cc:L640</summary>
    /// <param name="lr">Learning rate.</param>
    /// <param name="t">Number of update.</param>
    /// <param name="weight">Weight</param>
    /// <param name="grad">Gradient</param>
    /// <param name="d">Internal state ``d_t``</param>
    /// <param name="v">Internal state ``v_t``</param>
    /// <param name="z">Internal state ``z_t``</param>
    /// <param name="beta1">Generally close to 0.5.</param>
    /// <param name="beta2">Generally close to 1.</param>
    /// <param name="epsilon">Epsilon to prevent div 0.</param>
    /// <param name="wd">Weight decay augments the objective function with a regularization term that penalizes large weights. The penalty scales with the square of the magnitude of each weight.</param>
    /// <param name="rescaleGrad">Rescale gradient to grad = rescale_grad*grad.</param>
    /// <param name="clipGrad">Clip gradient to the range of [-clip_gradient, clip_gradient] If clip_gradient &lt;= 0, gradient clipping is turned off. grad = max(min(grad, clip_gradient), -clip_gradient).</param>
    static member FtmlUpdate(lr : float, t : int, [<Optional>] ?weight : Symbol, [<Optional>] ?grad : Symbol, [<Optional>] ?d : Symbol, [<Optional>] ?v : Symbol, [<Optional>] ?z : Symbol, [<Optional>] ?beta1 : float, [<Optional>] ?beta2 : float, [<Optional>] ?epsilon : double, [<Optional>] ?wd : float, [<Optional>] ?rescaleGrad : float, [<Optional>] ?clipGrad : float) =
        FtmlUpdate(lr, t, ?weight = weight, ?grad = grad, ?d = d, ?v = v, ?z = z, ?beta1 = beta1, ?beta2 = beta2, ?epsilon = epsilon, ?wd = wd, ?rescaleGrad = rescaleGrad, ?clipGrad = clipGrad)

    /// <summary>Update function for Adam optimizer. Adam is seen as a generalization
    /// of AdaGrad.
    /// 
    /// Adam update consists of the following steps, where g represents gradient and m, v
    /// are 1st and 2nd order moment estimates (mean and variance).
    /// 
    /// .. math::
    /// 
    ///  g_t = \nabla J(W_{t-1})\\
    ///  m_t = \beta_1 m_{t-1} + (1 - \beta_1) g_t\\
    ///  v_t = \beta_2 v_{t-1} + (1 - \beta_2) g_t^2\\
    ///  W_t = W_{t-1} - \alpha \frac{ m_t }{ \sqrt{ v_t } + \epsilon }
    /// 
    /// It updates the weights using::
    /// 
    ///  m = beta1*m + (1-beta1)*grad
    ///  v = beta2*v + (1-beta2)*(grad**2)
    ///  w += - learning_rate * m / (sqrt(v) + epsilon)
    /// 
    /// However, if grad&#39;s storage type is ``row_sparse``, ``lazy_update`` is True and the storage
    /// type of weight is the same as those of m and v,
    /// only the row slices whose indices appear in grad.indices are updated (for w, m and v)::
    /// 
    ///  for row in grad.indices:
    ///      m[row] = beta1*m[row] + (1-beta1)*grad[row]
    ///      v[row] = beta2*v[row] + (1-beta2)*(grad[row]**2)
    ///      w[row] += - learning_rate * m[row] / (sqrt(v[row]) + epsilon)
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\optimizer_op.cc:L688</summary>
    /// <param name="weight">Weight</param>
    /// <param name="grad">Gradient</param>
    /// <param name="mean">Moving mean</param>
    /// <param name="var">Moving variance</param>
    /// <param name="lr">Learning rate</param>
    /// <param name="beta1">The decay rate for the 1st moment estimates.</param>
    /// <param name="beta2">The decay rate for the 2nd moment estimates.</param>
    /// <param name="epsilon">A small constant for numerical stability.</param>
    /// <param name="wd">Weight decay augments the objective function with a regularization term that penalizes large weights. The penalty scales with the square of the magnitude of each weight.</param>
    /// <param name="rescaleGrad">Rescale gradient to grad = rescale_grad*grad.</param>
    /// <param name="clipGradient">Clip gradient to the range of [-clip_gradient, clip_gradient] If clip_gradient &lt;= 0, gradient clipping is turned off. grad = max(min(grad, clip_gradient), -clip_gradient).</param>
    /// <param name="lazyUpdate">If true, lazy updates are applied if gradient&#39;s stype is row_sparse and all of w, m and v have the same stype</param>
    static member AdamUpdate(weight : NDArray, 
                             grad : NDArray, 
                             mean : NDArray, 
                             var : NDArray, 
                             lr : float, 
                             [<Optional; DefaultParameterValue(0.899999976)>] beta1 : float, 
                             [<Optional; DefaultParameterValue(0.999000013)>] beta2 : float, 
                             [<Optional; DefaultParameterValue(9.99999994E-09)>] epsilon : float, 
                             [<Optional; DefaultParameterValue(0.0)>] wd : float, 
                             [<Optional; DefaultParameterValue(1.0)>] rescaleGrad : float, 
                             [<Optional; DefaultParameterValue(-1.0)>] clipGradient : float, 
                             [<Optional; DefaultParameterValue(true)>] lazyUpdate : bool) =
        let creator = AtomicSymbolCreator.FromName "adam_update"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg weight)) then weight.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg grad)) then grad.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg mean)) then mean.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg var)) then var.UnsafeHandle|]
                                                 [|"lr"; "beta1"; "beta2"; "epsilon"; "wd"; "rescale_grad"; "clip_gradient"; "lazy_update"|]
                                                 [|string lr; string beta1; string beta2; string epsilon; string wd; string rescaleGrad; string clipGradient; string lazyUpdate|]
        (new NDArray(outputs.[0]))
    /// <summary>Update function for Adam optimizer. Adam is seen as a generalization
    /// of AdaGrad.
    /// 
    /// Adam update consists of the following steps, where g represents gradient and m, v
    /// are 1st and 2nd order moment estimates (mean and variance).
    /// 
    /// .. math::
    /// 
    ///  g_t = \nabla J(W_{t-1})\\
    ///  m_t = \beta_1 m_{t-1} + (1 - \beta_1) g_t\\
    ///  v_t = \beta_2 v_{t-1} + (1 - \beta_2) g_t^2\\
    ///  W_t = W_{t-1} - \alpha \frac{ m_t }{ \sqrt{ v_t } + \epsilon }
    /// 
    /// It updates the weights using::
    /// 
    ///  m = beta1*m + (1-beta1)*grad
    ///  v = beta2*v + (1-beta2)*(grad**2)
    ///  w += - learning_rate * m / (sqrt(v) + epsilon)
    /// 
    /// However, if grad&#39;s storage type is ``row_sparse``, ``lazy_update`` is True and the storage
    /// type of weight is the same as those of m and v,
    /// only the row slices whose indices appear in grad.indices are updated (for w, m and v)::
    /// 
    ///  for row in grad.indices:
    ///      m[row] = beta1*m[row] + (1-beta1)*grad[row]
    ///      v[row] = beta2*v[row] + (1-beta2)*(grad[row]**2)
    ///      w[row] += - learning_rate * m[row] / (sqrt(v[row]) + epsilon)
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\optimizer_op.cc:L688</summary>
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="weight">Weight</param>
    /// <param name="grad">Gradient</param>
    /// <param name="mean">Moving mean</param>
    /// <param name="var">Moving variance</param>
    /// <param name="lr">Learning rate</param>
    /// <param name="beta1">The decay rate for the 1st moment estimates.</param>
    /// <param name="beta2">The decay rate for the 2nd moment estimates.</param>
    /// <param name="epsilon">A small constant for numerical stability.</param>
    /// <param name="wd">Weight decay augments the objective function with a regularization term that penalizes large weights. The penalty scales with the square of the magnitude of each weight.</param>
    /// <param name="rescaleGrad">Rescale gradient to grad = rescale_grad*grad.</param>
    /// <param name="clipGradient">Clip gradient to the range of [-clip_gradient, clip_gradient] If clip_gradient &lt;= 0, gradient clipping is turned off. grad = max(min(grad, clip_gradient), -clip_gradient).</param>
    /// <param name="lazyUpdate">If true, lazy updates are applied if gradient&#39;s stype is row_sparse and all of w, m and v have the same stype</param>
    static member AdamUpdate(outputArray : NDArray seq, 
                             weight : NDArray, 
                             grad : NDArray, 
                             mean : NDArray, 
                             var : NDArray, 
                             lr : float, 
                             [<Optional; DefaultParameterValue(0.899999976)>] beta1 : float, 
                             [<Optional; DefaultParameterValue(0.999000013)>] beta2 : float, 
                             [<Optional; DefaultParameterValue(9.99999994E-09)>] epsilon : float, 
                             [<Optional; DefaultParameterValue(0.0)>] wd : float, 
                             [<Optional; DefaultParameterValue(1.0)>] rescaleGrad : float, 
                             [<Optional; DefaultParameterValue(-1.0)>] clipGradient : float, 
                             [<Optional; DefaultParameterValue(true)>] lazyUpdate : bool) =
        let creator = AtomicSymbolCreator.FromName "adam_update"
        let names = [|"lr"; "beta1"; "beta2"; "epsilon"; "wd"; "rescale_grad"; "clip_gradient"; "lazy_update"|]
        let vals = [|string lr; string beta1; string beta2; string epsilon; string wd; string rescaleGrad; string clipGradient; string lazyUpdate|]
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg weight)) then weight.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg grad)) then grad.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg mean)) then mean.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg var)) then var.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <summary>Update function for Adam optimizer. Adam is seen as a generalization
    /// of AdaGrad.
    /// 
    /// Adam update consists of the following steps, where g represents gradient and m, v
    /// are 1st and 2nd order moment estimates (mean and variance).
    /// 
    /// .. math::
    /// 
    ///  g_t = \nabla J(W_{t-1})\\
    ///  m_t = \beta_1 m_{t-1} + (1 - \beta_1) g_t\\
    ///  v_t = \beta_2 v_{t-1} + (1 - \beta_2) g_t^2\\
    ///  W_t = W_{t-1} - \alpha \frac{ m_t }{ \sqrt{ v_t } + \epsilon }
    /// 
    /// It updates the weights using::
    /// 
    ///  m = beta1*m + (1-beta1)*grad
    ///  v = beta2*v + (1-beta2)*(grad**2)
    ///  w += - learning_rate * m / (sqrt(v) + epsilon)
    /// 
    /// However, if grad&#39;s storage type is ``row_sparse``, ``lazy_update`` is True and the storage
    /// type of weight is the same as those of m and v,
    /// only the row slices whose indices appear in grad.indices are updated (for w, m and v)::
    /// 
    ///  for row in grad.indices:
    ///      m[row] = beta1*m[row] + (1-beta1)*grad[row]
    ///      v[row] = beta2*v[row] + (1-beta2)*(grad[row]**2)
    ///      w[row] += - learning_rate * m[row] / (sqrt(v[row]) + epsilon)
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\optimizer_op.cc:L688</summary>
    /// <param name="weight">Weight</param>
    /// <param name="grad">Gradient</param>
    /// <param name="mean">Moving mean</param>
    /// <param name="var">Moving variance</param>
    /// <param name="lr">Learning rate</param>
    /// <param name="beta1">The decay rate for the 1st moment estimates.</param>
    /// <param name="beta2">The decay rate for the 2nd moment estimates.</param>
    /// <param name="epsilon">A small constant for numerical stability.</param>
    /// <param name="wd">Weight decay augments the objective function with a regularization term that penalizes large weights. The penalty scales with the square of the magnitude of each weight.</param>
    /// <param name="rescaleGrad">Rescale gradient to grad = rescale_grad*grad.</param>
    /// <param name="clipGradient">Clip gradient to the range of [-clip_gradient, clip_gradient] If clip_gradient &lt;= 0, gradient clipping is turned off. grad = max(min(grad, clip_gradient), -clip_gradient).</param>
    /// <param name="lazyUpdate">If true, lazy updates are applied if gradient&#39;s stype is row_sparse and all of w, m and v have the same stype</param>
    static member AdamUpdate(weight : Symbol, grad : Symbol, mean : Symbol, var : Symbol, lr : float, [<Optional>] ?beta1 : float, [<Optional>] ?beta2 : float, [<Optional>] ?epsilon : float, [<Optional>] ?wd : float, [<Optional>] ?rescaleGrad : float, [<Optional>] ?clipGradient : float, [<Optional>] ?lazyUpdate : bool) =
        AdamUpdate(weight, grad, mean, var, lr, ?beta1 = beta1, ?beta2 = beta2, ?epsilon = epsilon, ?wd = wd, ?rescaleGrad = rescaleGrad, ?clipGradient = clipGradient, ?lazyUpdate = lazyUpdate)
    /// <summary>Update function for Adam optimizer. Adam is seen as a generalization
    /// of AdaGrad.
    /// 
    /// Adam update consists of the following steps, where g represents gradient and m, v
    /// are 1st and 2nd order moment estimates (mean and variance).
    /// 
    /// .. math::
    /// 
    ///  g_t = \nabla J(W_{t-1})\\
    ///  m_t = \beta_1 m_{t-1} + (1 - \beta_1) g_t\\
    ///  v_t = \beta_2 v_{t-1} + (1 - \beta_2) g_t^2\\
    ///  W_t = W_{t-1} - \alpha \frac{ m_t }{ \sqrt{ v_t } + \epsilon }
    /// 
    /// It updates the weights using::
    /// 
    ///  m = beta1*m + (1-beta1)*grad
    ///  v = beta2*v + (1-beta2)*(grad**2)
    ///  w += - learning_rate * m / (sqrt(v) + epsilon)
    /// 
    /// However, if grad&#39;s storage type is ``row_sparse``, ``lazy_update`` is True and the storage
    /// type of weight is the same as those of m and v,
    /// only the row slices whose indices appear in grad.indices are updated (for w, m and v)::
    /// 
    ///  for row in grad.indices:
    ///      m[row] = beta1*m[row] + (1-beta1)*grad[row]
    ///      v[row] = beta2*v[row] + (1-beta2)*(grad[row]**2)
    ///      w[row] += - learning_rate * m[row] / (sqrt(v[row]) + epsilon)
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\optimizer_op.cc:L688</summary>
    /// <param name="lr">Learning rate</param>
    /// <param name="weight">Weight</param>
    /// <param name="grad">Gradient</param>
    /// <param name="mean">Moving mean</param>
    /// <param name="var">Moving variance</param>
    /// <param name="beta1">The decay rate for the 1st moment estimates.</param>
    /// <param name="beta2">The decay rate for the 2nd moment estimates.</param>
    /// <param name="epsilon">A small constant for numerical stability.</param>
    /// <param name="wd">Weight decay augments the objective function with a regularization term that penalizes large weights. The penalty scales with the square of the magnitude of each weight.</param>
    /// <param name="rescaleGrad">Rescale gradient to grad = rescale_grad*grad.</param>
    /// <param name="clipGradient">Clip gradient to the range of [-clip_gradient, clip_gradient] If clip_gradient &lt;= 0, gradient clipping is turned off. grad = max(min(grad, clip_gradient), -clip_gradient).</param>
    /// <param name="lazyUpdate">If true, lazy updates are applied if gradient&#39;s stype is row_sparse and all of w, m and v have the same stype</param>
    static member AdamUpdate(lr : float, [<Optional>] ?weight : Symbol, [<Optional>] ?grad : Symbol, [<Optional>] ?mean : Symbol, [<Optional>] ?var : Symbol, [<Optional>] ?beta1 : float, [<Optional>] ?beta2 : float, [<Optional>] ?epsilon : float, [<Optional>] ?wd : float, [<Optional>] ?rescaleGrad : float, [<Optional>] ?clipGradient : float, [<Optional>] ?lazyUpdate : bool) =
        AdamUpdate(lr, ?weight = weight, ?grad = grad, ?mean = mean, ?var = var, ?beta1 = beta1, ?beta2 = beta2, ?epsilon = epsilon, ?wd = wd, ?rescaleGrad = rescaleGrad, ?clipGradient = clipGradient, ?lazyUpdate = lazyUpdate)

    /// <summary>Update function for Nesterov Accelerated Gradient( NAG) optimizer.
    /// It updates the weights using the following formula,
    /// 
    /// .. math::
    ///   v_t = \gamma v_{t-1} + \eta * \nabla J(W_{t-1} - \gamma v_{t-1})\\
    ///   W_t = W_{t-1} - v_t
    /// 
    /// Where 
    /// :math:`\eta` is the learning rate of the optimizer
    /// :math:`\gamma` is the decay rate of the momentum estimate
    /// :math:`\v_t` is the update vector at time step `t`
    /// :math:`\W_t` is the weight vector at time step `t`
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\optimizer_op.cc:L726</summary>
    /// <param name="weight">Weight</param>
    /// <param name="grad">Gradient</param>
    /// <param name="mom">Momentum</param>
    /// <param name="lr">Learning rate</param>
    /// <param name="momentum">The decay rate of momentum estimates at each epoch.</param>
    /// <param name="wd">Weight decay augments the objective function with a regularization term that penalizes large weights. The penalty scales with the square of the magnitude of each weight.</param>
    /// <param name="rescaleGrad">Rescale gradient to grad = rescale_grad*grad.</param>
    /// <param name="clipGradient">Clip gradient to the range of [-clip_gradient, clip_gradient] If clip_gradient &lt;= 0, gradient clipping is turned off. grad = max(min(grad, clip_gradient), -clip_gradient).</param>
    static member NagMomUpdate(weight : NDArray, 
                               grad : NDArray, 
                               mom : NDArray, 
                               lr : float, 
                               [<Optional; DefaultParameterValue(0.0)>] momentum : float, 
                               [<Optional; DefaultParameterValue(0.0)>] wd : float, 
                               [<Optional; DefaultParameterValue(1.0)>] rescaleGrad : float, 
                               [<Optional; DefaultParameterValue(-1.0)>] clipGradient : float) =
        let creator = AtomicSymbolCreator.FromName "nag_mom_update"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg weight)) then weight.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg grad)) then grad.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg mom)) then mom.UnsafeHandle|]
                                                 [|"lr"; "momentum"; "wd"; "rescale_grad"; "clip_gradient"|]
                                                 [|string lr; string momentum; string wd; string rescaleGrad; string clipGradient|]
        (new NDArray(outputs.[0]))
    /// <summary>Update function for Nesterov Accelerated Gradient( NAG) optimizer.
    /// It updates the weights using the following formula,
    /// 
    /// .. math::
    ///   v_t = \gamma v_{t-1} + \eta * \nabla J(W_{t-1} - \gamma v_{t-1})\\
    ///   W_t = W_{t-1} - v_t
    /// 
    /// Where 
    /// :math:`\eta` is the learning rate of the optimizer
    /// :math:`\gamma` is the decay rate of the momentum estimate
    /// :math:`\v_t` is the update vector at time step `t`
    /// :math:`\W_t` is the weight vector at time step `t`
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\optimizer_op.cc:L726</summary>
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="weight">Weight</param>
    /// <param name="grad">Gradient</param>
    /// <param name="mom">Momentum</param>
    /// <param name="lr">Learning rate</param>
    /// <param name="momentum">The decay rate of momentum estimates at each epoch.</param>
    /// <param name="wd">Weight decay augments the objective function with a regularization term that penalizes large weights. The penalty scales with the square of the magnitude of each weight.</param>
    /// <param name="rescaleGrad">Rescale gradient to grad = rescale_grad*grad.</param>
    /// <param name="clipGradient">Clip gradient to the range of [-clip_gradient, clip_gradient] If clip_gradient &lt;= 0, gradient clipping is turned off. grad = max(min(grad, clip_gradient), -clip_gradient).</param>
    static member NagMomUpdate(outputArray : NDArray seq, 
                               weight : NDArray, 
                               grad : NDArray, 
                               mom : NDArray, 
                               lr : float, 
                               [<Optional; DefaultParameterValue(0.0)>] momentum : float, 
                               [<Optional; DefaultParameterValue(0.0)>] wd : float, 
                               [<Optional; DefaultParameterValue(1.0)>] rescaleGrad : float, 
                               [<Optional; DefaultParameterValue(-1.0)>] clipGradient : float) =
        let creator = AtomicSymbolCreator.FromName "nag_mom_update"
        let names = [|"lr"; "momentum"; "wd"; "rescale_grad"; "clip_gradient"|]
        let vals = [|string lr; string momentum; string wd; string rescaleGrad; string clipGradient|]
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg weight)) then weight.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg grad)) then grad.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg mom)) then mom.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <summary>Update function for Nesterov Accelerated Gradient( NAG) optimizer.
    /// It updates the weights using the following formula,
    /// 
    /// .. math::
    ///   v_t = \gamma v_{t-1} + \eta * \nabla J(W_{t-1} - \gamma v_{t-1})\\
    ///   W_t = W_{t-1} - v_t
    /// 
    /// Where 
    /// :math:`\eta` is the learning rate of the optimizer
    /// :math:`\gamma` is the decay rate of the momentum estimate
    /// :math:`\v_t` is the update vector at time step `t`
    /// :math:`\W_t` is the weight vector at time step `t`
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\optimizer_op.cc:L726</summary>
    /// <param name="weight">Weight</param>
    /// <param name="grad">Gradient</param>
    /// <param name="mom">Momentum</param>
    /// <param name="lr">Learning rate</param>
    /// <param name="momentum">The decay rate of momentum estimates at each epoch.</param>
    /// <param name="wd">Weight decay augments the objective function with a regularization term that penalizes large weights. The penalty scales with the square of the magnitude of each weight.</param>
    /// <param name="rescaleGrad">Rescale gradient to grad = rescale_grad*grad.</param>
    /// <param name="clipGradient">Clip gradient to the range of [-clip_gradient, clip_gradient] If clip_gradient &lt;= 0, gradient clipping is turned off. grad = max(min(grad, clip_gradient), -clip_gradient).</param>
    static member NagMomUpdate(weight : Symbol, grad : Symbol, mom : Symbol, lr : float, [<Optional>] ?momentum : float, [<Optional>] ?wd : float, [<Optional>] ?rescaleGrad : float, [<Optional>] ?clipGradient : float) =
        NagMomUpdate(weight, grad, mom, lr, ?momentum = momentum, ?wd = wd, ?rescaleGrad = rescaleGrad, ?clipGradient = clipGradient)
    /// <summary>Update function for Nesterov Accelerated Gradient( NAG) optimizer.
    /// It updates the weights using the following formula,
    /// 
    /// .. math::
    ///   v_t = \gamma v_{t-1} + \eta * \nabla J(W_{t-1} - \gamma v_{t-1})\\
    ///   W_t = W_{t-1} - v_t
    /// 
    /// Where 
    /// :math:`\eta` is the learning rate of the optimizer
    /// :math:`\gamma` is the decay rate of the momentum estimate
    /// :math:`\v_t` is the update vector at time step `t`
    /// :math:`\W_t` is the weight vector at time step `t`
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\optimizer_op.cc:L726</summary>
    /// <param name="lr">Learning rate</param>
    /// <param name="weight">Weight</param>
    /// <param name="grad">Gradient</param>
    /// <param name="mom">Momentum</param>
    /// <param name="momentum">The decay rate of momentum estimates at each epoch.</param>
    /// <param name="wd">Weight decay augments the objective function with a regularization term that penalizes large weights. The penalty scales with the square of the magnitude of each weight.</param>
    /// <param name="rescaleGrad">Rescale gradient to grad = rescale_grad*grad.</param>
    /// <param name="clipGradient">Clip gradient to the range of [-clip_gradient, clip_gradient] If clip_gradient &lt;= 0, gradient clipping is turned off. grad = max(min(grad, clip_gradient), -clip_gradient).</param>
    static member NagMomUpdate(lr : float, [<Optional>] ?weight : Symbol, [<Optional>] ?grad : Symbol, [<Optional>] ?mom : Symbol, [<Optional>] ?momentum : float, [<Optional>] ?wd : float, [<Optional>] ?rescaleGrad : float, [<Optional>] ?clipGradient : float) =
        NagMomUpdate(lr, ?weight = weight, ?grad = grad, ?mom = mom, ?momentum = momentum, ?wd = wd, ?rescaleGrad = rescaleGrad, ?clipGradient = clipGradient)

    /// <summary>Update function for multi-precision Nesterov Accelerated Gradient( NAG) optimizer.
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\optimizer_op.cc:L745</summary>
    /// <param name="weight">Weight</param>
    /// <param name="grad">Gradient</param>
    /// <param name="mom">Momentum</param>
    /// <param name="weight32">Weight32</param>
    /// <param name="lr">Learning rate</param>
    /// <param name="momentum">The decay rate of momentum estimates at each epoch.</param>
    /// <param name="wd">Weight decay augments the objective function with a regularization term that penalizes large weights. The penalty scales with the square of the magnitude of each weight.</param>
    /// <param name="rescaleGrad">Rescale gradient to grad = rescale_grad*grad.</param>
    /// <param name="clipGradient">Clip gradient to the range of [-clip_gradient, clip_gradient] If clip_gradient &lt;= 0, gradient clipping is turned off. grad = max(min(grad, clip_gradient), -clip_gradient).</param>
    static member MpNagMomUpdate(weight : NDArray, 
                                 grad : NDArray, 
                                 mom : NDArray, 
                                 weight32 : NDArray, 
                                 lr : float, 
                                 [<Optional; DefaultParameterValue(0.0)>] momentum : float, 
                                 [<Optional; DefaultParameterValue(0.0)>] wd : float, 
                                 [<Optional; DefaultParameterValue(1.0)>] rescaleGrad : float, 
                                 [<Optional; DefaultParameterValue(-1.0)>] clipGradient : float) =
        let creator = AtomicSymbolCreator.FromName "mp_nag_mom_update"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg weight)) then weight.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg grad)) then grad.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg mom)) then mom.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg weight32)) then weight32.UnsafeHandle|]
                                                 [|"lr"; "momentum"; "wd"; "rescale_grad"; "clip_gradient"|]
                                                 [|string lr; string momentum; string wd; string rescaleGrad; string clipGradient|]
        (new NDArray(outputs.[0]))
    /// <summary>Update function for multi-precision Nesterov Accelerated Gradient( NAG) optimizer.
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\optimizer_op.cc:L745</summary>
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="weight">Weight</param>
    /// <param name="grad">Gradient</param>
    /// <param name="mom">Momentum</param>
    /// <param name="weight32">Weight32</param>
    /// <param name="lr">Learning rate</param>
    /// <param name="momentum">The decay rate of momentum estimates at each epoch.</param>
    /// <param name="wd">Weight decay augments the objective function with a regularization term that penalizes large weights. The penalty scales with the square of the magnitude of each weight.</param>
    /// <param name="rescaleGrad">Rescale gradient to grad = rescale_grad*grad.</param>
    /// <param name="clipGradient">Clip gradient to the range of [-clip_gradient, clip_gradient] If clip_gradient &lt;= 0, gradient clipping is turned off. grad = max(min(grad, clip_gradient), -clip_gradient).</param>
    static member MpNagMomUpdate(outputArray : NDArray seq, 
                                 weight : NDArray, 
                                 grad : NDArray, 
                                 mom : NDArray, 
                                 weight32 : NDArray, 
                                 lr : float, 
                                 [<Optional; DefaultParameterValue(0.0)>] momentum : float, 
                                 [<Optional; DefaultParameterValue(0.0)>] wd : float, 
                                 [<Optional; DefaultParameterValue(1.0)>] rescaleGrad : float, 
                                 [<Optional; DefaultParameterValue(-1.0)>] clipGradient : float) =
        let creator = AtomicSymbolCreator.FromName "mp_nag_mom_update"
        let names = [|"lr"; "momentum"; "wd"; "rescale_grad"; "clip_gradient"|]
        let vals = [|string lr; string momentum; string wd; string rescaleGrad; string clipGradient|]
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg weight)) then weight.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg grad)) then grad.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg mom)) then mom.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg weight32)) then weight32.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <summary>Update function for multi-precision Nesterov Accelerated Gradient( NAG) optimizer.
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\optimizer_op.cc:L745</summary>
    /// <param name="weight">Weight</param>
    /// <param name="grad">Gradient</param>
    /// <param name="mom">Momentum</param>
    /// <param name="weight32">Weight32</param>
    /// <param name="lr">Learning rate</param>
    /// <param name="momentum">The decay rate of momentum estimates at each epoch.</param>
    /// <param name="wd">Weight decay augments the objective function with a regularization term that penalizes large weights. The penalty scales with the square of the magnitude of each weight.</param>
    /// <param name="rescaleGrad">Rescale gradient to grad = rescale_grad*grad.</param>
    /// <param name="clipGradient">Clip gradient to the range of [-clip_gradient, clip_gradient] If clip_gradient &lt;= 0, gradient clipping is turned off. grad = max(min(grad, clip_gradient), -clip_gradient).</param>
    static member MpNagMomUpdate(weight : Symbol, grad : Symbol, mom : Symbol, weight32 : Symbol, lr : float, [<Optional>] ?momentum : float, [<Optional>] ?wd : float, [<Optional>] ?rescaleGrad : float, [<Optional>] ?clipGradient : float) =
        MpNagMomUpdate(weight, grad, mom, weight32, lr, ?momentum = momentum, ?wd = wd, ?rescaleGrad = rescaleGrad, ?clipGradient = clipGradient)
    /// <summary>Update function for multi-precision Nesterov Accelerated Gradient( NAG) optimizer.
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\optimizer_op.cc:L745</summary>
    /// <param name="lr">Learning rate</param>
    /// <param name="weight">Weight</param>
    /// <param name="grad">Gradient</param>
    /// <param name="mom">Momentum</param>
    /// <param name="weight32">Weight32</param>
    /// <param name="momentum">The decay rate of momentum estimates at each epoch.</param>
    /// <param name="wd">Weight decay augments the objective function with a regularization term that penalizes large weights. The penalty scales with the square of the magnitude of each weight.</param>
    /// <param name="rescaleGrad">Rescale gradient to grad = rescale_grad*grad.</param>
    /// <param name="clipGradient">Clip gradient to the range of [-clip_gradient, clip_gradient] If clip_gradient &lt;= 0, gradient clipping is turned off. grad = max(min(grad, clip_gradient), -clip_gradient).</param>
    static member MpNagMomUpdate(lr : float, [<Optional>] ?weight : Symbol, [<Optional>] ?grad : Symbol, [<Optional>] ?mom : Symbol, [<Optional>] ?weight32 : Symbol, [<Optional>] ?momentum : float, [<Optional>] ?wd : float, [<Optional>] ?rescaleGrad : float, [<Optional>] ?clipGradient : float) =
        MpNagMomUpdate(lr, ?weight = weight, ?grad = grad, ?mom = mom, ?weight32 = weight32, ?momentum = momentum, ?wd = wd, ?rescaleGrad = rescaleGrad, ?clipGradient = clipGradient)

    /// <summary>Update function for `RMSProp` optimizer.
    /// 
    /// `RMSprop` is a variant of stochastic gradient descent where the gradients are
    /// divided by a cache which grows with the sum of squares of recent gradients?
    /// 
    /// `RMSProp` is similar to `AdaGrad`, a popular variant of `SGD` which adaptively
    /// tunes the learning rate of each parameter. `AdaGrad` lowers the learning rate for
    /// each parameter monotonically over the course of training.
    /// While this is analytically motivated for convex optimizations, it may not be ideal
    /// for non-convex problems. `RMSProp` deals with this heuristically by allowing the
    /// learning rates to rebound as the denominator decays over time.
    /// 
    /// Define the Root Mean Square (RMS) error criterion of the gradient as
    /// :math:`RMS[g]_t = \sqrt{E[g^2]_t + \epsilon}`, where :math:`g` represents
    /// gradient and :math:`E[g^2]_t` is the decaying average over past squared gradient.
    /// 
    /// The :math:`E[g^2]_t` is given by:
    /// 
    /// .. math::
    ///   E[g^2]_t = \gamma * E[g^2]_{t-1} + (1-\gamma) * g_t^2
    /// 
    /// The update step is
    /// 
    /// .. math::
    ///   \theta_{t+1} = \theta_t - \frac{\eta}{RMS[g]_t} g_t
    /// 
    /// The RMSProp code follows the version in
    /// http://www.cs.toronto.edu/~tijmen/csc321/slides/lecture_slides_lec6.pdf
    /// Tieleman &amp; Hinton, 2012.
    /// 
    /// Hinton suggests the momentum term :math:`\gamma` to be 0.9 and the learning rate
    /// :math:`\eta` to be 0.001.
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\optimizer_op.cc:L797</summary>
    /// <param name="weight">Weight</param>
    /// <param name="grad">Gradient</param>
    /// <param name="n">n</param>
    /// <param name="lr">Learning rate</param>
    /// <param name="gamma1">The decay rate of momentum estimates.</param>
    /// <param name="epsilon">A small constant for numerical stability.</param>
    /// <param name="wd">Weight decay augments the objective function with a regularization term that penalizes large weights. The penalty scales with the square of the magnitude of each weight.</param>
    /// <param name="rescaleGrad">Rescale gradient to grad = rescale_grad*grad.</param>
    /// <param name="clipGradient">Clip gradient to the range of [-clip_gradient, clip_gradient] If clip_gradient &lt;= 0, gradient clipping is turned off. grad = max(min(grad, clip_gradient), -clip_gradient).</param>
    /// <param name="clipWeights">Clip weights to the range of [-clip_weights, clip_weights] If clip_weights &lt;= 0, weight clipping is turned off. weights = max(min(weights, clip_weights), -clip_weights).</param>
    static member RmspropUpdate(weight : NDArray, 
                                grad : NDArray, 
                                n : NDArray, 
                                lr : float, 
                                [<Optional; DefaultParameterValue(0.949999988)>] gamma1 : float, 
                                [<Optional; DefaultParameterValue(9.99999994E-09)>] epsilon : float, 
                                [<Optional; DefaultParameterValue(0.0)>] wd : float, 
                                [<Optional; DefaultParameterValue(1.0)>] rescaleGrad : float, 
                                [<Optional; DefaultParameterValue(-1.0)>] clipGradient : float, 
                                [<Optional; DefaultParameterValue(-1.0)>] clipWeights : float) =
        let creator = AtomicSymbolCreator.FromName "rmsprop_update"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg weight)) then weight.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg grad)) then grad.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg n)) then n.UnsafeHandle|]
                                                 [|"lr"; "gamma1"; "epsilon"; "wd"; "rescale_grad"; "clip_gradient"; "clip_weights"|]
                                                 [|string lr; string gamma1; string epsilon; string wd; string rescaleGrad; string clipGradient; string clipWeights|]
        (new NDArray(outputs.[0]))
    /// <summary>Update function for `RMSProp` optimizer.
    /// 
    /// `RMSprop` is a variant of stochastic gradient descent where the gradients are
    /// divided by a cache which grows with the sum of squares of recent gradients?
    /// 
    /// `RMSProp` is similar to `AdaGrad`, a popular variant of `SGD` which adaptively
    /// tunes the learning rate of each parameter. `AdaGrad` lowers the learning rate for
    /// each parameter monotonically over the course of training.
    /// While this is analytically motivated for convex optimizations, it may not be ideal
    /// for non-convex problems. `RMSProp` deals with this heuristically by allowing the
    /// learning rates to rebound as the denominator decays over time.
    /// 
    /// Define the Root Mean Square (RMS) error criterion of the gradient as
    /// :math:`RMS[g]_t = \sqrt{E[g^2]_t + \epsilon}`, where :math:`g` represents
    /// gradient and :math:`E[g^2]_t` is the decaying average over past squared gradient.
    /// 
    /// The :math:`E[g^2]_t` is given by:
    /// 
    /// .. math::
    ///   E[g^2]_t = \gamma * E[g^2]_{t-1} + (1-\gamma) * g_t^2
    /// 
    /// The update step is
    /// 
    /// .. math::
    ///   \theta_{t+1} = \theta_t - \frac{\eta}{RMS[g]_t} g_t
    /// 
    /// The RMSProp code follows the version in
    /// http://www.cs.toronto.edu/~tijmen/csc321/slides/lecture_slides_lec6.pdf
    /// Tieleman &amp; Hinton, 2012.
    /// 
    /// Hinton suggests the momentum term :math:`\gamma` to be 0.9 and the learning rate
    /// :math:`\eta` to be 0.001.
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\optimizer_op.cc:L797</summary>
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="weight">Weight</param>
    /// <param name="grad">Gradient</param>
    /// <param name="n">n</param>
    /// <param name="lr">Learning rate</param>
    /// <param name="gamma1">The decay rate of momentum estimates.</param>
    /// <param name="epsilon">A small constant for numerical stability.</param>
    /// <param name="wd">Weight decay augments the objective function with a regularization term that penalizes large weights. The penalty scales with the square of the magnitude of each weight.</param>
    /// <param name="rescaleGrad">Rescale gradient to grad = rescale_grad*grad.</param>
    /// <param name="clipGradient">Clip gradient to the range of [-clip_gradient, clip_gradient] If clip_gradient &lt;= 0, gradient clipping is turned off. grad = max(min(grad, clip_gradient), -clip_gradient).</param>
    /// <param name="clipWeights">Clip weights to the range of [-clip_weights, clip_weights] If clip_weights &lt;= 0, weight clipping is turned off. weights = max(min(weights, clip_weights), -clip_weights).</param>
    static member RmspropUpdate(outputArray : NDArray seq, 
                                weight : NDArray, 
                                grad : NDArray, 
                                n : NDArray, 
                                lr : float, 
                                [<Optional; DefaultParameterValue(0.949999988)>] gamma1 : float, 
                                [<Optional; DefaultParameterValue(9.99999994E-09)>] epsilon : float, 
                                [<Optional; DefaultParameterValue(0.0)>] wd : float, 
                                [<Optional; DefaultParameterValue(1.0)>] rescaleGrad : float, 
                                [<Optional; DefaultParameterValue(-1.0)>] clipGradient : float, 
                                [<Optional; DefaultParameterValue(-1.0)>] clipWeights : float) =
        let creator = AtomicSymbolCreator.FromName "rmsprop_update"
        let names = [|"lr"; "gamma1"; "epsilon"; "wd"; "rescale_grad"; "clip_gradient"; "clip_weights"|]
        let vals = [|string lr; string gamma1; string epsilon; string wd; string rescaleGrad; string clipGradient; string clipWeights|]
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg weight)) then weight.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg grad)) then grad.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg n)) then n.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <summary>Update function for `RMSProp` optimizer.
    /// 
    /// `RMSprop` is a variant of stochastic gradient descent where the gradients are
    /// divided by a cache which grows with the sum of squares of recent gradients?
    /// 
    /// `RMSProp` is similar to `AdaGrad`, a popular variant of `SGD` which adaptively
    /// tunes the learning rate of each parameter. `AdaGrad` lowers the learning rate for
    /// each parameter monotonically over the course of training.
    /// While this is analytically motivated for convex optimizations, it may not be ideal
    /// for non-convex problems. `RMSProp` deals with this heuristically by allowing the
    /// learning rates to rebound as the denominator decays over time.
    /// 
    /// Define the Root Mean Square (RMS) error criterion of the gradient as
    /// :math:`RMS[g]_t = \sqrt{E[g^2]_t + \epsilon}`, where :math:`g` represents
    /// gradient and :math:`E[g^2]_t` is the decaying average over past squared gradient.
    /// 
    /// The :math:`E[g^2]_t` is given by:
    /// 
    /// .. math::
    ///   E[g^2]_t = \gamma * E[g^2]_{t-1} + (1-\gamma) * g_t^2
    /// 
    /// The update step is
    /// 
    /// .. math::
    ///   \theta_{t+1} = \theta_t - \frac{\eta}{RMS[g]_t} g_t
    /// 
    /// The RMSProp code follows the version in
    /// http://www.cs.toronto.edu/~tijmen/csc321/slides/lecture_slides_lec6.pdf
    /// Tieleman &amp; Hinton, 2012.
    /// 
    /// Hinton suggests the momentum term :math:`\gamma` to be 0.9 and the learning rate
    /// :math:`\eta` to be 0.001.
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\optimizer_op.cc:L797</summary>
    /// <param name="weight">Weight</param>
    /// <param name="grad">Gradient</param>
    /// <param name="n">n</param>
    /// <param name="lr">Learning rate</param>
    /// <param name="gamma1">The decay rate of momentum estimates.</param>
    /// <param name="epsilon">A small constant for numerical stability.</param>
    /// <param name="wd">Weight decay augments the objective function with a regularization term that penalizes large weights. The penalty scales with the square of the magnitude of each weight.</param>
    /// <param name="rescaleGrad">Rescale gradient to grad = rescale_grad*grad.</param>
    /// <param name="clipGradient">Clip gradient to the range of [-clip_gradient, clip_gradient] If clip_gradient &lt;= 0, gradient clipping is turned off. grad = max(min(grad, clip_gradient), -clip_gradient).</param>
    /// <param name="clipWeights">Clip weights to the range of [-clip_weights, clip_weights] If clip_weights &lt;= 0, weight clipping is turned off. weights = max(min(weights, clip_weights), -clip_weights).</param>
    static member RmspropUpdate(weight : Symbol, grad : Symbol, n : Symbol, lr : float, [<Optional>] ?gamma1 : float, [<Optional>] ?epsilon : float, [<Optional>] ?wd : float, [<Optional>] ?rescaleGrad : float, [<Optional>] ?clipGradient : float, [<Optional>] ?clipWeights : float) =
        RmspropUpdate(weight, grad, n, lr, ?gamma1 = gamma1, ?epsilon = epsilon, ?wd = wd, ?rescaleGrad = rescaleGrad, ?clipGradient = clipGradient, ?clipWeights = clipWeights)
    /// <summary>Update function for `RMSProp` optimizer.
    /// 
    /// `RMSprop` is a variant of stochastic gradient descent where the gradients are
    /// divided by a cache which grows with the sum of squares of recent gradients?
    /// 
    /// `RMSProp` is similar to `AdaGrad`, a popular variant of `SGD` which adaptively
    /// tunes the learning rate of each parameter. `AdaGrad` lowers the learning rate for
    /// each parameter monotonically over the course of training.
    /// While this is analytically motivated for convex optimizations, it may not be ideal
    /// for non-convex problems. `RMSProp` deals with this heuristically by allowing the
    /// learning rates to rebound as the denominator decays over time.
    /// 
    /// Define the Root Mean Square (RMS) error criterion of the gradient as
    /// :math:`RMS[g]_t = \sqrt{E[g^2]_t + \epsilon}`, where :math:`g` represents
    /// gradient and :math:`E[g^2]_t` is the decaying average over past squared gradient.
    /// 
    /// The :math:`E[g^2]_t` is given by:
    /// 
    /// .. math::
    ///   E[g^2]_t = \gamma * E[g^2]_{t-1} + (1-\gamma) * g_t^2
    /// 
    /// The update step is
    /// 
    /// .. math::
    ///   \theta_{t+1} = \theta_t - \frac{\eta}{RMS[g]_t} g_t
    /// 
    /// The RMSProp code follows the version in
    /// http://www.cs.toronto.edu/~tijmen/csc321/slides/lecture_slides_lec6.pdf
    /// Tieleman &amp; Hinton, 2012.
    /// 
    /// Hinton suggests the momentum term :math:`\gamma` to be 0.9 and the learning rate
    /// :math:`\eta` to be 0.001.
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\optimizer_op.cc:L797</summary>
    /// <param name="lr">Learning rate</param>
    /// <param name="weight">Weight</param>
    /// <param name="grad">Gradient</param>
    /// <param name="n">n</param>
    /// <param name="gamma1">The decay rate of momentum estimates.</param>
    /// <param name="epsilon">A small constant for numerical stability.</param>
    /// <param name="wd">Weight decay augments the objective function with a regularization term that penalizes large weights. The penalty scales with the square of the magnitude of each weight.</param>
    /// <param name="rescaleGrad">Rescale gradient to grad = rescale_grad*grad.</param>
    /// <param name="clipGradient">Clip gradient to the range of [-clip_gradient, clip_gradient] If clip_gradient &lt;= 0, gradient clipping is turned off. grad = max(min(grad, clip_gradient), -clip_gradient).</param>
    /// <param name="clipWeights">Clip weights to the range of [-clip_weights, clip_weights] If clip_weights &lt;= 0, weight clipping is turned off. weights = max(min(weights, clip_weights), -clip_weights).</param>
    static member RmspropUpdate(lr : float, [<Optional>] ?weight : Symbol, [<Optional>] ?grad : Symbol, [<Optional>] ?n : Symbol, [<Optional>] ?gamma1 : float, [<Optional>] ?epsilon : float, [<Optional>] ?wd : float, [<Optional>] ?rescaleGrad : float, [<Optional>] ?clipGradient : float, [<Optional>] ?clipWeights : float) =
        RmspropUpdate(lr, ?weight = weight, ?grad = grad, ?n = n, ?gamma1 = gamma1, ?epsilon = epsilon, ?wd = wd, ?rescaleGrad = rescaleGrad, ?clipGradient = clipGradient, ?clipWeights = clipWeights)

    /// <summary>Update function for RMSPropAlex optimizer.
    /// 
    /// `RMSPropAlex` is non-centered version of `RMSProp`.
    /// 
    /// Define :math:`E[g^2]_t` is the decaying average over past squared gradient and
    /// :math:`E[g]_t` is the decaying average over past gradient.
    /// 
    /// .. math::
    ///   E[g^2]_t = \gamma_1 * E[g^2]_{t-1} + (1 - \gamma_1) * g_t^2\\
    ///   E[g]_t = \gamma_1 * E[g]_{t-1} + (1 - \gamma_1) * g_t\\
    ///   \Delta_t = \gamma_2 * \Delta_{t-1} - \frac{\eta}{\sqrt{E[g^2]_t - E[g]_t^2 + \epsilon}} g_t\\
    /// 
    /// The update step is
    /// 
    /// .. math::
    ///   \theta_{t+1} = \theta_t + \Delta_t
    /// 
    /// The RMSPropAlex code follows the version in
    /// http://arxiv.org/pdf/1308.0850v5.pdf Eq(38) - Eq(45) by Alex Graves, 2013.
    /// 
    /// Graves suggests the momentum term :math:`\gamma_1` to be 0.95, :math:`\gamma_2`
    /// to be 0.9 and the learning rate :math:`\eta` to be 0.0001.
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\optimizer_op.cc:L836</summary>
    /// <param name="weight">Weight</param>
    /// <param name="grad">Gradient</param>
    /// <param name="n">n</param>
    /// <param name="g">g</param>
    /// <param name="delta">delta</param>
    /// <param name="lr">Learning rate</param>
    /// <param name="gamma1">Decay rate.</param>
    /// <param name="gamma2">Decay rate.</param>
    /// <param name="epsilon">A small constant for numerical stability.</param>
    /// <param name="wd">Weight decay augments the objective function with a regularization term that penalizes large weights. The penalty scales with the square of the magnitude of each weight.</param>
    /// <param name="rescaleGrad">Rescale gradient to grad = rescale_grad*grad.</param>
    /// <param name="clipGradient">Clip gradient to the range of [-clip_gradient, clip_gradient] If clip_gradient &lt;= 0, gradient clipping is turned off. grad = max(min(grad, clip_gradient), -clip_gradient).</param>
    /// <param name="clipWeights">Clip weights to the range of [-clip_weights, clip_weights] If clip_weights &lt;= 0, weight clipping is turned off. weights = max(min(weights, clip_weights), -clip_weights).</param>
    static member RmspropalexUpdate(weight : NDArray, 
                                    grad : NDArray, 
                                    n : NDArray, 
                                    g : NDArray, 
                                    delta : NDArray, 
                                    lr : float, 
                                    [<Optional; DefaultParameterValue(0.949999988)>] gamma1 : float, 
                                    [<Optional; DefaultParameterValue(0.899999976)>] gamma2 : float, 
                                    [<Optional; DefaultParameterValue(9.99999994E-09)>] epsilon : float, 
                                    [<Optional; DefaultParameterValue(0.0)>] wd : float, 
                                    [<Optional; DefaultParameterValue(1.0)>] rescaleGrad : float, 
                                    [<Optional; DefaultParameterValue(-1.0)>] clipGradient : float, 
                                    [<Optional; DefaultParameterValue(-1.0)>] clipWeights : float) =
        let creator = AtomicSymbolCreator.FromName "rmspropalex_update"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg weight)) then weight.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg grad)) then grad.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg n)) then n.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg g)) then g.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg delta)) then delta.UnsafeHandle|]
                                                 [|"lr"; "gamma1"; "gamma2"; "epsilon"; "wd"; "rescale_grad"; "clip_gradient"; "clip_weights"|]
                                                 [|string lr; string gamma1; string gamma2; string epsilon; string wd; string rescaleGrad; string clipGradient; string clipWeights|]
        (new NDArray(outputs.[0]))
    /// <summary>Update function for RMSPropAlex optimizer.
    /// 
    /// `RMSPropAlex` is non-centered version of `RMSProp`.
    /// 
    /// Define :math:`E[g^2]_t` is the decaying average over past squared gradient and
    /// :math:`E[g]_t` is the decaying average over past gradient.
    /// 
    /// .. math::
    ///   E[g^2]_t = \gamma_1 * E[g^2]_{t-1} + (1 - \gamma_1) * g_t^2\\
    ///   E[g]_t = \gamma_1 * E[g]_{t-1} + (1 - \gamma_1) * g_t\\
    ///   \Delta_t = \gamma_2 * \Delta_{t-1} - \frac{\eta}{\sqrt{E[g^2]_t - E[g]_t^2 + \epsilon}} g_t\\
    /// 
    /// The update step is
    /// 
    /// .. math::
    ///   \theta_{t+1} = \theta_t + \Delta_t
    /// 
    /// The RMSPropAlex code follows the version in
    /// http://arxiv.org/pdf/1308.0850v5.pdf Eq(38) - Eq(45) by Alex Graves, 2013.
    /// 
    /// Graves suggests the momentum term :math:`\gamma_1` to be 0.95, :math:`\gamma_2`
    /// to be 0.9 and the learning rate :math:`\eta` to be 0.0001.
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\optimizer_op.cc:L836</summary>
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="weight">Weight</param>
    /// <param name="grad">Gradient</param>
    /// <param name="n">n</param>
    /// <param name="g">g</param>
    /// <param name="delta">delta</param>
    /// <param name="lr">Learning rate</param>
    /// <param name="gamma1">Decay rate.</param>
    /// <param name="gamma2">Decay rate.</param>
    /// <param name="epsilon">A small constant for numerical stability.</param>
    /// <param name="wd">Weight decay augments the objective function with a regularization term that penalizes large weights. The penalty scales with the square of the magnitude of each weight.</param>
    /// <param name="rescaleGrad">Rescale gradient to grad = rescale_grad*grad.</param>
    /// <param name="clipGradient">Clip gradient to the range of [-clip_gradient, clip_gradient] If clip_gradient &lt;= 0, gradient clipping is turned off. grad = max(min(grad, clip_gradient), -clip_gradient).</param>
    /// <param name="clipWeights">Clip weights to the range of [-clip_weights, clip_weights] If clip_weights &lt;= 0, weight clipping is turned off. weights = max(min(weights, clip_weights), -clip_weights).</param>
    static member RmspropalexUpdate(outputArray : NDArray seq, 
                                    weight : NDArray, 
                                    grad : NDArray, 
                                    n : NDArray, 
                                    g : NDArray, 
                                    delta : NDArray, 
                                    lr : float, 
                                    [<Optional; DefaultParameterValue(0.949999988)>] gamma1 : float, 
                                    [<Optional; DefaultParameterValue(0.899999976)>] gamma2 : float, 
                                    [<Optional; DefaultParameterValue(9.99999994E-09)>] epsilon : float, 
                                    [<Optional; DefaultParameterValue(0.0)>] wd : float, 
                                    [<Optional; DefaultParameterValue(1.0)>] rescaleGrad : float, 
                                    [<Optional; DefaultParameterValue(-1.0)>] clipGradient : float, 
                                    [<Optional; DefaultParameterValue(-1.0)>] clipWeights : float) =
        let creator = AtomicSymbolCreator.FromName "rmspropalex_update"
        let names = [|"lr"; "gamma1"; "gamma2"; "epsilon"; "wd"; "rescale_grad"; "clip_gradient"; "clip_weights"|]
        let vals = [|string lr; string gamma1; string gamma2; string epsilon; string wd; string rescaleGrad; string clipGradient; string clipWeights|]
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg weight)) then weight.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg grad)) then grad.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg n)) then n.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg g)) then g.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg delta)) then delta.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <summary>Update function for RMSPropAlex optimizer.
    /// 
    /// `RMSPropAlex` is non-centered version of `RMSProp`.
    /// 
    /// Define :math:`E[g^2]_t` is the decaying average over past squared gradient and
    /// :math:`E[g]_t` is the decaying average over past gradient.
    /// 
    /// .. math::
    ///   E[g^2]_t = \gamma_1 * E[g^2]_{t-1} + (1 - \gamma_1) * g_t^2\\
    ///   E[g]_t = \gamma_1 * E[g]_{t-1} + (1 - \gamma_1) * g_t\\
    ///   \Delta_t = \gamma_2 * \Delta_{t-1} - \frac{\eta}{\sqrt{E[g^2]_t - E[g]_t^2 + \epsilon}} g_t\\
    /// 
    /// The update step is
    /// 
    /// .. math::
    ///   \theta_{t+1} = \theta_t + \Delta_t
    /// 
    /// The RMSPropAlex code follows the version in
    /// http://arxiv.org/pdf/1308.0850v5.pdf Eq(38) - Eq(45) by Alex Graves, 2013.
    /// 
    /// Graves suggests the momentum term :math:`\gamma_1` to be 0.95, :math:`\gamma_2`
    /// to be 0.9 and the learning rate :math:`\eta` to be 0.0001.
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\optimizer_op.cc:L836</summary>
    /// <param name="weight">Weight</param>
    /// <param name="grad">Gradient</param>
    /// <param name="n">n</param>
    /// <param name="g">g</param>
    /// <param name="delta">delta</param>
    /// <param name="lr">Learning rate</param>
    /// <param name="gamma1">Decay rate.</param>
    /// <param name="gamma2">Decay rate.</param>
    /// <param name="epsilon">A small constant for numerical stability.</param>
    /// <param name="wd">Weight decay augments the objective function with a regularization term that penalizes large weights. The penalty scales with the square of the magnitude of each weight.</param>
    /// <param name="rescaleGrad">Rescale gradient to grad = rescale_grad*grad.</param>
    /// <param name="clipGradient">Clip gradient to the range of [-clip_gradient, clip_gradient] If clip_gradient &lt;= 0, gradient clipping is turned off. grad = max(min(grad, clip_gradient), -clip_gradient).</param>
    /// <param name="clipWeights">Clip weights to the range of [-clip_weights, clip_weights] If clip_weights &lt;= 0, weight clipping is turned off. weights = max(min(weights, clip_weights), -clip_weights).</param>
    static member RmspropalexUpdate(weight : Symbol, grad : Symbol, n : Symbol, g : Symbol, delta : Symbol, lr : float, [<Optional>] ?gamma1 : float, [<Optional>] ?gamma2 : float, [<Optional>] ?epsilon : float, [<Optional>] ?wd : float, [<Optional>] ?rescaleGrad : float, [<Optional>] ?clipGradient : float, [<Optional>] ?clipWeights : float) =
        RmspropalexUpdate(weight, grad, n, g, delta, lr, ?gamma1 = gamma1, ?gamma2 = gamma2, ?epsilon = epsilon, ?wd = wd, ?rescaleGrad = rescaleGrad, ?clipGradient = clipGradient, ?clipWeights = clipWeights)
    /// <summary>Update function for RMSPropAlex optimizer.
    /// 
    /// `RMSPropAlex` is non-centered version of `RMSProp`.
    /// 
    /// Define :math:`E[g^2]_t` is the decaying average over past squared gradient and
    /// :math:`E[g]_t` is the decaying average over past gradient.
    /// 
    /// .. math::
    ///   E[g^2]_t = \gamma_1 * E[g^2]_{t-1} + (1 - \gamma_1) * g_t^2\\
    ///   E[g]_t = \gamma_1 * E[g]_{t-1} + (1 - \gamma_1) * g_t\\
    ///   \Delta_t = \gamma_2 * \Delta_{t-1} - \frac{\eta}{\sqrt{E[g^2]_t - E[g]_t^2 + \epsilon}} g_t\\
    /// 
    /// The update step is
    /// 
    /// .. math::
    ///   \theta_{t+1} = \theta_t + \Delta_t
    /// 
    /// The RMSPropAlex code follows the version in
    /// http://arxiv.org/pdf/1308.0850v5.pdf Eq(38) - Eq(45) by Alex Graves, 2013.
    /// 
    /// Graves suggests the momentum term :math:`\gamma_1` to be 0.95, :math:`\gamma_2`
    /// to be 0.9 and the learning rate :math:`\eta` to be 0.0001.
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\optimizer_op.cc:L836</summary>
    /// <param name="lr">Learning rate</param>
    /// <param name="weight">Weight</param>
    /// <param name="grad">Gradient</param>
    /// <param name="n">n</param>
    /// <param name="g">g</param>
    /// <param name="delta">delta</param>
    /// <param name="gamma1">Decay rate.</param>
    /// <param name="gamma2">Decay rate.</param>
    /// <param name="epsilon">A small constant for numerical stability.</param>
    /// <param name="wd">Weight decay augments the objective function with a regularization term that penalizes large weights. The penalty scales with the square of the magnitude of each weight.</param>
    /// <param name="rescaleGrad">Rescale gradient to grad = rescale_grad*grad.</param>
    /// <param name="clipGradient">Clip gradient to the range of [-clip_gradient, clip_gradient] If clip_gradient &lt;= 0, gradient clipping is turned off. grad = max(min(grad, clip_gradient), -clip_gradient).</param>
    /// <param name="clipWeights">Clip weights to the range of [-clip_weights, clip_weights] If clip_weights &lt;= 0, weight clipping is turned off. weights = max(min(weights, clip_weights), -clip_weights).</param>
    static member RmspropalexUpdate(lr : float, [<Optional>] ?weight : Symbol, [<Optional>] ?grad : Symbol, [<Optional>] ?n : Symbol, [<Optional>] ?g : Symbol, [<Optional>] ?delta : Symbol, [<Optional>] ?gamma1 : float, [<Optional>] ?gamma2 : float, [<Optional>] ?epsilon : float, [<Optional>] ?wd : float, [<Optional>] ?rescaleGrad : float, [<Optional>] ?clipGradient : float, [<Optional>] ?clipWeights : float) =
        RmspropalexUpdate(lr, ?weight = weight, ?grad = grad, ?n = n, ?g = g, ?delta = delta, ?gamma1 = gamma1, ?gamma2 = gamma2, ?epsilon = epsilon, ?wd = wd, ?rescaleGrad = rescaleGrad, ?clipGradient = clipGradient, ?clipWeights = clipWeights)

    /// <summary>Update function for Ftrl optimizer.
    /// Referenced from *Ad Click Prediction: a View from the Trenches*, available at
    /// http://dl.acm.org/citation.cfm?id=2488200.
    /// 
    /// It updates the weights using::
    /// 
    ///  rescaled_grad = clip(grad * rescale_grad, clip_gradient)
    ///  z += rescaled_grad - (sqrt(n + rescaled_grad**2) - sqrt(n)) * weight / learning_rate
    ///  n += rescaled_grad**2
    ///  w = (sign(z) * lamda1 - z) / ((beta + sqrt(n)) / learning_rate + wd) * (abs(z) &gt; lamda1)
    /// 
    /// If w, z and n are all of ``row_sparse`` storage type,
    /// only the row slices whose indices appear in grad.indices are updated (for w, z and n)::
    /// 
    ///  for row in grad.indices:
    ///      rescaled_grad[row] = clip(grad[row] * rescale_grad, clip_gradient)
    ///      z[row] += rescaled_grad[row] - (sqrt(n[row] + rescaled_grad[row]**2) - sqrt(n[row])) * weight[row] / learning_rate
    ///      n[row] += rescaled_grad[row]**2
    ///      w[row] = (sign(z[row]) * lamda1 - z[row]) / ((beta + sqrt(n[row])) / learning_rate + wd) * (abs(z[row]) &gt; lamda1)
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\optimizer_op.cc:L876</summary>
    /// <param name="weight">Weight</param>
    /// <param name="grad">Gradient</param>
    /// <param name="z">z</param>
    /// <param name="n">Square of grad</param>
    /// <param name="lr">Learning rate</param>
    /// <param name="lamda1">The L1 regularization coefficient.</param>
    /// <param name="beta">Per-Coordinate Learning Rate beta.</param>
    /// <param name="wd">Weight decay augments the objective function with a regularization term that penalizes large weights. The penalty scales with the square of the magnitude of each weight.</param>
    /// <param name="rescaleGrad">Rescale gradient to grad = rescale_grad*grad.</param>
    /// <param name="clipGradient">Clip gradient to the range of [-clip_gradient, clip_gradient] If clip_gradient &lt;= 0, gradient clipping is turned off. grad = max(min(grad, clip_gradient), -clip_gradient).</param>
    static member FtrlUpdate(weight : NDArray, 
                             grad : NDArray, 
                             z : NDArray, 
                             n : NDArray, 
                             lr : float, 
                             [<Optional; DefaultParameterValue(0.00999999978)>] lamda1 : float, 
                             [<Optional; DefaultParameterValue(1.0)>] beta : float, 
                             [<Optional; DefaultParameterValue(0.0)>] wd : float, 
                             [<Optional; DefaultParameterValue(1.0)>] rescaleGrad : float, 
                             [<Optional; DefaultParameterValue(-1.0)>] clipGradient : float) =
        let creator = AtomicSymbolCreator.FromName "ftrl_update"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg weight)) then weight.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg grad)) then grad.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg z)) then z.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg n)) then n.UnsafeHandle|]
                                                 [|"lr"; "lamda1"; "beta"; "wd"; "rescale_grad"; "clip_gradient"|]
                                                 [|string lr; string lamda1; string beta; string wd; string rescaleGrad; string clipGradient|]
        (new NDArray(outputs.[0]))
    /// <summary>Update function for Ftrl optimizer.
    /// Referenced from *Ad Click Prediction: a View from the Trenches*, available at
    /// http://dl.acm.org/citation.cfm?id=2488200.
    /// 
    /// It updates the weights using::
    /// 
    ///  rescaled_grad = clip(grad * rescale_grad, clip_gradient)
    ///  z += rescaled_grad - (sqrt(n + rescaled_grad**2) - sqrt(n)) * weight / learning_rate
    ///  n += rescaled_grad**2
    ///  w = (sign(z) * lamda1 - z) / ((beta + sqrt(n)) / learning_rate + wd) * (abs(z) &gt; lamda1)
    /// 
    /// If w, z and n are all of ``row_sparse`` storage type,
    /// only the row slices whose indices appear in grad.indices are updated (for w, z and n)::
    /// 
    ///  for row in grad.indices:
    ///      rescaled_grad[row] = clip(grad[row] * rescale_grad, clip_gradient)
    ///      z[row] += rescaled_grad[row] - (sqrt(n[row] + rescaled_grad[row]**2) - sqrt(n[row])) * weight[row] / learning_rate
    ///      n[row] += rescaled_grad[row]**2
    ///      w[row] = (sign(z[row]) * lamda1 - z[row]) / ((beta + sqrt(n[row])) / learning_rate + wd) * (abs(z[row]) &gt; lamda1)
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\optimizer_op.cc:L876</summary>
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="weight">Weight</param>
    /// <param name="grad">Gradient</param>
    /// <param name="z">z</param>
    /// <param name="n">Square of grad</param>
    /// <param name="lr">Learning rate</param>
    /// <param name="lamda1">The L1 regularization coefficient.</param>
    /// <param name="beta">Per-Coordinate Learning Rate beta.</param>
    /// <param name="wd">Weight decay augments the objective function with a regularization term that penalizes large weights. The penalty scales with the square of the magnitude of each weight.</param>
    /// <param name="rescaleGrad">Rescale gradient to grad = rescale_grad*grad.</param>
    /// <param name="clipGradient">Clip gradient to the range of [-clip_gradient, clip_gradient] If clip_gradient &lt;= 0, gradient clipping is turned off. grad = max(min(grad, clip_gradient), -clip_gradient).</param>
    static member FtrlUpdate(outputArray : NDArray seq, 
                             weight : NDArray, 
                             grad : NDArray, 
                             z : NDArray, 
                             n : NDArray, 
                             lr : float, 
                             [<Optional; DefaultParameterValue(0.00999999978)>] lamda1 : float, 
                             [<Optional; DefaultParameterValue(1.0)>] beta : float, 
                             [<Optional; DefaultParameterValue(0.0)>] wd : float, 
                             [<Optional; DefaultParameterValue(1.0)>] rescaleGrad : float, 
                             [<Optional; DefaultParameterValue(-1.0)>] clipGradient : float) =
        let creator = AtomicSymbolCreator.FromName "ftrl_update"
        let names = [|"lr"; "lamda1"; "beta"; "wd"; "rescale_grad"; "clip_gradient"|]
        let vals = [|string lr; string lamda1; string beta; string wd; string rescaleGrad; string clipGradient|]
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg weight)) then weight.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg grad)) then grad.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg z)) then z.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg n)) then n.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <summary>Update function for Ftrl optimizer.
    /// Referenced from *Ad Click Prediction: a View from the Trenches*, available at
    /// http://dl.acm.org/citation.cfm?id=2488200.
    /// 
    /// It updates the weights using::
    /// 
    ///  rescaled_grad = clip(grad * rescale_grad, clip_gradient)
    ///  z += rescaled_grad - (sqrt(n + rescaled_grad**2) - sqrt(n)) * weight / learning_rate
    ///  n += rescaled_grad**2
    ///  w = (sign(z) * lamda1 - z) / ((beta + sqrt(n)) / learning_rate + wd) * (abs(z) &gt; lamda1)
    /// 
    /// If w, z and n are all of ``row_sparse`` storage type,
    /// only the row slices whose indices appear in grad.indices are updated (for w, z and n)::
    /// 
    ///  for row in grad.indices:
    ///      rescaled_grad[row] = clip(grad[row] * rescale_grad, clip_gradient)
    ///      z[row] += rescaled_grad[row] - (sqrt(n[row] + rescaled_grad[row]**2) - sqrt(n[row])) * weight[row] / learning_rate
    ///      n[row] += rescaled_grad[row]**2
    ///      w[row] = (sign(z[row]) * lamda1 - z[row]) / ((beta + sqrt(n[row])) / learning_rate + wd) * (abs(z[row]) &gt; lamda1)
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\optimizer_op.cc:L876</summary>
    /// <param name="weight">Weight</param>
    /// <param name="grad">Gradient</param>
    /// <param name="z">z</param>
    /// <param name="n">Square of grad</param>
    /// <param name="lr">Learning rate</param>
    /// <param name="lamda1">The L1 regularization coefficient.</param>
    /// <param name="beta">Per-Coordinate Learning Rate beta.</param>
    /// <param name="wd">Weight decay augments the objective function with a regularization term that penalizes large weights. The penalty scales with the square of the magnitude of each weight.</param>
    /// <param name="rescaleGrad">Rescale gradient to grad = rescale_grad*grad.</param>
    /// <param name="clipGradient">Clip gradient to the range of [-clip_gradient, clip_gradient] If clip_gradient &lt;= 0, gradient clipping is turned off. grad = max(min(grad, clip_gradient), -clip_gradient).</param>
    static member FtrlUpdate(weight : Symbol, grad : Symbol, z : Symbol, n : Symbol, lr : float, [<Optional>] ?lamda1 : float, [<Optional>] ?beta : float, [<Optional>] ?wd : float, [<Optional>] ?rescaleGrad : float, [<Optional>] ?clipGradient : float) =
        FtrlUpdate(weight, grad, z, n, lr, ?lamda1 = lamda1, ?beta = beta, ?wd = wd, ?rescaleGrad = rescaleGrad, ?clipGradient = clipGradient)
    /// <summary>Update function for Ftrl optimizer.
    /// Referenced from *Ad Click Prediction: a View from the Trenches*, available at
    /// http://dl.acm.org/citation.cfm?id=2488200.
    /// 
    /// It updates the weights using::
    /// 
    ///  rescaled_grad = clip(grad * rescale_grad, clip_gradient)
    ///  z += rescaled_grad - (sqrt(n + rescaled_grad**2) - sqrt(n)) * weight / learning_rate
    ///  n += rescaled_grad**2
    ///  w = (sign(z) * lamda1 - z) / ((beta + sqrt(n)) / learning_rate + wd) * (abs(z) &gt; lamda1)
    /// 
    /// If w, z and n are all of ``row_sparse`` storage type,
    /// only the row slices whose indices appear in grad.indices are updated (for w, z and n)::
    /// 
    ///  for row in grad.indices:
    ///      rescaled_grad[row] = clip(grad[row] * rescale_grad, clip_gradient)
    ///      z[row] += rescaled_grad[row] - (sqrt(n[row] + rescaled_grad[row]**2) - sqrt(n[row])) * weight[row] / learning_rate
    ///      n[row] += rescaled_grad[row]**2
    ///      w[row] = (sign(z[row]) * lamda1 - z[row]) / ((beta + sqrt(n[row])) / learning_rate + wd) * (abs(z[row]) &gt; lamda1)
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\optimizer_op.cc:L876</summary>
    /// <param name="lr">Learning rate</param>
    /// <param name="weight">Weight</param>
    /// <param name="grad">Gradient</param>
    /// <param name="z">z</param>
    /// <param name="n">Square of grad</param>
    /// <param name="lamda1">The L1 regularization coefficient.</param>
    /// <param name="beta">Per-Coordinate Learning Rate beta.</param>
    /// <param name="wd">Weight decay augments the objective function with a regularization term that penalizes large weights. The penalty scales with the square of the magnitude of each weight.</param>
    /// <param name="rescaleGrad">Rescale gradient to grad = rescale_grad*grad.</param>
    /// <param name="clipGradient">Clip gradient to the range of [-clip_gradient, clip_gradient] If clip_gradient &lt;= 0, gradient clipping is turned off. grad = max(min(grad, clip_gradient), -clip_gradient).</param>
    static member FtrlUpdate(lr : float, [<Optional>] ?weight : Symbol, [<Optional>] ?grad : Symbol, [<Optional>] ?z : Symbol, [<Optional>] ?n : Symbol, [<Optional>] ?lamda1 : float, [<Optional>] ?beta : float, [<Optional>] ?wd : float, [<Optional>] ?rescaleGrad : float, [<Optional>] ?clipGradient : float) =
        FtrlUpdate(lr, ?weight = weight, ?grad = grad, ?z = z, ?n = n, ?lamda1 = lamda1, ?beta = beta, ?wd = wd, ?rescaleGrad = rescaleGrad, ?clipGradient = clipGradient)

    /// <summary>Update function for AdaGrad optimizer.
    /// 
    /// Referenced from *Adaptive Subgradient Methods for Online Learning and Stochastic Optimization*,
    /// and available at http://www.jmlr.org/papers/volume12/duchi11a/duchi11a.pdf.
    /// 
    /// Updates are applied by::
    /// 
    ///     rescaled_grad = clip(grad * rescale_grad, clip_gradient)
    ///     history = history + square(rescaled_grad)
    ///     w = w - learning_rate * rescaled_grad / sqrt(history + epsilon)
    /// 
    /// Note that non-zero values for the weight decay option are not supported.
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\optimizer_op.cc:L909</summary>
    /// <param name="weight">Weight</param>
    /// <param name="grad">Gradient</param>
    /// <param name="history">History</param>
    /// <param name="lr">Learning rate</param>
    /// <param name="epsilon">epsilon</param>
    /// <param name="wd">weight decay</param>
    /// <param name="rescaleGrad">Rescale gradient to grad = rescale_grad*grad.</param>
    /// <param name="clipGradient">Clip gradient to the range of [-clip_gradient, clip_gradient] If clip_gradient &lt;= 0, gradient clipping is turned off. grad = max(min(grad, clip_gradient), -clip_gradient).</param>
    static member SparseAdagradUpdate(weight : NDArray, 
                                      grad : NDArray, 
                                      history : NDArray, 
                                      lr : float, 
                                      [<Optional; DefaultParameterValue(1.00000001E-07)>] epsilon : float, 
                                      [<Optional; DefaultParameterValue(0.0)>] wd : float, 
                                      [<Optional; DefaultParameterValue(1.0)>] rescaleGrad : float, 
                                      [<Optional; DefaultParameterValue(-1.0)>] clipGradient : float) =
        let creator = AtomicSymbolCreator.FromName "_sparse_adagrad_update"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg weight)) then weight.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg grad)) then grad.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg history)) then history.UnsafeHandle|]
                                                 [|"lr"; "epsilon"; "wd"; "rescale_grad"; "clip_gradient"|]
                                                 [|string lr; string epsilon; string wd; string rescaleGrad; string clipGradient|]
        (new NDArray(outputs.[0]))
    /// <summary>Update function for AdaGrad optimizer.
    /// 
    /// Referenced from *Adaptive Subgradient Methods for Online Learning and Stochastic Optimization*,
    /// and available at http://www.jmlr.org/papers/volume12/duchi11a/duchi11a.pdf.
    /// 
    /// Updates are applied by::
    /// 
    ///     rescaled_grad = clip(grad * rescale_grad, clip_gradient)
    ///     history = history + square(rescaled_grad)
    ///     w = w - learning_rate * rescaled_grad / sqrt(history + epsilon)
    /// 
    /// Note that non-zero values for the weight decay option are not supported.
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\optimizer_op.cc:L909</summary>
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="weight">Weight</param>
    /// <param name="grad">Gradient</param>
    /// <param name="history">History</param>
    /// <param name="lr">Learning rate</param>
    /// <param name="epsilon">epsilon</param>
    /// <param name="wd">weight decay</param>
    /// <param name="rescaleGrad">Rescale gradient to grad = rescale_grad*grad.</param>
    /// <param name="clipGradient">Clip gradient to the range of [-clip_gradient, clip_gradient] If clip_gradient &lt;= 0, gradient clipping is turned off. grad = max(min(grad, clip_gradient), -clip_gradient).</param>
    static member SparseAdagradUpdate(outputArray : NDArray seq, 
                                      weight : NDArray, 
                                      grad : NDArray, 
                                      history : NDArray, 
                                      lr : float, 
                                      [<Optional; DefaultParameterValue(1.00000001E-07)>] epsilon : float, 
                                      [<Optional; DefaultParameterValue(0.0)>] wd : float, 
                                      [<Optional; DefaultParameterValue(1.0)>] rescaleGrad : float, 
                                      [<Optional; DefaultParameterValue(-1.0)>] clipGradient : float) =
        let creator = AtomicSymbolCreator.FromName "_sparse_adagrad_update"
        let names = [|"lr"; "epsilon"; "wd"; "rescale_grad"; "clip_gradient"|]
        let vals = [|string lr; string epsilon; string wd; string rescaleGrad; string clipGradient|]
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg weight)) then weight.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg grad)) then grad.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg history)) then history.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <summary>Update function for AdaGrad optimizer.
    /// 
    /// Referenced from *Adaptive Subgradient Methods for Online Learning and Stochastic Optimization*,
    /// and available at http://www.jmlr.org/papers/volume12/duchi11a/duchi11a.pdf.
    /// 
    /// Updates are applied by::
    /// 
    ///     rescaled_grad = clip(grad * rescale_grad, clip_gradient)
    ///     history = history + square(rescaled_grad)
    ///     w = w - learning_rate * rescaled_grad / sqrt(history + epsilon)
    /// 
    /// Note that non-zero values for the weight decay option are not supported.
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\optimizer_op.cc:L909</summary>
    /// <param name="weight">Weight</param>
    /// <param name="grad">Gradient</param>
    /// <param name="history">History</param>
    /// <param name="lr">Learning rate</param>
    /// <param name="epsilon">epsilon</param>
    /// <param name="wd">weight decay</param>
    /// <param name="rescaleGrad">Rescale gradient to grad = rescale_grad*grad.</param>
    /// <param name="clipGradient">Clip gradient to the range of [-clip_gradient, clip_gradient] If clip_gradient &lt;= 0, gradient clipping is turned off. grad = max(min(grad, clip_gradient), -clip_gradient).</param>
    static member SparseAdagradUpdate(weight : Symbol, grad : Symbol, history : Symbol, lr : float, [<Optional>] ?epsilon : float, [<Optional>] ?wd : float, [<Optional>] ?rescaleGrad : float, [<Optional>] ?clipGradient : float) =
        SparseAdagradUpdate(weight, grad, history, lr, ?epsilon = epsilon, ?wd = wd, ?rescaleGrad = rescaleGrad, ?clipGradient = clipGradient)
    /// <summary>Update function for AdaGrad optimizer.
    /// 
    /// Referenced from *Adaptive Subgradient Methods for Online Learning and Stochastic Optimization*,
    /// and available at http://www.jmlr.org/papers/volume12/duchi11a/duchi11a.pdf.
    /// 
    /// Updates are applied by::
    /// 
    ///     rescaled_grad = clip(grad * rescale_grad, clip_gradient)
    ///     history = history + square(rescaled_grad)
    ///     w = w - learning_rate * rescaled_grad / sqrt(history + epsilon)
    /// 
    /// Note that non-zero values for the weight decay option are not supported.
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\optimizer_op.cc:L909</summary>
    /// <param name="lr">Learning rate</param>
    /// <param name="weight">Weight</param>
    /// <param name="grad">Gradient</param>
    /// <param name="history">History</param>
    /// <param name="epsilon">epsilon</param>
    /// <param name="wd">weight decay</param>
    /// <param name="rescaleGrad">Rescale gradient to grad = rescale_grad*grad.</param>
    /// <param name="clipGradient">Clip gradient to the range of [-clip_gradient, clip_gradient] If clip_gradient &lt;= 0, gradient clipping is turned off. grad = max(min(grad, clip_gradient), -clip_gradient).</param>
    static member SparseAdagradUpdate(lr : float, [<Optional>] ?weight : Symbol, [<Optional>] ?grad : Symbol, [<Optional>] ?history : Symbol, [<Optional>] ?epsilon : float, [<Optional>] ?wd : float, [<Optional>] ?rescaleGrad : float, [<Optional>] ?clipGradient : float) =
        SparseAdagradUpdate(lr, ?weight = weight, ?grad = grad, ?history = history, ?epsilon = epsilon, ?wd = wd, ?rescaleGrad = rescaleGrad, ?clipGradient = clipGradient)

    /// <summary>Phase I of lamb update it performs the following operations and returns g:.
    /// 
    /// Link to paper: https://arxiv.org/pdf/1904.00962.pdf
    /// 
    /// .. math::
    ///     \begin{gather*}
    ///     grad = grad * rescale_grad
    ///     if (grad &lt; -clip_gradient)
    ///     then
    ///          grad = -clip_gradient
    ///     if (grad &gt; clip_gradient)
    ///     then
    ///          grad = clip_gradient
    /// 
    ///     mean = beta1 * mean + (1 - beta1) * grad;
    ///     variance = beta2 * variance + (1. - beta2) * grad ^ 2;
    /// 
    ///     if (bias_correction)
    ///     then
    ///          mean_hat = mean / (1. - beta1^t);
    ///          var_hat = var / (1 - beta2^t);
    ///          g = mean_hat / (var_hat^(1/2) + epsilon) + wd * weight;
    ///     else
    ///          g = mean / (var_data^(1/2) + epsilon) + wd * weight_data[i];
    ///     \end{gather*}
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\optimizer_op.cc:L953</summary>
    /// <param name="weight">Weight</param>
    /// <param name="grad">Gradient</param>
    /// <param name="mean">Moving mean</param>
    /// <param name="var">Moving variance</param>
    /// <param name="t">Index update count.</param>
    /// <param name="wd">Weight decay augments the objective function with a regularization term that penalizes large weights. The penalty scales with the square of the magnitude of each weight.</param>
    /// <param name="beta1">The decay rate for the 1st moment estimates.</param>
    /// <param name="beta2">The decay rate for the 2nd moment estimates.</param>
    /// <param name="epsilon">A small constant for numerical stability.</param>
    /// <param name="biasCorrection">Whether to use bias correction.</param>
    /// <param name="rescaleGrad">Rescale gradient to grad = rescale_grad*grad.</param>
    /// <param name="clipGradient">Clip gradient to the range of [-clip_gradient, clip_gradient] If clip_gradient &lt;= 0, gradient clipping is turned off. grad = max(min(grad, clip_gradient), -clip_gradient).</param>
    static member LambUpdatePhase1(weight : NDArray, 
                                   grad : NDArray, 
                                   mean : NDArray, 
                                   var : NDArray, 
                                   t : float, 
                                   wd : float, 
                                   [<Optional; DefaultParameterValue(0.899999976)>] beta1 : float, 
                                   [<Optional; DefaultParameterValue(0.999000013)>] beta2 : float, 
                                   [<Optional; DefaultParameterValue(9.99999997E-07)>] epsilon : float, 
                                   [<Optional; DefaultParameterValue(true)>] biasCorrection : bool, 
                                   [<Optional; DefaultParameterValue(1.0)>] rescaleGrad : float, 
                                   [<Optional; DefaultParameterValue(-1.0)>] clipGradient : float) =
        let creator = AtomicSymbolCreator.FromName "lamb_update_phase1"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg weight)) then weight.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg grad)) then grad.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg mean)) then mean.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg var)) then var.UnsafeHandle|]
                                                 [|"t"; "wd"; "beta1"; "beta2"; "epsilon"; "bias_correction"; "rescale_grad"; "clip_gradient"|]
                                                 [|string t; string wd; string beta1; string beta2; string epsilon; string biasCorrection; string rescaleGrad; string clipGradient|]
        outputs |> Array.map (fun h -> new NDArray(h))
    /// <summary>Phase I of lamb update it performs the following operations and returns g:.
    /// 
    /// Link to paper: https://arxiv.org/pdf/1904.00962.pdf
    /// 
    /// .. math::
    ///     \begin{gather*}
    ///     grad = grad * rescale_grad
    ///     if (grad &lt; -clip_gradient)
    ///     then
    ///          grad = -clip_gradient
    ///     if (grad &gt; clip_gradient)
    ///     then
    ///          grad = clip_gradient
    /// 
    ///     mean = beta1 * mean + (1 - beta1) * grad;
    ///     variance = beta2 * variance + (1. - beta2) * grad ^ 2;
    /// 
    ///     if (bias_correction)
    ///     then
    ///          mean_hat = mean / (1. - beta1^t);
    ///          var_hat = var / (1 - beta2^t);
    ///          g = mean_hat / (var_hat^(1/2) + epsilon) + wd * weight;
    ///     else
    ///          g = mean / (var_data^(1/2) + epsilon) + wd * weight_data[i];
    ///     \end{gather*}
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\optimizer_op.cc:L953</summary>
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="weight">Weight</param>
    /// <param name="grad">Gradient</param>
    /// <param name="mean">Moving mean</param>
    /// <param name="var">Moving variance</param>
    /// <param name="t">Index update count.</param>
    /// <param name="wd">Weight decay augments the objective function with a regularization term that penalizes large weights. The penalty scales with the square of the magnitude of each weight.</param>
    /// <param name="beta1">The decay rate for the 1st moment estimates.</param>
    /// <param name="beta2">The decay rate for the 2nd moment estimates.</param>
    /// <param name="epsilon">A small constant for numerical stability.</param>
    /// <param name="biasCorrection">Whether to use bias correction.</param>
    /// <param name="rescaleGrad">Rescale gradient to grad = rescale_grad*grad.</param>
    /// <param name="clipGradient">Clip gradient to the range of [-clip_gradient, clip_gradient] If clip_gradient &lt;= 0, gradient clipping is turned off. grad = max(min(grad, clip_gradient), -clip_gradient).</param>
    static member LambUpdatePhase1(outputArray : NDArray seq, 
                                   weight : NDArray, 
                                   grad : NDArray, 
                                   mean : NDArray, 
                                   var : NDArray, 
                                   t : float, 
                                   wd : float, 
                                   [<Optional; DefaultParameterValue(0.899999976)>] beta1 : float, 
                                   [<Optional; DefaultParameterValue(0.999000013)>] beta2 : float, 
                                   [<Optional; DefaultParameterValue(9.99999997E-07)>] epsilon : float, 
                                   [<Optional; DefaultParameterValue(true)>] biasCorrection : bool, 
                                   [<Optional; DefaultParameterValue(1.0)>] rescaleGrad : float, 
                                   [<Optional; DefaultParameterValue(-1.0)>] clipGradient : float) =
        let creator = AtomicSymbolCreator.FromName "lamb_update_phase1"
        let names = [|"t"; "wd"; "beta1"; "beta2"; "epsilon"; "bias_correction"; "rescale_grad"; "clip_gradient"|]
        let vals = [|string t; string wd; string beta1; string beta2; string epsilon; string biasCorrection; string rescaleGrad; string clipGradient|]
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg weight)) then weight.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg grad)) then grad.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg mean)) then mean.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg var)) then var.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <summary>Phase I of lamb update it performs the following operations and returns g:.
    /// 
    /// Link to paper: https://arxiv.org/pdf/1904.00962.pdf
    /// 
    /// .. math::
    ///     \begin{gather*}
    ///     grad = grad * rescale_grad
    ///     if (grad &lt; -clip_gradient)
    ///     then
    ///          grad = -clip_gradient
    ///     if (grad &gt; clip_gradient)
    ///     then
    ///          grad = clip_gradient
    /// 
    ///     mean = beta1 * mean + (1 - beta1) * grad;
    ///     variance = beta2 * variance + (1. - beta2) * grad ^ 2;
    /// 
    ///     if (bias_correction)
    ///     then
    ///          mean_hat = mean / (1. - beta1^t);
    ///          var_hat = var / (1 - beta2^t);
    ///          g = mean_hat / (var_hat^(1/2) + epsilon) + wd * weight;
    ///     else
    ///          g = mean / (var_data^(1/2) + epsilon) + wd * weight_data[i];
    ///     \end{gather*}
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\optimizer_op.cc:L953</summary>
    /// <param name="weight">Weight</param>
    /// <param name="grad">Gradient</param>
    /// <param name="mean">Moving mean</param>
    /// <param name="var">Moving variance</param>
    /// <param name="t">Index update count.</param>
    /// <param name="wd">Weight decay augments the objective function with a regularization term that penalizes large weights. The penalty scales with the square of the magnitude of each weight.</param>
    /// <param name="beta1">The decay rate for the 1st moment estimates.</param>
    /// <param name="beta2">The decay rate for the 2nd moment estimates.</param>
    /// <param name="epsilon">A small constant for numerical stability.</param>
    /// <param name="biasCorrection">Whether to use bias correction.</param>
    /// <param name="rescaleGrad">Rescale gradient to grad = rescale_grad*grad.</param>
    /// <param name="clipGradient">Clip gradient to the range of [-clip_gradient, clip_gradient] If clip_gradient &lt;= 0, gradient clipping is turned off. grad = max(min(grad, clip_gradient), -clip_gradient).</param>
    static member LambUpdatePhase1(weight : Symbol, grad : Symbol, mean : Symbol, var : Symbol, t : float, wd : float, [<Optional>] ?beta1 : float, [<Optional>] ?beta2 : float, [<Optional>] ?epsilon : float, [<Optional>] ?biasCorrection : bool, [<Optional>] ?rescaleGrad : float, [<Optional>] ?clipGradient : float) =
        LambUpdatePhase1(weight, grad, mean, var, t, wd, ?beta1 = beta1, ?beta2 = beta2, ?epsilon = epsilon, ?biasCorrection = biasCorrection, ?rescaleGrad = rescaleGrad, ?clipGradient = clipGradient)
    /// <summary>Phase I of lamb update it performs the following operations and returns g:.
    /// 
    /// Link to paper: https://arxiv.org/pdf/1904.00962.pdf
    /// 
    /// .. math::
    ///     \begin{gather*}
    ///     grad = grad * rescale_grad
    ///     if (grad &lt; -clip_gradient)
    ///     then
    ///          grad = -clip_gradient
    ///     if (grad &gt; clip_gradient)
    ///     then
    ///          grad = clip_gradient
    /// 
    ///     mean = beta1 * mean + (1 - beta1) * grad;
    ///     variance = beta2 * variance + (1. - beta2) * grad ^ 2;
    /// 
    ///     if (bias_correction)
    ///     then
    ///          mean_hat = mean / (1. - beta1^t);
    ///          var_hat = var / (1 - beta2^t);
    ///          g = mean_hat / (var_hat^(1/2) + epsilon) + wd * weight;
    ///     else
    ///          g = mean / (var_data^(1/2) + epsilon) + wd * weight_data[i];
    ///     \end{gather*}
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\optimizer_op.cc:L953</summary>
    /// <param name="t">Index update count.</param>
    /// <param name="wd">Weight decay augments the objective function with a regularization term that penalizes large weights. The penalty scales with the square of the magnitude of each weight.</param>
    /// <param name="weight">Weight</param>
    /// <param name="grad">Gradient</param>
    /// <param name="mean">Moving mean</param>
    /// <param name="var">Moving variance</param>
    /// <param name="beta1">The decay rate for the 1st moment estimates.</param>
    /// <param name="beta2">The decay rate for the 2nd moment estimates.</param>
    /// <param name="epsilon">A small constant for numerical stability.</param>
    /// <param name="biasCorrection">Whether to use bias correction.</param>
    /// <param name="rescaleGrad">Rescale gradient to grad = rescale_grad*grad.</param>
    /// <param name="clipGradient">Clip gradient to the range of [-clip_gradient, clip_gradient] If clip_gradient &lt;= 0, gradient clipping is turned off. grad = max(min(grad, clip_gradient), -clip_gradient).</param>
    static member LambUpdatePhase1(t : float, wd : float, [<Optional>] ?weight : Symbol, [<Optional>] ?grad : Symbol, [<Optional>] ?mean : Symbol, [<Optional>] ?var : Symbol, [<Optional>] ?beta1 : float, [<Optional>] ?beta2 : float, [<Optional>] ?epsilon : float, [<Optional>] ?biasCorrection : bool, [<Optional>] ?rescaleGrad : float, [<Optional>] ?clipGradient : float) =
        LambUpdatePhase1(t, wd, ?weight = weight, ?grad = grad, ?mean = mean, ?var = var, ?beta1 = beta1, ?beta2 = beta2, ?epsilon = epsilon, ?biasCorrection = biasCorrection, ?rescaleGrad = rescaleGrad, ?clipGradient = clipGradient)

    /// <summary>Phase II of lamb update it performs the following operations and updates grad.
    /// 
    /// Link to paper: https://arxiv.org/pdf/1904.00962.pdf
    /// 
    /// .. math::
    ///     \begin{gather*}
    ///     if (lower_bound &gt;= 0)
    ///     then
    ///          r1 = max(r1, lower_bound)
    ///     if (upper_bound &gt;= 0)
    ///     then
    ///          r1 = max(r1, upper_bound)
    /// 
    ///     if (r1 == 0 or r2 == 0)
    ///     then
    ///          lr = lr
    ///     else
    ///          lr = lr * (r1/r2)
    ///     weight = weight - lr * g
    ///     \end{gather*}
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\optimizer_op.cc:L992</summary>
    /// <param name="weight">Weight</param>
    /// <param name="g">Output of lamb_update_phase 1</param>
    /// <param name="r1">r1</param>
    /// <param name="r2">r2</param>
    /// <param name="lr">Learning rate</param>
    /// <param name="lowerBound">Lower limit of norm of weight. If lower_bound &lt;= 0, Lower limit is not set</param>
    /// <param name="upperBound">Upper limit of norm of weight. If upper_bound &lt;= 0, Upper limit is not set</param>
    static member LambUpdatePhase2(weight : NDArray, 
                                   g : NDArray, 
                                   r1 : NDArray, 
                                   r2 : NDArray, 
                                   lr : float, 
                                   [<Optional; DefaultParameterValue(-1.0)>] lowerBound : float, 
                                   [<Optional; DefaultParameterValue(-1.0)>] upperBound : float) =
        let creator = AtomicSymbolCreator.FromName "lamb_update_phase2"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg weight)) then weight.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg g)) then g.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg r1)) then r1.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg r2)) then r2.UnsafeHandle|]
                                                 [|"lr"; "lower_bound"; "upper_bound"|]
                                                 [|string lr; string lowerBound; string upperBound|]
        outputs |> Array.map (fun h -> new NDArray(h))
    /// <summary>Phase II of lamb update it performs the following operations and updates grad.
    /// 
    /// Link to paper: https://arxiv.org/pdf/1904.00962.pdf
    /// 
    /// .. math::
    ///     \begin{gather*}
    ///     if (lower_bound &gt;= 0)
    ///     then
    ///          r1 = max(r1, lower_bound)
    ///     if (upper_bound &gt;= 0)
    ///     then
    ///          r1 = max(r1, upper_bound)
    /// 
    ///     if (r1 == 0 or r2 == 0)
    ///     then
    ///          lr = lr
    ///     else
    ///          lr = lr * (r1/r2)
    ///     weight = weight - lr * g
    ///     \end{gather*}
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\optimizer_op.cc:L992</summary>
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="weight">Weight</param>
    /// <param name="g">Output of lamb_update_phase 1</param>
    /// <param name="r1">r1</param>
    /// <param name="r2">r2</param>
    /// <param name="lr">Learning rate</param>
    /// <param name="lowerBound">Lower limit of norm of weight. If lower_bound &lt;= 0, Lower limit is not set</param>
    /// <param name="upperBound">Upper limit of norm of weight. If upper_bound &lt;= 0, Upper limit is not set</param>
    static member LambUpdatePhase2(outputArray : NDArray seq, 
                                   weight : NDArray, 
                                   g : NDArray, 
                                   r1 : NDArray, 
                                   r2 : NDArray, 
                                   lr : float, 
                                   [<Optional; DefaultParameterValue(-1.0)>] lowerBound : float, 
                                   [<Optional; DefaultParameterValue(-1.0)>] upperBound : float) =
        let creator = AtomicSymbolCreator.FromName "lamb_update_phase2"
        let names = [|"lr"; "lower_bound"; "upper_bound"|]
        let vals = [|string lr; string lowerBound; string upperBound|]
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg weight)) then weight.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg g)) then g.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg r1)) then r1.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg r2)) then r2.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <summary>Phase II of lamb update it performs the following operations and updates grad.
    /// 
    /// Link to paper: https://arxiv.org/pdf/1904.00962.pdf
    /// 
    /// .. math::
    ///     \begin{gather*}
    ///     if (lower_bound &gt;= 0)
    ///     then
    ///          r1 = max(r1, lower_bound)
    ///     if (upper_bound &gt;= 0)
    ///     then
    ///          r1 = max(r1, upper_bound)
    /// 
    ///     if (r1 == 0 or r2 == 0)
    ///     then
    ///          lr = lr
    ///     else
    ///          lr = lr * (r1/r2)
    ///     weight = weight - lr * g
    ///     \end{gather*}
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\optimizer_op.cc:L992</summary>
    /// <param name="weight">Weight</param>
    /// <param name="g">Output of lamb_update_phase 1</param>
    /// <param name="r1">r1</param>
    /// <param name="r2">r2</param>
    /// <param name="lr">Learning rate</param>
    /// <param name="lowerBound">Lower limit of norm of weight. If lower_bound &lt;= 0, Lower limit is not set</param>
    /// <param name="upperBound">Upper limit of norm of weight. If upper_bound &lt;= 0, Upper limit is not set</param>
    static member LambUpdatePhase2(weight : Symbol, g : Symbol, r1 : Symbol, r2 : Symbol, lr : float, [<Optional>] ?lowerBound : float, [<Optional>] ?upperBound : float) =
        LambUpdatePhase2(weight, g, r1, r2, lr, ?lowerBound = lowerBound, ?upperBound = upperBound)
    /// <summary>Phase II of lamb update it performs the following operations and updates grad.
    /// 
    /// Link to paper: https://arxiv.org/pdf/1904.00962.pdf
    /// 
    /// .. math::
    ///     \begin{gather*}
    ///     if (lower_bound &gt;= 0)
    ///     then
    ///          r1 = max(r1, lower_bound)
    ///     if (upper_bound &gt;= 0)
    ///     then
    ///          r1 = max(r1, upper_bound)
    /// 
    ///     if (r1 == 0 or r2 == 0)
    ///     then
    ///          lr = lr
    ///     else
    ///          lr = lr * (r1/r2)
    ///     weight = weight - lr * g
    ///     \end{gather*}
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\optimizer_op.cc:L992</summary>
    /// <param name="lr">Learning rate</param>
    /// <param name="weight">Weight</param>
    /// <param name="g">Output of lamb_update_phase 1</param>
    /// <param name="r1">r1</param>
    /// <param name="r2">r2</param>
    /// <param name="lowerBound">Lower limit of norm of weight. If lower_bound &lt;= 0, Lower limit is not set</param>
    /// <param name="upperBound">Upper limit of norm of weight. If upper_bound &lt;= 0, Upper limit is not set</param>
    static member LambUpdatePhase2(lr : float, [<Optional>] ?weight : Symbol, [<Optional>] ?g : Symbol, [<Optional>] ?r1 : Symbol, [<Optional>] ?r2 : Symbol, [<Optional>] ?lowerBound : float, [<Optional>] ?upperBound : float) =
        LambUpdatePhase2(lr, ?weight = weight, ?g = g, ?r1 = r1, ?r2 = r2, ?lowerBound = lowerBound, ?upperBound = upperBound)

    /// <summary>Pads an input array with a constant or edge values of the array.
    /// 
    /// .. note:: `Pad` is deprecated. Use `pad` instead.
    /// 
    /// .. note:: Current implementation only supports 4D and 5D input arrays with padding applied
    ///    only on axes 1, 2 and 3. Expects axes 4 and 5 in `pad_width` to be zero.
    /// 
    /// This operation pads an input array with either a `constant_value` or edge values
    /// along each axis of the input array. The amount of padding is specified by `pad_width`.
    /// 
    /// `pad_width` is a tuple of integer padding widths for each axis of the format
    /// ``(before_1, after_1, ... , before_N, after_N)``. The `pad_width` should be of length ``2*N``
    /// where ``N`` is the number of dimensions of the array.
    /// 
    /// For dimension ``N`` of the input array, ``before_N`` and ``after_N`` indicates how many values
    /// to add before and after the elements of the array along dimension ``N``.
    /// The widths of the higher two dimensions ``before_1``, ``after_1``, ``before_2``,
    /// ``after_2`` must be 0.
    /// 
    /// Example::
    /// 
    ///    x = [[[[  1.   2.   3.]
    ///           [  4.   5.   6.]]
    /// 
    ///          [[  7.   8.   9.]
    ///           [ 10.  11.  12.]]]
    /// 
    /// 
    ///         [[[ 11.  12.  13.]
    ///           [ 14.  15.  16.]]
    /// 
    ///          [[ 17.  18.  19.]
    ///           [ 20.  21.  22.]]]]
    /// 
    ///    pad(x,mode=&quot;edge&quot;, pad_width=(0,0,0,0,1,1,1,1)) =
    /// 
    ///          [[[[  1.   1.   2.   3.   3.]
    ///             [  1.   1.   2.   3.   3.]
    ///             [  4.   4.   5.   6.   6.]
    ///             [  4.   4.   5.   6.   6.]]
    /// 
    ///            [[  7.   7.   8.   9.   9.]
    ///             [  7.   7.   8.   9.   9.]
    ///             [ 10.  10.  11.  12.  12.]
    ///             [ 10.  10.  11.  12.  12.]]]
    /// 
    /// 
    ///           [[[ 11.  11.  12.  13.  13.]
    ///             [ 11.  11.  12.  13.  13.]
    ///             [ 14.  14.  15.  16.  16.]
    ///             [ 14.  14.  15.  16.  16.]]
    /// 
    ///            [[ 17.  17.  18.  19.  19.]
    ///             [ 17.  17.  18.  19.  19.]
    ///             [ 20.  20.  21.  22.  22.]
    ///             [ 20.  20.  21.  22.  22.]]]]
    /// 
    ///    pad(x, mode=&quot;constant&quot;, constant_value=0, pad_width=(0,0,0,0,1,1,1,1)) =
    /// 
    ///          [[[[  0.   0.   0.   0.   0.]
    ///             [  0.   1.   2.   3.   0.]
    ///             [  0.   4.   5.   6.   0.]
    ///             [  0.   0.   0.   0.   0.]]
    /// 
    ///            [[  0.   0.   0.   0.   0.]
    ///             [  0.   7.   8.   9.   0.]
    ///             [  0.  10.  11.  12.   0.]
    ///             [  0.   0.   0.   0.   0.]]]
    /// 
    /// 
    ///           [[[  0.   0.   0.   0.   0.]
    ///             [  0.  11.  12.  13.   0.]
    ///             [  0.  14.  15.  16.   0.]
    ///             [  0.   0.   0.   0.   0.]]
    /// 
    ///            [[  0.   0.   0.   0.   0.]
    ///             [  0.  17.  18.  19.   0.]
    ///             [  0.  20.  21.  22.   0.]
    ///             [  0.   0.   0.   0.   0.]]]]
    /// 
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\pad.cc:L766</summary>
    /// <param name="data">An n-dimensional input array.</param>
    /// <param name="mode">Padding type to use. &quot;constant&quot; pads with `constant_value` &quot;edge&quot; pads using the edge values of the input array &quot;reflect&quot; pads by reflecting values with respect to the edges.</param>
    /// <param name="padWidth">Widths of the padding regions applied to the edges of each axis. It is a tuple of integer padding widths for each axis of the format ``(before_1, after_1, ... , before_N, after_N)``. It should be of length ``2*N`` where ``N`` is the number of dimensions of the array.This is equivalent to pad_width in numpy.pad, but flattened.</param>
    /// <param name="constantValue">The value used for padding when `mode` is &quot;constant&quot;.</param>
    static member Pad(data : NDArray, mode : PadMode, padWidth : int seq, [<Optional; DefaultParameterValue(0.0)>] constantValue : double) =
        let creator = AtomicSymbolCreator.FromName "Pad"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle|]
                                                 [|"mode"; "pad_width"; "constant_value"|]
                                                 [|string mode; (padWidth |> Seq.map string |> String.concat ", " |> sprintf "[%s]"); string constantValue|]
        outputs |> Array.map (fun h -> new NDArray(h))
    /// <summary>Pads an input array with a constant or edge values of the array.
    /// 
    /// .. note:: `Pad` is deprecated. Use `pad` instead.
    /// 
    /// .. note:: Current implementation only supports 4D and 5D input arrays with padding applied
    ///    only on axes 1, 2 and 3. Expects axes 4 and 5 in `pad_width` to be zero.
    /// 
    /// This operation pads an input array with either a `constant_value` or edge values
    /// along each axis of the input array. The amount of padding is specified by `pad_width`.
    /// 
    /// `pad_width` is a tuple of integer padding widths for each axis of the format
    /// ``(before_1, after_1, ... , before_N, after_N)``. The `pad_width` should be of length ``2*N``
    /// where ``N`` is the number of dimensions of the array.
    /// 
    /// For dimension ``N`` of the input array, ``before_N`` and ``after_N`` indicates how many values
    /// to add before and after the elements of the array along dimension ``N``.
    /// The widths of the higher two dimensions ``before_1``, ``after_1``, ``before_2``,
    /// ``after_2`` must be 0.
    /// 
    /// Example::
    /// 
    ///    x = [[[[  1.   2.   3.]
    ///           [  4.   5.   6.]]
    /// 
    ///          [[  7.   8.   9.]
    ///           [ 10.  11.  12.]]]
    /// 
    /// 
    ///         [[[ 11.  12.  13.]
    ///           [ 14.  15.  16.]]
    /// 
    ///          [[ 17.  18.  19.]
    ///           [ 20.  21.  22.]]]]
    /// 
    ///    pad(x,mode=&quot;edge&quot;, pad_width=(0,0,0,0,1,1,1,1)) =
    /// 
    ///          [[[[  1.   1.   2.   3.   3.]
    ///             [  1.   1.   2.   3.   3.]
    ///             [  4.   4.   5.   6.   6.]
    ///             [  4.   4.   5.   6.   6.]]
    /// 
    ///            [[  7.   7.   8.   9.   9.]
    ///             [  7.   7.   8.   9.   9.]
    ///             [ 10.  10.  11.  12.  12.]
    ///             [ 10.  10.  11.  12.  12.]]]
    /// 
    /// 
    ///           [[[ 11.  11.  12.  13.  13.]
    ///             [ 11.  11.  12.  13.  13.]
    ///             [ 14.  14.  15.  16.  16.]
    ///             [ 14.  14.  15.  16.  16.]]
    /// 
    ///            [[ 17.  17.  18.  19.  19.]
    ///             [ 17.  17.  18.  19.  19.]
    ///             [ 20.  20.  21.  22.  22.]
    ///             [ 20.  20.  21.  22.  22.]]]]
    /// 
    ///    pad(x, mode=&quot;constant&quot;, constant_value=0, pad_width=(0,0,0,0,1,1,1,1)) =
    /// 
    ///          [[[[  0.   0.   0.   0.   0.]
    ///             [  0.   1.   2.   3.   0.]
    ///             [  0.   4.   5.   6.   0.]
    ///             [  0.   0.   0.   0.   0.]]
    /// 
    ///            [[  0.   0.   0.   0.   0.]
    ///             [  0.   7.   8.   9.   0.]
    ///             [  0.  10.  11.  12.   0.]
    ///             [  0.   0.   0.   0.   0.]]]
    /// 
    /// 
    ///           [[[  0.   0.   0.   0.   0.]
    ///             [  0.  11.  12.  13.   0.]
    ///             [  0.  14.  15.  16.   0.]
    ///             [  0.   0.   0.   0.   0.]]
    /// 
    ///            [[  0.   0.   0.   0.   0.]
    ///             [  0.  17.  18.  19.   0.]
    ///             [  0.  20.  21.  22.   0.]
    ///             [  0.   0.   0.   0.   0.]]]]
    /// 
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\pad.cc:L766</summary>
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="data">An n-dimensional input array.</param>
    /// <param name="mode">Padding type to use. &quot;constant&quot; pads with `constant_value` &quot;edge&quot; pads using the edge values of the input array &quot;reflect&quot; pads by reflecting values with respect to the edges.</param>
    /// <param name="padWidth">Widths of the padding regions applied to the edges of each axis. It is a tuple of integer padding widths for each axis of the format ``(before_1, after_1, ... , before_N, after_N)``. It should be of length ``2*N`` where ``N`` is the number of dimensions of the array.This is equivalent to pad_width in numpy.pad, but flattened.</param>
    /// <param name="constantValue">The value used for padding when `mode` is &quot;constant&quot;.</param>
    static member Pad(outputArray : NDArray seq, data : NDArray, mode : PadMode, padWidth : int seq, [<Optional; DefaultParameterValue(0.0)>] constantValue : double) =
        let creator = AtomicSymbolCreator.FromName "Pad"
        let names = [|"mode"; "pad_width"; "constant_value"|]
        let vals = [|string mode; (padWidth |> Seq.map string |> String.concat ", " |> sprintf "[%s]"); string constantValue|]
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <summary>Pads an input array with a constant or edge values of the array.
    /// 
    /// .. note:: `Pad` is deprecated. Use `pad` instead.
    /// 
    /// .. note:: Current implementation only supports 4D and 5D input arrays with padding applied
    ///    only on axes 1, 2 and 3. Expects axes 4 and 5 in `pad_width` to be zero.
    /// 
    /// This operation pads an input array with either a `constant_value` or edge values
    /// along each axis of the input array. The amount of padding is specified by `pad_width`.
    /// 
    /// `pad_width` is a tuple of integer padding widths for each axis of the format
    /// ``(before_1, after_1, ... , before_N, after_N)``. The `pad_width` should be of length ``2*N``
    /// where ``N`` is the number of dimensions of the array.
    /// 
    /// For dimension ``N`` of the input array, ``before_N`` and ``after_N`` indicates how many values
    /// to add before and after the elements of the array along dimension ``N``.
    /// The widths of the higher two dimensions ``before_1``, ``after_1``, ``before_2``,
    /// ``after_2`` must be 0.
    /// 
    /// Example::
    /// 
    ///    x = [[[[  1.   2.   3.]
    ///           [  4.   5.   6.]]
    /// 
    ///          [[  7.   8.   9.]
    ///           [ 10.  11.  12.]]]
    /// 
    /// 
    ///         [[[ 11.  12.  13.]
    ///           [ 14.  15.  16.]]
    /// 
    ///          [[ 17.  18.  19.]
    ///           [ 20.  21.  22.]]]]
    /// 
    ///    pad(x,mode=&quot;edge&quot;, pad_width=(0,0,0,0,1,1,1,1)) =
    /// 
    ///          [[[[  1.   1.   2.   3.   3.]
    ///             [  1.   1.   2.   3.   3.]
    ///             [  4.   4.   5.   6.   6.]
    ///             [  4.   4.   5.   6.   6.]]
    /// 
    ///            [[  7.   7.   8.   9.   9.]
    ///             [  7.   7.   8.   9.   9.]
    ///             [ 10.  10.  11.  12.  12.]
    ///             [ 10.  10.  11.  12.  12.]]]
    /// 
    /// 
    ///           [[[ 11.  11.  12.  13.  13.]
    ///             [ 11.  11.  12.  13.  13.]
    ///             [ 14.  14.  15.  16.  16.]
    ///             [ 14.  14.  15.  16.  16.]]
    /// 
    ///            [[ 17.  17.  18.  19.  19.]
    ///             [ 17.  17.  18.  19.  19.]
    ///             [ 20.  20.  21.  22.  22.]
    ///             [ 20.  20.  21.  22.  22.]]]]
    /// 
    ///    pad(x, mode=&quot;constant&quot;, constant_value=0, pad_width=(0,0,0,0,1,1,1,1)) =
    /// 
    ///          [[[[  0.   0.   0.   0.   0.]
    ///             [  0.   1.   2.   3.   0.]
    ///             [  0.   4.   5.   6.   0.]
    ///             [  0.   0.   0.   0.   0.]]
    /// 
    ///            [[  0.   0.   0.   0.   0.]
    ///             [  0.   7.   8.   9.   0.]
    ///             [  0.  10.  11.  12.   0.]
    ///             [  0.   0.   0.   0.   0.]]]
    /// 
    /// 
    ///           [[[  0.   0.   0.   0.   0.]
    ///             [  0.  11.  12.  13.   0.]
    ///             [  0.  14.  15.  16.   0.]
    ///             [  0.   0.   0.   0.   0.]]
    /// 
    ///            [[  0.   0.   0.   0.   0.]
    ///             [  0.  17.  18.  19.   0.]
    ///             [  0.  20.  21.  22.   0.]
    ///             [  0.   0.   0.   0.   0.]]]]
    /// 
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\pad.cc:L766</summary>
    /// <param name="data">An n-dimensional input array.</param>
    /// <param name="mode">Padding type to use. &quot;constant&quot; pads with `constant_value` &quot;edge&quot; pads using the edge values of the input array &quot;reflect&quot; pads by reflecting values with respect to the edges.</param>
    /// <param name="padWidth">Widths of the padding regions applied to the edges of each axis. It is a tuple of integer padding widths for each axis of the format ``(before_1, after_1, ... , before_N, after_N)``. It should be of length ``2*N`` where ``N`` is the number of dimensions of the array.This is equivalent to pad_width in numpy.pad, but flattened.</param>
    /// <param name="constantValue">The value used for padding when `mode` is &quot;constant&quot;.</param>
    static member Pad(data : Symbol, mode : PadMode, padWidth : int seq, [<Optional>] ?constantValue : double) =
        Pad(data, mode, padWidth, ?constantValue = constantValue)
    /// <summary>Pads an input array with a constant or edge values of the array.
    /// 
    /// .. note:: `Pad` is deprecated. Use `pad` instead.
    /// 
    /// .. note:: Current implementation only supports 4D and 5D input arrays with padding applied
    ///    only on axes 1, 2 and 3. Expects axes 4 and 5 in `pad_width` to be zero.
    /// 
    /// This operation pads an input array with either a `constant_value` or edge values
    /// along each axis of the input array. The amount of padding is specified by `pad_width`.
    /// 
    /// `pad_width` is a tuple of integer padding widths for each axis of the format
    /// ``(before_1, after_1, ... , before_N, after_N)``. The `pad_width` should be of length ``2*N``
    /// where ``N`` is the number of dimensions of the array.
    /// 
    /// For dimension ``N`` of the input array, ``before_N`` and ``after_N`` indicates how many values
    /// to add before and after the elements of the array along dimension ``N``.
    /// The widths of the higher two dimensions ``before_1``, ``after_1``, ``before_2``,
    /// ``after_2`` must be 0.
    /// 
    /// Example::
    /// 
    ///    x = [[[[  1.   2.   3.]
    ///           [  4.   5.   6.]]
    /// 
    ///          [[  7.   8.   9.]
    ///           [ 10.  11.  12.]]]
    /// 
    /// 
    ///         [[[ 11.  12.  13.]
    ///           [ 14.  15.  16.]]
    /// 
    ///          [[ 17.  18.  19.]
    ///           [ 20.  21.  22.]]]]
    /// 
    ///    pad(x,mode=&quot;edge&quot;, pad_width=(0,0,0,0,1,1,1,1)) =
    /// 
    ///          [[[[  1.   1.   2.   3.   3.]
    ///             [  1.   1.   2.   3.   3.]
    ///             [  4.   4.   5.   6.   6.]
    ///             [  4.   4.   5.   6.   6.]]
    /// 
    ///            [[  7.   7.   8.   9.   9.]
    ///             [  7.   7.   8.   9.   9.]
    ///             [ 10.  10.  11.  12.  12.]
    ///             [ 10.  10.  11.  12.  12.]]]
    /// 
    /// 
    ///           [[[ 11.  11.  12.  13.  13.]
    ///             [ 11.  11.  12.  13.  13.]
    ///             [ 14.  14.  15.  16.  16.]
    ///             [ 14.  14.  15.  16.  16.]]
    /// 
    ///            [[ 17.  17.  18.  19.  19.]
    ///             [ 17.  17.  18.  19.  19.]
    ///             [ 20.  20.  21.  22.  22.]
    ///             [ 20.  20.  21.  22.  22.]]]]
    /// 
    ///    pad(x, mode=&quot;constant&quot;, constant_value=0, pad_width=(0,0,0,0,1,1,1,1)) =
    /// 
    ///          [[[[  0.   0.   0.   0.   0.]
    ///             [  0.   1.   2.   3.   0.]
    ///             [  0.   4.   5.   6.   0.]
    ///             [  0.   0.   0.   0.   0.]]
    /// 
    ///            [[  0.   0.   0.   0.   0.]
    ///             [  0.   7.   8.   9.   0.]
    ///             [  0.  10.  11.  12.   0.]
    ///             [  0.   0.   0.   0.   0.]]]
    /// 
    /// 
    ///           [[[  0.   0.   0.   0.   0.]
    ///             [  0.  11.  12.  13.   0.]
    ///             [  0.  14.  15.  16.   0.]
    ///             [  0.   0.   0.   0.   0.]]
    /// 
    ///            [[  0.   0.   0.   0.   0.]
    ///             [  0.  17.  18.  19.   0.]
    ///             [  0.  20.  21.  22.   0.]
    ///             [  0.   0.   0.   0.   0.]]]]
    /// 
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\pad.cc:L766</summary>
    /// <param name="mode">Padding type to use. &quot;constant&quot; pads with `constant_value` &quot;edge&quot; pads using the edge values of the input array &quot;reflect&quot; pads by reflecting values with respect to the edges.</param>
    /// <param name="padWidth">Widths of the padding regions applied to the edges of each axis. It is a tuple of integer padding widths for each axis of the format ``(before_1, after_1, ... , before_N, after_N)``. It should be of length ``2*N`` where ``N`` is the number of dimensions of the array.This is equivalent to pad_width in numpy.pad, but flattened.</param>
    /// <param name="data">An n-dimensional input array.</param>
    /// <param name="constantValue">The value used for padding when `mode` is &quot;constant&quot;.</param>
    static member Pad(mode : PadMode, padWidth : int seq, [<Optional>] ?data : Symbol, [<Optional>] ?constantValue : double) =
        Pad(mode, padWidth, ?data = data, ?constantValue = constantValue)

    /// <summary>Provide calibrated min/max for input histogram.
    /// 
    /// .. Note::
    ///     This operator only supports forward propagation. DO NOT use it in training.
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\quantization\calibrate.cc:L197</summary>
    /// <param name="hist">A ndarray/symbol of type `float32`</param>
    /// <param name="histEdges">A ndarray/symbol of type `float32`</param>
    /// <param name="numQuantizedBins">The number of quantized bins.</param>
    static member ContribCalibrateEntropy(hist : NDArray, histEdges : NDArray, [<Optional; DefaultParameterValue(255)>] numQuantizedBins : int) =
        let creator = AtomicSymbolCreator.FromName "_contrib_calibrate_entropy"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg hist)) then hist.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg histEdges)) then histEdges.UnsafeHandle|]
                                                 [|"num_quantized_bins"|]
                                                 [|string numQuantizedBins|]
        (new NDArray(outputs.[0])), (new NDArray(outputs.[1]))
    /// <summary>Provide calibrated min/max for input histogram.
    /// 
    /// .. Note::
    ///     This operator only supports forward propagation. DO NOT use it in training.
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\quantization\calibrate.cc:L197</summary>
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="hist">A ndarray/symbol of type `float32`</param>
    /// <param name="histEdges">A ndarray/symbol of type `float32`</param>
    /// <param name="numQuantizedBins">The number of quantized bins.</param>
    static member ContribCalibrateEntropy(outputArray : NDArray seq, hist : NDArray, histEdges : NDArray, [<Optional; DefaultParameterValue(255)>] numQuantizedBins : int) =
        let creator = AtomicSymbolCreator.FromName "_contrib_calibrate_entropy"
        let names = [|"num_quantized_bins"|]
        let vals = [|string numQuantizedBins|]
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg hist)) then hist.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg histEdges)) then histEdges.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <summary>Provide calibrated min/max for input histogram.
    /// 
    /// .. Note::
    ///     This operator only supports forward propagation. DO NOT use it in training.
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\quantization\calibrate.cc:L197</summary>
    /// <param name="hist">A ndarray/symbol of type `float32`</param>
    /// <param name="histEdges">A ndarray/symbol of type `float32`</param>
    /// <param name="numQuantizedBins">The number of quantized bins.</param>
    static member ContribCalibrateEntropy([<Optional>] ?hist : Symbol, [<Optional>] ?histEdges : Symbol, [<Optional>] ?numQuantizedBins : int) =
        ContribCalibrateEntropy(?hist = hist, ?histEdges = histEdges, ?numQuantizedBins = numQuantizedBins)

    /// <summary>Dequantize the input tensor into a float tensor.
    /// min_range and max_range are scalar floats that specify the range for
    /// the output data.
    /// 
    /// When input data type is `uint8`, the output is calculated using the following equation:
    /// 
    /// `out[i] = in[i] * (max_range - min_range) / 255.0`,
    /// 
    /// When input data type is `int8`, the output is calculate using the following equation
    /// by keep zero centered for the quantized value:
    /// 
    /// `out[i] = in[i] * MaxAbs(min_range, max_range) / 127.0`,
    /// 
    /// .. Note::
    ///     This operator only supports forward propogation. DO NOT use it in training.
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\quantization\dequantize.cc:L81</summary>
    /// <param name="data">A ndarray/symbol of type `uint8`</param>
    /// <param name="minRange">The minimum scalar value possibly produced for the input in float32</param>
    /// <param name="maxRange">The maximum scalar value possibly produced for the input in float32</param>
    /// <param name="outType">Output data type.</param>
    static member ContribDequantize(data : NDArray, minRange : NDArray, maxRange : NDArray, [<Optional>] outType : ContribDequantizeOutType) =
        let creator = AtomicSymbolCreator.FromName "_contrib_dequantize"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg minRange)) then minRange.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg maxRange)) then maxRange.UnsafeHandle|]
                                                 [|"out_type"|]
                                                 [|(if isNull (outType :> obj) then "float32" else string outType)|]
        (new NDArray(outputs.[0]))
    /// <summary>Dequantize the input tensor into a float tensor.
    /// min_range and max_range are scalar floats that specify the range for
    /// the output data.
    /// 
    /// When input data type is `uint8`, the output is calculated using the following equation:
    /// 
    /// `out[i] = in[i] * (max_range - min_range) / 255.0`,
    /// 
    /// When input data type is `int8`, the output is calculate using the following equation
    /// by keep zero centered for the quantized value:
    /// 
    /// `out[i] = in[i] * MaxAbs(min_range, max_range) / 127.0`,
    /// 
    /// .. Note::
    ///     This operator only supports forward propogation. DO NOT use it in training.
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\quantization\dequantize.cc:L81</summary>
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="data">A ndarray/symbol of type `uint8`</param>
    /// <param name="minRange">The minimum scalar value possibly produced for the input in float32</param>
    /// <param name="maxRange">The maximum scalar value possibly produced for the input in float32</param>
    /// <param name="outType">Output data type.</param>
    static member ContribDequantize(outputArray : NDArray seq, data : NDArray, minRange : NDArray, maxRange : NDArray, [<Optional>] outType : ContribDequantizeOutType) =
        let creator = AtomicSymbolCreator.FromName "_contrib_dequantize"
        let names = [|"out_type"|]
        let vals = [|(if isNull (outType :> obj) then "float32" else string outType)|]
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg minRange)) then minRange.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg maxRange)) then maxRange.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <summary>Dequantize the input tensor into a float tensor.
    /// min_range and max_range are scalar floats that specify the range for
    /// the output data.
    /// 
    /// When input data type is `uint8`, the output is calculated using the following equation:
    /// 
    /// `out[i] = in[i] * (max_range - min_range) / 255.0`,
    /// 
    /// When input data type is `int8`, the output is calculate using the following equation
    /// by keep zero centered for the quantized value:
    /// 
    /// `out[i] = in[i] * MaxAbs(min_range, max_range) / 127.0`,
    /// 
    /// .. Note::
    ///     This operator only supports forward propogation. DO NOT use it in training.
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\quantization\dequantize.cc:L81</summary>
    /// <param name="data">A ndarray/symbol of type `uint8`</param>
    /// <param name="minRange">The minimum scalar value possibly produced for the input in float32</param>
    /// <param name="maxRange">The maximum scalar value possibly produced for the input in float32</param>
    /// <param name="outType">Output data type.</param>
    static member ContribDequantize([<Optional>] ?data : Symbol, [<Optional>] ?minRange : Symbol, [<Optional>] ?maxRange : Symbol, [<Optional>] ?outType : ContribDequantizeOutType) =
        ContribDequantize(?data = data, ?minRange = minRange, ?maxRange = maxRange, ?outType = outType)

    /// <summary>Activation operator for input and output data type of int8.
    /// The input and output data comes with min and max thresholds for quantizing
    /// the float32 data into int8.
    /// 
    /// .. Note::
    ///      This operator only supports forward propogation. DO NOT use it in training.
    ///      This operator only supports `relu`
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\quantization\quantized_activation.cc:L91</summary>
    /// <param name="data">Input data.</param>
    /// <param name="minData">Minimum value of data.</param>
    /// <param name="maxData">Maximum value of data.</param>
    /// <param name="actType">Activation function to be applied.</param>
    static member ContribQuantizedAct(data : NDArray, minData : NDArray, maxData : NDArray, actType : ActType) =
        let creator = AtomicSymbolCreator.FromName "_contrib_quantized_act"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg minData)) then minData.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg maxData)) then maxData.UnsafeHandle|]
                                                 [|"act_type"|]
                                                 [|string actType|]
        (new NDArray(outputs.[0])), (new NDArray(outputs.[1])), (new NDArray(outputs.[2]))
    /// <summary>Activation operator for input and output data type of int8.
    /// The input and output data comes with min and max thresholds for quantizing
    /// the float32 data into int8.
    /// 
    /// .. Note::
    ///      This operator only supports forward propogation. DO NOT use it in training.
    ///      This operator only supports `relu`
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\quantization\quantized_activation.cc:L91</summary>
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="data">Input data.</param>
    /// <param name="minData">Minimum value of data.</param>
    /// <param name="maxData">Maximum value of data.</param>
    /// <param name="actType">Activation function to be applied.</param>
    static member ContribQuantizedAct(outputArray : NDArray seq, data : NDArray, minData : NDArray, maxData : NDArray, actType : ActType) =
        let creator = AtomicSymbolCreator.FromName "_contrib_quantized_act"
        let names = [|"act_type"|]
        let vals = [|string actType|]
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg minData)) then minData.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg maxData)) then maxData.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <summary>Activation operator for input and output data type of int8.
    /// The input and output data comes with min and max thresholds for quantizing
    /// the float32 data into int8.
    /// 
    /// .. Note::
    ///      This operator only supports forward propogation. DO NOT use it in training.
    ///      This operator only supports `relu`
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\quantization\quantized_activation.cc:L91</summary>
    /// <param name="data">Input data.</param>
    /// <param name="minData">Minimum value of data.</param>
    /// <param name="maxData">Maximum value of data.</param>
    /// <param name="actType">Activation function to be applied.</param>
    static member ContribQuantizedAct(data : Symbol, minData : Symbol, maxData : Symbol, actType : ActType) =
        ContribQuantizedAct(data, minData, maxData, actType)
    /// <summary>Activation operator for input and output data type of int8.
    /// The input and output data comes with min and max thresholds for quantizing
    /// the float32 data into int8.
    /// 
    /// .. Note::
    ///      This operator only supports forward propogation. DO NOT use it in training.
    ///      This operator only supports `relu`
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\quantization\quantized_activation.cc:L91</summary>
    /// <param name="actType">Activation function to be applied.</param>
    /// <param name="data">Input data.</param>
    /// <param name="minData">Minimum value of data.</param>
    /// <param name="maxData">Maximum value of data.</param>
    static member ContribQuantizedAct(actType : ActType, [<Optional>] ?data : Symbol, [<Optional>] ?minData : Symbol, [<Optional>] ?maxData : Symbol) =
        ContribQuantizedAct(actType, ?data = data, ?minData = minData, ?maxData = maxData)

    /// <summary>BatchNorm operator for input and output data type of int8.
    /// The input and output data comes with min and max thresholds for quantizing
    /// the float32 data into int8.
    /// 
    /// .. Note::
    ///     This operator only supports forward propogation. DO NOT use it in training.
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\quantization\quantized_batch_norm.cc:L95</summary>
    /// <param name="data">Input data.</param>
    /// <param name="gamma">gamma.</param>
    /// <param name="beta">beta.</param>
    /// <param name="movingMean">moving_mean.</param>
    /// <param name="movingVar">moving_var.</param>
    /// <param name="minData">Minimum value of data.</param>
    /// <param name="maxData">Maximum value of data.</param>
    /// <param name="eps">Epsilon to prevent div 0. Must be no less than CUDNN_BN_MIN_EPSILON defined in cudnn.h when using cudnn (usually 1e-5)</param>
    /// <param name="momentum">Momentum for moving average</param>
    /// <param name="fixGamma">Fix gamma while training</param>
    /// <param name="useGlobalStats">Whether use global moving statistics instead of local batch-norm. This will force change batch-norm into a scale shift operator.</param>
    /// <param name="outputMeanVar">Output the mean and inverse std </param>
    /// <param name="axis">Specify which shape axis the channel is specified</param>
    /// <param name="cudnnOff">Do not select CUDNN operator, if available</param>
    /// <param name="minCalibRange">The minimum scalar value in the form of float32 obtained through calibration. If present, it will be used to by quantized batch norm op to calculate primitive scale.Note: this calib_range is to calib bn output.</param>
    /// <param name="maxCalibRange">The maximum scalar value in the form of float32 obtained through calibration. If present, it will be used to by quantized batch norm op to calculate primitive scale.Note: this calib_range is to calib bn output.</param>
    static member ContribQuantizedBatchNorm(data : NDArray, 
                                            gamma : NDArray, 
                                            beta : NDArray, 
                                            movingMean : NDArray, 
                                            movingVar : NDArray, 
                                            minData : NDArray, 
                                            maxData : NDArray, 
                                            [<Optional>] ?eps : double, 
                                            [<Optional>] ?momentum : float, 
                                            [<Optional>] ?fixGamma : bool, 
                                            [<Optional>] ?useGlobalStats : bool, 
                                            [<Optional>] ?outputMeanVar : bool, 
                                            [<Optional>] ?axis : int, 
                                            [<Optional>] ?cudnnOff : bool, 
                                            [<Optional>] ?minCalibRange : float, 
                                            [<Optional>] ?maxCalibRange : float) =
        let creator = AtomicSymbolCreator.FromName "_contrib_quantized_batch_norm"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg gamma)) then gamma.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg beta)) then beta.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg movingMean)) then movingMean.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg movingVar)) then movingVar.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg minData)) then minData.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg maxData)) then maxData.UnsafeHandle|]
                                                 [|"eps"; "momentum"; "fix_gamma"; "use_global_stats"; "output_mean_var"; "axis"; "cudnn_off"; "min_calib_range"; "max_calib_range"|]
                                                 [|(match eps with None -> "0.00100000004749745" | Some eps -> string eps); (match momentum with None -> "0.899999976" | Some momentum -> string momentum); (match fixGamma with None -> "true" | Some fixGamma -> string fixGamma); (match useGlobalStats with None -> "false" | Some useGlobalStats -> string useGlobalStats); (match outputMeanVar with None -> "false" | Some outputMeanVar -> string outputMeanVar); (match axis with None -> "1" | Some axis -> string axis); (match cudnnOff with None -> "false" | Some cudnnOff -> string cudnnOff); (match minCalibRange with None -> "None" | Some minCalibRange -> string minCalibRange); (match maxCalibRange with None -> "None" | Some maxCalibRange -> string maxCalibRange)|]
        (new NDArray(outputs.[0])), (new NDArray(outputs.[1])), (new NDArray(outputs.[2]))
    /// <summary>BatchNorm operator for input and output data type of int8.
    /// The input and output data comes with min and max thresholds for quantizing
    /// the float32 data into int8.
    /// 
    /// .. Note::
    ///     This operator only supports forward propogation. DO NOT use it in training.
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\quantization\quantized_batch_norm.cc:L95</summary>
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="data">Input data.</param>
    /// <param name="gamma">gamma.</param>
    /// <param name="beta">beta.</param>
    /// <param name="movingMean">moving_mean.</param>
    /// <param name="movingVar">moving_var.</param>
    /// <param name="minData">Minimum value of data.</param>
    /// <param name="maxData">Maximum value of data.</param>
    /// <param name="eps">Epsilon to prevent div 0. Must be no less than CUDNN_BN_MIN_EPSILON defined in cudnn.h when using cudnn (usually 1e-5)</param>
    /// <param name="momentum">Momentum for moving average</param>
    /// <param name="fixGamma">Fix gamma while training</param>
    /// <param name="useGlobalStats">Whether use global moving statistics instead of local batch-norm. This will force change batch-norm into a scale shift operator.</param>
    /// <param name="outputMeanVar">Output the mean and inverse std </param>
    /// <param name="axis">Specify which shape axis the channel is specified</param>
    /// <param name="cudnnOff">Do not select CUDNN operator, if available</param>
    /// <param name="minCalibRange">The minimum scalar value in the form of float32 obtained through calibration. If present, it will be used to by quantized batch norm op to calculate primitive scale.Note: this calib_range is to calib bn output.</param>
    /// <param name="maxCalibRange">The maximum scalar value in the form of float32 obtained through calibration. If present, it will be used to by quantized batch norm op to calculate primitive scale.Note: this calib_range is to calib bn output.</param>
    static member ContribQuantizedBatchNorm(outputArray : NDArray seq, 
                                            data : NDArray, 
                                            gamma : NDArray, 
                                            beta : NDArray, 
                                            movingMean : NDArray, 
                                            movingVar : NDArray, 
                                            minData : NDArray, 
                                            maxData : NDArray, 
                                            [<Optional>] ?eps : double, 
                                            [<Optional>] ?momentum : float, 
                                            [<Optional>] ?fixGamma : bool, 
                                            [<Optional>] ?useGlobalStats : bool, 
                                            [<Optional>] ?outputMeanVar : bool, 
                                            [<Optional>] ?axis : int, 
                                            [<Optional>] ?cudnnOff : bool, 
                                            [<Optional>] ?minCalibRange : float, 
                                            [<Optional>] ?maxCalibRange : float) =
        let creator = AtomicSymbolCreator.FromName "_contrib_quantized_batch_norm"
        let names = [|"eps"; "momentum"; "fix_gamma"; "use_global_stats"; "output_mean_var"; "axis"; "cudnn_off"; "min_calib_range"; "max_calib_range"|]
        let vals = [|(match eps with None -> "0.00100000004749745" | Some eps -> string eps); (match momentum with None -> "0.899999976" | Some momentum -> string momentum); (match fixGamma with None -> "true" | Some fixGamma -> string fixGamma); (match useGlobalStats with None -> "false" | Some useGlobalStats -> string useGlobalStats); (match outputMeanVar with None -> "false" | Some outputMeanVar -> string outputMeanVar); (match axis with None -> "1" | Some axis -> string axis); (match cudnnOff with None -> "false" | Some cudnnOff -> string cudnnOff); (match minCalibRange with None -> "None" | Some minCalibRange -> string minCalibRange); (match maxCalibRange with None -> "None" | Some maxCalibRange -> string maxCalibRange)|]
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg gamma)) then gamma.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg beta)) then beta.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg movingMean)) then movingMean.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg movingVar)) then movingVar.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg minData)) then minData.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg maxData)) then maxData.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <summary>BatchNorm operator for input and output data type of int8.
    /// The input and output data comes with min and max thresholds for quantizing
    /// the float32 data into int8.
    /// 
    /// .. Note::
    ///     This operator only supports forward propogation. DO NOT use it in training.
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\quantization\quantized_batch_norm.cc:L95</summary>
    /// <param name="data">Input data.</param>
    /// <param name="gamma">gamma.</param>
    /// <param name="beta">beta.</param>
    /// <param name="movingMean">moving_mean.</param>
    /// <param name="movingVar">moving_var.</param>
    /// <param name="minData">Minimum value of data.</param>
    /// <param name="maxData">Maximum value of data.</param>
    /// <param name="eps">Epsilon to prevent div 0. Must be no less than CUDNN_BN_MIN_EPSILON defined in cudnn.h when using cudnn (usually 1e-5)</param>
    /// <param name="momentum">Momentum for moving average</param>
    /// <param name="fixGamma">Fix gamma while training</param>
    /// <param name="useGlobalStats">Whether use global moving statistics instead of local batch-norm. This will force change batch-norm into a scale shift operator.</param>
    /// <param name="outputMeanVar">Output the mean and inverse std </param>
    /// <param name="axis">Specify which shape axis the channel is specified</param>
    /// <param name="cudnnOff">Do not select CUDNN operator, if available</param>
    /// <param name="minCalibRange">The minimum scalar value in the form of float32 obtained through calibration. If present, it will be used to by quantized batch norm op to calculate primitive scale.Note: this calib_range is to calib bn output.</param>
    /// <param name="maxCalibRange">The maximum scalar value in the form of float32 obtained through calibration. If present, it will be used to by quantized batch norm op to calculate primitive scale.Note: this calib_range is to calib bn output.</param>
    static member ContribQuantizedBatchNorm([<Optional>] ?data : Symbol, [<Optional>] ?gamma : Symbol, [<Optional>] ?beta : Symbol, [<Optional>] ?movingMean : Symbol, [<Optional>] ?movingVar : Symbol, [<Optional>] ?minData : Symbol, [<Optional>] ?maxData : Symbol, [<Optional>] ?eps : double, [<Optional>] ?momentum : float, [<Optional>] ?fixGamma : bool, [<Optional>] ?useGlobalStats : bool, [<Optional>] ?outputMeanVar : bool, [<Optional>] ?axis : int, [<Optional>] ?cudnnOff : bool, [<Optional>] ?minCalibRange : float, [<Optional>] ?maxCalibRange : float) =
        ContribQuantizedBatchNorm(?data = data, ?gamma = gamma, ?beta = beta, ?movingMean = movingMean, ?movingVar = movingVar, ?minData = minData, ?maxData = maxData, ?eps = eps, ?momentum = momentum, ?fixGamma = fixGamma, ?useGlobalStats = useGlobalStats, ?outputMeanVar = outputMeanVar, ?axis = axis, ?cudnnOff = cudnnOff, ?minCalibRange = minCalibRange, ?maxCalibRange = maxCalibRange)

    /// <summary>Joins input arrays along a given axis.
    /// 
    /// The dimensions of the input arrays should be the same except the axis along
    /// which they will be concatenated.
    /// The dimension of the output array along the concatenated axis will be equal
    /// to the sum of the corresponding dimensions of the input arrays.
    /// All inputs with different min/max will be rescaled by using largest [min, max] pairs.
    /// If any input holds int8, then the output will be int8. Otherwise output will be uint8.
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\quantization\quantized_concat.cc:L108</summary>
    /// <param name="data">List of arrays to concatenate</param>
    /// <param name="numArgs">Number of inputs to be concated.</param>
    /// <param name="dim">the dimension to be concated.</param>
    static member ContribQuantizedConcat([<ParamArray>] data : NDArray[], [<Optional; DefaultParameterValue(1)>] dim : int) =
        let creator = AtomicSymbolCreator.FromName "_contrib_quantized_concat"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 (data |> Array.map (fun x -> x.UnsafeHandle))
                                                 [|"num_args"; "dim"|]
                                                 [|string data.Length; string dim|]
        (new NDArray(outputs.[0])), (new NDArray(outputs.[1])), (new NDArray(outputs.[2]))
    /// <summary>Joins input arrays along a given axis.
    /// 
    /// The dimensions of the input arrays should be the same except the axis along
    /// which they will be concatenated.
    /// The dimension of the output array along the concatenated axis will be equal
    /// to the sum of the corresponding dimensions of the input arrays.
    /// All inputs with different min/max will be rescaled by using largest [min, max] pairs.
    /// If any input holds int8, then the output will be int8. Otherwise output will be uint8.
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\quantization\quantized_concat.cc:L108</summary>
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="data">List of arrays to concatenate</param>
    /// <param name="numArgs">Number of inputs to be concated.</param>
    /// <param name="dim">the dimension to be concated.</param>
    static member ContribQuantizedConcat(outputArray : NDArray seq, [<ParamArray>] data : NDArray[], [<Optional; DefaultParameterValue(1)>] dim : int) =
        let creator = AtomicSymbolCreator.FromName "_contrib_quantized_concat"
        let names = [|"num_args"; "dim"|]
        let vals = [|string data.Length; string dim|]
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     (data |> Array.map (fun x -> x.UnsafeHandle))
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <summary>Joins input arrays along a given axis.
    /// 
    /// The dimensions of the input arrays should be the same except the axis along
    /// which they will be concatenated.
    /// The dimension of the output array along the concatenated axis will be equal
    /// to the sum of the corresponding dimensions of the input arrays.
    /// All inputs with different min/max will be rescaled by using largest [min, max] pairs.
    /// If any input holds int8, then the output will be int8. Otherwise output will be uint8.
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\quantization\quantized_concat.cc:L108</summary>
    /// <param name="data">List of arrays to concatenate</param>
    /// <param name="dim">the dimension to be concated.</param>
    static member ContribQuantizedConcat([<Optional>] ?data : Symbol seq, [<Optional>] ?dim : int) =
        ContribQuantizedConcat(?data = data, ?dim = dim)

    /// <summary>Convolution operator for input, weight and bias data type of int8,
    /// and accumulates in type int32 for the output. For each argument, two more arguments of type
    /// float32 must be provided representing the thresholds of quantizing argument from data
    /// type float32 to int8. The final outputs contain the convolution result in int32, and min
    /// and max thresholds representing the threholds for quantizing the float32 output into int32.
    /// 
    /// .. Note::
    ///     This operator only supports forward propogation. DO NOT use it in training.
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\quantization\quantized_conv.cc:L137</summary>
    /// <param name="data">Input data.</param>
    /// <param name="weight">weight.</param>
    /// <param name="bias">bias.</param>
    /// <param name="minData">Minimum value of data.</param>
    /// <param name="maxData">Maximum value of data.</param>
    /// <param name="minWeight">Minimum value of weight.</param>
    /// <param name="maxWeight">Maximum value of weight.</param>
    /// <param name="minBias">Minimum value of bias.</param>
    /// <param name="maxBias">Maximum value of bias.</param>
    /// <param name="kernel">Convolution kernel size: (w,), (h, w) or (d, h, w)</param>
    /// <param name="numFilter">Convolution filter(channel) number</param>
    /// <param name="stride">Convolution stride: (w,), (h, w) or (d, h, w). Defaults to 1 for each dimension.</param>
    /// <param name="dilate">Convolution dilate: (w,), (h, w) or (d, h, w). Defaults to 1 for each dimension.</param>
    /// <param name="pad">Zero pad for convolution: (w,), (h, w) or (d, h, w). Defaults to no padding.</param>
    /// <param name="numGroup">Number of group partitions.</param>
    /// <param name="workspace">Maximum temporary workspace allowed (MB) in convolution.This parameter has two usages. When CUDNN is not used, it determines the effective batch size of the convolution kernel. When CUDNN is used, it controls the maximum temporary storage used for tuning the best CUDNN kernel when `limited_workspace` strategy is used.</param>
    /// <param name="noBias">Whether to disable bias parameter.</param>
    /// <param name="cudnnTune">Whether to pick convolution algo by running performance test.</param>
    /// <param name="cudnnOff">Turn off cudnn for this layer.</param>
    /// <param name="layout">Set layout for input, output and weight. Empty for
    ///     default layout: NCW for 1d, NCHW for 2d and NCDHW for 3d.NHWC and NDHWC are only supported on GPU.</param>
    static member ContribQuantizedConv(data : NDArray, 
                                       weight : NDArray, 
                                       bias : NDArray, 
                                       minData : NDArray, 
                                       maxData : NDArray, 
                                       minWeight : NDArray, 
                                       maxWeight : NDArray, 
                                       minBias : NDArray, 
                                       maxBias : NDArray, 
                                       kernel : int seq, 
                                       numFilter : int, 
                                       [<Optional>] stride : int seq, 
                                       [<Optional>] dilate : int seq, 
                                       [<Optional>] pad : int seq, 
                                       [<Optional; DefaultParameterValue(1)>] numGroup : int, 
                                       [<Optional; DefaultParameterValue(1024L)>] workspace : int64, 
                                       [<Optional; DefaultParameterValue(false)>] noBias : bool, 
                                       [<Optional>] cudnnTune : CudnnTune, 
                                       [<Optional; DefaultParameterValue(false)>] cudnnOff : bool, 
                                       [<Optional>] layout : ContribQuantizedConvLayout) =
        let creator = AtomicSymbolCreator.FromName "_contrib_quantized_conv"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg weight)) then weight.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg bias)) then bias.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg minData)) then minData.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg maxData)) then maxData.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg minWeight)) then minWeight.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg maxWeight)) then maxWeight.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg minBias)) then minBias.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg maxBias)) then maxBias.UnsafeHandle|]
                                                 [|"kernel"; "num_filter"; "stride"; "dilate"; "pad"; "num_group"; "workspace"; "no_bias"; "cudnn_tune"; "cudnn_off"; "layout"|]
                                                 [|(kernel |> Seq.map string |> String.concat ", " |> sprintf "[%s]"); string numFilter; (if isNull (stride :> obj) then "[]" else (stride |> Seq.map string |> String.concat ", " |> sprintf "[%s]")); (if isNull (dilate :> obj) then "[]" else (dilate |> Seq.map string |> String.concat ", " |> sprintf "[%s]")); (if isNull (pad :> obj) then "[]" else (pad |> Seq.map string |> String.concat ", " |> sprintf "[%s]")); string numGroup; string workspace; string noBias; (if isNull (cudnnTune :> obj) then "None" else string cudnnTune); string cudnnOff; (if isNull (layout :> obj) then "None" else string layout)|]
        (new NDArray(outputs.[0])), (new NDArray(outputs.[1])), (new NDArray(outputs.[2]))
    /// <summary>Convolution operator for input, weight and bias data type of int8,
    /// and accumulates in type int32 for the output. For each argument, two more arguments of type
    /// float32 must be provided representing the thresholds of quantizing argument from data
    /// type float32 to int8. The final outputs contain the convolution result in int32, and min
    /// and max thresholds representing the threholds for quantizing the float32 output into int32.
    /// 
    /// .. Note::
    ///     This operator only supports forward propogation. DO NOT use it in training.
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\quantization\quantized_conv.cc:L137</summary>
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="data">Input data.</param>
    /// <param name="weight">weight.</param>
    /// <param name="bias">bias.</param>
    /// <param name="minData">Minimum value of data.</param>
    /// <param name="maxData">Maximum value of data.</param>
    /// <param name="minWeight">Minimum value of weight.</param>
    /// <param name="maxWeight">Maximum value of weight.</param>
    /// <param name="minBias">Minimum value of bias.</param>
    /// <param name="maxBias">Maximum value of bias.</param>
    /// <param name="kernel">Convolution kernel size: (w,), (h, w) or (d, h, w)</param>
    /// <param name="numFilter">Convolution filter(channel) number</param>
    /// <param name="stride">Convolution stride: (w,), (h, w) or (d, h, w). Defaults to 1 for each dimension.</param>
    /// <param name="dilate">Convolution dilate: (w,), (h, w) or (d, h, w). Defaults to 1 for each dimension.</param>
    /// <param name="pad">Zero pad for convolution: (w,), (h, w) or (d, h, w). Defaults to no padding.</param>
    /// <param name="numGroup">Number of group partitions.</param>
    /// <param name="workspace">Maximum temporary workspace allowed (MB) in convolution.This parameter has two usages. When CUDNN is not used, it determines the effective batch size of the convolution kernel. When CUDNN is used, it controls the maximum temporary storage used for tuning the best CUDNN kernel when `limited_workspace` strategy is used.</param>
    /// <param name="noBias">Whether to disable bias parameter.</param>
    /// <param name="cudnnTune">Whether to pick convolution algo by running performance test.</param>
    /// <param name="cudnnOff">Turn off cudnn for this layer.</param>
    /// <param name="layout">Set layout for input, output and weight. Empty for
    ///     default layout: NCW for 1d, NCHW for 2d and NCDHW for 3d.NHWC and NDHWC are only supported on GPU.</param>
    static member ContribQuantizedConv(outputArray : NDArray seq, 
                                       data : NDArray, 
                                       weight : NDArray, 
                                       bias : NDArray, 
                                       minData : NDArray, 
                                       maxData : NDArray, 
                                       minWeight : NDArray, 
                                       maxWeight : NDArray, 
                                       minBias : NDArray, 
                                       maxBias : NDArray, 
                                       kernel : int seq, 
                                       numFilter : int, 
                                       [<Optional>] stride : int seq, 
                                       [<Optional>] dilate : int seq, 
                                       [<Optional>] pad : int seq, 
                                       [<Optional; DefaultParameterValue(1)>] numGroup : int, 
                                       [<Optional; DefaultParameterValue(1024L)>] workspace : int64, 
                                       [<Optional; DefaultParameterValue(false)>] noBias : bool, 
                                       [<Optional>] cudnnTune : CudnnTune, 
                                       [<Optional; DefaultParameterValue(false)>] cudnnOff : bool, 
                                       [<Optional>] layout : ContribQuantizedConvLayout) =
        let creator = AtomicSymbolCreator.FromName "_contrib_quantized_conv"
        let names = [|"kernel"; "num_filter"; "stride"; "dilate"; "pad"; "num_group"; "workspace"; "no_bias"; "cudnn_tune"; "cudnn_off"; "layout"|]
        let vals = [|(kernel |> Seq.map string |> String.concat ", " |> sprintf "[%s]"); string numFilter; (if isNull (stride :> obj) then "[]" else (stride |> Seq.map string |> String.concat ", " |> sprintf "[%s]")); (if isNull (dilate :> obj) then "[]" else (dilate |> Seq.map string |> String.concat ", " |> sprintf "[%s]")); (if isNull (pad :> obj) then "[]" else (pad |> Seq.map string |> String.concat ", " |> sprintf "[%s]")); string numGroup; string workspace; string noBias; (if isNull (cudnnTune :> obj) then "None" else string cudnnTune); string cudnnOff; (if isNull (layout :> obj) then "None" else string layout)|]
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg weight)) then weight.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg bias)) then bias.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg minData)) then minData.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg maxData)) then maxData.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg minWeight)) then minWeight.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg maxWeight)) then maxWeight.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg minBias)) then minBias.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg maxBias)) then maxBias.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <summary>Convolution operator for input, weight and bias data type of int8,
    /// and accumulates in type int32 for the output. For each argument, two more arguments of type
    /// float32 must be provided representing the thresholds of quantizing argument from data
    /// type float32 to int8. The final outputs contain the convolution result in int32, and min
    /// and max thresholds representing the threholds for quantizing the float32 output into int32.
    /// 
    /// .. Note::
    ///     This operator only supports forward propogation. DO NOT use it in training.
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\quantization\quantized_conv.cc:L137</summary>
    /// <param name="data">Input data.</param>
    /// <param name="weight">weight.</param>
    /// <param name="bias">bias.</param>
    /// <param name="minData">Minimum value of data.</param>
    /// <param name="maxData">Maximum value of data.</param>
    /// <param name="minWeight">Minimum value of weight.</param>
    /// <param name="maxWeight">Maximum value of weight.</param>
    /// <param name="minBias">Minimum value of bias.</param>
    /// <param name="maxBias">Maximum value of bias.</param>
    /// <param name="kernel">Convolution kernel size: (w,), (h, w) or (d, h, w)</param>
    /// <param name="numFilter">Convolution filter(channel) number</param>
    /// <param name="stride">Convolution stride: (w,), (h, w) or (d, h, w). Defaults to 1 for each dimension.</param>
    /// <param name="dilate">Convolution dilate: (w,), (h, w) or (d, h, w). Defaults to 1 for each dimension.</param>
    /// <param name="pad">Zero pad for convolution: (w,), (h, w) or (d, h, w). Defaults to no padding.</param>
    /// <param name="numGroup">Number of group partitions.</param>
    /// <param name="workspace">Maximum temporary workspace allowed (MB) in convolution.This parameter has two usages. When CUDNN is not used, it determines the effective batch size of the convolution kernel. When CUDNN is used, it controls the maximum temporary storage used for tuning the best CUDNN kernel when `limited_workspace` strategy is used.</param>
    /// <param name="noBias">Whether to disable bias parameter.</param>
    /// <param name="cudnnTune">Whether to pick convolution algo by running performance test.</param>
    /// <param name="cudnnOff">Turn off cudnn for this layer.</param>
    /// <param name="layout">Set layout for input, output and weight. Empty for
    ///     default layout: NCW for 1d, NCHW for 2d and NCDHW for 3d.NHWC and NDHWC are only supported on GPU.</param>
    static member ContribQuantizedConv(data : Symbol, weight : Symbol, bias : Symbol, minData : Symbol, maxData : Symbol, minWeight : Symbol, maxWeight : Symbol, minBias : Symbol, maxBias : Symbol, kernel : int seq, numFilter : int, [<Optional>] ?stride : int seq, [<Optional>] ?dilate : int seq, [<Optional>] ?pad : int seq, [<Optional>] ?numGroup : int, [<Optional>] ?workspace : int64, [<Optional>] ?noBias : bool, [<Optional>] ?cudnnTune : CudnnTune, [<Optional>] ?cudnnOff : bool, [<Optional>] ?layout : ContribQuantizedConvLayout) =
        ContribQuantizedConv(data, weight, bias, minData, maxData, minWeight, maxWeight, minBias, maxBias, kernel, numFilter, ?stride = stride, ?dilate = dilate, ?pad = pad, ?numGroup = numGroup, ?workspace = workspace, ?noBias = noBias, ?cudnnTune = cudnnTune, ?cudnnOff = cudnnOff, ?layout = layout)
    /// <summary>Convolution operator for input, weight and bias data type of int8,
    /// and accumulates in type int32 for the output. For each argument, two more arguments of type
    /// float32 must be provided representing the thresholds of quantizing argument from data
    /// type float32 to int8. The final outputs contain the convolution result in int32, and min
    /// and max thresholds representing the threholds for quantizing the float32 output into int32.
    /// 
    /// .. Note::
    ///     This operator only supports forward propogation. DO NOT use it in training.
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\quantization\quantized_conv.cc:L137</summary>
    /// <param name="kernel">Convolution kernel size: (w,), (h, w) or (d, h, w)</param>
    /// <param name="numFilter">Convolution filter(channel) number</param>
    /// <param name="data">Input data.</param>
    /// <param name="weight">weight.</param>
    /// <param name="bias">bias.</param>
    /// <param name="minData">Minimum value of data.</param>
    /// <param name="maxData">Maximum value of data.</param>
    /// <param name="minWeight">Minimum value of weight.</param>
    /// <param name="maxWeight">Maximum value of weight.</param>
    /// <param name="minBias">Minimum value of bias.</param>
    /// <param name="maxBias">Maximum value of bias.</param>
    /// <param name="stride">Convolution stride: (w,), (h, w) or (d, h, w). Defaults to 1 for each dimension.</param>
    /// <param name="dilate">Convolution dilate: (w,), (h, w) or (d, h, w). Defaults to 1 for each dimension.</param>
    /// <param name="pad">Zero pad for convolution: (w,), (h, w) or (d, h, w). Defaults to no padding.</param>
    /// <param name="numGroup">Number of group partitions.</param>
    /// <param name="workspace">Maximum temporary workspace allowed (MB) in convolution.This parameter has two usages. When CUDNN is not used, it determines the effective batch size of the convolution kernel. When CUDNN is used, it controls the maximum temporary storage used for tuning the best CUDNN kernel when `limited_workspace` strategy is used.</param>
    /// <param name="noBias">Whether to disable bias parameter.</param>
    /// <param name="cudnnTune">Whether to pick convolution algo by running performance test.</param>
    /// <param name="cudnnOff">Turn off cudnn for this layer.</param>
    /// <param name="layout">Set layout for input, output and weight. Empty for
    ///     default layout: NCW for 1d, NCHW for 2d and NCDHW for 3d.NHWC and NDHWC are only supported on GPU.</param>
    static member ContribQuantizedConv(kernel : int seq, numFilter : int, [<Optional>] ?data : Symbol, [<Optional>] ?weight : Symbol, [<Optional>] ?bias : Symbol, [<Optional>] ?minData : Symbol, [<Optional>] ?maxData : Symbol, [<Optional>] ?minWeight : Symbol, [<Optional>] ?maxWeight : Symbol, [<Optional>] ?minBias : Symbol, [<Optional>] ?maxBias : Symbol, [<Optional>] ?stride : int seq, [<Optional>] ?dilate : int seq, [<Optional>] ?pad : int seq, [<Optional>] ?numGroup : int, [<Optional>] ?workspace : int64, [<Optional>] ?noBias : bool, [<Optional>] ?cudnnTune : CudnnTune, [<Optional>] ?cudnnOff : bool, [<Optional>] ?layout : ContribQuantizedConvLayout) =
        ContribQuantizedConv(kernel, numFilter, ?data = data, ?weight = weight, ?bias = bias, ?minData = minData, ?maxData = maxData, ?minWeight = minWeight, ?maxWeight = maxWeight, ?minBias = minBias, ?maxBias = maxBias, ?stride = stride, ?dilate = dilate, ?pad = pad, ?numGroup = numGroup, ?workspace = workspace, ?noBias = noBias, ?cudnnTune = cudnnTune, ?cudnnOff = cudnnOff, ?layout = layout)

    /// <summary>elemwise_add operator for input dataA and input dataB data type of int8,
    /// and accumulates in type int32 for the output. For each argument, two more arguments of type
    /// float32 must be provided representing the thresholds of quantizing argument from data
    /// type float32 to int8. The final outputs contain result in int32, and min
    /// and max thresholds representing the threholds for quantizing the float32 output into int32.
    /// 
    /// .. Note::
    ///     This operator only supports forward propogation. DO NOT use it in training.
    /// 
    /// </summary>
    /// <param name="lhs">first input</param>
    /// <param name="rhs">second input</param>
    /// <param name="lhsMin">3rd input</param>
    /// <param name="lhsMax">4th input</param>
    /// <param name="rhsMin">5th input</param>
    /// <param name="rhsMax">6th input</param>
    /// <param name="minCalibRange">The minimum scalar value in the form of float32 obtained through calibration. If present, it will be used to requantize the int8 output data.</param>
    /// <param name="maxCalibRange">The maximum scalar value in the form of float32 obtained through calibration. If present, it will be used to requantize the int8 output data.</param>
    static member ContribQuantizedElemwiseAdd(lhs : NDArray, 
                                              rhs : NDArray, 
                                              lhsMin : NDArray, 
                                              lhsMax : NDArray, 
                                              rhsMin : NDArray, 
                                              rhsMax : NDArray, 
                                              [<Optional>] ?minCalibRange : float, 
                                              [<Optional>] ?maxCalibRange : float) =
        let creator = AtomicSymbolCreator.FromName "_contrib_quantized_elemwise_add"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg lhs)) then lhs.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg rhs)) then rhs.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg lhsMin)) then lhsMin.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg lhsMax)) then lhsMax.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg rhsMin)) then rhsMin.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg rhsMax)) then rhsMax.UnsafeHandle|]
                                                 [|"min_calib_range"; "max_calib_range"|]
                                                 [|(match minCalibRange with None -> "None" | Some minCalibRange -> string minCalibRange); (match maxCalibRange with None -> "None" | Some maxCalibRange -> string maxCalibRange)|]
        (new NDArray(outputs.[0])), (new NDArray(outputs.[1])), (new NDArray(outputs.[2]))
    /// <summary>elemwise_add operator for input dataA and input dataB data type of int8,
    /// and accumulates in type int32 for the output. For each argument, two more arguments of type
    /// float32 must be provided representing the thresholds of quantizing argument from data
    /// type float32 to int8. The final outputs contain result in int32, and min
    /// and max thresholds representing the threholds for quantizing the float32 output into int32.
    /// 
    /// .. Note::
    ///     This operator only supports forward propogation. DO NOT use it in training.
    /// 
    /// </summary>
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="lhs">first input</param>
    /// <param name="rhs">second input</param>
    /// <param name="lhsMin">3rd input</param>
    /// <param name="lhsMax">4th input</param>
    /// <param name="rhsMin">5th input</param>
    /// <param name="rhsMax">6th input</param>
    /// <param name="minCalibRange">The minimum scalar value in the form of float32 obtained through calibration. If present, it will be used to requantize the int8 output data.</param>
    /// <param name="maxCalibRange">The maximum scalar value in the form of float32 obtained through calibration. If present, it will be used to requantize the int8 output data.</param>
    static member ContribQuantizedElemwiseAdd(outputArray : NDArray seq, 
                                              lhs : NDArray, 
                                              rhs : NDArray, 
                                              lhsMin : NDArray, 
                                              lhsMax : NDArray, 
                                              rhsMin : NDArray, 
                                              rhsMax : NDArray, 
                                              [<Optional>] ?minCalibRange : float, 
                                              [<Optional>] ?maxCalibRange : float) =
        let creator = AtomicSymbolCreator.FromName "_contrib_quantized_elemwise_add"
        let names = [|"min_calib_range"; "max_calib_range"|]
        let vals = [|(match minCalibRange with None -> "None" | Some minCalibRange -> string minCalibRange); (match maxCalibRange with None -> "None" | Some maxCalibRange -> string maxCalibRange)|]
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg lhs)) then lhs.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg rhs)) then rhs.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg lhsMin)) then lhsMin.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg lhsMax)) then lhsMax.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg rhsMin)) then rhsMin.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg rhsMax)) then rhsMax.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <summary>elemwise_add operator for input dataA and input dataB data type of int8,
    /// and accumulates in type int32 for the output. For each argument, two more arguments of type
    /// float32 must be provided representing the thresholds of quantizing argument from data
    /// type float32 to int8. The final outputs contain result in int32, and min
    /// and max thresholds representing the threholds for quantizing the float32 output into int32.
    /// 
    /// .. Note::
    ///     This operator only supports forward propogation. DO NOT use it in training.
    /// 
    /// </summary>
    /// <param name="lhs">first input</param>
    /// <param name="rhs">second input</param>
    /// <param name="lhsMin">3rd input</param>
    /// <param name="lhsMax">4th input</param>
    /// <param name="rhsMin">5th input</param>
    /// <param name="rhsMax">6th input</param>
    /// <param name="minCalibRange">The minimum scalar value in the form of float32 obtained through calibration. If present, it will be used to requantize the int8 output data.</param>
    /// <param name="maxCalibRange">The maximum scalar value in the form of float32 obtained through calibration. If present, it will be used to requantize the int8 output data.</param>
    static member ContribQuantizedElemwiseAdd([<Optional>] ?lhs : Symbol, [<Optional>] ?rhs : Symbol, [<Optional>] ?lhsMin : Symbol, [<Optional>] ?lhsMax : Symbol, [<Optional>] ?rhsMin : Symbol, [<Optional>] ?rhsMax : Symbol, [<Optional>] ?minCalibRange : float, [<Optional>] ?maxCalibRange : float) =
        ContribQuantizedElemwiseAdd(?lhs = lhs, ?rhs = rhs, ?lhsMin = lhsMin, ?lhsMax = lhsMax, ?rhsMin = rhsMin, ?rhsMax = rhsMax, ?minCalibRange = minCalibRange, ?maxCalibRange = maxCalibRange)

    /// <param name="data">A ndarray/symbol of type `float32`</param>
    /// <param name="minData">The minimum scalar value possibly produced for the data</param>
    /// <param name="maxData">The maximum scalar value possibly produced for the data</param>
    static member ContribQuantizedFlatten(data : NDArray, minData : NDArray, maxData : NDArray) =
        let creator = AtomicSymbolCreator.FromName "_contrib_quantized_flatten"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg minData)) then minData.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg maxData)) then maxData.UnsafeHandle|]
                                                 Array.empty
                                                 Array.empty
        outputs |> Array.map (fun h -> new NDArray(h))
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="data">A ndarray/symbol of type `float32`</param>
    /// <param name="minData">The minimum scalar value possibly produced for the data</param>
    /// <param name="maxData">The maximum scalar value possibly produced for the data</param>
    static member ContribQuantizedFlatten(outputArray : NDArray seq, data : NDArray, minData : NDArray, maxData : NDArray) =
        let creator = AtomicSymbolCreator.FromName "_contrib_quantized_flatten"
        let names = Array.empty
        let vals = Array.empty
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg minData)) then minData.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg maxData)) then maxData.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <param name="data">A ndarray/symbol of type `float32`</param>
    /// <param name="minData">The minimum scalar value possibly produced for the data</param>
    /// <param name="maxData">The maximum scalar value possibly produced for the data</param>
    static member ContribQuantizedFlatten([<Optional>] ?data : Symbol, [<Optional>] ?minData : Symbol, [<Optional>] ?maxData : Symbol) =
        ContribQuantizedFlatten(?data = data, ?minData = minData, ?maxData = maxData)

    /// <summary>Pooling operator for input and output data type of int8.
    /// The input and output data comes with min and max thresholds for quantizing
    /// the float32 data into int8.
    /// 
    /// .. Note::
    ///     This operator only supports forward propogation. DO NOT use it in training.
    ///     This operator only supports `pool_type` of `avg` or `max`.
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\quantization\quantized_pooling.cc:L145</summary>
    /// <param name="data">Input data.</param>
    /// <param name="minData">Minimum value of data.</param>
    /// <param name="maxData">Maximum value of data.</param>
    /// <param name="kernel">Pooling kernel size: (y, x) or (d, y, x)</param>
    /// <param name="poolType">Pooling type to be applied.</param>
    /// <param name="globalPool">Ignore kernel size, do global pooling based on current input feature map. </param>
    /// <param name="cudnnOff">Turn off cudnn pooling and use MXNet pooling operator. </param>
    /// <param name="poolingConvention">Pooling convention to be applied.</param>
    /// <param name="stride">Stride: for pooling (y, x) or (d, y, x). Defaults to 1 for each dimension.</param>
    /// <param name="pad">Pad for pooling: (y, x) or (d, y, x). Defaults to no padding.</param>
    /// <param name="pValue">Value of p for Lp pooling, can be 1 or 2, required for Lp Pooling.</param>
    /// <param name="countIncludePad">Only used for AvgPool, specify whether to count padding elements for averagecalculation. For example, with a 5*5 kernel on a 3*3 corner of a image,the sum of the 9 valid elements will be divided by 25 if this is set to true,or it will be divided by 9 if this is set to false. Defaults to true.</param>
    /// <param name="layout">Set layout for input and output. Empty for
    ///     default layout: NCW for 1d, NCHW for 2d and NCDHW for 3d.</param>
    static member ContribQuantizedPooling(data : NDArray, 
                                          minData : NDArray, 
                                          maxData : NDArray, 
                                          [<Optional>] ?kernel : int seq, 
                                          [<Optional>] ?poolType : PoolType, 
                                          [<Optional>] ?globalPool : bool, 
                                          [<Optional>] ?cudnnOff : bool, 
                                          [<Optional>] ?poolingConvention : PoolingConvention, 
                                          [<Optional>] ?stride : int seq, 
                                          [<Optional>] ?pad : int seq, 
                                          [<Optional>] ?pValue : int, 
                                          [<Optional>] ?countIncludePad : bool, 
                                          [<Optional>] ?layout : ContribQuantizedPoolingLayout) =
        let creator = AtomicSymbolCreator.FromName "_contrib_quantized_pooling"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg minData)) then minData.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg maxData)) then maxData.UnsafeHandle|]
                                                 [|"kernel"; "pool_type"; "global_pool"; "cudnn_off"; "pooling_convention"; "stride"; "pad"; "p_value"; "count_include_pad"; "layout"|]
                                                 [|(match kernel with None -> "[]" | Some kernel -> (kernel |> Seq.map string |> String.concat ", " |> sprintf "[%s]")); (match poolType with None -> "max" | Some poolType -> string poolType); (match globalPool with None -> "false" | Some globalPool -> string globalPool); (match cudnnOff with None -> "false" | Some cudnnOff -> string cudnnOff); (match poolingConvention with None -> "valid" | Some poolingConvention -> string poolingConvention); (match stride with None -> "[]" | Some stride -> (stride |> Seq.map string |> String.concat ", " |> sprintf "[%s]")); (match pad with None -> "[]" | Some pad -> (pad |> Seq.map string |> String.concat ", " |> sprintf "[%s]")); (match pValue with None -> "None" | Some pValue -> string pValue); (match countIncludePad with None -> "None" | Some countIncludePad -> string countIncludePad); (match layout with None -> "None" | Some layout -> string layout)|]
        (new NDArray(outputs.[0])), (new NDArray(outputs.[1])), (new NDArray(outputs.[2]))
    /// <summary>Pooling operator for input and output data type of int8.
    /// The input and output data comes with min and max thresholds for quantizing
    /// the float32 data into int8.
    /// 
    /// .. Note::
    ///     This operator only supports forward propogation. DO NOT use it in training.
    ///     This operator only supports `pool_type` of `avg` or `max`.
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\quantization\quantized_pooling.cc:L145</summary>
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="data">Input data.</param>
    /// <param name="minData">Minimum value of data.</param>
    /// <param name="maxData">Maximum value of data.</param>
    /// <param name="kernel">Pooling kernel size: (y, x) or (d, y, x)</param>
    /// <param name="poolType">Pooling type to be applied.</param>
    /// <param name="globalPool">Ignore kernel size, do global pooling based on current input feature map. </param>
    /// <param name="cudnnOff">Turn off cudnn pooling and use MXNet pooling operator. </param>
    /// <param name="poolingConvention">Pooling convention to be applied.</param>
    /// <param name="stride">Stride: for pooling (y, x) or (d, y, x). Defaults to 1 for each dimension.</param>
    /// <param name="pad">Pad for pooling: (y, x) or (d, y, x). Defaults to no padding.</param>
    /// <param name="pValue">Value of p for Lp pooling, can be 1 or 2, required for Lp Pooling.</param>
    /// <param name="countIncludePad">Only used for AvgPool, specify whether to count padding elements for averagecalculation. For example, with a 5*5 kernel on a 3*3 corner of a image,the sum of the 9 valid elements will be divided by 25 if this is set to true,or it will be divided by 9 if this is set to false. Defaults to true.</param>
    /// <param name="layout">Set layout for input and output. Empty for
    ///     default layout: NCW for 1d, NCHW for 2d and NCDHW for 3d.</param>
    static member ContribQuantizedPooling(outputArray : NDArray seq, 
                                          data : NDArray, 
                                          minData : NDArray, 
                                          maxData : NDArray, 
                                          [<Optional>] ?kernel : int seq, 
                                          [<Optional>] ?poolType : PoolType, 
                                          [<Optional>] ?globalPool : bool, 
                                          [<Optional>] ?cudnnOff : bool, 
                                          [<Optional>] ?poolingConvention : PoolingConvention, 
                                          [<Optional>] ?stride : int seq, 
                                          [<Optional>] ?pad : int seq, 
                                          [<Optional>] ?pValue : int, 
                                          [<Optional>] ?countIncludePad : bool, 
                                          [<Optional>] ?layout : ContribQuantizedPoolingLayout) =
        let creator = AtomicSymbolCreator.FromName "_contrib_quantized_pooling"
        let names = [|"kernel"; "pool_type"; "global_pool"; "cudnn_off"; "pooling_convention"; "stride"; "pad"; "p_value"; "count_include_pad"; "layout"|]
        let vals = [|(match kernel with None -> "[]" | Some kernel -> (kernel |> Seq.map string |> String.concat ", " |> sprintf "[%s]")); (match poolType with None -> "max" | Some poolType -> string poolType); (match globalPool with None -> "false" | Some globalPool -> string globalPool); (match cudnnOff with None -> "false" | Some cudnnOff -> string cudnnOff); (match poolingConvention with None -> "valid" | Some poolingConvention -> string poolingConvention); (match stride with None -> "[]" | Some stride -> (stride |> Seq.map string |> String.concat ", " |> sprintf "[%s]")); (match pad with None -> "[]" | Some pad -> (pad |> Seq.map string |> String.concat ", " |> sprintf "[%s]")); (match pValue with None -> "None" | Some pValue -> string pValue); (match countIncludePad with None -> "None" | Some countIncludePad -> string countIncludePad); (match layout with None -> "None" | Some layout -> string layout)|]
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg minData)) then minData.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg maxData)) then maxData.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <summary>Pooling operator for input and output data type of int8.
    /// The input and output data comes with min and max thresholds for quantizing
    /// the float32 data into int8.
    /// 
    /// .. Note::
    ///     This operator only supports forward propogation. DO NOT use it in training.
    ///     This operator only supports `pool_type` of `avg` or `max`.
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\quantization\quantized_pooling.cc:L145</summary>
    /// <param name="data">Input data.</param>
    /// <param name="minData">Minimum value of data.</param>
    /// <param name="maxData">Maximum value of data.</param>
    /// <param name="kernel">Pooling kernel size: (y, x) or (d, y, x)</param>
    /// <param name="poolType">Pooling type to be applied.</param>
    /// <param name="globalPool">Ignore kernel size, do global pooling based on current input feature map. </param>
    /// <param name="cudnnOff">Turn off cudnn pooling and use MXNet pooling operator. </param>
    /// <param name="poolingConvention">Pooling convention to be applied.</param>
    /// <param name="stride">Stride: for pooling (y, x) or (d, y, x). Defaults to 1 for each dimension.</param>
    /// <param name="pad">Pad for pooling: (y, x) or (d, y, x). Defaults to no padding.</param>
    /// <param name="pValue">Value of p for Lp pooling, can be 1 or 2, required for Lp Pooling.</param>
    /// <param name="countIncludePad">Only used for AvgPool, specify whether to count padding elements for averagecalculation. For example, with a 5*5 kernel on a 3*3 corner of a image,the sum of the 9 valid elements will be divided by 25 if this is set to true,or it will be divided by 9 if this is set to false. Defaults to true.</param>
    /// <param name="layout">Set layout for input and output. Empty for
    ///     default layout: NCW for 1d, NCHW for 2d and NCDHW for 3d.</param>
    static member ContribQuantizedPooling([<Optional>] ?data : Symbol, [<Optional>] ?minData : Symbol, [<Optional>] ?maxData : Symbol, [<Optional>] ?kernel : int seq, [<Optional>] ?poolType : PoolType, [<Optional>] ?globalPool : bool, [<Optional>] ?cudnnOff : bool, [<Optional>] ?poolingConvention : PoolingConvention, [<Optional>] ?stride : int seq, [<Optional>] ?pad : int seq, [<Optional>] ?pValue : int, [<Optional>] ?countIncludePad : bool, [<Optional>] ?layout : ContribQuantizedPoolingLayout) =
        ContribQuantizedPooling(?data = data, ?minData = minData, ?maxData = maxData, ?kernel = kernel, ?poolType = poolType, ?globalPool = globalPool, ?cudnnOff = cudnnOff, ?poolingConvention = poolingConvention, ?stride = stride, ?pad = pad, ?pValue = pValue, ?countIncludePad = countIncludePad, ?layout = layout)

    /// <summary>Quantize a input tensor from float to `out_type`,
    /// with user-specified `min_range` and `max_range`.
    /// 
    /// min_range and max_range are scalar floats that specify the range for
    /// the input data.
    /// 
    /// When out_type is `uint8`, the output is calculated using the following equation:
    /// 
    /// `out[i] = (in[i] - min_range) * range(OUTPUT_TYPE) / (max_range - min_range) + 0.5`,
    /// 
    /// where `range(T) = numeric_limits&lt;T&gt;::max() - numeric_limits&lt;T&gt;::min()`.
    /// 
    /// When out_type is `int8`, the output is calculate using the following equation
    /// by keep zero centered for the quantized value:
    /// 
    /// `out[i] = sign(in[i]) * min(abs(in[i] * scale + 0.5f, quantized_range)`,
    /// 
    /// where
    /// `quantized_range = MinAbs(max(int8), min(int8))` and
    /// `scale = quantized_range / MaxAbs(min_range, max_range).`
    /// 
    /// .. Note::
    ///     This operator only supports forward propagation. DO NOT use it in training.
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\quantization\quantize.cc:L74</summary>
    /// <param name="data">A ndarray/symbol of type `float32`</param>
    /// <param name="minRange">The minimum scalar value possibly produced for the input</param>
    /// <param name="maxRange">The maximum scalar value possibly produced for the input</param>
    /// <param name="outType">Output data type.</param>
    static member ContribQuantize(data : NDArray, minRange : NDArray, maxRange : NDArray, [<Optional>] outType : ContribQuantizeOutType) =
        let creator = AtomicSymbolCreator.FromName "_contrib_quantize"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg minRange)) then minRange.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg maxRange)) then maxRange.UnsafeHandle|]
                                                 [|"out_type"|]
                                                 [|(if isNull (outType :> obj) then "uint8" else string outType)|]
        (new NDArray(outputs.[0])), (new NDArray(outputs.[1])), (new NDArray(outputs.[2]))
    /// <summary>Quantize a input tensor from float to `out_type`,
    /// with user-specified `min_range` and `max_range`.
    /// 
    /// min_range and max_range are scalar floats that specify the range for
    /// the input data.
    /// 
    /// When out_type is `uint8`, the output is calculated using the following equation:
    /// 
    /// `out[i] = (in[i] - min_range) * range(OUTPUT_TYPE) / (max_range - min_range) + 0.5`,
    /// 
    /// where `range(T) = numeric_limits&lt;T&gt;::max() - numeric_limits&lt;T&gt;::min()`.
    /// 
    /// When out_type is `int8`, the output is calculate using the following equation
    /// by keep zero centered for the quantized value:
    /// 
    /// `out[i] = sign(in[i]) * min(abs(in[i] * scale + 0.5f, quantized_range)`,
    /// 
    /// where
    /// `quantized_range = MinAbs(max(int8), min(int8))` and
    /// `scale = quantized_range / MaxAbs(min_range, max_range).`
    /// 
    /// .. Note::
    ///     This operator only supports forward propagation. DO NOT use it in training.
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\quantization\quantize.cc:L74</summary>
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="data">A ndarray/symbol of type `float32`</param>
    /// <param name="minRange">The minimum scalar value possibly produced for the input</param>
    /// <param name="maxRange">The maximum scalar value possibly produced for the input</param>
    /// <param name="outType">Output data type.</param>
    static member ContribQuantize(outputArray : NDArray seq, data : NDArray, minRange : NDArray, maxRange : NDArray, [<Optional>] outType : ContribQuantizeOutType) =
        let creator = AtomicSymbolCreator.FromName "_contrib_quantize"
        let names = [|"out_type"|]
        let vals = [|(if isNull (outType :> obj) then "uint8" else string outType)|]
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg minRange)) then minRange.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg maxRange)) then maxRange.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <summary>Quantize a input tensor from float to `out_type`,
    /// with user-specified `min_range` and `max_range`.
    /// 
    /// min_range and max_range are scalar floats that specify the range for
    /// the input data.
    /// 
    /// When out_type is `uint8`, the output is calculated using the following equation:
    /// 
    /// `out[i] = (in[i] - min_range) * range(OUTPUT_TYPE) / (max_range - min_range) + 0.5`,
    /// 
    /// where `range(T) = numeric_limits&lt;T&gt;::max() - numeric_limits&lt;T&gt;::min()`.
    /// 
    /// When out_type is `int8`, the output is calculate using the following equation
    /// by keep zero centered for the quantized value:
    /// 
    /// `out[i] = sign(in[i]) * min(abs(in[i] * scale + 0.5f, quantized_range)`,
    /// 
    /// where
    /// `quantized_range = MinAbs(max(int8), min(int8))` and
    /// `scale = quantized_range / MaxAbs(min_range, max_range).`
    /// 
    /// .. Note::
    ///     This operator only supports forward propagation. DO NOT use it in training.
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\quantization\quantize.cc:L74</summary>
    /// <param name="data">A ndarray/symbol of type `float32`</param>
    /// <param name="minRange">The minimum scalar value possibly produced for the input</param>
    /// <param name="maxRange">The maximum scalar value possibly produced for the input</param>
    /// <param name="outType">Output data type.</param>
    static member ContribQuantize([<Optional>] ?data : Symbol, [<Optional>] ?minRange : Symbol, [<Optional>] ?maxRange : Symbol, [<Optional>] ?outType : ContribQuantizeOutType) =
        ContribQuantize(?data = data, ?minRange = minRange, ?maxRange = maxRange, ?outType = outType)

    /// <summary>Quantize a input tensor from float to `out_type`,
    /// with user-specified `min_calib_range` and `max_calib_range` or the input range collected at runtime.
    /// 
    /// Output `min_range` and `max_range` are scalar floats that specify the range for the input data.
    /// 
    /// When out_type is `uint8`, the output is calculated using the following equation:
    /// 
    /// `out[i] = (in[i] - min_range) * range(OUTPUT_TYPE) / (max_range - min_range) + 0.5`,
    /// 
    /// where `range(T) = numeric_limits&lt;T&gt;::max() - numeric_limits&lt;T&gt;::min()`.
    /// 
    /// When out_type is `int8`, the output is calculate using the following equation
    /// by keep zero centered for the quantized value:
    /// 
    /// `out[i] = sign(in[i]) * min(abs(in[i] * scale + 0.5f, quantized_range)`,
    /// 
    /// where
    /// `quantized_range = MinAbs(max(int8), min(int8))` and
    /// `scale = quantized_range / MaxAbs(min_range, max_range).`
    /// 
    /// When out_type is `auto`, the output type is automatically determined by min_calib_range if presented.
    /// If min_calib_range &lt; 0.0f, the output type will be int8, otherwise will be uint8.
    /// If min_calib_range isn&#39;t presented, the output type will be int8.
    /// 
    /// .. Note::
    ///     This operator only supports forward propagation. DO NOT use it in training.
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\quantization\quantize_v2.cc:L92</summary>
    /// <param name="data">A ndarray/symbol of type `float32`</param>
    /// <param name="outType">Output data type. `auto` can be specified to automatically determine output type according to min_calib_range.</param>
    /// <param name="minCalibRange">The minimum scalar value in the form of float32. If present, it will be used to quantize the fp32 data into int8 or uint8.</param>
    /// <param name="maxCalibRange">The maximum scalar value in the form of float32. If present, it will be used to quantize the fp32 data into int8 or uint8.</param>
    static member ContribQuantizeV2(data : NDArray, [<Optional>] ?outType : ContribQuantizeV2OutType, [<Optional>] ?minCalibRange : float, [<Optional>] ?maxCalibRange : float) =
        let creator = AtomicSymbolCreator.FromName "_contrib_quantize_v2"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle|]
                                                 [|"out_type"; "min_calib_range"; "max_calib_range"|]
                                                 [|(match outType with None -> "int8" | Some outType -> string outType); (match minCalibRange with None -> "None" | Some minCalibRange -> string minCalibRange); (match maxCalibRange with None -> "None" | Some maxCalibRange -> string maxCalibRange)|]
        (new NDArray(outputs.[0])), (new NDArray(outputs.[1])), (new NDArray(outputs.[2]))
    /// <summary>Quantize a input tensor from float to `out_type`,
    /// with user-specified `min_calib_range` and `max_calib_range` or the input range collected at runtime.
    /// 
    /// Output `min_range` and `max_range` are scalar floats that specify the range for the input data.
    /// 
    /// When out_type is `uint8`, the output is calculated using the following equation:
    /// 
    /// `out[i] = (in[i] - min_range) * range(OUTPUT_TYPE) / (max_range - min_range) + 0.5`,
    /// 
    /// where `range(T) = numeric_limits&lt;T&gt;::max() - numeric_limits&lt;T&gt;::min()`.
    /// 
    /// When out_type is `int8`, the output is calculate using the following equation
    /// by keep zero centered for the quantized value:
    /// 
    /// `out[i] = sign(in[i]) * min(abs(in[i] * scale + 0.5f, quantized_range)`,
    /// 
    /// where
    /// `quantized_range = MinAbs(max(int8), min(int8))` and
    /// `scale = quantized_range / MaxAbs(min_range, max_range).`
    /// 
    /// When out_type is `auto`, the output type is automatically determined by min_calib_range if presented.
    /// If min_calib_range &lt; 0.0f, the output type will be int8, otherwise will be uint8.
    /// If min_calib_range isn&#39;t presented, the output type will be int8.
    /// 
    /// .. Note::
    ///     This operator only supports forward propagation. DO NOT use it in training.
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\quantization\quantize_v2.cc:L92</summary>
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="data">A ndarray/symbol of type `float32`</param>
    /// <param name="outType">Output data type. `auto` can be specified to automatically determine output type according to min_calib_range.</param>
    /// <param name="minCalibRange">The minimum scalar value in the form of float32. If present, it will be used to quantize the fp32 data into int8 or uint8.</param>
    /// <param name="maxCalibRange">The maximum scalar value in the form of float32. If present, it will be used to quantize the fp32 data into int8 or uint8.</param>
    static member ContribQuantizeV2(outputArray : NDArray seq, data : NDArray, [<Optional>] ?outType : ContribQuantizeV2OutType, [<Optional>] ?minCalibRange : float, [<Optional>] ?maxCalibRange : float) =
        let creator = AtomicSymbolCreator.FromName "_contrib_quantize_v2"
        let names = [|"out_type"; "min_calib_range"; "max_calib_range"|]
        let vals = [|(match outType with None -> "int8" | Some outType -> string outType); (match minCalibRange with None -> "None" | Some minCalibRange -> string minCalibRange); (match maxCalibRange with None -> "None" | Some maxCalibRange -> string maxCalibRange)|]
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <summary>Quantize a input tensor from float to `out_type`,
    /// with user-specified `min_calib_range` and `max_calib_range` or the input range collected at runtime.
    /// 
    /// Output `min_range` and `max_range` are scalar floats that specify the range for the input data.
    /// 
    /// When out_type is `uint8`, the output is calculated using the following equation:
    /// 
    /// `out[i] = (in[i] - min_range) * range(OUTPUT_TYPE) / (max_range - min_range) + 0.5`,
    /// 
    /// where `range(T) = numeric_limits&lt;T&gt;::max() - numeric_limits&lt;T&gt;::min()`.
    /// 
    /// When out_type is `int8`, the output is calculate using the following equation
    /// by keep zero centered for the quantized value:
    /// 
    /// `out[i] = sign(in[i]) * min(abs(in[i] * scale + 0.5f, quantized_range)`,
    /// 
    /// where
    /// `quantized_range = MinAbs(max(int8), min(int8))` and
    /// `scale = quantized_range / MaxAbs(min_range, max_range).`
    /// 
    /// When out_type is `auto`, the output type is automatically determined by min_calib_range if presented.
    /// If min_calib_range &lt; 0.0f, the output type will be int8, otherwise will be uint8.
    /// If min_calib_range isn&#39;t presented, the output type will be int8.
    /// 
    /// .. Note::
    ///     This operator only supports forward propagation. DO NOT use it in training.
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\quantization\quantize_v2.cc:L92</summary>
    /// <param name="data">A ndarray/symbol of type `float32`</param>
    /// <param name="outType">Output data type. `auto` can be specified to automatically determine output type according to min_calib_range.</param>
    /// <param name="minCalibRange">The minimum scalar value in the form of float32. If present, it will be used to quantize the fp32 data into int8 or uint8.</param>
    /// <param name="maxCalibRange">The maximum scalar value in the form of float32. If present, it will be used to quantize the fp32 data into int8 or uint8.</param>
    static member ContribQuantizeV2([<Optional>] ?data : Symbol, [<Optional>] ?outType : ContribQuantizeV2OutType, [<Optional>] ?minCalibRange : float, [<Optional>] ?maxCalibRange : float) =
        ContribQuantizeV2(?data = data, ?outType = outType, ?minCalibRange = minCalibRange, ?maxCalibRange = maxCalibRange)

    /// <summary>Flattens the input array into a 2-D array by collapsing the higher dimensions.
    /// .. note:: `Flatten` is deprecated. Use `flatten` instead.
    /// For an input array with shape ``(d1, d2, ..., dk)``, `flatten` operation reshapes
    /// the input array into an output array of shape ``(d1, d2*...*dk)``.
    /// Note that the behavior of this function is different from numpy.ndarray.flatten,
    /// which behaves similar to mxnet.ndarray.reshape((-1,)).
    /// Example::
    ///     x = [[
    ///         [1,2,3],
    ///         [4,5,6],
    ///         [7,8,9]
    ///     ],
    ///     [    [1,2,3],
    ///         [4,5,6],
    ///         [7,8,9]
    ///     ]],
    ///     flatten(x) = [[ 1.,  2.,  3.,  4.,  5.,  6.,  7.,  8.,  9.],
    ///        [ 1.,  2.,  3.,  4.,  5.,  6.,  7.,  8.,  9.]]
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\matrix_op.cc:L250</summary>
    /// <param name="data">Input array.</param>
    static member Flatten(data : NDArray) =
        let creator = AtomicSymbolCreator.FromName "Flatten"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle|]
                                                 Array.empty
                                                 Array.empty
        (new NDArray(outputs.[0]))
    /// <summary>Flattens the input array into a 2-D array by collapsing the higher dimensions.
    /// .. note:: `Flatten` is deprecated. Use `flatten` instead.
    /// For an input array with shape ``(d1, d2, ..., dk)``, `flatten` operation reshapes
    /// the input array into an output array of shape ``(d1, d2*...*dk)``.
    /// Note that the behavior of this function is different from numpy.ndarray.flatten,
    /// which behaves similar to mxnet.ndarray.reshape((-1,)).
    /// Example::
    ///     x = [[
    ///         [1,2,3],
    ///         [4,5,6],
    ///         [7,8,9]
    ///     ],
    ///     [    [1,2,3],
    ///         [4,5,6],
    ///         [7,8,9]
    ///     ]],
    ///     flatten(x) = [[ 1.,  2.,  3.,  4.,  5.,  6.,  7.,  8.,  9.],
    ///        [ 1.,  2.,  3.,  4.,  5.,  6.,  7.,  8.,  9.]]
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\matrix_op.cc:L250</summary>
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="data">Input array.</param>
    static member Flatten(outputArray : NDArray seq, data : NDArray) =
        let creator = AtomicSymbolCreator.FromName "Flatten"
        let names = Array.empty
        let vals = Array.empty
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <summary>Flattens the input array into a 2-D array by collapsing the higher dimensions.
    /// .. note:: `Flatten` is deprecated. Use `flatten` instead.
    /// For an input array with shape ``(d1, d2, ..., dk)``, `flatten` operation reshapes
    /// the input array into an output array of shape ``(d1, d2*...*dk)``.
    /// Note that the behavior of this function is different from numpy.ndarray.flatten,
    /// which behaves similar to mxnet.ndarray.reshape((-1,)).
    /// Example::
    ///     x = [[
    ///         [1,2,3],
    ///         [4,5,6],
    ///         [7,8,9]
    ///     ],
    ///     [    [1,2,3],
    ///         [4,5,6],
    ///         [7,8,9]
    ///     ]],
    ///     flatten(x) = [[ 1.,  2.,  3.,  4.,  5.,  6.,  7.,  8.,  9.],
    ///        [ 1.,  2.,  3.,  4.,  5.,  6.,  7.,  8.,  9.]]
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\matrix_op.cc:L250</summary>
    /// <param name="data">Input array.</param>
    static member Flatten([<Optional>] ?data : Symbol) =
        Flatten(?data = data)

    /// <summary>Fully Connected operator for input, weight and bias data type of int8,
    /// and accumulates in type int32 for the output. For each argument, two more arguments of type
    /// float32 must be provided representing the thresholds of quantizing argument from data
    /// type float32 to int8. The final outputs contain the convolution result in int32, and min
    /// and max thresholds representing the threholds for quantizing the float32 output into int32.
    /// 
    /// .. Note::
    ///     This operator only supports forward propogation. DO NOT use it in training.
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\quantization\quantized_fully_connected.cc:L313</summary>
    /// <param name="data">Input data.</param>
    /// <param name="weight">weight.</param>
    /// <param name="bias">bias.</param>
    /// <param name="minData">Minimum value of data.</param>
    /// <param name="maxData">Maximum value of data.</param>
    /// <param name="minWeight">Minimum value of weight.</param>
    /// <param name="maxWeight">Maximum value of weight.</param>
    /// <param name="minBias">Minimum value of bias.</param>
    /// <param name="maxBias">Maximum value of bias.</param>
    /// <param name="numHidden">Number of hidden nodes of the output.</param>
    /// <param name="noBias">Whether to disable bias parameter.</param>
    /// <param name="flatten">Whether to collapse all but the first axis of the input data tensor.</param>
    static member ContribQuantizedFullyConnected(data : NDArray, 
                                                 weight : NDArray, 
                                                 bias : NDArray, 
                                                 minData : NDArray, 
                                                 maxData : NDArray, 
                                                 minWeight : NDArray, 
                                                 maxWeight : NDArray, 
                                                 minBias : NDArray, 
                                                 maxBias : NDArray, 
                                                 numHidden : int, 
                                                 [<Optional; DefaultParameterValue(false)>] noBias : bool, 
                                                 [<Optional; DefaultParameterValue(true)>] flatten : bool) =
        let creator = AtomicSymbolCreator.FromName "_contrib_quantized_fully_connected"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg weight)) then weight.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg bias)) then bias.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg minData)) then minData.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg maxData)) then maxData.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg minWeight)) then minWeight.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg maxWeight)) then maxWeight.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg minBias)) then minBias.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg maxBias)) then maxBias.UnsafeHandle|]
                                                 [|"num_hidden"; "no_bias"; "flatten"|]
                                                 [|string numHidden; string noBias; string flatten|]
        (new NDArray(outputs.[0])), (new NDArray(outputs.[1])), (new NDArray(outputs.[2]))
    /// <summary>Fully Connected operator for input, weight and bias data type of int8,
    /// and accumulates in type int32 for the output. For each argument, two more arguments of type
    /// float32 must be provided representing the thresholds of quantizing argument from data
    /// type float32 to int8. The final outputs contain the convolution result in int32, and min
    /// and max thresholds representing the threholds for quantizing the float32 output into int32.
    /// 
    /// .. Note::
    ///     This operator only supports forward propogation. DO NOT use it in training.
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\quantization\quantized_fully_connected.cc:L313</summary>
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="data">Input data.</param>
    /// <param name="weight">weight.</param>
    /// <param name="bias">bias.</param>
    /// <param name="minData">Minimum value of data.</param>
    /// <param name="maxData">Maximum value of data.</param>
    /// <param name="minWeight">Minimum value of weight.</param>
    /// <param name="maxWeight">Maximum value of weight.</param>
    /// <param name="minBias">Minimum value of bias.</param>
    /// <param name="maxBias">Maximum value of bias.</param>
    /// <param name="numHidden">Number of hidden nodes of the output.</param>
    /// <param name="noBias">Whether to disable bias parameter.</param>
    /// <param name="flatten">Whether to collapse all but the first axis of the input data tensor.</param>
    static member ContribQuantizedFullyConnected(outputArray : NDArray seq, 
                                                 data : NDArray, 
                                                 weight : NDArray, 
                                                 bias : NDArray, 
                                                 minData : NDArray, 
                                                 maxData : NDArray, 
                                                 minWeight : NDArray, 
                                                 maxWeight : NDArray, 
                                                 minBias : NDArray, 
                                                 maxBias : NDArray, 
                                                 numHidden : int, 
                                                 [<Optional; DefaultParameterValue(false)>] noBias : bool, 
                                                 [<Optional; DefaultParameterValue(true)>] flatten : bool) =
        let creator = AtomicSymbolCreator.FromName "_contrib_quantized_fully_connected"
        let names = [|"num_hidden"; "no_bias"; "flatten"|]
        let vals = [|string numHidden; string noBias; string flatten|]
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg weight)) then weight.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg bias)) then bias.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg minData)) then minData.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg maxData)) then maxData.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg minWeight)) then minWeight.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg maxWeight)) then maxWeight.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg minBias)) then minBias.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg maxBias)) then maxBias.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <summary>Fully Connected operator for input, weight and bias data type of int8,
    /// and accumulates in type int32 for the output. For each argument, two more arguments of type
    /// float32 must be provided representing the thresholds of quantizing argument from data
    /// type float32 to int8. The final outputs contain the convolution result in int32, and min
    /// and max thresholds representing the threholds for quantizing the float32 output into int32.
    /// 
    /// .. Note::
    ///     This operator only supports forward propogation. DO NOT use it in training.
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\quantization\quantized_fully_connected.cc:L313</summary>
    /// <param name="data">Input data.</param>
    /// <param name="weight">weight.</param>
    /// <param name="bias">bias.</param>
    /// <param name="minData">Minimum value of data.</param>
    /// <param name="maxData">Maximum value of data.</param>
    /// <param name="minWeight">Minimum value of weight.</param>
    /// <param name="maxWeight">Maximum value of weight.</param>
    /// <param name="minBias">Minimum value of bias.</param>
    /// <param name="maxBias">Maximum value of bias.</param>
    /// <param name="numHidden">Number of hidden nodes of the output.</param>
    /// <param name="noBias">Whether to disable bias parameter.</param>
    /// <param name="flatten">Whether to collapse all but the first axis of the input data tensor.</param>
    static member ContribQuantizedFullyConnected(data : Symbol, weight : Symbol, bias : Symbol, minData : Symbol, maxData : Symbol, minWeight : Symbol, maxWeight : Symbol, minBias : Symbol, maxBias : Symbol, numHidden : int, [<Optional>] ?noBias : bool, [<Optional>] ?flatten : bool) =
        ContribQuantizedFullyConnected(data, weight, bias, minData, maxData, minWeight, maxWeight, minBias, maxBias, numHidden, ?noBias = noBias, ?flatten = flatten)
    /// <summary>Fully Connected operator for input, weight and bias data type of int8,
    /// and accumulates in type int32 for the output. For each argument, two more arguments of type
    /// float32 must be provided representing the thresholds of quantizing argument from data
    /// type float32 to int8. The final outputs contain the convolution result in int32, and min
    /// and max thresholds representing the threholds for quantizing the float32 output into int32.
    /// 
    /// .. Note::
    ///     This operator only supports forward propogation. DO NOT use it in training.
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\quantization\quantized_fully_connected.cc:L313</summary>
    /// <param name="numHidden">Number of hidden nodes of the output.</param>
    /// <param name="data">Input data.</param>
    /// <param name="weight">weight.</param>
    /// <param name="bias">bias.</param>
    /// <param name="minData">Minimum value of data.</param>
    /// <param name="maxData">Maximum value of data.</param>
    /// <param name="minWeight">Minimum value of weight.</param>
    /// <param name="maxWeight">Maximum value of weight.</param>
    /// <param name="minBias">Minimum value of bias.</param>
    /// <param name="maxBias">Maximum value of bias.</param>
    /// <param name="noBias">Whether to disable bias parameter.</param>
    /// <param name="flatten">Whether to collapse all but the first axis of the input data tensor.</param>
    static member ContribQuantizedFullyConnected(numHidden : int, [<Optional>] ?data : Symbol, [<Optional>] ?weight : Symbol, [<Optional>] ?bias : Symbol, [<Optional>] ?minData : Symbol, [<Optional>] ?maxData : Symbol, [<Optional>] ?minWeight : Symbol, [<Optional>] ?maxWeight : Symbol, [<Optional>] ?minBias : Symbol, [<Optional>] ?maxBias : Symbol, [<Optional>] ?noBias : bool, [<Optional>] ?flatten : bool) =
        ContribQuantizedFullyConnected(numHidden, ?data = data, ?weight = weight, ?bias = bias, ?minData = minData, ?maxData = maxData, ?minWeight = minWeight, ?maxWeight = maxWeight, ?minBias = minBias, ?maxBias = maxBias, ?noBias = noBias, ?flatten = flatten)

    /// <summary>Given data that is quantized in int32 and the corresponding thresholds,
    /// requantize the data into int8 using min and max thresholds either calculated at runtime
    /// or from calibration. It&#39;s highly recommended to pre-calucate the min and max thresholds
    /// through calibration since it is able to save the runtime of the operator and improve the
    /// inference accuracy.
    /// 
    /// .. Note::
    ///     This operator only supports forward propogation. DO NOT use it in training.
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\quantization\requantize.cc:L60</summary>
    /// <param name="data">A ndarray/symbol of type `int32`</param>
    /// <param name="minRange">The original minimum scalar value in the form of float32 used for quantizing data into int32.</param>
    /// <param name="maxRange">The original maximum scalar value in the form of float32 used for quantizing data into int32.</param>
    /// <param name="outType">Output data type. `auto` can be specified to automatically determine output type according to min_calib_range.</param>
    /// <param name="minCalibRange">The minimum scalar value in the form of float32 obtained through calibration. If present, it will be used to requantize the int32 data into int8.</param>
    /// <param name="maxCalibRange">The maximum scalar value in the form of float32 obtained through calibration. If present, it will be used to requantize the int32 data into int8.</param>
    static member ContribRequantize(data : NDArray, 
                                    minRange : NDArray, 
                                    maxRange : NDArray, 
                                    [<Optional>] ?outType : ContribRequantizeOutType, 
                                    [<Optional>] ?minCalibRange : float, 
                                    [<Optional>] ?maxCalibRange : float) =
        let creator = AtomicSymbolCreator.FromName "_contrib_requantize"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg minRange)) then minRange.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg maxRange)) then maxRange.UnsafeHandle|]
                                                 [|"out_type"; "min_calib_range"; "max_calib_range"|]
                                                 [|(match outType with None -> "int8" | Some outType -> string outType); (match minCalibRange with None -> "None" | Some minCalibRange -> string minCalibRange); (match maxCalibRange with None -> "None" | Some maxCalibRange -> string maxCalibRange)|]
        (new NDArray(outputs.[0])), (new NDArray(outputs.[1])), (new NDArray(outputs.[2]))
    /// <summary>Given data that is quantized in int32 and the corresponding thresholds,
    /// requantize the data into int8 using min and max thresholds either calculated at runtime
    /// or from calibration. It&#39;s highly recommended to pre-calucate the min and max thresholds
    /// through calibration since it is able to save the runtime of the operator and improve the
    /// inference accuracy.
    /// 
    /// .. Note::
    ///     This operator only supports forward propogation. DO NOT use it in training.
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\quantization\requantize.cc:L60</summary>
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="data">A ndarray/symbol of type `int32`</param>
    /// <param name="minRange">The original minimum scalar value in the form of float32 used for quantizing data into int32.</param>
    /// <param name="maxRange">The original maximum scalar value in the form of float32 used for quantizing data into int32.</param>
    /// <param name="outType">Output data type. `auto` can be specified to automatically determine output type according to min_calib_range.</param>
    /// <param name="minCalibRange">The minimum scalar value in the form of float32 obtained through calibration. If present, it will be used to requantize the int32 data into int8.</param>
    /// <param name="maxCalibRange">The maximum scalar value in the form of float32 obtained through calibration. If present, it will be used to requantize the int32 data into int8.</param>
    static member ContribRequantize(outputArray : NDArray seq, 
                                    data : NDArray, 
                                    minRange : NDArray, 
                                    maxRange : NDArray, 
                                    [<Optional>] ?outType : ContribRequantizeOutType, 
                                    [<Optional>] ?minCalibRange : float, 
                                    [<Optional>] ?maxCalibRange : float) =
        let creator = AtomicSymbolCreator.FromName "_contrib_requantize"
        let names = [|"out_type"; "min_calib_range"; "max_calib_range"|]
        let vals = [|(match outType with None -> "int8" | Some outType -> string outType); (match minCalibRange with None -> "None" | Some minCalibRange -> string minCalibRange); (match maxCalibRange with None -> "None" | Some maxCalibRange -> string maxCalibRange)|]
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg minRange)) then minRange.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg maxRange)) then maxRange.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <summary>Given data that is quantized in int32 and the corresponding thresholds,
    /// requantize the data into int8 using min and max thresholds either calculated at runtime
    /// or from calibration. It&#39;s highly recommended to pre-calucate the min and max thresholds
    /// through calibration since it is able to save the runtime of the operator and improve the
    /// inference accuracy.
    /// 
    /// .. Note::
    ///     This operator only supports forward propogation. DO NOT use it in training.
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\quantization\requantize.cc:L60</summary>
    /// <param name="data">A ndarray/symbol of type `int32`</param>
    /// <param name="minRange">The original minimum scalar value in the form of float32 used for quantizing data into int32.</param>
    /// <param name="maxRange">The original maximum scalar value in the form of float32 used for quantizing data into int32.</param>
    /// <param name="outType">Output data type. `auto` can be specified to automatically determine output type according to min_calib_range.</param>
    /// <param name="minCalibRange">The minimum scalar value in the form of float32 obtained through calibration. If present, it will be used to requantize the int32 data into int8.</param>
    /// <param name="maxCalibRange">The maximum scalar value in the form of float32 obtained through calibration. If present, it will be used to requantize the int32 data into int8.</param>
    static member ContribRequantize([<Optional>] ?data : Symbol, [<Optional>] ?minRange : Symbol, [<Optional>] ?maxRange : Symbol, [<Optional>] ?outType : ContribRequantizeOutType, [<Optional>] ?minCalibRange : float, [<Optional>] ?maxCalibRange : float) =
        ContribRequantize(?data = data, ?minRange = minRange, ?maxRange = maxRange, ?outType = outType, ?minCalibRange = minCalibRange, ?maxCalibRange = maxCalibRange)

    /// <summary>Concurrent sampling from multiple
    /// uniform distributions on the intervals given by *[low,high)*.
    /// 
    /// The parameters of the distributions are provided as input arrays.
    /// Let *[s]* be the shape of the input arrays, *n* be the dimension of *[s]*, *[t]*
    /// be the shape specified as the parameter of the operator, and *m* be the dimension
    /// of *[t]*. Then the output will be a *(n+m)*-dimensional array with shape *[s]x[t]*.
    /// 
    /// For any valid *n*-dimensional index *i* with respect to the input arrays, *output[i]*
    /// will be an *m*-dimensional array that holds randomly drawn samples from the distribution
    /// which is parameterized by the input values at index *i*. If the shape parameter of the
    /// operator is not set, then one sample will be drawn per distribution and the output array
    /// has the same shape as the input arrays.
    /// 
    /// Examples::
    /// 
    ///    low = [ 0.0, 2.5 ]
    ///    high = [ 1.0, 3.7 ]
    /// 
    ///    // Draw a single sample for each distribution
    ///    sample_uniform(low, high) = [ 0.40451524,  3.18687344]
    /// 
    ///    // Draw a vector containing two samples for each distribution
    ///    sample_uniform(low, high, shape=(2)) = [[ 0.40451524,  0.18017688],
    ///                                            [ 3.18687344,  3.68352246]]
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\random\multisample_op.cc:L277</summary>
    /// <param name="low">Lower bounds of the distributions.</param>
    /// <param name="high">Upper bounds of the distributions.</param>
    /// <param name="shape">Shape to be sampled from each random distribution.</param>
    /// <param name="dtype">DType of the output in case this can&#39;t be inferred. Defaults to float32 if not defined (dtype=None).</param>
    static member SampleUniform(low : NDArray, high : NDArray, [<Optional>] shape : int seq, [<Optional>] dtype : FloatDType) =
        let creator = AtomicSymbolCreator.FromName "_sample_uniform"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg low)) then low.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg high)) then high.UnsafeHandle|]
                                                 [|"shape"; "dtype"|]
                                                 [|(if isNull (shape :> obj) then "[]" else (shape |> Seq.map string |> String.concat ", " |> sprintf "[%s]")); (if isNull (dtype :> obj) then "None" else string dtype)|]
        outputs |> Array.map (fun h -> new NDArray(h))
    /// <summary>Concurrent sampling from multiple
    /// uniform distributions on the intervals given by *[low,high)*.
    /// 
    /// The parameters of the distributions are provided as input arrays.
    /// Let *[s]* be the shape of the input arrays, *n* be the dimension of *[s]*, *[t]*
    /// be the shape specified as the parameter of the operator, and *m* be the dimension
    /// of *[t]*. Then the output will be a *(n+m)*-dimensional array with shape *[s]x[t]*.
    /// 
    /// For any valid *n*-dimensional index *i* with respect to the input arrays, *output[i]*
    /// will be an *m*-dimensional array that holds randomly drawn samples from the distribution
    /// which is parameterized by the input values at index *i*. If the shape parameter of the
    /// operator is not set, then one sample will be drawn per distribution and the output array
    /// has the same shape as the input arrays.
    /// 
    /// Examples::
    /// 
    ///    low = [ 0.0, 2.5 ]
    ///    high = [ 1.0, 3.7 ]
    /// 
    ///    // Draw a single sample for each distribution
    ///    sample_uniform(low, high) = [ 0.40451524,  3.18687344]
    /// 
    ///    // Draw a vector containing two samples for each distribution
    ///    sample_uniform(low, high, shape=(2)) = [[ 0.40451524,  0.18017688],
    ///                                            [ 3.18687344,  3.68352246]]
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\random\multisample_op.cc:L277</summary>
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="low">Lower bounds of the distributions.</param>
    /// <param name="high">Upper bounds of the distributions.</param>
    /// <param name="shape">Shape to be sampled from each random distribution.</param>
    /// <param name="dtype">DType of the output in case this can&#39;t be inferred. Defaults to float32 if not defined (dtype=None).</param>
    static member SampleUniform(outputArray : NDArray seq, low : NDArray, high : NDArray, [<Optional>] shape : int seq, [<Optional>] dtype : FloatDType) =
        let creator = AtomicSymbolCreator.FromName "_sample_uniform"
        let names = [|"shape"; "dtype"|]
        let vals = [|(if isNull (shape :> obj) then "[]" else (shape |> Seq.map string |> String.concat ", " |> sprintf "[%s]")); (if isNull (dtype :> obj) then "None" else string dtype)|]
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg low)) then low.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg high)) then high.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <summary>Concurrent sampling from multiple
    /// uniform distributions on the intervals given by *[low,high)*.
    /// 
    /// The parameters of the distributions are provided as input arrays.
    /// Let *[s]* be the shape of the input arrays, *n* be the dimension of *[s]*, *[t]*
    /// be the shape specified as the parameter of the operator, and *m* be the dimension
    /// of *[t]*. Then the output will be a *(n+m)*-dimensional array with shape *[s]x[t]*.
    /// 
    /// For any valid *n*-dimensional index *i* with respect to the input arrays, *output[i]*
    /// will be an *m*-dimensional array that holds randomly drawn samples from the distribution
    /// which is parameterized by the input values at index *i*. If the shape parameter of the
    /// operator is not set, then one sample will be drawn per distribution and the output array
    /// has the same shape as the input arrays.
    /// 
    /// Examples::
    /// 
    ///    low = [ 0.0, 2.5 ]
    ///    high = [ 1.0, 3.7 ]
    /// 
    ///    // Draw a single sample for each distribution
    ///    sample_uniform(low, high) = [ 0.40451524,  3.18687344]
    /// 
    ///    // Draw a vector containing two samples for each distribution
    ///    sample_uniform(low, high, shape=(2)) = [[ 0.40451524,  0.18017688],
    ///                                            [ 3.18687344,  3.68352246]]
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\random\multisample_op.cc:L277</summary>
    /// <param name="low">Lower bounds of the distributions.</param>
    /// <param name="high">Upper bounds of the distributions.</param>
    /// <param name="shape">Shape to be sampled from each random distribution.</param>
    /// <param name="dtype">DType of the output in case this can&#39;t be inferred. Defaults to float32 if not defined (dtype=None).</param>
    static member SampleUniform([<Optional>] ?low : Symbol, [<Optional>] ?high : Symbol, [<Optional>] ?shape : int seq, [<Optional>] ?dtype : FloatDType) =
        SampleUniform(?low = low, ?high = high, ?shape = shape, ?dtype = dtype)

    /// <summary>Concurrent sampling from multiple
    /// normal distributions with parameters *mu* (mean) and *sigma* (standard deviation).
    /// 
    /// The parameters of the distributions are provided as input arrays.
    /// Let *[s]* be the shape of the input arrays, *n* be the dimension of *[s]*, *[t]*
    /// be the shape specified as the parameter of the operator, and *m* be the dimension
    /// of *[t]*. Then the output will be a *(n+m)*-dimensional array with shape *[s]x[t]*.
    /// 
    /// For any valid *n*-dimensional index *i* with respect to the input arrays, *output[i]*
    /// will be an *m*-dimensional array that holds randomly drawn samples from the distribution
    /// which is parameterized by the input values at index *i*. If the shape parameter of the
    /// operator is not set, then one sample will be drawn per distribution and the output array
    /// has the same shape as the input arrays.
    /// 
    /// Examples::
    /// 
    ///    mu = [ 0.0, 2.5 ]
    ///    sigma = [ 1.0, 3.7 ]
    /// 
    ///    // Draw a single sample for each distribution
    ///    sample_normal(mu, sigma) = [-0.56410581,  0.95934606]
    /// 
    ///    // Draw a vector containing two samples for each distribution
    ///    sample_normal(mu, sigma, shape=(2)) = [[-0.56410581,  0.2928229 ],
    ///                                           [ 0.95934606,  4.48287058]]
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\random\multisample_op.cc:L279</summary>
    /// <param name="mu">Means of the distributions.</param>
    /// <param name="sigma">Standard deviations of the distributions.</param>
    /// <param name="shape">Shape to be sampled from each random distribution.</param>
    /// <param name="dtype">DType of the output in case this can&#39;t be inferred. Defaults to float32 if not defined (dtype=None).</param>
    static member SampleNormal(mu : NDArray, sigma : NDArray, [<Optional>] shape : int seq, [<Optional>] dtype : FloatDType) =
        let creator = AtomicSymbolCreator.FromName "_sample_normal"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg mu)) then mu.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg sigma)) then sigma.UnsafeHandle|]
                                                 [|"shape"; "dtype"|]
                                                 [|(if isNull (shape :> obj) then "[]" else (shape |> Seq.map string |> String.concat ", " |> sprintf "[%s]")); (if isNull (dtype :> obj) then "None" else string dtype)|]
        outputs |> Array.map (fun h -> new NDArray(h))
    /// <summary>Concurrent sampling from multiple
    /// normal distributions with parameters *mu* (mean) and *sigma* (standard deviation).
    /// 
    /// The parameters of the distributions are provided as input arrays.
    /// Let *[s]* be the shape of the input arrays, *n* be the dimension of *[s]*, *[t]*
    /// be the shape specified as the parameter of the operator, and *m* be the dimension
    /// of *[t]*. Then the output will be a *(n+m)*-dimensional array with shape *[s]x[t]*.
    /// 
    /// For any valid *n*-dimensional index *i* with respect to the input arrays, *output[i]*
    /// will be an *m*-dimensional array that holds randomly drawn samples from the distribution
    /// which is parameterized by the input values at index *i*. If the shape parameter of the
    /// operator is not set, then one sample will be drawn per distribution and the output array
    /// has the same shape as the input arrays.
    /// 
    /// Examples::
    /// 
    ///    mu = [ 0.0, 2.5 ]
    ///    sigma = [ 1.0, 3.7 ]
    /// 
    ///    // Draw a single sample for each distribution
    ///    sample_normal(mu, sigma) = [-0.56410581,  0.95934606]
    /// 
    ///    // Draw a vector containing two samples for each distribution
    ///    sample_normal(mu, sigma, shape=(2)) = [[-0.56410581,  0.2928229 ],
    ///                                           [ 0.95934606,  4.48287058]]
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\random\multisample_op.cc:L279</summary>
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="mu">Means of the distributions.</param>
    /// <param name="sigma">Standard deviations of the distributions.</param>
    /// <param name="shape">Shape to be sampled from each random distribution.</param>
    /// <param name="dtype">DType of the output in case this can&#39;t be inferred. Defaults to float32 if not defined (dtype=None).</param>
    static member SampleNormal(outputArray : NDArray seq, mu : NDArray, sigma : NDArray, [<Optional>] shape : int seq, [<Optional>] dtype : FloatDType) =
        let creator = AtomicSymbolCreator.FromName "_sample_normal"
        let names = [|"shape"; "dtype"|]
        let vals = [|(if isNull (shape :> obj) then "[]" else (shape |> Seq.map string |> String.concat ", " |> sprintf "[%s]")); (if isNull (dtype :> obj) then "None" else string dtype)|]
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg mu)) then mu.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg sigma)) then sigma.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <summary>Concurrent sampling from multiple
    /// normal distributions with parameters *mu* (mean) and *sigma* (standard deviation).
    /// 
    /// The parameters of the distributions are provided as input arrays.
    /// Let *[s]* be the shape of the input arrays, *n* be the dimension of *[s]*, *[t]*
    /// be the shape specified as the parameter of the operator, and *m* be the dimension
    /// of *[t]*. Then the output will be a *(n+m)*-dimensional array with shape *[s]x[t]*.
    /// 
    /// For any valid *n*-dimensional index *i* with respect to the input arrays, *output[i]*
    /// will be an *m*-dimensional array that holds randomly drawn samples from the distribution
    /// which is parameterized by the input values at index *i*. If the shape parameter of the
    /// operator is not set, then one sample will be drawn per distribution and the output array
    /// has the same shape as the input arrays.
    /// 
    /// Examples::
    /// 
    ///    mu = [ 0.0, 2.5 ]
    ///    sigma = [ 1.0, 3.7 ]
    /// 
    ///    // Draw a single sample for each distribution
    ///    sample_normal(mu, sigma) = [-0.56410581,  0.95934606]
    /// 
    ///    // Draw a vector containing two samples for each distribution
    ///    sample_normal(mu, sigma, shape=(2)) = [[-0.56410581,  0.2928229 ],
    ///                                           [ 0.95934606,  4.48287058]]
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\random\multisample_op.cc:L279</summary>
    /// <param name="mu">Means of the distributions.</param>
    /// <param name="sigma">Standard deviations of the distributions.</param>
    /// <param name="shape">Shape to be sampled from each random distribution.</param>
    /// <param name="dtype">DType of the output in case this can&#39;t be inferred. Defaults to float32 if not defined (dtype=None).</param>
    static member SampleNormal([<Optional>] ?mu : Symbol, [<Optional>] ?sigma : Symbol, [<Optional>] ?shape : int seq, [<Optional>] ?dtype : FloatDType) =
        SampleNormal(?mu = mu, ?sigma = sigma, ?shape = shape, ?dtype = dtype)

    /// <summary>Concurrent sampling from multiple
    /// gamma distributions with parameters *alpha* (shape) and *beta* (scale).
    /// 
    /// The parameters of the distributions are provided as input arrays.
    /// Let *[s]* be the shape of the input arrays, *n* be the dimension of *[s]*, *[t]*
    /// be the shape specified as the parameter of the operator, and *m* be the dimension
    /// of *[t]*. Then the output will be a *(n+m)*-dimensional array with shape *[s]x[t]*.
    /// 
    /// For any valid *n*-dimensional index *i* with respect to the input arrays, *output[i]*
    /// will be an *m*-dimensional array that holds randomly drawn samples from the distribution
    /// which is parameterized by the input values at index *i*. If the shape parameter of the
    /// operator is not set, then one sample will be drawn per distribution and the output array
    /// has the same shape as the input arrays.
    /// 
    /// Examples::
    /// 
    ///    alpha = [ 0.0, 2.5 ]
    ///    beta = [ 1.0, 0.7 ]
    /// 
    ///    // Draw a single sample for each distribution
    ///    sample_gamma(alpha, beta) = [ 0.        ,  2.25797319]
    /// 
    ///    // Draw a vector containing two samples for each distribution
    ///    sample_gamma(alpha, beta, shape=(2)) = [[ 0.        ,  0.        ],
    ///                                            [ 2.25797319,  1.70734084]]
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\random\multisample_op.cc:L282</summary>
    /// <param name="alpha">Alpha (shape) parameters of the distributions.</param>
    /// <param name="beta">Beta (scale) parameters of the distributions.</param>
    /// <param name="shape">Shape to be sampled from each random distribution.</param>
    /// <param name="dtype">DType of the output in case this can&#39;t be inferred. Defaults to float32 if not defined (dtype=None).</param>
    static member SampleGamma(alpha : NDArray, beta : NDArray, [<Optional>] shape : int seq, [<Optional>] dtype : FloatDType) =
        let creator = AtomicSymbolCreator.FromName "_sample_gamma"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg alpha)) then alpha.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg beta)) then beta.UnsafeHandle|]
                                                 [|"shape"; "dtype"|]
                                                 [|(if isNull (shape :> obj) then "[]" else (shape |> Seq.map string |> String.concat ", " |> sprintf "[%s]")); (if isNull (dtype :> obj) then "None" else string dtype)|]
        outputs |> Array.map (fun h -> new NDArray(h))
    /// <summary>Concurrent sampling from multiple
    /// gamma distributions with parameters *alpha* (shape) and *beta* (scale).
    /// 
    /// The parameters of the distributions are provided as input arrays.
    /// Let *[s]* be the shape of the input arrays, *n* be the dimension of *[s]*, *[t]*
    /// be the shape specified as the parameter of the operator, and *m* be the dimension
    /// of *[t]*. Then the output will be a *(n+m)*-dimensional array with shape *[s]x[t]*.
    /// 
    /// For any valid *n*-dimensional index *i* with respect to the input arrays, *output[i]*
    /// will be an *m*-dimensional array that holds randomly drawn samples from the distribution
    /// which is parameterized by the input values at index *i*. If the shape parameter of the
    /// operator is not set, then one sample will be drawn per distribution and the output array
    /// has the same shape as the input arrays.
    /// 
    /// Examples::
    /// 
    ///    alpha = [ 0.0, 2.5 ]
    ///    beta = [ 1.0, 0.7 ]
    /// 
    ///    // Draw a single sample for each distribution
    ///    sample_gamma(alpha, beta) = [ 0.        ,  2.25797319]
    /// 
    ///    // Draw a vector containing two samples for each distribution
    ///    sample_gamma(alpha, beta, shape=(2)) = [[ 0.        ,  0.        ],
    ///                                            [ 2.25797319,  1.70734084]]
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\random\multisample_op.cc:L282</summary>
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="alpha">Alpha (shape) parameters of the distributions.</param>
    /// <param name="beta">Beta (scale) parameters of the distributions.</param>
    /// <param name="shape">Shape to be sampled from each random distribution.</param>
    /// <param name="dtype">DType of the output in case this can&#39;t be inferred. Defaults to float32 if not defined (dtype=None).</param>
    static member SampleGamma(outputArray : NDArray seq, alpha : NDArray, beta : NDArray, [<Optional>] shape : int seq, [<Optional>] dtype : FloatDType) =
        let creator = AtomicSymbolCreator.FromName "_sample_gamma"
        let names = [|"shape"; "dtype"|]
        let vals = [|(if isNull (shape :> obj) then "[]" else (shape |> Seq.map string |> String.concat ", " |> sprintf "[%s]")); (if isNull (dtype :> obj) then "None" else string dtype)|]
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg alpha)) then alpha.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg beta)) then beta.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <summary>Concurrent sampling from multiple
    /// gamma distributions with parameters *alpha* (shape) and *beta* (scale).
    /// 
    /// The parameters of the distributions are provided as input arrays.
    /// Let *[s]* be the shape of the input arrays, *n* be the dimension of *[s]*, *[t]*
    /// be the shape specified as the parameter of the operator, and *m* be the dimension
    /// of *[t]*. Then the output will be a *(n+m)*-dimensional array with shape *[s]x[t]*.
    /// 
    /// For any valid *n*-dimensional index *i* with respect to the input arrays, *output[i]*
    /// will be an *m*-dimensional array that holds randomly drawn samples from the distribution
    /// which is parameterized by the input values at index *i*. If the shape parameter of the
    /// operator is not set, then one sample will be drawn per distribution and the output array
    /// has the same shape as the input arrays.
    /// 
    /// Examples::
    /// 
    ///    alpha = [ 0.0, 2.5 ]
    ///    beta = [ 1.0, 0.7 ]
    /// 
    ///    // Draw a single sample for each distribution
    ///    sample_gamma(alpha, beta) = [ 0.        ,  2.25797319]
    /// 
    ///    // Draw a vector containing two samples for each distribution
    ///    sample_gamma(alpha, beta, shape=(2)) = [[ 0.        ,  0.        ],
    ///                                            [ 2.25797319,  1.70734084]]
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\random\multisample_op.cc:L282</summary>
    /// <param name="alpha">Alpha (shape) parameters of the distributions.</param>
    /// <param name="beta">Beta (scale) parameters of the distributions.</param>
    /// <param name="shape">Shape to be sampled from each random distribution.</param>
    /// <param name="dtype">DType of the output in case this can&#39;t be inferred. Defaults to float32 if not defined (dtype=None).</param>
    static member SampleGamma([<Optional>] ?alpha : Symbol, [<Optional>] ?beta : Symbol, [<Optional>] ?shape : int seq, [<Optional>] ?dtype : FloatDType) =
        SampleGamma(?alpha = alpha, ?beta = beta, ?shape = shape, ?dtype = dtype)

    /// <summary>Concurrent sampling from multiple
    /// exponential distributions with parameters lambda (rate).
    /// 
    /// The parameters of the distributions are provided as an input array.
    /// Let *[s]* be the shape of the input array, *n* be the dimension of *[s]*, *[t]*
    /// be the shape specified as the parameter of the operator, and *m* be the dimension
    /// of *[t]*. Then the output will be a *(n+m)*-dimensional array with shape *[s]x[t]*.
    /// 
    /// For any valid *n*-dimensional index *i* with respect to the input array, *output[i]*
    /// will be an *m*-dimensional array that holds randomly drawn samples from the distribution
    /// which is parameterized by the input value at index *i*. If the shape parameter of the
    /// operator is not set, then one sample will be drawn per distribution and the output array
    /// has the same shape as the input array.
    /// 
    /// Examples::
    /// 
    ///    lam = [ 1.0, 8.5 ]
    /// 
    ///    // Draw a single sample for each distribution
    ///    sample_exponential(lam) = [ 0.51837951,  0.09994757]
    /// 
    ///    // Draw a vector containing two samples for each distribution
    ///    sample_exponential(lam, shape=(2)) = [[ 0.51837951,  0.19866663],
    ///                                          [ 0.09994757,  0.50447971]]
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\random\multisample_op.cc:L284</summary>
    /// <param name="lam">Lambda (rate) parameters of the distributions.</param>
    /// <param name="shape">Shape to be sampled from each random distribution.</param>
    /// <param name="dtype">DType of the output in case this can&#39;t be inferred. Defaults to float32 if not defined (dtype=None).</param>
    static member SampleExponential(lam : NDArray, [<Optional>] shape : int seq, [<Optional>] dtype : FloatDType) =
        let creator = AtomicSymbolCreator.FromName "_sample_exponential"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg lam)) then lam.UnsafeHandle|]
                                                 [|"shape"; "dtype"|]
                                                 [|(if isNull (shape :> obj) then "[]" else (shape |> Seq.map string |> String.concat ", " |> sprintf "[%s]")); (if isNull (dtype :> obj) then "None" else string dtype)|]
        outputs |> Array.map (fun h -> new NDArray(h))
    /// <summary>Concurrent sampling from multiple
    /// exponential distributions with parameters lambda (rate).
    /// 
    /// The parameters of the distributions are provided as an input array.
    /// Let *[s]* be the shape of the input array, *n* be the dimension of *[s]*, *[t]*
    /// be the shape specified as the parameter of the operator, and *m* be the dimension
    /// of *[t]*. Then the output will be a *(n+m)*-dimensional array with shape *[s]x[t]*.
    /// 
    /// For any valid *n*-dimensional index *i* with respect to the input array, *output[i]*
    /// will be an *m*-dimensional array that holds randomly drawn samples from the distribution
    /// which is parameterized by the input value at index *i*. If the shape parameter of the
    /// operator is not set, then one sample will be drawn per distribution and the output array
    /// has the same shape as the input array.
    /// 
    /// Examples::
    /// 
    ///    lam = [ 1.0, 8.5 ]
    /// 
    ///    // Draw a single sample for each distribution
    ///    sample_exponential(lam) = [ 0.51837951,  0.09994757]
    /// 
    ///    // Draw a vector containing two samples for each distribution
    ///    sample_exponential(lam, shape=(2)) = [[ 0.51837951,  0.19866663],
    ///                                          [ 0.09994757,  0.50447971]]
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\random\multisample_op.cc:L284</summary>
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="lam">Lambda (rate) parameters of the distributions.</param>
    /// <param name="shape">Shape to be sampled from each random distribution.</param>
    /// <param name="dtype">DType of the output in case this can&#39;t be inferred. Defaults to float32 if not defined (dtype=None).</param>
    static member SampleExponential(outputArray : NDArray seq, lam : NDArray, [<Optional>] shape : int seq, [<Optional>] dtype : FloatDType) =
        let creator = AtomicSymbolCreator.FromName "_sample_exponential"
        let names = [|"shape"; "dtype"|]
        let vals = [|(if isNull (shape :> obj) then "[]" else (shape |> Seq.map string |> String.concat ", " |> sprintf "[%s]")); (if isNull (dtype :> obj) then "None" else string dtype)|]
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg lam)) then lam.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <summary>Concurrent sampling from multiple
    /// exponential distributions with parameters lambda (rate).
    /// 
    /// The parameters of the distributions are provided as an input array.
    /// Let *[s]* be the shape of the input array, *n* be the dimension of *[s]*, *[t]*
    /// be the shape specified as the parameter of the operator, and *m* be the dimension
    /// of *[t]*. Then the output will be a *(n+m)*-dimensional array with shape *[s]x[t]*.
    /// 
    /// For any valid *n*-dimensional index *i* with respect to the input array, *output[i]*
    /// will be an *m*-dimensional array that holds randomly drawn samples from the distribution
    /// which is parameterized by the input value at index *i*. If the shape parameter of the
    /// operator is not set, then one sample will be drawn per distribution and the output array
    /// has the same shape as the input array.
    /// 
    /// Examples::
    /// 
    ///    lam = [ 1.0, 8.5 ]
    /// 
    ///    // Draw a single sample for each distribution
    ///    sample_exponential(lam) = [ 0.51837951,  0.09994757]
    /// 
    ///    // Draw a vector containing two samples for each distribution
    ///    sample_exponential(lam, shape=(2)) = [[ 0.51837951,  0.19866663],
    ///                                          [ 0.09994757,  0.50447971]]
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\random\multisample_op.cc:L284</summary>
    /// <param name="lam">Lambda (rate) parameters of the distributions.</param>
    /// <param name="shape">Shape to be sampled from each random distribution.</param>
    /// <param name="dtype">DType of the output in case this can&#39;t be inferred. Defaults to float32 if not defined (dtype=None).</param>
    static member SampleExponential([<Optional>] ?lam : Symbol, [<Optional>] ?shape : int seq, [<Optional>] ?dtype : FloatDType) =
        SampleExponential(?lam = lam, ?shape = shape, ?dtype = dtype)

    /// <summary>Concurrent sampling from multiple
    /// Poisson distributions with parameters lambda (rate).
    /// 
    /// The parameters of the distributions are provided as an input array.
    /// Let *[s]* be the shape of the input array, *n* be the dimension of *[s]*, *[t]*
    /// be the shape specified as the parameter of the operator, and *m* be the dimension
    /// of *[t]*. Then the output will be a *(n+m)*-dimensional array with shape *[s]x[t]*.
    /// 
    /// For any valid *n*-dimensional index *i* with respect to the input array, *output[i]*
    /// will be an *m*-dimensional array that holds randomly drawn samples from the distribution
    /// which is parameterized by the input value at index *i*. If the shape parameter of the
    /// operator is not set, then one sample will be drawn per distribution and the output array
    /// has the same shape as the input array.
    /// 
    /// Samples will always be returned as a floating point data type.
    /// 
    /// Examples::
    /// 
    ///    lam = [ 1.0, 8.5 ]
    /// 
    ///    // Draw a single sample for each distribution
    ///    sample_poisson(lam) = [  0.,  13.]
    /// 
    ///    // Draw a vector containing two samples for each distribution
    ///    sample_poisson(lam, shape=(2)) = [[  0.,   4.],
    ///                                      [ 13.,   8.]]
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\random\multisample_op.cc:L286</summary>
    /// <param name="lam">Lambda (rate) parameters of the distributions.</param>
    /// <param name="shape">Shape to be sampled from each random distribution.</param>
    /// <param name="dtype">DType of the output in case this can&#39;t be inferred. Defaults to float32 if not defined (dtype=None).</param>
    static member SamplePoisson(lam : NDArray, [<Optional>] shape : int seq, [<Optional>] dtype : FloatDType) =
        let creator = AtomicSymbolCreator.FromName "_sample_poisson"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg lam)) then lam.UnsafeHandle|]
                                                 [|"shape"; "dtype"|]
                                                 [|(if isNull (shape :> obj) then "[]" else (shape |> Seq.map string |> String.concat ", " |> sprintf "[%s]")); (if isNull (dtype :> obj) then "None" else string dtype)|]
        outputs |> Array.map (fun h -> new NDArray(h))
    /// <summary>Concurrent sampling from multiple
    /// Poisson distributions with parameters lambda (rate).
    /// 
    /// The parameters of the distributions are provided as an input array.
    /// Let *[s]* be the shape of the input array, *n* be the dimension of *[s]*, *[t]*
    /// be the shape specified as the parameter of the operator, and *m* be the dimension
    /// of *[t]*. Then the output will be a *(n+m)*-dimensional array with shape *[s]x[t]*.
    /// 
    /// For any valid *n*-dimensional index *i* with respect to the input array, *output[i]*
    /// will be an *m*-dimensional array that holds randomly drawn samples from the distribution
    /// which is parameterized by the input value at index *i*. If the shape parameter of the
    /// operator is not set, then one sample will be drawn per distribution and the output array
    /// has the same shape as the input array.
    /// 
    /// Samples will always be returned as a floating point data type.
    /// 
    /// Examples::
    /// 
    ///    lam = [ 1.0, 8.5 ]
    /// 
    ///    // Draw a single sample for each distribution
    ///    sample_poisson(lam) = [  0.,  13.]
    /// 
    ///    // Draw a vector containing two samples for each distribution
    ///    sample_poisson(lam, shape=(2)) = [[  0.,   4.],
    ///                                      [ 13.,   8.]]
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\random\multisample_op.cc:L286</summary>
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="lam">Lambda (rate) parameters of the distributions.</param>
    /// <param name="shape">Shape to be sampled from each random distribution.</param>
    /// <param name="dtype">DType of the output in case this can&#39;t be inferred. Defaults to float32 if not defined (dtype=None).</param>
    static member SamplePoisson(outputArray : NDArray seq, lam : NDArray, [<Optional>] shape : int seq, [<Optional>] dtype : FloatDType) =
        let creator = AtomicSymbolCreator.FromName "_sample_poisson"
        let names = [|"shape"; "dtype"|]
        let vals = [|(if isNull (shape :> obj) then "[]" else (shape |> Seq.map string |> String.concat ", " |> sprintf "[%s]")); (if isNull (dtype :> obj) then "None" else string dtype)|]
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg lam)) then lam.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <summary>Concurrent sampling from multiple
    /// Poisson distributions with parameters lambda (rate).
    /// 
    /// The parameters of the distributions are provided as an input array.
    /// Let *[s]* be the shape of the input array, *n* be the dimension of *[s]*, *[t]*
    /// be the shape specified as the parameter of the operator, and *m* be the dimension
    /// of *[t]*. Then the output will be a *(n+m)*-dimensional array with shape *[s]x[t]*.
    /// 
    /// For any valid *n*-dimensional index *i* with respect to the input array, *output[i]*
    /// will be an *m*-dimensional array that holds randomly drawn samples from the distribution
    /// which is parameterized by the input value at index *i*. If the shape parameter of the
    /// operator is not set, then one sample will be drawn per distribution and the output array
    /// has the same shape as the input array.
    /// 
    /// Samples will always be returned as a floating point data type.
    /// 
    /// Examples::
    /// 
    ///    lam = [ 1.0, 8.5 ]
    /// 
    ///    // Draw a single sample for each distribution
    ///    sample_poisson(lam) = [  0.,  13.]
    /// 
    ///    // Draw a vector containing two samples for each distribution
    ///    sample_poisson(lam, shape=(2)) = [[  0.,   4.],
    ///                                      [ 13.,   8.]]
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\random\multisample_op.cc:L286</summary>
    /// <param name="lam">Lambda (rate) parameters of the distributions.</param>
    /// <param name="shape">Shape to be sampled from each random distribution.</param>
    /// <param name="dtype">DType of the output in case this can&#39;t be inferred. Defaults to float32 if not defined (dtype=None).</param>
    static member SamplePoisson([<Optional>] ?lam : Symbol, [<Optional>] ?shape : int seq, [<Optional>] ?dtype : FloatDType) =
        SamplePoisson(?lam = lam, ?shape = shape, ?dtype = dtype)

    /// <summary>Concurrent sampling from multiple
    /// negative binomial distributions with parameters *k* (failure limit) and *p* (failure probability).
    /// 
    /// The parameters of the distributions are provided as input arrays.
    /// Let *[s]* be the shape of the input arrays, *n* be the dimension of *[s]*, *[t]*
    /// be the shape specified as the parameter of the operator, and *m* be the dimension
    /// of *[t]*. Then the output will be a *(n+m)*-dimensional array with shape *[s]x[t]*.
    /// 
    /// For any valid *n*-dimensional index *i* with respect to the input arrays, *output[i]*
    /// will be an *m*-dimensional array that holds randomly drawn samples from the distribution
    /// which is parameterized by the input values at index *i*. If the shape parameter of the
    /// operator is not set, then one sample will be drawn per distribution and the output array
    /// has the same shape as the input arrays.
    /// 
    /// Samples will always be returned as a floating point data type.
    /// 
    /// Examples::
    /// 
    ///    k = [ 20, 49 ]
    ///    p = [ 0.4 , 0.77 ]
    /// 
    ///    // Draw a single sample for each distribution
    ///    sample_negative_binomial(k, p) = [ 15.,  16.]
    /// 
    ///    // Draw a vector containing two samples for each distribution
    ///    sample_negative_binomial(k, p, shape=(2)) = [[ 15.,  50.],
    ///                                                 [ 16.,  12.]]
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\random\multisample_op.cc:L289</summary>
    /// <param name="k">Limits of unsuccessful experiments.</param>
    /// <param name="p">Failure probabilities in each experiment.</param>
    /// <param name="shape">Shape to be sampled from each random distribution.</param>
    /// <param name="dtype">DType of the output in case this can&#39;t be inferred. Defaults to float32 if not defined (dtype=None).</param>
    static member SampleNegativeBinomial(k : NDArray, p : NDArray, [<Optional>] shape : int seq, [<Optional>] dtype : FloatDType) =
        let creator = AtomicSymbolCreator.FromName "_sample_negative_binomial"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg k)) then k.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg p)) then p.UnsafeHandle|]
                                                 [|"shape"; "dtype"|]
                                                 [|(if isNull (shape :> obj) then "[]" else (shape |> Seq.map string |> String.concat ", " |> sprintf "[%s]")); (if isNull (dtype :> obj) then "None" else string dtype)|]
        outputs |> Array.map (fun h -> new NDArray(h))
    /// <summary>Concurrent sampling from multiple
    /// negative binomial distributions with parameters *k* (failure limit) and *p* (failure probability).
    /// 
    /// The parameters of the distributions are provided as input arrays.
    /// Let *[s]* be the shape of the input arrays, *n* be the dimension of *[s]*, *[t]*
    /// be the shape specified as the parameter of the operator, and *m* be the dimension
    /// of *[t]*. Then the output will be a *(n+m)*-dimensional array with shape *[s]x[t]*.
    /// 
    /// For any valid *n*-dimensional index *i* with respect to the input arrays, *output[i]*
    /// will be an *m*-dimensional array that holds randomly drawn samples from the distribution
    /// which is parameterized by the input values at index *i*. If the shape parameter of the
    /// operator is not set, then one sample will be drawn per distribution and the output array
    /// has the same shape as the input arrays.
    /// 
    /// Samples will always be returned as a floating point data type.
    /// 
    /// Examples::
    /// 
    ///    k = [ 20, 49 ]
    ///    p = [ 0.4 , 0.77 ]
    /// 
    ///    // Draw a single sample for each distribution
    ///    sample_negative_binomial(k, p) = [ 15.,  16.]
    /// 
    ///    // Draw a vector containing two samples for each distribution
    ///    sample_negative_binomial(k, p, shape=(2)) = [[ 15.,  50.],
    ///                                                 [ 16.,  12.]]
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\random\multisample_op.cc:L289</summary>
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="k">Limits of unsuccessful experiments.</param>
    /// <param name="p">Failure probabilities in each experiment.</param>
    /// <param name="shape">Shape to be sampled from each random distribution.</param>
    /// <param name="dtype">DType of the output in case this can&#39;t be inferred. Defaults to float32 if not defined (dtype=None).</param>
    static member SampleNegativeBinomial(outputArray : NDArray seq, k : NDArray, p : NDArray, [<Optional>] shape : int seq, [<Optional>] dtype : FloatDType) =
        let creator = AtomicSymbolCreator.FromName "_sample_negative_binomial"
        let names = [|"shape"; "dtype"|]
        let vals = [|(if isNull (shape :> obj) then "[]" else (shape |> Seq.map string |> String.concat ", " |> sprintf "[%s]")); (if isNull (dtype :> obj) then "None" else string dtype)|]
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg k)) then k.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg p)) then p.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <summary>Concurrent sampling from multiple
    /// negative binomial distributions with parameters *k* (failure limit) and *p* (failure probability).
    /// 
    /// The parameters of the distributions are provided as input arrays.
    /// Let *[s]* be the shape of the input arrays, *n* be the dimension of *[s]*, *[t]*
    /// be the shape specified as the parameter of the operator, and *m* be the dimension
    /// of *[t]*. Then the output will be a *(n+m)*-dimensional array with shape *[s]x[t]*.
    /// 
    /// For any valid *n*-dimensional index *i* with respect to the input arrays, *output[i]*
    /// will be an *m*-dimensional array that holds randomly drawn samples from the distribution
    /// which is parameterized by the input values at index *i*. If the shape parameter of the
    /// operator is not set, then one sample will be drawn per distribution and the output array
    /// has the same shape as the input arrays.
    /// 
    /// Samples will always be returned as a floating point data type.
    /// 
    /// Examples::
    /// 
    ///    k = [ 20, 49 ]
    ///    p = [ 0.4 , 0.77 ]
    /// 
    ///    // Draw a single sample for each distribution
    ///    sample_negative_binomial(k, p) = [ 15.,  16.]
    /// 
    ///    // Draw a vector containing two samples for each distribution
    ///    sample_negative_binomial(k, p, shape=(2)) = [[ 15.,  50.],
    ///                                                 [ 16.,  12.]]
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\random\multisample_op.cc:L289</summary>
    /// <param name="k">Limits of unsuccessful experiments.</param>
    /// <param name="p">Failure probabilities in each experiment.</param>
    /// <param name="shape">Shape to be sampled from each random distribution.</param>
    /// <param name="dtype">DType of the output in case this can&#39;t be inferred. Defaults to float32 if not defined (dtype=None).</param>
    static member SampleNegativeBinomial([<Optional>] ?k : Symbol, [<Optional>] ?p : Symbol, [<Optional>] ?shape : int seq, [<Optional>] ?dtype : FloatDType) =
        SampleNegativeBinomial(?k = k, ?p = p, ?shape = shape, ?dtype = dtype)

    /// <summary>Concurrent sampling from multiple
    /// generalized negative binomial distributions with parameters *mu* (mean) and *alpha* (dispersion).
    /// 
    /// The parameters of the distributions are provided as input arrays.
    /// Let *[s]* be the shape of the input arrays, *n* be the dimension of *[s]*, *[t]*
    /// be the shape specified as the parameter of the operator, and *m* be the dimension
    /// of *[t]*. Then the output will be a *(n+m)*-dimensional array with shape *[s]x[t]*.
    /// 
    /// For any valid *n*-dimensional index *i* with respect to the input arrays, *output[i]*
    /// will be an *m*-dimensional array that holds randomly drawn samples from the distribution
    /// which is parameterized by the input values at index *i*. If the shape parameter of the
    /// operator is not set, then one sample will be drawn per distribution and the output array
    /// has the same shape as the input arrays.
    /// 
    /// Samples will always be returned as a floating point data type.
    /// 
    /// Examples::
    /// 
    ///    mu = [ 2.0, 2.5 ]
    ///    alpha = [ 1.0, 0.1 ]
    /// 
    ///    // Draw a single sample for each distribution
    ///    sample_generalized_negative_binomial(mu, alpha) = [ 0.,  3.]
    /// 
    ///    // Draw a vector containing two samples for each distribution
    ///    sample_generalized_negative_binomial(mu, alpha, shape=(2)) = [[ 0.,  3.],
    ///                                                                  [ 3.,  1.]]
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\random\multisample_op.cc:L293</summary>
    /// <param name="mu">Means of the distributions.</param>
    /// <param name="alpha">Alpha (dispersion) parameters of the distributions.</param>
    /// <param name="shape">Shape to be sampled from each random distribution.</param>
    /// <param name="dtype">DType of the output in case this can&#39;t be inferred. Defaults to float32 if not defined (dtype=None).</param>
    static member SampleGeneralizedNegativeBinomial(mu : NDArray, alpha : NDArray, [<Optional>] shape : int seq, [<Optional>] dtype : FloatDType) =
        let creator = AtomicSymbolCreator.FromName "_sample_generalized_negative_binomial"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg mu)) then mu.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg alpha)) then alpha.UnsafeHandle|]
                                                 [|"shape"; "dtype"|]
                                                 [|(if isNull (shape :> obj) then "[]" else (shape |> Seq.map string |> String.concat ", " |> sprintf "[%s]")); (if isNull (dtype :> obj) then "None" else string dtype)|]
        outputs |> Array.map (fun h -> new NDArray(h))
    /// <summary>Concurrent sampling from multiple
    /// generalized negative binomial distributions with parameters *mu* (mean) and *alpha* (dispersion).
    /// 
    /// The parameters of the distributions are provided as input arrays.
    /// Let *[s]* be the shape of the input arrays, *n* be the dimension of *[s]*, *[t]*
    /// be the shape specified as the parameter of the operator, and *m* be the dimension
    /// of *[t]*. Then the output will be a *(n+m)*-dimensional array with shape *[s]x[t]*.
    /// 
    /// For any valid *n*-dimensional index *i* with respect to the input arrays, *output[i]*
    /// will be an *m*-dimensional array that holds randomly drawn samples from the distribution
    /// which is parameterized by the input values at index *i*. If the shape parameter of the
    /// operator is not set, then one sample will be drawn per distribution and the output array
    /// has the same shape as the input arrays.
    /// 
    /// Samples will always be returned as a floating point data type.
    /// 
    /// Examples::
    /// 
    ///    mu = [ 2.0, 2.5 ]
    ///    alpha = [ 1.0, 0.1 ]
    /// 
    ///    // Draw a single sample for each distribution
    ///    sample_generalized_negative_binomial(mu, alpha) = [ 0.,  3.]
    /// 
    ///    // Draw a vector containing two samples for each distribution
    ///    sample_generalized_negative_binomial(mu, alpha, shape=(2)) = [[ 0.,  3.],
    ///                                                                  [ 3.,  1.]]
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\random\multisample_op.cc:L293</summary>
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="mu">Means of the distributions.</param>
    /// <param name="alpha">Alpha (dispersion) parameters of the distributions.</param>
    /// <param name="shape">Shape to be sampled from each random distribution.</param>
    /// <param name="dtype">DType of the output in case this can&#39;t be inferred. Defaults to float32 if not defined (dtype=None).</param>
    static member SampleGeneralizedNegativeBinomial(outputArray : NDArray seq, mu : NDArray, alpha : NDArray, [<Optional>] shape : int seq, [<Optional>] dtype : FloatDType) =
        let creator = AtomicSymbolCreator.FromName "_sample_generalized_negative_binomial"
        let names = [|"shape"; "dtype"|]
        let vals = [|(if isNull (shape :> obj) then "[]" else (shape |> Seq.map string |> String.concat ", " |> sprintf "[%s]")); (if isNull (dtype :> obj) then "None" else string dtype)|]
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg mu)) then mu.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg alpha)) then alpha.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <summary>Concurrent sampling from multiple
    /// generalized negative binomial distributions with parameters *mu* (mean) and *alpha* (dispersion).
    /// 
    /// The parameters of the distributions are provided as input arrays.
    /// Let *[s]* be the shape of the input arrays, *n* be the dimension of *[s]*, *[t]*
    /// be the shape specified as the parameter of the operator, and *m* be the dimension
    /// of *[t]*. Then the output will be a *(n+m)*-dimensional array with shape *[s]x[t]*.
    /// 
    /// For any valid *n*-dimensional index *i* with respect to the input arrays, *output[i]*
    /// will be an *m*-dimensional array that holds randomly drawn samples from the distribution
    /// which is parameterized by the input values at index *i*. If the shape parameter of the
    /// operator is not set, then one sample will be drawn per distribution and the output array
    /// has the same shape as the input arrays.
    /// 
    /// Samples will always be returned as a floating point data type.
    /// 
    /// Examples::
    /// 
    ///    mu = [ 2.0, 2.5 ]
    ///    alpha = [ 1.0, 0.1 ]
    /// 
    ///    // Draw a single sample for each distribution
    ///    sample_generalized_negative_binomial(mu, alpha) = [ 0.,  3.]
    /// 
    ///    // Draw a vector containing two samples for each distribution
    ///    sample_generalized_negative_binomial(mu, alpha, shape=(2)) = [[ 0.,  3.],
    ///                                                                  [ 3.,  1.]]
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\random\multisample_op.cc:L293</summary>
    /// <param name="mu">Means of the distributions.</param>
    /// <param name="alpha">Alpha (dispersion) parameters of the distributions.</param>
    /// <param name="shape">Shape to be sampled from each random distribution.</param>
    /// <param name="dtype">DType of the output in case this can&#39;t be inferred. Defaults to float32 if not defined (dtype=None).</param>
    static member SampleGeneralizedNegativeBinomial([<Optional>] ?mu : Symbol, [<Optional>] ?alpha : Symbol, [<Optional>] ?shape : int seq, [<Optional>] ?dtype : FloatDType) =
        SampleGeneralizedNegativeBinomial(?mu = mu, ?alpha = alpha, ?shape = shape, ?dtype = dtype)

    /// <summary>Computes the value of the PDF of *sample* of
    /// uniform distributions on the intervals given by *[low,high)*.
    /// 
    /// *low* and *high* must have the same shape, which must match the leftmost subshape
    /// of *sample*.  That is, *sample* can have the same shape as *low* and *high*, in which
    /// case the output contains one density per distribution, or *sample* can be a tensor
    /// of tensors with that shape, in which case the output is a tensor of densities such that
    /// the densities at index *i* in the output are given by the samples at index *i* in *sample*
    /// parameterized by the values of *low* and *high* at index *i*.
    /// 
    /// Examples::
    /// 
    ///     random_pdf_uniform(sample=[[1,2,3,4]], low=[0], high=[10]) = [0.1, 0.1, 0.1, 0.1]
    /// 
    ///     sample = [[[1, 2, 3],
    ///                [1, 2, 3]],
    ///               [[1, 2, 3],
    ///                [1, 2, 3]]]
    ///     low  = [[0, 0],
    ///             [0, 0]]
    ///     high = [[ 5, 10],
    ///             [15, 20]]
    ///     random_pdf_uniform(sample=sample, low=low, high=high) =
    ///         [[[0.2,        0.2,        0.2    ],
    ///           [0.1,        0.1,        0.1    ]],
    ///          [[0.06667,    0.06667,    0.06667],
    ///           [0.05,       0.05,       0.05   ]]]
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\random\pdf_op.cc:L298</summary>
    /// <param name="sample">Samples from the distributions.</param>
    /// <param name="low">Lower bounds of the distributions.</param>
    /// <param name="high">Upper bounds of the distributions.</param>
    /// <param name="isLog">If set, compute the density of the log-probability instead of the probability.</param>
    static member RandomPdfUniform(sample : NDArray, low : NDArray, high : NDArray, [<Optional; DefaultParameterValue(false)>] isLog : bool) =
        let creator = AtomicSymbolCreator.FromName "_random_pdf_uniform"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg sample)) then sample.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg low)) then low.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg high)) then high.UnsafeHandle|]
                                                 [|"is_log"|]
                                                 [|string isLog|]
        outputs |> Array.map (fun h -> new NDArray(h))
    /// <summary>Computes the value of the PDF of *sample* of
    /// uniform distributions on the intervals given by *[low,high)*.
    /// 
    /// *low* and *high* must have the same shape, which must match the leftmost subshape
    /// of *sample*.  That is, *sample* can have the same shape as *low* and *high*, in which
    /// case the output contains one density per distribution, or *sample* can be a tensor
    /// of tensors with that shape, in which case the output is a tensor of densities such that
    /// the densities at index *i* in the output are given by the samples at index *i* in *sample*
    /// parameterized by the values of *low* and *high* at index *i*.
    /// 
    /// Examples::
    /// 
    ///     random_pdf_uniform(sample=[[1,2,3,4]], low=[0], high=[10]) = [0.1, 0.1, 0.1, 0.1]
    /// 
    ///     sample = [[[1, 2, 3],
    ///                [1, 2, 3]],
    ///               [[1, 2, 3],
    ///                [1, 2, 3]]]
    ///     low  = [[0, 0],
    ///             [0, 0]]
    ///     high = [[ 5, 10],
    ///             [15, 20]]
    ///     random_pdf_uniform(sample=sample, low=low, high=high) =
    ///         [[[0.2,        0.2,        0.2    ],
    ///           [0.1,        0.1,        0.1    ]],
    ///          [[0.06667,    0.06667,    0.06667],
    ///           [0.05,       0.05,       0.05   ]]]
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\random\pdf_op.cc:L298</summary>
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="sample">Samples from the distributions.</param>
    /// <param name="low">Lower bounds of the distributions.</param>
    /// <param name="high">Upper bounds of the distributions.</param>
    /// <param name="isLog">If set, compute the density of the log-probability instead of the probability.</param>
    static member RandomPdfUniform(outputArray : NDArray seq, sample : NDArray, low : NDArray, high : NDArray, [<Optional; DefaultParameterValue(false)>] isLog : bool) =
        let creator = AtomicSymbolCreator.FromName "_random_pdf_uniform"
        let names = [|"is_log"|]
        let vals = [|string isLog|]
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg sample)) then sample.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg low)) then low.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg high)) then high.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <summary>Computes the value of the PDF of *sample* of
    /// uniform distributions on the intervals given by *[low,high)*.
    /// 
    /// *low* and *high* must have the same shape, which must match the leftmost subshape
    /// of *sample*.  That is, *sample* can have the same shape as *low* and *high*, in which
    /// case the output contains one density per distribution, or *sample* can be a tensor
    /// of tensors with that shape, in which case the output is a tensor of densities such that
    /// the densities at index *i* in the output are given by the samples at index *i* in *sample*
    /// parameterized by the values of *low* and *high* at index *i*.
    /// 
    /// Examples::
    /// 
    ///     random_pdf_uniform(sample=[[1,2,3,4]], low=[0], high=[10]) = [0.1, 0.1, 0.1, 0.1]
    /// 
    ///     sample = [[[1, 2, 3],
    ///                [1, 2, 3]],
    ///               [[1, 2, 3],
    ///                [1, 2, 3]]]
    ///     low  = [[0, 0],
    ///             [0, 0]]
    ///     high = [[ 5, 10],
    ///             [15, 20]]
    ///     random_pdf_uniform(sample=sample, low=low, high=high) =
    ///         [[[0.2,        0.2,        0.2    ],
    ///           [0.1,        0.1,        0.1    ]],
    ///          [[0.06667,    0.06667,    0.06667],
    ///           [0.05,       0.05,       0.05   ]]]
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\random\pdf_op.cc:L298</summary>
    /// <param name="sample">Samples from the distributions.</param>
    /// <param name="low">Lower bounds of the distributions.</param>
    /// <param name="high">Upper bounds of the distributions.</param>
    /// <param name="isLog">If set, compute the density of the log-probability instead of the probability.</param>
    static member RandomPdfUniform([<Optional>] ?sample : Symbol, [<Optional>] ?low : Symbol, [<Optional>] ?high : Symbol, [<Optional>] ?isLog : bool) =
        RandomPdfUniform(?sample = sample, ?low = low, ?high = high, ?isLog = isLog)


    /// <summary>Computes the value of the PDF of *sample* of
    /// normal distributions with parameters *mu* (mean) and *sigma* (standard deviation).
    /// 
    /// *mu* and *sigma* must have the same shape, which must match the leftmost subshape
    /// of *sample*.  That is, *sample* can have the same shape as *mu* and *sigma*, in which
    /// case the output contains one density per distribution, or *sample* can be a tensor
    /// of tensors with that shape, in which case the output is a tensor of densities such that
    /// the densities at index *i* in the output are given by the samples at index *i* in *sample*
    /// parameterized by the values of *mu* and *sigma* at index *i*.
    /// 
    /// Examples::
    /// 
    ///     sample = [[-2, -1, 0, 1, 2]]
    ///     random_pdf_normal(sample=sample, mu=[0], sigma=[1]) =
    ///         [[0.05399097, 0.24197073, 0.3989423, 0.24197073, 0.05399097]]
    /// 
    ///     random_pdf_normal(sample=sample*2, mu=[0,0], sigma=[1,2]) =
    ///         [[0.05399097, 0.24197073, 0.3989423,  0.24197073, 0.05399097],
    ///          [0.12098537, 0.17603266, 0.19947115, 0.17603266, 0.12098537]]
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\random\pdf_op.cc:L300</summary>
    /// <param name="sample">Samples from the distributions.</param>
    /// <param name="mu">Means of the distributions.</param>
    /// <param name="sigma">Standard deviations of the distributions.</param>
    /// <param name="isLog">If set, compute the density of the log-probability instead of the probability.</param>
    static member RandomPdfNormal(sample : NDArray, mu : NDArray, sigma : NDArray, [<Optional; DefaultParameterValue(false)>] isLog : bool) =
        let creator = AtomicSymbolCreator.FromName "_random_pdf_normal"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg sample)) then sample.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg mu)) then mu.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg sigma)) then sigma.UnsafeHandle|]
                                                 [|"is_log"|]
                                                 [|string isLog|]
        outputs |> Array.map (fun h -> new NDArray(h))
    /// <summary>Computes the value of the PDF of *sample* of
    /// normal distributions with parameters *mu* (mean) and *sigma* (standard deviation).
    /// 
    /// *mu* and *sigma* must have the same shape, which must match the leftmost subshape
    /// of *sample*.  That is, *sample* can have the same shape as *mu* and *sigma*, in which
    /// case the output contains one density per distribution, or *sample* can be a tensor
    /// of tensors with that shape, in which case the output is a tensor of densities such that
    /// the densities at index *i* in the output are given by the samples at index *i* in *sample*
    /// parameterized by the values of *mu* and *sigma* at index *i*.
    /// 
    /// Examples::
    /// 
    ///     sample = [[-2, -1, 0, 1, 2]]
    ///     random_pdf_normal(sample=sample, mu=[0], sigma=[1]) =
    ///         [[0.05399097, 0.24197073, 0.3989423, 0.24197073, 0.05399097]]
    /// 
    ///     random_pdf_normal(sample=sample*2, mu=[0,0], sigma=[1,2]) =
    ///         [[0.05399097, 0.24197073, 0.3989423,  0.24197073, 0.05399097],
    ///          [0.12098537, 0.17603266, 0.19947115, 0.17603266, 0.12098537]]
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\random\pdf_op.cc:L300</summary>
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="sample">Samples from the distributions.</param>
    /// <param name="mu">Means of the distributions.</param>
    /// <param name="sigma">Standard deviations of the distributions.</param>
    /// <param name="isLog">If set, compute the density of the log-probability instead of the probability.</param>
    static member RandomPdfNormal(outputArray : NDArray seq, sample : NDArray, mu : NDArray, sigma : NDArray, [<Optional; DefaultParameterValue(false)>] isLog : bool) =
        let creator = AtomicSymbolCreator.FromName "_random_pdf_normal"
        let names = [|"is_log"|]
        let vals = [|string isLog|]
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg sample)) then sample.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg mu)) then mu.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg sigma)) then sigma.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <summary>Computes the value of the PDF of *sample* of
    /// normal distributions with parameters *mu* (mean) and *sigma* (standard deviation).
    /// 
    /// *mu* and *sigma* must have the same shape, which must match the leftmost subshape
    /// of *sample*.  That is, *sample* can have the same shape as *mu* and *sigma*, in which
    /// case the output contains one density per distribution, or *sample* can be a tensor
    /// of tensors with that shape, in which case the output is a tensor of densities such that
    /// the densities at index *i* in the output are given by the samples at index *i* in *sample*
    /// parameterized by the values of *mu* and *sigma* at index *i*.
    /// 
    /// Examples::
    /// 
    ///     sample = [[-2, -1, 0, 1, 2]]
    ///     random_pdf_normal(sample=sample, mu=[0], sigma=[1]) =
    ///         [[0.05399097, 0.24197073, 0.3989423, 0.24197073, 0.05399097]]
    /// 
    ///     random_pdf_normal(sample=sample*2, mu=[0,0], sigma=[1,2]) =
    ///         [[0.05399097, 0.24197073, 0.3989423,  0.24197073, 0.05399097],
    ///          [0.12098537, 0.17603266, 0.19947115, 0.17603266, 0.12098537]]
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\random\pdf_op.cc:L300</summary>
    /// <param name="sample">Samples from the distributions.</param>
    /// <param name="mu">Means of the distributions.</param>
    /// <param name="sigma">Standard deviations of the distributions.</param>
    /// <param name="isLog">If set, compute the density of the log-probability instead of the probability.</param>
    static member RandomPdfNormal([<Optional>] ?sample : Symbol, [<Optional>] ?mu : Symbol, [<Optional>] ?sigma : Symbol, [<Optional>] ?isLog : bool) =
        RandomPdfNormal(?sample = sample, ?mu = mu, ?sigma = sigma, ?isLog = isLog)


    /// <summary>Computes the value of the PDF of *sample* of
    /// gamma distributions with parameters *alpha* (shape) and *beta* (rate).
    /// 
    /// *alpha* and *beta* must have the same shape, which must match the leftmost subshape
    /// of *sample*.  That is, *sample* can have the same shape as *alpha* and *beta*, in which
    /// case the output contains one density per distribution, or *sample* can be a tensor
    /// of tensors with that shape, in which case the output is a tensor of densities such that
    /// the densities at index *i* in the output are given by the samples at index *i* in *sample*
    /// parameterized by the values of *alpha* and *beta* at index *i*.
    /// 
    /// Examples::
    /// 
    ///   random_pdf_gamma(sample=[[1,2,3,4,5]], alpha=[5], beta=[1]) =
    ///       [[0.01532831, 0.09022352, 0.16803136, 0.19536681, 0.17546739]]
    /// 
    ///   sample = [[1, 2, 3, 4, 5],
    ///             [2, 3, 4, 5, 6],
    ///             [3, 4, 5, 6, 7]]
    /// 
    ///   random_pdf_gamma(sample=sample, alpha=[5,6,7], beta=[1,1,1]) =
    ///       [[0.01532831, 0.09022352, 0.16803136, 0.19536681, 0.17546739],
    ///        [0.03608941, 0.10081882, 0.15629345, 0.17546739, 0.16062315],
    ///        [0.05040941, 0.10419563, 0.14622283, 0.16062315, 0.14900276]]
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\random\pdf_op.cc:L303</summary>
    /// <param name="sample">Samples from the distributions.</param>
    /// <param name="alpha">Alpha (shape) parameters of the distributions.</param>
    /// <param name="beta">Beta (scale) parameters of the distributions.</param>
    /// <param name="isLog">If set, compute the density of the log-probability instead of the probability.</param>
    static member RandomPdfGamma(sample : NDArray, alpha : NDArray, beta : NDArray, [<Optional; DefaultParameterValue(false)>] isLog : bool) =
        let creator = AtomicSymbolCreator.FromName "_random_pdf_gamma"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg sample)) then sample.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg alpha)) then alpha.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg beta)) then beta.UnsafeHandle|]
                                                 [|"is_log"|]
                                                 [|string isLog|]
        outputs |> Array.map (fun h -> new NDArray(h))
    /// <summary>Computes the value of the PDF of *sample* of
    /// gamma distributions with parameters *alpha* (shape) and *beta* (rate).
    /// 
    /// *alpha* and *beta* must have the same shape, which must match the leftmost subshape
    /// of *sample*.  That is, *sample* can have the same shape as *alpha* and *beta*, in which
    /// case the output contains one density per distribution, or *sample* can be a tensor
    /// of tensors with that shape, in which case the output is a tensor of densities such that
    /// the densities at index *i* in the output are given by the samples at index *i* in *sample*
    /// parameterized by the values of *alpha* and *beta* at index *i*.
    /// 
    /// Examples::
    /// 
    ///   random_pdf_gamma(sample=[[1,2,3,4,5]], alpha=[5], beta=[1]) =
    ///       [[0.01532831, 0.09022352, 0.16803136, 0.19536681, 0.17546739]]
    /// 
    ///   sample = [[1, 2, 3, 4, 5],
    ///             [2, 3, 4, 5, 6],
    ///             [3, 4, 5, 6, 7]]
    /// 
    ///   random_pdf_gamma(sample=sample, alpha=[5,6,7], beta=[1,1,1]) =
    ///       [[0.01532831, 0.09022352, 0.16803136, 0.19536681, 0.17546739],
    ///        [0.03608941, 0.10081882, 0.15629345, 0.17546739, 0.16062315],
    ///        [0.05040941, 0.10419563, 0.14622283, 0.16062315, 0.14900276]]
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\random\pdf_op.cc:L303</summary>
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="sample">Samples from the distributions.</param>
    /// <param name="alpha">Alpha (shape) parameters of the distributions.</param>
    /// <param name="beta">Beta (scale) parameters of the distributions.</param>
    /// <param name="isLog">If set, compute the density of the log-probability instead of the probability.</param>
    static member RandomPdfGamma(outputArray : NDArray seq, sample : NDArray, alpha : NDArray, beta : NDArray, [<Optional; DefaultParameterValue(false)>] isLog : bool) =
        let creator = AtomicSymbolCreator.FromName "_random_pdf_gamma"
        let names = [|"is_log"|]
        let vals = [|string isLog|]
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg sample)) then sample.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg alpha)) then alpha.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg beta)) then beta.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <summary>Computes the value of the PDF of *sample* of
    /// gamma distributions with parameters *alpha* (shape) and *beta* (rate).
    /// 
    /// *alpha* and *beta* must have the same shape, which must match the leftmost subshape
    /// of *sample*.  That is, *sample* can have the same shape as *alpha* and *beta*, in which
    /// case the output contains one density per distribution, or *sample* can be a tensor
    /// of tensors with that shape, in which case the output is a tensor of densities such that
    /// the densities at index *i* in the output are given by the samples at index *i* in *sample*
    /// parameterized by the values of *alpha* and *beta* at index *i*.
    /// 
    /// Examples::
    /// 
    ///   random_pdf_gamma(sample=[[1,2,3,4,5]], alpha=[5], beta=[1]) =
    ///       [[0.01532831, 0.09022352, 0.16803136, 0.19536681, 0.17546739]]
    /// 
    ///   sample = [[1, 2, 3, 4, 5],
    ///             [2, 3, 4, 5, 6],
    ///             [3, 4, 5, 6, 7]]
    /// 
    ///   random_pdf_gamma(sample=sample, alpha=[5,6,7], beta=[1,1,1]) =
    ///       [[0.01532831, 0.09022352, 0.16803136, 0.19536681, 0.17546739],
    ///        [0.03608941, 0.10081882, 0.15629345, 0.17546739, 0.16062315],
    ///        [0.05040941, 0.10419563, 0.14622283, 0.16062315, 0.14900276]]
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\random\pdf_op.cc:L303</summary>
    /// <param name="sample">Samples from the distributions.</param>
    /// <param name="alpha">Alpha (shape) parameters of the distributions.</param>
    /// <param name="beta">Beta (scale) parameters of the distributions.</param>
    /// <param name="isLog">If set, compute the density of the log-probability instead of the probability.</param>
    static member RandomPdfGamma([<Optional>] ?sample : Symbol, [<Optional>] ?alpha : Symbol, [<Optional>] ?beta : Symbol, [<Optional>] ?isLog : bool) =
        RandomPdfGamma(?sample = sample, ?alpha = alpha, ?beta = beta, ?isLog = isLog)


    /// <summary>Computes the value of the PDF of *sample* of
    /// exponential distributions with parameters *lam* (rate).
    /// 
    /// The shape of *lam* must match the leftmost subshape of *sample*.  That is, *sample*
    /// can have the same shape as *lam*, in which case the output contains one density per
    /// distribution, or *sample* can be a tensor of tensors with that shape, in which case
    /// the output is a tensor of densities such that the densities at index *i* in the output
    /// are given by the samples at index *i* in *sample* parameterized by the value of *lam*
    /// at index *i*.
    /// 
    /// Examples::
    /// 
    ///   random_pdf_exponential(sample=[[1, 2, 3]], lam=[1]) =
    ///       [[0.36787945, 0.13533528, 0.04978707]]
    /// 
    ///   sample = [[1,2,3],
    ///             [1,2,3],
    ///             [1,2,3]]
    /// 
    ///   random_pdf_exponential(sample=sample, lam=[1,0.5,0.25]) =
    ///       [[0.36787945, 0.13533528, 0.04978707],
    ///        [0.30326533, 0.18393973, 0.11156508],
    ///        [0.1947002,  0.15163267, 0.11809164]]
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\random\pdf_op.cc:L305</summary>
    /// <param name="sample">Samples from the distributions.</param>
    /// <param name="lam">Lambda (rate) parameters of the distributions.</param>
    /// <param name="isLog">If set, compute the density of the log-probability instead of the probability.</param>
    static member RandomPdfExponential(sample : NDArray, lam : NDArray, [<Optional; DefaultParameterValue(false)>] isLog : bool) =
        let creator = AtomicSymbolCreator.FromName "_random_pdf_exponential"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg sample)) then sample.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg lam)) then lam.UnsafeHandle|]
                                                 [|"is_log"|]
                                                 [|string isLog|]
        outputs |> Array.map (fun h -> new NDArray(h))
    /// <summary>Computes the value of the PDF of *sample* of
    /// exponential distributions with parameters *lam* (rate).
    /// 
    /// The shape of *lam* must match the leftmost subshape of *sample*.  That is, *sample*
    /// can have the same shape as *lam*, in which case the output contains one density per
    /// distribution, or *sample* can be a tensor of tensors with that shape, in which case
    /// the output is a tensor of densities such that the densities at index *i* in the output
    /// are given by the samples at index *i* in *sample* parameterized by the value of *lam*
    /// at index *i*.
    /// 
    /// Examples::
    /// 
    ///   random_pdf_exponential(sample=[[1, 2, 3]], lam=[1]) =
    ///       [[0.36787945, 0.13533528, 0.04978707]]
    /// 
    ///   sample = [[1,2,3],
    ///             [1,2,3],
    ///             [1,2,3]]
    /// 
    ///   random_pdf_exponential(sample=sample, lam=[1,0.5,0.25]) =
    ///       [[0.36787945, 0.13533528, 0.04978707],
    ///        [0.30326533, 0.18393973, 0.11156508],
    ///        [0.1947002,  0.15163267, 0.11809164]]
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\random\pdf_op.cc:L305</summary>
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="sample">Samples from the distributions.</param>
    /// <param name="lam">Lambda (rate) parameters of the distributions.</param>
    /// <param name="isLog">If set, compute the density of the log-probability instead of the probability.</param>
    static member RandomPdfExponential(outputArray : NDArray seq, sample : NDArray, lam : NDArray, [<Optional; DefaultParameterValue(false)>] isLog : bool) =
        let creator = AtomicSymbolCreator.FromName "_random_pdf_exponential"
        let names = [|"is_log"|]
        let vals = [|string isLog|]
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg sample)) then sample.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg lam)) then lam.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <summary>Computes the value of the PDF of *sample* of
    /// exponential distributions with parameters *lam* (rate).
    /// 
    /// The shape of *lam* must match the leftmost subshape of *sample*.  That is, *sample*
    /// can have the same shape as *lam*, in which case the output contains one density per
    /// distribution, or *sample* can be a tensor of tensors with that shape, in which case
    /// the output is a tensor of densities such that the densities at index *i* in the output
    /// are given by the samples at index *i* in *sample* parameterized by the value of *lam*
    /// at index *i*.
    /// 
    /// Examples::
    /// 
    ///   random_pdf_exponential(sample=[[1, 2, 3]], lam=[1]) =
    ///       [[0.36787945, 0.13533528, 0.04978707]]
    /// 
    ///   sample = [[1,2,3],
    ///             [1,2,3],
    ///             [1,2,3]]
    /// 
    ///   random_pdf_exponential(sample=sample, lam=[1,0.5,0.25]) =
    ///       [[0.36787945, 0.13533528, 0.04978707],
    ///        [0.30326533, 0.18393973, 0.11156508],
    ///        [0.1947002,  0.15163267, 0.11809164]]
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\random\pdf_op.cc:L305</summary>
    /// <param name="sample">Samples from the distributions.</param>
    /// <param name="lam">Lambda (rate) parameters of the distributions.</param>
    /// <param name="isLog">If set, compute the density of the log-probability instead of the probability.</param>
    static member RandomPdfExponential([<Optional>] ?sample : Symbol, [<Optional>] ?lam : Symbol, [<Optional>] ?isLog : bool) =
        RandomPdfExponential(?sample = sample, ?lam = lam, ?isLog = isLog)


    /// <summary>Computes the value of the PDF of *sample* of
    /// Poisson distributions with parameters *lam* (rate).
    /// 
    /// The shape of *lam* must match the leftmost subshape of *sample*.  That is, *sample*
    /// can have the same shape as *lam*, in which case the output contains one density per
    /// distribution, or *sample* can be a tensor of tensors with that shape, in which case
    /// the output is a tensor of densities such that the densities at index *i* in the output
    /// are given by the samples at index *i* in *sample* parameterized by the value of *lam*
    /// at index *i*.
    /// 
    /// Examples::
    /// 
    ///     random_pdf_poisson(sample=[[0,1,2,3]], lam=[1]) =
    ///         [[0.36787945, 0.36787945, 0.18393973, 0.06131324]]
    /// 
    ///     sample = [[0,1,2,3],
    ///               [0,1,2,3],
    ///               [0,1,2,3]]
    /// 
    ///     random_pdf_poisson(sample=sample, lam=[1,2,3]) =
    ///         [[0.36787945, 0.36787945, 0.18393973, 0.06131324],
    ///          [0.13533528, 0.27067056, 0.27067056, 0.18044704],
    ///          [0.04978707, 0.14936121, 0.22404182, 0.22404182]]
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\random\pdf_op.cc:L307</summary>
    /// <param name="sample">Samples from the distributions.</param>
    /// <param name="lam">Lambda (rate) parameters of the distributions.</param>
    /// <param name="isLog">If set, compute the density of the log-probability instead of the probability.</param>
    static member RandomPdfPoisson(sample : NDArray, lam : NDArray, [<Optional; DefaultParameterValue(false)>] isLog : bool) =
        let creator = AtomicSymbolCreator.FromName "_random_pdf_poisson"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg sample)) then sample.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg lam)) then lam.UnsafeHandle|]
                                                 [|"is_log"|]
                                                 [|string isLog|]
        outputs |> Array.map (fun h -> new NDArray(h))
    /// <summary>Computes the value of the PDF of *sample* of
    /// Poisson distributions with parameters *lam* (rate).
    /// 
    /// The shape of *lam* must match the leftmost subshape of *sample*.  That is, *sample*
    /// can have the same shape as *lam*, in which case the output contains one density per
    /// distribution, or *sample* can be a tensor of tensors with that shape, in which case
    /// the output is a tensor of densities such that the densities at index *i* in the output
    /// are given by the samples at index *i* in *sample* parameterized by the value of *lam*
    /// at index *i*.
    /// 
    /// Examples::
    /// 
    ///     random_pdf_poisson(sample=[[0,1,2,3]], lam=[1]) =
    ///         [[0.36787945, 0.36787945, 0.18393973, 0.06131324]]
    /// 
    ///     sample = [[0,1,2,3],
    ///               [0,1,2,3],
    ///               [0,1,2,3]]
    /// 
    ///     random_pdf_poisson(sample=sample, lam=[1,2,3]) =
    ///         [[0.36787945, 0.36787945, 0.18393973, 0.06131324],
    ///          [0.13533528, 0.27067056, 0.27067056, 0.18044704],
    ///          [0.04978707, 0.14936121, 0.22404182, 0.22404182]]
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\random\pdf_op.cc:L307</summary>
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="sample">Samples from the distributions.</param>
    /// <param name="lam">Lambda (rate) parameters of the distributions.</param>
    /// <param name="isLog">If set, compute the density of the log-probability instead of the probability.</param>
    static member RandomPdfPoisson(outputArray : NDArray seq, sample : NDArray, lam : NDArray, [<Optional; DefaultParameterValue(false)>] isLog : bool) =
        let creator = AtomicSymbolCreator.FromName "_random_pdf_poisson"
        let names = [|"is_log"|]
        let vals = [|string isLog|]
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg sample)) then sample.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg lam)) then lam.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <summary>Computes the value of the PDF of *sample* of
    /// Poisson distributions with parameters *lam* (rate).
    /// 
    /// The shape of *lam* must match the leftmost subshape of *sample*.  That is, *sample*
    /// can have the same shape as *lam*, in which case the output contains one density per
    /// distribution, or *sample* can be a tensor of tensors with that shape, in which case
    /// the output is a tensor of densities such that the densities at index *i* in the output
    /// are given by the samples at index *i* in *sample* parameterized by the value of *lam*
    /// at index *i*.
    /// 
    /// Examples::
    /// 
    ///     random_pdf_poisson(sample=[[0,1,2,3]], lam=[1]) =
    ///         [[0.36787945, 0.36787945, 0.18393973, 0.06131324]]
    /// 
    ///     sample = [[0,1,2,3],
    ///               [0,1,2,3],
    ///               [0,1,2,3]]
    /// 
    ///     random_pdf_poisson(sample=sample, lam=[1,2,3]) =
    ///         [[0.36787945, 0.36787945, 0.18393973, 0.06131324],
    ///          [0.13533528, 0.27067056, 0.27067056, 0.18044704],
    ///          [0.04978707, 0.14936121, 0.22404182, 0.22404182]]
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\random\pdf_op.cc:L307</summary>
    /// <param name="sample">Samples from the distributions.</param>
    /// <param name="lam">Lambda (rate) parameters of the distributions.</param>
    /// <param name="isLog">If set, compute the density of the log-probability instead of the probability.</param>
    static member RandomPdfPoisson([<Optional>] ?sample : Symbol, [<Optional>] ?lam : Symbol, [<Optional>] ?isLog : bool) =
        RandomPdfPoisson(?sample = sample, ?lam = lam, ?isLog = isLog)


    /// <summary>Computes the value of the PDF of samples of
    /// negative binomial distributions with parameters *k* (failure limit) and *p* (failure probability).
    /// 
    /// *k* and *p* must have the same shape, which must match the leftmost subshape
    /// of *sample*.  That is, *sample* can have the same shape as *k* and *p*, in which
    /// case the output contains one density per distribution, or *sample* can be a tensor
    /// of tensors with that shape, in which case the output is a tensor of densities such that
    /// the densities at index *i* in the output are given by the samples at index *i* in *sample*
    /// parameterized by the values of *k* and *p* at index *i*.
    /// 
    /// Examples::
    /// 
    ///     random_pdf_negative_binomial(sample=[[1,2,3,4]], k=[1], p=a[0.5]) =
    ///         [[0.25, 0.125, 0.0625, 0.03125]]
    /// 
    ///     # Note that k may be real-valued
    ///     sample = [[1,2,3,4],
    ///               [1,2,3,4]]
    ///     random_pdf_negative_binomial(sample=sample, k=[1, 1.5], p=[0.5, 0.5]) =
    ///         [[0.25,       0.125,      0.0625,     0.03125   ],
    ///          [0.26516506, 0.16572815, 0.09667476, 0.05437956]]
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\random\pdf_op.cc:L310</summary>
    /// <param name="sample">Samples from the distributions.</param>
    /// <param name="k">Limits of unsuccessful experiments.</param>
    /// <param name="p">Failure probabilities in each experiment.</param>
    /// <param name="isLog">If set, compute the density of the log-probability instead of the probability.</param>
    static member RandomPdfNegativeBinomial(sample : NDArray, k : NDArray, p : NDArray, [<Optional; DefaultParameterValue(false)>] isLog : bool) =
        let creator = AtomicSymbolCreator.FromName "_random_pdf_negative_binomial"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg sample)) then sample.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg k)) then k.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg p)) then p.UnsafeHandle|]
                                                 [|"is_log"|]
                                                 [|string isLog|]
        outputs |> Array.map (fun h -> new NDArray(h))
    /// <summary>Computes the value of the PDF of samples of
    /// negative binomial distributions with parameters *k* (failure limit) and *p* (failure probability).
    /// 
    /// *k* and *p* must have the same shape, which must match the leftmost subshape
    /// of *sample*.  That is, *sample* can have the same shape as *k* and *p*, in which
    /// case the output contains one density per distribution, or *sample* can be a tensor
    /// of tensors with that shape, in which case the output is a tensor of densities such that
    /// the densities at index *i* in the output are given by the samples at index *i* in *sample*
    /// parameterized by the values of *k* and *p* at index *i*.
    /// 
    /// Examples::
    /// 
    ///     random_pdf_negative_binomial(sample=[[1,2,3,4]], k=[1], p=a[0.5]) =
    ///         [[0.25, 0.125, 0.0625, 0.03125]]
    /// 
    ///     # Note that k may be real-valued
    ///     sample = [[1,2,3,4],
    ///               [1,2,3,4]]
    ///     random_pdf_negative_binomial(sample=sample, k=[1, 1.5], p=[0.5, 0.5]) =
    ///         [[0.25,       0.125,      0.0625,     0.03125   ],
    ///          [0.26516506, 0.16572815, 0.09667476, 0.05437956]]
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\random\pdf_op.cc:L310</summary>
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="sample">Samples from the distributions.</param>
    /// <param name="k">Limits of unsuccessful experiments.</param>
    /// <param name="p">Failure probabilities in each experiment.</param>
    /// <param name="isLog">If set, compute the density of the log-probability instead of the probability.</param>
    static member RandomPdfNegativeBinomial(outputArray : NDArray seq, sample : NDArray, k : NDArray, p : NDArray, [<Optional; DefaultParameterValue(false)>] isLog : bool) =
        let creator = AtomicSymbolCreator.FromName "_random_pdf_negative_binomial"
        let names = [|"is_log"|]
        let vals = [|string isLog|]
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg sample)) then sample.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg k)) then k.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg p)) then p.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <summary>Computes the value of the PDF of samples of
    /// negative binomial distributions with parameters *k* (failure limit) and *p* (failure probability).
    /// 
    /// *k* and *p* must have the same shape, which must match the leftmost subshape
    /// of *sample*.  That is, *sample* can have the same shape as *k* and *p*, in which
    /// case the output contains one density per distribution, or *sample* can be a tensor
    /// of tensors with that shape, in which case the output is a tensor of densities such that
    /// the densities at index *i* in the output are given by the samples at index *i* in *sample*
    /// parameterized by the values of *k* and *p* at index *i*.
    /// 
    /// Examples::
    /// 
    ///     random_pdf_negative_binomial(sample=[[1,2,3,4]], k=[1], p=a[0.5]) =
    ///         [[0.25, 0.125, 0.0625, 0.03125]]
    /// 
    ///     # Note that k may be real-valued
    ///     sample = [[1,2,3,4],
    ///               [1,2,3,4]]
    ///     random_pdf_negative_binomial(sample=sample, k=[1, 1.5], p=[0.5, 0.5]) =
    ///         [[0.25,       0.125,      0.0625,     0.03125   ],
    ///          [0.26516506, 0.16572815, 0.09667476, 0.05437956]]
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\random\pdf_op.cc:L310</summary>
    /// <param name="sample">Samples from the distributions.</param>
    /// <param name="k">Limits of unsuccessful experiments.</param>
    /// <param name="p">Failure probabilities in each experiment.</param>
    /// <param name="isLog">If set, compute the density of the log-probability instead of the probability.</param>
    static member RandomPdfNegativeBinomial([<Optional>] ?sample : Symbol, [<Optional>] ?k : Symbol, [<Optional>] ?p : Symbol, [<Optional>] ?isLog : bool) =
        RandomPdfNegativeBinomial(?sample = sample, ?k = k, ?p = p, ?isLog = isLog)


    /// <summary>Computes the value of the PDF of *sample* of
    /// generalized negative binomial distributions with parameters *mu* (mean)
    /// and *alpha* (dispersion).  This can be understood as a reparameterization of
    /// the negative binomial, where *k* = *1 / alpha* and *p* = *1 / (mu \* alpha + 1)*.
    /// 
    /// *mu* and *alpha* must have the same shape, which must match the leftmost subshape
    /// of *sample*.  That is, *sample* can have the same shape as *mu* and *alpha*, in which
    /// case the output contains one density per distribution, or *sample* can be a tensor
    /// of tensors with that shape, in which case the output is a tensor of densities such that
    /// the densities at index *i* in the output are given by the samples at index *i* in *sample*
    /// parameterized by the values of *mu* and *alpha* at index *i*.
    /// 
    /// Examples::
    /// 
    ///     random_pdf_generalized_negative_binomial(sample=[[1, 2, 3, 4]], alpha=[1], mu=[1]) =
    ///         [[0.25, 0.125, 0.0625, 0.03125]]
    /// 
    ///     sample = [[1,2,3,4],
    ///               [1,2,3,4]]
    ///     random_pdf_generalized_negative_binomial(sample=sample, alpha=[1, 0.6666], mu=[1, 1.5]) =
    ///         [[0.25,       0.125,      0.0625,     0.03125   ],
    ///          [0.26517063, 0.16573331, 0.09667706, 0.05437994]]
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\random\pdf_op.cc:L314</summary>
    /// <param name="sample">Samples from the distributions.</param>
    /// <param name="mu">Means of the distributions.</param>
    /// <param name="alpha">Alpha (dispersion) parameters of the distributions.</param>
    /// <param name="isLog">If set, compute the density of the log-probability instead of the probability.</param>
    static member RandomPdfGeneralizedNegativeBinomial(sample : NDArray, mu : NDArray, alpha : NDArray, [<Optional; DefaultParameterValue(false)>] isLog : bool) =
        let creator = AtomicSymbolCreator.FromName "_random_pdf_generalized_negative_binomial"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg sample)) then sample.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg mu)) then mu.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg alpha)) then alpha.UnsafeHandle|]
                                                 [|"is_log"|]
                                                 [|string isLog|]
        outputs |> Array.map (fun h -> new NDArray(h))
    /// <summary>Computes the value of the PDF of *sample* of
    /// generalized negative binomial distributions with parameters *mu* (mean)
    /// and *alpha* (dispersion).  This can be understood as a reparameterization of
    /// the negative binomial, where *k* = *1 / alpha* and *p* = *1 / (mu \* alpha + 1)*.
    /// 
    /// *mu* and *alpha* must have the same shape, which must match the leftmost subshape
    /// of *sample*.  That is, *sample* can have the same shape as *mu* and *alpha*, in which
    /// case the output contains one density per distribution, or *sample* can be a tensor
    /// of tensors with that shape, in which case the output is a tensor of densities such that
    /// the densities at index *i* in the output are given by the samples at index *i* in *sample*
    /// parameterized by the values of *mu* and *alpha* at index *i*.
    /// 
    /// Examples::
    /// 
    ///     random_pdf_generalized_negative_binomial(sample=[[1, 2, 3, 4]], alpha=[1], mu=[1]) =
    ///         [[0.25, 0.125, 0.0625, 0.03125]]
    /// 
    ///     sample = [[1,2,3,4],
    ///               [1,2,3,4]]
    ///     random_pdf_generalized_negative_binomial(sample=sample, alpha=[1, 0.6666], mu=[1, 1.5]) =
    ///         [[0.25,       0.125,      0.0625,     0.03125   ],
    ///          [0.26517063, 0.16573331, 0.09667706, 0.05437994]]
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\random\pdf_op.cc:L314</summary>
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="sample">Samples from the distributions.</param>
    /// <param name="mu">Means of the distributions.</param>
    /// <param name="alpha">Alpha (dispersion) parameters of the distributions.</param>
    /// <param name="isLog">If set, compute the density of the log-probability instead of the probability.</param>
    static member RandomPdfGeneralizedNegativeBinomial(outputArray : NDArray seq, sample : NDArray, mu : NDArray, alpha : NDArray, [<Optional; DefaultParameterValue(false)>] isLog : bool) =
        let creator = AtomicSymbolCreator.FromName "_random_pdf_generalized_negative_binomial"
        let names = [|"is_log"|]
        let vals = [|string isLog|]
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg sample)) then sample.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg mu)) then mu.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg alpha)) then alpha.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <summary>Computes the value of the PDF of *sample* of
    /// generalized negative binomial distributions with parameters *mu* (mean)
    /// and *alpha* (dispersion).  This can be understood as a reparameterization of
    /// the negative binomial, where *k* = *1 / alpha* and *p* = *1 / (mu \* alpha + 1)*.
    /// 
    /// *mu* and *alpha* must have the same shape, which must match the leftmost subshape
    /// of *sample*.  That is, *sample* can have the same shape as *mu* and *alpha*, in which
    /// case the output contains one density per distribution, or *sample* can be a tensor
    /// of tensors with that shape, in which case the output is a tensor of densities such that
    /// the densities at index *i* in the output are given by the samples at index *i* in *sample*
    /// parameterized by the values of *mu* and *alpha* at index *i*.
    /// 
    /// Examples::
    /// 
    ///     random_pdf_generalized_negative_binomial(sample=[[1, 2, 3, 4]], alpha=[1], mu=[1]) =
    ///         [[0.25, 0.125, 0.0625, 0.03125]]
    /// 
    ///     sample = [[1,2,3,4],
    ///               [1,2,3,4]]
    ///     random_pdf_generalized_negative_binomial(sample=sample, alpha=[1, 0.6666], mu=[1, 1.5]) =
    ///         [[0.25,       0.125,      0.0625,     0.03125   ],
    ///          [0.26517063, 0.16573331, 0.09667706, 0.05437994]]
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\random\pdf_op.cc:L314</summary>
    /// <param name="sample">Samples from the distributions.</param>
    /// <param name="mu">Means of the distributions.</param>
    /// <param name="alpha">Alpha (dispersion) parameters of the distributions.</param>
    /// <param name="isLog">If set, compute the density of the log-probability instead of the probability.</param>
    static member RandomPdfGeneralizedNegativeBinomial([<Optional>] ?sample : Symbol, [<Optional>] ?mu : Symbol, [<Optional>] ?alpha : Symbol, [<Optional>] ?isLog : bool) =
        RandomPdfGeneralizedNegativeBinomial(?sample = sample, ?mu = mu, ?alpha = alpha, ?isLog = isLog)


    /// <summary>Computes the value of the PDF of *sample* of
    /// Dirichlet distributions with parameter *alpha*.
    /// 
    /// The shape of *alpha* must match the leftmost subshape of *sample*.  That is, *sample*
    /// can have the same shape as *alpha*, in which case the output contains one density per
    /// distribution, or *sample* can be a tensor of tensors with that shape, in which case
    /// the output is a tensor of densities such that the densities at index *i* in the output
    /// are given by the samples at index *i* in *sample* parameterized by the value of *alpha*
    /// at index *i*.
    /// 
    /// Examples::
    /// 
    ///     random_pdf_dirichlet(sample=[[1,2],[2,3],[3,4]], alpha=[2.5, 2.5]) =
    ///         [38.413498, 199.60245, 564.56085]
    /// 
    ///     sample = [[[1, 2, 3], [10, 20, 30], [100, 200, 300]],
    ///               [[0.1, 0.2, 0.3], [0.01, 0.02, 0.03], [0.001, 0.002, 0.003]]]
    /// 
    ///     random_pdf_dirichlet(sample=sample, alpha=[0.1, 0.4, 0.9]) =
    ///         [[2.3257459e-02, 5.8420084e-04, 1.4674458e-05],
    ///          [9.2589635e-01, 3.6860607e+01, 1.4674468e+03]]
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\random\pdf_op.cc:L316</summary>
    /// <param name="sample">Samples from the distributions.</param>
    /// <param name="alpha">Concentration parameters of the distributions.</param>
    /// <param name="isLog">If set, compute the density of the log-probability instead of the probability.</param>
    static member RandomPdfDirichlet(sample : NDArray, alpha : NDArray, [<Optional; DefaultParameterValue(false)>] isLog : bool) =
        let creator = AtomicSymbolCreator.FromName "_random_pdf_dirichlet"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg sample)) then sample.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg alpha)) then alpha.UnsafeHandle|]
                                                 [|"is_log"|]
                                                 [|string isLog|]
        outputs |> Array.map (fun h -> new NDArray(h))
    /// <summary>Computes the value of the PDF of *sample* of
    /// Dirichlet distributions with parameter *alpha*.
    /// 
    /// The shape of *alpha* must match the leftmost subshape of *sample*.  That is, *sample*
    /// can have the same shape as *alpha*, in which case the output contains one density per
    /// distribution, or *sample* can be a tensor of tensors with that shape, in which case
    /// the output is a tensor of densities such that the densities at index *i* in the output
    /// are given by the samples at index *i* in *sample* parameterized by the value of *alpha*
    /// at index *i*.
    /// 
    /// Examples::
    /// 
    ///     random_pdf_dirichlet(sample=[[1,2],[2,3],[3,4]], alpha=[2.5, 2.5]) =
    ///         [38.413498, 199.60245, 564.56085]
    /// 
    ///     sample = [[[1, 2, 3], [10, 20, 30], [100, 200, 300]],
    ///               [[0.1, 0.2, 0.3], [0.01, 0.02, 0.03], [0.001, 0.002, 0.003]]]
    /// 
    ///     random_pdf_dirichlet(sample=sample, alpha=[0.1, 0.4, 0.9]) =
    ///         [[2.3257459e-02, 5.8420084e-04, 1.4674458e-05],
    ///          [9.2589635e-01, 3.6860607e+01, 1.4674468e+03]]
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\random\pdf_op.cc:L316</summary>
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="sample">Samples from the distributions.</param>
    /// <param name="alpha">Concentration parameters of the distributions.</param>
    /// <param name="isLog">If set, compute the density of the log-probability instead of the probability.</param>
    static member RandomPdfDirichlet(outputArray : NDArray seq, sample : NDArray, alpha : NDArray, [<Optional; DefaultParameterValue(false)>] isLog : bool) =
        let creator = AtomicSymbolCreator.FromName "_random_pdf_dirichlet"
        let names = [|"is_log"|]
        let vals = [|string isLog|]
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg sample)) then sample.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg alpha)) then alpha.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <summary>Computes the value of the PDF of *sample* of
    /// Dirichlet distributions with parameter *alpha*.
    /// 
    /// The shape of *alpha* must match the leftmost subshape of *sample*.  That is, *sample*
    /// can have the same shape as *alpha*, in which case the output contains one density per
    /// distribution, or *sample* can be a tensor of tensors with that shape, in which case
    /// the output is a tensor of densities such that the densities at index *i* in the output
    /// are given by the samples at index *i* in *sample* parameterized by the value of *alpha*
    /// at index *i*.
    /// 
    /// Examples::
    /// 
    ///     random_pdf_dirichlet(sample=[[1,2],[2,3],[3,4]], alpha=[2.5, 2.5]) =
    ///         [38.413498, 199.60245, 564.56085]
    /// 
    ///     sample = [[[1, 2, 3], [10, 20, 30], [100, 200, 300]],
    ///               [[0.1, 0.2, 0.3], [0.01, 0.02, 0.03], [0.001, 0.002, 0.003]]]
    /// 
    ///     random_pdf_dirichlet(sample=sample, alpha=[0.1, 0.4, 0.9]) =
    ///         [[2.3257459e-02, 5.8420084e-04, 1.4674458e-05],
    ///          [9.2589635e-01, 3.6860607e+01, 1.4674468e+03]]
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\random\pdf_op.cc:L316</summary>
    /// <param name="sample">Samples from the distributions.</param>
    /// <param name="alpha">Concentration parameters of the distributions.</param>
    /// <param name="isLog">If set, compute the density of the log-probability instead of the probability.</param>
    static member RandomPdfDirichlet([<Optional>] ?sample : Symbol, [<Optional>] ?alpha : Symbol, [<Optional>] ?isLog : bool) =
        RandomPdfDirichlet(?sample = sample, ?alpha = alpha, ?isLog = isLog)


    /// <summary>Concurrent sampling from multiple multinomial distributions.
    /// 
    /// *data* is an *n* dimensional array whose last dimension has length *k*, where
    /// *k* is the number of possible outcomes of each multinomial distribution. This
    /// operator will draw *shape* samples from each distribution. If shape is empty
    /// one sample will be drawn from each distribution.
    /// 
    /// If *get_prob* is true, a second array containing log likelihood of the drawn
    /// samples will also be returned. This is usually used for reinforcement learning
    /// where you can provide reward as head gradient for this array to estimate
    /// gradient.
    /// 
    /// Note that the input distribution must be normalized, i.e. *data* must sum to
    /// 1 along its last axis.
    /// 
    /// Examples::
    /// 
    ///    probs = [[0, 0.1, 0.2, 0.3, 0.4], [0.4, 0.3, 0.2, 0.1, 0]]
    /// 
    ///    // Draw a single sample for each distribution
    ///    sample_multinomial(probs) = [3, 0]
    /// 
    ///    // Draw a vector containing two samples for each distribution
    ///    sample_multinomial(probs, shape=(2)) = [[4, 2],
    ///                                            [0, 0]]
    /// 
    ///    // requests log likelihood
    ///    sample_multinomial(probs, get_prob=True) = [2, 1], [0.2, 0.3]
    /// </summary>
    /// <param name="data">Distribution probabilities. Must sum to one on the last axis.</param>
    /// <param name="shape">Shape to be sampled from each random distribution.</param>
    /// <param name="getProb">Whether to also return the log probability of sampled result. This is usually used for differentiating through stochastic variables, e.g. in reinforcement learning.</param>
    /// <param name="dtype">DType of the output in case this can&#39;t be inferred.</param>
    static member SampleMultinomial(data : NDArray, [<Optional>] shape : int seq, [<Optional; DefaultParameterValue(false)>] getProb : bool, [<Optional>] dtype : SampleMultinomialDtype) =
        let creator = AtomicSymbolCreator.FromName "_sample_multinomial"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle|]
                                                 [|"shape"; "get_prob"; "dtype"|]
                                                 [|(if isNull (shape :> obj) then "[]" else (shape |> Seq.map string |> String.concat ", " |> sprintf "[%s]")); string getProb; (if isNull (dtype :> obj) then "int32" else string dtype)|]
        outputs |> Array.map (fun h -> new NDArray(h))
    /// <summary>Concurrent sampling from multiple multinomial distributions.
    /// 
    /// *data* is an *n* dimensional array whose last dimension has length *k*, where
    /// *k* is the number of possible outcomes of each multinomial distribution. This
    /// operator will draw *shape* samples from each distribution. If shape is empty
    /// one sample will be drawn from each distribution.
    /// 
    /// If *get_prob* is true, a second array containing log likelihood of the drawn
    /// samples will also be returned. This is usually used for reinforcement learning
    /// where you can provide reward as head gradient for this array to estimate
    /// gradient.
    /// 
    /// Note that the input distribution must be normalized, i.e. *data* must sum to
    /// 1 along its last axis.
    /// 
    /// Examples::
    /// 
    ///    probs = [[0, 0.1, 0.2, 0.3, 0.4], [0.4, 0.3, 0.2, 0.1, 0]]
    /// 
    ///    // Draw a single sample for each distribution
    ///    sample_multinomial(probs) = [3, 0]
    /// 
    ///    // Draw a vector containing two samples for each distribution
    ///    sample_multinomial(probs, shape=(2)) = [[4, 2],
    ///                                            [0, 0]]
    /// 
    ///    // requests log likelihood
    ///    sample_multinomial(probs, get_prob=True) = [2, 1], [0.2, 0.3]
    /// </summary>
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="data">Distribution probabilities. Must sum to one on the last axis.</param>
    /// <param name="shape">Shape to be sampled from each random distribution.</param>
    /// <param name="getProb">Whether to also return the log probability of sampled result. This is usually used for differentiating through stochastic variables, e.g. in reinforcement learning.</param>
    /// <param name="dtype">DType of the output in case this can&#39;t be inferred.</param>
    static member SampleMultinomial(outputArray : NDArray seq, data : NDArray, [<Optional>] shape : int seq, [<Optional; DefaultParameterValue(false)>] getProb : bool, [<Optional>] dtype : SampleMultinomialDtype) =
        let creator = AtomicSymbolCreator.FromName "_sample_multinomial"
        let names = [|"shape"; "get_prob"; "dtype"|]
        let vals = [|(if isNull (shape :> obj) then "[]" else (shape |> Seq.map string |> String.concat ", " |> sprintf "[%s]")); string getProb; (if isNull (dtype :> obj) then "int32" else string dtype)|]
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <summary>Concurrent sampling from multiple multinomial distributions.
    /// 
    /// *data* is an *n* dimensional array whose last dimension has length *k*, where
    /// *k* is the number of possible outcomes of each multinomial distribution. This
    /// operator will draw *shape* samples from each distribution. If shape is empty
    /// one sample will be drawn from each distribution.
    /// 
    /// If *get_prob* is true, a second array containing log likelihood of the drawn
    /// samples will also be returned. This is usually used for reinforcement learning
    /// where you can provide reward as head gradient for this array to estimate
    /// gradient.
    /// 
    /// Note that the input distribution must be normalized, i.e. *data* must sum to
    /// 1 along its last axis.
    /// 
    /// Examples::
    /// 
    ///    probs = [[0, 0.1, 0.2, 0.3, 0.4], [0.4, 0.3, 0.2, 0.1, 0]]
    /// 
    ///    // Draw a single sample for each distribution
    ///    sample_multinomial(probs) = [3, 0]
    /// 
    ///    // Draw a vector containing two samples for each distribution
    ///    sample_multinomial(probs, shape=(2)) = [[4, 2],
    ///                                            [0, 0]]
    /// 
    ///    // requests log likelihood
    ///    sample_multinomial(probs, get_prob=True) = [2, 1], [0.2, 0.3]
    /// </summary>
    /// <param name="data">Distribution probabilities. Must sum to one on the last axis.</param>
    /// <param name="shape">Shape to be sampled from each random distribution.</param>
    /// <param name="getProb">Whether to also return the log probability of sampled result. This is usually used for differentiating through stochastic variables, e.g. in reinforcement learning.</param>
    /// <param name="dtype">DType of the output in case this can&#39;t be inferred.</param>
    static member SampleMultinomial([<Optional>] ?data : Symbol, [<Optional>] ?shape : int seq, [<Optional>] ?getProb : bool, [<Optional>] ?dtype : SampleMultinomialDtype) =
        SampleMultinomial(?data = data, ?shape = shape, ?getProb = getProb, ?dtype = dtype)


    /// <summary>Draw random samples from a uniform distribution.
    /// 
    /// .. note:: The existing alias ``uniform`` is deprecated.
    /// 
    /// Samples are uniformly distributed over the half-open interval *[low, high)*
    /// (includes *low*, but excludes *high*).
    /// 
    /// Example::
    /// 
    ///    uniform(low=0, high=1, shape=(2,2)) = [[ 0.60276335,  0.85794562],
    ///                                           [ 0.54488319,  0.84725171]]
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\random\sample_op.cc:L96</summary>
    /// <param name="ctx">Context of output, in format [cpu|gpu|cpu_pinned](n). Only used for imperative calls.</param>
    /// <param name="low">Lower bound of the distribution.</param>
    /// <param name="high">Upper bound of the distribution.</param>
    /// <param name="shape">Shape of the output.</param>
    /// <param name="dtype">DType of the output in case this can&#39;t be inferred. Defaults to float32 if not defined (dtype=None).</param>
    static member RandomUniformNDArray(ctx : Context, 
                                       [<Optional; DefaultParameterValue(0.0)>] low : float, 
                                       [<Optional; DefaultParameterValue(1.0)>] high : float, 
                                       [<Optional>] shape : int seq, 
                                       [<Optional>] dtype : FloatDType) =
        let creator = AtomicSymbolCreator.FromName "_random_uniform"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 Array.empty
                                                 [|"ctx"; "low"; "high"; "shape"; "dtype"|]
                                                 [|string ctx; string low; string high; (if isNull (shape :> obj) then null else (shape |> Seq.map string |> String.concat ", " |> sprintf "[%s]")); (if isNull (dtype :> obj) then "None" else string dtype)|]
        (new NDArray(outputs.[0]))
    /// <summary>Draw random samples from a uniform distribution.
    /// 
    /// .. note:: The existing alias ``uniform`` is deprecated.
    /// 
    /// Samples are uniformly distributed over the half-open interval *[low, high)*
    /// (includes *low*, but excludes *high*).
    /// 
    /// Example::
    /// 
    ///    uniform(low=0, high=1, shape=(2,2)) = [[ 0.60276335,  0.85794562],
    ///                                           [ 0.54488319,  0.84725171]]
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\random\sample_op.cc:L96</summary>
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="ctx">Context of output, in format [cpu|gpu|cpu_pinned](n). Only used for imperative calls.</param>
    /// <param name="low">Lower bound of the distribution.</param>
    /// <param name="high">Upper bound of the distribution.</param>
    /// <param name="shape">Shape of the output.</param>
    /// <param name="dtype">DType of the output in case this can&#39;t be inferred. Defaults to float32 if not defined (dtype=None).</param>
    static member RandomUniform(outputArray : NDArray seq, 
                                ctx : Context, 
                                [<Optional; DefaultParameterValue(0.0)>] low : float, 
                                [<Optional; DefaultParameterValue(1.0)>] high : float, 
                                [<Optional>] shape : int seq, 
                                [<Optional>] dtype : FloatDType) =
        let creator = AtomicSymbolCreator.FromName "_random_uniform"
        let names = [|"ctx"; "low"; "high"; "shape"; "dtype"|]
        let vals = [|string ctx; string low; string high; (if isNull (shape :> obj) then null else (shape |> Seq.map string |> String.concat ", " |> sprintf "[%s]")); (if isNull (dtype :> obj) then "None" else string dtype)|]
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     Array.empty
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <summary>Draw random samples from a uniform distribution.
    /// 
    /// .. note:: The existing alias ``uniform`` is deprecated.
    /// 
    /// Samples are uniformly distributed over the half-open interval *[low, high)*
    /// (includes *low*, but excludes *high*).
    /// 
    /// Example::
    /// 
    ///    uniform(low=0, high=1, shape=(2,2)) = [[ 0.60276335,  0.85794562],
    ///                                           [ 0.54488319,  0.84725171]]
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\random\sample_op.cc:L96</summary>
    /// <param name="low">Lower bound of the distribution.</param>
    /// <param name="high">Upper bound of the distribution.</param>
    /// <param name="shape">Shape of the output.</param>
    /// <param name="dtype">DType of the output in case this can&#39;t be inferred. Defaults to float32 if not defined (dtype=None).</param>
    static member RandomUniform([<Optional>] ?low : float, [<Optional>] ?high : float, [<Optional>] ?shape : int seq, [<Optional>] ?dtype : FloatDType) =
        RandomUniform(?low = low, ?high = high, ?shape = shape, ?dtype = dtype)

    /// <summary>Draw random samples from a normal (Gaussian) distribution.
    /// 
    /// .. note:: The existing alias ``normal`` is deprecated.
    /// 
    /// Samples are distributed according to a normal distribution parametrized by *loc* (mean) and *scale*
    /// (standard deviation).
    /// 
    /// Example::
    /// 
    ///    normal(loc=0, scale=1, shape=(2,2)) = [[ 1.89171135, -1.16881478],
    ///                                           [-1.23474145,  1.55807114]]
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\random\sample_op.cc:L113</summary>
    /// <param name="ctx">Context of output, in format [cpu|gpu|cpu_pinned](n). Only used for imperative calls.</param>
    /// <param name="loc">Mean of the distribution.</param>
    /// <param name="scale">Standard deviation of the distribution.</param>
    /// <param name="shape">Shape of the output.</param>
    /// <param name="dtype">DType of the output in case this can&#39;t be inferred. Defaults to float32 if not defined (dtype=None).</param>
    static member RandomNormalNDArray(ctx : Context, 
                                      [<Optional; DefaultParameterValue(0.0)>] loc : float, 
                                      [<Optional; DefaultParameterValue(1.0)>] scale : float, 
                                      [<Optional>] shape : int seq, 
                                      [<Optional>] dtype : FloatDType) =
        let creator = AtomicSymbolCreator.FromName "_random_normal"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 Array.empty
                                                 [|"ctx"; "loc"; "scale"; "shape"; "dtype"|]
                                                 [|string ctx; string loc; string scale; (if isNull (shape :> obj) then null else (shape |> Seq.map string |> String.concat ", " |> sprintf "[%s]")); (if isNull (dtype :> obj) then "None" else string dtype)|]
        (new NDArray(outputs.[0]))
    /// <summary>Draw random samples from a normal (Gaussian) distribution.
    /// 
    /// .. note:: The existing alias ``normal`` is deprecated.
    /// 
    /// Samples are distributed according to a normal distribution parametrized by *loc* (mean) and *scale*
    /// (standard deviation).
    /// 
    /// Example::
    /// 
    ///    normal(loc=0, scale=1, shape=(2,2)) = [[ 1.89171135, -1.16881478],
    ///                                           [-1.23474145,  1.55807114]]
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\random\sample_op.cc:L113</summary>
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="ctx">Context of output, in format [cpu|gpu|cpu_pinned](n). Only used for imperative calls.</param>
    /// <param name="loc">Mean of the distribution.</param>
    /// <param name="scale">Standard deviation of the distribution.</param>
    /// <param name="shape">Shape of the output.</param>
    /// <param name="dtype">DType of the output in case this can&#39;t be inferred. Defaults to float32 if not defined (dtype=None).</param>
    static member RandomNormal(outputArray : NDArray seq, 
                               ctx : Context, 
                               [<Optional; DefaultParameterValue(0.0)>] loc : float, 
                               [<Optional; DefaultParameterValue(1.0)>] scale : float, 
                               [<Optional>] shape : int seq, 
                               [<Optional>] dtype : FloatDType) =
        let creator = AtomicSymbolCreator.FromName "_random_normal"
        let names = [|"ctx"; "loc"; "scale"; "shape"; "dtype"|]
        let vals = [|string ctx; string loc; string scale; (if isNull (shape :> obj) then null else (shape |> Seq.map string |> String.concat ", " |> sprintf "[%s]")); (if isNull (dtype :> obj) then "None" else string dtype)|]
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     Array.empty
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <summary>Draw random samples from a normal (Gaussian) distribution.
    /// 
    /// .. note:: The existing alias ``normal`` is deprecated.
    /// 
    /// Samples are distributed according to a normal distribution parametrized by *loc* (mean) and *scale*
    /// (standard deviation).
    /// 
    /// Example::
    /// 
    ///    normal(loc=0, scale=1, shape=(2,2)) = [[ 1.89171135, -1.16881478],
    ///                                           [-1.23474145,  1.55807114]]
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\random\sample_op.cc:L113</summary>
    /// <param name="loc">Mean of the distribution.</param>
    /// <param name="scale">Standard deviation of the distribution.</param>
    /// <param name="shape">Shape of the output.</param>
    /// <param name="dtype">DType of the output in case this can&#39;t be inferred. Defaults to float32 if not defined (dtype=None).</param>
    static member RandomNormal([<Optional>] ?loc : float, [<Optional>] ?scale : float, [<Optional>] ?shape : int seq, [<Optional>] ?dtype : FloatDType) =
        RandomNormal(?loc = loc, ?scale = scale, ?shape = shape, ?dtype = dtype)

    /// <summary>Draw random samples from a gamma distribution.
    /// 
    /// Samples are distributed according to a gamma distribution parametrized by *alpha* (shape) and *beta* (scale).
    /// 
    /// Example::
    /// 
    ///    gamma(alpha=9, beta=0.5, shape=(2,2)) = [[ 7.10486984,  3.37695289],
    ///                                             [ 3.91697288,  3.65933681]]
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\random\sample_op.cc:L125</summary>
    /// <param name="ctx">Context of output, in format [cpu|gpu|cpu_pinned](n). Only used for imperative calls.</param>
    /// <param name="alpha">Alpha parameter (shape) of the gamma distribution.</param>
    /// <param name="beta">Beta parameter (scale) of the gamma distribution.</param>
    /// <param name="shape">Shape of the output.</param>
    /// <param name="dtype">DType of the output in case this can&#39;t be inferred. Defaults to float32 if not defined (dtype=None).</param>
    static member RandomGammaNDArray(ctx : Context, 
                                     [<Optional; DefaultParameterValue(1.0)>] alpha : float, 
                                     [<Optional; DefaultParameterValue(1.0)>] beta : float, 
                                     [<Optional>] shape : int seq, 
                                     [<Optional>] dtype : FloatDType) =
        let creator = AtomicSymbolCreator.FromName "_random_gamma"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 Array.empty
                                                 [|"ctx"; "alpha"; "beta"; "shape"; "dtype"|]
                                                 [|string ctx; string alpha; string beta; (if isNull (shape :> obj) then null else (shape |> Seq.map string |> String.concat ", " |> sprintf "[%s]")); (if isNull (dtype :> obj) then "None" else string dtype)|]
        (new NDArray(outputs.[0]))
    /// <summary>Draw random samples from a gamma distribution.
    /// 
    /// Samples are distributed according to a gamma distribution parametrized by *alpha* (shape) and *beta* (scale).
    /// 
    /// Example::
    /// 
    ///    gamma(alpha=9, beta=0.5, shape=(2,2)) = [[ 7.10486984,  3.37695289],
    ///                                             [ 3.91697288,  3.65933681]]
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\random\sample_op.cc:L125</summary>
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="ctx">Context of output, in format [cpu|gpu|cpu_pinned](n). Only used for imperative calls.</param>
    /// <param name="alpha">Alpha parameter (shape) of the gamma distribution.</param>
    /// <param name="beta">Beta parameter (scale) of the gamma distribution.</param>
    /// <param name="shape">Shape of the output.</param>
    /// <param name="dtype">DType of the output in case this can&#39;t be inferred. Defaults to float32 if not defined (dtype=None).</param>
    static member RandomGamma(outputArray : NDArray seq, 
                              ctx : Context, 
                              [<Optional; DefaultParameterValue(1.0)>] alpha : float, 
                              [<Optional; DefaultParameterValue(1.0)>] beta : float, 
                              [<Optional>] shape : int seq, 
                              [<Optional>] dtype : FloatDType) =
        let creator = AtomicSymbolCreator.FromName "_random_gamma"
        let names = [|"ctx"; "alpha"; "beta"; "shape"; "dtype"|]
        let vals = [|string ctx; string alpha; string beta; (if isNull (shape :> obj) then null else (shape |> Seq.map string |> String.concat ", " |> sprintf "[%s]")); (if isNull (dtype :> obj) then "None" else string dtype)|]
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     Array.empty
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <summary>Draw random samples from a gamma distribution.
    /// 
    /// Samples are distributed according to a gamma distribution parametrized by *alpha* (shape) and *beta* (scale).
    /// 
    /// Example::
    /// 
    ///    gamma(alpha=9, beta=0.5, shape=(2,2)) = [[ 7.10486984,  3.37695289],
    ///                                             [ 3.91697288,  3.65933681]]
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\random\sample_op.cc:L125</summary>
    /// <param name="alpha">Alpha parameter (shape) of the gamma distribution.</param>
    /// <param name="beta">Beta parameter (scale) of the gamma distribution.</param>
    /// <param name="shape">Shape of the output.</param>
    /// <param name="dtype">DType of the output in case this can&#39;t be inferred. Defaults to float32 if not defined (dtype=None).</param>
    static member RandomGamma([<Optional>] ?alpha : float, [<Optional>] ?beta : float, [<Optional>] ?shape : int seq, [<Optional>] ?dtype : FloatDType) =
        RandomGamma(?alpha = alpha, ?beta = beta, ?shape = shape, ?dtype = dtype)

    /// <summary>Draw random samples from an exponential distribution.
    /// 
    /// Samples are distributed according to an exponential distribution parametrized by *lambda* (rate).
    /// 
    /// Example::
    /// 
    ///    exponential(lam=4, shape=(2,2)) = [[ 0.0097189 ,  0.08999364],
    ///                                       [ 0.04146638,  0.31715935]]
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\random\sample_op.cc:L137</summary>
    /// <param name="ctx">Context of output, in format [cpu|gpu|cpu_pinned](n). Only used for imperative calls.</param>
    /// <param name="lam">Lambda parameter (rate) of the exponential distribution.</param>
    /// <param name="shape">Shape of the output.</param>
    /// <param name="dtype">DType of the output in case this can&#39;t be inferred. Defaults to float32 if not defined (dtype=None).</param>
    static member RandomExponentialNDArray(ctx : Context, [<Optional; DefaultParameterValue(1.0)>] lam : float, [<Optional>] shape : int seq, [<Optional>] dtype : FloatDType) =
        let creator = AtomicSymbolCreator.FromName "_random_exponential"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 Array.empty
                                                 [|"ctx"; "lam"; "shape"; "dtype"|]
                                                 [|string ctx; string lam; (if isNull (shape :> obj) then null else (shape |> Seq.map string |> String.concat ", " |> sprintf "[%s]")); (if isNull (dtype :> obj) then "None" else string dtype)|]
        (new NDArray(outputs.[0]))
    /// <summary>Draw random samples from an exponential distribution.
    /// 
    /// Samples are distributed according to an exponential distribution parametrized by *lambda* (rate).
    /// 
    /// Example::
    /// 
    ///    exponential(lam=4, shape=(2,2)) = [[ 0.0097189 ,  0.08999364],
    ///                                       [ 0.04146638,  0.31715935]]
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\random\sample_op.cc:L137</summary>
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="ctx">Context of output, in format [cpu|gpu|cpu_pinned](n). Only used for imperative calls.</param>
    /// <param name="lam">Lambda parameter (rate) of the exponential distribution.</param>
    /// <param name="shape">Shape of the output.</param>
    /// <param name="dtype">DType of the output in case this can&#39;t be inferred. Defaults to float32 if not defined (dtype=None).</param>
    static member RandomExponential(outputArray : NDArray seq, ctx : Context, [<Optional; DefaultParameterValue(1.0)>] lam : float, [<Optional>] shape : int seq, [<Optional>] dtype : FloatDType) =
        let creator = AtomicSymbolCreator.FromName "_random_exponential"
        let names = [|"ctx"; "lam"; "shape"; "dtype"|]
        let vals = [|string ctx; string lam; (if isNull (shape :> obj) then null else (shape |> Seq.map string |> String.concat ", " |> sprintf "[%s]")); (if isNull (dtype :> obj) then "None" else string dtype)|]
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     Array.empty
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <summary>Draw random samples from an exponential distribution.
    /// 
    /// Samples are distributed according to an exponential distribution parametrized by *lambda* (rate).
    /// 
    /// Example::
    /// 
    ///    exponential(lam=4, shape=(2,2)) = [[ 0.0097189 ,  0.08999364],
    ///                                       [ 0.04146638,  0.31715935]]
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\random\sample_op.cc:L137</summary>
    /// <param name="lam">Lambda parameter (rate) of the exponential distribution.</param>
    /// <param name="shape">Shape of the output.</param>
    /// <param name="dtype">DType of the output in case this can&#39;t be inferred. Defaults to float32 if not defined (dtype=None).</param>
    static member RandomExponential([<Optional>] ?lam : float, [<Optional>] ?shape : int seq, [<Optional>] ?dtype : FloatDType) =
        RandomExponential(?lam = lam, ?shape = shape, ?dtype = dtype)

    /// <summary>Draw random samples from a Poisson distribution.
    /// 
    /// Samples are distributed according to a Poisson distribution parametrized by *lambda* (rate).
    /// Samples will always be returned as a floating point data type.
    /// 
    /// Example::
    /// 
    ///    poisson(lam=4, shape=(2,2)) = [[ 5.,  2.],
    ///                                   [ 4.,  6.]]
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\random\sample_op.cc:L150</summary>
    /// <param name="ctx">Context of output, in format [cpu|gpu|cpu_pinned](n). Only used for imperative calls.</param>
    /// <param name="lam">Lambda parameter (rate) of the Poisson distribution.</param>
    /// <param name="shape">Shape of the output.</param>
    /// <param name="dtype">DType of the output in case this can&#39;t be inferred. Defaults to float32 if not defined (dtype=None).</param>
    static member RandomPoissonNDArray(ctx : Context, [<Optional; DefaultParameterValue(1.0)>] lam : float, [<Optional>] shape : int seq, [<Optional>] dtype : FloatDType) =
        let creator = AtomicSymbolCreator.FromName "_random_poisson"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 Array.empty
                                                 [|"ctx"; "lam"; "shape"; "dtype"|]
                                                 [|string ctx; string lam; (if isNull (shape :> obj) then null else (shape |> Seq.map string |> String.concat ", " |> sprintf "[%s]")); (if isNull (dtype :> obj) then "None" else string dtype)|]
        (new NDArray(outputs.[0]))
    /// <summary>Draw random samples from a Poisson distribution.
    /// 
    /// Samples are distributed according to a Poisson distribution parametrized by *lambda* (rate).
    /// Samples will always be returned as a floating point data type.
    /// 
    /// Example::
    /// 
    ///    poisson(lam=4, shape=(2,2)) = [[ 5.,  2.],
    ///                                   [ 4.,  6.]]
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\random\sample_op.cc:L150</summary>
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="ctx">Context of output, in format [cpu|gpu|cpu_pinned](n). Only used for imperative calls.</param>
    /// <param name="lam">Lambda parameter (rate) of the Poisson distribution.</param>
    /// <param name="shape">Shape of the output.</param>
    /// <param name="dtype">DType of the output in case this can&#39;t be inferred. Defaults to float32 if not defined (dtype=None).</param>
    static member RandomPoisson(outputArray : NDArray seq, ctx : Context, [<Optional; DefaultParameterValue(1.0)>] lam : float, [<Optional>] shape : int seq, [<Optional>] dtype : FloatDType) =
        let creator = AtomicSymbolCreator.FromName "_random_poisson"
        let names = [|"ctx"; "lam"; "shape"; "dtype"|]
        let vals = [|string ctx; string lam; (if isNull (shape :> obj) then null else (shape |> Seq.map string |> String.concat ", " |> sprintf "[%s]")); (if isNull (dtype :> obj) then "None" else string dtype)|]
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     Array.empty
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <summary>Draw random samples from a Poisson distribution.
    /// 
    /// Samples are distributed according to a Poisson distribution parametrized by *lambda* (rate).
    /// Samples will always be returned as a floating point data type.
    /// 
    /// Example::
    /// 
    ///    poisson(lam=4, shape=(2,2)) = [[ 5.,  2.],
    ///                                   [ 4.,  6.]]
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\random\sample_op.cc:L150</summary>
    /// <param name="lam">Lambda parameter (rate) of the Poisson distribution.</param>
    /// <param name="shape">Shape of the output.</param>
    /// <param name="dtype">DType of the output in case this can&#39;t be inferred. Defaults to float32 if not defined (dtype=None).</param>
    static member RandomPoisson([<Optional>] ?lam : float, [<Optional>] ?shape : int seq, [<Optional>] ?dtype : FloatDType) =
        RandomPoisson(?lam = lam, ?shape = shape, ?dtype = dtype)

    /// <summary>Draw random samples from a negative binomial distribution.
    /// 
    /// Samples are distributed according to a negative binomial distribution parametrized by
    /// *k* (limit of unsuccessful experiments) and *p* (failure probability in each experiment).
    /// Samples will always be returned as a floating point data type.
    /// 
    /// Example::
    /// 
    ///    negative_binomial(k=3, p=0.4, shape=(2,2)) = [[ 4.,  7.],
    ///                                                  [ 2.,  5.]]
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\random\sample_op.cc:L164</summary>
    /// <param name="ctx">Context of output, in format [cpu|gpu|cpu_pinned](n). Only used for imperative calls.</param>
    /// <param name="k">Limit of unsuccessful experiments.</param>
    /// <param name="p">Failure probability in each experiment.</param>
    /// <param name="shape">Shape of the output.</param>
    /// <param name="dtype">DType of the output in case this can&#39;t be inferred. Defaults to float32 if not defined (dtype=None).</param>
    static member RandomNegativeBinomialNDArray(ctx : Context, 
                                                [<Optional; DefaultParameterValue(1)>] k : int, 
                                                [<Optional; DefaultParameterValue(1.0)>] p : float, 
                                                [<Optional>] shape : int seq, 
                                                [<Optional>] dtype : FloatDType) =
        let creator = AtomicSymbolCreator.FromName "_random_negative_binomial"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 Array.empty
                                                 [|"ctx"; "k"; "p"; "shape"; "dtype"|]
                                                 [|string ctx; string k; string p; (if isNull (shape :> obj) then null else (shape |> Seq.map string |> String.concat ", " |> sprintf "[%s]")); (if isNull (dtype :> obj) then "None" else string dtype)|]
        (new NDArray(outputs.[0]))
    /// <summary>Draw random samples from a negative binomial distribution.
    /// 
    /// Samples are distributed according to a negative binomial distribution parametrized by
    /// *k* (limit of unsuccessful experiments) and *p* (failure probability in each experiment).
    /// Samples will always be returned as a floating point data type.
    /// 
    /// Example::
    /// 
    ///    negative_binomial(k=3, p=0.4, shape=(2,2)) = [[ 4.,  7.],
    ///                                                  [ 2.,  5.]]
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\random\sample_op.cc:L164</summary>
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="ctx">Context of output, in format [cpu|gpu|cpu_pinned](n). Only used for imperative calls.</param>
    /// <param name="k">Limit of unsuccessful experiments.</param>
    /// <param name="p">Failure probability in each experiment.</param>
    /// <param name="shape">Shape of the output.</param>
    /// <param name="dtype">DType of the output in case this can&#39;t be inferred. Defaults to float32 if not defined (dtype=None).</param>
    static member RandomNegativeBinomial(outputArray : NDArray seq, 
                                         ctx : Context, 
                                         [<Optional; DefaultParameterValue(1)>] k : int, 
                                         [<Optional; DefaultParameterValue(1.0)>] p : float, 
                                         [<Optional>] shape : int seq, 
                                         [<Optional>] dtype : FloatDType) =
        let creator = AtomicSymbolCreator.FromName "_random_negative_binomial"
        let names = [|"ctx"; "k"; "p"; "shape"; "dtype"|]
        let vals = [|string ctx; string k; string p; (if isNull (shape :> obj) then null else (shape |> Seq.map string |> String.concat ", " |> sprintf "[%s]")); (if isNull (dtype :> obj) then "None" else string dtype)|]
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     Array.empty
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <summary>Draw random samples from a negative binomial distribution.
    /// 
    /// Samples are distributed according to a negative binomial distribution parametrized by
    /// *k* (limit of unsuccessful experiments) and *p* (failure probability in each experiment).
    /// Samples will always be returned as a floating point data type.
    /// 
    /// Example::
    /// 
    ///    negative_binomial(k=3, p=0.4, shape=(2,2)) = [[ 4.,  7.],
    ///                                                  [ 2.,  5.]]
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\random\sample_op.cc:L164</summary>
    /// <param name="k">Limit of unsuccessful experiments.</param>
    /// <param name="p">Failure probability in each experiment.</param>
    /// <param name="shape">Shape of the output.</param>
    /// <param name="dtype">DType of the output in case this can&#39;t be inferred. Defaults to float32 if not defined (dtype=None).</param>
    static member RandomNegativeBinomial([<Optional>] ?k : int, [<Optional>] ?p : float, [<Optional>] ?shape : int seq, [<Optional>] ?dtype : FloatDType) =
        RandomNegativeBinomial(?k = k, ?p = p, ?shape = shape, ?dtype = dtype)

    /// <summary>Draw random samples from a generalized negative binomial distribution.
    /// 
    /// Samples are distributed according to a generalized negative binomial distribution parametrized by
    /// *mu* (mean) and *alpha* (dispersion). *alpha* is defined as *1/k* where *k* is the failure limit of the
    /// number of unsuccessful experiments (generalized to real numbers).
    /// Samples will always be returned as a floating point data type.
    /// 
    /// Example::
    /// 
    ///    generalized_negative_binomial(mu=2.0, alpha=0.3, shape=(2,2)) = [[ 2.,  1.],
    ///                                                                     [ 6.,  4.]]
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\random\sample_op.cc:L179</summary>
    /// <param name="ctx">Context of output, in format [cpu|gpu|cpu_pinned](n). Only used for imperative calls.</param>
    /// <param name="mu">Mean of the negative binomial distribution.</param>
    /// <param name="alpha">Alpha (dispersion) parameter of the negative binomial distribution.</param>
    /// <param name="shape">Shape of the output.</param>
    /// <param name="dtype">DType of the output in case this can&#39;t be inferred. Defaults to float32 if not defined (dtype=None).</param>
    static member RandomGeneralizedNegativeBinomialNDArray(ctx : Context, 
                                                           [<Optional; DefaultParameterValue(1.0)>] mu : float, 
                                                           [<Optional; DefaultParameterValue(1.0)>] alpha : float, 
                                                           [<Optional>] shape : int seq, 
                                                           [<Optional>] dtype : FloatDType) =
        let creator = AtomicSymbolCreator.FromName "_random_generalized_negative_binomial"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 Array.empty
                                                 [|"ctx"; "mu"; "alpha"; "shape"; "dtype"|]
                                                 [|string ctx; string mu; string alpha; (if isNull (shape :> obj) then null else (shape |> Seq.map string |> String.concat ", " |> sprintf "[%s]")); (if isNull (dtype :> obj) then "None" else string dtype)|]
        (new NDArray(outputs.[0]))
    /// <summary>Draw random samples from a generalized negative binomial distribution.
    /// 
    /// Samples are distributed according to a generalized negative binomial distribution parametrized by
    /// *mu* (mean) and *alpha* (dispersion). *alpha* is defined as *1/k* where *k* is the failure limit of the
    /// number of unsuccessful experiments (generalized to real numbers).
    /// Samples will always be returned as a floating point data type.
    /// 
    /// Example::
    /// 
    ///    generalized_negative_binomial(mu=2.0, alpha=0.3, shape=(2,2)) = [[ 2.,  1.],
    ///                                                                     [ 6.,  4.]]
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\random\sample_op.cc:L179</summary>
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="ctx">Context of output, in format [cpu|gpu|cpu_pinned](n). Only used for imperative calls.</param>
    /// <param name="mu">Mean of the negative binomial distribution.</param>
    /// <param name="alpha">Alpha (dispersion) parameter of the negative binomial distribution.</param>
    /// <param name="shape">Shape of the output.</param>
    /// <param name="dtype">DType of the output in case this can&#39;t be inferred. Defaults to float32 if not defined (dtype=None).</param>
    static member RandomGeneralizedNegativeBinomial(outputArray : NDArray seq, 
                                                    ctx : Context, 
                                                    [<Optional; DefaultParameterValue(1.0)>] mu : float, 
                                                    [<Optional; DefaultParameterValue(1.0)>] alpha : float, 
                                                    [<Optional>] shape : int seq, 
                                                    [<Optional>] dtype : FloatDType) =
        let creator = AtomicSymbolCreator.FromName "_random_generalized_negative_binomial"
        let names = [|"ctx"; "mu"; "alpha"; "shape"; "dtype"|]
        let vals = [|string ctx; string mu; string alpha; (if isNull (shape :> obj) then null else (shape |> Seq.map string |> String.concat ", " |> sprintf "[%s]")); (if isNull (dtype :> obj) then "None" else string dtype)|]
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     Array.empty
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <summary>Draw random samples from a generalized negative binomial distribution.
    /// 
    /// Samples are distributed according to a generalized negative binomial distribution parametrized by
    /// *mu* (mean) and *alpha* (dispersion). *alpha* is defined as *1/k* where *k* is the failure limit of the
    /// number of unsuccessful experiments (generalized to real numbers).
    /// Samples will always be returned as a floating point data type.
    /// 
    /// Example::
    /// 
    ///    generalized_negative_binomial(mu=2.0, alpha=0.3, shape=(2,2)) = [[ 2.,  1.],
    ///                                                                     [ 6.,  4.]]
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\random\sample_op.cc:L179</summary>
    /// <param name="mu">Mean of the negative binomial distribution.</param>
    /// <param name="alpha">Alpha (dispersion) parameter of the negative binomial distribution.</param>
    /// <param name="shape">Shape of the output.</param>
    /// <param name="dtype">DType of the output in case this can&#39;t be inferred. Defaults to float32 if not defined (dtype=None).</param>
    static member RandomGeneralizedNegativeBinomial([<Optional>] ?mu : float, [<Optional>] ?alpha : float, [<Optional>] ?shape : int seq, [<Optional>] ?dtype : FloatDType) =
        RandomGeneralizedNegativeBinomial(?mu = mu, ?alpha = alpha, ?shape = shape, ?dtype = dtype)

    /// <summary>Draw random samples from a discrete uniform distribution.
    /// 
    /// Samples are uniformly distributed over the half-open interval *[low, high)*
    /// (includes *low*, but excludes *high*).
    /// 
    /// Example::
    /// 
    ///    randint(low=0, high=5, shape=(2,2)) = [[ 0,  2],
    ///                                           [ 3,  1]]
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\random\sample_op.cc:L194</summary>
    /// <param name="low">Lower bound of the distribution.</param>
    /// <param name="high">Upper bound of the distribution.</param>
    /// <param name="ctx">Context of output, in format [cpu|gpu|cpu_pinned](n). Only used for imperative calls.</param>
    /// <param name="shape">Shape of the output.</param>
    /// <param name="dtype">DType of the output in case this can&#39;t be inferred. Defaults to int32 if not defined (dtype=None).</param>
    static member RandomRandintNDArray(low : int64, 
                                       high : int64, 
                                       ctx : Context, 
                                       [<Optional>] shape : int seq, 
                                       [<Optional>] dtype : RandomRandintDtype) =
        let creator = AtomicSymbolCreator.FromName "_random_randint"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 Array.empty
                                                 [|"low"; "high"; "ctx"; "shape"; "dtype"|]
                                                 [|string low; string high; string ctx; (if isNull (shape :> obj) then null else (shape |> Seq.map string |> String.concat ", " |> sprintf "[%s]")); (if isNull (dtype :> obj) then "None" else string dtype)|]
        (new NDArray(outputs.[0]))
    /// <summary>Draw random samples from a discrete uniform distribution.
    /// 
    /// Samples are uniformly distributed over the half-open interval *[low, high)*
    /// (includes *low*, but excludes *high*).
    /// 
    /// Example::
    /// 
    ///    randint(low=0, high=5, shape=(2,2)) = [[ 0,  2],
    ///                                           [ 3,  1]]
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\random\sample_op.cc:L194</summary>
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="low">Lower bound of the distribution.</param>
    /// <param name="high">Upper bound of the distribution.</param>
    /// <param name="ctx">Context of output, in format [cpu|gpu|cpu_pinned](n). Only used for imperative calls.</param>
    /// <param name="shape">Shape of the output.</param>
    /// <param name="dtype">DType of the output in case this can&#39;t be inferred. Defaults to int32 if not defined (dtype=None).</param>
    static member RandomRandint(outputArray : NDArray seq, 
                                low : int64, 
                                high : int64, 
                                ctx : Context, 
                                [<Optional>] shape : int seq, 
                                [<Optional>] dtype : RandomRandintDtype) =
        let creator = AtomicSymbolCreator.FromName "_random_randint"
        let names = [|"low"; "high"; "ctx"; "shape"; "dtype"|]
        let vals = [|string low; string high; string ctx; (if isNull (shape :> obj) then null else (shape |> Seq.map string |> String.concat ", " |> sprintf "[%s]")); (if isNull (dtype :> obj) then "None" else string dtype)|]
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     Array.empty
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <summary>Draw random samples from a discrete uniform distribution.
    /// 
    /// Samples are uniformly distributed over the half-open interval *[low, high)*
    /// (includes *low*, but excludes *high*).
    /// 
    /// Example::
    /// 
    ///    randint(low=0, high=5, shape=(2,2)) = [[ 0,  2],
    ///                                           [ 3,  1]]
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\random\sample_op.cc:L194</summary>
    /// <param name="low">Lower bound of the distribution.</param>
    /// <param name="high">Upper bound of the distribution.</param>
    /// <param name="shape">Shape of the output.</param>
    /// <param name="dtype">DType of the output in case this can&#39;t be inferred. Defaults to int32 if not defined (dtype=None).</param>
    static member RandomRandint(low : int64, high : int64, [<Optional>] ?shape : int seq, [<Optional>] ?dtype : RandomRandintDtype) =
        RandomRandint(low, high, ?shape = shape, ?dtype = dtype)

    /// <summary>Draw random samples from a uniform distribution according to the input array shape.
    /// 
    /// Samples are uniformly distributed over the half-open interval *[low, high)*
    /// (includes *low*, but excludes *high*).
    /// 
    /// Example::
    /// 
    ///    uniform(low=0, high=1, data=ones(2,2)) = [[ 0.60276335,  0.85794562],
    ///                                              [ 0.54488319,  0.84725171]]
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\random\sample_op.cc:L209</summary>
    /// <param name="data">The input</param>
    /// <param name="low">Lower bound of the distribution.</param>
    /// <param name="high">Upper bound of the distribution.</param>
    static member RandomUniformLike(data : NDArray, [<Optional; DefaultParameterValue(0.0)>] low : float, [<Optional; DefaultParameterValue(1.0)>] high : float) =
        let creator = AtomicSymbolCreator.FromName "_random_uniform_like"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle|]
                                                 [|"low"; "high"|]
                                                 [|string low; string high|]
        (new NDArray(outputs.[0]))
    /// <summary>Draw random samples from a uniform distribution according to the input array shape.
    /// 
    /// Samples are uniformly distributed over the half-open interval *[low, high)*
    /// (includes *low*, but excludes *high*).
    /// 
    /// Example::
    /// 
    ///    uniform(low=0, high=1, data=ones(2,2)) = [[ 0.60276335,  0.85794562],
    ///                                              [ 0.54488319,  0.84725171]]
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\random\sample_op.cc:L209</summary>
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="data">The input</param>
    /// <param name="low">Lower bound of the distribution.</param>
    /// <param name="high">Upper bound of the distribution.</param>
    static member RandomUniformLike(outputArray : NDArray seq, data : NDArray, [<Optional; DefaultParameterValue(0.0)>] low : float, [<Optional; DefaultParameterValue(1.0)>] high : float) =
        let creator = AtomicSymbolCreator.FromName "_random_uniform_like"
        let names = [|"low"; "high"|]
        let vals = [|string low; string high|]
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <summary>Draw random samples from a uniform distribution according to the input array shape.
    /// 
    /// Samples are uniformly distributed over the half-open interval *[low, high)*
    /// (includes *low*, but excludes *high*).
    /// 
    /// Example::
    /// 
    ///    uniform(low=0, high=1, data=ones(2,2)) = [[ 0.60276335,  0.85794562],
    ///                                              [ 0.54488319,  0.84725171]]
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\random\sample_op.cc:L209</summary>
    /// <param name="data">The input</param>
    /// <param name="low">Lower bound of the distribution.</param>
    /// <param name="high">Upper bound of the distribution.</param>
    static member RandomUniformLike([<Optional>] ?data : Symbol, [<Optional>] ?low : float, [<Optional>] ?high : float) =
        RandomUniformLike(?data = data, ?low = low, ?high = high)

    /// <summary>Draw random samples from a normal (Gaussian) distribution according to the input array shape.
    /// 
    /// Samples are distributed according to a normal distribution parametrized by *loc* (mean) and *scale*
    /// (standard deviation).
    /// 
    /// Example::
    /// 
    ///    normal(loc=0, scale=1, data=ones(2,2)) = [[ 1.89171135, -1.16881478],
    ///                                              [-1.23474145,  1.55807114]]
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\random\sample_op.cc:L221</summary>
    /// <param name="data">The input</param>
    /// <param name="loc">Mean of the distribution.</param>
    /// <param name="scale">Standard deviation of the distribution.</param>
    static member RandomNormalLike(data : NDArray, [<Optional; DefaultParameterValue(0.0)>] loc : float, [<Optional; DefaultParameterValue(1.0)>] scale : float) =
        let creator = AtomicSymbolCreator.FromName "_random_normal_like"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle|]
                                                 [|"loc"; "scale"|]
                                                 [|string loc; string scale|]
        (new NDArray(outputs.[0]))
    /// <summary>Draw random samples from a normal (Gaussian) distribution according to the input array shape.
    /// 
    /// Samples are distributed according to a normal distribution parametrized by *loc* (mean) and *scale*
    /// (standard deviation).
    /// 
    /// Example::
    /// 
    ///    normal(loc=0, scale=1, data=ones(2,2)) = [[ 1.89171135, -1.16881478],
    ///                                              [-1.23474145,  1.55807114]]
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\random\sample_op.cc:L221</summary>
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="data">The input</param>
    /// <param name="loc">Mean of the distribution.</param>
    /// <param name="scale">Standard deviation of the distribution.</param>
    static member RandomNormalLike(outputArray : NDArray seq, data : NDArray, [<Optional; DefaultParameterValue(0.0)>] loc : float, [<Optional; DefaultParameterValue(1.0)>] scale : float) =
        let creator = AtomicSymbolCreator.FromName "_random_normal_like"
        let names = [|"loc"; "scale"|]
        let vals = [|string loc; string scale|]
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <summary>Draw random samples from a normal (Gaussian) distribution according to the input array shape.
    /// 
    /// Samples are distributed according to a normal distribution parametrized by *loc* (mean) and *scale*
    /// (standard deviation).
    /// 
    /// Example::
    /// 
    ///    normal(loc=0, scale=1, data=ones(2,2)) = [[ 1.89171135, -1.16881478],
    ///                                              [-1.23474145,  1.55807114]]
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\random\sample_op.cc:L221</summary>
    /// <param name="data">The input</param>
    /// <param name="loc">Mean of the distribution.</param>
    /// <param name="scale">Standard deviation of the distribution.</param>
    static member RandomNormalLike([<Optional>] ?data : Symbol, [<Optional>] ?loc : float, [<Optional>] ?scale : float) =
        RandomNormalLike(?data = data, ?loc = loc, ?scale = scale)

    /// <summary>Draw random samples from a gamma distribution according to the input array shape.
    /// 
    /// Samples are distributed according to a gamma distribution parametrized by *alpha* (shape) and *beta* (scale).
    /// 
    /// Example::
    /// 
    ///    gamma(alpha=9, beta=0.5, data=ones(2,2)) = [[ 7.10486984,  3.37695289],
    ///                                                [ 3.91697288,  3.65933681]]
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\random\sample_op.cc:L232</summary>
    /// <param name="data">The input</param>
    /// <param name="alpha">Alpha parameter (shape) of the gamma distribution.</param>
    /// <param name="beta">Beta parameter (scale) of the gamma distribution.</param>
    static member RandomGammaLike(data : NDArray, [<Optional; DefaultParameterValue(1.0)>] alpha : float, [<Optional; DefaultParameterValue(1.0)>] beta : float) =
        let creator = AtomicSymbolCreator.FromName "_random_gamma_like"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle|]
                                                 [|"alpha"; "beta"|]
                                                 [|string alpha; string beta|]
        (new NDArray(outputs.[0]))
    /// <summary>Draw random samples from a gamma distribution according to the input array shape.
    /// 
    /// Samples are distributed according to a gamma distribution parametrized by *alpha* (shape) and *beta* (scale).
    /// 
    /// Example::
    /// 
    ///    gamma(alpha=9, beta=0.5, data=ones(2,2)) = [[ 7.10486984,  3.37695289],
    ///                                                [ 3.91697288,  3.65933681]]
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\random\sample_op.cc:L232</summary>
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="data">The input</param>
    /// <param name="alpha">Alpha parameter (shape) of the gamma distribution.</param>
    /// <param name="beta">Beta parameter (scale) of the gamma distribution.</param>
    static member RandomGammaLike(outputArray : NDArray seq, data : NDArray, [<Optional; DefaultParameterValue(1.0)>] alpha : float, [<Optional; DefaultParameterValue(1.0)>] beta : float) =
        let creator = AtomicSymbolCreator.FromName "_random_gamma_like"
        let names = [|"alpha"; "beta"|]
        let vals = [|string alpha; string beta|]
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <summary>Draw random samples from a gamma distribution according to the input array shape.
    /// 
    /// Samples are distributed according to a gamma distribution parametrized by *alpha* (shape) and *beta* (scale).
    /// 
    /// Example::
    /// 
    ///    gamma(alpha=9, beta=0.5, data=ones(2,2)) = [[ 7.10486984,  3.37695289],
    ///                                                [ 3.91697288,  3.65933681]]
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\random\sample_op.cc:L232</summary>
    /// <param name="data">The input</param>
    /// <param name="alpha">Alpha parameter (shape) of the gamma distribution.</param>
    /// <param name="beta">Beta parameter (scale) of the gamma distribution.</param>
    static member RandomGammaLike([<Optional>] ?data : Symbol, [<Optional>] ?alpha : float, [<Optional>] ?beta : float) =
        RandomGammaLike(?data = data, ?alpha = alpha, ?beta = beta)

    /// <summary>Draw random samples from an exponential distribution according to the input array shape.
    /// 
    /// Samples are distributed according to an exponential distribution parametrized by *lambda* (rate).
    /// 
    /// Example::
    /// 
    ///    exponential(lam=4, data=ones(2,2)) = [[ 0.0097189 ,  0.08999364],
    ///                                          [ 0.04146638,  0.31715935]]
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\random\sample_op.cc:L243</summary>
    /// <param name="data">The input</param>
    /// <param name="lam">Lambda parameter (rate) of the exponential distribution.</param>
    static member RandomExponentialLike(data : NDArray, [<Optional; DefaultParameterValue(1.0)>] lam : float) =
        let creator = AtomicSymbolCreator.FromName "_random_exponential_like"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle|]
                                                 [|"lam"|]
                                                 [|string lam|]
        (new NDArray(outputs.[0]))
    /// <summary>Draw random samples from an exponential distribution according to the input array shape.
    /// 
    /// Samples are distributed according to an exponential distribution parametrized by *lambda* (rate).
    /// 
    /// Example::
    /// 
    ///    exponential(lam=4, data=ones(2,2)) = [[ 0.0097189 ,  0.08999364],
    ///                                          [ 0.04146638,  0.31715935]]
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\random\sample_op.cc:L243</summary>
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="data">The input</param>
    /// <param name="lam">Lambda parameter (rate) of the exponential distribution.</param>
    static member RandomExponentialLike(outputArray : NDArray seq, data : NDArray, [<Optional; DefaultParameterValue(1.0)>] lam : float) =
        let creator = AtomicSymbolCreator.FromName "_random_exponential_like"
        let names = [|"lam"|]
        let vals = [|string lam|]
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <summary>Draw random samples from an exponential distribution according to the input array shape.
    /// 
    /// Samples are distributed according to an exponential distribution parametrized by *lambda* (rate).
    /// 
    /// Example::
    /// 
    ///    exponential(lam=4, data=ones(2,2)) = [[ 0.0097189 ,  0.08999364],
    ///                                          [ 0.04146638,  0.31715935]]
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\random\sample_op.cc:L243</summary>
    /// <param name="data">The input</param>
    /// <param name="lam">Lambda parameter (rate) of the exponential distribution.</param>
    static member RandomExponentialLike([<Optional>] ?data : Symbol, [<Optional>] ?lam : float) =
        RandomExponentialLike(?data = data, ?lam = lam)

    /// <summary>Draw random samples from a Poisson distribution according to the input array shape.
    /// 
    /// Samples are distributed according to a Poisson distribution parametrized by *lambda* (rate).
    /// Samples will always be returned as a floating point data type.
    /// 
    /// Example::
    /// 
    ///    poisson(lam=4, data=ones(2,2)) = [[ 5.,  2.],
    ///                                      [ 4.,  6.]]
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\random\sample_op.cc:L255</summary>
    /// <param name="data">The input</param>
    /// <param name="lam">Lambda parameter (rate) of the Poisson distribution.</param>
    static member RandomPoissonLike(data : NDArray, [<Optional; DefaultParameterValue(1.0)>] lam : float) =
        let creator = AtomicSymbolCreator.FromName "_random_poisson_like"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle|]
                                                 [|"lam"|]
                                                 [|string lam|]
        (new NDArray(outputs.[0]))
    /// <summary>Draw random samples from a Poisson distribution according to the input array shape.
    /// 
    /// Samples are distributed according to a Poisson distribution parametrized by *lambda* (rate).
    /// Samples will always be returned as a floating point data type.
    /// 
    /// Example::
    /// 
    ///    poisson(lam=4, data=ones(2,2)) = [[ 5.,  2.],
    ///                                      [ 4.,  6.]]
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\random\sample_op.cc:L255</summary>
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="data">The input</param>
    /// <param name="lam">Lambda parameter (rate) of the Poisson distribution.</param>
    static member RandomPoissonLike(outputArray : NDArray seq, data : NDArray, [<Optional; DefaultParameterValue(1.0)>] lam : float) =
        let creator = AtomicSymbolCreator.FromName "_random_poisson_like"
        let names = [|"lam"|]
        let vals = [|string lam|]
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <summary>Draw random samples from a Poisson distribution according to the input array shape.
    /// 
    /// Samples are distributed according to a Poisson distribution parametrized by *lambda* (rate).
    /// Samples will always be returned as a floating point data type.
    /// 
    /// Example::
    /// 
    ///    poisson(lam=4, data=ones(2,2)) = [[ 5.,  2.],
    ///                                      [ 4.,  6.]]
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\random\sample_op.cc:L255</summary>
    /// <param name="data">The input</param>
    /// <param name="lam">Lambda parameter (rate) of the Poisson distribution.</param>
    static member RandomPoissonLike([<Optional>] ?data : Symbol, [<Optional>] ?lam : float) =
        RandomPoissonLike(?data = data, ?lam = lam)

    /// <summary>Draw random samples from a negative binomial distribution according to the input array shape.
    /// 
    /// Samples are distributed according to a negative binomial distribution parametrized by
    /// *k* (limit of unsuccessful experiments) and *p* (failure probability in each experiment).
    /// Samples will always be returned as a floating point data type.
    /// 
    /// Example::
    /// 
    ///    negative_binomial(k=3, p=0.4, data=ones(2,2)) = [[ 4.,  7.],
    ///                                                     [ 2.,  5.]]
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\random\sample_op.cc:L268</summary>
    /// <param name="data">The input</param>
    /// <param name="k">Limit of unsuccessful experiments.</param>
    /// <param name="p">Failure probability in each experiment.</param>
    static member RandomNegativeBinomialLike(data : NDArray, [<Optional; DefaultParameterValue(1)>] k : int, [<Optional; DefaultParameterValue(1.0)>] p : float) =
        let creator = AtomicSymbolCreator.FromName "_random_negative_binomial_like"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle|]
                                                 [|"k"; "p"|]
                                                 [|string k; string p|]
        (new NDArray(outputs.[0]))
    /// <summary>Draw random samples from a negative binomial distribution according to the input array shape.
    /// 
    /// Samples are distributed according to a negative binomial distribution parametrized by
    /// *k* (limit of unsuccessful experiments) and *p* (failure probability in each experiment).
    /// Samples will always be returned as a floating point data type.
    /// 
    /// Example::
    /// 
    ///    negative_binomial(k=3, p=0.4, data=ones(2,2)) = [[ 4.,  7.],
    ///                                                     [ 2.,  5.]]
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\random\sample_op.cc:L268</summary>
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="data">The input</param>
    /// <param name="k">Limit of unsuccessful experiments.</param>
    /// <param name="p">Failure probability in each experiment.</param>
    static member RandomNegativeBinomialLike(outputArray : NDArray seq, data : NDArray, [<Optional; DefaultParameterValue(1)>] k : int, [<Optional; DefaultParameterValue(1.0)>] p : float) =
        let creator = AtomicSymbolCreator.FromName "_random_negative_binomial_like"
        let names = [|"k"; "p"|]
        let vals = [|string k; string p|]
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <summary>Draw random samples from a negative binomial distribution according to the input array shape.
    /// 
    /// Samples are distributed according to a negative binomial distribution parametrized by
    /// *k* (limit of unsuccessful experiments) and *p* (failure probability in each experiment).
    /// Samples will always be returned as a floating point data type.
    /// 
    /// Example::
    /// 
    ///    negative_binomial(k=3, p=0.4, data=ones(2,2)) = [[ 4.,  7.],
    ///                                                     [ 2.,  5.]]
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\random\sample_op.cc:L268</summary>
    /// <param name="data">The input</param>
    /// <param name="k">Limit of unsuccessful experiments.</param>
    /// <param name="p">Failure probability in each experiment.</param>
    static member RandomNegativeBinomialLike([<Optional>] ?data : Symbol, [<Optional>] ?k : int, [<Optional>] ?p : float) =
        RandomNegativeBinomialLike(?data = data, ?k = k, ?p = p)

    /// <summary>Draw random samples from a generalized negative binomial distribution according to the
    /// input array shape.
    /// 
    /// Samples are distributed according to a generalized negative binomial distribution parametrized by
    /// *mu* (mean) and *alpha* (dispersion). *alpha* is defined as *1/k* where *k* is the failure limit of the
    /// number of unsuccessful experiments (generalized to real numbers).
    /// Samples will always be returned as a floating point data type.
    /// 
    /// Example::
    /// 
    ///    generalized_negative_binomial(mu=2.0, alpha=0.3, data=ones(2,2)) = [[ 2.,  1.],
    ///                                                                        [ 6.,  4.]]
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\random\sample_op.cc:L284</summary>
    /// <param name="data">The input</param>
    /// <param name="mu">Mean of the negative binomial distribution.</param>
    /// <param name="alpha">Alpha (dispersion) parameter of the negative binomial distribution.</param>
    static member RandomGeneralizedNegativeBinomialLike(data : NDArray, [<Optional; DefaultParameterValue(1.0)>] mu : float, [<Optional; DefaultParameterValue(1.0)>] alpha : float) =
        let creator = AtomicSymbolCreator.FromName "_random_generalized_negative_binomial_like"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle|]
                                                 [|"mu"; "alpha"|]
                                                 [|string mu; string alpha|]
        (new NDArray(outputs.[0]))
    /// <summary>Draw random samples from a generalized negative binomial distribution according to the
    /// input array shape.
    /// 
    /// Samples are distributed according to a generalized negative binomial distribution parametrized by
    /// *mu* (mean) and *alpha* (dispersion). *alpha* is defined as *1/k* where *k* is the failure limit of the
    /// number of unsuccessful experiments (generalized to real numbers).
    /// Samples will always be returned as a floating point data type.
    /// 
    /// Example::
    /// 
    ///    generalized_negative_binomial(mu=2.0, alpha=0.3, data=ones(2,2)) = [[ 2.,  1.],
    ///                                                                        [ 6.,  4.]]
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\random\sample_op.cc:L284</summary>
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="data">The input</param>
    /// <param name="mu">Mean of the negative binomial distribution.</param>
    /// <param name="alpha">Alpha (dispersion) parameter of the negative binomial distribution.</param>
    static member RandomGeneralizedNegativeBinomialLike(outputArray : NDArray seq, data : NDArray, [<Optional; DefaultParameterValue(1.0)>] mu : float, [<Optional; DefaultParameterValue(1.0)>] alpha : float) =
        let creator = AtomicSymbolCreator.FromName "_random_generalized_negative_binomial_like"
        let names = [|"mu"; "alpha"|]
        let vals = [|string mu; string alpha|]
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <summary>Draw random samples from a generalized negative binomial distribution according to the
    /// input array shape.
    /// 
    /// Samples are distributed according to a generalized negative binomial distribution parametrized by
    /// *mu* (mean) and *alpha* (dispersion). *alpha* is defined as *1/k* where *k* is the failure limit of the
    /// number of unsuccessful experiments (generalized to real numbers).
    /// Samples will always be returned as a floating point data type.
    /// 
    /// Example::
    /// 
    ///    generalized_negative_binomial(mu=2.0, alpha=0.3, data=ones(2,2)) = [[ 2.,  1.],
    ///                                                                        [ 6.,  4.]]
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\random\sample_op.cc:L284</summary>
    /// <param name="data">The input</param>
    /// <param name="mu">Mean of the negative binomial distribution.</param>
    /// <param name="alpha">Alpha (dispersion) parameter of the negative binomial distribution.</param>
    static member RandomGeneralizedNegativeBinomialLike([<Optional>] ?data : Symbol, [<Optional>] ?mu : float, [<Optional>] ?alpha : float) =
        RandomGeneralizedNegativeBinomialLike(?data = data, ?mu = mu, ?alpha = alpha)

    /// <summary>Randomly shuffle the elements.
    /// 
    /// This shuffles the array along the first axis.
    /// The order of the elements in each subarray does not change.
    /// For example, if a 2D array is given, the order of the rows randomly changes,
    /// but the order of the elements in each row does not change.
    /// </summary>
    /// <param name="data">Data to be shuffled.</param>
    static member Shuffle(data : NDArray) =
        let creator = AtomicSymbolCreator.FromName "_shuffle"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle|]
                                                 Array.empty
                                                 Array.empty
        (new NDArray(outputs.[0]))
    /// <summary>Randomly shuffle the elements.
    /// 
    /// This shuffles the array along the first axis.
    /// The order of the elements in each subarray does not change.
    /// For example, if a 2D array is given, the order of the rows randomly changes,
    /// but the order of the elements in each row does not change.
    /// </summary>
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="data">Data to be shuffled.</param>
    static member Shuffle(outputArray : NDArray seq, data : NDArray) =
        let creator = AtomicSymbolCreator.FromName "_shuffle"
        let names = Array.empty
        let vals = Array.empty
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <summary>Randomly shuffle the elements.
    /// 
    /// This shuffles the array along the first axis.
    /// The order of the elements in each subarray does not change.
    /// For example, if a 2D array is given, the order of the rows randomly changes,
    /// but the order of the elements in each row does not change.
    /// </summary>
    /// <param name="data">Data to be shuffled.</param>
    static member Shuffle([<Optional>] ?data : Symbol) =
        Shuffle(?data = data)

    /// <summary>Draw random samples from an an approximately log-uniform
    /// or Zipfian distribution without replacement.
    /// 
    /// This operation takes a 2-D shape `(batch_size, num_sampled)`,
    /// and randomly generates *num_sampled* samples from the range of integers [0, range_max)
    /// for each instance in the batch.
    /// 
    /// The elements in each instance are drawn without replacement from the base distribution.
    /// The base distribution for this operator is an approximately log-uniform or Zipfian distribution:
    /// 
    ///   P(class) = (log(class + 2) - log(class + 1)) / log(range_max + 1)
    /// 
    /// Additionaly, it also returns the number of trials used to obtain `num_sampled` samples for
    /// each instance in the batch.
    /// 
    /// Example::
    /// 
    ///    samples, trials = _sample_unique_zipfian(750000, shape=(4, 8192))
    ///    unique(samples[0]) = 8192
    ///    unique(samples[3]) = 8192
    ///    trials[0] = 16435
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\random\unique_sample_op.cc:L66</summary>
    /// <param name="rangeMax">The number of possible classes.</param>
    /// <param name="shape">2-D shape of the output, where shape[0] is the batch size, and shape[1] is the number of candidates to sample for each batch.</param>
    static member SampleUniqueZipfianNDArray(rangeMax : int, [<Optional>] shape : int seq) =
        let creator = AtomicSymbolCreator.FromName "_sample_unique_zipfian"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 Array.empty
                                                 [|"range_max"; "shape"|]
                                                 [|string rangeMax; (if isNull (shape :> obj) then null else (shape |> Seq.map string |> String.concat ", " |> sprintf "[%s]"))|]
        (new NDArray(outputs.[0]))
    /// <summary>Draw random samples from an an approximately log-uniform
    /// or Zipfian distribution without replacement.
    /// 
    /// This operation takes a 2-D shape `(batch_size, num_sampled)`,
    /// and randomly generates *num_sampled* samples from the range of integers [0, range_max)
    /// for each instance in the batch.
    /// 
    /// The elements in each instance are drawn without replacement from the base distribution.
    /// The base distribution for this operator is an approximately log-uniform or Zipfian distribution:
    /// 
    ///   P(class) = (log(class + 2) - log(class + 1)) / log(range_max + 1)
    /// 
    /// Additionaly, it also returns the number of trials used to obtain `num_sampled` samples for
    /// each instance in the batch.
    /// 
    /// Example::
    /// 
    ///    samples, trials = _sample_unique_zipfian(750000, shape=(4, 8192))
    ///    unique(samples[0]) = 8192
    ///    unique(samples[3]) = 8192
    ///    trials[0] = 16435
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\random\unique_sample_op.cc:L66</summary>
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="rangeMax">The number of possible classes.</param>
    /// <param name="shape">2-D shape of the output, where shape[0] is the batch size, and shape[1] is the number of candidates to sample for each batch.</param>
    static member SampleUniqueZipfian(outputArray : NDArray seq, rangeMax : int, [<Optional>] shape : int seq) =
        let creator = AtomicSymbolCreator.FromName "_sample_unique_zipfian"
        let names = [|"range_max"; "shape"|]
        let vals = [|string rangeMax; (if isNull (shape :> obj) then null else (shape |> Seq.map string |> String.concat ", " |> sprintf "[%s]"))|]
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     Array.empty
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <summary>Draw random samples from an an approximately log-uniform
    /// or Zipfian distribution without replacement.
    /// 
    /// This operation takes a 2-D shape `(batch_size, num_sampled)`,
    /// and randomly generates *num_sampled* samples from the range of integers [0, range_max)
    /// for each instance in the batch.
    /// 
    /// The elements in each instance are drawn without replacement from the base distribution.
    /// The base distribution for this operator is an approximately log-uniform or Zipfian distribution:
    /// 
    ///   P(class) = (log(class + 2) - log(class + 1)) / log(range_max + 1)
    /// 
    /// Additionaly, it also returns the number of trials used to obtain `num_sampled` samples for
    /// each instance in the batch.
    /// 
    /// Example::
    /// 
    ///    samples, trials = _sample_unique_zipfian(750000, shape=(4, 8192))
    ///    unique(samples[0]) = 8192
    ///    unique(samples[3]) = 8192
    ///    trials[0] = 16435
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\random\unique_sample_op.cc:L66</summary>
    /// <param name="rangeMax">The number of possible classes.</param>
    /// <param name="shape">2-D shape of the output, where shape[0] is the batch size, and shape[1] is the number of candidates to sample for each batch.</param>
    static member SampleUniqueZipfian(rangeMax : int, [<Optional>] ?shape : int seq) =
        SampleUniqueZipfian(rangeMax, ?shape = shape)

    /// <summary>Computes and optimizes for squared loss during backward propagation.
    /// Just outputs ``data`` during forward propagation.
    /// 
    /// If :math:`\hat{y}_i` is the predicted value of the i-th sample, and :math:`y_i` is the corresponding target value,
    /// then the squared loss estimated over :math:`n` samples is defined as
    /// 
    /// :math:`\text{SquaredLoss}(\textbf{Y}, \hat{\textbf{Y}} ) = \frac{1}{n} \sum_{i=0}^{n-1} \lVert  \textbf{y}_i - \hat{\textbf{y}}_i  \rVert_2`
    /// 
    /// .. note::
    ///    Use the LinearRegressionOutput as the final output layer of a net.
    /// 
    /// The storage type of ``label`` can be ``default`` or ``csr``
    /// 
    /// - LinearRegressionOutput(default, default) = default
    /// - LinearRegressionOutput(default, csr) = default
    /// 
    /// By default, gradients of this loss function are scaled by factor `1/m`, where m is the number of regression outputs of a training example.
    /// The parameter `grad_scale` can be used to change this scale to `grad_scale/m`.
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\regression_output.cc:L92</summary>
    /// <param name="data">Input data to the function.</param>
    /// <param name="label">Input label to the function.</param>
    /// <param name="gradScale">Scale the gradient by a float factor</param>
    static member LinearRegressionOutput(data : NDArray, label : NDArray, [<Optional; DefaultParameterValue(1.0)>] gradScale : float) =
        let creator = AtomicSymbolCreator.FromName "LinearRegressionOutput"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg label)) then label.UnsafeHandle|]
                                                 [|"grad_scale"|]
                                                 [|string gradScale|]
        (new NDArray(outputs.[0]))
    /// <summary>Computes and optimizes for squared loss during backward propagation.
    /// Just outputs ``data`` during forward propagation.
    /// 
    /// If :math:`\hat{y}_i` is the predicted value of the i-th sample, and :math:`y_i` is the corresponding target value,
    /// then the squared loss estimated over :math:`n` samples is defined as
    /// 
    /// :math:`\text{SquaredLoss}(\textbf{Y}, \hat{\textbf{Y}} ) = \frac{1}{n} \sum_{i=0}^{n-1} \lVert  \textbf{y}_i - \hat{\textbf{y}}_i  \rVert_2`
    /// 
    /// .. note::
    ///    Use the LinearRegressionOutput as the final output layer of a net.
    /// 
    /// The storage type of ``label`` can be ``default`` or ``csr``
    /// 
    /// - LinearRegressionOutput(default, default) = default
    /// - LinearRegressionOutput(default, csr) = default
    /// 
    /// By default, gradients of this loss function are scaled by factor `1/m`, where m is the number of regression outputs of a training example.
    /// The parameter `grad_scale` can be used to change this scale to `grad_scale/m`.
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\regression_output.cc:L92</summary>
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="data">Input data to the function.</param>
    /// <param name="label">Input label to the function.</param>
    /// <param name="gradScale">Scale the gradient by a float factor</param>
    static member LinearRegressionOutput(outputArray : NDArray seq, data : NDArray, label : NDArray, [<Optional; DefaultParameterValue(1.0)>] gradScale : float) =
        let creator = AtomicSymbolCreator.FromName "LinearRegressionOutput"
        let names = [|"grad_scale"|]
        let vals = [|string gradScale|]
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg label)) then label.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <summary>Computes and optimizes for squared loss during backward propagation.
    /// Just outputs ``data`` during forward propagation.
    /// 
    /// If :math:`\hat{y}_i` is the predicted value of the i-th sample, and :math:`y_i` is the corresponding target value,
    /// then the squared loss estimated over :math:`n` samples is defined as
    /// 
    /// :math:`\text{SquaredLoss}(\textbf{Y}, \hat{\textbf{Y}} ) = \frac{1}{n} \sum_{i=0}^{n-1} \lVert  \textbf{y}_i - \hat{\textbf{y}}_i  \rVert_2`
    /// 
    /// .. note::
    ///    Use the LinearRegressionOutput as the final output layer of a net.
    /// 
    /// The storage type of ``label`` can be ``default`` or ``csr``
    /// 
    /// - LinearRegressionOutput(default, default) = default
    /// - LinearRegressionOutput(default, csr) = default
    /// 
    /// By default, gradients of this loss function are scaled by factor `1/m`, where m is the number of regression outputs of a training example.
    /// The parameter `grad_scale` can be used to change this scale to `grad_scale/m`.
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\regression_output.cc:L92</summary>
    /// <param name="data">Input data to the function.</param>
    /// <param name="label">Input label to the function.</param>
    /// <param name="gradScale">Scale the gradient by a float factor</param>
    static member LinearRegressionOutput([<Optional>] ?data : Symbol, [<Optional>] ?label : Symbol, [<Optional>] ?gradScale : float) =
        LinearRegressionOutput(?data = data, ?label = label, ?gradScale = gradScale)


    /// <summary>Computes mean absolute error of the input.
    /// 
    /// MAE is a risk metric corresponding to the expected value of the absolute error.
    /// 
    /// If :math:`\hat{y}_i` is the predicted value of the i-th sample, and :math:`y_i` is the corresponding target value,
    /// then the mean absolute error (MAE) estimated over :math:`n` samples is defined as
    /// 
    /// :math:`\text{MAE}(\textbf{Y}, \hat{\textbf{Y}} ) = \frac{1}{n} \sum_{i=0}^{n-1} \lVert \textbf{y}_i - \hat{\textbf{y}}_i \rVert_1`
    /// 
    /// .. note::
    ///    Use the MAERegressionOutput as the final output layer of a net.
    /// 
    /// The storage type of ``label`` can be ``default`` or ``csr``
    /// 
    /// - MAERegressionOutput(default, default) = default
    /// - MAERegressionOutput(default, csr) = default
    /// 
    /// By default, gradients of this loss function are scaled by factor `1/m`, where m is the number of regression outputs of a training example.
    /// The parameter `grad_scale` can be used to change this scale to `grad_scale/m`.
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\regression_output.cc:L120</summary>
    /// <param name="data">Input data to the function.</param>
    /// <param name="label">Input label to the function.</param>
    /// <param name="gradScale">Scale the gradient by a float factor</param>
    static member MAERegressionOutput(data : NDArray, label : NDArray, [<Optional; DefaultParameterValue(1.0)>] gradScale : float) =
        let creator = AtomicSymbolCreator.FromName "MAERegressionOutput"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg label)) then label.UnsafeHandle|]
                                                 [|"grad_scale"|]
                                                 [|string gradScale|]
        (new NDArray(outputs.[0]))
    /// <summary>Computes mean absolute error of the input.
    /// 
    /// MAE is a risk metric corresponding to the expected value of the absolute error.
    /// 
    /// If :math:`\hat{y}_i` is the predicted value of the i-th sample, and :math:`y_i` is the corresponding target value,
    /// then the mean absolute error (MAE) estimated over :math:`n` samples is defined as
    /// 
    /// :math:`\text{MAE}(\textbf{Y}, \hat{\textbf{Y}} ) = \frac{1}{n} \sum_{i=0}^{n-1} \lVert \textbf{y}_i - \hat{\textbf{y}}_i \rVert_1`
    /// 
    /// .. note::
    ///    Use the MAERegressionOutput as the final output layer of a net.
    /// 
    /// The storage type of ``label`` can be ``default`` or ``csr``
    /// 
    /// - MAERegressionOutput(default, default) = default
    /// - MAERegressionOutput(default, csr) = default
    /// 
    /// By default, gradients of this loss function are scaled by factor `1/m`, where m is the number of regression outputs of a training example.
    /// The parameter `grad_scale` can be used to change this scale to `grad_scale/m`.
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\regression_output.cc:L120</summary>
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="data">Input data to the function.</param>
    /// <param name="label">Input label to the function.</param>
    /// <param name="gradScale">Scale the gradient by a float factor</param>
    static member MAERegressionOutput(outputArray : NDArray seq, data : NDArray, label : NDArray, [<Optional; DefaultParameterValue(1.0)>] gradScale : float) =
        let creator = AtomicSymbolCreator.FromName "MAERegressionOutput"
        let names = [|"grad_scale"|]
        let vals = [|string gradScale|]
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg label)) then label.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <summary>Computes mean absolute error of the input.
    /// 
    /// MAE is a risk metric corresponding to the expected value of the absolute error.
    /// 
    /// If :math:`\hat{y}_i` is the predicted value of the i-th sample, and :math:`y_i` is the corresponding target value,
    /// then the mean absolute error (MAE) estimated over :math:`n` samples is defined as
    /// 
    /// :math:`\text{MAE}(\textbf{Y}, \hat{\textbf{Y}} ) = \frac{1}{n} \sum_{i=0}^{n-1} \lVert \textbf{y}_i - \hat{\textbf{y}}_i \rVert_1`
    /// 
    /// .. note::
    ///    Use the MAERegressionOutput as the final output layer of a net.
    /// 
    /// The storage type of ``label`` can be ``default`` or ``csr``
    /// 
    /// - MAERegressionOutput(default, default) = default
    /// - MAERegressionOutput(default, csr) = default
    /// 
    /// By default, gradients of this loss function are scaled by factor `1/m`, where m is the number of regression outputs of a training example.
    /// The parameter `grad_scale` can be used to change this scale to `grad_scale/m`.
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\regression_output.cc:L120</summary>
    /// <param name="data">Input data to the function.</param>
    /// <param name="label">Input label to the function.</param>
    /// <param name="gradScale">Scale the gradient by a float factor</param>
    static member MAERegressionOutput([<Optional>] ?data : Symbol, [<Optional>] ?label : Symbol, [<Optional>] ?gradScale : float) =
        MAERegressionOutput(?data = data, ?label = label, ?gradScale = gradScale)


    /// <summary>Applies a logistic function to the input.
    /// 
    /// The logistic function, also known as the sigmoid function, is computed as
    /// :math:`\frac{1}{1+exp(-\textbf{x})}`.
    /// 
    /// Commonly, the sigmoid is used to squash the real-valued output of a linear model
    /// :math:`wTx+b` into the [0,1] range so that it can be interpreted as a probability.
    /// It is suitable for binary classification or probability prediction tasks.
    /// 
    /// .. note::
    ///    Use the LogisticRegressionOutput as the final output layer of a net.
    /// 
    /// The storage type of ``label`` can be ``default`` or ``csr``
    /// 
    /// - LogisticRegressionOutput(default, default) = default
    /// - LogisticRegressionOutput(default, csr) = default
    /// 
    /// The loss function used is the Binary Cross Entropy Loss:
    /// 
    /// :math:`-{(y\log(p) + (1 - y)\log(1 - p))}`
    /// 
    /// Where `y` is the ground truth probability of positive outcome for a given example, and `p` the probability predicted by the model. By default, gradients of this loss function are scaled by factor `1/m`, where m is the number of regression outputs of a training example.
    /// The parameter `grad_scale` can be used to change this scale to `grad_scale/m`.
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\regression_output.cc:L152</summary>
    /// <param name="data">Input data to the function.</param>
    /// <param name="label">Input label to the function.</param>
    /// <param name="gradScale">Scale the gradient by a float factor</param>
    static member LogisticRegressionOutput(data : NDArray, label : NDArray, [<Optional; DefaultParameterValue(1.0)>] gradScale : float) =
        let creator = AtomicSymbolCreator.FromName "LogisticRegressionOutput"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg label)) then label.UnsafeHandle|]
                                                 [|"grad_scale"|]
                                                 [|string gradScale|]
        (new NDArray(outputs.[0]))
    /// <summary>Applies a logistic function to the input.
    /// 
    /// The logistic function, also known as the sigmoid function, is computed as
    /// :math:`\frac{1}{1+exp(-\textbf{x})}`.
    /// 
    /// Commonly, the sigmoid is used to squash the real-valued output of a linear model
    /// :math:`wTx+b` into the [0,1] range so that it can be interpreted as a probability.
    /// It is suitable for binary classification or probability prediction tasks.
    /// 
    /// .. note::
    ///    Use the LogisticRegressionOutput as the final output layer of a net.
    /// 
    /// The storage type of ``label`` can be ``default`` or ``csr``
    /// 
    /// - LogisticRegressionOutput(default, default) = default
    /// - LogisticRegressionOutput(default, csr) = default
    /// 
    /// The loss function used is the Binary Cross Entropy Loss:
    /// 
    /// :math:`-{(y\log(p) + (1 - y)\log(1 - p))}`
    /// 
    /// Where `y` is the ground truth probability of positive outcome for a given example, and `p` the probability predicted by the model. By default, gradients of this loss function are scaled by factor `1/m`, where m is the number of regression outputs of a training example.
    /// The parameter `grad_scale` can be used to change this scale to `grad_scale/m`.
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\regression_output.cc:L152</summary>
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="data">Input data to the function.</param>
    /// <param name="label">Input label to the function.</param>
    /// <param name="gradScale">Scale the gradient by a float factor</param>
    static member LogisticRegressionOutput(outputArray : NDArray seq, data : NDArray, label : NDArray, [<Optional; DefaultParameterValue(1.0)>] gradScale : float) =
        let creator = AtomicSymbolCreator.FromName "LogisticRegressionOutput"
        let names = [|"grad_scale"|]
        let vals = [|string gradScale|]
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg label)) then label.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <summary>Applies a logistic function to the input.
    /// 
    /// The logistic function, also known as the sigmoid function, is computed as
    /// :math:`\frac{1}{1+exp(-\textbf{x})}`.
    /// 
    /// Commonly, the sigmoid is used to squash the real-valued output of a linear model
    /// :math:`wTx+b` into the [0,1] range so that it can be interpreted as a probability.
    /// It is suitable for binary classification or probability prediction tasks.
    /// 
    /// .. note::
    ///    Use the LogisticRegressionOutput as the final output layer of a net.
    /// 
    /// The storage type of ``label`` can be ``default`` or ``csr``
    /// 
    /// - LogisticRegressionOutput(default, default) = default
    /// - LogisticRegressionOutput(default, csr) = default
    /// 
    /// The loss function used is the Binary Cross Entropy Loss:
    /// 
    /// :math:`-{(y\log(p) + (1 - y)\log(1 - p))}`
    /// 
    /// Where `y` is the ground truth probability of positive outcome for a given example, and `p` the probability predicted by the model. By default, gradients of this loss function are scaled by factor `1/m`, where m is the number of regression outputs of a training example.
    /// The parameter `grad_scale` can be used to change this scale to `grad_scale/m`.
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\regression_output.cc:L152</summary>
    /// <param name="data">Input data to the function.</param>
    /// <param name="label">Input label to the function.</param>
    /// <param name="gradScale">Scale the gradient by a float factor</param>
    static member LogisticRegressionOutput([<Optional>] ?data : Symbol, [<Optional>] ?label : Symbol, [<Optional>] ?gradScale : float) =
        LogisticRegressionOutput(?data = data, ?label = label, ?gradScale = gradScale)


    /// <summary>Applies recurrent layers to input data. Currently, vanilla RNN, LSTM and GRU are
    /// implemented, with both multi-layer and bidirectional support.
    /// 
    /// When the input data is of type float32 and the environment variables MXNET_CUDA_ALLOW_TENSOR_CORE
    /// and MXNET_CUDA_TENSOR_OP_MATH_ALLOW_CONVERSION are set to 1, this operator will try to use
    /// pseudo-float16 precision (float32 math with float16 I/O) precision in order to use
    /// Tensor Cores on suitable NVIDIA GPUs. This can sometimes give significant speedups.
    /// 
    /// **Vanilla RNN**
    /// 
    /// Applies a single-gate recurrent layer to input X. Two kinds of activation function are supported:
    /// ReLU and Tanh.
    /// 
    /// With ReLU activation function:
    /// 
    /// .. math::
    ///     h_t = relu(W_{ih} * x_t + b_{ih}  +  W_{hh} * h_{(t-1)} + b_{hh})
    /// 
    /// With Tanh activtion function:
    /// 
    /// .. math::
    ///     h_t = \tanh(W_{ih} * x_t + b_{ih}  +  W_{hh} * h_{(t-1)} + b_{hh})
    /// 
    /// Reference paper: Finding structure in time - Elman, 1988.
    /// https://crl.ucsd.edu/~elman/Papers/fsit.pdf
    /// 
    /// **LSTM**
    /// 
    /// Long Short-Term Memory - Hochreiter, 1997. http://www.bioinf.jku.at/publications/older/2604.pdf
    /// 
    /// .. math::
    ///   \begin{array}{ll}
    ///             i_t = \mathrm{sigmoid}(W_{ii} x_t + b_{ii} + W_{hi} h_{(t-1)} + b_{hi}) \\
    ///             f_t = \mathrm{sigmoid}(W_{if} x_t + b_{if} + W_{hf} h_{(t-1)} + b_{hf}) \\
    ///             g_t = \tanh(W_{ig} x_t + b_{ig} + W_{hc} h_{(t-1)} + b_{hg}) \\
    ///             o_t = \mathrm{sigmoid}(W_{io} x_t + b_{io} + W_{ho} h_{(t-1)} + b_{ho}) \\
    ///             c_t = f_t * c_{(t-1)} + i_t * g_t \\
    ///             h_t = o_t * \tanh(c_t)
    ///             \end{array}
    /// 
    /// **GRU**
    /// 
    /// Gated Recurrent Unit - Cho et al. 2014. http://arxiv.org/abs/1406.1078
    /// 
    /// The definition of GRU here is slightly different from paper but compatible with CUDNN.
    /// 
    /// .. math::
    ///   \begin{array}{ll}
    ///             r_t = \mathrm{sigmoid}(W_{ir} x_t + b_{ir} + W_{hr} h_{(t-1)} + b_{hr}) \\
    ///             z_t = \mathrm{sigmoid}(W_{iz} x_t + b_{iz} + W_{hz} h_{(t-1)} + b_{hz}) \\
    ///             n_t = \tanh(W_{in} x_t + b_{in} + r_t * (W_{hn} h_{(t-1)}+ b_{hn})) \\
    ///             h_t = (1 - z_t) * n_t + z_t * h_{(t-1)} \\
    ///             \end{array}
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\rnn.cc:L351</summary>
    /// <param name="data">Input data to RNN</param>
    /// <param name="parameters">Vector of all RNN trainable parameters concatenated</param>
    /// <param name="state">initial hidden state of the RNN</param>
    /// <param name="stateCell">initial cell state for LSTM networks (only for LSTM)</param>
    /// <param name="sequenceLength">Vector of valid sequence lengths for each element in batch. (Only used if use_sequence_length kwarg is True)</param>
    /// <param name="stateSize">size of the state for each layer</param>
    /// <param name="numLayers">number of stacked layers</param>
    /// <param name="mode">the type of RNN to compute</param>
    /// <param name="bidirectional">whether to use bidirectional recurrent layers</param>
    /// <param name="p">drop rate of the dropout on the outputs of each RNN layer, except the last layer.</param>
    /// <param name="stateOutputs">Whether to have the states as symbol outputs.</param>
    /// <param name="projectionSize">size of project size</param>
    /// <param name="lstmStateClipMin">Minimum clip value of LSTM states. This option must be used together with lstm_state_clip_max.</param>
    /// <param name="lstmStateClipMax">Maximum clip value of LSTM states. This option must be used together with lstm_state_clip_min.</param>
    /// <param name="lstmStateClipNan">Whether to stop NaN from propagating in state by clipping it to min/max. If clipping range is not specified, this option is ignored.</param>
    /// <param name="useSequenceLength">If set to true, this layer takes in an extra input parameter `sequence_length` to specify variable length sequence</param>
    static member RNN(data : NDArray, 
                      parameters : NDArray, 
                      state : NDArray, 
                      stateCell : NDArray, 
                      sequenceLength : NDArray, 
                      stateSize : int, 
                      numLayers : int, 
                      mode : RNNMode, 
                      [<Optional>] ?bidirectional : bool, 
                      [<Optional>] ?p : float, 
                      [<Optional>] ?stateOutputs : bool, 
                      [<Optional>] ?projectionSize : int, 
                      [<Optional>] ?lstmStateClipMin : float, 
                      [<Optional>] ?lstmStateClipMax : float, 
                      [<Optional>] ?lstmStateClipNan : bool, 
                      [<Optional>] ?useSequenceLength : bool) =
        let creator = AtomicSymbolCreator.FromName "RNN"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg parameters)) then parameters.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg state)) then state.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg stateCell)) then stateCell.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg sequenceLength)) then sequenceLength.UnsafeHandle|]
                                                 [|"state_size"; "num_layers"; "mode"; "bidirectional"; "p"; "state_outputs"; "projection_size"; "lstm_state_clip_min"; "lstm_state_clip_max"; "lstm_state_clip_nan"; "use_sequence_length"|]
                                                 [|string stateSize; string numLayers; string mode; (match bidirectional with None -> "false" | Some bidirectional -> string bidirectional); (match p with None -> "0.0" | Some p -> string p); (match stateOutputs with None -> "false" | Some stateOutputs -> string stateOutputs); (match projectionSize with None -> "None" | Some projectionSize -> string projectionSize); (match lstmStateClipMin with None -> "None" | Some lstmStateClipMin -> string lstmStateClipMin); (match lstmStateClipMax with None -> "None" | Some lstmStateClipMax -> string lstmStateClipMax); (match lstmStateClipNan with None -> "false" | Some lstmStateClipNan -> string lstmStateClipNan); (match useSequenceLength with None -> "false" | Some useSequenceLength -> string useSequenceLength)|]
        outputs |> Array.map (fun h -> new NDArray(h))
    /// <summary>Applies recurrent layers to input data. Currently, vanilla RNN, LSTM and GRU are
    /// implemented, with both multi-layer and bidirectional support.
    /// 
    /// When the input data is of type float32 and the environment variables MXNET_CUDA_ALLOW_TENSOR_CORE
    /// and MXNET_CUDA_TENSOR_OP_MATH_ALLOW_CONVERSION are set to 1, this operator will try to use
    /// pseudo-float16 precision (float32 math with float16 I/O) precision in order to use
    /// Tensor Cores on suitable NVIDIA GPUs. This can sometimes give significant speedups.
    /// 
    /// **Vanilla RNN**
    /// 
    /// Applies a single-gate recurrent layer to input X. Two kinds of activation function are supported:
    /// ReLU and Tanh.
    /// 
    /// With ReLU activation function:
    /// 
    /// .. math::
    ///     h_t = relu(W_{ih} * x_t + b_{ih}  +  W_{hh} * h_{(t-1)} + b_{hh})
    /// 
    /// With Tanh activtion function:
    /// 
    /// .. math::
    ///     h_t = \tanh(W_{ih} * x_t + b_{ih}  +  W_{hh} * h_{(t-1)} + b_{hh})
    /// 
    /// Reference paper: Finding structure in time - Elman, 1988.
    /// https://crl.ucsd.edu/~elman/Papers/fsit.pdf
    /// 
    /// **LSTM**
    /// 
    /// Long Short-Term Memory - Hochreiter, 1997. http://www.bioinf.jku.at/publications/older/2604.pdf
    /// 
    /// .. math::
    ///   \begin{array}{ll}
    ///             i_t = \mathrm{sigmoid}(W_{ii} x_t + b_{ii} + W_{hi} h_{(t-1)} + b_{hi}) \\
    ///             f_t = \mathrm{sigmoid}(W_{if} x_t + b_{if} + W_{hf} h_{(t-1)} + b_{hf}) \\
    ///             g_t = \tanh(W_{ig} x_t + b_{ig} + W_{hc} h_{(t-1)} + b_{hg}) \\
    ///             o_t = \mathrm{sigmoid}(W_{io} x_t + b_{io} + W_{ho} h_{(t-1)} + b_{ho}) \\
    ///             c_t = f_t * c_{(t-1)} + i_t * g_t \\
    ///             h_t = o_t * \tanh(c_t)
    ///             \end{array}
    /// 
    /// **GRU**
    /// 
    /// Gated Recurrent Unit - Cho et al. 2014. http://arxiv.org/abs/1406.1078
    /// 
    /// The definition of GRU here is slightly different from paper but compatible with CUDNN.
    /// 
    /// .. math::
    ///   \begin{array}{ll}
    ///             r_t = \mathrm{sigmoid}(W_{ir} x_t + b_{ir} + W_{hr} h_{(t-1)} + b_{hr}) \\
    ///             z_t = \mathrm{sigmoid}(W_{iz} x_t + b_{iz} + W_{hz} h_{(t-1)} + b_{hz}) \\
    ///             n_t = \tanh(W_{in} x_t + b_{in} + r_t * (W_{hn} h_{(t-1)}+ b_{hn})) \\
    ///             h_t = (1 - z_t) * n_t + z_t * h_{(t-1)} \\
    ///             \end{array}
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\rnn.cc:L351</summary>
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="data">Input data to RNN</param>
    /// <param name="parameters">Vector of all RNN trainable parameters concatenated</param>
    /// <param name="state">initial hidden state of the RNN</param>
    /// <param name="stateCell">initial cell state for LSTM networks (only for LSTM)</param>
    /// <param name="sequenceLength">Vector of valid sequence lengths for each element in batch. (Only used if use_sequence_length kwarg is True)</param>
    /// <param name="stateSize">size of the state for each layer</param>
    /// <param name="numLayers">number of stacked layers</param>
    /// <param name="mode">the type of RNN to compute</param>
    /// <param name="bidirectional">whether to use bidirectional recurrent layers</param>
    /// <param name="p">drop rate of the dropout on the outputs of each RNN layer, except the last layer.</param>
    /// <param name="stateOutputs">Whether to have the states as symbol outputs.</param>
    /// <param name="projectionSize">size of project size</param>
    /// <param name="lstmStateClipMin">Minimum clip value of LSTM states. This option must be used together with lstm_state_clip_max.</param>
    /// <param name="lstmStateClipMax">Maximum clip value of LSTM states. This option must be used together with lstm_state_clip_min.</param>
    /// <param name="lstmStateClipNan">Whether to stop NaN from propagating in state by clipping it to min/max. If clipping range is not specified, this option is ignored.</param>
    /// <param name="useSequenceLength">If set to true, this layer takes in an extra input parameter `sequence_length` to specify variable length sequence</param>
    static member RNN(outputArray : NDArray seq, 
                      data : NDArray, 
                      parameters : NDArray, 
                      state : NDArray, 
                      stateCell : NDArray, 
                      sequenceLength : NDArray, 
                      stateSize : int, 
                      numLayers : int, 
                      mode : RNNMode, 
                      [<Optional>] ?bidirectional : bool, 
                      [<Optional>] ?p : float, 
                      [<Optional>] ?stateOutputs : bool, 
                      [<Optional>] ?projectionSize : int, 
                      [<Optional>] ?lstmStateClipMin : float, 
                      [<Optional>] ?lstmStateClipMax : float, 
                      [<Optional>] ?lstmStateClipNan : bool, 
                      [<Optional>] ?useSequenceLength : bool) =
        let creator = AtomicSymbolCreator.FromName "RNN"
        let names = [|"state_size"; "num_layers"; "mode"; "bidirectional"; "p"; "state_outputs"; "projection_size"; "lstm_state_clip_min"; "lstm_state_clip_max"; "lstm_state_clip_nan"; "use_sequence_length"|]
        let vals = [|string stateSize; string numLayers; string mode; (match bidirectional with None -> "false" | Some bidirectional -> string bidirectional); (match p with None -> "0.0" | Some p -> string p); (match stateOutputs with None -> "false" | Some stateOutputs -> string stateOutputs); (match projectionSize with None -> "None" | Some projectionSize -> string projectionSize); (match lstmStateClipMin with None -> "None" | Some lstmStateClipMin -> string lstmStateClipMin); (match lstmStateClipMax with None -> "None" | Some lstmStateClipMax -> string lstmStateClipMax); (match lstmStateClipNan with None -> "false" | Some lstmStateClipNan -> string lstmStateClipNan); (match useSequenceLength with None -> "false" | Some useSequenceLength -> string useSequenceLength)|]
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg parameters)) then parameters.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg state)) then state.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg stateCell)) then stateCell.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg sequenceLength)) then sequenceLength.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <summary>Applies recurrent layers to input data. Currently, vanilla RNN, LSTM and GRU are
    /// implemented, with both multi-layer and bidirectional support.
    /// 
    /// When the input data is of type float32 and the environment variables MXNET_CUDA_ALLOW_TENSOR_CORE
    /// and MXNET_CUDA_TENSOR_OP_MATH_ALLOW_CONVERSION are set to 1, this operator will try to use
    /// pseudo-float16 precision (float32 math with float16 I/O) precision in order to use
    /// Tensor Cores on suitable NVIDIA GPUs. This can sometimes give significant speedups.
    /// 
    /// **Vanilla RNN**
    /// 
    /// Applies a single-gate recurrent layer to input X. Two kinds of activation function are supported:
    /// ReLU and Tanh.
    /// 
    /// With ReLU activation function:
    /// 
    /// .. math::
    ///     h_t = relu(W_{ih} * x_t + b_{ih}  +  W_{hh} * h_{(t-1)} + b_{hh})
    /// 
    /// With Tanh activtion function:
    /// 
    /// .. math::
    ///     h_t = \tanh(W_{ih} * x_t + b_{ih}  +  W_{hh} * h_{(t-1)} + b_{hh})
    /// 
    /// Reference paper: Finding structure in time - Elman, 1988.
    /// https://crl.ucsd.edu/~elman/Papers/fsit.pdf
    /// 
    /// **LSTM**
    /// 
    /// Long Short-Term Memory - Hochreiter, 1997. http://www.bioinf.jku.at/publications/older/2604.pdf
    /// 
    /// .. math::
    ///   \begin{array}{ll}
    ///             i_t = \mathrm{sigmoid}(W_{ii} x_t + b_{ii} + W_{hi} h_{(t-1)} + b_{hi}) \\
    ///             f_t = \mathrm{sigmoid}(W_{if} x_t + b_{if} + W_{hf} h_{(t-1)} + b_{hf}) \\
    ///             g_t = \tanh(W_{ig} x_t + b_{ig} + W_{hc} h_{(t-1)} + b_{hg}) \\
    ///             o_t = \mathrm{sigmoid}(W_{io} x_t + b_{io} + W_{ho} h_{(t-1)} + b_{ho}) \\
    ///             c_t = f_t * c_{(t-1)} + i_t * g_t \\
    ///             h_t = o_t * \tanh(c_t)
    ///             \end{array}
    /// 
    /// **GRU**
    /// 
    /// Gated Recurrent Unit - Cho et al. 2014. http://arxiv.org/abs/1406.1078
    /// 
    /// The definition of GRU here is slightly different from paper but compatible with CUDNN.
    /// 
    /// .. math::
    ///   \begin{array}{ll}
    ///             r_t = \mathrm{sigmoid}(W_{ir} x_t + b_{ir} + W_{hr} h_{(t-1)} + b_{hr}) \\
    ///             z_t = \mathrm{sigmoid}(W_{iz} x_t + b_{iz} + W_{hz} h_{(t-1)} + b_{hz}) \\
    ///             n_t = \tanh(W_{in} x_t + b_{in} + r_t * (W_{hn} h_{(t-1)}+ b_{hn})) \\
    ///             h_t = (1 - z_t) * n_t + z_t * h_{(t-1)} \\
    ///             \end{array}
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\rnn.cc:L351</summary>
    /// <param name="data">Input data to RNN</param>
    /// <param name="parameters">Vector of all RNN trainable parameters concatenated</param>
    /// <param name="state">initial hidden state of the RNN</param>
    /// <param name="stateCell">initial cell state for LSTM networks (only for LSTM)</param>
    /// <param name="sequenceLength">Vector of valid sequence lengths for each element in batch. (Only used if use_sequence_length kwarg is True)</param>
    /// <param name="stateSize">size of the state for each layer</param>
    /// <param name="numLayers">number of stacked layers</param>
    /// <param name="mode">the type of RNN to compute</param>
    /// <param name="bidirectional">whether to use bidirectional recurrent layers</param>
    /// <param name="p">drop rate of the dropout on the outputs of each RNN layer, except the last layer.</param>
    /// <param name="stateOutputs">Whether to have the states as symbol outputs.</param>
    /// <param name="projectionSize">size of project size</param>
    /// <param name="lstmStateClipMin">Minimum clip value of LSTM states. This option must be used together with lstm_state_clip_max.</param>
    /// <param name="lstmStateClipMax">Maximum clip value of LSTM states. This option must be used together with lstm_state_clip_min.</param>
    /// <param name="lstmStateClipNan">Whether to stop NaN from propagating in state by clipping it to min/max. If clipping range is not specified, this option is ignored.</param>
    /// <param name="useSequenceLength">If set to true, this layer takes in an extra input parameter `sequence_length` to specify variable length sequence</param>
    static member RNN(data : Symbol, parameters : Symbol, state : Symbol, stateCell : Symbol, sequenceLength : Symbol, stateSize : int, numLayers : int, mode : RNNMode, [<Optional>] ?bidirectional : bool, [<Optional>] ?p : float, [<Optional>] ?stateOutputs : bool, [<Optional>] ?projectionSize : int, [<Optional>] ?lstmStateClipMin : float, [<Optional>] ?lstmStateClipMax : float, [<Optional>] ?lstmStateClipNan : bool, [<Optional>] ?useSequenceLength : bool) =
        RNN(data, parameters, state, stateCell, sequenceLength, stateSize, numLayers, mode, ?bidirectional = bidirectional, ?p = p, ?stateOutputs = stateOutputs, ?projectionSize = projectionSize, ?lstmStateClipMin = lstmStateClipMin, ?lstmStateClipMax = lstmStateClipMax, ?lstmStateClipNan = lstmStateClipNan, ?useSequenceLength = useSequenceLength)
    /// <summary>Applies recurrent layers to input data. Currently, vanilla RNN, LSTM and GRU are
    /// implemented, with both multi-layer and bidirectional support.
    /// 
    /// When the input data is of type float32 and the environment variables MXNET_CUDA_ALLOW_TENSOR_CORE
    /// and MXNET_CUDA_TENSOR_OP_MATH_ALLOW_CONVERSION are set to 1, this operator will try to use
    /// pseudo-float16 precision (float32 math with float16 I/O) precision in order to use
    /// Tensor Cores on suitable NVIDIA GPUs. This can sometimes give significant speedups.
    /// 
    /// **Vanilla RNN**
    /// 
    /// Applies a single-gate recurrent layer to input X. Two kinds of activation function are supported:
    /// ReLU and Tanh.
    /// 
    /// With ReLU activation function:
    /// 
    /// .. math::
    ///     h_t = relu(W_{ih} * x_t + b_{ih}  +  W_{hh} * h_{(t-1)} + b_{hh})
    /// 
    /// With Tanh activtion function:
    /// 
    /// .. math::
    ///     h_t = \tanh(W_{ih} * x_t + b_{ih}  +  W_{hh} * h_{(t-1)} + b_{hh})
    /// 
    /// Reference paper: Finding structure in time - Elman, 1988.
    /// https://crl.ucsd.edu/~elman/Papers/fsit.pdf
    /// 
    /// **LSTM**
    /// 
    /// Long Short-Term Memory - Hochreiter, 1997. http://www.bioinf.jku.at/publications/older/2604.pdf
    /// 
    /// .. math::
    ///   \begin{array}{ll}
    ///             i_t = \mathrm{sigmoid}(W_{ii} x_t + b_{ii} + W_{hi} h_{(t-1)} + b_{hi}) \\
    ///             f_t = \mathrm{sigmoid}(W_{if} x_t + b_{if} + W_{hf} h_{(t-1)} + b_{hf}) \\
    ///             g_t = \tanh(W_{ig} x_t + b_{ig} + W_{hc} h_{(t-1)} + b_{hg}) \\
    ///             o_t = \mathrm{sigmoid}(W_{io} x_t + b_{io} + W_{ho} h_{(t-1)} + b_{ho}) \\
    ///             c_t = f_t * c_{(t-1)} + i_t * g_t \\
    ///             h_t = o_t * \tanh(c_t)
    ///             \end{array}
    /// 
    /// **GRU**
    /// 
    /// Gated Recurrent Unit - Cho et al. 2014. http://arxiv.org/abs/1406.1078
    /// 
    /// The definition of GRU here is slightly different from paper but compatible with CUDNN.
    /// 
    /// .. math::
    ///   \begin{array}{ll}
    ///             r_t = \mathrm{sigmoid}(W_{ir} x_t + b_{ir} + W_{hr} h_{(t-1)} + b_{hr}) \\
    ///             z_t = \mathrm{sigmoid}(W_{iz} x_t + b_{iz} + W_{hz} h_{(t-1)} + b_{hz}) \\
    ///             n_t = \tanh(W_{in} x_t + b_{in} + r_t * (W_{hn} h_{(t-1)}+ b_{hn})) \\
    ///             h_t = (1 - z_t) * n_t + z_t * h_{(t-1)} \\
    ///             \end{array}
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\rnn.cc:L351</summary>
    /// <param name="stateSize">size of the state for each layer</param>
    /// <param name="numLayers">number of stacked layers</param>
    /// <param name="mode">the type of RNN to compute</param>
    /// <param name="data">Input data to RNN</param>
    /// <param name="parameters">Vector of all RNN trainable parameters concatenated</param>
    /// <param name="state">initial hidden state of the RNN</param>
    /// <param name="stateCell">initial cell state for LSTM networks (only for LSTM)</param>
    /// <param name="sequenceLength">Vector of valid sequence lengths for each element in batch. (Only used if use_sequence_length kwarg is True)</param>
    /// <param name="bidirectional">whether to use bidirectional recurrent layers</param>
    /// <param name="p">drop rate of the dropout on the outputs of each RNN layer, except the last layer.</param>
    /// <param name="stateOutputs">Whether to have the states as symbol outputs.</param>
    /// <param name="projectionSize">size of project size</param>
    /// <param name="lstmStateClipMin">Minimum clip value of LSTM states. This option must be used together with lstm_state_clip_max.</param>
    /// <param name="lstmStateClipMax">Maximum clip value of LSTM states. This option must be used together with lstm_state_clip_min.</param>
    /// <param name="lstmStateClipNan">Whether to stop NaN from propagating in state by clipping it to min/max. If clipping range is not specified, this option is ignored.</param>
    /// <param name="useSequenceLength">If set to true, this layer takes in an extra input parameter `sequence_length` to specify variable length sequence</param>
    static member RNN(stateSize : int, numLayers : int, mode : RNNMode, [<Optional>] ?data : Symbol, [<Optional>] ?parameters : Symbol, [<Optional>] ?state : Symbol, [<Optional>] ?stateCell : Symbol, [<Optional>] ?sequenceLength : Symbol, [<Optional>] ?bidirectional : bool, [<Optional>] ?p : float, [<Optional>] ?stateOutputs : bool, [<Optional>] ?projectionSize : int, [<Optional>] ?lstmStateClipMin : float, [<Optional>] ?lstmStateClipMax : float, [<Optional>] ?lstmStateClipNan : bool, [<Optional>] ?useSequenceLength : bool) =
        RNN(stateSize, numLayers, mode, ?data = data, ?parameters = parameters, ?state = state, ?stateCell = stateCell, ?sequenceLength = sequenceLength, ?bidirectional = bidirectional, ?p = p, ?stateOutputs = stateOutputs, ?projectionSize = projectionSize, ?lstmStateClipMin = lstmStateClipMin, ?lstmStateClipMax = lstmStateClipMax, ?lstmStateClipNan = lstmStateClipNan, ?useSequenceLength = useSequenceLength)


    /// <summary>Performs region of interest(ROI) pooling on the input array.
    /// 
    /// ROI pooling is a variant of a max pooling layer, in which the output size is fixed and
    /// region of interest is a parameter. Its purpose is to perform max pooling on the inputs
    /// of non-uniform sizes to obtain fixed-size feature maps. ROI pooling is a neural-net
    /// layer mostly used in training a `Fast R-CNN` network for object detection.
    /// 
    /// This operator takes a 4D feature map as an input array and region proposals as `rois`,
    /// then it pools over sub-regions of input and produces a fixed-sized output array
    /// regardless of the ROI size.
    /// 
    /// To crop the feature map accordingly, you can resize the bounding box coordinates
    /// by changing the parameters `rois` and `spatial_scale`.
    /// 
    /// The cropped feature maps are pooled by standard max pooling operation to a fixed size output
    /// indicated by a `pooled_size` parameter. batch_size will change to the number of region
    /// bounding boxes after `ROIPooling`.
    /// 
    /// The size of each region of interest doesn&#39;t have to be perfectly divisible by
    /// the number of pooling sections(`pooled_size`).
    /// 
    /// Example::
    /// 
    ///   x = [[[[  0.,   1.,   2.,   3.,   4.,   5.],
    ///          [  6.,   7.,   8.,   9.,  10.,  11.],
    ///          [ 12.,  13.,  14.,  15.,  16.,  17.],
    ///          [ 18.,  19.,  20.,  21.,  22.,  23.],
    ///          [ 24.,  25.,  26.,  27.,  28.,  29.],
    ///          [ 30.,  31.,  32.,  33.,  34.,  35.],
    ///          [ 36.,  37.,  38.,  39.,  40.,  41.],
    ///          [ 42.,  43.,  44.,  45.,  46.,  47.]]]]
    /// 
    ///   // region of interest i.e. bounding box coordinates.
    ///   y = [[0,0,0,4,4]]
    /// 
    ///   // returns array of shape (2,2) according to the given roi with max pooling.
    ///   ROIPooling(x, y, (2,2), 1.0) = [[[[ 14.,  16.],
    ///                                     [ 26.,  28.]]]]
    /// 
    ///   // region of interest is changed due to the change in `spacial_scale` parameter.
    ///   ROIPooling(x, y, (2,2), 0.7) = [[[[  7.,   9.],
    ///                                     [ 19.,  21.]]]]
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\roi_pooling.cc:L225</summary>
    /// <param name="data">The input array to the pooling operator,  a 4D Feature maps </param>
    /// <param name="rois">Bounding box coordinates, a 2D array of [[batch_index, x1, y1, x2, y2]], where (x1, y1) and (x2, y2) are top left and bottom right corners of designated region of interest. `batch_index` indicates the index of corresponding image in the input array</param>
    /// <param name="pooledSize">ROI pooling output shape (h,w) </param>
    /// <param name="spatialScale">Ratio of input feature map height (or w) to raw image height (or w). Equals the reciprocal of total stride in convolutional layers</param>
    static member ROIPooling(data : NDArray, rois : NDArray, pooledSize : int seq, spatialScale : float) =
        let creator = AtomicSymbolCreator.FromName "ROIPooling"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg rois)) then rois.UnsafeHandle|]
                                                 [|"pooled_size"; "spatial_scale"|]
                                                 [|(pooledSize |> Seq.map string |> String.concat ", " |> sprintf "[%s]"); string spatialScale|]
        outputs |> Array.map (fun h -> new NDArray(h))
    /// <summary>Performs region of interest(ROI) pooling on the input array.
    /// 
    /// ROI pooling is a variant of a max pooling layer, in which the output size is fixed and
    /// region of interest is a parameter. Its purpose is to perform max pooling on the inputs
    /// of non-uniform sizes to obtain fixed-size feature maps. ROI pooling is a neural-net
    /// layer mostly used in training a `Fast R-CNN` network for object detection.
    /// 
    /// This operator takes a 4D feature map as an input array and region proposals as `rois`,
    /// then it pools over sub-regions of input and produces a fixed-sized output array
    /// regardless of the ROI size.
    /// 
    /// To crop the feature map accordingly, you can resize the bounding box coordinates
    /// by changing the parameters `rois` and `spatial_scale`.
    /// 
    /// The cropped feature maps are pooled by standard max pooling operation to a fixed size output
    /// indicated by a `pooled_size` parameter. batch_size will change to the number of region
    /// bounding boxes after `ROIPooling`.
    /// 
    /// The size of each region of interest doesn&#39;t have to be perfectly divisible by
    /// the number of pooling sections(`pooled_size`).
    /// 
    /// Example::
    /// 
    ///   x = [[[[  0.,   1.,   2.,   3.,   4.,   5.],
    ///          [  6.,   7.,   8.,   9.,  10.,  11.],
    ///          [ 12.,  13.,  14.,  15.,  16.,  17.],
    ///          [ 18.,  19.,  20.,  21.,  22.,  23.],
    ///          [ 24.,  25.,  26.,  27.,  28.,  29.],
    ///          [ 30.,  31.,  32.,  33.,  34.,  35.],
    ///          [ 36.,  37.,  38.,  39.,  40.,  41.],
    ///          [ 42.,  43.,  44.,  45.,  46.,  47.]]]]
    /// 
    ///   // region of interest i.e. bounding box coordinates.
    ///   y = [[0,0,0,4,4]]
    /// 
    ///   // returns array of shape (2,2) according to the given roi with max pooling.
    ///   ROIPooling(x, y, (2,2), 1.0) = [[[[ 14.,  16.],
    ///                                     [ 26.,  28.]]]]
    /// 
    ///   // region of interest is changed due to the change in `spacial_scale` parameter.
    ///   ROIPooling(x, y, (2,2), 0.7) = [[[[  7.,   9.],
    ///                                     [ 19.,  21.]]]]
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\roi_pooling.cc:L225</summary>
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="data">The input array to the pooling operator,  a 4D Feature maps </param>
    /// <param name="rois">Bounding box coordinates, a 2D array of [[batch_index, x1, y1, x2, y2]], where (x1, y1) and (x2, y2) are top left and bottom right corners of designated region of interest. `batch_index` indicates the index of corresponding image in the input array</param>
    /// <param name="pooledSize">ROI pooling output shape (h,w) </param>
    /// <param name="spatialScale">Ratio of input feature map height (or w) to raw image height (or w). Equals the reciprocal of total stride in convolutional layers</param>
    static member ROIPooling(outputArray : NDArray seq, data : NDArray, rois : NDArray, pooledSize : int seq, spatialScale : float) =
        let creator = AtomicSymbolCreator.FromName "ROIPooling"
        let names = [|"pooled_size"; "spatial_scale"|]
        let vals = [|(pooledSize |> Seq.map string |> String.concat ", " |> sprintf "[%s]"); string spatialScale|]
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg rois)) then rois.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <summary>Performs region of interest(ROI) pooling on the input array.
    /// 
    /// ROI pooling is a variant of a max pooling layer, in which the output size is fixed and
    /// region of interest is a parameter. Its purpose is to perform max pooling on the inputs
    /// of non-uniform sizes to obtain fixed-size feature maps. ROI pooling is a neural-net
    /// layer mostly used in training a `Fast R-CNN` network for object detection.
    /// 
    /// This operator takes a 4D feature map as an input array and region proposals as `rois`,
    /// then it pools over sub-regions of input and produces a fixed-sized output array
    /// regardless of the ROI size.
    /// 
    /// To crop the feature map accordingly, you can resize the bounding box coordinates
    /// by changing the parameters `rois` and `spatial_scale`.
    /// 
    /// The cropped feature maps are pooled by standard max pooling operation to a fixed size output
    /// indicated by a `pooled_size` parameter. batch_size will change to the number of region
    /// bounding boxes after `ROIPooling`.
    /// 
    /// The size of each region of interest doesn&#39;t have to be perfectly divisible by
    /// the number of pooling sections(`pooled_size`).
    /// 
    /// Example::
    /// 
    ///   x = [[[[  0.,   1.,   2.,   3.,   4.,   5.],
    ///          [  6.,   7.,   8.,   9.,  10.,  11.],
    ///          [ 12.,  13.,  14.,  15.,  16.,  17.],
    ///          [ 18.,  19.,  20.,  21.,  22.,  23.],
    ///          [ 24.,  25.,  26.,  27.,  28.,  29.],
    ///          [ 30.,  31.,  32.,  33.,  34.,  35.],
    ///          [ 36.,  37.,  38.,  39.,  40.,  41.],
    ///          [ 42.,  43.,  44.,  45.,  46.,  47.]]]]
    /// 
    ///   // region of interest i.e. bounding box coordinates.
    ///   y = [[0,0,0,4,4]]
    /// 
    ///   // returns array of shape (2,2) according to the given roi with max pooling.
    ///   ROIPooling(x, y, (2,2), 1.0) = [[[[ 14.,  16.],
    ///                                     [ 26.,  28.]]]]
    /// 
    ///   // region of interest is changed due to the change in `spacial_scale` parameter.
    ///   ROIPooling(x, y, (2,2), 0.7) = [[[[  7.,   9.],
    ///                                     [ 19.,  21.]]]]
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\roi_pooling.cc:L225</summary>
    /// <param name="data">The input array to the pooling operator,  a 4D Feature maps </param>
    /// <param name="rois">Bounding box coordinates, a 2D array of [[batch_index, x1, y1, x2, y2]], where (x1, y1) and (x2, y2) are top left and bottom right corners of designated region of interest. `batch_index` indicates the index of corresponding image in the input array</param>
    /// <param name="pooledSize">ROI pooling output shape (h,w) </param>
    /// <param name="spatialScale">Ratio of input feature map height (or w) to raw image height (or w). Equals the reciprocal of total stride in convolutional layers</param>
    static member ROIPooling(data : Symbol, rois : Symbol, pooledSize : int seq, spatialScale : float) =
        ROIPooling(data, rois, pooledSize, spatialScale)
    /// <summary>Performs region of interest(ROI) pooling on the input array.
    /// 
    /// ROI pooling is a variant of a max pooling layer, in which the output size is fixed and
    /// region of interest is a parameter. Its purpose is to perform max pooling on the inputs
    /// of non-uniform sizes to obtain fixed-size feature maps. ROI pooling is a neural-net
    /// layer mostly used in training a `Fast R-CNN` network for object detection.
    /// 
    /// This operator takes a 4D feature map as an input array and region proposals as `rois`,
    /// then it pools over sub-regions of input and produces a fixed-sized output array
    /// regardless of the ROI size.
    /// 
    /// To crop the feature map accordingly, you can resize the bounding box coordinates
    /// by changing the parameters `rois` and `spatial_scale`.
    /// 
    /// The cropped feature maps are pooled by standard max pooling operation to a fixed size output
    /// indicated by a `pooled_size` parameter. batch_size will change to the number of region
    /// bounding boxes after `ROIPooling`.
    /// 
    /// The size of each region of interest doesn&#39;t have to be perfectly divisible by
    /// the number of pooling sections(`pooled_size`).
    /// 
    /// Example::
    /// 
    ///   x = [[[[  0.,   1.,   2.,   3.,   4.,   5.],
    ///          [  6.,   7.,   8.,   9.,  10.,  11.],
    ///          [ 12.,  13.,  14.,  15.,  16.,  17.],
    ///          [ 18.,  19.,  20.,  21.,  22.,  23.],
    ///          [ 24.,  25.,  26.,  27.,  28.,  29.],
    ///          [ 30.,  31.,  32.,  33.,  34.,  35.],
    ///          [ 36.,  37.,  38.,  39.,  40.,  41.],
    ///          [ 42.,  43.,  44.,  45.,  46.,  47.]]]]
    /// 
    ///   // region of interest i.e. bounding box coordinates.
    ///   y = [[0,0,0,4,4]]
    /// 
    ///   // returns array of shape (2,2) according to the given roi with max pooling.
    ///   ROIPooling(x, y, (2,2), 1.0) = [[[[ 14.,  16.],
    ///                                     [ 26.,  28.]]]]
    /// 
    ///   // region of interest is changed due to the change in `spacial_scale` parameter.
    ///   ROIPooling(x, y, (2,2), 0.7) = [[[[  7.,   9.],
    ///                                     [ 19.,  21.]]]]
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\roi_pooling.cc:L225</summary>
    /// <param name="pooledSize">ROI pooling output shape (h,w) </param>
    /// <param name="spatialScale">Ratio of input feature map height (or w) to raw image height (or w). Equals the reciprocal of total stride in convolutional layers</param>
    /// <param name="data">The input array to the pooling operator,  a 4D Feature maps </param>
    /// <param name="rois">Bounding box coordinates, a 2D array of [[batch_index, x1, y1, x2, y2]], where (x1, y1) and (x2, y2) are top left and bottom right corners of designated region of interest. `batch_index` indicates the index of corresponding image in the input array</param>
    static member ROIPooling(pooledSize : int seq, spatialScale : float, [<Optional>] ?data : Symbol, [<Optional>] ?rois : Symbol) =
        ROIPooling(pooledSize, spatialScale, ?data = data, ?rois = rois)

    /// <summary>Sets all elements outside the sequence to a constant value.
    /// 
    /// This function takes an n-dimensional input array of the form
    /// [max_sequence_length, batch_size, other_feature_dims] and returns an array of the same shape.
    /// 
    /// Parameter `sequence_length` is used to handle variable-length sequences. `sequence_length`
    /// should be an input array of positive ints of dimension [batch_size].
    /// To use this parameter, set `use_sequence_length` to `True`,
    /// otherwise each example in the batch is assumed to have the max sequence length and
    /// this operator works as the `identity` operator.
    /// 
    /// Example::
    /// 
    ///    x = [[[  1.,   2.,   3.],
    ///          [  4.,   5.,   6.]],
    /// 
    ///         [[  7.,   8.,   9.],
    ///          [ 10.,  11.,  12.]],
    /// 
    ///         [[ 13.,  14.,   15.],
    ///          [ 16.,  17.,   18.]]]
    /// 
    ///    // Batch 1
    ///    B1 = [[  1.,   2.,   3.],
    ///          [  7.,   8.,   9.],
    ///          [ 13.,  14.,  15.]]
    /// 
    ///    // Batch 2
    ///    B2 = [[  4.,   5.,   6.],
    ///          [ 10.,  11.,  12.],
    ///          [ 16.,  17.,  18.]]
    /// 
    ///    // works as identity operator when sequence_length parameter is not used
    ///    SequenceMask(x) = [[[  1.,   2.,   3.],
    ///                        [  4.,   5.,   6.]],
    /// 
    ///                       [[  7.,   8.,   9.],
    ///                        [ 10.,  11.,  12.]],
    /// 
    ///                       [[ 13.,  14.,   15.],
    ///                        [ 16.,  17.,   18.]]]
    /// 
    ///    // sequence_length [1,1] means 1 of each batch will be kept
    ///    // and other rows are masked with default mask value = 0
    ///    SequenceMask(x, sequence_length=[1,1], use_sequence_length=True) =
    ///                 [[[  1.,   2.,   3.],
    ///                   [  4.,   5.,   6.]],
    /// 
    ///                  [[  0.,   0.,   0.],
    ///                   [  0.,   0.,   0.]],
    /// 
    ///                  [[  0.,   0.,   0.],
    ///                   [  0.,   0.,   0.]]]
    /// 
    ///    // sequence_length [2,3] means 2 of batch B1 and 3 of batch B2 will be kept
    ///    // and other rows are masked with value = 1
    ///    SequenceMask(x, sequence_length=[2,3], use_sequence_length=True, value=1) =
    ///                 [[[  1.,   2.,   3.],
    ///                   [  4.,   5.,   6.]],
    /// 
    ///                  [[  7.,   8.,   9.],
    ///                   [  10.,  11.,  12.]],
    /// 
    ///                  [[   1.,   1.,   1.],
    ///                   [  16.,  17.,  18.]]]
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\sequence_mask.cc:L186</summary>
    /// <param name="data">n-dimensional input array of the form [max_sequence_length, batch_size, other_feature_dims] where n&gt;2</param>
    /// <param name="sequenceLength">vector of sequence lengths of the form [batch_size]</param>
    /// <param name="useSequenceLength">If set to true, this layer takes in an extra input parameter `sequence_length` to specify variable length sequence</param>
    /// <param name="value">The value to be used as a mask.</param>
    /// <param name="axis">The sequence axis. Only values of 0 and 1 are currently supported.</param>
    static member SequenceMask(data : NDArray, 
                               sequenceLength : NDArray, 
                               [<Optional; DefaultParameterValue(false)>] useSequenceLength : bool, 
                               [<Optional; DefaultParameterValue(0.0)>] value : float, 
                               [<Optional; DefaultParameterValue(0)>] axis : int) =
        let creator = AtomicSymbolCreator.FromName "SequenceMask"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg sequenceLength)) then sequenceLength.UnsafeHandle|]
                                                 [|"use_sequence_length"; "value"; "axis"|]
                                                 [|string useSequenceLength; string value; string axis|]
        (new NDArray(outputs.[0]))
    /// <summary>Sets all elements outside the sequence to a constant value.
    /// 
    /// This function takes an n-dimensional input array of the form
    /// [max_sequence_length, batch_size, other_feature_dims] and returns an array of the same shape.
    /// 
    /// Parameter `sequence_length` is used to handle variable-length sequences. `sequence_length`
    /// should be an input array of positive ints of dimension [batch_size].
    /// To use this parameter, set `use_sequence_length` to `True`,
    /// otherwise each example in the batch is assumed to have the max sequence length and
    /// this operator works as the `identity` operator.
    /// 
    /// Example::
    /// 
    ///    x = [[[  1.,   2.,   3.],
    ///          [  4.,   5.,   6.]],
    /// 
    ///         [[  7.,   8.,   9.],
    ///          [ 10.,  11.,  12.]],
    /// 
    ///         [[ 13.,  14.,   15.],
    ///          [ 16.,  17.,   18.]]]
    /// 
    ///    // Batch 1
    ///    B1 = [[  1.,   2.,   3.],
    ///          [  7.,   8.,   9.],
    ///          [ 13.,  14.,  15.]]
    /// 
    ///    // Batch 2
    ///    B2 = [[  4.,   5.,   6.],
    ///          [ 10.,  11.,  12.],
    ///          [ 16.,  17.,  18.]]
    /// 
    ///    // works as identity operator when sequence_length parameter is not used
    ///    SequenceMask(x) = [[[  1.,   2.,   3.],
    ///                        [  4.,   5.,   6.]],
    /// 
    ///                       [[  7.,   8.,   9.],
    ///                        [ 10.,  11.,  12.]],
    /// 
    ///                       [[ 13.,  14.,   15.],
    ///                        [ 16.,  17.,   18.]]]
    /// 
    ///    // sequence_length [1,1] means 1 of each batch will be kept
    ///    // and other rows are masked with default mask value = 0
    ///    SequenceMask(x, sequence_length=[1,1], use_sequence_length=True) =
    ///                 [[[  1.,   2.,   3.],
    ///                   [  4.,   5.,   6.]],
    /// 
    ///                  [[  0.,   0.,   0.],
    ///                   [  0.,   0.,   0.]],
    /// 
    ///                  [[  0.,   0.,   0.],
    ///                   [  0.,   0.,   0.]]]
    /// 
    ///    // sequence_length [2,3] means 2 of batch B1 and 3 of batch B2 will be kept
    ///    // and other rows are masked with value = 1
    ///    SequenceMask(x, sequence_length=[2,3], use_sequence_length=True, value=1) =
    ///                 [[[  1.,   2.,   3.],
    ///                   [  4.,   5.,   6.]],
    /// 
    ///                  [[  7.,   8.,   9.],
    ///                   [  10.,  11.,  12.]],
    /// 
    ///                  [[   1.,   1.,   1.],
    ///                   [  16.,  17.,  18.]]]
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\sequence_mask.cc:L186</summary>
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="data">n-dimensional input array of the form [max_sequence_length, batch_size, other_feature_dims] where n&gt;2</param>
    /// <param name="sequenceLength">vector of sequence lengths of the form [batch_size]</param>
    /// <param name="useSequenceLength">If set to true, this layer takes in an extra input parameter `sequence_length` to specify variable length sequence</param>
    /// <param name="value">The value to be used as a mask.</param>
    /// <param name="axis">The sequence axis. Only values of 0 and 1 are currently supported.</param>
    static member SequenceMask(outputArray : NDArray seq, 
                               data : NDArray, 
                               sequenceLength : NDArray, 
                               [<Optional; DefaultParameterValue(false)>] useSequenceLength : bool, 
                               [<Optional; DefaultParameterValue(0.0)>] value : float, 
                               [<Optional; DefaultParameterValue(0)>] axis : int) =
        let creator = AtomicSymbolCreator.FromName "SequenceMask"
        let names = [|"use_sequence_length"; "value"; "axis"|]
        let vals = [|string useSequenceLength; string value; string axis|]
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg sequenceLength)) then sequenceLength.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <summary>Sets all elements outside the sequence to a constant value.
    /// 
    /// This function takes an n-dimensional input array of the form
    /// [max_sequence_length, batch_size, other_feature_dims] and returns an array of the same shape.
    /// 
    /// Parameter `sequence_length` is used to handle variable-length sequences. `sequence_length`
    /// should be an input array of positive ints of dimension [batch_size].
    /// To use this parameter, set `use_sequence_length` to `True`,
    /// otherwise each example in the batch is assumed to have the max sequence length and
    /// this operator works as the `identity` operator.
    /// 
    /// Example::
    /// 
    ///    x = [[[  1.,   2.,   3.],
    ///          [  4.,   5.,   6.]],
    /// 
    ///         [[  7.,   8.,   9.],
    ///          [ 10.,  11.,  12.]],
    /// 
    ///         [[ 13.,  14.,   15.],
    ///          [ 16.,  17.,   18.]]]
    /// 
    ///    // Batch 1
    ///    B1 = [[  1.,   2.,   3.],
    ///          [  7.,   8.,   9.],
    ///          [ 13.,  14.,  15.]]
    /// 
    ///    // Batch 2
    ///    B2 = [[  4.,   5.,   6.],
    ///          [ 10.,  11.,  12.],
    ///          [ 16.,  17.,  18.]]
    /// 
    ///    // works as identity operator when sequence_length parameter is not used
    ///    SequenceMask(x) = [[[  1.,   2.,   3.],
    ///                        [  4.,   5.,   6.]],
    /// 
    ///                       [[  7.,   8.,   9.],
    ///                        [ 10.,  11.,  12.]],
    /// 
    ///                       [[ 13.,  14.,   15.],
    ///                        [ 16.,  17.,   18.]]]
    /// 
    ///    // sequence_length [1,1] means 1 of each batch will be kept
    ///    // and other rows are masked with default mask value = 0
    ///    SequenceMask(x, sequence_length=[1,1], use_sequence_length=True) =
    ///                 [[[  1.,   2.,   3.],
    ///                   [  4.,   5.,   6.]],
    /// 
    ///                  [[  0.,   0.,   0.],
    ///                   [  0.,   0.,   0.]],
    /// 
    ///                  [[  0.,   0.,   0.],
    ///                   [  0.,   0.,   0.]]]
    /// 
    ///    // sequence_length [2,3] means 2 of batch B1 and 3 of batch B2 will be kept
    ///    // and other rows are masked with value = 1
    ///    SequenceMask(x, sequence_length=[2,3], use_sequence_length=True, value=1) =
    ///                 [[[  1.,   2.,   3.],
    ///                   [  4.,   5.,   6.]],
    /// 
    ///                  [[  7.,   8.,   9.],
    ///                   [  10.,  11.,  12.]],
    /// 
    ///                  [[   1.,   1.,   1.],
    ///                   [  16.,  17.,  18.]]]
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\sequence_mask.cc:L186</summary>
    /// <param name="data">n-dimensional input array of the form [max_sequence_length, batch_size, other_feature_dims] where n&gt;2</param>
    /// <param name="sequenceLength">vector of sequence lengths of the form [batch_size]</param>
    /// <param name="useSequenceLength">If set to true, this layer takes in an extra input parameter `sequence_length` to specify variable length sequence</param>
    /// <param name="value">The value to be used as a mask.</param>
    /// <param name="axis">The sequence axis. Only values of 0 and 1 are currently supported.</param>
    static member SequenceMask([<Optional>] ?data : Symbol, [<Optional>] ?sequenceLength : Symbol, [<Optional>] ?useSequenceLength : bool, [<Optional>] ?value : float, [<Optional>] ?axis : int) =
        SequenceMask(?data = data, ?sequenceLength = sequenceLength, ?useSequenceLength = useSequenceLength, ?value = value, ?axis = axis)

    /// <summary>Splits an array along a particular axis into multiple sub-arrays.
    /// 
    /// .. note:: ``SliceChannel`` is deprecated. Use ``split`` instead.
    /// 
    /// **Note** that `num_outputs` should evenly divide the length of the axis
    /// along which to split the array.
    /// 
    /// Example::
    /// 
    ///    x  = [[[ 1.]
    ///           [ 2.]]
    ///          [[ 3.]
    ///           [ 4.]]
    ///          [[ 5.]
    ///           [ 6.]]]
    ///    x.shape = (3, 2, 1)
    /// 
    ///    y = split(x, axis=1, num_outputs=2) // a list of 2 arrays with shape (3, 1, 1)
    ///    y = [[[ 1.]]
    ///         [[ 3.]]
    ///         [[ 5.]]]
    /// 
    ///        [[[ 2.]]
    ///         [[ 4.]]
    ///         [[ 6.]]]
    /// 
    ///    y[0].shape = (3, 1, 1)
    /// 
    ///    z = split(x, axis=0, num_outputs=3) // a list of 3 arrays with shape (1, 2, 1)
    ///    z = [[[ 1.]
    ///          [ 2.]]]
    /// 
    ///        [[[ 3.]
    ///          [ 4.]]]
    /// 
    ///        [[[ 5.]
    ///          [ 6.]]]
    /// 
    ///    z[0].shape = (1, 2, 1)
    /// 
    /// `squeeze_axis=1` removes the axis with length 1 from the shapes of the output arrays.
    /// **Note** that setting `squeeze_axis` to ``1`` removes axis with length 1 only
    /// along the `axis` which it is split.
    /// Also `squeeze_axis` can be set to true only if ``input.shape[axis] == num_outputs``.
    /// 
    /// Example::
    /// 
    ///    z = split(x, axis=0, num_outputs=3, squeeze_axis=1) // a list of 3 arrays with shape (2, 1)
    ///    z = [[ 1.]
    ///         [ 2.]]
    /// 
    ///        [[ 3.]
    ///         [ 4.]]
    /// 
    ///        [[ 5.]
    ///         [ 6.]]
    ///    z[0].shape = (2 ,1 )
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\slice_channel.cc:L107</summary>
    /// <param name="data">The input</param>
    /// <param name="numOutputs">Number of splits. Note that this should evenly divide the length of the `axis`.</param>
    /// <param name="axis">Axis along which to split.</param>
    /// <param name="squeezeAxis">If true, Removes the axis with length 1 from the shapes of the output arrays. **Note** that setting `squeeze_axis` to ``true`` removes axis with length 1 only along the `axis` which it is split. Also `squeeze_axis` can be set to ``true`` only if ``input.shape[axis] == num_outputs``.</param>
    static member SliceChannel(data : NDArray, numOutputs : int, [<Optional; DefaultParameterValue(1)>] axis : int, [<Optional; DefaultParameterValue(false)>] squeezeAxis : bool) =
        let creator = AtomicSymbolCreator.FromName "SliceChannel"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle|]
                                                 [|"num_outputs"; "axis"; "squeeze_axis"|]
                                                 [|string numOutputs; string axis; string squeezeAxis|]
        (new NDArray(outputs.[0]))
    /// <summary>Splits an array along a particular axis into multiple sub-arrays.
    /// 
    /// .. note:: ``SliceChannel`` is deprecated. Use ``split`` instead.
    /// 
    /// **Note** that `num_outputs` should evenly divide the length of the axis
    /// along which to split the array.
    /// 
    /// Example::
    /// 
    ///    x  = [[[ 1.]
    ///           [ 2.]]
    ///          [[ 3.]
    ///           [ 4.]]
    ///          [[ 5.]
    ///           [ 6.]]]
    ///    x.shape = (3, 2, 1)
    /// 
    ///    y = split(x, axis=1, num_outputs=2) // a list of 2 arrays with shape (3, 1, 1)
    ///    y = [[[ 1.]]
    ///         [[ 3.]]
    ///         [[ 5.]]]
    /// 
    ///        [[[ 2.]]
    ///         [[ 4.]]
    ///         [[ 6.]]]
    /// 
    ///    y[0].shape = (3, 1, 1)
    /// 
    ///    z = split(x, axis=0, num_outputs=3) // a list of 3 arrays with shape (1, 2, 1)
    ///    z = [[[ 1.]
    ///          [ 2.]]]
    /// 
    ///        [[[ 3.]
    ///          [ 4.]]]
    /// 
    ///        [[[ 5.]
    ///          [ 6.]]]
    /// 
    ///    z[0].shape = (1, 2, 1)
    /// 
    /// `squeeze_axis=1` removes the axis with length 1 from the shapes of the output arrays.
    /// **Note** that setting `squeeze_axis` to ``1`` removes axis with length 1 only
    /// along the `axis` which it is split.
    /// Also `squeeze_axis` can be set to true only if ``input.shape[axis] == num_outputs``.
    /// 
    /// Example::
    /// 
    ///    z = split(x, axis=0, num_outputs=3, squeeze_axis=1) // a list of 3 arrays with shape (2, 1)
    ///    z = [[ 1.]
    ///         [ 2.]]
    /// 
    ///        [[ 3.]
    ///         [ 4.]]
    /// 
    ///        [[ 5.]
    ///         [ 6.]]
    ///    z[0].shape = (2 ,1 )
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\slice_channel.cc:L107</summary>
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="data">The input</param>
    /// <param name="numOutputs">Number of splits. Note that this should evenly divide the length of the `axis`.</param>
    /// <param name="axis">Axis along which to split.</param>
    /// <param name="squeezeAxis">If true, Removes the axis with length 1 from the shapes of the output arrays. **Note** that setting `squeeze_axis` to ``true`` removes axis with length 1 only along the `axis` which it is split. Also `squeeze_axis` can be set to ``true`` only if ``input.shape[axis] == num_outputs``.</param>
    static member SliceChannel(outputArray : NDArray seq, data : NDArray, numOutputs : int, [<Optional; DefaultParameterValue(1)>] axis : int, [<Optional; DefaultParameterValue(false)>] squeezeAxis : bool) =
        let creator = AtomicSymbolCreator.FromName "SliceChannel"
        let names = [|"num_outputs"; "axis"; "squeeze_axis"|]
        let vals = [|string numOutputs; string axis; string squeezeAxis|]
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <summary>Splits an array along a particular axis into multiple sub-arrays.
    /// 
    /// .. note:: ``SliceChannel`` is deprecated. Use ``split`` instead.
    /// 
    /// **Note** that `num_outputs` should evenly divide the length of the axis
    /// along which to split the array.
    /// 
    /// Example::
    /// 
    ///    x  = [[[ 1.]
    ///           [ 2.]]
    ///          [[ 3.]
    ///           [ 4.]]
    ///          [[ 5.]
    ///           [ 6.]]]
    ///    x.shape = (3, 2, 1)
    /// 
    ///    y = split(x, axis=1, num_outputs=2) // a list of 2 arrays with shape (3, 1, 1)
    ///    y = [[[ 1.]]
    ///         [[ 3.]]
    ///         [[ 5.]]]
    /// 
    ///        [[[ 2.]]
    ///         [[ 4.]]
    ///         [[ 6.]]]
    /// 
    ///    y[0].shape = (3, 1, 1)
    /// 
    ///    z = split(x, axis=0, num_outputs=3) // a list of 3 arrays with shape (1, 2, 1)
    ///    z = [[[ 1.]
    ///          [ 2.]]]
    /// 
    ///        [[[ 3.]
    ///          [ 4.]]]
    /// 
    ///        [[[ 5.]
    ///          [ 6.]]]
    /// 
    ///    z[0].shape = (1, 2, 1)
    /// 
    /// `squeeze_axis=1` removes the axis with length 1 from the shapes of the output arrays.
    /// **Note** that setting `squeeze_axis` to ``1`` removes axis with length 1 only
    /// along the `axis` which it is split.
    /// Also `squeeze_axis` can be set to true only if ``input.shape[axis] == num_outputs``.
    /// 
    /// Example::
    /// 
    ///    z = split(x, axis=0, num_outputs=3, squeeze_axis=1) // a list of 3 arrays with shape (2, 1)
    ///    z = [[ 1.]
    ///         [ 2.]]
    /// 
    ///        [[ 3.]
    ///         [ 4.]]
    /// 
    ///        [[ 5.]
    ///         [ 6.]]
    ///    z[0].shape = (2 ,1 )
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\slice_channel.cc:L107</summary>
    /// <param name="data">The input</param>
    /// <param name="numOutputs">Number of splits. Note that this should evenly divide the length of the `axis`.</param>
    /// <param name="axis">Axis along which to split.</param>
    /// <param name="squeezeAxis">If true, Removes the axis with length 1 from the shapes of the output arrays. **Note** that setting `squeeze_axis` to ``true`` removes axis with length 1 only along the `axis` which it is split. Also `squeeze_axis` can be set to ``true`` only if ``input.shape[axis] == num_outputs``.</param>
    static member SliceChannel(data : Symbol, numOutputs : int, [<Optional>] ?axis : int, [<Optional>] ?squeezeAxis : bool) =
        SliceChannel(data, numOutputs, ?axis = axis, ?squeezeAxis = squeezeAxis)
    /// <summary>Splits an array along a particular axis into multiple sub-arrays.
    /// 
    /// .. note:: ``SliceChannel`` is deprecated. Use ``split`` instead.
    /// 
    /// **Note** that `num_outputs` should evenly divide the length of the axis
    /// along which to split the array.
    /// 
    /// Example::
    /// 
    ///    x  = [[[ 1.]
    ///           [ 2.]]
    ///          [[ 3.]
    ///           [ 4.]]
    ///          [[ 5.]
    ///           [ 6.]]]
    ///    x.shape = (3, 2, 1)
    /// 
    ///    y = split(x, axis=1, num_outputs=2) // a list of 2 arrays with shape (3, 1, 1)
    ///    y = [[[ 1.]]
    ///         [[ 3.]]
    ///         [[ 5.]]]
    /// 
    ///        [[[ 2.]]
    ///         [[ 4.]]
    ///         [[ 6.]]]
    /// 
    ///    y[0].shape = (3, 1, 1)
    /// 
    ///    z = split(x, axis=0, num_outputs=3) // a list of 3 arrays with shape (1, 2, 1)
    ///    z = [[[ 1.]
    ///          [ 2.]]]
    /// 
    ///        [[[ 3.]
    ///          [ 4.]]]
    /// 
    ///        [[[ 5.]
    ///          [ 6.]]]
    /// 
    ///    z[0].shape = (1, 2, 1)
    /// 
    /// `squeeze_axis=1` removes the axis with length 1 from the shapes of the output arrays.
    /// **Note** that setting `squeeze_axis` to ``1`` removes axis with length 1 only
    /// along the `axis` which it is split.
    /// Also `squeeze_axis` can be set to true only if ``input.shape[axis] == num_outputs``.
    /// 
    /// Example::
    /// 
    ///    z = split(x, axis=0, num_outputs=3, squeeze_axis=1) // a list of 3 arrays with shape (2, 1)
    ///    z = [[ 1.]
    ///         [ 2.]]
    /// 
    ///        [[ 3.]
    ///         [ 4.]]
    /// 
    ///        [[ 5.]
    ///         [ 6.]]
    ///    z[0].shape = (2 ,1 )
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\slice_channel.cc:L107</summary>
    /// <param name="numOutputs">Number of splits. Note that this should evenly divide the length of the `axis`.</param>
    /// <param name="data">The input</param>
    /// <param name="axis">Axis along which to split.</param>
    /// <param name="squeezeAxis">If true, Removes the axis with length 1 from the shapes of the output arrays. **Note** that setting `squeeze_axis` to ``true`` removes axis with length 1 only along the `axis` which it is split. Also `squeeze_axis` can be set to ``true`` only if ``input.shape[axis] == num_outputs``.</param>
    static member SliceChannel(numOutputs : int, [<Optional>] ?data : Symbol, [<Optional>] ?axis : int, [<Optional>] ?squeezeAxis : bool) =
        SliceChannel(numOutputs, ?data = data, ?axis = axis, ?squeezeAxis = squeezeAxis)

    /// <summary>Computes the gradient of cross entropy loss with respect to softmax output.
    /// 
    /// - This operator computes the gradient in two steps.
    ///   The cross entropy loss does not actually need to be computed.
    /// 
    ///   - Applies softmax function on the input array.
    ///   - Computes and returns the gradient of cross entropy loss w.r.t. the softmax output.
    /// 
    /// - The softmax function, cross entropy loss and gradient is given by:
    /// 
    ///   - Softmax Function:
    /// 
    ///     .. math:: \text{softmax}(x)_i = \frac{exp(x_i)}{\sum_j exp(x_j)}
    /// 
    ///   - Cross Entropy Function:
    /// 
    ///     .. math:: \text{CE(label, output)} = - \sum_i \text{label}_i \log(\text{output}_i)
    /// 
    ///   - The gradient of cross entropy loss w.r.t softmax output:
    /// 
    ///     .. math:: \text{gradient} = \text{output} - \text{label}
    /// 
    /// - During forward propagation, the softmax function is computed for each instance in the input array.
    /// 
    ///   For general *N*-D input arrays with shape :math:`(d_1, d_2, ..., d_n)`. The size is
    ///   :math:`s=d_1 \cdot d_2 \cdot \cdot \cdot d_n`. We can use the parameters `preserve_shape`
    ///   and `multi_output` to specify the way to compute softmax:
    /// 
    ///   - By default, `preserve_shape` is ``false``. This operator will reshape the input array
    ///     into a 2-D array with shape :math:`(d_1, \frac{s}{d_1})` and then compute the softmax function for
    ///     each row in the reshaped array, and afterwards reshape it back to the original shape
    ///     :math:`(d_1, d_2, ..., d_n)`.
    ///   - If `preserve_shape` is ``true``, the softmax function will be computed along
    ///     the last axis (`axis` = ``-1``).
    ///   - If `multi_output` is ``true``, the softmax function will be computed along
    ///     the second axis (`axis` = ``1``).
    /// 
    /// - During backward propagation, the gradient of cross-entropy loss w.r.t softmax output array is computed.
    ///   The provided label can be a one-hot label array or a probability label array.
    /// 
    ///   - If the parameter `use_ignore` is ``true``, `ignore_label` can specify input instances
    ///     with a particular label to be ignored during backward propagation. **This has no effect when
    ///     softmax `output` has same shape as `label`**.
    /// 
    ///     Example::
    /// 
    ///       data = [[1,2,3,4],[2,2,2,2],[3,3,3,3],[4,4,4,4]]
    ///       label = [1,0,2,3]
    ///       ignore_label = 1
    ///       SoftmaxOutput(data=data, label = label,\
    ///                     multi_output=true, use_ignore=true,\
    ///                     ignore_label=ignore_label)
    ///       ## forward softmax output
    ///       [[ 0.0320586   0.08714432  0.23688284  0.64391428]
    ///        [ 0.25        0.25        0.25        0.25      ]
    ///        [ 0.25        0.25        0.25        0.25      ]
    ///        [ 0.25        0.25        0.25        0.25      ]]
    ///       ## backward gradient output
    ///       [[ 0.    0.    0.    0.  ]
    ///        [-0.75  0.25  0.25  0.25]
    ///        [ 0.25  0.25 -0.75  0.25]
    ///        [ 0.25  0.25  0.25 -0.75]]
    ///       ## notice that the first row is all 0 because label[0] is 1, which is equal to ignore_label.
    /// 
    ///   - The parameter `grad_scale` can be used to rescale the gradient, which is often used to
    ///     give each loss function different weights.
    /// 
    ///   - This operator also supports various ways to normalize the gradient by `normalization`,
    ///     The `normalization` is applied if softmax output has different shape than the labels.
    ///     The `normalization` mode can be set to the followings:
    /// 
    ///     - ``&#39;null&#39;``: do nothing.
    ///     - ``&#39;batch&#39;``: divide the gradient by the batch size.
    ///     - ``&#39;valid&#39;``: divide the gradient by the number of instances which are not ignored.
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\softmax_output.cc:L231</summary>
    /// <param name="data">Input array.</param>
    /// <param name="label">Ground truth label.</param>
    /// <param name="gradScale">Scales the gradient by a float factor.</param>
    /// <param name="ignoreLabel">The instances whose `labels` == `ignore_label` will be ignored during backward, if `use_ignore` is set to ``true``).</param>
    /// <param name="multiOutput">If set to ``true``, the softmax function will be computed along axis ``1``. This is applied when the shape of input array differs from the shape of label array.</param>
    /// <param name="useIgnore">If set to ``true``, the `ignore_label` value will not contribute to the backward gradient.</param>
    /// <param name="preserveShape">If set to ``true``, the softmax function will be computed along the last axis (``-1``).</param>
    /// <param name="normalization">Normalizes the gradient.</param>
    /// <param name="outGrad">Multiplies gradient with output gradient element-wise.</param>
    /// <param name="smoothAlpha">Constant for computing a label smoothed version of cross-entropyfor the backwards pass.  This constant gets subtracted from theone-hot encoding of the gold label and distributed uniformly toall other labels.</param>
    static member SoftmaxOutput(data : NDArray, 
                                label : NDArray, 
                                [<Optional; DefaultParameterValue(1.0)>] gradScale : float, 
                                [<Optional; DefaultParameterValue(-1.0)>] ignoreLabel : float, 
                                [<Optional; DefaultParameterValue(false)>] multiOutput : bool, 
                                [<Optional; DefaultParameterValue(false)>] useIgnore : bool, 
                                [<Optional; DefaultParameterValue(false)>] preserveShape : bool, 
                                [<Optional>] normalization : Normalization, 
                                [<Optional; DefaultParameterValue(false)>] outGrad : bool, 
                                [<Optional; DefaultParameterValue(0.0)>] smoothAlpha : float) =
        let creator = AtomicSymbolCreator.FromName "SoftmaxOutput"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg label)) then label.UnsafeHandle|]
                                                 [|"grad_scale"; "ignore_label"; "multi_output"; "use_ignore"; "preserve_shape"; "normalization"; "out_grad"; "smooth_alpha"|]
                                                 [|string gradScale; string ignoreLabel; string multiOutput; string useIgnore; string preserveShape; (if isNull (normalization :> obj) then "null" else string normalization); string outGrad; string smoothAlpha|]
        (new NDArray(outputs.[0]))
    /// <summary>Computes the gradient of cross entropy loss with respect to softmax output.
    /// 
    /// - This operator computes the gradient in two steps.
    ///   The cross entropy loss does not actually need to be computed.
    /// 
    ///   - Applies softmax function on the input array.
    ///   - Computes and returns the gradient of cross entropy loss w.r.t. the softmax output.
    /// 
    /// - The softmax function, cross entropy loss and gradient is given by:
    /// 
    ///   - Softmax Function:
    /// 
    ///     .. math:: \text{softmax}(x)_i = \frac{exp(x_i)}{\sum_j exp(x_j)}
    /// 
    ///   - Cross Entropy Function:
    /// 
    ///     .. math:: \text{CE(label, output)} = - \sum_i \text{label}_i \log(\text{output}_i)
    /// 
    ///   - The gradient of cross entropy loss w.r.t softmax output:
    /// 
    ///     .. math:: \text{gradient} = \text{output} - \text{label}
    /// 
    /// - During forward propagation, the softmax function is computed for each instance in the input array.
    /// 
    ///   For general *N*-D input arrays with shape :math:`(d_1, d_2, ..., d_n)`. The size is
    ///   :math:`s=d_1 \cdot d_2 \cdot \cdot \cdot d_n`. We can use the parameters `preserve_shape`
    ///   and `multi_output` to specify the way to compute softmax:
    /// 
    ///   - By default, `preserve_shape` is ``false``. This operator will reshape the input array
    ///     into a 2-D array with shape :math:`(d_1, \frac{s}{d_1})` and then compute the softmax function for
    ///     each row in the reshaped array, and afterwards reshape it back to the original shape
    ///     :math:`(d_1, d_2, ..., d_n)`.
    ///   - If `preserve_shape` is ``true``, the softmax function will be computed along
    ///     the last axis (`axis` = ``-1``).
    ///   - If `multi_output` is ``true``, the softmax function will be computed along
    ///     the second axis (`axis` = ``1``).
    /// 
    /// - During backward propagation, the gradient of cross-entropy loss w.r.t softmax output array is computed.
    ///   The provided label can be a one-hot label array or a probability label array.
    /// 
    ///   - If the parameter `use_ignore` is ``true``, `ignore_label` can specify input instances
    ///     with a particular label to be ignored during backward propagation. **This has no effect when
    ///     softmax `output` has same shape as `label`**.
    /// 
    ///     Example::
    /// 
    ///       data = [[1,2,3,4],[2,2,2,2],[3,3,3,3],[4,4,4,4]]
    ///       label = [1,0,2,3]
    ///       ignore_label = 1
    ///       SoftmaxOutput(data=data, label = label,\
    ///                     multi_output=true, use_ignore=true,\
    ///                     ignore_label=ignore_label)
    ///       ## forward softmax output
    ///       [[ 0.0320586   0.08714432  0.23688284  0.64391428]
    ///        [ 0.25        0.25        0.25        0.25      ]
    ///        [ 0.25        0.25        0.25        0.25      ]
    ///        [ 0.25        0.25        0.25        0.25      ]]
    ///       ## backward gradient output
    ///       [[ 0.    0.    0.    0.  ]
    ///        [-0.75  0.25  0.25  0.25]
    ///        [ 0.25  0.25 -0.75  0.25]
    ///        [ 0.25  0.25  0.25 -0.75]]
    ///       ## notice that the first row is all 0 because label[0] is 1, which is equal to ignore_label.
    /// 
    ///   - The parameter `grad_scale` can be used to rescale the gradient, which is often used to
    ///     give each loss function different weights.
    /// 
    ///   - This operator also supports various ways to normalize the gradient by `normalization`,
    ///     The `normalization` is applied if softmax output has different shape than the labels.
    ///     The `normalization` mode can be set to the followings:
    /// 
    ///     - ``&#39;null&#39;``: do nothing.
    ///     - ``&#39;batch&#39;``: divide the gradient by the batch size.
    ///     - ``&#39;valid&#39;``: divide the gradient by the number of instances which are not ignored.
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\softmax_output.cc:L231</summary>
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="data">Input array.</param>
    /// <param name="label">Ground truth label.</param>
    /// <param name="gradScale">Scales the gradient by a float factor.</param>
    /// <param name="ignoreLabel">The instances whose `labels` == `ignore_label` will be ignored during backward, if `use_ignore` is set to ``true``).</param>
    /// <param name="multiOutput">If set to ``true``, the softmax function will be computed along axis ``1``. This is applied when the shape of input array differs from the shape of label array.</param>
    /// <param name="useIgnore">If set to ``true``, the `ignore_label` value will not contribute to the backward gradient.</param>
    /// <param name="preserveShape">If set to ``true``, the softmax function will be computed along the last axis (``-1``).</param>
    /// <param name="normalization">Normalizes the gradient.</param>
    /// <param name="outGrad">Multiplies gradient with output gradient element-wise.</param>
    /// <param name="smoothAlpha">Constant for computing a label smoothed version of cross-entropyfor the backwards pass.  This constant gets subtracted from theone-hot encoding of the gold label and distributed uniformly toall other labels.</param>
    static member SoftmaxOutput(outputArray : NDArray seq, 
                                data : NDArray, 
                                label : NDArray, 
                                [<Optional; DefaultParameterValue(1.0)>] gradScale : float, 
                                [<Optional; DefaultParameterValue(-1.0)>] ignoreLabel : float, 
                                [<Optional; DefaultParameterValue(false)>] multiOutput : bool, 
                                [<Optional; DefaultParameterValue(false)>] useIgnore : bool, 
                                [<Optional; DefaultParameterValue(false)>] preserveShape : bool, 
                                [<Optional>] normalization : Normalization, 
                                [<Optional; DefaultParameterValue(false)>] outGrad : bool, 
                                [<Optional; DefaultParameterValue(0.0)>] smoothAlpha : float) =
        let creator = AtomicSymbolCreator.FromName "SoftmaxOutput"
        let names = [|"grad_scale"; "ignore_label"; "multi_output"; "use_ignore"; "preserve_shape"; "normalization"; "out_grad"; "smooth_alpha"|]
        let vals = [|string gradScale; string ignoreLabel; string multiOutput; string useIgnore; string preserveShape; (if isNull (normalization :> obj) then "null" else string normalization); string outGrad; string smoothAlpha|]
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg label)) then label.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <summary>Computes the gradient of cross entropy loss with respect to softmax output.
    /// 
    /// - This operator computes the gradient in two steps.
    ///   The cross entropy loss does not actually need to be computed.
    /// 
    ///   - Applies softmax function on the input array.
    ///   - Computes and returns the gradient of cross entropy loss w.r.t. the softmax output.
    /// 
    /// - The softmax function, cross entropy loss and gradient is given by:
    /// 
    ///   - Softmax Function:
    /// 
    ///     .. math:: \text{softmax}(x)_i = \frac{exp(x_i)}{\sum_j exp(x_j)}
    /// 
    ///   - Cross Entropy Function:
    /// 
    ///     .. math:: \text{CE(label, output)} = - \sum_i \text{label}_i \log(\text{output}_i)
    /// 
    ///   - The gradient of cross entropy loss w.r.t softmax output:
    /// 
    ///     .. math:: \text{gradient} = \text{output} - \text{label}
    /// 
    /// - During forward propagation, the softmax function is computed for each instance in the input array.
    /// 
    ///   For general *N*-D input arrays with shape :math:`(d_1, d_2, ..., d_n)`. The size is
    ///   :math:`s=d_1 \cdot d_2 \cdot \cdot \cdot d_n`. We can use the parameters `preserve_shape`
    ///   and `multi_output` to specify the way to compute softmax:
    /// 
    ///   - By default, `preserve_shape` is ``false``. This operator will reshape the input array
    ///     into a 2-D array with shape :math:`(d_1, \frac{s}{d_1})` and then compute the softmax function for
    ///     each row in the reshaped array, and afterwards reshape it back to the original shape
    ///     :math:`(d_1, d_2, ..., d_n)`.
    ///   - If `preserve_shape` is ``true``, the softmax function will be computed along
    ///     the last axis (`axis` = ``-1``).
    ///   - If `multi_output` is ``true``, the softmax function will be computed along
    ///     the second axis (`axis` = ``1``).
    /// 
    /// - During backward propagation, the gradient of cross-entropy loss w.r.t softmax output array is computed.
    ///   The provided label can be a one-hot label array or a probability label array.
    /// 
    ///   - If the parameter `use_ignore` is ``true``, `ignore_label` can specify input instances
    ///     with a particular label to be ignored during backward propagation. **This has no effect when
    ///     softmax `output` has same shape as `label`**.
    /// 
    ///     Example::
    /// 
    ///       data = [[1,2,3,4],[2,2,2,2],[3,3,3,3],[4,4,4,4]]
    ///       label = [1,0,2,3]
    ///       ignore_label = 1
    ///       SoftmaxOutput(data=data, label = label,\
    ///                     multi_output=true, use_ignore=true,\
    ///                     ignore_label=ignore_label)
    ///       ## forward softmax output
    ///       [[ 0.0320586   0.08714432  0.23688284  0.64391428]
    ///        [ 0.25        0.25        0.25        0.25      ]
    ///        [ 0.25        0.25        0.25        0.25      ]
    ///        [ 0.25        0.25        0.25        0.25      ]]
    ///       ## backward gradient output
    ///       [[ 0.    0.    0.    0.  ]
    ///        [-0.75  0.25  0.25  0.25]
    ///        [ 0.25  0.25 -0.75  0.25]
    ///        [ 0.25  0.25  0.25 -0.75]]
    ///       ## notice that the first row is all 0 because label[0] is 1, which is equal to ignore_label.
    /// 
    ///   - The parameter `grad_scale` can be used to rescale the gradient, which is often used to
    ///     give each loss function different weights.
    /// 
    ///   - This operator also supports various ways to normalize the gradient by `normalization`,
    ///     The `normalization` is applied if softmax output has different shape than the labels.
    ///     The `normalization` mode can be set to the followings:
    /// 
    ///     - ``&#39;null&#39;``: do nothing.
    ///     - ``&#39;batch&#39;``: divide the gradient by the batch size.
    ///     - ``&#39;valid&#39;``: divide the gradient by the number of instances which are not ignored.
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\softmax_output.cc:L231</summary>
    /// <param name="data">Input array.</param>
    /// <param name="label">Ground truth label.</param>
    /// <param name="gradScale">Scales the gradient by a float factor.</param>
    /// <param name="ignoreLabel">The instances whose `labels` == `ignore_label` will be ignored during backward, if `use_ignore` is set to ``true``).</param>
    /// <param name="multiOutput">If set to ``true``, the softmax function will be computed along axis ``1``. This is applied when the shape of input array differs from the shape of label array.</param>
    /// <param name="useIgnore">If set to ``true``, the `ignore_label` value will not contribute to the backward gradient.</param>
    /// <param name="preserveShape">If set to ``true``, the softmax function will be computed along the last axis (``-1``).</param>
    /// <param name="normalization">Normalizes the gradient.</param>
    /// <param name="outGrad">Multiplies gradient with output gradient element-wise.</param>
    /// <param name="smoothAlpha">Constant for computing a label smoothed version of cross-entropyfor the backwards pass.  This constant gets subtracted from theone-hot encoding of the gold label and distributed uniformly toall other labels.</param>
    static member SoftmaxOutput([<Optional>] ?data : Symbol, [<Optional>] ?label : Symbol, [<Optional>] ?gradScale : float, [<Optional>] ?ignoreLabel : float, [<Optional>] ?multiOutput : bool, [<Optional>] ?useIgnore : bool, [<Optional>] ?preserveShape : bool, [<Optional>] ?normalization : Normalization, [<Optional>] ?outGrad : bool, [<Optional>] ?smoothAlpha : float) =
        SoftmaxOutput(?data = data, ?label = label, ?gradScale = gradScale, ?ignoreLabel = ignoreLabel, ?multiOutput = multiOutput, ?useIgnore = useIgnore, ?preserveShape = preserveShape, ?normalization = normalization, ?outGrad = outGrad, ?smoothAlpha = smoothAlpha)


    /// <summary>_sg_mkldnn_conv
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\subgraph\mkldnn\mkldnn_conv.cc:L773</summary>
    static member SgMkldnnConvNDArray() =
        let creator = AtomicSymbolCreator.FromName "_sg_mkldnn_conv"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 Array.empty
                                                 Array.empty
                                                 Array.empty
        outputs |> Array.map (fun h -> new NDArray(h))
    /// <summary>_sg_mkldnn_conv
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\subgraph\mkldnn\mkldnn_conv.cc:L773</summary>
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    static member SgMkldnnConv(outputArray : NDArray seq) =
        let creator = AtomicSymbolCreator.FromName "_sg_mkldnn_conv"
        let names = Array.empty
        let vals = Array.empty
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     Array.empty
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <summary>_sg_mkldnn_conv
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\subgraph\mkldnn\mkldnn_conv.cc:L773</summary>
    static member SgMkldnnConv() =
        SgMkldnnConv()

    /// <summary>_sg_mkldnn_fully_connected
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\subgraph\mkldnn\mkldnn_fc.cc:L452</summary>
    static member SgMkldnnFullyConnectedNDArray() =
        let creator = AtomicSymbolCreator.FromName "_sg_mkldnn_fully_connected"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 Array.empty
                                                 Array.empty
                                                 Array.empty
        outputs |> Array.map (fun h -> new NDArray(h))
    /// <summary>_sg_mkldnn_fully_connected
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\subgraph\mkldnn\mkldnn_fc.cc:L452</summary>
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    static member SgMkldnnFullyConnected(outputArray : NDArray seq) =
        let creator = AtomicSymbolCreator.FromName "_sg_mkldnn_fully_connected"
        let names = Array.empty
        let vals = Array.empty
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     Array.empty
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <summary>_sg_mkldnn_fully_connected
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\subgraph\mkldnn\mkldnn_fc.cc:L452</summary>
    static member SgMkldnnFullyConnected() =
        SgMkldnnFullyConnected()

    /// <summary>Interchanges two axes of an array.
    /// 
    /// Examples::
    /// 
    ///   x = [[1, 2, 3]])
    ///   swapaxes(x, 0, 1) = [[ 1],
    ///                        [ 2],
    ///                        [ 3]]
    /// 
    ///   x = [[[ 0, 1],
    ///         [ 2, 3]],
    ///        [[ 4, 5],
    ///         [ 6, 7]]]  // (2,2,2) array
    /// 
    ///  swapaxes(x, 0, 2) = [[[ 0, 4],
    ///                        [ 2, 6]],
    ///                       [[ 1, 5],
    ///                        [ 3, 7]]]
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\swapaxis.cc:L70</summary>
    /// <param name="data">Input array.</param>
    /// <param name="dim1">the first axis to be swapped.</param>
    /// <param name="dim2">the second axis to be swapped.</param>
    static member SwapAxis(data : NDArray, [<Optional; DefaultParameterValue(0)>] dim1 : int, [<Optional; DefaultParameterValue(0)>] dim2 : int) =
        let creator = AtomicSymbolCreator.FromName "SwapAxis"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle|]
                                                 [|"dim1"; "dim2"|]
                                                 [|string dim1; string dim2|]
        (new NDArray(outputs.[0]))
    /// <summary>Interchanges two axes of an array.
    /// 
    /// Examples::
    /// 
    ///   x = [[1, 2, 3]])
    ///   swapaxes(x, 0, 1) = [[ 1],
    ///                        [ 2],
    ///                        [ 3]]
    /// 
    ///   x = [[[ 0, 1],
    ///         [ 2, 3]],
    ///        [[ 4, 5],
    ///         [ 6, 7]]]  // (2,2,2) array
    /// 
    ///  swapaxes(x, 0, 2) = [[[ 0, 4],
    ///                        [ 2, 6]],
    ///                       [[ 1, 5],
    ///                        [ 3, 7]]]
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\swapaxis.cc:L70</summary>
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="data">Input array.</param>
    /// <param name="dim1">the first axis to be swapped.</param>
    /// <param name="dim2">the second axis to be swapped.</param>
    static member SwapAxis(outputArray : NDArray seq, data : NDArray, [<Optional; DefaultParameterValue(0)>] dim1 : int, [<Optional; DefaultParameterValue(0)>] dim2 : int) =
        let creator = AtomicSymbolCreator.FromName "SwapAxis"
        let names = [|"dim1"; "dim2"|]
        let vals = [|string dim1; string dim2|]
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <summary>Interchanges two axes of an array.
    /// 
    /// Examples::
    /// 
    ///   x = [[1, 2, 3]])
    ///   swapaxes(x, 0, 1) = [[ 1],
    ///                        [ 2],
    ///                        [ 3]]
    /// 
    ///   x = [[[ 0, 1],
    ///         [ 2, 3]],
    ///        [[ 4, 5],
    ///         [ 6, 7]]]  // (2,2,2) array
    /// 
    ///  swapaxes(x, 0, 2) = [[[ 0, 4],
    ///                        [ 2, 6]],
    ///                       [[ 1, 5],
    ///                        [ 3, 7]]]
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\swapaxis.cc:L70</summary>
    /// <param name="data">Input array.</param>
    /// <param name="dim1">the first axis to be swapped.</param>
    /// <param name="dim2">the second axis to be swapped.</param>
    static member SwapAxis([<Optional>] ?data : Symbol, [<Optional>] ?dim1 : int, [<Optional>] ?dim2 : int) =
        SwapAxis(?data = data, ?dim1 = dim1, ?dim2 = dim2)

    /// <summary>Cast function between low precision float/FP32 used by AMP.
    /// 
    /// It casts only between low precision float/FP32 and does not do anything for other types.
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\amp_cast.cc:L37</summary>
    /// <param name="data">The input.</param>
    /// <param name="dtype">Output data type.</param>
    static member AmpCast(data : NDArray, dtype : DataType) =
        let creator = AtomicSymbolCreator.FromName "amp_cast"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle|]
                                                 [|"dtype"|]
                                                 [|string dtype|]
        outputs |> Array.map (fun h -> new NDArray(h))
    /// <summary>Cast function between low precision float/FP32 used by AMP.
    /// 
    /// It casts only between low precision float/FP32 and does not do anything for other types.
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\amp_cast.cc:L37</summary>
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="data">The input.</param>
    /// <param name="dtype">Output data type.</param>
    static member AmpCast(outputArray : NDArray seq, data : NDArray, dtype : DataType) =
        let creator = AtomicSymbolCreator.FromName "amp_cast"
        let names = [|"dtype"|]
        let vals = [|string dtype|]
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <summary>Cast function between low precision float/FP32 used by AMP.
    /// 
    /// It casts only between low precision float/FP32 and does not do anything for other types.
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\amp_cast.cc:L37</summary>
    /// <param name="data">The input.</param>
    /// <param name="dtype">Output data type.</param>
    static member AmpCast(data : Symbol, dtype : DataType) =
        AmpCast(data, dtype)
    /// <summary>Cast function between low precision float/FP32 used by AMP.
    /// 
    /// It casts only between low precision float/FP32 and does not do anything for other types.
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\amp_cast.cc:L37</summary>
    /// <param name="dtype">Output data type.</param>
    /// <param name="data">The input.</param>
    static member AmpCast(dtype : DataType, [<Optional>] ?data : Symbol) =
        AmpCast(dtype, ?data = data)


    /// <summary>Cast function used by AMP, that casts its inputs to the common widest type.
    /// 
    /// It casts only between low precision float/FP32 and does not do anything for other types.
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\amp_cast.cc:L71</summary>
    /// <param name="data">Weights</param>
    /// <param name="numOutputs">Number of input/output pairs to be casted to the widest type.</param>
    /// <param name="castNarrow">Whether to cast to the narrowest type</param>
    static member AmpMulticast([<ParamArray>] data : NDArray[], numOutputs : int, [<Optional; DefaultParameterValue(false)>] castNarrow : bool) =
        let creator = AtomicSymbolCreator.FromName "amp_multicast"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 (data |> Array.map (fun x -> x.UnsafeHandle))
                                                 [|"num_outputs"; "cast_narrow"|]
                                                 [|string numOutputs; string castNarrow|]
        outputs |> Array.map (fun h -> new NDArray(h))
    /// <summary>Cast function used by AMP, that casts its inputs to the common widest type.
    /// 
    /// It casts only between low precision float/FP32 and does not do anything for other types.
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\amp_cast.cc:L71</summary>
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="data">Weights</param>
    /// <param name="numOutputs">Number of input/output pairs to be casted to the widest type.</param>
    /// <param name="castNarrow">Whether to cast to the narrowest type</param>
    static member AmpMulticast(outputArray : NDArray seq, [<ParamArray>] data : NDArray[], numOutputs : int, [<Optional; DefaultParameterValue(false)>] castNarrow : bool) =
        let creator = AtomicSymbolCreator.FromName "amp_multicast"
        let names = [|"num_outputs"; "cast_narrow"|]
        let vals = [|string numOutputs; string castNarrow|]
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     (data |> Array.map (fun x -> x.UnsafeHandle))
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <summary>Cast function used by AMP, that casts its inputs to the common widest type.
    /// 
    /// It casts only between low precision float/FP32 and does not do anything for other types.
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\amp_cast.cc:L71</summary>
    /// <param name="data">Weights</param>
    /// <param name="numOutputs">Number of input/output pairs to be casted to the widest type.</param>
    /// <param name="castNarrow">Whether to cast to the narrowest type</param>
    static member AmpMulticast(data : Symbol seq, numOutputs : int, [<Optional>] ?castNarrow : bool) =
        AmpMulticast(data, numOutputs, ?castNarrow = castNarrow)
    /// <summary>Cast function used by AMP, that casts its inputs to the common widest type.
    /// 
    /// It casts only between low precision float/FP32 and does not do anything for other types.
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\amp_cast.cc:L71</summary>
    /// <param name="numOutputs">Number of input/output pairs to be casted to the widest type.</param>
    /// <param name="data">Weights</param>
    /// <param name="castNarrow">Whether to cast to the narrowest type</param>
    static member AmpMulticast(numOutputs : int, [<Optional>] ?data : Symbol seq, [<Optional>] ?castNarrow : bool) =
        AmpMulticast(numOutputs, ?data = data, ?castNarrow = castNarrow)


    /// <summary>Computes the max of array elements over given axes.
    /// 
    /// Defined in c:\jenkins\workspace\mxnet\mxnet\src\operator\tensor\./broadcast_reduce_op.h:L32</summary>
    /// <param name="data">The input</param>
    /// <param name="axis">The axis or axes along which to perform the reduction.
    /// 
    ///       The default, `axis=()`, will compute over all elements into a
    ///       scalar array with shape `(1,)`.
    /// 
    ///       If `axis` is int, a reduction is performed on a particular axis.
    /// 
    ///       If `axis` is a tuple of ints, a reduction is performed on all the axes
    ///       specified in the tuple.
    /// 
    ///       If `exclude` is true, reduction will be performed on the axes that are
    ///       NOT in axis instead.
    /// 
    ///       Negative values means indexing from right to left.</param>
    /// <param name="keepdims">If this is set to `True`, the reduced axes are left in the result as dimension with size one.</param>
    /// <param name="exclude">Whether to perform reduction on axis that are NOT in axis instead.</param>
    static member Max(data : NDArray, [<Optional>] ?axis : int seq, [<Optional>] ?keepdims : bool, [<Optional>] ?exclude : bool) =
        let creator = AtomicSymbolCreator.FromName "max"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle|]
                                                 [|"axis"; "keepdims"; "exclude"|]
                                                 [|(match axis with None -> "None" | Some axis -> (axis |> Seq.map string |> String.concat ", " |> sprintf "[%s]")); (match keepdims with None -> "false" | Some keepdims -> string keepdims); (match exclude with None -> "false" | Some exclude -> string exclude)|]
        (new NDArray(outputs.[0]))
    /// <summary>Computes the max of array elements over given axes.
    /// 
    /// Defined in c:\jenkins\workspace\mxnet\mxnet\src\operator\tensor\./broadcast_reduce_op.h:L32</summary>
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="data">The input</param>
    /// <param name="axis">The axis or axes along which to perform the reduction.
    /// 
    ///       The default, `axis=()`, will compute over all elements into a
    ///       scalar array with shape `(1,)`.
    /// 
    ///       If `axis` is int, a reduction is performed on a particular axis.
    /// 
    ///       If `axis` is a tuple of ints, a reduction is performed on all the axes
    ///       specified in the tuple.
    /// 
    ///       If `exclude` is true, reduction will be performed on the axes that are
    ///       NOT in axis instead.
    /// 
    ///       Negative values means indexing from right to left.</param>
    /// <param name="keepdims">If this is set to `True`, the reduced axes are left in the result as dimension with size one.</param>
    /// <param name="exclude">Whether to perform reduction on axis that are NOT in axis instead.</param>
    static member Max(outputArray : NDArray seq, data : NDArray, [<Optional>] ?axis : int seq, [<Optional>] ?keepdims : bool, [<Optional>] ?exclude : bool) =
        let creator = AtomicSymbolCreator.FromName "max"
        let names = [|"axis"; "keepdims"; "exclude"|]
        let vals = [|(match axis with None -> "None" | Some axis -> (axis |> Seq.map string |> String.concat ", " |> sprintf "[%s]")); (match keepdims with None -> "false" | Some keepdims -> string keepdims); (match exclude with None -> "false" | Some exclude -> string exclude)|]
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <summary>Computes the max of array elements over given axes.
    /// 
    /// Defined in c:\jenkins\workspace\mxnet\mxnet\src\operator\tensor\./broadcast_reduce_op.h:L32</summary>
    /// <param name="data">The input</param>
    /// <param name="axis">The axis or axes along which to perform the reduction.
    /// 
    ///       The default, `axis=()`, will compute over all elements into a
    ///       scalar array with shape `(1,)`.
    /// 
    ///       If `axis` is int, a reduction is performed on a particular axis.
    /// 
    ///       If `axis` is a tuple of ints, a reduction is performed on all the axes
    ///       specified in the tuple.
    /// 
    ///       If `exclude` is true, reduction will be performed on the axes that are
    ///       NOT in axis instead.
    /// 
    ///       Negative values means indexing from right to left.</param>
    /// <param name="keepdims">If this is set to `True`, the reduced axes are left in the result as dimension with size one.</param>
    /// <param name="exclude">Whether to perform reduction on axis that are NOT in axis instead.</param>
    static member Max([<Optional>] ?data : Symbol, [<Optional>] ?axis : int seq, [<Optional>] ?keepdims : bool, [<Optional>] ?exclude : bool) =
        Max(?data = data, ?axis = axis, ?keepdims = keepdims, ?exclude = exclude)


    /// <summary>Computes the min of array elements over given axes.
    /// 
    /// Defined in c:\jenkins\workspace\mxnet\mxnet\src\operator\tensor\./broadcast_reduce_op.h:L47</summary>
    /// <param name="data">The input</param>
    /// <param name="axis">The axis or axes along which to perform the reduction.
    /// 
    ///       The default, `axis=()`, will compute over all elements into a
    ///       scalar array with shape `(1,)`.
    /// 
    ///       If `axis` is int, a reduction is performed on a particular axis.
    /// 
    ///       If `axis` is a tuple of ints, a reduction is performed on all the axes
    ///       specified in the tuple.
    /// 
    ///       If `exclude` is true, reduction will be performed on the axes that are
    ///       NOT in axis instead.
    /// 
    ///       Negative values means indexing from right to left.</param>
    /// <param name="keepdims">If this is set to `True`, the reduced axes are left in the result as dimension with size one.</param>
    /// <param name="exclude">Whether to perform reduction on axis that are NOT in axis instead.</param>
    static member Min(data : NDArray, [<Optional>] ?axis : int seq, [<Optional>] ?keepdims : bool, [<Optional>] ?exclude : bool) =
        let creator = AtomicSymbolCreator.FromName "min"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle|]
                                                 [|"axis"; "keepdims"; "exclude"|]
                                                 [|(match axis with None -> "None" | Some axis -> (axis |> Seq.map string |> String.concat ", " |> sprintf "[%s]")); (match keepdims with None -> "false" | Some keepdims -> string keepdims); (match exclude with None -> "false" | Some exclude -> string exclude)|]
        (new NDArray(outputs.[0]))
    /// <summary>Computes the min of array elements over given axes.
    /// 
    /// Defined in c:\jenkins\workspace\mxnet\mxnet\src\operator\tensor\./broadcast_reduce_op.h:L47</summary>
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="data">The input</param>
    /// <param name="axis">The axis or axes along which to perform the reduction.
    /// 
    ///       The default, `axis=()`, will compute over all elements into a
    ///       scalar array with shape `(1,)`.
    /// 
    ///       If `axis` is int, a reduction is performed on a particular axis.
    /// 
    ///       If `axis` is a tuple of ints, a reduction is performed on all the axes
    ///       specified in the tuple.
    /// 
    ///       If `exclude` is true, reduction will be performed on the axes that are
    ///       NOT in axis instead.
    /// 
    ///       Negative values means indexing from right to left.</param>
    /// <param name="keepdims">If this is set to `True`, the reduced axes are left in the result as dimension with size one.</param>
    /// <param name="exclude">Whether to perform reduction on axis that are NOT in axis instead.</param>
    static member Min(outputArray : NDArray seq, data : NDArray, [<Optional>] ?axis : int seq, [<Optional>] ?keepdims : bool, [<Optional>] ?exclude : bool) =
        let creator = AtomicSymbolCreator.FromName "min"
        let names = [|"axis"; "keepdims"; "exclude"|]
        let vals = [|(match axis with None -> "None" | Some axis -> (axis |> Seq.map string |> String.concat ", " |> sprintf "[%s]")); (match keepdims with None -> "false" | Some keepdims -> string keepdims); (match exclude with None -> "false" | Some exclude -> string exclude)|]
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <summary>Computes the min of array elements over given axes.
    /// 
    /// Defined in c:\jenkins\workspace\mxnet\mxnet\src\operator\tensor\./broadcast_reduce_op.h:L47</summary>
    /// <param name="data">The input</param>
    /// <param name="axis">The axis or axes along which to perform the reduction.
    /// 
    ///       The default, `axis=()`, will compute over all elements into a
    ///       scalar array with shape `(1,)`.
    /// 
    ///       If `axis` is int, a reduction is performed on a particular axis.
    /// 
    ///       If `axis` is a tuple of ints, a reduction is performed on all the axes
    ///       specified in the tuple.
    /// 
    ///       If `exclude` is true, reduction will be performed on the axes that are
    ///       NOT in axis instead.
    /// 
    ///       Negative values means indexing from right to left.</param>
    /// <param name="keepdims">If this is set to `True`, the reduced axes are left in the result as dimension with size one.</param>
    /// <param name="exclude">Whether to perform reduction on axis that are NOT in axis instead.</param>
    static member Min([<Optional>] ?data : Symbol, [<Optional>] ?axis : int seq, [<Optional>] ?keepdims : bool, [<Optional>] ?exclude : bool) =
        Min(?data = data, ?axis = axis, ?keepdims = keepdims, ?exclude = exclude)


    /// <summary>Computes the norm on an NDArray.
    /// 
    /// This operator computes the norm on an NDArray with the specified axis, depending
    /// on the value of the ord parameter. By default, it computes the L2 norm on the entire
    /// array. Currently only ord=2 supports sparse ndarrays.
    /// 
    /// Examples::
    /// 
    ///   x = [[[1, 2],
    ///         [3, 4]],
    ///        [[2, 2],
    ///         [5, 6]]]
    /// 
    ///   norm(x, ord=2, axis=1) = [[3.1622777 4.472136 ]
    ///                             [5.3851647 6.3245554]]
    /// 
    ///   norm(x, ord=1, axis=1) = [[4., 6.],
    ///                             [7., 8.]]
    /// 
    ///   rsp = x.cast_storage(&#39;row_sparse&#39;)
    /// 
    ///   norm(rsp) = [5.47722578]
    /// 
    ///   csr = x.cast_storage(&#39;csr&#39;)
    /// 
    ///   norm(csr) = [5.47722578]
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\broadcast_reduce_norm_value.cc:L89</summary>
    /// <param name="data">The input</param>
    /// <param name="ord">Order of the norm. Currently ord=1 and ord=2 is supported.</param>
    /// <param name="axis">The axis or axes along which to perform the reduction.
    ///       The default, `axis=()`, will compute over all elements into a
    ///       scalar array with shape `(1,)`.
    ///       If `axis` is int, a reduction is performed on a particular axis.
    ///       If `axis` is a 2-tuple, it specifies the axes that hold 2-D matrices,
    ///       and the matrix norms of these matrices are computed.</param>
    /// <param name="outDtype">The data type of the output.</param>
    /// <param name="keepdims">If this is set to `True`, the reduced axis is left in the result as dimension with size one.</param>
    static member Norm(data : NDArray, 
                       [<Optional>] ?ord : int, 
                       [<Optional>] ?axis : int seq, 
                       [<Optional>] ?outDtype : DataType, 
                       [<Optional>] ?keepdims : bool) =
        let creator = AtomicSymbolCreator.FromName "norm"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle|]
                                                 [|"ord"; "axis"; "out_dtype"; "keepdims"|]
                                                 [|(match ord with None -> "2" | Some ord -> string ord); (match axis with None -> "None" | Some axis -> (axis |> Seq.map string |> String.concat ", " |> sprintf "[%s]")); (match outDtype with None -> "None" | Some outDtype -> string outDtype); (match keepdims with None -> "false" | Some keepdims -> string keepdims)|]
        (new NDArray(outputs.[0]))
    /// <summary>Computes the norm on an NDArray.
    /// 
    /// This operator computes the norm on an NDArray with the specified axis, depending
    /// on the value of the ord parameter. By default, it computes the L2 norm on the entire
    /// array. Currently only ord=2 supports sparse ndarrays.
    /// 
    /// Examples::
    /// 
    ///   x = [[[1, 2],
    ///         [3, 4]],
    ///        [[2, 2],
    ///         [5, 6]]]
    /// 
    ///   norm(x, ord=2, axis=1) = [[3.1622777 4.472136 ]
    ///                             [5.3851647 6.3245554]]
    /// 
    ///   norm(x, ord=1, axis=1) = [[4., 6.],
    ///                             [7., 8.]]
    /// 
    ///   rsp = x.cast_storage(&#39;row_sparse&#39;)
    /// 
    ///   norm(rsp) = [5.47722578]
    /// 
    ///   csr = x.cast_storage(&#39;csr&#39;)
    /// 
    ///   norm(csr) = [5.47722578]
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\broadcast_reduce_norm_value.cc:L89</summary>
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="data">The input</param>
    /// <param name="ord">Order of the norm. Currently ord=1 and ord=2 is supported.</param>
    /// <param name="axis">The axis or axes along which to perform the reduction.
    ///       The default, `axis=()`, will compute over all elements into a
    ///       scalar array with shape `(1,)`.
    ///       If `axis` is int, a reduction is performed on a particular axis.
    ///       If `axis` is a 2-tuple, it specifies the axes that hold 2-D matrices,
    ///       and the matrix norms of these matrices are computed.</param>
    /// <param name="outDtype">The data type of the output.</param>
    /// <param name="keepdims">If this is set to `True`, the reduced axis is left in the result as dimension with size one.</param>
    static member Norm(outputArray : NDArray seq, 
                       data : NDArray, 
                       [<Optional>] ?ord : int, 
                       [<Optional>] ?axis : int seq, 
                       [<Optional>] ?outDtype : DataType, 
                       [<Optional>] ?keepdims : bool) =
        let creator = AtomicSymbolCreator.FromName "norm"
        let names = [|"ord"; "axis"; "out_dtype"; "keepdims"|]
        let vals = [|(match ord with None -> "2" | Some ord -> string ord); (match axis with None -> "None" | Some axis -> (axis |> Seq.map string |> String.concat ", " |> sprintf "[%s]")); (match outDtype with None -> "None" | Some outDtype -> string outDtype); (match keepdims with None -> "false" | Some keepdims -> string keepdims)|]
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <summary>Computes the norm on an NDArray.
    /// 
    /// This operator computes the norm on an NDArray with the specified axis, depending
    /// on the value of the ord parameter. By default, it computes the L2 norm on the entire
    /// array. Currently only ord=2 supports sparse ndarrays.
    /// 
    /// Examples::
    /// 
    ///   x = [[[1, 2],
    ///         [3, 4]],
    ///        [[2, 2],
    ///         [5, 6]]]
    /// 
    ///   norm(x, ord=2, axis=1) = [[3.1622777 4.472136 ]
    ///                             [5.3851647 6.3245554]]
    /// 
    ///   norm(x, ord=1, axis=1) = [[4., 6.],
    ///                             [7., 8.]]
    /// 
    ///   rsp = x.cast_storage(&#39;row_sparse&#39;)
    /// 
    ///   norm(rsp) = [5.47722578]
    /// 
    ///   csr = x.cast_storage(&#39;csr&#39;)
    /// 
    ///   norm(csr) = [5.47722578]
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\broadcast_reduce_norm_value.cc:L89</summary>
    /// <param name="data">The input</param>
    /// <param name="ord">Order of the norm. Currently ord=1 and ord=2 is supported.</param>
    /// <param name="axis">The axis or axes along which to perform the reduction.
    ///       The default, `axis=()`, will compute over all elements into a
    ///       scalar array with shape `(1,)`.
    ///       If `axis` is int, a reduction is performed on a particular axis.
    ///       If `axis` is a 2-tuple, it specifies the axes that hold 2-D matrices,
    ///       and the matrix norms of these matrices are computed.</param>
    /// <param name="outDtype">The data type of the output.</param>
    /// <param name="keepdims">If this is set to `True`, the reduced axis is left in the result as dimension with size one.</param>
    static member Norm([<Optional>] ?data : Symbol, [<Optional>] ?ord : int, [<Optional>] ?axis : int seq, [<Optional>] ?outDtype : DataType, [<Optional>] ?keepdims : bool) =
        Norm(?data = data, ?ord = ord, ?axis = axis, ?outDtype = outDtype, ?keepdims = keepdims)


    /// <summary>Returns indices of the maximum values along an axis.
    /// 
    /// In the case of multiple occurrences of maximum values, the indices corresponding to the first occurrence
    /// are returned.
    /// 
    /// Examples::
    /// 
    ///   x = [[ 0.,  1.,  2.],
    ///        [ 3.,  4.,  5.]]
    /// 
    ///   // argmax along axis 0
    ///   argmax(x, axis=0) = [ 1.,  1.,  1.]
    /// 
    ///   // argmax along axis 1
    ///   argmax(x, axis=1) = [ 2.,  2.]
    /// 
    ///   // argmax along axis 1 keeping same dims as an input array
    ///   argmax(x, axis=1, keepdims=True) = [[ 2.],
    ///                                       [ 2.]]
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\broadcast_reduce_op_index.cc:L52</summary>
    /// <param name="data">The input</param>
    /// <param name="axis">The axis along which to perform the reduction. Negative values means indexing from right to left. ``Requires axis to be set as int, because global reduction is not supported yet.``</param>
    /// <param name="keepdims">If this is set to `True`, the reduced axis is left in the result as dimension with size one.</param>
    static member Argmax(data : NDArray, [<Optional>] ?axis : int, [<Optional>] ?keepdims : bool) =
        let creator = AtomicSymbolCreator.FromName "argmax"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle|]
                                                 [|"axis"; "keepdims"|]
                                                 [|(match axis with None -> "None" | Some axis -> string axis); (match keepdims with None -> "false" | Some keepdims -> string keepdims)|]
        (new NDArray(outputs.[0]))
    /// <summary>Returns indices of the maximum values along an axis.
    /// 
    /// In the case of multiple occurrences of maximum values, the indices corresponding to the first occurrence
    /// are returned.
    /// 
    /// Examples::
    /// 
    ///   x = [[ 0.,  1.,  2.],
    ///        [ 3.,  4.,  5.]]
    /// 
    ///   // argmax along axis 0
    ///   argmax(x, axis=0) = [ 1.,  1.,  1.]
    /// 
    ///   // argmax along axis 1
    ///   argmax(x, axis=1) = [ 2.,  2.]
    /// 
    ///   // argmax along axis 1 keeping same dims as an input array
    ///   argmax(x, axis=1, keepdims=True) = [[ 2.],
    ///                                       [ 2.]]
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\broadcast_reduce_op_index.cc:L52</summary>
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="data">The input</param>
    /// <param name="axis">The axis along which to perform the reduction. Negative values means indexing from right to left. ``Requires axis to be set as int, because global reduction is not supported yet.``</param>
    /// <param name="keepdims">If this is set to `True`, the reduced axis is left in the result as dimension with size one.</param>
    static member Argmax(outputArray : NDArray seq, data : NDArray, [<Optional>] ?axis : int, [<Optional>] ?keepdims : bool) =
        let creator = AtomicSymbolCreator.FromName "argmax"
        let names = [|"axis"; "keepdims"|]
        let vals = [|(match axis with None -> "None" | Some axis -> string axis); (match keepdims with None -> "false" | Some keepdims -> string keepdims)|]
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <summary>Returns indices of the maximum values along an axis.
    /// 
    /// In the case of multiple occurrences of maximum values, the indices corresponding to the first occurrence
    /// are returned.
    /// 
    /// Examples::
    /// 
    ///   x = [[ 0.,  1.,  2.],
    ///        [ 3.,  4.,  5.]]
    /// 
    ///   // argmax along axis 0
    ///   argmax(x, axis=0) = [ 1.,  1.,  1.]
    /// 
    ///   // argmax along axis 1
    ///   argmax(x, axis=1) = [ 2.,  2.]
    /// 
    ///   // argmax along axis 1 keeping same dims as an input array
    ///   argmax(x, axis=1, keepdims=True) = [[ 2.],
    ///                                       [ 2.]]
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\broadcast_reduce_op_index.cc:L52</summary>
    /// <param name="data">The input</param>
    /// <param name="axis">The axis along which to perform the reduction. Negative values means indexing from right to left. ``Requires axis to be set as int, because global reduction is not supported yet.``</param>
    /// <param name="keepdims">If this is set to `True`, the reduced axis is left in the result as dimension with size one.</param>
    static member Argmax([<Optional>] ?data : Symbol, [<Optional>] ?axis : int, [<Optional>] ?keepdims : bool) =
        Argmax(?data = data, ?axis = axis, ?keepdims = keepdims)

    /// <summary>Returns indices of the minimum values along an axis.
    /// 
    /// In the case of multiple occurrences of minimum values, the indices corresponding to the first occurrence
    /// are returned.
    /// 
    /// Examples::
    /// 
    ///   x = [[ 0.,  1.,  2.],
    ///        [ 3.,  4.,  5.]]
    /// 
    ///   // argmin along axis 0
    ///   argmin(x, axis=0) = [ 0.,  0.,  0.]
    /// 
    ///   // argmin along axis 1
    ///   argmin(x, axis=1) = [ 0.,  0.]
    /// 
    ///   // argmin along axis 1 keeping same dims as an input array
    ///   argmin(x, axis=1, keepdims=True) = [[ 0.],
    ///                                       [ 0.]]
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\broadcast_reduce_op_index.cc:L77</summary>
    /// <param name="data">The input</param>
    /// <param name="axis">The axis along which to perform the reduction. Negative values means indexing from right to left. ``Requires axis to be set as int, because global reduction is not supported yet.``</param>
    /// <param name="keepdims">If this is set to `True`, the reduced axis is left in the result as dimension with size one.</param>
    static member Argmin(data : NDArray, [<Optional>] ?axis : int, [<Optional>] ?keepdims : bool) =
        let creator = AtomicSymbolCreator.FromName "argmin"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle|]
                                                 [|"axis"; "keepdims"|]
                                                 [|(match axis with None -> "None" | Some axis -> string axis); (match keepdims with None -> "false" | Some keepdims -> string keepdims)|]
        (new NDArray(outputs.[0]))
    /// <summary>Returns indices of the minimum values along an axis.
    /// 
    /// In the case of multiple occurrences of minimum values, the indices corresponding to the first occurrence
    /// are returned.
    /// 
    /// Examples::
    /// 
    ///   x = [[ 0.,  1.,  2.],
    ///        [ 3.,  4.,  5.]]
    /// 
    ///   // argmin along axis 0
    ///   argmin(x, axis=0) = [ 0.,  0.,  0.]
    /// 
    ///   // argmin along axis 1
    ///   argmin(x, axis=1) = [ 0.,  0.]
    /// 
    ///   // argmin along axis 1 keeping same dims as an input array
    ///   argmin(x, axis=1, keepdims=True) = [[ 0.],
    ///                                       [ 0.]]
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\broadcast_reduce_op_index.cc:L77</summary>
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="data">The input</param>
    /// <param name="axis">The axis along which to perform the reduction. Negative values means indexing from right to left. ``Requires axis to be set as int, because global reduction is not supported yet.``</param>
    /// <param name="keepdims">If this is set to `True`, the reduced axis is left in the result as dimension with size one.</param>
    static member Argmin(outputArray : NDArray seq, data : NDArray, [<Optional>] ?axis : int, [<Optional>] ?keepdims : bool) =
        let creator = AtomicSymbolCreator.FromName "argmin"
        let names = [|"axis"; "keepdims"|]
        let vals = [|(match axis with None -> "None" | Some axis -> string axis); (match keepdims with None -> "false" | Some keepdims -> string keepdims)|]
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <summary>Returns indices of the minimum values along an axis.
    /// 
    /// In the case of multiple occurrences of minimum values, the indices corresponding to the first occurrence
    /// are returned.
    /// 
    /// Examples::
    /// 
    ///   x = [[ 0.,  1.,  2.],
    ///        [ 3.,  4.,  5.]]
    /// 
    ///   // argmin along axis 0
    ///   argmin(x, axis=0) = [ 0.,  0.,  0.]
    /// 
    ///   // argmin along axis 1
    ///   argmin(x, axis=1) = [ 0.,  0.]
    /// 
    ///   // argmin along axis 1 keeping same dims as an input array
    ///   argmin(x, axis=1, keepdims=True) = [[ 0.],
    ///                                       [ 0.]]
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\broadcast_reduce_op_index.cc:L77</summary>
    /// <param name="data">The input</param>
    /// <param name="axis">The axis along which to perform the reduction. Negative values means indexing from right to left. ``Requires axis to be set as int, because global reduction is not supported yet.``</param>
    /// <param name="keepdims">If this is set to `True`, the reduced axis is left in the result as dimension with size one.</param>
    static member Argmin([<Optional>] ?data : Symbol, [<Optional>] ?axis : int, [<Optional>] ?keepdims : bool) =
        Argmin(?data = data, ?axis = axis, ?keepdims = keepdims)

    /// <summary>Returns argmax indices of each channel from the input array.
    /// 
    /// The result will be an NDArray of shape (num_channel,).
    /// 
    /// In case of multiple occurrences of the maximum values, the indices corresponding to the first occurrence
    /// are returned.
    /// 
    /// Examples::
    /// 
    ///   x = [[ 0.,  1.,  2.],
    ///        [ 3.,  4.,  5.]]
    /// 
    ///   argmax_channel(x) = [ 2.,  2.]
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\broadcast_reduce_op_index.cc:L97</summary>
    /// <param name="data">The input array</param>
    static member ArgmaxChannel(data : NDArray) =
        let creator = AtomicSymbolCreator.FromName "argmax_channel"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle|]
                                                 Array.empty
                                                 Array.empty
        (new NDArray(outputs.[0]))
    /// <summary>Returns argmax indices of each channel from the input array.
    /// 
    /// The result will be an NDArray of shape (num_channel,).
    /// 
    /// In case of multiple occurrences of the maximum values, the indices corresponding to the first occurrence
    /// are returned.
    /// 
    /// Examples::
    /// 
    ///   x = [[ 0.,  1.,  2.],
    ///        [ 3.,  4.,  5.]]
    /// 
    ///   argmax_channel(x) = [ 2.,  2.]
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\broadcast_reduce_op_index.cc:L97</summary>
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="data">The input array</param>
    static member ArgmaxChannel(outputArray : NDArray seq, data : NDArray) =
        let creator = AtomicSymbolCreator.FromName "argmax_channel"
        let names = Array.empty
        let vals = Array.empty
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <summary>Returns argmax indices of each channel from the input array.
    /// 
    /// The result will be an NDArray of shape (num_channel,).
    /// 
    /// In case of multiple occurrences of the maximum values, the indices corresponding to the first occurrence
    /// are returned.
    /// 
    /// Examples::
    /// 
    ///   x = [[ 0.,  1.,  2.],
    ///        [ 3.,  4.,  5.]]
    /// 
    ///   argmax_channel(x) = [ 2.,  2.]
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\broadcast_reduce_op_index.cc:L97</summary>
    /// <param name="data">The input array</param>
    static member ArgmaxChannel([<Optional>] ?data : Symbol) =
        ArgmaxChannel(?data = data)

    /// <summary>Picks elements from an input array according to the input indices along the given axis.
    /// 
    /// Given an input array of shape ``(d0, d1)`` and indices of shape ``(i0,)``, the result will be
    /// an output array of shape ``(i0,)`` with::
    /// 
    ///   output[i] = input[i, indices[i]]
    /// 
    /// By default, if any index mentioned is too large, it is replaced by the index that addresses
    /// the last element along an axis (the `clip` mode).
    /// 
    /// This function supports n-dimensional input and (n-1)-dimensional indices arrays.
    /// 
    /// Examples::
    /// 
    ///   x = [[ 1.,  2.],
    ///        [ 3.,  4.],
    ///        [ 5.,  6.]]
    /// 
    ///   // picks elements with specified indices along axis 0
    ///   pick(x, y=[0,1], 0) = [ 1.,  4.]
    /// 
    ///   // picks elements with specified indices along axis 1
    ///   pick(x, y=[0,1,0], 1) = [ 1.,  4.,  5.]
    /// 
    ///   y = [[ 1.],
    ///        [ 0.],
    ///        [ 2.]]
    /// 
    ///   // picks elements with specified indices along axis 1 using &#39;wrap&#39; mode
    ///   // to place indicies that would normally be out of bounds
    ///   pick(x, y=[2,-1,-2], 1, mode=&#39;wrap&#39;) = [ 1.,  4.,  5.]
    /// 
    ///   y = [[ 1.],
    ///        [ 0.],
    ///        [ 2.]]
    /// 
    ///   // picks elements with specified indices along axis 1 and dims are maintained
    ///   pick(x,y, 1, keepdims=True) = [[ 2.],
    ///                                  [ 3.],
    ///                                  [ 6.]]
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\broadcast_reduce_op_index.cc:L155</summary>
    /// <param name="data">The input array</param>
    /// <param name="index">The index array</param>
    /// <param name="axis">int or None. The axis to picking the elements. Negative values means indexing from right to left. If is `None`, the elements in the index w.r.t the flattened input will be picked.</param>
    /// <param name="keepdims">If true, the axis where we pick the elements is left in the result as dimension with size one.</param>
    /// <param name="mode">Specify how out-of-bound indices behave. Default is &quot;clip&quot;. &quot;clip&quot; means clip to the range. So, if all indices mentioned are too large, they are replaced by the index that addresses the last element along an axis.  &quot;wrap&quot; means to wrap around.</param>
    static member Pick(data : NDArray, 
                       index : NDArray, 
                       [<Optional>] ?axis : int, 
                       [<Optional>] ?keepdims : bool, 
                       [<Optional>] ?mode : PickMode) =
        let creator = AtomicSymbolCreator.FromName "pick"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg index)) then index.UnsafeHandle|]
                                                 [|"axis"; "keepdims"; "mode"|]
                                                 [|(match axis with None -> "None" | Some axis -> string axis); (match keepdims with None -> "false" | Some keepdims -> string keepdims); (match mode with None -> "clip" | Some mode -> string mode)|]
        (new NDArray(outputs.[0]))
    /// <summary>Picks elements from an input array according to the input indices along the given axis.
    /// 
    /// Given an input array of shape ``(d0, d1)`` and indices of shape ``(i0,)``, the result will be
    /// an output array of shape ``(i0,)`` with::
    /// 
    ///   output[i] = input[i, indices[i]]
    /// 
    /// By default, if any index mentioned is too large, it is replaced by the index that addresses
    /// the last element along an axis (the `clip` mode).
    /// 
    /// This function supports n-dimensional input and (n-1)-dimensional indices arrays.
    /// 
    /// Examples::
    /// 
    ///   x = [[ 1.,  2.],
    ///        [ 3.,  4.],
    ///        [ 5.,  6.]]
    /// 
    ///   // picks elements with specified indices along axis 0
    ///   pick(x, y=[0,1], 0) = [ 1.,  4.]
    /// 
    ///   // picks elements with specified indices along axis 1
    ///   pick(x, y=[0,1,0], 1) = [ 1.,  4.,  5.]
    /// 
    ///   y = [[ 1.],
    ///        [ 0.],
    ///        [ 2.]]
    /// 
    ///   // picks elements with specified indices along axis 1 using &#39;wrap&#39; mode
    ///   // to place indicies that would normally be out of bounds
    ///   pick(x, y=[2,-1,-2], 1, mode=&#39;wrap&#39;) = [ 1.,  4.,  5.]
    /// 
    ///   y = [[ 1.],
    ///        [ 0.],
    ///        [ 2.]]
    /// 
    ///   // picks elements with specified indices along axis 1 and dims are maintained
    ///   pick(x,y, 1, keepdims=True) = [[ 2.],
    ///                                  [ 3.],
    ///                                  [ 6.]]
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\broadcast_reduce_op_index.cc:L155</summary>
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="data">The input array</param>
    /// <param name="index">The index array</param>
    /// <param name="axis">int or None. The axis to picking the elements. Negative values means indexing from right to left. If is `None`, the elements in the index w.r.t the flattened input will be picked.</param>
    /// <param name="keepdims">If true, the axis where we pick the elements is left in the result as dimension with size one.</param>
    /// <param name="mode">Specify how out-of-bound indices behave. Default is &quot;clip&quot;. &quot;clip&quot; means clip to the range. So, if all indices mentioned are too large, they are replaced by the index that addresses the last element along an axis.  &quot;wrap&quot; means to wrap around.</param>
    static member Pick(outputArray : NDArray seq, 
                       data : NDArray, 
                       index : NDArray, 
                       [<Optional>] ?axis : int, 
                       [<Optional>] ?keepdims : bool, 
                       [<Optional>] ?mode : PickMode) =
        let creator = AtomicSymbolCreator.FromName "pick"
        let names = [|"axis"; "keepdims"; "mode"|]
        let vals = [|(match axis with None -> "None" | Some axis -> string axis); (match keepdims with None -> "false" | Some keepdims -> string keepdims); (match mode with None -> "clip" | Some mode -> string mode)|]
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg index)) then index.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <summary>Picks elements from an input array according to the input indices along the given axis.
    /// 
    /// Given an input array of shape ``(d0, d1)`` and indices of shape ``(i0,)``, the result will be
    /// an output array of shape ``(i0,)`` with::
    /// 
    ///   output[i] = input[i, indices[i]]
    /// 
    /// By default, if any index mentioned is too large, it is replaced by the index that addresses
    /// the last element along an axis (the `clip` mode).
    /// 
    /// This function supports n-dimensional input and (n-1)-dimensional indices arrays.
    /// 
    /// Examples::
    /// 
    ///   x = [[ 1.,  2.],
    ///        [ 3.,  4.],
    ///        [ 5.,  6.]]
    /// 
    ///   // picks elements with specified indices along axis 0
    ///   pick(x, y=[0,1], 0) = [ 1.,  4.]
    /// 
    ///   // picks elements with specified indices along axis 1
    ///   pick(x, y=[0,1,0], 1) = [ 1.,  4.,  5.]
    /// 
    ///   y = [[ 1.],
    ///        [ 0.],
    ///        [ 2.]]
    /// 
    ///   // picks elements with specified indices along axis 1 using &#39;wrap&#39; mode
    ///   // to place indicies that would normally be out of bounds
    ///   pick(x, y=[2,-1,-2], 1, mode=&#39;wrap&#39;) = [ 1.,  4.,  5.]
    /// 
    ///   y = [[ 1.],
    ///        [ 0.],
    ///        [ 2.]]
    /// 
    ///   // picks elements with specified indices along axis 1 and dims are maintained
    ///   pick(x,y, 1, keepdims=True) = [[ 2.],
    ///                                  [ 3.],
    ///                                  [ 6.]]
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\broadcast_reduce_op_index.cc:L155</summary>
    /// <param name="data">The input array</param>
    /// <param name="index">The index array</param>
    /// <param name="axis">int or None. The axis to picking the elements. Negative values means indexing from right to left. If is `None`, the elements in the index w.r.t the flattened input will be picked.</param>
    /// <param name="keepdims">If true, the axis where we pick the elements is left in the result as dimension with size one.</param>
    /// <param name="mode">Specify how out-of-bound indices behave. Default is &quot;clip&quot;. &quot;clip&quot; means clip to the range. So, if all indices mentioned are too large, they are replaced by the index that addresses the last element along an axis.  &quot;wrap&quot; means to wrap around.</param>
    static member Pick([<Optional>] ?data : Symbol, [<Optional>] ?index : Symbol, [<Optional>] ?axis : int, [<Optional>] ?keepdims : bool, [<Optional>] ?mode : PickMode) =
        Pick(?data = data, ?index = index, ?axis = axis, ?keepdims = keepdims, ?mode = mode)


    /// <summary>Broadcasts the input array over particular axes.
    /// 
    /// Broadcasting is allowed on axes with size 1, such as from `(2,1,3,1)` to
    /// `(2,8,3,9)`. Elements will be duplicated on the broadcasted axes.
    /// 
    /// `broadcast_axes` is an alias to the function `broadcast_axis`.
    /// 
    /// Example::
    /// 
    ///    // given x of shape (1,2,1)
    ///    x = [[[ 1.],
    ///          [ 2.]]]
    /// 
    ///    // broadcast x on on axis 2
    ///    broadcast_axis(x, axis=2, size=3) = [[[ 1.,  1.,  1.],
    ///                                          [ 2.,  2.,  2.]]]
    ///    // broadcast x on on axes 0 and 2
    ///    broadcast_axis(x, axis=(0,2), size=(2,3)) = [[[ 1.,  1.,  1.],
    ///                                                  [ 2.,  2.,  2.]],
    ///                                                 [[ 1.,  1.,  1.],
    ///                                                  [ 2.,  2.,  2.]]]
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\broadcast_reduce_op_value.cc:L58</summary>
    /// <param name="data">The input</param>
    /// <param name="axis">The axes to perform the broadcasting.</param>
    /// <param name="size">Target sizes of the broadcasting axes.</param>
    static member BroadcastAxis(data : NDArray, [<Optional>] axis : int seq, [<Optional>] size : int seq) =
        let creator = AtomicSymbolCreator.FromName "broadcast_axis"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle|]
                                                 [|"axis"; "size"|]
                                                 [|(if isNull (axis :> obj) then "[]" else (axis |> Seq.map string |> String.concat ", " |> sprintf "[%s]")); (if isNull (size :> obj) then "[]" else (size |> Seq.map string |> String.concat ", " |> sprintf "[%s]"))|]
        (new NDArray(outputs.[0]))
    /// <summary>Broadcasts the input array over particular axes.
    /// 
    /// Broadcasting is allowed on axes with size 1, such as from `(2,1,3,1)` to
    /// `(2,8,3,9)`. Elements will be duplicated on the broadcasted axes.
    /// 
    /// `broadcast_axes` is an alias to the function `broadcast_axis`.
    /// 
    /// Example::
    /// 
    ///    // given x of shape (1,2,1)
    ///    x = [[[ 1.],
    ///          [ 2.]]]
    /// 
    ///    // broadcast x on on axis 2
    ///    broadcast_axis(x, axis=2, size=3) = [[[ 1.,  1.,  1.],
    ///                                          [ 2.,  2.,  2.]]]
    ///    // broadcast x on on axes 0 and 2
    ///    broadcast_axis(x, axis=(0,2), size=(2,3)) = [[[ 1.,  1.,  1.],
    ///                                                  [ 2.,  2.,  2.]],
    ///                                                 [[ 1.,  1.,  1.],
    ///                                                  [ 2.,  2.,  2.]]]
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\broadcast_reduce_op_value.cc:L58</summary>
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="data">The input</param>
    /// <param name="axis">The axes to perform the broadcasting.</param>
    /// <param name="size">Target sizes of the broadcasting axes.</param>
    static member BroadcastAxis(outputArray : NDArray seq, data : NDArray, [<Optional>] axis : int seq, [<Optional>] size : int seq) =
        let creator = AtomicSymbolCreator.FromName "broadcast_axis"
        let names = [|"axis"; "size"|]
        let vals = [|(if isNull (axis :> obj) then "[]" else (axis |> Seq.map string |> String.concat ", " |> sprintf "[%s]")); (if isNull (size :> obj) then "[]" else (size |> Seq.map string |> String.concat ", " |> sprintf "[%s]"))|]
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <summary>Broadcasts the input array over particular axes.
    /// 
    /// Broadcasting is allowed on axes with size 1, such as from `(2,1,3,1)` to
    /// `(2,8,3,9)`. Elements will be duplicated on the broadcasted axes.
    /// 
    /// `broadcast_axes` is an alias to the function `broadcast_axis`.
    /// 
    /// Example::
    /// 
    ///    // given x of shape (1,2,1)
    ///    x = [[[ 1.],
    ///          [ 2.]]]
    /// 
    ///    // broadcast x on on axis 2
    ///    broadcast_axis(x, axis=2, size=3) = [[[ 1.,  1.,  1.],
    ///                                          [ 2.,  2.,  2.]]]
    ///    // broadcast x on on axes 0 and 2
    ///    broadcast_axis(x, axis=(0,2), size=(2,3)) = [[[ 1.,  1.,  1.],
    ///                                                  [ 2.,  2.,  2.]],
    ///                                                 [[ 1.,  1.,  1.],
    ///                                                  [ 2.,  2.,  2.]]]
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\broadcast_reduce_op_value.cc:L58</summary>
    /// <param name="data">The input</param>
    /// <param name="axis">The axes to perform the broadcasting.</param>
    /// <param name="size">Target sizes of the broadcasting axes.</param>
    static member BroadcastAxis([<Optional>] ?data : Symbol, [<Optional>] ?axis : int seq, [<Optional>] ?size : int seq) =
        BroadcastAxis(?data = data, ?axis = axis, ?size = size)

    /// <summary>Broadcasts the input array to a new shape.
    /// 
    /// Broadcasting is a mechanism that allows NDArrays to perform arithmetic operations
    /// with arrays of different shapes efficiently without creating multiple copies of arrays.
    /// Also see, `Broadcasting &lt;https://docs.scipy.org/doc/numpy/user/basics.broadcasting.html&gt;`_ for more explanation.
    /// 
    /// Broadcasting is allowed on axes with size 1, such as from `(2,1,3,1)` to
    /// `(2,8,3,9)`. Elements will be duplicated on the broadcasted axes.
    /// 
    /// For example::
    /// 
    ///    broadcast_to([[1,2,3]], shape=(2,3)) = [[ 1.,  2.,  3.],
    ///                                            [ 1.,  2.,  3.]])
    /// 
    /// The dimension which you do not want to change can also be kept as `0` which means copy the original value.
    /// So with `shape=(2,0)`, we will obtain the same result as in the above example.
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\broadcast_reduce_op_value.cc:L82</summary>
    /// <param name="data">The input</param>
    /// <param name="shape">The shape of the desired array. We can set the dim to zero if it&#39;s same as the original. E.g `A = broadcast_to(B, shape=(10, 0, 0))` has the same meaning as `A = broadcast_axis(B, axis=0, size=10)`.</param>
    static member BroadcastTo(data : NDArray, [<Optional>] shape : int seq) =
        let creator = AtomicSymbolCreator.FromName "broadcast_to"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle|]
                                                 [|"shape"|]
                                                 [|(if isNull (shape :> obj) then "[]" else (shape |> Seq.map string |> String.concat ", " |> sprintf "[%s]"))|]
        (new NDArray(outputs.[0]))
    /// <summary>Broadcasts the input array to a new shape.
    /// 
    /// Broadcasting is a mechanism that allows NDArrays to perform arithmetic operations
    /// with arrays of different shapes efficiently without creating multiple copies of arrays.
    /// Also see, `Broadcasting &lt;https://docs.scipy.org/doc/numpy/user/basics.broadcasting.html&gt;`_ for more explanation.
    /// 
    /// Broadcasting is allowed on axes with size 1, such as from `(2,1,3,1)` to
    /// `(2,8,3,9)`. Elements will be duplicated on the broadcasted axes.
    /// 
    /// For example::
    /// 
    ///    broadcast_to([[1,2,3]], shape=(2,3)) = [[ 1.,  2.,  3.],
    ///                                            [ 1.,  2.,  3.]])
    /// 
    /// The dimension which you do not want to change can also be kept as `0` which means copy the original value.
    /// So with `shape=(2,0)`, we will obtain the same result as in the above example.
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\broadcast_reduce_op_value.cc:L82</summary>
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="data">The input</param>
    /// <param name="shape">The shape of the desired array. We can set the dim to zero if it&#39;s same as the original. E.g `A = broadcast_to(B, shape=(10, 0, 0))` has the same meaning as `A = broadcast_axis(B, axis=0, size=10)`.</param>
    static member BroadcastTo(outputArray : NDArray seq, data : NDArray, [<Optional>] shape : int seq) =
        let creator = AtomicSymbolCreator.FromName "broadcast_to"
        let names = [|"shape"|]
        let vals = [|(if isNull (shape :> obj) then "[]" else (shape |> Seq.map string |> String.concat ", " |> sprintf "[%s]"))|]
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <summary>Broadcasts the input array to a new shape.
    /// 
    /// Broadcasting is a mechanism that allows NDArrays to perform arithmetic operations
    /// with arrays of different shapes efficiently without creating multiple copies of arrays.
    /// Also see, `Broadcasting &lt;https://docs.scipy.org/doc/numpy/user/basics.broadcasting.html&gt;`_ for more explanation.
    /// 
    /// Broadcasting is allowed on axes with size 1, such as from `(2,1,3,1)` to
    /// `(2,8,3,9)`. Elements will be duplicated on the broadcasted axes.
    /// 
    /// For example::
    /// 
    ///    broadcast_to([[1,2,3]], shape=(2,3)) = [[ 1.,  2.,  3.],
    ///                                            [ 1.,  2.,  3.]])
    /// 
    /// The dimension which you do not want to change can also be kept as `0` which means copy the original value.
    /// So with `shape=(2,0)`, we will obtain the same result as in the above example.
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\broadcast_reduce_op_value.cc:L82</summary>
    /// <param name="data">The input</param>
    /// <param name="shape">The shape of the desired array. We can set the dim to zero if it&#39;s same as the original. E.g `A = broadcast_to(B, shape=(10, 0, 0))` has the same meaning as `A = broadcast_axis(B, axis=0, size=10)`.</param>
    static member BroadcastTo([<Optional>] ?data : Symbol, [<Optional>] ?shape : int seq) =
        BroadcastTo(?data = data, ?shape = shape)

    static member BroadcastBackwardNDArray() =
        let creator = AtomicSymbolCreator.FromName "_broadcast_backward"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 Array.empty
                                                 Array.empty
                                                 Array.empty
        outputs |> Array.map (fun h -> new NDArray(h))
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    static member BroadcastBackward(outputArray : NDArray seq) =
        let creator = AtomicSymbolCreator.FromName "_broadcast_backward"
        let names = Array.empty
        let vals = Array.empty
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     Array.empty
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    static member BroadcastBackward() =
        BroadcastBackward()

    /// <summary>Broadcasts lhs to have the same shape as rhs.
    /// 
    /// Broadcasting is a mechanism that allows NDArrays to perform arithmetic operations
    /// with arrays of different shapes efficiently without creating multiple copies of arrays.
    /// Also see, `Broadcasting &lt;https://docs.scipy.org/doc/numpy/user/basics.broadcasting.html&gt;`_ for more explanation.
    /// 
    /// Broadcasting is allowed on axes with size 1, such as from `(2,1,3,1)` to
    /// `(2,8,3,9)`. Elements will be duplicated on the broadcasted axes.
    /// 
    /// For example::
    /// 
    ///    broadcast_like([[1,2,3]], [[5,6,7],[7,8,9]]) = [[ 1.,  2.,  3.],
    ///                                                    [ 1.,  2.,  3.]])
    /// 
    ///    broadcast_like([9], [1,2,3,4,5], lhs_axes=(0,), rhs_axes=(-1,)) = [9,9,9,9,9]
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\broadcast_reduce_op_value.cc:L135</summary>
    /// <param name="lhs">First input.</param>
    /// <param name="rhs">Second input.</param>
    /// <param name="lhsAxes">Axes to perform broadcast on in the first input array</param>
    /// <param name="rhsAxes">Axes to copy from the second input array</param>
    static member BroadcastLike(lhs : NDArray, rhs : NDArray, [<Optional>] ?lhsAxes : int seq, [<Optional>] ?rhsAxes : int seq) =
        let creator = AtomicSymbolCreator.FromName "broadcast_like"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg lhs)) then lhs.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg rhs)) then rhs.UnsafeHandle|]
                                                 [|"lhs_axes"; "rhs_axes"|]
                                                 [|(match lhsAxes with None -> "None" | Some lhsAxes -> (lhsAxes |> Seq.map string |> String.concat ", " |> sprintf "[%s]")); (match rhsAxes with None -> "None" | Some rhsAxes -> (rhsAxes |> Seq.map string |> String.concat ", " |> sprintf "[%s]"))|]
        (new NDArray(outputs.[0]))
    /// <summary>Broadcasts lhs to have the same shape as rhs.
    /// 
    /// Broadcasting is a mechanism that allows NDArrays to perform arithmetic operations
    /// with arrays of different shapes efficiently without creating multiple copies of arrays.
    /// Also see, `Broadcasting &lt;https://docs.scipy.org/doc/numpy/user/basics.broadcasting.html&gt;`_ for more explanation.
    /// 
    /// Broadcasting is allowed on axes with size 1, such as from `(2,1,3,1)` to
    /// `(2,8,3,9)`. Elements will be duplicated on the broadcasted axes.
    /// 
    /// For example::
    /// 
    ///    broadcast_like([[1,2,3]], [[5,6,7],[7,8,9]]) = [[ 1.,  2.,  3.],
    ///                                                    [ 1.,  2.,  3.]])
    /// 
    ///    broadcast_like([9], [1,2,3,4,5], lhs_axes=(0,), rhs_axes=(-1,)) = [9,9,9,9,9]
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\broadcast_reduce_op_value.cc:L135</summary>
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="lhs">First input.</param>
    /// <param name="rhs">Second input.</param>
    /// <param name="lhsAxes">Axes to perform broadcast on in the first input array</param>
    /// <param name="rhsAxes">Axes to copy from the second input array</param>
    static member BroadcastLike(outputArray : NDArray seq, lhs : NDArray, rhs : NDArray, [<Optional>] ?lhsAxes : int seq, [<Optional>] ?rhsAxes : int seq) =
        let creator = AtomicSymbolCreator.FromName "broadcast_like"
        let names = [|"lhs_axes"; "rhs_axes"|]
        let vals = [|(match lhsAxes with None -> "None" | Some lhsAxes -> (lhsAxes |> Seq.map string |> String.concat ", " |> sprintf "[%s]")); (match rhsAxes with None -> "None" | Some rhsAxes -> (rhsAxes |> Seq.map string |> String.concat ", " |> sprintf "[%s]"))|]
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg lhs)) then lhs.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg rhs)) then rhs.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <summary>Broadcasts lhs to have the same shape as rhs.
    /// 
    /// Broadcasting is a mechanism that allows NDArrays to perform arithmetic operations
    /// with arrays of different shapes efficiently without creating multiple copies of arrays.
    /// Also see, `Broadcasting &lt;https://docs.scipy.org/doc/numpy/user/basics.broadcasting.html&gt;`_ for more explanation.
    /// 
    /// Broadcasting is allowed on axes with size 1, such as from `(2,1,3,1)` to
    /// `(2,8,3,9)`. Elements will be duplicated on the broadcasted axes.
    /// 
    /// For example::
    /// 
    ///    broadcast_like([[1,2,3]], [[5,6,7],[7,8,9]]) = [[ 1.,  2.,  3.],
    ///                                                    [ 1.,  2.,  3.]])
    /// 
    ///    broadcast_like([9], [1,2,3,4,5], lhs_axes=(0,), rhs_axes=(-1,)) = [9,9,9,9,9]
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\broadcast_reduce_op_value.cc:L135</summary>
    /// <param name="lhs">First input.</param>
    /// <param name="rhs">Second input.</param>
    /// <param name="lhsAxes">Axes to perform broadcast on in the first input array</param>
    /// <param name="rhsAxes">Axes to copy from the second input array</param>
    static member BroadcastLike([<Optional>] ?lhs : Symbol, [<Optional>] ?rhs : Symbol, [<Optional>] ?lhsAxes : int seq, [<Optional>] ?rhsAxes : int seq) =
        BroadcastLike(?lhs = lhs, ?rhs = rhs, ?lhsAxes = lhsAxes, ?rhsAxes = rhsAxes)

    /// <summary>Computes the product of array elements over given axes.
    /// 
    /// Defined in c:\jenkins\workspace\mxnet\mxnet\src\operator\tensor\./broadcast_reduce_op.h:L31</summary>
    /// <param name="data">The input</param>
    /// <param name="axis">The axis or axes along which to perform the reduction.
    /// 
    ///       The default, `axis=()`, will compute over all elements into a
    ///       scalar array with shape `(1,)`.
    /// 
    ///       If `axis` is int, a reduction is performed on a particular axis.
    /// 
    ///       If `axis` is a tuple of ints, a reduction is performed on all the axes
    ///       specified in the tuple.
    /// 
    ///       If `exclude` is true, reduction will be performed on the axes that are
    ///       NOT in axis instead.
    /// 
    ///       Negative values means indexing from right to left.</param>
    /// <param name="keepdims">If this is set to `True`, the reduced axes are left in the result as dimension with size one.</param>
    /// <param name="exclude">Whether to perform reduction on axis that are NOT in axis instead.</param>
    static member Prod(data : NDArray, [<Optional>] ?axis : int seq, [<Optional>] ?keepdims : bool, [<Optional>] ?exclude : bool) =
        let creator = AtomicSymbolCreator.FromName "prod"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle|]
                                                 [|"axis"; "keepdims"; "exclude"|]
                                                 [|(match axis with None -> "None" | Some axis -> (axis |> Seq.map string |> String.concat ", " |> sprintf "[%s]")); (match keepdims with None -> "false" | Some keepdims -> string keepdims); (match exclude with None -> "false" | Some exclude -> string exclude)|]
        (new NDArray(outputs.[0]))
    /// <summary>Computes the product of array elements over given axes.
    /// 
    /// Defined in c:\jenkins\workspace\mxnet\mxnet\src\operator\tensor\./broadcast_reduce_op.h:L31</summary>
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="data">The input</param>
    /// <param name="axis">The axis or axes along which to perform the reduction.
    /// 
    ///       The default, `axis=()`, will compute over all elements into a
    ///       scalar array with shape `(1,)`.
    /// 
    ///       If `axis` is int, a reduction is performed on a particular axis.
    /// 
    ///       If `axis` is a tuple of ints, a reduction is performed on all the axes
    ///       specified in the tuple.
    /// 
    ///       If `exclude` is true, reduction will be performed on the axes that are
    ///       NOT in axis instead.
    /// 
    ///       Negative values means indexing from right to left.</param>
    /// <param name="keepdims">If this is set to `True`, the reduced axes are left in the result as dimension with size one.</param>
    /// <param name="exclude">Whether to perform reduction on axis that are NOT in axis instead.</param>
    static member Prod(outputArray : NDArray seq, data : NDArray, [<Optional>] ?axis : int seq, [<Optional>] ?keepdims : bool, [<Optional>] ?exclude : bool) =
        let creator = AtomicSymbolCreator.FromName "prod"
        let names = [|"axis"; "keepdims"; "exclude"|]
        let vals = [|(match axis with None -> "None" | Some axis -> (axis |> Seq.map string |> String.concat ", " |> sprintf "[%s]")); (match keepdims with None -> "false" | Some keepdims -> string keepdims); (match exclude with None -> "false" | Some exclude -> string exclude)|]
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <summary>Computes the product of array elements over given axes.
    /// 
    /// Defined in c:\jenkins\workspace\mxnet\mxnet\src\operator\tensor\./broadcast_reduce_op.h:L31</summary>
    /// <param name="data">The input</param>
    /// <param name="axis">The axis or axes along which to perform the reduction.
    /// 
    ///       The default, `axis=()`, will compute over all elements into a
    ///       scalar array with shape `(1,)`.
    /// 
    ///       If `axis` is int, a reduction is performed on a particular axis.
    /// 
    ///       If `axis` is a tuple of ints, a reduction is performed on all the axes
    ///       specified in the tuple.
    /// 
    ///       If `exclude` is true, reduction will be performed on the axes that are
    ///       NOT in axis instead.
    /// 
    ///       Negative values means indexing from right to left.</param>
    /// <param name="keepdims">If this is set to `True`, the reduced axes are left in the result as dimension with size one.</param>
    /// <param name="exclude">Whether to perform reduction on axis that are NOT in axis instead.</param>
    static member Prod([<Optional>] ?data : Symbol, [<Optional>] ?axis : int seq, [<Optional>] ?keepdims : bool, [<Optional>] ?exclude : bool) =
        Prod(?data = data, ?axis = axis, ?keepdims = keepdims, ?exclude = exclude)


    /// <summary>Computes the product of array elements over given axes treating Not a Numbers (``NaN``) as one.
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\broadcast_reduce_prod_value.cc:L47</summary>
    /// <param name="data">The input</param>
    /// <param name="axis">The axis or axes along which to perform the reduction.
    /// 
    ///       The default, `axis=()`, will compute over all elements into a
    ///       scalar array with shape `(1,)`.
    /// 
    ///       If `axis` is int, a reduction is performed on a particular axis.
    /// 
    ///       If `axis` is a tuple of ints, a reduction is performed on all the axes
    ///       specified in the tuple.
    /// 
    ///       If `exclude` is true, reduction will be performed on the axes that are
    ///       NOT in axis instead.
    /// 
    ///       Negative values means indexing from right to left.</param>
    /// <param name="keepdims">If this is set to `True`, the reduced axes are left in the result as dimension with size one.</param>
    /// <param name="exclude">Whether to perform reduction on axis that are NOT in axis instead.</param>
    static member Nanprod(data : NDArray, [<Optional>] ?axis : int seq, [<Optional>] ?keepdims : bool, [<Optional>] ?exclude : bool) =
        let creator = AtomicSymbolCreator.FromName "nanprod"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle|]
                                                 [|"axis"; "keepdims"; "exclude"|]
                                                 [|(match axis with None -> "None" | Some axis -> (axis |> Seq.map string |> String.concat ", " |> sprintf "[%s]")); (match keepdims with None -> "false" | Some keepdims -> string keepdims); (match exclude with None -> "false" | Some exclude -> string exclude)|]
        (new NDArray(outputs.[0]))
    /// <summary>Computes the product of array elements over given axes treating Not a Numbers (``NaN``) as one.
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\broadcast_reduce_prod_value.cc:L47</summary>
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="data">The input</param>
    /// <param name="axis">The axis or axes along which to perform the reduction.
    /// 
    ///       The default, `axis=()`, will compute over all elements into a
    ///       scalar array with shape `(1,)`.
    /// 
    ///       If `axis` is int, a reduction is performed on a particular axis.
    /// 
    ///       If `axis` is a tuple of ints, a reduction is performed on all the axes
    ///       specified in the tuple.
    /// 
    ///       If `exclude` is true, reduction will be performed on the axes that are
    ///       NOT in axis instead.
    /// 
    ///       Negative values means indexing from right to left.</param>
    /// <param name="keepdims">If this is set to `True`, the reduced axes are left in the result as dimension with size one.</param>
    /// <param name="exclude">Whether to perform reduction on axis that are NOT in axis instead.</param>
    static member Nanprod(outputArray : NDArray seq, data : NDArray, [<Optional>] ?axis : int seq, [<Optional>] ?keepdims : bool, [<Optional>] ?exclude : bool) =
        let creator = AtomicSymbolCreator.FromName "nanprod"
        let names = [|"axis"; "keepdims"; "exclude"|]
        let vals = [|(match axis with None -> "None" | Some axis -> (axis |> Seq.map string |> String.concat ", " |> sprintf "[%s]")); (match keepdims with None -> "false" | Some keepdims -> string keepdims); (match exclude with None -> "false" | Some exclude -> string exclude)|]
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <summary>Computes the product of array elements over given axes treating Not a Numbers (``NaN``) as one.
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\broadcast_reduce_prod_value.cc:L47</summary>
    /// <param name="data">The input</param>
    /// <param name="axis">The axis or axes along which to perform the reduction.
    /// 
    ///       The default, `axis=()`, will compute over all elements into a
    ///       scalar array with shape `(1,)`.
    /// 
    ///       If `axis` is int, a reduction is performed on a particular axis.
    /// 
    ///       If `axis` is a tuple of ints, a reduction is performed on all the axes
    ///       specified in the tuple.
    /// 
    ///       If `exclude` is true, reduction will be performed on the axes that are
    ///       NOT in axis instead.
    /// 
    ///       Negative values means indexing from right to left.</param>
    /// <param name="keepdims">If this is set to `True`, the reduced axes are left in the result as dimension with size one.</param>
    /// <param name="exclude">Whether to perform reduction on axis that are NOT in axis instead.</param>
    static member Nanprod([<Optional>] ?data : Symbol, [<Optional>] ?axis : int seq, [<Optional>] ?keepdims : bool, [<Optional>] ?exclude : bool) =
        Nanprod(?data = data, ?axis = axis, ?keepdims = keepdims, ?exclude = exclude)


    /// <summary>Computes the sum of array elements over given axes.
    /// 
    /// .. Note::
    /// 
    ///   `sum` and `sum_axis` are equivalent.
    ///   For ndarray of csr storage type summation along axis 0 and axis 1 is supported.
    ///   Setting keepdims or exclude to True will cause a fallback to dense operator.
    /// 
    /// Example::
    /// 
    ///   data = [[[1, 2], [2, 3], [1, 3]],
    ///           [[1, 4], [4, 3], [5, 2]],
    ///           [[7, 1], [7, 2], [7, 3]]]
    /// 
    ///   sum(data, axis=1)
    ///   [[  4.   8.]
    ///    [ 10.   9.]
    ///    [ 21.   6.]]
    /// 
    ///   sum(data, axis=[1,2])
    ///   [ 12.  19.  27.]
    /// 
    ///   data = [[1, 2, 0],
    ///           [3, 0, 1],
    ///           [4, 1, 0]]
    /// 
    ///   csr = cast_storage(data, &#39;csr&#39;)
    /// 
    ///   sum(csr, axis=0)
    ///   [ 8.  3.  1.]
    /// 
    ///   sum(csr, axis=1)
    ///   [ 3.  4.  5.]
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\broadcast_reduce_sum_value.cc:L67</summary>
    /// <param name="data">The input</param>
    /// <param name="axis">The axis or axes along which to perform the reduction.
    /// 
    ///       The default, `axis=()`, will compute over all elements into a
    ///       scalar array with shape `(1,)`.
    /// 
    ///       If `axis` is int, a reduction is performed on a particular axis.
    /// 
    ///       If `axis` is a tuple of ints, a reduction is performed on all the axes
    ///       specified in the tuple.
    /// 
    ///       If `exclude` is true, reduction will be performed on the axes that are
    ///       NOT in axis instead.
    /// 
    ///       Negative values means indexing from right to left.</param>
    /// <param name="keepdims">If this is set to `True`, the reduced axes are left in the result as dimension with size one.</param>
    /// <param name="exclude">Whether to perform reduction on axis that are NOT in axis instead.</param>
    static member Sum(data : NDArray, [<Optional>] ?axis : int seq, [<Optional>] ?keepdims : bool, [<Optional>] ?exclude : bool) =
        let creator = AtomicSymbolCreator.FromName "sum"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle|]
                                                 [|"axis"; "keepdims"; "exclude"|]
                                                 [|(match axis with None -> "None" | Some axis -> (axis |> Seq.map string |> String.concat ", " |> sprintf "[%s]")); (match keepdims with None -> "false" | Some keepdims -> string keepdims); (match exclude with None -> "false" | Some exclude -> string exclude)|]
        (new NDArray(outputs.[0]))
    /// <summary>Computes the sum of array elements over given axes.
    /// 
    /// .. Note::
    /// 
    ///   `sum` and `sum_axis` are equivalent.
    ///   For ndarray of csr storage type summation along axis 0 and axis 1 is supported.
    ///   Setting keepdims or exclude to True will cause a fallback to dense operator.
    /// 
    /// Example::
    /// 
    ///   data = [[[1, 2], [2, 3], [1, 3]],
    ///           [[1, 4], [4, 3], [5, 2]],
    ///           [[7, 1], [7, 2], [7, 3]]]
    /// 
    ///   sum(data, axis=1)
    ///   [[  4.   8.]
    ///    [ 10.   9.]
    ///    [ 21.   6.]]
    /// 
    ///   sum(data, axis=[1,2])
    ///   [ 12.  19.  27.]
    /// 
    ///   data = [[1, 2, 0],
    ///           [3, 0, 1],
    ///           [4, 1, 0]]
    /// 
    ///   csr = cast_storage(data, &#39;csr&#39;)
    /// 
    ///   sum(csr, axis=0)
    ///   [ 8.  3.  1.]
    /// 
    ///   sum(csr, axis=1)
    ///   [ 3.  4.  5.]
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\broadcast_reduce_sum_value.cc:L67</summary>
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="data">The input</param>
    /// <param name="axis">The axis or axes along which to perform the reduction.
    /// 
    ///       The default, `axis=()`, will compute over all elements into a
    ///       scalar array with shape `(1,)`.
    /// 
    ///       If `axis` is int, a reduction is performed on a particular axis.
    /// 
    ///       If `axis` is a tuple of ints, a reduction is performed on all the axes
    ///       specified in the tuple.
    /// 
    ///       If `exclude` is true, reduction will be performed on the axes that are
    ///       NOT in axis instead.
    /// 
    ///       Negative values means indexing from right to left.</param>
    /// <param name="keepdims">If this is set to `True`, the reduced axes are left in the result as dimension with size one.</param>
    /// <param name="exclude">Whether to perform reduction on axis that are NOT in axis instead.</param>
    static member Sum(outputArray : NDArray seq, data : NDArray, [<Optional>] ?axis : int seq, [<Optional>] ?keepdims : bool, [<Optional>] ?exclude : bool) =
        let creator = AtomicSymbolCreator.FromName "sum"
        let names = [|"axis"; "keepdims"; "exclude"|]
        let vals = [|(match axis with None -> "None" | Some axis -> (axis |> Seq.map string |> String.concat ", " |> sprintf "[%s]")); (match keepdims with None -> "false" | Some keepdims -> string keepdims); (match exclude with None -> "false" | Some exclude -> string exclude)|]
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <summary>Computes the sum of array elements over given axes.
    /// 
    /// .. Note::
    /// 
    ///   `sum` and `sum_axis` are equivalent.
    ///   For ndarray of csr storage type summation along axis 0 and axis 1 is supported.
    ///   Setting keepdims or exclude to True will cause a fallback to dense operator.
    /// 
    /// Example::
    /// 
    ///   data = [[[1, 2], [2, 3], [1, 3]],
    ///           [[1, 4], [4, 3], [5, 2]],
    ///           [[7, 1], [7, 2], [7, 3]]]
    /// 
    ///   sum(data, axis=1)
    ///   [[  4.   8.]
    ///    [ 10.   9.]
    ///    [ 21.   6.]]
    /// 
    ///   sum(data, axis=[1,2])
    ///   [ 12.  19.  27.]
    /// 
    ///   data = [[1, 2, 0],
    ///           [3, 0, 1],
    ///           [4, 1, 0]]
    /// 
    ///   csr = cast_storage(data, &#39;csr&#39;)
    /// 
    ///   sum(csr, axis=0)
    ///   [ 8.  3.  1.]
    /// 
    ///   sum(csr, axis=1)
    ///   [ 3.  4.  5.]
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\broadcast_reduce_sum_value.cc:L67</summary>
    /// <param name="data">The input</param>
    /// <param name="axis">The axis or axes along which to perform the reduction.
    /// 
    ///       The default, `axis=()`, will compute over all elements into a
    ///       scalar array with shape `(1,)`.
    /// 
    ///       If `axis` is int, a reduction is performed on a particular axis.
    /// 
    ///       If `axis` is a tuple of ints, a reduction is performed on all the axes
    ///       specified in the tuple.
    /// 
    ///       If `exclude` is true, reduction will be performed on the axes that are
    ///       NOT in axis instead.
    /// 
    ///       Negative values means indexing from right to left.</param>
    /// <param name="keepdims">If this is set to `True`, the reduced axes are left in the result as dimension with size one.</param>
    /// <param name="exclude">Whether to perform reduction on axis that are NOT in axis instead.</param>
    static member Sum([<Optional>] ?data : Symbol, [<Optional>] ?axis : int seq, [<Optional>] ?keepdims : bool, [<Optional>] ?exclude : bool) =
        Sum(?data = data, ?axis = axis, ?keepdims = keepdims, ?exclude = exclude)


    /// <summary>Computes the mean of array elements over given axes.
    /// 
    /// Defined in c:\jenkins\workspace\mxnet\mxnet\src\operator\tensor\./broadcast_reduce_op.h:L84</summary>
    /// <param name="data">The input</param>
    /// <param name="axis">The axis or axes along which to perform the reduction.
    /// 
    ///       The default, `axis=()`, will compute over all elements into a
    ///       scalar array with shape `(1,)`.
    /// 
    ///       If `axis` is int, a reduction is performed on a particular axis.
    /// 
    ///       If `axis` is a tuple of ints, a reduction is performed on all the axes
    ///       specified in the tuple.
    /// 
    ///       If `exclude` is true, reduction will be performed on the axes that are
    ///       NOT in axis instead.
    /// 
    ///       Negative values means indexing from right to left.</param>
    /// <param name="keepdims">If this is set to `True`, the reduced axes are left in the result as dimension with size one.</param>
    /// <param name="exclude">Whether to perform reduction on axis that are NOT in axis instead.</param>
    static member Mean(data : NDArray, [<Optional>] ?axis : int seq, [<Optional>] ?keepdims : bool, [<Optional>] ?exclude : bool) =
        let creator = AtomicSymbolCreator.FromName "mean"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle|]
                                                 [|"axis"; "keepdims"; "exclude"|]
                                                 [|(match axis with None -> "None" | Some axis -> (axis |> Seq.map string |> String.concat ", " |> sprintf "[%s]")); (match keepdims with None -> "false" | Some keepdims -> string keepdims); (match exclude with None -> "false" | Some exclude -> string exclude)|]
        (new NDArray(outputs.[0]))
    /// <summary>Computes the mean of array elements over given axes.
    /// 
    /// Defined in c:\jenkins\workspace\mxnet\mxnet\src\operator\tensor\./broadcast_reduce_op.h:L84</summary>
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="data">The input</param>
    /// <param name="axis">The axis or axes along which to perform the reduction.
    /// 
    ///       The default, `axis=()`, will compute over all elements into a
    ///       scalar array with shape `(1,)`.
    /// 
    ///       If `axis` is int, a reduction is performed on a particular axis.
    /// 
    ///       If `axis` is a tuple of ints, a reduction is performed on all the axes
    ///       specified in the tuple.
    /// 
    ///       If `exclude` is true, reduction will be performed on the axes that are
    ///       NOT in axis instead.
    /// 
    ///       Negative values means indexing from right to left.</param>
    /// <param name="keepdims">If this is set to `True`, the reduced axes are left in the result as dimension with size one.</param>
    /// <param name="exclude">Whether to perform reduction on axis that are NOT in axis instead.</param>
    static member Mean(outputArray : NDArray seq, data : NDArray, [<Optional>] ?axis : int seq, [<Optional>] ?keepdims : bool, [<Optional>] ?exclude : bool) =
        let creator = AtomicSymbolCreator.FromName "mean"
        let names = [|"axis"; "keepdims"; "exclude"|]
        let vals = [|(match axis with None -> "None" | Some axis -> (axis |> Seq.map string |> String.concat ", " |> sprintf "[%s]")); (match keepdims with None -> "false" | Some keepdims -> string keepdims); (match exclude with None -> "false" | Some exclude -> string exclude)|]
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <summary>Computes the mean of array elements over given axes.
    /// 
    /// Defined in c:\jenkins\workspace\mxnet\mxnet\src\operator\tensor\./broadcast_reduce_op.h:L84</summary>
    /// <param name="data">The input</param>
    /// <param name="axis">The axis or axes along which to perform the reduction.
    /// 
    ///       The default, `axis=()`, will compute over all elements into a
    ///       scalar array with shape `(1,)`.
    /// 
    ///       If `axis` is int, a reduction is performed on a particular axis.
    /// 
    ///       If `axis` is a tuple of ints, a reduction is performed on all the axes
    ///       specified in the tuple.
    /// 
    ///       If `exclude` is true, reduction will be performed on the axes that are
    ///       NOT in axis instead.
    /// 
    ///       Negative values means indexing from right to left.</param>
    /// <param name="keepdims">If this is set to `True`, the reduced axes are left in the result as dimension with size one.</param>
    /// <param name="exclude">Whether to perform reduction on axis that are NOT in axis instead.</param>
    static member Mean([<Optional>] ?data : Symbol, [<Optional>] ?axis : int seq, [<Optional>] ?keepdims : bool, [<Optional>] ?exclude : bool) =
        Mean(?data = data, ?axis = axis, ?keepdims = keepdims, ?exclude = exclude)


    /// <summary>Computes the sum of array elements over given axes treating Not a Numbers (``NaN``) as zero.
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\broadcast_reduce_sum_value.cc:L102</summary>
    /// <param name="data">The input</param>
    /// <param name="axis">The axis or axes along which to perform the reduction.
    /// 
    ///       The default, `axis=()`, will compute over all elements into a
    ///       scalar array with shape `(1,)`.
    /// 
    ///       If `axis` is int, a reduction is performed on a particular axis.
    /// 
    ///       If `axis` is a tuple of ints, a reduction is performed on all the axes
    ///       specified in the tuple.
    /// 
    ///       If `exclude` is true, reduction will be performed on the axes that are
    ///       NOT in axis instead.
    /// 
    ///       Negative values means indexing from right to left.</param>
    /// <param name="keepdims">If this is set to `True`, the reduced axes are left in the result as dimension with size one.</param>
    /// <param name="exclude">Whether to perform reduction on axis that are NOT in axis instead.</param>
    static member Nansum(data : NDArray, [<Optional>] ?axis : int seq, [<Optional>] ?keepdims : bool, [<Optional>] ?exclude : bool) =
        let creator = AtomicSymbolCreator.FromName "nansum"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle|]
                                                 [|"axis"; "keepdims"; "exclude"|]
                                                 [|(match axis with None -> "None" | Some axis -> (axis |> Seq.map string |> String.concat ", " |> sprintf "[%s]")); (match keepdims with None -> "false" | Some keepdims -> string keepdims); (match exclude with None -> "false" | Some exclude -> string exclude)|]
        (new NDArray(outputs.[0]))
    /// <summary>Computes the sum of array elements over given axes treating Not a Numbers (``NaN``) as zero.
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\broadcast_reduce_sum_value.cc:L102</summary>
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="data">The input</param>
    /// <param name="axis">The axis or axes along which to perform the reduction.
    /// 
    ///       The default, `axis=()`, will compute over all elements into a
    ///       scalar array with shape `(1,)`.
    /// 
    ///       If `axis` is int, a reduction is performed on a particular axis.
    /// 
    ///       If `axis` is a tuple of ints, a reduction is performed on all the axes
    ///       specified in the tuple.
    /// 
    ///       If `exclude` is true, reduction will be performed on the axes that are
    ///       NOT in axis instead.
    /// 
    ///       Negative values means indexing from right to left.</param>
    /// <param name="keepdims">If this is set to `True`, the reduced axes are left in the result as dimension with size one.</param>
    /// <param name="exclude">Whether to perform reduction on axis that are NOT in axis instead.</param>
    static member Nansum(outputArray : NDArray seq, data : NDArray, [<Optional>] ?axis : int seq, [<Optional>] ?keepdims : bool, [<Optional>] ?exclude : bool) =
        let creator = AtomicSymbolCreator.FromName "nansum"
        let names = [|"axis"; "keepdims"; "exclude"|]
        let vals = [|(match axis with None -> "None" | Some axis -> (axis |> Seq.map string |> String.concat ", " |> sprintf "[%s]")); (match keepdims with None -> "false" | Some keepdims -> string keepdims); (match exclude with None -> "false" | Some exclude -> string exclude)|]
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <summary>Computes the sum of array elements over given axes treating Not a Numbers (``NaN``) as zero.
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\broadcast_reduce_sum_value.cc:L102</summary>
    /// <param name="data">The input</param>
    /// <param name="axis">The axis or axes along which to perform the reduction.
    /// 
    ///       The default, `axis=()`, will compute over all elements into a
    ///       scalar array with shape `(1,)`.
    /// 
    ///       If `axis` is int, a reduction is performed on a particular axis.
    /// 
    ///       If `axis` is a tuple of ints, a reduction is performed on all the axes
    ///       specified in the tuple.
    /// 
    ///       If `exclude` is true, reduction will be performed on the axes that are
    ///       NOT in axis instead.
    /// 
    ///       Negative values means indexing from right to left.</param>
    /// <param name="keepdims">If this is set to `True`, the reduced axes are left in the result as dimension with size one.</param>
    /// <param name="exclude">Whether to perform reduction on axis that are NOT in axis instead.</param>
    static member Nansum([<Optional>] ?data : Symbol, [<Optional>] ?axis : int seq, [<Optional>] ?keepdims : bool, [<Optional>] ?exclude : bool) =
        Nansum(?data = data, ?axis = axis, ?keepdims = keepdims, ?exclude = exclude)


    /// <summary>Casts tensor storage type to the new type.
    /// 
    /// When an NDArray with default storage type is cast to csr or row_sparse storage,
    /// the result is compact, which means:
    /// 
    /// - for csr, zero values will not be retained
    /// - for row_sparse, row slices of all zeros will not be retained
    /// 
    /// The storage type of ``cast_storage`` output depends on stype parameter:
    /// 
    /// - cast_storage(csr, &#39;default&#39;) = default
    /// - cast_storage(row_sparse, &#39;default&#39;) = default
    /// - cast_storage(default, &#39;csr&#39;) = csr
    /// - cast_storage(default, &#39;row_sparse&#39;) = row_sparse
    /// - cast_storage(csr, &#39;csr&#39;) = csr
    /// - cast_storage(row_sparse, &#39;row_sparse&#39;) = row_sparse
    /// 
    /// Example::
    /// 
    ///     dense = [[ 0.,  1.,  0.],
    ///              [ 2.,  0.,  3.],
    ///              [ 0.,  0.,  0.],
    ///              [ 0.,  0.,  0.]]
    /// 
    ///     # cast to row_sparse storage type
    ///     rsp = cast_storage(dense, &#39;row_sparse&#39;)
    ///     rsp.indices = [0, 1]
    ///     rsp.values = [[ 0.,  1.,  0.],
    ///                   [ 2.,  0.,  3.]]
    /// 
    ///     # cast to csr storage type
    ///     csr = cast_storage(dense, &#39;csr&#39;)
    ///     csr.indices = [1, 0, 2]
    ///     csr.values = [ 1.,  2.,  3.]
    ///     csr.indptr = [0, 1, 3, 3, 3]
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\cast_storage.cc:L71</summary>
    /// <param name="data">The input.</param>
    /// <param name="stype">Output storage type.</param>
    static member CastStorage(data : NDArray, stype : StorageType) =
        let creator = AtomicSymbolCreator.FromName "cast_storage"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle|]
                                                 [|"stype"|]
                                                 [|string stype|]
        (new NDArray(outputs.[0]))
    /// <summary>Casts tensor storage type to the new type.
    /// 
    /// When an NDArray with default storage type is cast to csr or row_sparse storage,
    /// the result is compact, which means:
    /// 
    /// - for csr, zero values will not be retained
    /// - for row_sparse, row slices of all zeros will not be retained
    /// 
    /// The storage type of ``cast_storage`` output depends on stype parameter:
    /// 
    /// - cast_storage(csr, &#39;default&#39;) = default
    /// - cast_storage(row_sparse, &#39;default&#39;) = default
    /// - cast_storage(default, &#39;csr&#39;) = csr
    /// - cast_storage(default, &#39;row_sparse&#39;) = row_sparse
    /// - cast_storage(csr, &#39;csr&#39;) = csr
    /// - cast_storage(row_sparse, &#39;row_sparse&#39;) = row_sparse
    /// 
    /// Example::
    /// 
    ///     dense = [[ 0.,  1.,  0.],
    ///              [ 2.,  0.,  3.],
    ///              [ 0.,  0.,  0.],
    ///              [ 0.,  0.,  0.]]
    /// 
    ///     # cast to row_sparse storage type
    ///     rsp = cast_storage(dense, &#39;row_sparse&#39;)
    ///     rsp.indices = [0, 1]
    ///     rsp.values = [[ 0.,  1.,  0.],
    ///                   [ 2.,  0.,  3.]]
    /// 
    ///     # cast to csr storage type
    ///     csr = cast_storage(dense, &#39;csr&#39;)
    ///     csr.indices = [1, 0, 2]
    ///     csr.values = [ 1.,  2.,  3.]
    ///     csr.indptr = [0, 1, 3, 3, 3]
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\cast_storage.cc:L71</summary>
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="data">The input.</param>
    /// <param name="stype">Output storage type.</param>
    static member CastStorage(outputArray : NDArray seq, data : NDArray, stype : StorageType) =
        let creator = AtomicSymbolCreator.FromName "cast_storage"
        let names = [|"stype"|]
        let vals = [|string stype|]
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <summary>Casts tensor storage type to the new type.
    /// 
    /// When an NDArray with default storage type is cast to csr or row_sparse storage,
    /// the result is compact, which means:
    /// 
    /// - for csr, zero values will not be retained
    /// - for row_sparse, row slices of all zeros will not be retained
    /// 
    /// The storage type of ``cast_storage`` output depends on stype parameter:
    /// 
    /// - cast_storage(csr, &#39;default&#39;) = default
    /// - cast_storage(row_sparse, &#39;default&#39;) = default
    /// - cast_storage(default, &#39;csr&#39;) = csr
    /// - cast_storage(default, &#39;row_sparse&#39;) = row_sparse
    /// - cast_storage(csr, &#39;csr&#39;) = csr
    /// - cast_storage(row_sparse, &#39;row_sparse&#39;) = row_sparse
    /// 
    /// Example::
    /// 
    ///     dense = [[ 0.,  1.,  0.],
    ///              [ 2.,  0.,  3.],
    ///              [ 0.,  0.,  0.],
    ///              [ 0.,  0.,  0.]]
    /// 
    ///     # cast to row_sparse storage type
    ///     rsp = cast_storage(dense, &#39;row_sparse&#39;)
    ///     rsp.indices = [0, 1]
    ///     rsp.values = [[ 0.,  1.,  0.],
    ///                   [ 2.,  0.,  3.]]
    /// 
    ///     # cast to csr storage type
    ///     csr = cast_storage(dense, &#39;csr&#39;)
    ///     csr.indices = [1, 0, 2]
    ///     csr.values = [ 1.,  2.,  3.]
    ///     csr.indptr = [0, 1, 3, 3, 3]
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\cast_storage.cc:L71</summary>
    /// <param name="data">The input.</param>
    /// <param name="stype">Output storage type.</param>
    static member CastStorage(data : Symbol, stype : StorageType) =
        CastStorage(data, stype)
    /// <summary>Casts tensor storage type to the new type.
    /// 
    /// When an NDArray with default storage type is cast to csr or row_sparse storage,
    /// the result is compact, which means:
    /// 
    /// - for csr, zero values will not be retained
    /// - for row_sparse, row slices of all zeros will not be retained
    /// 
    /// The storage type of ``cast_storage`` output depends on stype parameter:
    /// 
    /// - cast_storage(csr, &#39;default&#39;) = default
    /// - cast_storage(row_sparse, &#39;default&#39;) = default
    /// - cast_storage(default, &#39;csr&#39;) = csr
    /// - cast_storage(default, &#39;row_sparse&#39;) = row_sparse
    /// - cast_storage(csr, &#39;csr&#39;) = csr
    /// - cast_storage(row_sparse, &#39;row_sparse&#39;) = row_sparse
    /// 
    /// Example::
    /// 
    ///     dense = [[ 0.,  1.,  0.],
    ///              [ 2.,  0.,  3.],
    ///              [ 0.,  0.,  0.],
    ///              [ 0.,  0.,  0.]]
    /// 
    ///     # cast to row_sparse storage type
    ///     rsp = cast_storage(dense, &#39;row_sparse&#39;)
    ///     rsp.indices = [0, 1]
    ///     rsp.values = [[ 0.,  1.,  0.],
    ///                   [ 2.,  0.,  3.]]
    /// 
    ///     # cast to csr storage type
    ///     csr = cast_storage(dense, &#39;csr&#39;)
    ///     csr.indices = [1, 0, 2]
    ///     csr.values = [ 1.,  2.,  3.]
    ///     csr.indptr = [0, 1, 3, 3, 3]
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\cast_storage.cc:L71</summary>
    /// <param name="stype">Output storage type.</param>
    /// <param name="data">The input.</param>
    static member CastStorage(stype : StorageType, [<Optional>] ?data : Symbol) =
        CastStorage(stype, ?data = data)

    /// <summary>Return the elements, either from x or y, depending on the condition.
    /// 
    /// Given three ndarrays, condition, x, and y, return an ndarray with the elements from x or y,
    /// depending on the elements from condition are true or false. x and y must have the same shape.
    /// If condition has the same shape as x, each element in the output array is from x if the
    /// corresponding element in the condition is true, and from y if false.
    /// 
    /// If condition does not have the same shape as x, it must be a 1D array whose size is
    /// the same as x&#39;s first dimension size. Each row of the output array is from x&#39;s row
    /// if the corresponding element from condition is true, and from y&#39;s row if false.
    /// 
    /// Note that all non-zero values are interpreted as ``True`` in condition.
    /// 
    /// Examples::
    /// 
    ///   x = [[1, 2], [3, 4]]
    ///   y = [[5, 6], [7, 8]]
    ///   cond = [[0, 1], [-1, 0]]
    /// 
    ///   where(cond, x, y) = [[5, 2], [3, 8]]
    /// 
    ///   csr_cond = cast_storage(cond, &#39;csr&#39;)
    /// 
    ///   where(csr_cond, x, y) = [[5, 2], [3, 8]]
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\control_flow_op.cc:L57</summary>
    /// <param name="condition">condition array</param>
    /// <param name="x"></param>
    /// <param name="y"></param>
    static member Where(condition : NDArray, x : NDArray, y : NDArray) =
        let creator = AtomicSymbolCreator.FromName "where"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg condition)) then condition.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg x)) then x.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg y)) then y.UnsafeHandle|]
                                                 Array.empty
                                                 Array.empty
        (new NDArray(outputs.[0]))
    /// <summary>Return the elements, either from x or y, depending on the condition.
    /// 
    /// Given three ndarrays, condition, x, and y, return an ndarray with the elements from x or y,
    /// depending on the elements from condition are true or false. x and y must have the same shape.
    /// If condition has the same shape as x, each element in the output array is from x if the
    /// corresponding element in the condition is true, and from y if false.
    /// 
    /// If condition does not have the same shape as x, it must be a 1D array whose size is
    /// the same as x&#39;s first dimension size. Each row of the output array is from x&#39;s row
    /// if the corresponding element from condition is true, and from y&#39;s row if false.
    /// 
    /// Note that all non-zero values are interpreted as ``True`` in condition.
    /// 
    /// Examples::
    /// 
    ///   x = [[1, 2], [3, 4]]
    ///   y = [[5, 6], [7, 8]]
    ///   cond = [[0, 1], [-1, 0]]
    /// 
    ///   where(cond, x, y) = [[5, 2], [3, 8]]
    /// 
    ///   csr_cond = cast_storage(cond, &#39;csr&#39;)
    /// 
    ///   where(csr_cond, x, y) = [[5, 2], [3, 8]]
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\control_flow_op.cc:L57</summary>
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="condition">condition array</param>
    /// <param name="x"></param>
    /// <param name="y"></param>
    static member Where(outputArray : NDArray seq, condition : NDArray, x : NDArray, y : NDArray) =
        let creator = AtomicSymbolCreator.FromName "where"
        let names = Array.empty
        let vals = Array.empty
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg condition)) then condition.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg x)) then x.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg y)) then y.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <summary>Return the elements, either from x or y, depending on the condition.
    /// 
    /// Given three ndarrays, condition, x, and y, return an ndarray with the elements from x or y,
    /// depending on the elements from condition are true or false. x and y must have the same shape.
    /// If condition has the same shape as x, each element in the output array is from x if the
    /// corresponding element in the condition is true, and from y if false.
    /// 
    /// If condition does not have the same shape as x, it must be a 1D array whose size is
    /// the same as x&#39;s first dimension size. Each row of the output array is from x&#39;s row
    /// if the corresponding element from condition is true, and from y&#39;s row if false.
    /// 
    /// Note that all non-zero values are interpreted as ``True`` in condition.
    /// 
    /// Examples::
    /// 
    ///   x = [[1, 2], [3, 4]]
    ///   y = [[5, 6], [7, 8]]
    ///   cond = [[0, 1], [-1, 0]]
    /// 
    ///   where(cond, x, y) = [[5, 2], [3, 8]]
    /// 
    ///   csr_cond = cast_storage(cond, &#39;csr&#39;)
    /// 
    ///   where(csr_cond, x, y) = [[5, 2], [3, 8]]
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\control_flow_op.cc:L57</summary>
    /// <param name="condition">condition array</param>
    /// <param name="x"></param>
    /// <param name="y"></param>
    static member Where([<Optional>] ?condition : Symbol, [<Optional>] ?x : Symbol, [<Optional>] ?y : Symbol) =
        Where(?condition = condition, ?x = x, ?y = y)


    /// <summary>Extracts a diagonal or constructs a diagonal array.
    /// 
    /// ``diag``&#39;s behavior depends on the input array dimensions:
    /// 
    /// - 1-D arrays: constructs a 2-D array with the input as its diagonal, all other elements are zero.
    /// - N-D arrays: extracts the diagonals of the sub-arrays with axes specified by ``axis1`` and ``axis2``.
    ///   The output shape would be decided by removing the axes numbered ``axis1`` and ``axis2`` from the
    ///   input shape and appending to the result a new axis with the size of the diagonals in question.
    /// 
    ///   For example, when the input shape is `(2, 3, 4, 5)`, ``axis1`` and ``axis2`` are 0 and 2
    ///   respectively and ``k`` is 0, the resulting shape would be `(3, 5, 2)`.
    /// 
    /// Examples::
    /// 
    ///   x = [[1, 2, 3],
    ///        [4, 5, 6]]
    /// 
    ///   diag(x) = [1, 5]
    /// 
    ///   diag(x, k=1) = [2, 6]
    /// 
    ///   diag(x, k=-1) = [4]
    /// 
    ///   x = [1, 2, 3]
    /// 
    ///   diag(x) = [[1, 0, 0],
    ///              [0, 2, 0],
    ///              [0, 0, 3]]
    /// 
    ///   diag(x, k=1) = [[0, 1, 0],
    ///                   [0, 0, 2],
    ///                   [0, 0, 0]]
    /// 
    ///   diag(x, k=-1) = [[0, 0, 0],
    ///                    [1, 0, 0],
    ///                    [0, 2, 0]]
    /// 
    ///   x = [[[1, 2],
    ///         [3, 4]],
    /// 
    ///        [[5, 6],
    ///         [7, 8]]]
    /// 
    ///   diag(x) = [[1, 7],
    ///              [2, 8]]
    /// 
    ///   diag(x, k=1) = [[3],
    ///                   [4]]
    /// 
    ///   diag(x, axis1=-2, axis2=-1) = [[1, 4],
    ///                                  [5, 8]]
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\diag_op.cc:L87</summary>
    /// <param name="data">Input ndarray</param>
    /// <param name="k">Diagonal in question. The default is 0. Use k&gt;0 for diagonals above the main diagonal, and k&lt;0 for diagonals below the main diagonal. If input has shape (S0 S1) k must be between -S0 and S1</param>
    /// <param name="axis1">The first axis of the sub-arrays of interest. Ignored when the input is a 1-D array.</param>
    /// <param name="axis2">The second axis of the sub-arrays of interest. Ignored when the input is a 1-D array.</param>
    static member Diag(data : NDArray, [<Optional; DefaultParameterValue(0)>] k : int, [<Optional; DefaultParameterValue(0)>] axis1 : int, [<Optional; DefaultParameterValue(1)>] axis2 : int) =
        let creator = AtomicSymbolCreator.FromName "diag"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle|]
                                                 [|"k"; "axis1"; "axis2"|]
                                                 [|string k; string axis1; string axis2|]
        (new NDArray(outputs.[0]))
    /// <summary>Extracts a diagonal or constructs a diagonal array.
    /// 
    /// ``diag``&#39;s behavior depends on the input array dimensions:
    /// 
    /// - 1-D arrays: constructs a 2-D array with the input as its diagonal, all other elements are zero.
    /// - N-D arrays: extracts the diagonals of the sub-arrays with axes specified by ``axis1`` and ``axis2``.
    ///   The output shape would be decided by removing the axes numbered ``axis1`` and ``axis2`` from the
    ///   input shape and appending to the result a new axis with the size of the diagonals in question.
    /// 
    ///   For example, when the input shape is `(2, 3, 4, 5)`, ``axis1`` and ``axis2`` are 0 and 2
    ///   respectively and ``k`` is 0, the resulting shape would be `(3, 5, 2)`.
    /// 
    /// Examples::
    /// 
    ///   x = [[1, 2, 3],
    ///        [4, 5, 6]]
    /// 
    ///   diag(x) = [1, 5]
    /// 
    ///   diag(x, k=1) = [2, 6]
    /// 
    ///   diag(x, k=-1) = [4]
    /// 
    ///   x = [1, 2, 3]
    /// 
    ///   diag(x) = [[1, 0, 0],
    ///              [0, 2, 0],
    ///              [0, 0, 3]]
    /// 
    ///   diag(x, k=1) = [[0, 1, 0],
    ///                   [0, 0, 2],
    ///                   [0, 0, 0]]
    /// 
    ///   diag(x, k=-1) = [[0, 0, 0],
    ///                    [1, 0, 0],
    ///                    [0, 2, 0]]
    /// 
    ///   x = [[[1, 2],
    ///         [3, 4]],
    /// 
    ///        [[5, 6],
    ///         [7, 8]]]
    /// 
    ///   diag(x) = [[1, 7],
    ///              [2, 8]]
    /// 
    ///   diag(x, k=1) = [[3],
    ///                   [4]]
    /// 
    ///   diag(x, axis1=-2, axis2=-1) = [[1, 4],
    ///                                  [5, 8]]
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\diag_op.cc:L87</summary>
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="data">Input ndarray</param>
    /// <param name="k">Diagonal in question. The default is 0. Use k&gt;0 for diagonals above the main diagonal, and k&lt;0 for diagonals below the main diagonal. If input has shape (S0 S1) k must be between -S0 and S1</param>
    /// <param name="axis1">The first axis of the sub-arrays of interest. Ignored when the input is a 1-D array.</param>
    /// <param name="axis2">The second axis of the sub-arrays of interest. Ignored when the input is a 1-D array.</param>
    static member Diag(outputArray : NDArray seq, data : NDArray, [<Optional; DefaultParameterValue(0)>] k : int, [<Optional; DefaultParameterValue(0)>] axis1 : int, [<Optional; DefaultParameterValue(1)>] axis2 : int) =
        let creator = AtomicSymbolCreator.FromName "diag"
        let names = [|"k"; "axis1"; "axis2"|]
        let vals = [|string k; string axis1; string axis2|]
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <summary>Extracts a diagonal or constructs a diagonal array.
    /// 
    /// ``diag``&#39;s behavior depends on the input array dimensions:
    /// 
    /// - 1-D arrays: constructs a 2-D array with the input as its diagonal, all other elements are zero.
    /// - N-D arrays: extracts the diagonals of the sub-arrays with axes specified by ``axis1`` and ``axis2``.
    ///   The output shape would be decided by removing the axes numbered ``axis1`` and ``axis2`` from the
    ///   input shape and appending to the result a new axis with the size of the diagonals in question.
    /// 
    ///   For example, when the input shape is `(2, 3, 4, 5)`, ``axis1`` and ``axis2`` are 0 and 2
    ///   respectively and ``k`` is 0, the resulting shape would be `(3, 5, 2)`.
    /// 
    /// Examples::
    /// 
    ///   x = [[1, 2, 3],
    ///        [4, 5, 6]]
    /// 
    ///   diag(x) = [1, 5]
    /// 
    ///   diag(x, k=1) = [2, 6]
    /// 
    ///   diag(x, k=-1) = [4]
    /// 
    ///   x = [1, 2, 3]
    /// 
    ///   diag(x) = [[1, 0, 0],
    ///              [0, 2, 0],
    ///              [0, 0, 3]]
    /// 
    ///   diag(x, k=1) = [[0, 1, 0],
    ///                   [0, 0, 2],
    ///                   [0, 0, 0]]
    /// 
    ///   diag(x, k=-1) = [[0, 0, 0],
    ///                    [1, 0, 0],
    ///                    [0, 2, 0]]
    /// 
    ///   x = [[[1, 2],
    ///         [3, 4]],
    /// 
    ///        [[5, 6],
    ///         [7, 8]]]
    /// 
    ///   diag(x) = [[1, 7],
    ///              [2, 8]]
    /// 
    ///   diag(x, k=1) = [[3],
    ///                   [4]]
    /// 
    ///   diag(x, axis1=-2, axis2=-1) = [[1, 4],
    ///                                  [5, 8]]
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\diag_op.cc:L87</summary>
    /// <param name="data">Input ndarray</param>
    /// <param name="k">Diagonal in question. The default is 0. Use k&gt;0 for diagonals above the main diagonal, and k&lt;0 for diagonals below the main diagonal. If input has shape (S0 S1) k must be between -S0 and S1</param>
    /// <param name="axis1">The first axis of the sub-arrays of interest. Ignored when the input is a 1-D array.</param>
    /// <param name="axis2">The second axis of the sub-arrays of interest. Ignored when the input is a 1-D array.</param>
    static member Diag([<Optional>] ?data : Symbol, [<Optional>] ?k : int, [<Optional>] ?axis1 : int, [<Optional>] ?axis2 : int) =
        Diag(?data = data, ?k = k, ?axis1 = axis1, ?axis2 = axis2)


    /// <summary>Dot product of two arrays.
    /// 
    /// ``dot``&#39;s behavior depends on the input array dimensions:
    /// 
    /// - 1-D arrays: inner product of vectors
    /// - 2-D arrays: matrix multiplication
    /// - N-D arrays: a sum product over the last axis of the first input and the first
    ///   axis of the second input
    /// 
    ///   For example, given 3-D ``x`` with shape `(n,m,k)` and ``y`` with shape `(k,r,s)`, the
    ///   result array will have shape `(n,m,r,s)`. It is computed by::
    /// 
    ///     dot(x,y)[i,j,a,b] = sum(x[i,j,:]*y[:,a,b])
    /// 
    ///   Example::
    /// 
    ///     x = reshape([0,1,2,3,4,5,6,7], shape=(2,2,2))
    ///     y = reshape([7,6,5,4,3,2,1,0], shape=(2,2,2))
    ///     dot(x,y)[0,0,1,1] = 0
    ///     sum(x[0,0,:]*y[:,1,1]) = 0
    /// 
    /// The storage type of ``dot`` output depends on storage types of inputs, transpose option and
    /// forward_stype option for output storage type. Implemented sparse operations include:
    /// 
    /// - dot(default, default, transpose_a=True/False, transpose_b=True/False) = default
    /// - dot(csr, default, transpose_a=True) = default
    /// - dot(csr, default, transpose_a=True) = row_sparse
    /// - dot(csr, default) = default
    /// - dot(csr, row_sparse) = default
    /// - dot(default, csr) = csr (CPU only)
    /// - dot(default, csr, forward_stype=&#39;default&#39;) = default
    /// - dot(default, csr, transpose_b=True, forward_stype=&#39;default&#39;) = default
    /// 
    /// If the combination of input storage types and forward_stype does not match any of the
    /// above patterns, ``dot`` will fallback and generate output with default storage.
    /// 
    /// .. Note::
    /// 
    ///     If the storage type of the lhs is &quot;csr&quot;, the storage type of gradient w.r.t rhs will be
    ///     &quot;row_sparse&quot;. Only a subset of optimizers support sparse gradients, including SGD, AdaGrad
    ///     and Adam. Note that by default lazy updates is turned on, which may perform differently
    ///     from standard updates. For more details, please check the Optimization API at:
    ///     https://mxnet.incubator.apache.org/api/python/optimization/optimization.html
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\dot.cc:L77</summary>
    /// <param name="lhs">The first input</param>
    /// <param name="rhs">The second input</param>
    /// <param name="transposeA">If true then transpose the first input before dot.</param>
    /// <param name="transposeB">If true then transpose the second input before dot.</param>
    /// <param name="forwardStype">The desired storage type of the forward output given by user, if thecombination of input storage types and this hint does not matchany implemented ones, the dot operator will perform fallback operationand still produce an output of the desired storage type.</param>
    static member Dot(lhs : NDArray, 
                      rhs : NDArray, 
                      [<Optional; DefaultParameterValue(false)>] transposeA : bool, 
                      [<Optional; DefaultParameterValue(false)>] transposeB : bool, 
                      [<Optional>] forwardStype : StorageType) =
        let creator = AtomicSymbolCreator.FromName "dot"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg lhs)) then lhs.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg rhs)) then rhs.UnsafeHandle|]
                                                 [|"transpose_a"; "transpose_b"; "forward_stype"|]
                                                 [|string transposeA; string transposeB; (if isNull (forwardStype :> obj) then "None" else string forwardStype)|]
        (new NDArray(outputs.[0]))
    /// <summary>Dot product of two arrays.
    /// 
    /// ``dot``&#39;s behavior depends on the input array dimensions:
    /// 
    /// - 1-D arrays: inner product of vectors
    /// - 2-D arrays: matrix multiplication
    /// - N-D arrays: a sum product over the last axis of the first input and the first
    ///   axis of the second input
    /// 
    ///   For example, given 3-D ``x`` with shape `(n,m,k)` and ``y`` with shape `(k,r,s)`, the
    ///   result array will have shape `(n,m,r,s)`. It is computed by::
    /// 
    ///     dot(x,y)[i,j,a,b] = sum(x[i,j,:]*y[:,a,b])
    /// 
    ///   Example::
    /// 
    ///     x = reshape([0,1,2,3,4,5,6,7], shape=(2,2,2))
    ///     y = reshape([7,6,5,4,3,2,1,0], shape=(2,2,2))
    ///     dot(x,y)[0,0,1,1] = 0
    ///     sum(x[0,0,:]*y[:,1,1]) = 0
    /// 
    /// The storage type of ``dot`` output depends on storage types of inputs, transpose option and
    /// forward_stype option for output storage type. Implemented sparse operations include:
    /// 
    /// - dot(default, default, transpose_a=True/False, transpose_b=True/False) = default
    /// - dot(csr, default, transpose_a=True) = default
    /// - dot(csr, default, transpose_a=True) = row_sparse
    /// - dot(csr, default) = default
    /// - dot(csr, row_sparse) = default
    /// - dot(default, csr) = csr (CPU only)
    /// - dot(default, csr, forward_stype=&#39;default&#39;) = default
    /// - dot(default, csr, transpose_b=True, forward_stype=&#39;default&#39;) = default
    /// 
    /// If the combination of input storage types and forward_stype does not match any of the
    /// above patterns, ``dot`` will fallback and generate output with default storage.
    /// 
    /// .. Note::
    /// 
    ///     If the storage type of the lhs is &quot;csr&quot;, the storage type of gradient w.r.t rhs will be
    ///     &quot;row_sparse&quot;. Only a subset of optimizers support sparse gradients, including SGD, AdaGrad
    ///     and Adam. Note that by default lazy updates is turned on, which may perform differently
    ///     from standard updates. For more details, please check the Optimization API at:
    ///     https://mxnet.incubator.apache.org/api/python/optimization/optimization.html
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\dot.cc:L77</summary>
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="lhs">The first input</param>
    /// <param name="rhs">The second input</param>
    /// <param name="transposeA">If true then transpose the first input before dot.</param>
    /// <param name="transposeB">If true then transpose the second input before dot.</param>
    /// <param name="forwardStype">The desired storage type of the forward output given by user, if thecombination of input storage types and this hint does not matchany implemented ones, the dot operator will perform fallback operationand still produce an output of the desired storage type.</param>
    static member Dot(outputArray : NDArray seq, 
                      lhs : NDArray, 
                      rhs : NDArray, 
                      [<Optional; DefaultParameterValue(false)>] transposeA : bool, 
                      [<Optional; DefaultParameterValue(false)>] transposeB : bool, 
                      [<Optional>] forwardStype : StorageType) =
        let creator = AtomicSymbolCreator.FromName "dot"
        let names = [|"transpose_a"; "transpose_b"; "forward_stype"|]
        let vals = [|string transposeA; string transposeB; (if isNull (forwardStype :> obj) then "None" else string forwardStype)|]
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg lhs)) then lhs.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg rhs)) then rhs.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <summary>Dot product of two arrays.
    /// 
    /// ``dot``&#39;s behavior depends on the input array dimensions:
    /// 
    /// - 1-D arrays: inner product of vectors
    /// - 2-D arrays: matrix multiplication
    /// - N-D arrays: a sum product over the last axis of the first input and the first
    ///   axis of the second input
    /// 
    ///   For example, given 3-D ``x`` with shape `(n,m,k)` and ``y`` with shape `(k,r,s)`, the
    ///   result array will have shape `(n,m,r,s)`. It is computed by::
    /// 
    ///     dot(x,y)[i,j,a,b] = sum(x[i,j,:]*y[:,a,b])
    /// 
    ///   Example::
    /// 
    ///     x = reshape([0,1,2,3,4,5,6,7], shape=(2,2,2))
    ///     y = reshape([7,6,5,4,3,2,1,0], shape=(2,2,2))
    ///     dot(x,y)[0,0,1,1] = 0
    ///     sum(x[0,0,:]*y[:,1,1]) = 0
    /// 
    /// The storage type of ``dot`` output depends on storage types of inputs, transpose option and
    /// forward_stype option for output storage type. Implemented sparse operations include:
    /// 
    /// - dot(default, default, transpose_a=True/False, transpose_b=True/False) = default
    /// - dot(csr, default, transpose_a=True) = default
    /// - dot(csr, default, transpose_a=True) = row_sparse
    /// - dot(csr, default) = default
    /// - dot(csr, row_sparse) = default
    /// - dot(default, csr) = csr (CPU only)
    /// - dot(default, csr, forward_stype=&#39;default&#39;) = default
    /// - dot(default, csr, transpose_b=True, forward_stype=&#39;default&#39;) = default
    /// 
    /// If the combination of input storage types and forward_stype does not match any of the
    /// above patterns, ``dot`` will fallback and generate output with default storage.
    /// 
    /// .. Note::
    /// 
    ///     If the storage type of the lhs is &quot;csr&quot;, the storage type of gradient w.r.t rhs will be
    ///     &quot;row_sparse&quot;. Only a subset of optimizers support sparse gradients, including SGD, AdaGrad
    ///     and Adam. Note that by default lazy updates is turned on, which may perform differently
    ///     from standard updates. For more details, please check the Optimization API at:
    ///     https://mxnet.incubator.apache.org/api/python/optimization/optimization.html
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\dot.cc:L77</summary>
    /// <param name="lhs">The first input</param>
    /// <param name="rhs">The second input</param>
    /// <param name="transposeA">If true then transpose the first input before dot.</param>
    /// <param name="transposeB">If true then transpose the second input before dot.</param>
    /// <param name="forwardStype">The desired storage type of the forward output given by user, if thecombination of input storage types and this hint does not matchany implemented ones, the dot operator will perform fallback operationand still produce an output of the desired storage type.</param>
    static member Dot([<Optional>] ?lhs : Symbol, [<Optional>] ?rhs : Symbol, [<Optional>] ?transposeA : bool, [<Optional>] ?transposeB : bool, [<Optional>] ?forwardStype : StorageType) =
        Dot(?lhs = lhs, ?rhs = rhs, ?transposeA = transposeA, ?transposeB = transposeB, ?forwardStype = forwardStype)


    /// <summary>Batchwise dot product.
    /// 
    /// ``batch_dot`` is used to compute dot product of ``x`` and ``y`` when ``x`` and
    /// ``y`` are data in batch, namely N-D (N &gt;= 3) arrays in shape of `(B0, ..., B_i, :, :)`.
    /// 
    /// For example, given ``x`` with shape `(B_0, ..., B_i, N, M)` and ``y`` with shape
    /// `(B_0, ..., B_i, M, K)`, the result array will have shape `(B_0, ..., B_i, N, K)`,
    /// which is computed by::
    /// 
    ///    batch_dot(x,y)[b_0, ..., b_i, :, :] = dot(x[b_0, ..., b_i, :, :], y[b_0, ..., b_i, :, :])
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\dot.cc:L127</summary>
    /// <param name="lhs">The first input</param>
    /// <param name="rhs">The second input</param>
    /// <param name="transposeA">If true then transpose the first input before dot.</param>
    /// <param name="transposeB">If true then transpose the second input before dot.</param>
    /// <param name="forwardStype">The desired storage type of the forward output given by user, if thecombination of input storage types and this hint does not matchany implemented ones, the dot operator will perform fallback operationand still produce an output of the desired storage type.</param>
    static member BatchDot(lhs : NDArray, 
                           rhs : NDArray, 
                           [<Optional; DefaultParameterValue(false)>] transposeA : bool, 
                           [<Optional; DefaultParameterValue(false)>] transposeB : bool, 
                           [<Optional>] forwardStype : StorageType) =
        let creator = AtomicSymbolCreator.FromName "batch_dot"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg lhs)) then lhs.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg rhs)) then rhs.UnsafeHandle|]
                                                 [|"transpose_a"; "transpose_b"; "forward_stype"|]
                                                 [|string transposeA; string transposeB; (if isNull (forwardStype :> obj) then "None" else string forwardStype)|]
        (new NDArray(outputs.[0]))
    /// <summary>Batchwise dot product.
    /// 
    /// ``batch_dot`` is used to compute dot product of ``x`` and ``y`` when ``x`` and
    /// ``y`` are data in batch, namely N-D (N &gt;= 3) arrays in shape of `(B0, ..., B_i, :, :)`.
    /// 
    /// For example, given ``x`` with shape `(B_0, ..., B_i, N, M)` and ``y`` with shape
    /// `(B_0, ..., B_i, M, K)`, the result array will have shape `(B_0, ..., B_i, N, K)`,
    /// which is computed by::
    /// 
    ///    batch_dot(x,y)[b_0, ..., b_i, :, :] = dot(x[b_0, ..., b_i, :, :], y[b_0, ..., b_i, :, :])
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\dot.cc:L127</summary>
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="lhs">The first input</param>
    /// <param name="rhs">The second input</param>
    /// <param name="transposeA">If true then transpose the first input before dot.</param>
    /// <param name="transposeB">If true then transpose the second input before dot.</param>
    /// <param name="forwardStype">The desired storage type of the forward output given by user, if thecombination of input storage types and this hint does not matchany implemented ones, the dot operator will perform fallback operationand still produce an output of the desired storage type.</param>
    static member BatchDot(outputArray : NDArray seq, 
                           lhs : NDArray, 
                           rhs : NDArray, 
                           [<Optional; DefaultParameterValue(false)>] transposeA : bool, 
                           [<Optional; DefaultParameterValue(false)>] transposeB : bool, 
                           [<Optional>] forwardStype : StorageType) =
        let creator = AtomicSymbolCreator.FromName "batch_dot"
        let names = [|"transpose_a"; "transpose_b"; "forward_stype"|]
        let vals = [|string transposeA; string transposeB; (if isNull (forwardStype :> obj) then "None" else string forwardStype)|]
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg lhs)) then lhs.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg rhs)) then rhs.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <summary>Batchwise dot product.
    /// 
    /// ``batch_dot`` is used to compute dot product of ``x`` and ``y`` when ``x`` and
    /// ``y`` are data in batch, namely N-D (N &gt;= 3) arrays in shape of `(B0, ..., B_i, :, :)`.
    /// 
    /// For example, given ``x`` with shape `(B_0, ..., B_i, N, M)` and ``y`` with shape
    /// `(B_0, ..., B_i, M, K)`, the result array will have shape `(B_0, ..., B_i, N, K)`,
    /// which is computed by::
    /// 
    ///    batch_dot(x,y)[b_0, ..., b_i, :, :] = dot(x[b_0, ..., b_i, :, :], y[b_0, ..., b_i, :, :])
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\dot.cc:L127</summary>
    /// <param name="lhs">The first input</param>
    /// <param name="rhs">The second input</param>
    /// <param name="transposeA">If true then transpose the first input before dot.</param>
    /// <param name="transposeB">If true then transpose the second input before dot.</param>
    /// <param name="forwardStype">The desired storage type of the forward output given by user, if thecombination of input storage types and this hint does not matchany implemented ones, the dot operator will perform fallback operationand still produce an output of the desired storage type.</param>
    static member BatchDot([<Optional>] ?lhs : Symbol, [<Optional>] ?rhs : Symbol, [<Optional>] ?transposeA : bool, [<Optional>] ?transposeB : bool, [<Optional>] ?forwardStype : StorageType) =
        BatchDot(?lhs = lhs, ?rhs = rhs, ?transposeA = transposeA, ?transposeB = transposeB, ?forwardStype = forwardStype)

    /// <summary>Returns element-wise sum of the input arrays with broadcasting.
    /// 
    /// `broadcast_plus` is an alias to the function `broadcast_add`.
    /// 
    /// Example::
    /// 
    ///    x = [[ 1.,  1.,  1.],
    ///         [ 1.,  1.,  1.]]
    /// 
    ///    y = [[ 0.],
    ///         [ 1.]]
    /// 
    ///    broadcast_add(x, y) = [[ 1.,  1.,  1.],
    ///                           [ 2.,  2.,  2.]]
    /// 
    ///    broadcast_plus(x, y) = [[ 1.,  1.,  1.],
    ///                            [ 2.,  2.,  2.]]
    /// 
    /// Supported sparse operations:
    /// 
    ///    broadcast_add(csr, dense(1D)) = dense
    ///    broadcast_add(dense(1D), csr) = dense
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\elemwise_binary_broadcast_op_basic.cc:L58</summary>
    /// <param name="lhs">First input to the function</param>
    /// <param name="rhs">Second input to the function</param>
    static member BroadcastAdd(lhs : NDArray, rhs : NDArray) =
        let creator = AtomicSymbolCreator.FromName "broadcast_add"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg lhs)) then lhs.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg rhs)) then rhs.UnsafeHandle|]
                                                 Array.empty
                                                 Array.empty
        (new NDArray(outputs.[0]))
    /// <summary>Returns element-wise sum of the input arrays with broadcasting.
    /// 
    /// `broadcast_plus` is an alias to the function `broadcast_add`.
    /// 
    /// Example::
    /// 
    ///    x = [[ 1.,  1.,  1.],
    ///         [ 1.,  1.,  1.]]
    /// 
    ///    y = [[ 0.],
    ///         [ 1.]]
    /// 
    ///    broadcast_add(x, y) = [[ 1.,  1.,  1.],
    ///                           [ 2.,  2.,  2.]]
    /// 
    ///    broadcast_plus(x, y) = [[ 1.,  1.,  1.],
    ///                            [ 2.,  2.,  2.]]
    /// 
    /// Supported sparse operations:
    /// 
    ///    broadcast_add(csr, dense(1D)) = dense
    ///    broadcast_add(dense(1D), csr) = dense
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\elemwise_binary_broadcast_op_basic.cc:L58</summary>
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="lhs">First input to the function</param>
    /// <param name="rhs">Second input to the function</param>
    static member BroadcastAdd(outputArray : NDArray seq, lhs : NDArray, rhs : NDArray) =
        let creator = AtomicSymbolCreator.FromName "broadcast_add"
        let names = Array.empty
        let vals = Array.empty
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg lhs)) then lhs.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg rhs)) then rhs.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <summary>Returns element-wise sum of the input arrays with broadcasting.
    /// 
    /// `broadcast_plus` is an alias to the function `broadcast_add`.
    /// 
    /// Example::
    /// 
    ///    x = [[ 1.,  1.,  1.],
    ///         [ 1.,  1.,  1.]]
    /// 
    ///    y = [[ 0.],
    ///         [ 1.]]
    /// 
    ///    broadcast_add(x, y) = [[ 1.,  1.,  1.],
    ///                           [ 2.,  2.,  2.]]
    /// 
    ///    broadcast_plus(x, y) = [[ 1.,  1.,  1.],
    ///                            [ 2.,  2.,  2.]]
    /// 
    /// Supported sparse operations:
    /// 
    ///    broadcast_add(csr, dense(1D)) = dense
    ///    broadcast_add(dense(1D), csr) = dense
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\elemwise_binary_broadcast_op_basic.cc:L58</summary>
    /// <param name="lhs">First input to the function</param>
    /// <param name="rhs">Second input to the function</param>
    static member BroadcastAdd([<Optional>] ?lhs : Symbol, [<Optional>] ?rhs : Symbol) =
        BroadcastAdd(?lhs = lhs, ?rhs = rhs)


    /// <summary>Returns element-wise difference of the input arrays with broadcasting.
    /// 
    /// `broadcast_minus` is an alias to the function `broadcast_sub`.
    /// 
    /// Example::
    /// 
    ///    x = [[ 1.,  1.,  1.],
    ///         [ 1.,  1.,  1.]]
    /// 
    ///    y = [[ 0.],
    ///         [ 1.]]
    /// 
    ///    broadcast_sub(x, y) = [[ 1.,  1.,  1.],
    ///                           [ 0.,  0.,  0.]]
    /// 
    ///    broadcast_minus(x, y) = [[ 1.,  1.,  1.],
    ///                             [ 0.,  0.,  0.]]
    /// 
    /// Supported sparse operations:
    /// 
    ///    broadcast_sub/minus(csr, dense(1D)) = dense
    ///    broadcast_sub/minus(dense(1D), csr) = dense
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\elemwise_binary_broadcast_op_basic.cc:L106</summary>
    /// <param name="lhs">First input to the function</param>
    /// <param name="rhs">Second input to the function</param>
    static member BroadcastSub(lhs : NDArray, rhs : NDArray) =
        let creator = AtomicSymbolCreator.FromName "broadcast_sub"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg lhs)) then lhs.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg rhs)) then rhs.UnsafeHandle|]
                                                 Array.empty
                                                 Array.empty
        (new NDArray(outputs.[0]))
    /// <summary>Returns element-wise difference of the input arrays with broadcasting.
    /// 
    /// `broadcast_minus` is an alias to the function `broadcast_sub`.
    /// 
    /// Example::
    /// 
    ///    x = [[ 1.,  1.,  1.],
    ///         [ 1.,  1.,  1.]]
    /// 
    ///    y = [[ 0.],
    ///         [ 1.]]
    /// 
    ///    broadcast_sub(x, y) = [[ 1.,  1.,  1.],
    ///                           [ 0.,  0.,  0.]]
    /// 
    ///    broadcast_minus(x, y) = [[ 1.,  1.,  1.],
    ///                             [ 0.,  0.,  0.]]
    /// 
    /// Supported sparse operations:
    /// 
    ///    broadcast_sub/minus(csr, dense(1D)) = dense
    ///    broadcast_sub/minus(dense(1D), csr) = dense
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\elemwise_binary_broadcast_op_basic.cc:L106</summary>
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="lhs">First input to the function</param>
    /// <param name="rhs">Second input to the function</param>
    static member BroadcastSub(outputArray : NDArray seq, lhs : NDArray, rhs : NDArray) =
        let creator = AtomicSymbolCreator.FromName "broadcast_sub"
        let names = Array.empty
        let vals = Array.empty
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg lhs)) then lhs.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg rhs)) then rhs.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <summary>Returns element-wise difference of the input arrays with broadcasting.
    /// 
    /// `broadcast_minus` is an alias to the function `broadcast_sub`.
    /// 
    /// Example::
    /// 
    ///    x = [[ 1.,  1.,  1.],
    ///         [ 1.,  1.,  1.]]
    /// 
    ///    y = [[ 0.],
    ///         [ 1.]]
    /// 
    ///    broadcast_sub(x, y) = [[ 1.,  1.,  1.],
    ///                           [ 0.,  0.,  0.]]
    /// 
    ///    broadcast_minus(x, y) = [[ 1.,  1.,  1.],
    ///                             [ 0.,  0.,  0.]]
    /// 
    /// Supported sparse operations:
    /// 
    ///    broadcast_sub/minus(csr, dense(1D)) = dense
    ///    broadcast_sub/minus(dense(1D), csr) = dense
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\elemwise_binary_broadcast_op_basic.cc:L106</summary>
    /// <param name="lhs">First input to the function</param>
    /// <param name="rhs">Second input to the function</param>
    static member BroadcastSub([<Optional>] ?lhs : Symbol, [<Optional>] ?rhs : Symbol) =
        BroadcastSub(?lhs = lhs, ?rhs = rhs)


    /// <summary>Returns element-wise product of the input arrays with broadcasting.
    /// 
    /// Example::
    /// 
    ///    x = [[ 1.,  1.,  1.],
    ///         [ 1.,  1.,  1.]]
    /// 
    ///    y = [[ 0.],
    ///         [ 1.]]
    /// 
    ///    broadcast_mul(x, y) = [[ 0.,  0.,  0.],
    ///                           [ 1.,  1.,  1.]]
    /// 
    /// Supported sparse operations:
    /// 
    ///    broadcast_mul(csr, dense(1D)) = csr
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\elemwise_binary_broadcast_op_basic.cc:L146</summary>
    /// <param name="lhs">First input to the function</param>
    /// <param name="rhs">Second input to the function</param>
    static member BroadcastMul(lhs : NDArray, rhs : NDArray) =
        let creator = AtomicSymbolCreator.FromName "broadcast_mul"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg lhs)) then lhs.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg rhs)) then rhs.UnsafeHandle|]
                                                 Array.empty
                                                 Array.empty
        (new NDArray(outputs.[0]))
    /// <summary>Returns element-wise product of the input arrays with broadcasting.
    /// 
    /// Example::
    /// 
    ///    x = [[ 1.,  1.,  1.],
    ///         [ 1.,  1.,  1.]]
    /// 
    ///    y = [[ 0.],
    ///         [ 1.]]
    /// 
    ///    broadcast_mul(x, y) = [[ 0.,  0.,  0.],
    ///                           [ 1.,  1.,  1.]]
    /// 
    /// Supported sparse operations:
    /// 
    ///    broadcast_mul(csr, dense(1D)) = csr
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\elemwise_binary_broadcast_op_basic.cc:L146</summary>
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="lhs">First input to the function</param>
    /// <param name="rhs">Second input to the function</param>
    static member BroadcastMul(outputArray : NDArray seq, lhs : NDArray, rhs : NDArray) =
        let creator = AtomicSymbolCreator.FromName "broadcast_mul"
        let names = Array.empty
        let vals = Array.empty
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg lhs)) then lhs.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg rhs)) then rhs.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <summary>Returns element-wise product of the input arrays with broadcasting.
    /// 
    /// Example::
    /// 
    ///    x = [[ 1.,  1.,  1.],
    ///         [ 1.,  1.,  1.]]
    /// 
    ///    y = [[ 0.],
    ///         [ 1.]]
    /// 
    ///    broadcast_mul(x, y) = [[ 0.,  0.,  0.],
    ///                           [ 1.,  1.,  1.]]
    /// 
    /// Supported sparse operations:
    /// 
    ///    broadcast_mul(csr, dense(1D)) = csr
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\elemwise_binary_broadcast_op_basic.cc:L146</summary>
    /// <param name="lhs">First input to the function</param>
    /// <param name="rhs">Second input to the function</param>
    static member BroadcastMul([<Optional>] ?lhs : Symbol, [<Optional>] ?rhs : Symbol) =
        BroadcastMul(?lhs = lhs, ?rhs = rhs)


    /// <summary>Returns element-wise division of the input arrays with broadcasting.
    /// 
    /// Example::
    /// 
    ///    x = [[ 6.,  6.,  6.],
    ///         [ 6.,  6.,  6.]]
    /// 
    ///    y = [[ 2.],
    ///         [ 3.]]
    /// 
    ///    broadcast_div(x, y) = [[ 3.,  3.,  3.],
    ///                           [ 2.,  2.,  2.]]
    /// 
    /// Supported sparse operations:
    /// 
    ///    broadcast_div(csr, dense(1D)) = csr
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\elemwise_binary_broadcast_op_basic.cc:L187</summary>
    /// <param name="lhs">First input to the function</param>
    /// <param name="rhs">Second input to the function</param>
    static member BroadcastDiv(lhs : NDArray, rhs : NDArray) =
        let creator = AtomicSymbolCreator.FromName "broadcast_div"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg lhs)) then lhs.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg rhs)) then rhs.UnsafeHandle|]
                                                 Array.empty
                                                 Array.empty
        (new NDArray(outputs.[0]))
    /// <summary>Returns element-wise division of the input arrays with broadcasting.
    /// 
    /// Example::
    /// 
    ///    x = [[ 6.,  6.,  6.],
    ///         [ 6.,  6.,  6.]]
    /// 
    ///    y = [[ 2.],
    ///         [ 3.]]
    /// 
    ///    broadcast_div(x, y) = [[ 3.,  3.,  3.],
    ///                           [ 2.,  2.,  2.]]
    /// 
    /// Supported sparse operations:
    /// 
    ///    broadcast_div(csr, dense(1D)) = csr
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\elemwise_binary_broadcast_op_basic.cc:L187</summary>
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="lhs">First input to the function</param>
    /// <param name="rhs">Second input to the function</param>
    static member BroadcastDiv(outputArray : NDArray seq, lhs : NDArray, rhs : NDArray) =
        let creator = AtomicSymbolCreator.FromName "broadcast_div"
        let names = Array.empty
        let vals = Array.empty
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg lhs)) then lhs.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg rhs)) then rhs.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <summary>Returns element-wise division of the input arrays with broadcasting.
    /// 
    /// Example::
    /// 
    ///    x = [[ 6.,  6.,  6.],
    ///         [ 6.,  6.,  6.]]
    /// 
    ///    y = [[ 2.],
    ///         [ 3.]]
    /// 
    ///    broadcast_div(x, y) = [[ 3.,  3.,  3.],
    ///                           [ 2.,  2.,  2.]]
    /// 
    /// Supported sparse operations:
    /// 
    ///    broadcast_div(csr, dense(1D)) = csr
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\elemwise_binary_broadcast_op_basic.cc:L187</summary>
    /// <param name="lhs">First input to the function</param>
    /// <param name="rhs">Second input to the function</param>
    static member BroadcastDiv([<Optional>] ?lhs : Symbol, [<Optional>] ?rhs : Symbol) =
        BroadcastDiv(?lhs = lhs, ?rhs = rhs)


    /// <summary>Returns element-wise modulo of the input arrays with broadcasting.
    /// 
    /// Example::
    /// 
    ///    x = [[ 8.,  8.,  8.],
    ///         [ 8.,  8.,  8.]]
    /// 
    ///    y = [[ 2.],
    ///         [ 3.]]
    /// 
    ///    broadcast_mod(x, y) = [[ 0.,  0.,  0.],
    ///                           [ 2.,  2.,  2.]]
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\elemwise_binary_broadcast_op_basic.cc:L222</summary>
    /// <param name="lhs">First input to the function</param>
    /// <param name="rhs">Second input to the function</param>
    static member BroadcastMod(lhs : NDArray, rhs : NDArray) =
        let creator = AtomicSymbolCreator.FromName "broadcast_mod"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg lhs)) then lhs.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg rhs)) then rhs.UnsafeHandle|]
                                                 Array.empty
                                                 Array.empty
        (new NDArray(outputs.[0]))
    /// <summary>Returns element-wise modulo of the input arrays with broadcasting.
    /// 
    /// Example::
    /// 
    ///    x = [[ 8.,  8.,  8.],
    ///         [ 8.,  8.,  8.]]
    /// 
    ///    y = [[ 2.],
    ///         [ 3.]]
    /// 
    ///    broadcast_mod(x, y) = [[ 0.,  0.,  0.],
    ///                           [ 2.,  2.,  2.]]
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\elemwise_binary_broadcast_op_basic.cc:L222</summary>
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="lhs">First input to the function</param>
    /// <param name="rhs">Second input to the function</param>
    static member BroadcastMod(outputArray : NDArray seq, lhs : NDArray, rhs : NDArray) =
        let creator = AtomicSymbolCreator.FromName "broadcast_mod"
        let names = Array.empty
        let vals = Array.empty
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg lhs)) then lhs.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg rhs)) then rhs.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <summary>Returns element-wise modulo of the input arrays with broadcasting.
    /// 
    /// Example::
    /// 
    ///    x = [[ 8.,  8.,  8.],
    ///         [ 8.,  8.,  8.]]
    /// 
    ///    y = [[ 2.],
    ///         [ 3.]]
    /// 
    ///    broadcast_mod(x, y) = [[ 0.,  0.,  0.],
    ///                           [ 2.,  2.,  2.]]
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\elemwise_binary_broadcast_op_basic.cc:L222</summary>
    /// <param name="lhs">First input to the function</param>
    /// <param name="rhs">Second input to the function</param>
    static member BroadcastMod([<Optional>] ?lhs : Symbol, [<Optional>] ?rhs : Symbol) =
        BroadcastMod(?lhs = lhs, ?rhs = rhs)


    /// <summary>Returns result of first array elements raised to powers from second array, element-wise with broadcasting.
    /// 
    /// Example::
    /// 
    ///    x = [[ 1.,  1.,  1.],
    ///         [ 1.,  1.,  1.]]
    /// 
    ///    y = [[ 0.],
    ///         [ 1.]]
    /// 
    ///    broadcast_power(x, y) = [[ 2.,  2.,  2.],
    ///                             [ 4.,  4.,  4.]]
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\elemwise_binary_broadcast_op_extended.cc:L45</summary>
    /// <param name="lhs">First input to the function</param>
    /// <param name="rhs">Second input to the function</param>
    static member BroadcastPower(lhs : NDArray, rhs : NDArray) =
        let creator = AtomicSymbolCreator.FromName "broadcast_power"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg lhs)) then lhs.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg rhs)) then rhs.UnsafeHandle|]
                                                 Array.empty
                                                 Array.empty
        (new NDArray(outputs.[0]))
    /// <summary>Returns result of first array elements raised to powers from second array, element-wise with broadcasting.
    /// 
    /// Example::
    /// 
    ///    x = [[ 1.,  1.,  1.],
    ///         [ 1.,  1.,  1.]]
    /// 
    ///    y = [[ 0.],
    ///         [ 1.]]
    /// 
    ///    broadcast_power(x, y) = [[ 2.,  2.,  2.],
    ///                             [ 4.,  4.,  4.]]
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\elemwise_binary_broadcast_op_extended.cc:L45</summary>
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="lhs">First input to the function</param>
    /// <param name="rhs">Second input to the function</param>
    static member BroadcastPower(outputArray : NDArray seq, lhs : NDArray, rhs : NDArray) =
        let creator = AtomicSymbolCreator.FromName "broadcast_power"
        let names = Array.empty
        let vals = Array.empty
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg lhs)) then lhs.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg rhs)) then rhs.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <summary>Returns result of first array elements raised to powers from second array, element-wise with broadcasting.
    /// 
    /// Example::
    /// 
    ///    x = [[ 1.,  1.,  1.],
    ///         [ 1.,  1.,  1.]]
    /// 
    ///    y = [[ 0.],
    ///         [ 1.]]
    /// 
    ///    broadcast_power(x, y) = [[ 2.,  2.,  2.],
    ///                             [ 4.,  4.,  4.]]
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\elemwise_binary_broadcast_op_extended.cc:L45</summary>
    /// <param name="lhs">First input to the function</param>
    /// <param name="rhs">Second input to the function</param>
    static member BroadcastPower([<Optional>] ?lhs : Symbol, [<Optional>] ?rhs : Symbol) =
        BroadcastPower(?lhs = lhs, ?rhs = rhs)


    /// <summary>Returns element-wise maximum of the input arrays with broadcasting.
    /// 
    /// This function compares two input arrays and returns a new array having the element-wise maxima.
    /// 
    /// Example::
    /// 
    ///    x = [[ 1.,  1.,  1.],
    ///         [ 1.,  1.,  1.]]
    /// 
    ///    y = [[ 0.],
    ///         [ 1.]]
    /// 
    ///    broadcast_maximum(x, y) = [[ 1.,  1.,  1.],
    ///                               [ 1.,  1.,  1.]]
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\elemwise_binary_broadcast_op_extended.cc:L81</summary>
    /// <param name="lhs">First input to the function</param>
    /// <param name="rhs">Second input to the function</param>
    static member BroadcastMaximum(lhs : NDArray, rhs : NDArray) =
        let creator = AtomicSymbolCreator.FromName "broadcast_maximum"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg lhs)) then lhs.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg rhs)) then rhs.UnsafeHandle|]
                                                 Array.empty
                                                 Array.empty
        (new NDArray(outputs.[0]))
    /// <summary>Returns element-wise maximum of the input arrays with broadcasting.
    /// 
    /// This function compares two input arrays and returns a new array having the element-wise maxima.
    /// 
    /// Example::
    /// 
    ///    x = [[ 1.,  1.,  1.],
    ///         [ 1.,  1.,  1.]]
    /// 
    ///    y = [[ 0.],
    ///         [ 1.]]
    /// 
    ///    broadcast_maximum(x, y) = [[ 1.,  1.,  1.],
    ///                               [ 1.,  1.,  1.]]
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\elemwise_binary_broadcast_op_extended.cc:L81</summary>
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="lhs">First input to the function</param>
    /// <param name="rhs">Second input to the function</param>
    static member BroadcastMaximum(outputArray : NDArray seq, lhs : NDArray, rhs : NDArray) =
        let creator = AtomicSymbolCreator.FromName "broadcast_maximum"
        let names = Array.empty
        let vals = Array.empty
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg lhs)) then lhs.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg rhs)) then rhs.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <summary>Returns element-wise maximum of the input arrays with broadcasting.
    /// 
    /// This function compares two input arrays and returns a new array having the element-wise maxima.
    /// 
    /// Example::
    /// 
    ///    x = [[ 1.,  1.,  1.],
    ///         [ 1.,  1.,  1.]]
    /// 
    ///    y = [[ 0.],
    ///         [ 1.]]
    /// 
    ///    broadcast_maximum(x, y) = [[ 1.,  1.,  1.],
    ///                               [ 1.,  1.,  1.]]
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\elemwise_binary_broadcast_op_extended.cc:L81</summary>
    /// <param name="lhs">First input to the function</param>
    /// <param name="rhs">Second input to the function</param>
    static member BroadcastMaximum([<Optional>] ?lhs : Symbol, [<Optional>] ?rhs : Symbol) =
        BroadcastMaximum(?lhs = lhs, ?rhs = rhs)


    /// <summary>Returns element-wise minimum of the input arrays with broadcasting.
    /// 
    /// This function compares two input arrays and returns a new array having the element-wise minima.
    /// 
    /// Example::
    /// 
    ///    x = [[ 1.,  1.,  1.],
    ///         [ 1.,  1.,  1.]]
    /// 
    ///    y = [[ 0.],
    ///         [ 1.]]
    /// 
    ///    broadcast_maximum(x, y) = [[ 0.,  0.,  0.],
    ///                               [ 1.,  1.,  1.]]
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\elemwise_binary_broadcast_op_extended.cc:L117</summary>
    /// <param name="lhs">First input to the function</param>
    /// <param name="rhs">Second input to the function</param>
    static member BroadcastMinimum(lhs : NDArray, rhs : NDArray) =
        let creator = AtomicSymbolCreator.FromName "broadcast_minimum"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg lhs)) then lhs.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg rhs)) then rhs.UnsafeHandle|]
                                                 Array.empty
                                                 Array.empty
        (new NDArray(outputs.[0]))
    /// <summary>Returns element-wise minimum of the input arrays with broadcasting.
    /// 
    /// This function compares two input arrays and returns a new array having the element-wise minima.
    /// 
    /// Example::
    /// 
    ///    x = [[ 1.,  1.,  1.],
    ///         [ 1.,  1.,  1.]]
    /// 
    ///    y = [[ 0.],
    ///         [ 1.]]
    /// 
    ///    broadcast_maximum(x, y) = [[ 0.,  0.,  0.],
    ///                               [ 1.,  1.,  1.]]
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\elemwise_binary_broadcast_op_extended.cc:L117</summary>
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="lhs">First input to the function</param>
    /// <param name="rhs">Second input to the function</param>
    static member BroadcastMinimum(outputArray : NDArray seq, lhs : NDArray, rhs : NDArray) =
        let creator = AtomicSymbolCreator.FromName "broadcast_minimum"
        let names = Array.empty
        let vals = Array.empty
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg lhs)) then lhs.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg rhs)) then rhs.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <summary>Returns element-wise minimum of the input arrays with broadcasting.
    /// 
    /// This function compares two input arrays and returns a new array having the element-wise minima.
    /// 
    /// Example::
    /// 
    ///    x = [[ 1.,  1.,  1.],
    ///         [ 1.,  1.,  1.]]
    /// 
    ///    y = [[ 0.],
    ///         [ 1.]]
    /// 
    ///    broadcast_maximum(x, y) = [[ 0.,  0.,  0.],
    ///                               [ 1.,  1.,  1.]]
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\elemwise_binary_broadcast_op_extended.cc:L117</summary>
    /// <param name="lhs">First input to the function</param>
    /// <param name="rhs">Second input to the function</param>
    static member BroadcastMinimum([<Optional>] ?lhs : Symbol, [<Optional>] ?rhs : Symbol) =
        BroadcastMinimum(?lhs = lhs, ?rhs = rhs)


    /// <summary> Returns the hypotenuse of a right angled triangle, given its &quot;legs&quot;
    /// with broadcasting.
    /// 
    /// It is equivalent to doing :math:`sqrt(x_1^2 + x_2^2)`.
    /// 
    /// Example::
    /// 
    ///    x = [[ 3.,  3.,  3.]]
    /// 
    ///    y = [[ 4.],
    ///         [ 4.]]
    /// 
    ///    broadcast_hypot(x, y) = [[ 5.,  5.,  5.],
    ///                             [ 5.,  5.,  5.]]
    /// 
    ///    z = [[ 0.],
    ///         [ 4.]]
    /// 
    ///    broadcast_hypot(x, z) = [[ 3.,  3.,  3.],
    ///                             [ 5.,  5.,  5.]]
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\elemwise_binary_broadcast_op_extended.cc:L158</summary>
    /// <param name="lhs">First input to the function</param>
    /// <param name="rhs">Second input to the function</param>
    static member BroadcastHypot(lhs : NDArray, rhs : NDArray) =
        let creator = AtomicSymbolCreator.FromName "broadcast_hypot"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg lhs)) then lhs.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg rhs)) then rhs.UnsafeHandle|]
                                                 Array.empty
                                                 Array.empty
        (new NDArray(outputs.[0]))
    /// <summary> Returns the hypotenuse of a right angled triangle, given its &quot;legs&quot;
    /// with broadcasting.
    /// 
    /// It is equivalent to doing :math:`sqrt(x_1^2 + x_2^2)`.
    /// 
    /// Example::
    /// 
    ///    x = [[ 3.,  3.,  3.]]
    /// 
    ///    y = [[ 4.],
    ///         [ 4.]]
    /// 
    ///    broadcast_hypot(x, y) = [[ 5.,  5.,  5.],
    ///                             [ 5.,  5.,  5.]]
    /// 
    ///    z = [[ 0.],
    ///         [ 4.]]
    /// 
    ///    broadcast_hypot(x, z) = [[ 3.,  3.,  3.],
    ///                             [ 5.,  5.,  5.]]
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\elemwise_binary_broadcast_op_extended.cc:L158</summary>
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="lhs">First input to the function</param>
    /// <param name="rhs">Second input to the function</param>
    static member BroadcastHypot(outputArray : NDArray seq, lhs : NDArray, rhs : NDArray) =
        let creator = AtomicSymbolCreator.FromName "broadcast_hypot"
        let names = Array.empty
        let vals = Array.empty
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg lhs)) then lhs.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg rhs)) then rhs.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <summary> Returns the hypotenuse of a right angled triangle, given its &quot;legs&quot;
    /// with broadcasting.
    /// 
    /// It is equivalent to doing :math:`sqrt(x_1^2 + x_2^2)`.
    /// 
    /// Example::
    /// 
    ///    x = [[ 3.,  3.,  3.]]
    /// 
    ///    y = [[ 4.],
    ///         [ 4.]]
    /// 
    ///    broadcast_hypot(x, y) = [[ 5.,  5.,  5.],
    ///                             [ 5.,  5.,  5.]]
    /// 
    ///    z = [[ 0.],
    ///         [ 4.]]
    /// 
    ///    broadcast_hypot(x, z) = [[ 3.,  3.,  3.],
    ///                             [ 5.,  5.,  5.]]
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\elemwise_binary_broadcast_op_extended.cc:L158</summary>
    /// <param name="lhs">First input to the function</param>
    /// <param name="rhs">Second input to the function</param>
    static member BroadcastHypot([<Optional>] ?lhs : Symbol, [<Optional>] ?rhs : Symbol) =
        BroadcastHypot(?lhs = lhs, ?rhs = rhs)


    /// <summary>Returns the result of element-wise **equal to** (==) comparison operation with broadcasting.
    /// 
    /// Example::
    /// 
    ///    x = [[ 1.,  1.,  1.],
    ///         [ 1.,  1.,  1.]]
    /// 
    ///    y = [[ 0.],
    ///         [ 1.]]
    /// 
    ///    broadcast_equal(x, y) = [[ 0.,  0.,  0.],
    ///                             [ 1.,  1.,  1.]]
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\elemwise_binary_broadcast_op_logic.cc:L46</summary>
    /// <param name="lhs">First input to the function</param>
    /// <param name="rhs">Second input to the function</param>
    static member BroadcastEqual(lhs : NDArray, rhs : NDArray) =
        let creator = AtomicSymbolCreator.FromName "broadcast_equal"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg lhs)) then lhs.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg rhs)) then rhs.UnsafeHandle|]
                                                 Array.empty
                                                 Array.empty
        (new NDArray(outputs.[0]))
    /// <summary>Returns the result of element-wise **equal to** (==) comparison operation with broadcasting.
    /// 
    /// Example::
    /// 
    ///    x = [[ 1.,  1.,  1.],
    ///         [ 1.,  1.,  1.]]
    /// 
    ///    y = [[ 0.],
    ///         [ 1.]]
    /// 
    ///    broadcast_equal(x, y) = [[ 0.,  0.,  0.],
    ///                             [ 1.,  1.,  1.]]
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\elemwise_binary_broadcast_op_logic.cc:L46</summary>
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="lhs">First input to the function</param>
    /// <param name="rhs">Second input to the function</param>
    static member BroadcastEqual(outputArray : NDArray seq, lhs : NDArray, rhs : NDArray) =
        let creator = AtomicSymbolCreator.FromName "broadcast_equal"
        let names = Array.empty
        let vals = Array.empty
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg lhs)) then lhs.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg rhs)) then rhs.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <summary>Returns the result of element-wise **equal to** (==) comparison operation with broadcasting.
    /// 
    /// Example::
    /// 
    ///    x = [[ 1.,  1.,  1.],
    ///         [ 1.,  1.,  1.]]
    /// 
    ///    y = [[ 0.],
    ///         [ 1.]]
    /// 
    ///    broadcast_equal(x, y) = [[ 0.,  0.,  0.],
    ///                             [ 1.,  1.,  1.]]
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\elemwise_binary_broadcast_op_logic.cc:L46</summary>
    /// <param name="lhs">First input to the function</param>
    /// <param name="rhs">Second input to the function</param>
    static member BroadcastEqual([<Optional>] ?lhs : Symbol, [<Optional>] ?rhs : Symbol) =
        BroadcastEqual(?lhs = lhs, ?rhs = rhs)

    /// <summary>Returns the result of element-wise **not equal to** (!=) comparison operation with broadcasting.
    /// 
    /// Example::
    /// 
    ///    x = [[ 1.,  1.,  1.],
    ///         [ 1.,  1.,  1.]]
    /// 
    ///    y = [[ 0.],
    ///         [ 1.]]
    /// 
    ///    broadcast_not_equal(x, y) = [[ 1.,  1.,  1.],
    ///                                 [ 0.,  0.,  0.]]
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\elemwise_binary_broadcast_op_logic.cc:L64</summary>
    /// <param name="lhs">First input to the function</param>
    /// <param name="rhs">Second input to the function</param>
    static member BroadcastNotEqual(lhs : NDArray, rhs : NDArray) =
        let creator = AtomicSymbolCreator.FromName "broadcast_not_equal"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg lhs)) then lhs.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg rhs)) then rhs.UnsafeHandle|]
                                                 Array.empty
                                                 Array.empty
        (new NDArray(outputs.[0]))
    /// <summary>Returns the result of element-wise **not equal to** (!=) comparison operation with broadcasting.
    /// 
    /// Example::
    /// 
    ///    x = [[ 1.,  1.,  1.],
    ///         [ 1.,  1.,  1.]]
    /// 
    ///    y = [[ 0.],
    ///         [ 1.]]
    /// 
    ///    broadcast_not_equal(x, y) = [[ 1.,  1.,  1.],
    ///                                 [ 0.,  0.,  0.]]
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\elemwise_binary_broadcast_op_logic.cc:L64</summary>
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="lhs">First input to the function</param>
    /// <param name="rhs">Second input to the function</param>
    static member BroadcastNotEqual(outputArray : NDArray seq, lhs : NDArray, rhs : NDArray) =
        let creator = AtomicSymbolCreator.FromName "broadcast_not_equal"
        let names = Array.empty
        let vals = Array.empty
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg lhs)) then lhs.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg rhs)) then rhs.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <summary>Returns the result of element-wise **not equal to** (!=) comparison operation with broadcasting.
    /// 
    /// Example::
    /// 
    ///    x = [[ 1.,  1.,  1.],
    ///         [ 1.,  1.,  1.]]
    /// 
    ///    y = [[ 0.],
    ///         [ 1.]]
    /// 
    ///    broadcast_not_equal(x, y) = [[ 1.,  1.,  1.],
    ///                                 [ 0.,  0.,  0.]]
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\elemwise_binary_broadcast_op_logic.cc:L64</summary>
    /// <param name="lhs">First input to the function</param>
    /// <param name="rhs">Second input to the function</param>
    static member BroadcastNotEqual([<Optional>] ?lhs : Symbol, [<Optional>] ?rhs : Symbol) =
        BroadcastNotEqual(?lhs = lhs, ?rhs = rhs)

    /// <summary>Returns the result of element-wise **greater than** (&gt;) comparison operation with broadcasting.
    /// 
    /// Example::
    /// 
    ///    x = [[ 1.,  1.,  1.],
    ///         [ 1.,  1.,  1.]]
    /// 
    ///    y = [[ 0.],
    ///         [ 1.]]
    /// 
    ///    broadcast_greater(x, y) = [[ 1.,  1.,  1.],
    ///                               [ 0.,  0.,  0.]]
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\elemwise_binary_broadcast_op_logic.cc:L82</summary>
    /// <param name="lhs">First input to the function</param>
    /// <param name="rhs">Second input to the function</param>
    static member BroadcastGreater(lhs : NDArray, rhs : NDArray) =
        let creator = AtomicSymbolCreator.FromName "broadcast_greater"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg lhs)) then lhs.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg rhs)) then rhs.UnsafeHandle|]
                                                 Array.empty
                                                 Array.empty
        (new NDArray(outputs.[0]))
    /// <summary>Returns the result of element-wise **greater than** (&gt;) comparison operation with broadcasting.
    /// 
    /// Example::
    /// 
    ///    x = [[ 1.,  1.,  1.],
    ///         [ 1.,  1.,  1.]]
    /// 
    ///    y = [[ 0.],
    ///         [ 1.]]
    /// 
    ///    broadcast_greater(x, y) = [[ 1.,  1.,  1.],
    ///                               [ 0.,  0.,  0.]]
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\elemwise_binary_broadcast_op_logic.cc:L82</summary>
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="lhs">First input to the function</param>
    /// <param name="rhs">Second input to the function</param>
    static member BroadcastGreater(outputArray : NDArray seq, lhs : NDArray, rhs : NDArray) =
        let creator = AtomicSymbolCreator.FromName "broadcast_greater"
        let names = Array.empty
        let vals = Array.empty
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg lhs)) then lhs.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg rhs)) then rhs.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <summary>Returns the result of element-wise **greater than** (&gt;) comparison operation with broadcasting.
    /// 
    /// Example::
    /// 
    ///    x = [[ 1.,  1.,  1.],
    ///         [ 1.,  1.,  1.]]
    /// 
    ///    y = [[ 0.],
    ///         [ 1.]]
    /// 
    ///    broadcast_greater(x, y) = [[ 1.,  1.,  1.],
    ///                               [ 0.,  0.,  0.]]
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\elemwise_binary_broadcast_op_logic.cc:L82</summary>
    /// <param name="lhs">First input to the function</param>
    /// <param name="rhs">Second input to the function</param>
    static member BroadcastGreater([<Optional>] ?lhs : Symbol, [<Optional>] ?rhs : Symbol) =
        BroadcastGreater(?lhs = lhs, ?rhs = rhs)

    /// <summary>Returns the result of element-wise **greater than or equal to** (&gt;=) comparison operation with broadcasting.
    /// 
    /// Example::
    /// 
    ///    x = [[ 1.,  1.,  1.],
    ///         [ 1.,  1.,  1.]]
    /// 
    ///    y = [[ 0.],
    ///         [ 1.]]
    /// 
    ///    broadcast_greater_equal(x, y) = [[ 1.,  1.,  1.],
    ///                                     [ 1.,  1.,  1.]]
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\elemwise_binary_broadcast_op_logic.cc:L100</summary>
    /// <param name="lhs">First input to the function</param>
    /// <param name="rhs">Second input to the function</param>
    static member BroadcastGreaterEqual(lhs : NDArray, rhs : NDArray) =
        let creator = AtomicSymbolCreator.FromName "broadcast_greater_equal"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg lhs)) then lhs.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg rhs)) then rhs.UnsafeHandle|]
                                                 Array.empty
                                                 Array.empty
        (new NDArray(outputs.[0]))
    /// <summary>Returns the result of element-wise **greater than or equal to** (&gt;=) comparison operation with broadcasting.
    /// 
    /// Example::
    /// 
    ///    x = [[ 1.,  1.,  1.],
    ///         [ 1.,  1.,  1.]]
    /// 
    ///    y = [[ 0.],
    ///         [ 1.]]
    /// 
    ///    broadcast_greater_equal(x, y) = [[ 1.,  1.,  1.],
    ///                                     [ 1.,  1.,  1.]]
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\elemwise_binary_broadcast_op_logic.cc:L100</summary>
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="lhs">First input to the function</param>
    /// <param name="rhs">Second input to the function</param>
    static member BroadcastGreaterEqual(outputArray : NDArray seq, lhs : NDArray, rhs : NDArray) =
        let creator = AtomicSymbolCreator.FromName "broadcast_greater_equal"
        let names = Array.empty
        let vals = Array.empty
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg lhs)) then lhs.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg rhs)) then rhs.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <summary>Returns the result of element-wise **greater than or equal to** (&gt;=) comparison operation with broadcasting.
    /// 
    /// Example::
    /// 
    ///    x = [[ 1.,  1.,  1.],
    ///         [ 1.,  1.,  1.]]
    /// 
    ///    y = [[ 0.],
    ///         [ 1.]]
    /// 
    ///    broadcast_greater_equal(x, y) = [[ 1.,  1.,  1.],
    ///                                     [ 1.,  1.,  1.]]
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\elemwise_binary_broadcast_op_logic.cc:L100</summary>
    /// <param name="lhs">First input to the function</param>
    /// <param name="rhs">Second input to the function</param>
    static member BroadcastGreaterEqual([<Optional>] ?lhs : Symbol, [<Optional>] ?rhs : Symbol) =
        BroadcastGreaterEqual(?lhs = lhs, ?rhs = rhs)

    /// <summary>Returns the result of element-wise **lesser than** (&lt;) comparison operation with broadcasting.
    /// 
    /// Example::
    /// 
    ///    x = [[ 1.,  1.,  1.],
    ///         [ 1.,  1.,  1.]]
    /// 
    ///    y = [[ 0.],
    ///         [ 1.]]
    /// 
    ///    broadcast_lesser(x, y) = [[ 0.,  0.,  0.],
    ///                              [ 0.,  0.,  0.]]
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\elemwise_binary_broadcast_op_logic.cc:L118</summary>
    /// <param name="lhs">First input to the function</param>
    /// <param name="rhs">Second input to the function</param>
    static member BroadcastLesser(lhs : NDArray, rhs : NDArray) =
        let creator = AtomicSymbolCreator.FromName "broadcast_lesser"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg lhs)) then lhs.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg rhs)) then rhs.UnsafeHandle|]
                                                 Array.empty
                                                 Array.empty
        (new NDArray(outputs.[0]))
    /// <summary>Returns the result of element-wise **lesser than** (&lt;) comparison operation with broadcasting.
    /// 
    /// Example::
    /// 
    ///    x = [[ 1.,  1.,  1.],
    ///         [ 1.,  1.,  1.]]
    /// 
    ///    y = [[ 0.],
    ///         [ 1.]]
    /// 
    ///    broadcast_lesser(x, y) = [[ 0.,  0.,  0.],
    ///                              [ 0.,  0.,  0.]]
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\elemwise_binary_broadcast_op_logic.cc:L118</summary>
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="lhs">First input to the function</param>
    /// <param name="rhs">Second input to the function</param>
    static member BroadcastLesser(outputArray : NDArray seq, lhs : NDArray, rhs : NDArray) =
        let creator = AtomicSymbolCreator.FromName "broadcast_lesser"
        let names = Array.empty
        let vals = Array.empty
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg lhs)) then lhs.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg rhs)) then rhs.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <summary>Returns the result of element-wise **lesser than** (&lt;) comparison operation with broadcasting.
    /// 
    /// Example::
    /// 
    ///    x = [[ 1.,  1.,  1.],
    ///         [ 1.,  1.,  1.]]
    /// 
    ///    y = [[ 0.],
    ///         [ 1.]]
    /// 
    ///    broadcast_lesser(x, y) = [[ 0.,  0.,  0.],
    ///                              [ 0.,  0.,  0.]]
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\elemwise_binary_broadcast_op_logic.cc:L118</summary>
    /// <param name="lhs">First input to the function</param>
    /// <param name="rhs">Second input to the function</param>
    static member BroadcastLesser([<Optional>] ?lhs : Symbol, [<Optional>] ?rhs : Symbol) =
        BroadcastLesser(?lhs = lhs, ?rhs = rhs)

    /// <summary>Returns the result of element-wise **lesser than or equal to** (&lt;=) comparison operation with broadcasting.
    /// 
    /// Example::
    /// 
    ///    x = [[ 1.,  1.,  1.],
    ///         [ 1.,  1.,  1.]]
    /// 
    ///    y = [[ 0.],
    ///         [ 1.]]
    /// 
    ///    broadcast_lesser_equal(x, y) = [[ 0.,  0.,  0.],
    ///                                    [ 1.,  1.,  1.]]
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\elemwise_binary_broadcast_op_logic.cc:L136</summary>
    /// <param name="lhs">First input to the function</param>
    /// <param name="rhs">Second input to the function</param>
    static member BroadcastLesserEqual(lhs : NDArray, rhs : NDArray) =
        let creator = AtomicSymbolCreator.FromName "broadcast_lesser_equal"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg lhs)) then lhs.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg rhs)) then rhs.UnsafeHandle|]
                                                 Array.empty
                                                 Array.empty
        (new NDArray(outputs.[0]))
    /// <summary>Returns the result of element-wise **lesser than or equal to** (&lt;=) comparison operation with broadcasting.
    /// 
    /// Example::
    /// 
    ///    x = [[ 1.,  1.,  1.],
    ///         [ 1.,  1.,  1.]]
    /// 
    ///    y = [[ 0.],
    ///         [ 1.]]
    /// 
    ///    broadcast_lesser_equal(x, y) = [[ 0.,  0.,  0.],
    ///                                    [ 1.,  1.,  1.]]
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\elemwise_binary_broadcast_op_logic.cc:L136</summary>
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="lhs">First input to the function</param>
    /// <param name="rhs">Second input to the function</param>
    static member BroadcastLesserEqual(outputArray : NDArray seq, lhs : NDArray, rhs : NDArray) =
        let creator = AtomicSymbolCreator.FromName "broadcast_lesser_equal"
        let names = Array.empty
        let vals = Array.empty
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg lhs)) then lhs.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg rhs)) then rhs.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <summary>Returns the result of element-wise **lesser than or equal to** (&lt;=) comparison operation with broadcasting.
    /// 
    /// Example::
    /// 
    ///    x = [[ 1.,  1.,  1.],
    ///         [ 1.,  1.,  1.]]
    /// 
    ///    y = [[ 0.],
    ///         [ 1.]]
    /// 
    ///    broadcast_lesser_equal(x, y) = [[ 0.,  0.,  0.],
    ///                                    [ 1.,  1.,  1.]]
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\elemwise_binary_broadcast_op_logic.cc:L136</summary>
    /// <param name="lhs">First input to the function</param>
    /// <param name="rhs">Second input to the function</param>
    static member BroadcastLesserEqual([<Optional>] ?lhs : Symbol, [<Optional>] ?rhs : Symbol) =
        BroadcastLesserEqual(?lhs = lhs, ?rhs = rhs)

    /// <summary>Returns the result of element-wise **logical and** with broadcasting.
    /// 
    /// Example::
    /// 
    ///    x = [[ 1.,  1.,  1.],
    ///         [ 1.,  1.,  1.]]
    /// 
    ///    y = [[ 0.],
    ///         [ 1.]]
    /// 
    ///    broadcast_logical_and(x, y) = [[ 0.,  0.,  0.],
    ///                                   [ 1.,  1.,  1.]]
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\elemwise_binary_broadcast_op_logic.cc:L154</summary>
    /// <param name="lhs">First input to the function</param>
    /// <param name="rhs">Second input to the function</param>
    static member BroadcastLogicalAnd(lhs : NDArray, rhs : NDArray) =
        let creator = AtomicSymbolCreator.FromName "broadcast_logical_and"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg lhs)) then lhs.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg rhs)) then rhs.UnsafeHandle|]
                                                 Array.empty
                                                 Array.empty
        (new NDArray(outputs.[0]))
    /// <summary>Returns the result of element-wise **logical and** with broadcasting.
    /// 
    /// Example::
    /// 
    ///    x = [[ 1.,  1.,  1.],
    ///         [ 1.,  1.,  1.]]
    /// 
    ///    y = [[ 0.],
    ///         [ 1.]]
    /// 
    ///    broadcast_logical_and(x, y) = [[ 0.,  0.,  0.],
    ///                                   [ 1.,  1.,  1.]]
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\elemwise_binary_broadcast_op_logic.cc:L154</summary>
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="lhs">First input to the function</param>
    /// <param name="rhs">Second input to the function</param>
    static member BroadcastLogicalAnd(outputArray : NDArray seq, lhs : NDArray, rhs : NDArray) =
        let creator = AtomicSymbolCreator.FromName "broadcast_logical_and"
        let names = Array.empty
        let vals = Array.empty
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg lhs)) then lhs.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg rhs)) then rhs.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <summary>Returns the result of element-wise **logical and** with broadcasting.
    /// 
    /// Example::
    /// 
    ///    x = [[ 1.,  1.,  1.],
    ///         [ 1.,  1.,  1.]]
    /// 
    ///    y = [[ 0.],
    ///         [ 1.]]
    /// 
    ///    broadcast_logical_and(x, y) = [[ 0.,  0.,  0.],
    ///                                   [ 1.,  1.,  1.]]
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\elemwise_binary_broadcast_op_logic.cc:L154</summary>
    /// <param name="lhs">First input to the function</param>
    /// <param name="rhs">Second input to the function</param>
    static member BroadcastLogicalAnd([<Optional>] ?lhs : Symbol, [<Optional>] ?rhs : Symbol) =
        BroadcastLogicalAnd(?lhs = lhs, ?rhs = rhs)

    /// <summary>Returns the result of element-wise **logical or** with broadcasting.
    /// 
    /// Example::
    /// 
    ///    x = [[ 1.,  1.,  0.],
    ///         [ 1.,  1.,  0.]]
    /// 
    ///    y = [[ 1.],
    ///         [ 0.]]
    /// 
    ///    broadcast_logical_or(x, y) = [[ 1.,  1.,  1.],
    ///                                  [ 1.,  1.,  0.]]
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\elemwise_binary_broadcast_op_logic.cc:L172</summary>
    /// <param name="lhs">First input to the function</param>
    /// <param name="rhs">Second input to the function</param>
    static member BroadcastLogicalOr(lhs : NDArray, rhs : NDArray) =
        let creator = AtomicSymbolCreator.FromName "broadcast_logical_or"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg lhs)) then lhs.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg rhs)) then rhs.UnsafeHandle|]
                                                 Array.empty
                                                 Array.empty
        (new NDArray(outputs.[0]))
    /// <summary>Returns the result of element-wise **logical or** with broadcasting.
    /// 
    /// Example::
    /// 
    ///    x = [[ 1.,  1.,  0.],
    ///         [ 1.,  1.,  0.]]
    /// 
    ///    y = [[ 1.],
    ///         [ 0.]]
    /// 
    ///    broadcast_logical_or(x, y) = [[ 1.,  1.,  1.],
    ///                                  [ 1.,  1.,  0.]]
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\elemwise_binary_broadcast_op_logic.cc:L172</summary>
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="lhs">First input to the function</param>
    /// <param name="rhs">Second input to the function</param>
    static member BroadcastLogicalOr(outputArray : NDArray seq, lhs : NDArray, rhs : NDArray) =
        let creator = AtomicSymbolCreator.FromName "broadcast_logical_or"
        let names = Array.empty
        let vals = Array.empty
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg lhs)) then lhs.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg rhs)) then rhs.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <summary>Returns the result of element-wise **logical or** with broadcasting.
    /// 
    /// Example::
    /// 
    ///    x = [[ 1.,  1.,  0.],
    ///         [ 1.,  1.,  0.]]
    /// 
    ///    y = [[ 1.],
    ///         [ 0.]]
    /// 
    ///    broadcast_logical_or(x, y) = [[ 1.,  1.,  1.],
    ///                                  [ 1.,  1.,  0.]]
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\elemwise_binary_broadcast_op_logic.cc:L172</summary>
    /// <param name="lhs">First input to the function</param>
    /// <param name="rhs">Second input to the function</param>
    static member BroadcastLogicalOr([<Optional>] ?lhs : Symbol, [<Optional>] ?rhs : Symbol) =
        BroadcastLogicalOr(?lhs = lhs, ?rhs = rhs)

    /// <summary>Returns the result of element-wise **logical xor** with broadcasting.
    /// 
    /// Example::
    /// 
    ///    x = [[ 1.,  1.,  0.],
    ///         [ 1.,  1.,  0.]]
    /// 
    ///    y = [[ 1.],
    ///         [ 0.]]
    /// 
    ///    broadcast_logical_xor(x, y) = [[ 0.,  0.,  1.],
    ///                                   [ 1.,  1.,  0.]]
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\elemwise_binary_broadcast_op_logic.cc:L190</summary>
    /// <param name="lhs">First input to the function</param>
    /// <param name="rhs">Second input to the function</param>
    static member BroadcastLogicalXor(lhs : NDArray, rhs : NDArray) =
        let creator = AtomicSymbolCreator.FromName "broadcast_logical_xor"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg lhs)) then lhs.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg rhs)) then rhs.UnsafeHandle|]
                                                 Array.empty
                                                 Array.empty
        (new NDArray(outputs.[0]))
    /// <summary>Returns the result of element-wise **logical xor** with broadcasting.
    /// 
    /// Example::
    /// 
    ///    x = [[ 1.,  1.,  0.],
    ///         [ 1.,  1.,  0.]]
    /// 
    ///    y = [[ 1.],
    ///         [ 0.]]
    /// 
    ///    broadcast_logical_xor(x, y) = [[ 0.,  0.,  1.],
    ///                                   [ 1.,  1.,  0.]]
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\elemwise_binary_broadcast_op_logic.cc:L190</summary>
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="lhs">First input to the function</param>
    /// <param name="rhs">Second input to the function</param>
    static member BroadcastLogicalXor(outputArray : NDArray seq, lhs : NDArray, rhs : NDArray) =
        let creator = AtomicSymbolCreator.FromName "broadcast_logical_xor"
        let names = Array.empty
        let vals = Array.empty
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg lhs)) then lhs.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg rhs)) then rhs.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <summary>Returns the result of element-wise **logical xor** with broadcasting.
    /// 
    /// Example::
    /// 
    ///    x = [[ 1.,  1.,  0.],
    ///         [ 1.,  1.,  0.]]
    /// 
    ///    y = [[ 1.],
    ///         [ 0.]]
    /// 
    ///    broadcast_logical_xor(x, y) = [[ 0.,  0.,  1.],
    ///                                   [ 1.,  1.,  0.]]
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\elemwise_binary_broadcast_op_logic.cc:L190</summary>
    /// <param name="lhs">First input to the function</param>
    /// <param name="rhs">Second input to the function</param>
    static member BroadcastLogicalXor([<Optional>] ?lhs : Symbol, [<Optional>] ?rhs : Symbol) =
        BroadcastLogicalXor(?lhs = lhs, ?rhs = rhs)

    /// <summary>Adds arguments element-wise.
    /// 
    /// The storage type of ``elemwise_add`` output depends on storage types of inputs
    /// 
    ///    - elemwise_add(row_sparse, row_sparse) = row_sparse
    ///    - elemwise_add(csr, csr) = csr
    ///    - elemwise_add(default, csr) = default
    ///    - elemwise_add(csr, default) = default
    ///    - elemwise_add(default, rsp) = default
    ///    - elemwise_add(rsp, default) = default
    ///    - otherwise, ``elemwise_add`` generates output with default storage
    /// 
    /// </summary>
    /// <param name="lhs">first input</param>
    /// <param name="rhs">second input</param>
    static member ElemwiseAdd(lhs : NDArray, rhs : NDArray) =
        let creator = AtomicSymbolCreator.FromName "elemwise_add"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg lhs)) then lhs.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg rhs)) then rhs.UnsafeHandle|]
                                                 Array.empty
                                                 Array.empty
        (new NDArray(outputs.[0]))
    /// <summary>Adds arguments element-wise.
    /// 
    /// The storage type of ``elemwise_add`` output depends on storage types of inputs
    /// 
    ///    - elemwise_add(row_sparse, row_sparse) = row_sparse
    ///    - elemwise_add(csr, csr) = csr
    ///    - elemwise_add(default, csr) = default
    ///    - elemwise_add(csr, default) = default
    ///    - elemwise_add(default, rsp) = default
    ///    - elemwise_add(rsp, default) = default
    ///    - otherwise, ``elemwise_add`` generates output with default storage
    /// 
    /// </summary>
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="lhs">first input</param>
    /// <param name="rhs">second input</param>
    static member ElemwiseAdd(outputArray : NDArray seq, lhs : NDArray, rhs : NDArray) =
        let creator = AtomicSymbolCreator.FromName "elemwise_add"
        let names = Array.empty
        let vals = Array.empty
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg lhs)) then lhs.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg rhs)) then rhs.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <summary>Adds arguments element-wise.
    /// 
    /// The storage type of ``elemwise_add`` output depends on storage types of inputs
    /// 
    ///    - elemwise_add(row_sparse, row_sparse) = row_sparse
    ///    - elemwise_add(csr, csr) = csr
    ///    - elemwise_add(default, csr) = default
    ///    - elemwise_add(csr, default) = default
    ///    - elemwise_add(default, rsp) = default
    ///    - elemwise_add(rsp, default) = default
    ///    - otherwise, ``elemwise_add`` generates output with default storage
    /// 
    /// </summary>
    /// <param name="lhs">first input</param>
    /// <param name="rhs">second input</param>
    static member ElemwiseAdd([<Optional>] ?lhs : Symbol, [<Optional>] ?rhs : Symbol) =
        ElemwiseAdd(?lhs = lhs, ?rhs = rhs)

    /// <param name="lhs">first input</param>
    /// <param name="rhs">second input</param>
    static member GradAdd(lhs : NDArray, rhs : NDArray) =
        let creator = AtomicSymbolCreator.FromName "_grad_add"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg lhs)) then lhs.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg rhs)) then rhs.UnsafeHandle|]
                                                 Array.empty
                                                 Array.empty
        (new NDArray(outputs.[0]))
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="lhs">first input</param>
    /// <param name="rhs">second input</param>
    static member GradAdd(outputArray : NDArray seq, lhs : NDArray, rhs : NDArray) =
        let creator = AtomicSymbolCreator.FromName "_grad_add"
        let names = Array.empty
        let vals = Array.empty
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg lhs)) then lhs.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg rhs)) then rhs.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <param name="lhs">first input</param>
    /// <param name="rhs">second input</param>
    static member GradAdd([<Optional>] ?lhs : Symbol, [<Optional>] ?rhs : Symbol) =
        GradAdd(?lhs = lhs, ?rhs = rhs)


    /// <summary>Subtracts arguments element-wise.
    /// 
    /// The storage type of ``elemwise_sub`` output depends on storage types of inputs
    /// 
    ///    - elemwise_sub(row_sparse, row_sparse) = row_sparse
    ///    - elemwise_sub(csr, csr) = csr
    ///    - elemwise_sub(default, csr) = default
    ///    - elemwise_sub(csr, default) = default
    ///    - elemwise_sub(default, rsp) = default
    ///    - elemwise_sub(rsp, default) = default
    ///    - otherwise, ``elemwise_sub`` generates output with default storage
    /// 
    /// </summary>
    /// <param name="lhs">first input</param>
    /// <param name="rhs">second input</param>
    static member ElemwiseSub(lhs : NDArray, rhs : NDArray) =
        let creator = AtomicSymbolCreator.FromName "elemwise_sub"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg lhs)) then lhs.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg rhs)) then rhs.UnsafeHandle|]
                                                 Array.empty
                                                 Array.empty
        (new NDArray(outputs.[0]))
    /// <summary>Subtracts arguments element-wise.
    /// 
    /// The storage type of ``elemwise_sub`` output depends on storage types of inputs
    /// 
    ///    - elemwise_sub(row_sparse, row_sparse) = row_sparse
    ///    - elemwise_sub(csr, csr) = csr
    ///    - elemwise_sub(default, csr) = default
    ///    - elemwise_sub(csr, default) = default
    ///    - elemwise_sub(default, rsp) = default
    ///    - elemwise_sub(rsp, default) = default
    ///    - otherwise, ``elemwise_sub`` generates output with default storage
    /// 
    /// </summary>
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="lhs">first input</param>
    /// <param name="rhs">second input</param>
    static member ElemwiseSub(outputArray : NDArray seq, lhs : NDArray, rhs : NDArray) =
        let creator = AtomicSymbolCreator.FromName "elemwise_sub"
        let names = Array.empty
        let vals = Array.empty
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg lhs)) then lhs.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg rhs)) then rhs.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <summary>Subtracts arguments element-wise.
    /// 
    /// The storage type of ``elemwise_sub`` output depends on storage types of inputs
    /// 
    ///    - elemwise_sub(row_sparse, row_sparse) = row_sparse
    ///    - elemwise_sub(csr, csr) = csr
    ///    - elemwise_sub(default, csr) = default
    ///    - elemwise_sub(csr, default) = default
    ///    - elemwise_sub(default, rsp) = default
    ///    - elemwise_sub(rsp, default) = default
    ///    - otherwise, ``elemwise_sub`` generates output with default storage
    /// 
    /// </summary>
    /// <param name="lhs">first input</param>
    /// <param name="rhs">second input</param>
    static member ElemwiseSub([<Optional>] ?lhs : Symbol, [<Optional>] ?rhs : Symbol) =
        ElemwiseSub(?lhs = lhs, ?rhs = rhs)


    /// <summary>Multiplies arguments element-wise.
    /// 
    /// The storage type of ``elemwise_mul`` output depends on storage types of inputs
    /// 
    ///    - elemwise_mul(default, default) = default
    ///    - elemwise_mul(row_sparse, row_sparse) = row_sparse
    ///    - elemwise_mul(default, row_sparse) = row_sparse
    ///    - elemwise_mul(row_sparse, default) = row_sparse
    ///    - elemwise_mul(csr, csr) = csr
    ///    - otherwise, ``elemwise_mul`` generates output with default storage
    /// 
    /// </summary>
    /// <param name="lhs">first input</param>
    /// <param name="rhs">second input</param>
    static member ElemwiseMul(lhs : NDArray, rhs : NDArray) =
        let creator = AtomicSymbolCreator.FromName "elemwise_mul"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg lhs)) then lhs.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg rhs)) then rhs.UnsafeHandle|]
                                                 Array.empty
                                                 Array.empty
        (new NDArray(outputs.[0]))
    /// <summary>Multiplies arguments element-wise.
    /// 
    /// The storage type of ``elemwise_mul`` output depends on storage types of inputs
    /// 
    ///    - elemwise_mul(default, default) = default
    ///    - elemwise_mul(row_sparse, row_sparse) = row_sparse
    ///    - elemwise_mul(default, row_sparse) = row_sparse
    ///    - elemwise_mul(row_sparse, default) = row_sparse
    ///    - elemwise_mul(csr, csr) = csr
    ///    - otherwise, ``elemwise_mul`` generates output with default storage
    /// 
    /// </summary>
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="lhs">first input</param>
    /// <param name="rhs">second input</param>
    static member ElemwiseMul(outputArray : NDArray seq, lhs : NDArray, rhs : NDArray) =
        let creator = AtomicSymbolCreator.FromName "elemwise_mul"
        let names = Array.empty
        let vals = Array.empty
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg lhs)) then lhs.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg rhs)) then rhs.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <summary>Multiplies arguments element-wise.
    /// 
    /// The storage type of ``elemwise_mul`` output depends on storage types of inputs
    /// 
    ///    - elemwise_mul(default, default) = default
    ///    - elemwise_mul(row_sparse, row_sparse) = row_sparse
    ///    - elemwise_mul(default, row_sparse) = row_sparse
    ///    - elemwise_mul(row_sparse, default) = row_sparse
    ///    - elemwise_mul(csr, csr) = csr
    ///    - otherwise, ``elemwise_mul`` generates output with default storage
    /// 
    /// </summary>
    /// <param name="lhs">first input</param>
    /// <param name="rhs">second input</param>
    static member ElemwiseMul([<Optional>] ?lhs : Symbol, [<Optional>] ?rhs : Symbol) =
        ElemwiseMul(?lhs = lhs, ?rhs = rhs)


    /// <summary>Divides arguments element-wise.
    /// 
    /// The storage type of ``elemwise_div`` output is always dense
    /// 
    /// </summary>
    /// <param name="lhs">first input</param>
    /// <param name="rhs">second input</param>
    static member ElemwiseDiv(lhs : NDArray, rhs : NDArray) =
        let creator = AtomicSymbolCreator.FromName "elemwise_div"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg lhs)) then lhs.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg rhs)) then rhs.UnsafeHandle|]
                                                 Array.empty
                                                 Array.empty
        (new NDArray(outputs.[0]))
    /// <summary>Divides arguments element-wise.
    /// 
    /// The storage type of ``elemwise_div`` output is always dense
    /// 
    /// </summary>
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="lhs">first input</param>
    /// <param name="rhs">second input</param>
    static member ElemwiseDiv(outputArray : NDArray seq, lhs : NDArray, rhs : NDArray) =
        let creator = AtomicSymbolCreator.FromName "elemwise_div"
        let names = Array.empty
        let vals = Array.empty
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg lhs)) then lhs.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg rhs)) then rhs.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <summary>Divides arguments element-wise.
    /// 
    /// The storage type of ``elemwise_div`` output is always dense
    /// 
    /// </summary>
    /// <param name="lhs">first input</param>
    /// <param name="rhs">second input</param>
    static member ElemwiseDiv([<Optional>] ?lhs : Symbol, [<Optional>] ?rhs : Symbol) =
        ElemwiseDiv(?lhs = lhs, ?rhs = rhs)


    /// <param name="lhs">first input</param>
    /// <param name="rhs">second input</param>
    static member Mod(lhs : NDArray, rhs : NDArray) =
        let creator = AtomicSymbolCreator.FromName "_mod"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg lhs)) then lhs.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg rhs)) then rhs.UnsafeHandle|]
                                                 Array.empty
                                                 Array.empty
        (new NDArray(outputs.[0]))
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="lhs">first input</param>
    /// <param name="rhs">second input</param>
    static member Mod(outputArray : NDArray seq, lhs : NDArray, rhs : NDArray) =
        let creator = AtomicSymbolCreator.FromName "_mod"
        let names = Array.empty
        let vals = Array.empty
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg lhs)) then lhs.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg rhs)) then rhs.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <param name="lhs">first input</param>
    /// <param name="rhs">second input</param>
    static member Mod([<Optional>] ?lhs : Symbol, [<Optional>] ?rhs : Symbol) =
        Mod(?lhs = lhs, ?rhs = rhs)


    /// <param name="lhs">first input</param>
    /// <param name="rhs">second input</param>
    static member Power(lhs : NDArray, rhs : NDArray) =
        let creator = AtomicSymbolCreator.FromName "_power"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg lhs)) then lhs.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg rhs)) then rhs.UnsafeHandle|]
                                                 Array.empty
                                                 Array.empty
        (new NDArray(outputs.[0]))
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="lhs">first input</param>
    /// <param name="rhs">second input</param>
    static member Power(outputArray : NDArray seq, lhs : NDArray, rhs : NDArray) =
        let creator = AtomicSymbolCreator.FromName "_power"
        let names = Array.empty
        let vals = Array.empty
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg lhs)) then lhs.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg rhs)) then rhs.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <param name="lhs">first input</param>
    /// <param name="rhs">second input</param>
    static member Power([<Optional>] ?lhs : Symbol, [<Optional>] ?rhs : Symbol) =
        Power(?lhs = lhs, ?rhs = rhs)


    /// <param name="lhs">first input</param>
    /// <param name="rhs">second input</param>
    static member Maximum(lhs : NDArray, rhs : NDArray) =
        let creator = AtomicSymbolCreator.FromName "_maximum"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg lhs)) then lhs.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg rhs)) then rhs.UnsafeHandle|]
                                                 Array.empty
                                                 Array.empty
        (new NDArray(outputs.[0]))
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="lhs">first input</param>
    /// <param name="rhs">second input</param>
    static member Maximum(outputArray : NDArray seq, lhs : NDArray, rhs : NDArray) =
        let creator = AtomicSymbolCreator.FromName "_maximum"
        let names = Array.empty
        let vals = Array.empty
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg lhs)) then lhs.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg rhs)) then rhs.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <param name="lhs">first input</param>
    /// <param name="rhs">second input</param>
    static member Maximum([<Optional>] ?lhs : Symbol, [<Optional>] ?rhs : Symbol) =
        Maximum(?lhs = lhs, ?rhs = rhs)


    /// <param name="lhs">first input</param>
    /// <param name="rhs">second input</param>
    static member Minimum(lhs : NDArray, rhs : NDArray) =
        let creator = AtomicSymbolCreator.FromName "_minimum"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg lhs)) then lhs.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg rhs)) then rhs.UnsafeHandle|]
                                                 Array.empty
                                                 Array.empty
        (new NDArray(outputs.[0]))
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="lhs">first input</param>
    /// <param name="rhs">second input</param>
    static member Minimum(outputArray : NDArray seq, lhs : NDArray, rhs : NDArray) =
        let creator = AtomicSymbolCreator.FromName "_minimum"
        let names = Array.empty
        let vals = Array.empty
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg lhs)) then lhs.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg rhs)) then rhs.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <param name="lhs">first input</param>
    /// <param name="rhs">second input</param>
    static member Minimum([<Optional>] ?lhs : Symbol, [<Optional>] ?rhs : Symbol) =
        Minimum(?lhs = lhs, ?rhs = rhs)


    /// <summary>Given the &quot;legs&quot; of a right triangle, return its hypotenuse.
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\elemwise_binary_op_extended.cc:L79</summary>
    /// <param name="lhs">first input</param>
    /// <param name="rhs">second input</param>
    static member Hypot(lhs : NDArray, rhs : NDArray) =
        let creator = AtomicSymbolCreator.FromName "_hypot"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg lhs)) then lhs.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg rhs)) then rhs.UnsafeHandle|]
                                                 Array.empty
                                                 Array.empty
        (new NDArray(outputs.[0]))
    /// <summary>Given the &quot;legs&quot; of a right triangle, return its hypotenuse.
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\elemwise_binary_op_extended.cc:L79</summary>
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="lhs">first input</param>
    /// <param name="rhs">second input</param>
    static member Hypot(outputArray : NDArray seq, lhs : NDArray, rhs : NDArray) =
        let creator = AtomicSymbolCreator.FromName "_hypot"
        let names = Array.empty
        let vals = Array.empty
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg lhs)) then lhs.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg rhs)) then rhs.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <summary>Given the &quot;legs&quot; of a right triangle, return its hypotenuse.
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\elemwise_binary_op_extended.cc:L79</summary>
    /// <param name="lhs">first input</param>
    /// <param name="rhs">second input</param>
    static member Hypot([<Optional>] ?lhs : Symbol, [<Optional>] ?rhs : Symbol) =
        Hypot(?lhs = lhs, ?rhs = rhs)


    /// <param name="lhs">first input</param>
    /// <param name="rhs">second input</param>
    static member Equal(lhs : NDArray, rhs : NDArray) =
        let creator = AtomicSymbolCreator.FromName "_equal"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg lhs)) then lhs.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg rhs)) then rhs.UnsafeHandle|]
                                                 Array.empty
                                                 Array.empty
        (new NDArray(outputs.[0]))
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="lhs">first input</param>
    /// <param name="rhs">second input</param>
    static member Equal(outputArray : NDArray seq, lhs : NDArray, rhs : NDArray) =
        let creator = AtomicSymbolCreator.FromName "_equal"
        let names = Array.empty
        let vals = Array.empty
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg lhs)) then lhs.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg rhs)) then rhs.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <param name="lhs">first input</param>
    /// <param name="rhs">second input</param>
    static member Equal([<Optional>] ?lhs : Symbol, [<Optional>] ?rhs : Symbol) =
        Equal(?lhs = lhs, ?rhs = rhs)

    /// <param name="lhs">first input</param>
    /// <param name="rhs">second input</param>
    static member NotEqual(lhs : NDArray, rhs : NDArray) =
        let creator = AtomicSymbolCreator.FromName "_not_equal"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg lhs)) then lhs.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg rhs)) then rhs.UnsafeHandle|]
                                                 Array.empty
                                                 Array.empty
        (new NDArray(outputs.[0]))
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="lhs">first input</param>
    /// <param name="rhs">second input</param>
    static member NotEqual(outputArray : NDArray seq, lhs : NDArray, rhs : NDArray) =
        let creator = AtomicSymbolCreator.FromName "_not_equal"
        let names = Array.empty
        let vals = Array.empty
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg lhs)) then lhs.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg rhs)) then rhs.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <param name="lhs">first input</param>
    /// <param name="rhs">second input</param>
    static member NotEqual([<Optional>] ?lhs : Symbol, [<Optional>] ?rhs : Symbol) =
        NotEqual(?lhs = lhs, ?rhs = rhs)

    /// <param name="lhs">first input</param>
    /// <param name="rhs">second input</param>
    static member Greater(lhs : NDArray, rhs : NDArray) =
        let creator = AtomicSymbolCreator.FromName "_greater"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg lhs)) then lhs.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg rhs)) then rhs.UnsafeHandle|]
                                                 Array.empty
                                                 Array.empty
        (new NDArray(outputs.[0]))
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="lhs">first input</param>
    /// <param name="rhs">second input</param>
    static member Greater(outputArray : NDArray seq, lhs : NDArray, rhs : NDArray) =
        let creator = AtomicSymbolCreator.FromName "_greater"
        let names = Array.empty
        let vals = Array.empty
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg lhs)) then lhs.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg rhs)) then rhs.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <param name="lhs">first input</param>
    /// <param name="rhs">second input</param>
    static member Greater([<Optional>] ?lhs : Symbol, [<Optional>] ?rhs : Symbol) =
        Greater(?lhs = lhs, ?rhs = rhs)

    /// <param name="lhs">first input</param>
    /// <param name="rhs">second input</param>
    static member GreaterEqual(lhs : NDArray, rhs : NDArray) =
        let creator = AtomicSymbolCreator.FromName "_greater_equal"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg lhs)) then lhs.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg rhs)) then rhs.UnsafeHandle|]
                                                 Array.empty
                                                 Array.empty
        (new NDArray(outputs.[0]))
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="lhs">first input</param>
    /// <param name="rhs">second input</param>
    static member GreaterEqual(outputArray : NDArray seq, lhs : NDArray, rhs : NDArray) =
        let creator = AtomicSymbolCreator.FromName "_greater_equal"
        let names = Array.empty
        let vals = Array.empty
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg lhs)) then lhs.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg rhs)) then rhs.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <param name="lhs">first input</param>
    /// <param name="rhs">second input</param>
    static member GreaterEqual([<Optional>] ?lhs : Symbol, [<Optional>] ?rhs : Symbol) =
        GreaterEqual(?lhs = lhs, ?rhs = rhs)

    /// <param name="lhs">first input</param>
    /// <param name="rhs">second input</param>
    static member Lesser(lhs : NDArray, rhs : NDArray) =
        let creator = AtomicSymbolCreator.FromName "_lesser"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg lhs)) then lhs.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg rhs)) then rhs.UnsafeHandle|]
                                                 Array.empty
                                                 Array.empty
        (new NDArray(outputs.[0]))
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="lhs">first input</param>
    /// <param name="rhs">second input</param>
    static member Lesser(outputArray : NDArray seq, lhs : NDArray, rhs : NDArray) =
        let creator = AtomicSymbolCreator.FromName "_lesser"
        let names = Array.empty
        let vals = Array.empty
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg lhs)) then lhs.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg rhs)) then rhs.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <param name="lhs">first input</param>
    /// <param name="rhs">second input</param>
    static member Lesser([<Optional>] ?lhs : Symbol, [<Optional>] ?rhs : Symbol) =
        Lesser(?lhs = lhs, ?rhs = rhs)

    /// <param name="lhs">first input</param>
    /// <param name="rhs">second input</param>
    static member LesserEqual(lhs : NDArray, rhs : NDArray) =
        let creator = AtomicSymbolCreator.FromName "_lesser_equal"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg lhs)) then lhs.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg rhs)) then rhs.UnsafeHandle|]
                                                 Array.empty
                                                 Array.empty
        (new NDArray(outputs.[0]))
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="lhs">first input</param>
    /// <param name="rhs">second input</param>
    static member LesserEqual(outputArray : NDArray seq, lhs : NDArray, rhs : NDArray) =
        let creator = AtomicSymbolCreator.FromName "_lesser_equal"
        let names = Array.empty
        let vals = Array.empty
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg lhs)) then lhs.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg rhs)) then rhs.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <param name="lhs">first input</param>
    /// <param name="rhs">second input</param>
    static member LesserEqual([<Optional>] ?lhs : Symbol, [<Optional>] ?rhs : Symbol) =
        LesserEqual(?lhs = lhs, ?rhs = rhs)

    /// <param name="lhs">first input</param>
    /// <param name="rhs">second input</param>
    static member LogicalAnd(lhs : NDArray, rhs : NDArray) =
        let creator = AtomicSymbolCreator.FromName "_logical_and"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg lhs)) then lhs.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg rhs)) then rhs.UnsafeHandle|]
                                                 Array.empty
                                                 Array.empty
        (new NDArray(outputs.[0]))
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="lhs">first input</param>
    /// <param name="rhs">second input</param>
    static member LogicalAnd(outputArray : NDArray seq, lhs : NDArray, rhs : NDArray) =
        let creator = AtomicSymbolCreator.FromName "_logical_and"
        let names = Array.empty
        let vals = Array.empty
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg lhs)) then lhs.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg rhs)) then rhs.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <param name="lhs">first input</param>
    /// <param name="rhs">second input</param>
    static member LogicalAnd([<Optional>] ?lhs : Symbol, [<Optional>] ?rhs : Symbol) =
        LogicalAnd(?lhs = lhs, ?rhs = rhs)

    /// <param name="lhs">first input</param>
    /// <param name="rhs">second input</param>
    static member LogicalOr(lhs : NDArray, rhs : NDArray) =
        let creator = AtomicSymbolCreator.FromName "_logical_or"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg lhs)) then lhs.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg rhs)) then rhs.UnsafeHandle|]
                                                 Array.empty
                                                 Array.empty
        (new NDArray(outputs.[0]))
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="lhs">first input</param>
    /// <param name="rhs">second input</param>
    static member LogicalOr(outputArray : NDArray seq, lhs : NDArray, rhs : NDArray) =
        let creator = AtomicSymbolCreator.FromName "_logical_or"
        let names = Array.empty
        let vals = Array.empty
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg lhs)) then lhs.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg rhs)) then rhs.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <param name="lhs">first input</param>
    /// <param name="rhs">second input</param>
    static member LogicalOr([<Optional>] ?lhs : Symbol, [<Optional>] ?rhs : Symbol) =
        LogicalOr(?lhs = lhs, ?rhs = rhs)

    /// <param name="lhs">first input</param>
    /// <param name="rhs">second input</param>
    static member LogicalXor(lhs : NDArray, rhs : NDArray) =
        let creator = AtomicSymbolCreator.FromName "_logical_xor"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg lhs)) then lhs.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg rhs)) then rhs.UnsafeHandle|]
                                                 Array.empty
                                                 Array.empty
        (new NDArray(outputs.[0]))
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="lhs">first input</param>
    /// <param name="rhs">second input</param>
    static member LogicalXor(outputArray : NDArray seq, lhs : NDArray, rhs : NDArray) =
        let creator = AtomicSymbolCreator.FromName "_logical_xor"
        let names = Array.empty
        let vals = Array.empty
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg lhs)) then lhs.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg rhs)) then rhs.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <param name="lhs">first input</param>
    /// <param name="rhs">second input</param>
    static member LogicalXor([<Optional>] ?lhs : Symbol, [<Optional>] ?rhs : Symbol) =
        LogicalXor(?lhs = lhs, ?rhs = rhs)

    /// <param name="data">source input</param>
    /// <param name="scalar">scalar input</param>
    static member PlusScalar(data : NDArray, scalar : float) =
        let creator = AtomicSymbolCreator.FromName "_plus_scalar"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle|]
                                                 [|"scalar"|]
                                                 [|string scalar|]
        (new NDArray(outputs.[0]))
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="data">source input</param>
    /// <param name="scalar">scalar input</param>
    static member PlusScalar(outputArray : NDArray seq, data : NDArray, scalar : float) =
        let creator = AtomicSymbolCreator.FromName "_plus_scalar"
        let names = [|"scalar"|]
        let vals = [|string scalar|]
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <param name="data">source input</param>
    /// <param name="scalar">scalar input</param>
    static member PlusScalar(data : Symbol, scalar : float) =
        PlusScalar(data, scalar)
    /// <param name="scalar">scalar input</param>
    /// <param name="data">source input</param>
    static member PlusScalar(scalar : float, [<Optional>] ?data : Symbol) =
        PlusScalar(scalar, ?data = data)

    /// <param name="data">source input</param>
    /// <param name="scalar">scalar input</param>
    static member MinusScalar(data : NDArray, scalar : float) =
        let creator = AtomicSymbolCreator.FromName "_minus_scalar"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle|]
                                                 [|"scalar"|]
                                                 [|string scalar|]
        (new NDArray(outputs.[0]))
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="data">source input</param>
    /// <param name="scalar">scalar input</param>
    static member MinusScalar(outputArray : NDArray seq, data : NDArray, scalar : float) =
        let creator = AtomicSymbolCreator.FromName "_minus_scalar"
        let names = [|"scalar"|]
        let vals = [|string scalar|]
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <param name="data">source input</param>
    /// <param name="scalar">scalar input</param>
    static member MinusScalar(data : Symbol, scalar : float) =
        MinusScalar(data, scalar)
    /// <param name="scalar">scalar input</param>
    /// <param name="data">source input</param>
    static member MinusScalar(scalar : float, [<Optional>] ?data : Symbol) =
        MinusScalar(scalar, ?data = data)

    /// <param name="data">source input</param>
    /// <param name="scalar">scalar input</param>
    static member RminusScalar(data : NDArray, scalar : float) =
        let creator = AtomicSymbolCreator.FromName "_rminus_scalar"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle|]
                                                 [|"scalar"|]
                                                 [|string scalar|]
        (new NDArray(outputs.[0]))
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="data">source input</param>
    /// <param name="scalar">scalar input</param>
    static member RminusScalar(outputArray : NDArray seq, data : NDArray, scalar : float) =
        let creator = AtomicSymbolCreator.FromName "_rminus_scalar"
        let names = [|"scalar"|]
        let vals = [|string scalar|]
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <param name="data">source input</param>
    /// <param name="scalar">scalar input</param>
    static member RminusScalar(data : Symbol, scalar : float) =
        RminusScalar(data, scalar)
    /// <param name="scalar">scalar input</param>
    /// <param name="data">source input</param>
    static member RminusScalar(scalar : float, [<Optional>] ?data : Symbol) =
        RminusScalar(scalar, ?data = data)

    /// <summary>Multiply an array with a scalar.
    /// 
    /// ``_mul_scalar`` only operates on data array of input if input is sparse.
    /// 
    /// For example, if input of shape (100, 100) has only 2 non zero elements,
    /// i.e. input.data = [5, 6], scalar = nan,
    /// it will result output.data = [nan, nan] instead of 10000 nans.
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\elemwise_binary_scalar_op_basic.cc:L149</summary>
    /// <param name="data">source input</param>
    /// <param name="scalar">scalar input</param>
    static member MulScalar(data : NDArray, scalar : float) =
        let creator = AtomicSymbolCreator.FromName "_mul_scalar"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle|]
                                                 [|"scalar"|]
                                                 [|string scalar|]
        (new NDArray(outputs.[0]))
    /// <summary>Multiply an array with a scalar.
    /// 
    /// ``_mul_scalar`` only operates on data array of input if input is sparse.
    /// 
    /// For example, if input of shape (100, 100) has only 2 non zero elements,
    /// i.e. input.data = [5, 6], scalar = nan,
    /// it will result output.data = [nan, nan] instead of 10000 nans.
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\elemwise_binary_scalar_op_basic.cc:L149</summary>
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="data">source input</param>
    /// <param name="scalar">scalar input</param>
    static member MulScalar(outputArray : NDArray seq, data : NDArray, scalar : float) =
        let creator = AtomicSymbolCreator.FromName "_mul_scalar"
        let names = [|"scalar"|]
        let vals = [|string scalar|]
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <summary>Multiply an array with a scalar.
    /// 
    /// ``_mul_scalar`` only operates on data array of input if input is sparse.
    /// 
    /// For example, if input of shape (100, 100) has only 2 non zero elements,
    /// i.e. input.data = [5, 6], scalar = nan,
    /// it will result output.data = [nan, nan] instead of 10000 nans.
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\elemwise_binary_scalar_op_basic.cc:L149</summary>
    /// <param name="data">source input</param>
    /// <param name="scalar">scalar input</param>
    static member MulScalar(data : Symbol, scalar : float) =
        MulScalar(data, scalar)
    /// <summary>Multiply an array with a scalar.
    /// 
    /// ``_mul_scalar`` only operates on data array of input if input is sparse.
    /// 
    /// For example, if input of shape (100, 100) has only 2 non zero elements,
    /// i.e. input.data = [5, 6], scalar = nan,
    /// it will result output.data = [nan, nan] instead of 10000 nans.
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\elemwise_binary_scalar_op_basic.cc:L149</summary>
    /// <param name="scalar">scalar input</param>
    /// <param name="data">source input</param>
    static member MulScalar(scalar : float, [<Optional>] ?data : Symbol) =
        MulScalar(scalar, ?data = data)


    /// <summary>Divide an array with a scalar.
    /// 
    /// ``_div_scalar`` only operates on data array of input if input is sparse.
    /// 
    /// For example, if input of shape (100, 100) has only 2 non zero elements,
    /// i.e. input.data = [5, 6], scalar = nan,
    /// it will result output.data = [nan, nan] instead of 10000 nans.
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\elemwise_binary_scalar_op_basic.cc:L171</summary>
    /// <param name="data">source input</param>
    /// <param name="scalar">scalar input</param>
    static member DivScalar(data : NDArray, scalar : float) =
        let creator = AtomicSymbolCreator.FromName "_div_scalar"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle|]
                                                 [|"scalar"|]
                                                 [|string scalar|]
        (new NDArray(outputs.[0]))
    /// <summary>Divide an array with a scalar.
    /// 
    /// ``_div_scalar`` only operates on data array of input if input is sparse.
    /// 
    /// For example, if input of shape (100, 100) has only 2 non zero elements,
    /// i.e. input.data = [5, 6], scalar = nan,
    /// it will result output.data = [nan, nan] instead of 10000 nans.
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\elemwise_binary_scalar_op_basic.cc:L171</summary>
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="data">source input</param>
    /// <param name="scalar">scalar input</param>
    static member DivScalar(outputArray : NDArray seq, data : NDArray, scalar : float) =
        let creator = AtomicSymbolCreator.FromName "_div_scalar"
        let names = [|"scalar"|]
        let vals = [|string scalar|]
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <summary>Divide an array with a scalar.
    /// 
    /// ``_div_scalar`` only operates on data array of input if input is sparse.
    /// 
    /// For example, if input of shape (100, 100) has only 2 non zero elements,
    /// i.e. input.data = [5, 6], scalar = nan,
    /// it will result output.data = [nan, nan] instead of 10000 nans.
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\elemwise_binary_scalar_op_basic.cc:L171</summary>
    /// <param name="data">source input</param>
    /// <param name="scalar">scalar input</param>
    static member DivScalar(data : Symbol, scalar : float) =
        DivScalar(data, scalar)
    /// <summary>Divide an array with a scalar.
    /// 
    /// ``_div_scalar`` only operates on data array of input if input is sparse.
    /// 
    /// For example, if input of shape (100, 100) has only 2 non zero elements,
    /// i.e. input.data = [5, 6], scalar = nan,
    /// it will result output.data = [nan, nan] instead of 10000 nans.
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\elemwise_binary_scalar_op_basic.cc:L171</summary>
    /// <param name="scalar">scalar input</param>
    /// <param name="data">source input</param>
    static member DivScalar(scalar : float, [<Optional>] ?data : Symbol) =
        DivScalar(scalar, ?data = data)


    /// <param name="data">source input</param>
    /// <param name="scalar">scalar input</param>
    static member RdivScalar(data : NDArray, scalar : float) =
        let creator = AtomicSymbolCreator.FromName "_rdiv_scalar"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle|]
                                                 [|"scalar"|]
                                                 [|string scalar|]
        (new NDArray(outputs.[0]))
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="data">source input</param>
    /// <param name="scalar">scalar input</param>
    static member RdivScalar(outputArray : NDArray seq, data : NDArray, scalar : float) =
        let creator = AtomicSymbolCreator.FromName "_rdiv_scalar"
        let names = [|"scalar"|]
        let vals = [|string scalar|]
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <param name="data">source input</param>
    /// <param name="scalar">scalar input</param>
    static member RdivScalar(data : Symbol, scalar : float) =
        RdivScalar(data, scalar)
    /// <param name="scalar">scalar input</param>
    /// <param name="data">source input</param>
    static member RdivScalar(scalar : float, [<Optional>] ?data : Symbol) =
        RdivScalar(scalar, ?data = data)


    /// <param name="data">source input</param>
    /// <param name="scalar">scalar input</param>
    static member ModScalar(data : NDArray, scalar : float) =
        let creator = AtomicSymbolCreator.FromName "_mod_scalar"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle|]
                                                 [|"scalar"|]
                                                 [|string scalar|]
        (new NDArray(outputs.[0]))
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="data">source input</param>
    /// <param name="scalar">scalar input</param>
    static member ModScalar(outputArray : NDArray seq, data : NDArray, scalar : float) =
        let creator = AtomicSymbolCreator.FromName "_mod_scalar"
        let names = [|"scalar"|]
        let vals = [|string scalar|]
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <param name="data">source input</param>
    /// <param name="scalar">scalar input</param>
    static member ModScalar(data : Symbol, scalar : float) =
        ModScalar(data, scalar)
    /// <param name="scalar">scalar input</param>
    /// <param name="data">source input</param>
    static member ModScalar(scalar : float, [<Optional>] ?data : Symbol) =
        ModScalar(scalar, ?data = data)


    /// <param name="data">source input</param>
    /// <param name="scalar">scalar input</param>
    static member RmodScalar(data : NDArray, scalar : float) =
        let creator = AtomicSymbolCreator.FromName "_rmod_scalar"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle|]
                                                 [|"scalar"|]
                                                 [|string scalar|]
        (new NDArray(outputs.[0]))
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="data">source input</param>
    /// <param name="scalar">scalar input</param>
    static member RmodScalar(outputArray : NDArray seq, data : NDArray, scalar : float) =
        let creator = AtomicSymbolCreator.FromName "_rmod_scalar"
        let names = [|"scalar"|]
        let vals = [|string scalar|]
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <param name="data">source input</param>
    /// <param name="scalar">scalar input</param>
    static member RmodScalar(data : Symbol, scalar : float) =
        RmodScalar(data, scalar)
    /// <param name="scalar">scalar input</param>
    /// <param name="data">source input</param>
    static member RmodScalar(scalar : float, [<Optional>] ?data : Symbol) =
        RmodScalar(scalar, ?data = data)


    /// <param name="data">source input</param>
    /// <param name="scalar">scalar input</param>
    static member MaximumScalar(data : NDArray, scalar : float) =
        let creator = AtomicSymbolCreator.FromName "_maximum_scalar"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle|]
                                                 [|"scalar"|]
                                                 [|string scalar|]
        (new NDArray(outputs.[0]))
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="data">source input</param>
    /// <param name="scalar">scalar input</param>
    static member MaximumScalar(outputArray : NDArray seq, data : NDArray, scalar : float) =
        let creator = AtomicSymbolCreator.FromName "_maximum_scalar"
        let names = [|"scalar"|]
        let vals = [|string scalar|]
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <param name="data">source input</param>
    /// <param name="scalar">scalar input</param>
    static member MaximumScalar(data : Symbol, scalar : float) =
        MaximumScalar(data, scalar)
    /// <param name="scalar">scalar input</param>
    /// <param name="data">source input</param>
    static member MaximumScalar(scalar : float, [<Optional>] ?data : Symbol) =
        MaximumScalar(scalar, ?data = data)


    /// <param name="data">source input</param>
    /// <param name="scalar">scalar input</param>
    static member MinimumScalar(data : NDArray, scalar : float) =
        let creator = AtomicSymbolCreator.FromName "_minimum_scalar"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle|]
                                                 [|"scalar"|]
                                                 [|string scalar|]
        (new NDArray(outputs.[0]))
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="data">source input</param>
    /// <param name="scalar">scalar input</param>
    static member MinimumScalar(outputArray : NDArray seq, data : NDArray, scalar : float) =
        let creator = AtomicSymbolCreator.FromName "_minimum_scalar"
        let names = [|"scalar"|]
        let vals = [|string scalar|]
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <param name="data">source input</param>
    /// <param name="scalar">scalar input</param>
    static member MinimumScalar(data : Symbol, scalar : float) =
        MinimumScalar(data, scalar)
    /// <param name="scalar">scalar input</param>
    /// <param name="data">source input</param>
    static member MinimumScalar(scalar : float, [<Optional>] ?data : Symbol) =
        MinimumScalar(scalar, ?data = data)


    /// <param name="data">source input</param>
    /// <param name="scalar">scalar input</param>
    static member PowerScalar(data : NDArray, scalar : float) =
        let creator = AtomicSymbolCreator.FromName "_power_scalar"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle|]
                                                 [|"scalar"|]
                                                 [|string scalar|]
        (new NDArray(outputs.[0]))
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="data">source input</param>
    /// <param name="scalar">scalar input</param>
    static member PowerScalar(outputArray : NDArray seq, data : NDArray, scalar : float) =
        let creator = AtomicSymbolCreator.FromName "_power_scalar"
        let names = [|"scalar"|]
        let vals = [|string scalar|]
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <param name="data">source input</param>
    /// <param name="scalar">scalar input</param>
    static member PowerScalar(data : Symbol, scalar : float) =
        PowerScalar(data, scalar)
    /// <param name="scalar">scalar input</param>
    /// <param name="data">source input</param>
    static member PowerScalar(scalar : float, [<Optional>] ?data : Symbol) =
        PowerScalar(scalar, ?data = data)


    /// <param name="data">source input</param>
    /// <param name="scalar">scalar input</param>
    static member RpowerScalar(data : NDArray, scalar : float) =
        let creator = AtomicSymbolCreator.FromName "_rpower_scalar"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle|]
                                                 [|"scalar"|]
                                                 [|string scalar|]
        (new NDArray(outputs.[0]))
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="data">source input</param>
    /// <param name="scalar">scalar input</param>
    static member RpowerScalar(outputArray : NDArray seq, data : NDArray, scalar : float) =
        let creator = AtomicSymbolCreator.FromName "_rpower_scalar"
        let names = [|"scalar"|]
        let vals = [|string scalar|]
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <param name="data">source input</param>
    /// <param name="scalar">scalar input</param>
    static member RpowerScalar(data : Symbol, scalar : float) =
        RpowerScalar(data, scalar)
    /// <param name="scalar">scalar input</param>
    /// <param name="data">source input</param>
    static member RpowerScalar(scalar : float, [<Optional>] ?data : Symbol) =
        RpowerScalar(scalar, ?data = data)


    /// <param name="data">source input</param>
    /// <param name="scalar">scalar input</param>
    static member HypotScalar(data : NDArray, scalar : float) =
        let creator = AtomicSymbolCreator.FromName "_hypot_scalar"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle|]
                                                 [|"scalar"|]
                                                 [|string scalar|]
        (new NDArray(outputs.[0]))
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="data">source input</param>
    /// <param name="scalar">scalar input</param>
    static member HypotScalar(outputArray : NDArray seq, data : NDArray, scalar : float) =
        let creator = AtomicSymbolCreator.FromName "_hypot_scalar"
        let names = [|"scalar"|]
        let vals = [|string scalar|]
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <param name="data">source input</param>
    /// <param name="scalar">scalar input</param>
    static member HypotScalar(data : Symbol, scalar : float) =
        HypotScalar(data, scalar)
    /// <param name="scalar">scalar input</param>
    /// <param name="data">source input</param>
    static member HypotScalar(scalar : float, [<Optional>] ?data : Symbol) =
        HypotScalar(scalar, ?data = data)


    /// <summary>Calculate Smooth L1 Loss(lhs, scalar) by summing
    /// 
    /// .. math::
    /// 
    ///     f(x) =
    ///     \begin{cases}
    ///     (\sigma x)^2/2,&amp; \text{if }x &lt; 1/\sigma^2\\
    ///     |x|-0.5/\sigma^2,&amp; \text{otherwise}
    ///     \end{cases}
    /// 
    /// where :math:`x` is an element of the tensor *lhs* and :math:`\sigma` is the scalar.
    /// 
    /// Example::
    /// 
    ///   smooth_l1([1, 2, 3, 4]) = [0.5, 1.5, 2.5, 3.5]
    ///   smooth_l1([1, 2, 3, 4], scalar=1) = [0.5, 1.5, 2.5, 3.5]
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\elemwise_binary_scalar_op_extended.cc:L108</summary>
    /// <param name="data">source input</param>
    /// <param name="scalar">scalar input</param>
    static member SmoothL1(data : NDArray, scalar : float) =
        let creator = AtomicSymbolCreator.FromName "smooth_l1"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle|]
                                                 [|"scalar"|]
                                                 [|string scalar|]
        (new NDArray(outputs.[0]))
    /// <summary>Calculate Smooth L1 Loss(lhs, scalar) by summing
    /// 
    /// .. math::
    /// 
    ///     f(x) =
    ///     \begin{cases}
    ///     (\sigma x)^2/2,&amp; \text{if }x &lt; 1/\sigma^2\\
    ///     |x|-0.5/\sigma^2,&amp; \text{otherwise}
    ///     \end{cases}
    /// 
    /// where :math:`x` is an element of the tensor *lhs* and :math:`\sigma` is the scalar.
    /// 
    /// Example::
    /// 
    ///   smooth_l1([1, 2, 3, 4]) = [0.5, 1.5, 2.5, 3.5]
    ///   smooth_l1([1, 2, 3, 4], scalar=1) = [0.5, 1.5, 2.5, 3.5]
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\elemwise_binary_scalar_op_extended.cc:L108</summary>
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="data">source input</param>
    /// <param name="scalar">scalar input</param>
    static member SmoothL1(outputArray : NDArray seq, data : NDArray, scalar : float) =
        let creator = AtomicSymbolCreator.FromName "smooth_l1"
        let names = [|"scalar"|]
        let vals = [|string scalar|]
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <summary>Calculate Smooth L1 Loss(lhs, scalar) by summing
    /// 
    /// .. math::
    /// 
    ///     f(x) =
    ///     \begin{cases}
    ///     (\sigma x)^2/2,&amp; \text{if }x &lt; 1/\sigma^2\\
    ///     |x|-0.5/\sigma^2,&amp; \text{otherwise}
    ///     \end{cases}
    /// 
    /// where :math:`x` is an element of the tensor *lhs* and :math:`\sigma` is the scalar.
    /// 
    /// Example::
    /// 
    ///   smooth_l1([1, 2, 3, 4]) = [0.5, 1.5, 2.5, 3.5]
    ///   smooth_l1([1, 2, 3, 4], scalar=1) = [0.5, 1.5, 2.5, 3.5]
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\elemwise_binary_scalar_op_extended.cc:L108</summary>
    /// <param name="data">source input</param>
    /// <param name="scalar">scalar input</param>
    static member SmoothL1(data : Symbol, scalar : float) =
        SmoothL1(data, scalar)
    /// <summary>Calculate Smooth L1 Loss(lhs, scalar) by summing
    /// 
    /// .. math::
    /// 
    ///     f(x) =
    ///     \begin{cases}
    ///     (\sigma x)^2/2,&amp; \text{if }x &lt; 1/\sigma^2\\
    ///     |x|-0.5/\sigma^2,&amp; \text{otherwise}
    ///     \end{cases}
    /// 
    /// where :math:`x` is an element of the tensor *lhs* and :math:`\sigma` is the scalar.
    /// 
    /// Example::
    /// 
    ///   smooth_l1([1, 2, 3, 4]) = [0.5, 1.5, 2.5, 3.5]
    ///   smooth_l1([1, 2, 3, 4], scalar=1) = [0.5, 1.5, 2.5, 3.5]
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\elemwise_binary_scalar_op_extended.cc:L108</summary>
    /// <param name="scalar">scalar input</param>
    /// <param name="data">source input</param>
    static member SmoothL1(scalar : float, [<Optional>] ?data : Symbol) =
        SmoothL1(scalar, ?data = data)


    /// <param name="data">source input</param>
    /// <param name="scalar">scalar input</param>
    static member EqualScalar(data : NDArray, scalar : float) =
        let creator = AtomicSymbolCreator.FromName "_equal_scalar"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle|]
                                                 [|"scalar"|]
                                                 [|string scalar|]
        (new NDArray(outputs.[0]))
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="data">source input</param>
    /// <param name="scalar">scalar input</param>
    static member EqualScalar(outputArray : NDArray seq, data : NDArray, scalar : float) =
        let creator = AtomicSymbolCreator.FromName "_equal_scalar"
        let names = [|"scalar"|]
        let vals = [|string scalar|]
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <param name="data">source input</param>
    /// <param name="scalar">scalar input</param>
    static member EqualScalar(data : Symbol, scalar : float) =
        EqualScalar(data, scalar)
    /// <param name="scalar">scalar input</param>
    /// <param name="data">source input</param>
    static member EqualScalar(scalar : float, [<Optional>] ?data : Symbol) =
        EqualScalar(scalar, ?data = data)

    /// <param name="data">source input</param>
    /// <param name="scalar">scalar input</param>
    static member NotEqualScalar(data : NDArray, scalar : float) =
        let creator = AtomicSymbolCreator.FromName "_not_equal_scalar"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle|]
                                                 [|"scalar"|]
                                                 [|string scalar|]
        (new NDArray(outputs.[0]))
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="data">source input</param>
    /// <param name="scalar">scalar input</param>
    static member NotEqualScalar(outputArray : NDArray seq, data : NDArray, scalar : float) =
        let creator = AtomicSymbolCreator.FromName "_not_equal_scalar"
        let names = [|"scalar"|]
        let vals = [|string scalar|]
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <param name="data">source input</param>
    /// <param name="scalar">scalar input</param>
    static member NotEqualScalar(data : Symbol, scalar : float) =
        NotEqualScalar(data, scalar)
    /// <param name="scalar">scalar input</param>
    /// <param name="data">source input</param>
    static member NotEqualScalar(scalar : float, [<Optional>] ?data : Symbol) =
        NotEqualScalar(scalar, ?data = data)

    /// <param name="data">source input</param>
    /// <param name="scalar">scalar input</param>
    static member GreaterScalar(data : NDArray, scalar : float) =
        let creator = AtomicSymbolCreator.FromName "_greater_scalar"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle|]
                                                 [|"scalar"|]
                                                 [|string scalar|]
        (new NDArray(outputs.[0]))
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="data">source input</param>
    /// <param name="scalar">scalar input</param>
    static member GreaterScalar(outputArray : NDArray seq, data : NDArray, scalar : float) =
        let creator = AtomicSymbolCreator.FromName "_greater_scalar"
        let names = [|"scalar"|]
        let vals = [|string scalar|]
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <param name="data">source input</param>
    /// <param name="scalar">scalar input</param>
    static member GreaterScalar(data : Symbol, scalar : float) =
        GreaterScalar(data, scalar)
    /// <param name="scalar">scalar input</param>
    /// <param name="data">source input</param>
    static member GreaterScalar(scalar : float, [<Optional>] ?data : Symbol) =
        GreaterScalar(scalar, ?data = data)

    /// <param name="data">source input</param>
    /// <param name="scalar">scalar input</param>
    static member GreaterEqualScalar(data : NDArray, scalar : float) =
        let creator = AtomicSymbolCreator.FromName "_greater_equal_scalar"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle|]
                                                 [|"scalar"|]
                                                 [|string scalar|]
        (new NDArray(outputs.[0]))
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="data">source input</param>
    /// <param name="scalar">scalar input</param>
    static member GreaterEqualScalar(outputArray : NDArray seq, data : NDArray, scalar : float) =
        let creator = AtomicSymbolCreator.FromName "_greater_equal_scalar"
        let names = [|"scalar"|]
        let vals = [|string scalar|]
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <param name="data">source input</param>
    /// <param name="scalar">scalar input</param>
    static member GreaterEqualScalar(data : Symbol, scalar : float) =
        GreaterEqualScalar(data, scalar)
    /// <param name="scalar">scalar input</param>
    /// <param name="data">source input</param>
    static member GreaterEqualScalar(scalar : float, [<Optional>] ?data : Symbol) =
        GreaterEqualScalar(scalar, ?data = data)

    /// <param name="data">source input</param>
    /// <param name="scalar">scalar input</param>
    static member LesserScalar(data : NDArray, scalar : float) =
        let creator = AtomicSymbolCreator.FromName "_lesser_scalar"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle|]
                                                 [|"scalar"|]
                                                 [|string scalar|]
        (new NDArray(outputs.[0]))
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="data">source input</param>
    /// <param name="scalar">scalar input</param>
    static member LesserScalar(outputArray : NDArray seq, data : NDArray, scalar : float) =
        let creator = AtomicSymbolCreator.FromName "_lesser_scalar"
        let names = [|"scalar"|]
        let vals = [|string scalar|]
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <param name="data">source input</param>
    /// <param name="scalar">scalar input</param>
    static member LesserScalar(data : Symbol, scalar : float) =
        LesserScalar(data, scalar)
    /// <param name="scalar">scalar input</param>
    /// <param name="data">source input</param>
    static member LesserScalar(scalar : float, [<Optional>] ?data : Symbol) =
        LesserScalar(scalar, ?data = data)

    /// <param name="data">source input</param>
    /// <param name="scalar">scalar input</param>
    static member LesserEqualScalar(data : NDArray, scalar : float) =
        let creator = AtomicSymbolCreator.FromName "_lesser_equal_scalar"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle|]
                                                 [|"scalar"|]
                                                 [|string scalar|]
        (new NDArray(outputs.[0]))
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="data">source input</param>
    /// <param name="scalar">scalar input</param>
    static member LesserEqualScalar(outputArray : NDArray seq, data : NDArray, scalar : float) =
        let creator = AtomicSymbolCreator.FromName "_lesser_equal_scalar"
        let names = [|"scalar"|]
        let vals = [|string scalar|]
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <param name="data">source input</param>
    /// <param name="scalar">scalar input</param>
    static member LesserEqualScalar(data : Symbol, scalar : float) =
        LesserEqualScalar(data, scalar)
    /// <param name="scalar">scalar input</param>
    /// <param name="data">source input</param>
    static member LesserEqualScalar(scalar : float, [<Optional>] ?data : Symbol) =
        LesserEqualScalar(scalar, ?data = data)

    /// <param name="data">source input</param>
    /// <param name="scalar">scalar input</param>
    static member LogicalAndScalar(data : NDArray, scalar : float) =
        let creator = AtomicSymbolCreator.FromName "_logical_and_scalar"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle|]
                                                 [|"scalar"|]
                                                 [|string scalar|]
        (new NDArray(outputs.[0]))
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="data">source input</param>
    /// <param name="scalar">scalar input</param>
    static member LogicalAndScalar(outputArray : NDArray seq, data : NDArray, scalar : float) =
        let creator = AtomicSymbolCreator.FromName "_logical_and_scalar"
        let names = [|"scalar"|]
        let vals = [|string scalar|]
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <param name="data">source input</param>
    /// <param name="scalar">scalar input</param>
    static member LogicalAndScalar(data : Symbol, scalar : float) =
        LogicalAndScalar(data, scalar)
    /// <param name="scalar">scalar input</param>
    /// <param name="data">source input</param>
    static member LogicalAndScalar(scalar : float, [<Optional>] ?data : Symbol) =
        LogicalAndScalar(scalar, ?data = data)

    /// <param name="data">source input</param>
    /// <param name="scalar">scalar input</param>
    static member LogicalOrScalar(data : NDArray, scalar : float) =
        let creator = AtomicSymbolCreator.FromName "_logical_or_scalar"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle|]
                                                 [|"scalar"|]
                                                 [|string scalar|]
        (new NDArray(outputs.[0]))
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="data">source input</param>
    /// <param name="scalar">scalar input</param>
    static member LogicalOrScalar(outputArray : NDArray seq, data : NDArray, scalar : float) =
        let creator = AtomicSymbolCreator.FromName "_logical_or_scalar"
        let names = [|"scalar"|]
        let vals = [|string scalar|]
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <param name="data">source input</param>
    /// <param name="scalar">scalar input</param>
    static member LogicalOrScalar(data : Symbol, scalar : float) =
        LogicalOrScalar(data, scalar)
    /// <param name="scalar">scalar input</param>
    /// <param name="data">source input</param>
    static member LogicalOrScalar(scalar : float, [<Optional>] ?data : Symbol) =
        LogicalOrScalar(scalar, ?data = data)

    /// <param name="data">source input</param>
    /// <param name="scalar">scalar input</param>
    static member LogicalXorScalar(data : NDArray, scalar : float) =
        let creator = AtomicSymbolCreator.FromName "_logical_xor_scalar"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle|]
                                                 [|"scalar"|]
                                                 [|string scalar|]
        (new NDArray(outputs.[0]))
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="data">source input</param>
    /// <param name="scalar">scalar input</param>
    static member LogicalXorScalar(outputArray : NDArray seq, data : NDArray, scalar : float) =
        let creator = AtomicSymbolCreator.FromName "_logical_xor_scalar"
        let names = [|"scalar"|]
        let vals = [|string scalar|]
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <param name="data">source input</param>
    /// <param name="scalar">scalar input</param>
    static member LogicalXorScalar(data : Symbol, scalar : float) =
        LogicalXorScalar(data, scalar)
    /// <param name="scalar">scalar input</param>
    /// <param name="data">source input</param>
    static member LogicalXorScalar(scalar : float, [<Optional>] ?data : Symbol) =
        LogicalXorScalar(scalar, ?data = data)

    /// <summary>Divides arguments element-wise.  If the left-hand-side input is &#39;row_sparse&#39;, then
    /// only the values which exist in the left-hand sparse array are computed.  The &#39;missing&#39; values
    /// are ignored.
    /// 
    /// The storage type of ``_scatter_elemwise_div`` output depends on storage types of inputs
    /// 
    /// - _scatter_elemwise_div(row_sparse, row_sparse) = row_sparse
    /// - _scatter_elemwise_div(row_sparse, dense) = row_sparse
    /// - _scatter_elemwise_div(row_sparse, csr) = row_sparse
    /// - otherwise, ``_scatter_elemwise_div`` behaves exactly like elemwise_div and generates output
    /// with default storage
    /// 
    /// </summary>
    /// <param name="lhs">first input</param>
    /// <param name="rhs">second input</param>
    static member ScatterElemwiseDiv(lhs : NDArray, rhs : NDArray) =
        let creator = AtomicSymbolCreator.FromName "_scatter_elemwise_div"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg lhs)) then lhs.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg rhs)) then rhs.UnsafeHandle|]
                                                 Array.empty
                                                 Array.empty
        (new NDArray(outputs.[0]))
    /// <summary>Divides arguments element-wise.  If the left-hand-side input is &#39;row_sparse&#39;, then
    /// only the values which exist in the left-hand sparse array are computed.  The &#39;missing&#39; values
    /// are ignored.
    /// 
    /// The storage type of ``_scatter_elemwise_div`` output depends on storage types of inputs
    /// 
    /// - _scatter_elemwise_div(row_sparse, row_sparse) = row_sparse
    /// - _scatter_elemwise_div(row_sparse, dense) = row_sparse
    /// - _scatter_elemwise_div(row_sparse, csr) = row_sparse
    /// - otherwise, ``_scatter_elemwise_div`` behaves exactly like elemwise_div and generates output
    /// with default storage
    /// 
    /// </summary>
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="lhs">first input</param>
    /// <param name="rhs">second input</param>
    static member ScatterElemwiseDiv(outputArray : NDArray seq, lhs : NDArray, rhs : NDArray) =
        let creator = AtomicSymbolCreator.FromName "_scatter_elemwise_div"
        let names = Array.empty
        let vals = Array.empty
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg lhs)) then lhs.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg rhs)) then rhs.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <summary>Divides arguments element-wise.  If the left-hand-side input is &#39;row_sparse&#39;, then
    /// only the values which exist in the left-hand sparse array are computed.  The &#39;missing&#39; values
    /// are ignored.
    /// 
    /// The storage type of ``_scatter_elemwise_div`` output depends on storage types of inputs
    /// 
    /// - _scatter_elemwise_div(row_sparse, row_sparse) = row_sparse
    /// - _scatter_elemwise_div(row_sparse, dense) = row_sparse
    /// - _scatter_elemwise_div(row_sparse, csr) = row_sparse
    /// - otherwise, ``_scatter_elemwise_div`` behaves exactly like elemwise_div and generates output
    /// with default storage
    /// 
    /// </summary>
    /// <param name="lhs">first input</param>
    /// <param name="rhs">second input</param>
    static member ScatterElemwiseDiv([<Optional>] ?lhs : Symbol, [<Optional>] ?rhs : Symbol) =
        ScatterElemwiseDiv(?lhs = lhs, ?rhs = rhs)

    /// <summary>Adds a scalar to a tensor element-wise.  If the left-hand-side input is
    /// &#39;row_sparse&#39; or &#39;csr&#39;, then only the values which exist in the left-hand sparse array are computed.
    /// The &#39;missing&#39; values are ignored.
    /// 
    /// The storage type of ``_scatter_plus_scalar`` output depends on storage types of inputs
    /// 
    /// - _scatter_plus_scalar(row_sparse, scalar) = row_sparse
    /// - _scatter_plus_scalar(csr, scalar) = csr
    /// - otherwise, ``_scatter_plus_scalar`` behaves exactly like _plus_scalar and generates output
    /// with default storage
    /// 
    /// </summary>
    /// <param name="data">source input</param>
    /// <param name="scalar">scalar input</param>
    static member ScatterPlusScalar(data : NDArray, scalar : float) =
        let creator = AtomicSymbolCreator.FromName "_scatter_plus_scalar"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle|]
                                                 [|"scalar"|]
                                                 [|string scalar|]
        (new NDArray(outputs.[0]))
    /// <summary>Adds a scalar to a tensor element-wise.  If the left-hand-side input is
    /// &#39;row_sparse&#39; or &#39;csr&#39;, then only the values which exist in the left-hand sparse array are computed.
    /// The &#39;missing&#39; values are ignored.
    /// 
    /// The storage type of ``_scatter_plus_scalar`` output depends on storage types of inputs
    /// 
    /// - _scatter_plus_scalar(row_sparse, scalar) = row_sparse
    /// - _scatter_plus_scalar(csr, scalar) = csr
    /// - otherwise, ``_scatter_plus_scalar`` behaves exactly like _plus_scalar and generates output
    /// with default storage
    /// 
    /// </summary>
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="data">source input</param>
    /// <param name="scalar">scalar input</param>
    static member ScatterPlusScalar(outputArray : NDArray seq, data : NDArray, scalar : float) =
        let creator = AtomicSymbolCreator.FromName "_scatter_plus_scalar"
        let names = [|"scalar"|]
        let vals = [|string scalar|]
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <summary>Adds a scalar to a tensor element-wise.  If the left-hand-side input is
    /// &#39;row_sparse&#39; or &#39;csr&#39;, then only the values which exist in the left-hand sparse array are computed.
    /// The &#39;missing&#39; values are ignored.
    /// 
    /// The storage type of ``_scatter_plus_scalar`` output depends on storage types of inputs
    /// 
    /// - _scatter_plus_scalar(row_sparse, scalar) = row_sparse
    /// - _scatter_plus_scalar(csr, scalar) = csr
    /// - otherwise, ``_scatter_plus_scalar`` behaves exactly like _plus_scalar and generates output
    /// with default storage
    /// 
    /// </summary>
    /// <param name="data">source input</param>
    /// <param name="scalar">scalar input</param>
    static member ScatterPlusScalar(data : Symbol, scalar : float) =
        ScatterPlusScalar(data, scalar)
    /// <summary>Adds a scalar to a tensor element-wise.  If the left-hand-side input is
    /// &#39;row_sparse&#39; or &#39;csr&#39;, then only the values which exist in the left-hand sparse array are computed.
    /// The &#39;missing&#39; values are ignored.
    /// 
    /// The storage type of ``_scatter_plus_scalar`` output depends on storage types of inputs
    /// 
    /// - _scatter_plus_scalar(row_sparse, scalar) = row_sparse
    /// - _scatter_plus_scalar(csr, scalar) = csr
    /// - otherwise, ``_scatter_plus_scalar`` behaves exactly like _plus_scalar and generates output
    /// with default storage
    /// 
    /// </summary>
    /// <param name="scalar">scalar input</param>
    /// <param name="data">source input</param>
    static member ScatterPlusScalar(scalar : float, [<Optional>] ?data : Symbol) =
        ScatterPlusScalar(scalar, ?data = data)

    /// <summary>Subtracts a scalar to a tensor element-wise.  If the left-hand-side input is
    /// &#39;row_sparse&#39; or &#39;csr&#39;, then only the values which exist in the left-hand sparse array are computed.
    /// The &#39;missing&#39; values are ignored.
    /// 
    /// The storage type of ``_scatter_minus_scalar`` output depends on storage types of inputs
    /// 
    /// - _scatter_minus_scalar(row_sparse, scalar) = row_sparse
    /// - _scatter_minus_scalar(csr, scalar) = csr
    /// - otherwise, ``_scatter_minus_scalar`` behaves exactly like _minus_scalar and generates output
    /// with default storage
    /// 
    /// </summary>
    /// <param name="data">source input</param>
    /// <param name="scalar">scalar input</param>
    static member ScatterMinusScalar(data : NDArray, scalar : float) =
        let creator = AtomicSymbolCreator.FromName "_scatter_minus_scalar"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle|]
                                                 [|"scalar"|]
                                                 [|string scalar|]
        (new NDArray(outputs.[0]))
    /// <summary>Subtracts a scalar to a tensor element-wise.  If the left-hand-side input is
    /// &#39;row_sparse&#39; or &#39;csr&#39;, then only the values which exist in the left-hand sparse array are computed.
    /// The &#39;missing&#39; values are ignored.
    /// 
    /// The storage type of ``_scatter_minus_scalar`` output depends on storage types of inputs
    /// 
    /// - _scatter_minus_scalar(row_sparse, scalar) = row_sparse
    /// - _scatter_minus_scalar(csr, scalar) = csr
    /// - otherwise, ``_scatter_minus_scalar`` behaves exactly like _minus_scalar and generates output
    /// with default storage
    /// 
    /// </summary>
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="data">source input</param>
    /// <param name="scalar">scalar input</param>
    static member ScatterMinusScalar(outputArray : NDArray seq, data : NDArray, scalar : float) =
        let creator = AtomicSymbolCreator.FromName "_scatter_minus_scalar"
        let names = [|"scalar"|]
        let vals = [|string scalar|]
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <summary>Subtracts a scalar to a tensor element-wise.  If the left-hand-side input is
    /// &#39;row_sparse&#39; or &#39;csr&#39;, then only the values which exist in the left-hand sparse array are computed.
    /// The &#39;missing&#39; values are ignored.
    /// 
    /// The storage type of ``_scatter_minus_scalar`` output depends on storage types of inputs
    /// 
    /// - _scatter_minus_scalar(row_sparse, scalar) = row_sparse
    /// - _scatter_minus_scalar(csr, scalar) = csr
    /// - otherwise, ``_scatter_minus_scalar`` behaves exactly like _minus_scalar and generates output
    /// with default storage
    /// 
    /// </summary>
    /// <param name="data">source input</param>
    /// <param name="scalar">scalar input</param>
    static member ScatterMinusScalar(data : Symbol, scalar : float) =
        ScatterMinusScalar(data, scalar)
    /// <summary>Subtracts a scalar to a tensor element-wise.  If the left-hand-side input is
    /// &#39;row_sparse&#39; or &#39;csr&#39;, then only the values which exist in the left-hand sparse array are computed.
    /// The &#39;missing&#39; values are ignored.
    /// 
    /// The storage type of ``_scatter_minus_scalar`` output depends on storage types of inputs
    /// 
    /// - _scatter_minus_scalar(row_sparse, scalar) = row_sparse
    /// - _scatter_minus_scalar(csr, scalar) = csr
    /// - otherwise, ``_scatter_minus_scalar`` behaves exactly like _minus_scalar and generates output
    /// with default storage
    /// 
    /// </summary>
    /// <param name="scalar">scalar input</param>
    /// <param name="data">source input</param>
    static member ScatterMinusScalar(scalar : float, [<Optional>] ?data : Symbol) =
        ScatterMinusScalar(scalar, ?data = data)

    /// <summary>Adds all input arguments element-wise.
    /// 
    /// .. math::
    ///    add\_n(a_1, a_2, ..., a_n) = a_1 + a_2 + ... + a_n
    /// 
    /// ``add_n`` is potentially more efficient than calling ``add`` by `n` times.
    /// 
    /// The storage type of ``add_n`` output depends on storage types of inputs
    /// 
    /// - add_n(row_sparse, row_sparse, ..) = row_sparse
    /// - add_n(default, csr, default) = default
    /// - add_n(any input combinations longer than 4 (&gt;4) with at least one default type) = default
    /// - otherwise, ``add_n`` falls all inputs back to default storage and generates default storage
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\elemwise_sum.cc:L155</summary>
    /// <param name="args">Positional input arguments</param>
    static member AddN([<ParamArray>] args : NDArray[]) =
        let creator = AtomicSymbolCreator.FromName "add_n"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 (args |> Array.map (fun x -> x.UnsafeHandle))
                                                 Array.empty
                                                 Array.empty
        (new NDArray(outputs.[0]))
    /// <summary>Adds all input arguments element-wise.
    /// 
    /// .. math::
    ///    add\_n(a_1, a_2, ..., a_n) = a_1 + a_2 + ... + a_n
    /// 
    /// ``add_n`` is potentially more efficient than calling ``add`` by `n` times.
    /// 
    /// The storage type of ``add_n`` output depends on storage types of inputs
    /// 
    /// - add_n(row_sparse, row_sparse, ..) = row_sparse
    /// - add_n(default, csr, default) = default
    /// - add_n(any input combinations longer than 4 (&gt;4) with at least one default type) = default
    /// - otherwise, ``add_n`` falls all inputs back to default storage and generates default storage
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\elemwise_sum.cc:L155</summary>
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="args">Positional input arguments</param>
    static member AddN(outputArray : NDArray seq, [<ParamArray>] args : NDArray[]) =
        let creator = AtomicSymbolCreator.FromName "add_n"
        let names = Array.empty
        let vals = Array.empty
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     (args |> Array.map (fun x -> x.UnsafeHandle))
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <summary>Adds all input arguments element-wise.
    /// 
    /// .. math::
    ///    add\_n(a_1, a_2, ..., a_n) = a_1 + a_2 + ... + a_n
    /// 
    /// ``add_n`` is potentially more efficient than calling ``add`` by `n` times.
    /// 
    /// The storage type of ``add_n`` output depends on storage types of inputs
    /// 
    /// - add_n(row_sparse, row_sparse, ..) = row_sparse
    /// - add_n(default, csr, default) = default
    /// - add_n(any input combinations longer than 4 (&gt;4) with at least one default type) = default
    /// - otherwise, ``add_n`` falls all inputs back to default storage and generates default storage
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\elemwise_sum.cc:L155</summary>
    /// <param name="args">Positional input arguments</param>
    static member AddN([<ParamArray>] args : Symbol[]) =
        AddN(args)

    /// <summary>Computes rectified linear activation.
    /// 
    /// .. math::
    ///    max(features, 0)
    /// 
    /// The storage type of ``relu`` output depends upon the input storage type:
    /// 
    ///    - relu(default) = default
    ///    - relu(row_sparse) = row_sparse
    ///    - relu(csr) = csr
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\elemwise_unary_op_basic.cc:L85</summary>
    /// <param name="data">The input array.</param>
    static member Relu(data : NDArray) =
        let creator = AtomicSymbolCreator.FromName "relu"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle|]
                                                 Array.empty
                                                 Array.empty
        (new NDArray(outputs.[0]))
    /// <summary>Computes rectified linear activation.
    /// 
    /// .. math::
    ///    max(features, 0)
    /// 
    /// The storage type of ``relu`` output depends upon the input storage type:
    /// 
    ///    - relu(default) = default
    ///    - relu(row_sparse) = row_sparse
    ///    - relu(csr) = csr
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\elemwise_unary_op_basic.cc:L85</summary>
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="data">The input array.</param>
    static member Relu(outputArray : NDArray seq, data : NDArray) =
        let creator = AtomicSymbolCreator.FromName "relu"
        let names = Array.empty
        let vals = Array.empty
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <summary>Computes rectified linear activation.
    /// 
    /// .. math::
    ///    max(features, 0)
    /// 
    /// The storage type of ``relu`` output depends upon the input storage type:
    /// 
    ///    - relu(default) = default
    ///    - relu(row_sparse) = row_sparse
    ///    - relu(csr) = csr
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\elemwise_unary_op_basic.cc:L85</summary>
    /// <param name="data">The input array.</param>
    static member Relu([<Optional>] ?data : Symbol) =
        Relu(?data = data)


    /// <summary>Computes sigmoid of x element-wise.
    /// 
    /// .. math::
    ///    y = 1 / (1 + exp(-x))
    /// 
    /// The storage type of ``sigmoid`` output is always dense
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\elemwise_unary_op_basic.cc:L119</summary>
    /// <param name="data">The input array.</param>
    static member Sigmoid(data : NDArray) =
        let creator = AtomicSymbolCreator.FromName "sigmoid"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle|]
                                                 Array.empty
                                                 Array.empty
        (new NDArray(outputs.[0]))
    /// <summary>Computes sigmoid of x element-wise.
    /// 
    /// .. math::
    ///    y = 1 / (1 + exp(-x))
    /// 
    /// The storage type of ``sigmoid`` output is always dense
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\elemwise_unary_op_basic.cc:L119</summary>
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="data">The input array.</param>
    static member Sigmoid(outputArray : NDArray seq, data : NDArray) =
        let creator = AtomicSymbolCreator.FromName "sigmoid"
        let names = Array.empty
        let vals = Array.empty
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <summary>Computes sigmoid of x element-wise.
    /// 
    /// .. math::
    ///    y = 1 / (1 + exp(-x))
    /// 
    /// The storage type of ``sigmoid`` output is always dense
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\elemwise_unary_op_basic.cc:L119</summary>
    /// <param name="data">The input array.</param>
    static member Sigmoid([<Optional>] ?data : Symbol) =
        Sigmoid(?data = data)


    /// <summary>Computes hard sigmoid of x element-wise.
    /// 
    /// .. math::
    ///    y = max(0, min(1, alpha * x + beta))
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\elemwise_unary_op_basic.cc:L161</summary>
    /// <param name="data">The input array.</param>
    /// <param name="alpha">Slope of hard sigmoid</param>
    /// <param name="beta">Bias of hard sigmoid.</param>
    static member HardSigmoid(data : NDArray, [<Optional; DefaultParameterValue(0.200000003)>] alpha : float, [<Optional; DefaultParameterValue(0.5)>] beta : float) =
        let creator = AtomicSymbolCreator.FromName "hard_sigmoid"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle|]
                                                 [|"alpha"; "beta"|]
                                                 [|string alpha; string beta|]
        (new NDArray(outputs.[0]))
    /// <summary>Computes hard sigmoid of x element-wise.
    /// 
    /// .. math::
    ///    y = max(0, min(1, alpha * x + beta))
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\elemwise_unary_op_basic.cc:L161</summary>
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="data">The input array.</param>
    /// <param name="alpha">Slope of hard sigmoid</param>
    /// <param name="beta">Bias of hard sigmoid.</param>
    static member HardSigmoid(outputArray : NDArray seq, data : NDArray, [<Optional; DefaultParameterValue(0.200000003)>] alpha : float, [<Optional; DefaultParameterValue(0.5)>] beta : float) =
        let creator = AtomicSymbolCreator.FromName "hard_sigmoid"
        let names = [|"alpha"; "beta"|]
        let vals = [|string alpha; string beta|]
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <summary>Computes hard sigmoid of x element-wise.
    /// 
    /// .. math::
    ///    y = max(0, min(1, alpha * x + beta))
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\elemwise_unary_op_basic.cc:L161</summary>
    /// <param name="data">The input array.</param>
    /// <param name="alpha">Slope of hard sigmoid</param>
    /// <param name="beta">Bias of hard sigmoid.</param>
    static member HardSigmoid([<Optional>] ?data : Symbol, [<Optional>] ?alpha : float, [<Optional>] ?beta : float) =
        HardSigmoid(?data = data, ?alpha = alpha, ?beta = beta)


    /// <summary>Computes softsign of x element-wise.
    /// 
    /// .. math::
    ///    y = x / (1 + abs(x))
    /// 
    /// The storage type of ``softsign`` output is always dense
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\elemwise_unary_op_basic.cc:L191</summary>
    /// <param name="data">The input array.</param>
    static member Softsign(data : NDArray) =
        let creator = AtomicSymbolCreator.FromName "softsign"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle|]
                                                 Array.empty
                                                 Array.empty
        (new NDArray(outputs.[0]))
    /// <summary>Computes softsign of x element-wise.
    /// 
    /// .. math::
    ///    y = x / (1 + abs(x))
    /// 
    /// The storage type of ``softsign`` output is always dense
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\elemwise_unary_op_basic.cc:L191</summary>
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="data">The input array.</param>
    static member Softsign(outputArray : NDArray seq, data : NDArray) =
        let creator = AtomicSymbolCreator.FromName "softsign"
        let names = Array.empty
        let vals = Array.empty
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <summary>Computes softsign of x element-wise.
    /// 
    /// .. math::
    ///    y = x / (1 + abs(x))
    /// 
    /// The storage type of ``softsign`` output is always dense
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\elemwise_unary_op_basic.cc:L191</summary>
    /// <param name="data">The input array.</param>
    static member Softsign([<Optional>] ?data : Symbol) =
        Softsign(?data = data)


    /// <summary>Returns a copy of the input.
    /// 
    /// From:C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\elemwise_unary_op_basic.cc:246</summary>
    /// <param name="data">The input array.</param>
    static member Copy(data : NDArray) =
        let creator = AtomicSymbolCreator.FromName "_copy"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle|]
                                                 Array.empty
                                                 Array.empty
        (new NDArray(outputs.[0]))
    /// <summary>Returns a copy of the input.
    /// 
    /// From:C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\elemwise_unary_op_basic.cc:246</summary>
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="data">The input array.</param>
    static member Copy(outputArray : NDArray seq, data : NDArray) =
        let creator = AtomicSymbolCreator.FromName "_copy"
        let names = Array.empty
        let vals = Array.empty
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <summary>Returns a copy of the input.
    /// 
    /// From:C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\elemwise_unary_op_basic.cc:246</summary>
    /// <param name="data">The input array.</param>
    static member Copy([<Optional>] ?data : Symbol) =
        Copy(?data = data)



    /// <summary>Stops gradient computation.
    /// 
    /// Stops the accumulated gradient of the inputs from flowing through this operator
    /// in the backward direction. In other words, this operator prevents the contribution
    /// of its inputs to be taken into account for computing gradients.
    /// 
    /// Example::
    /// 
    ///   v1 = [1, 2]
    ///   v2 = [0, 1]
    ///   a = Variable(&#39;a&#39;)
    ///   b = Variable(&#39;b&#39;)
    ///   b_stop_grad = stop_gradient(3 * b)
    ///   loss = MakeLoss(b_stop_grad + a)
    /// 
    ///   executor = loss.simple_bind(ctx=cpu(), a=(1,2), b=(1,2))
    ///   executor.forward(is_train=True, a=v1, b=v2)
    ///   executor.outputs
    ///   [ 1.  5.]
    /// 
    ///   executor.backward()
    ///   executor.grad_arrays
    ///   [ 0.  0.]
    ///   [ 1.  1.]
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\elemwise_unary_op_basic.cc:L327</summary>
    /// <param name="data">The input array.</param>
    static member BlockGrad(data : NDArray) =
        let creator = AtomicSymbolCreator.FromName "BlockGrad"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle|]
                                                 Array.empty
                                                 Array.empty
        (new NDArray(outputs.[0]))
    /// <summary>Stops gradient computation.
    /// 
    /// Stops the accumulated gradient of the inputs from flowing through this operator
    /// in the backward direction. In other words, this operator prevents the contribution
    /// of its inputs to be taken into account for computing gradients.
    /// 
    /// Example::
    /// 
    ///   v1 = [1, 2]
    ///   v2 = [0, 1]
    ///   a = Variable(&#39;a&#39;)
    ///   b = Variable(&#39;b&#39;)
    ///   b_stop_grad = stop_gradient(3 * b)
    ///   loss = MakeLoss(b_stop_grad + a)
    /// 
    ///   executor = loss.simple_bind(ctx=cpu(), a=(1,2), b=(1,2))
    ///   executor.forward(is_train=True, a=v1, b=v2)
    ///   executor.outputs
    ///   [ 1.  5.]
    /// 
    ///   executor.backward()
    ///   executor.grad_arrays
    ///   [ 0.  0.]
    ///   [ 1.  1.]
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\elemwise_unary_op_basic.cc:L327</summary>
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="data">The input array.</param>
    static member BlockGrad(outputArray : NDArray seq, data : NDArray) =
        let creator = AtomicSymbolCreator.FromName "BlockGrad"
        let names = Array.empty
        let vals = Array.empty
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <summary>Stops gradient computation.
    /// 
    /// Stops the accumulated gradient of the inputs from flowing through this operator
    /// in the backward direction. In other words, this operator prevents the contribution
    /// of its inputs to be taken into account for computing gradients.
    /// 
    /// Example::
    /// 
    ///   v1 = [1, 2]
    ///   v2 = [0, 1]
    ///   a = Variable(&#39;a&#39;)
    ///   b = Variable(&#39;b&#39;)
    ///   b_stop_grad = stop_gradient(3 * b)
    ///   loss = MakeLoss(b_stop_grad + a)
    /// 
    ///   executor = loss.simple_bind(ctx=cpu(), a=(1,2), b=(1,2))
    ///   executor.forward(is_train=True, a=v1, b=v2)
    ///   executor.outputs
    ///   [ 1.  5.]
    /// 
    ///   executor.backward()
    ///   executor.grad_arrays
    ///   [ 0.  0.]
    ///   [ 1.  1.]
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\elemwise_unary_op_basic.cc:L327</summary>
    /// <param name="data">The input array.</param>
    static member BlockGrad([<Optional>] ?data : Symbol) =
        BlockGrad(?data = data)

    /// <summary>Make your own loss function in network construction.
    /// 
    /// This operator accepts a customized loss function symbol as a terminal loss and
    /// the symbol should be an operator with no backward dependency.
    /// The output of this function is the gradient of loss with respect to the input data.
    /// 
    /// For example, if you are a making a cross entropy loss function. Assume ``out`` is the
    /// predicted output and ``label`` is the true label, then the cross entropy can be defined as::
    /// 
    ///   cross_entropy = label * log(out) + (1 - label) * log(1 - out)
    ///   loss = make_loss(cross_entropy)
    /// 
    /// We will need to use ``make_loss`` when we are creating our own loss function or we want to
    /// combine multiple loss functions. Also we may want to stop some variables&#39; gradients
    /// from backpropagation. See more detail in ``BlockGrad`` or ``stop_gradient``.
    /// 
    /// The storage type of ``make_loss`` output depends upon the input storage type:
    /// 
    ///    - make_loss(default) = default
    ///    - make_loss(row_sparse) = row_sparse
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\elemwise_unary_op_basic.cc:L360</summary>
    /// <param name="data">The input array.</param>
    static member MakeLoss(data : NDArray) =
        let creator = AtomicSymbolCreator.FromName "make_loss"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle|]
                                                 Array.empty
                                                 Array.empty
        (new NDArray(outputs.[0]))
    /// <summary>Make your own loss function in network construction.
    /// 
    /// This operator accepts a customized loss function symbol as a terminal loss and
    /// the symbol should be an operator with no backward dependency.
    /// The output of this function is the gradient of loss with respect to the input data.
    /// 
    /// For example, if you are a making a cross entropy loss function. Assume ``out`` is the
    /// predicted output and ``label`` is the true label, then the cross entropy can be defined as::
    /// 
    ///   cross_entropy = label * log(out) + (1 - label) * log(1 - out)
    ///   loss = make_loss(cross_entropy)
    /// 
    /// We will need to use ``make_loss`` when we are creating our own loss function or we want to
    /// combine multiple loss functions. Also we may want to stop some variables&#39; gradients
    /// from backpropagation. See more detail in ``BlockGrad`` or ``stop_gradient``.
    /// 
    /// The storage type of ``make_loss`` output depends upon the input storage type:
    /// 
    ///    - make_loss(default) = default
    ///    - make_loss(row_sparse) = row_sparse
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\elemwise_unary_op_basic.cc:L360</summary>
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="data">The input array.</param>
    static member MakeLoss(outputArray : NDArray seq, data : NDArray) =
        let creator = AtomicSymbolCreator.FromName "make_loss"
        let names = Array.empty
        let vals = Array.empty
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <summary>Make your own loss function in network construction.
    /// 
    /// This operator accepts a customized loss function symbol as a terminal loss and
    /// the symbol should be an operator with no backward dependency.
    /// The output of this function is the gradient of loss with respect to the input data.
    /// 
    /// For example, if you are a making a cross entropy loss function. Assume ``out`` is the
    /// predicted output and ``label`` is the true label, then the cross entropy can be defined as::
    /// 
    ///   cross_entropy = label * log(out) + (1 - label) * log(1 - out)
    ///   loss = make_loss(cross_entropy)
    /// 
    /// We will need to use ``make_loss`` when we are creating our own loss function or we want to
    /// combine multiple loss functions. Also we may want to stop some variables&#39; gradients
    /// from backpropagation. See more detail in ``BlockGrad`` or ``stop_gradient``.
    /// 
    /// The storage type of ``make_loss`` output depends upon the input storage type:
    /// 
    ///    - make_loss(default) = default
    ///    - make_loss(row_sparse) = row_sparse
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\elemwise_unary_op_basic.cc:L360</summary>
    /// <param name="data">The input array.</param>
    static member MakeLoss([<Optional>] ?data : Symbol) =
        MakeLoss(?data = data)

    /// <param name="lhs">First input.</param>
    /// <param name="rhs">Second input.</param>
    static member IdentityWithAttrLikeRhs(lhs : NDArray, rhs : NDArray) =
        let creator = AtomicSymbolCreator.FromName "_identity_with_attr_like_rhs"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg lhs)) then lhs.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg rhs)) then rhs.UnsafeHandle|]
                                                 Array.empty
                                                 Array.empty
        outputs |> Array.map (fun h -> new NDArray(h))
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="lhs">First input.</param>
    /// <param name="rhs">Second input.</param>
    static member IdentityWithAttrLikeRhs(outputArray : NDArray seq, lhs : NDArray, rhs : NDArray) =
        let creator = AtomicSymbolCreator.FromName "_identity_with_attr_like_rhs"
        let names = Array.empty
        let vals = Array.empty
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg lhs)) then lhs.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg rhs)) then rhs.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <param name="lhs">First input.</param>
    /// <param name="rhs">Second input.</param>
    static member IdentityWithAttrLikeRhs([<Optional>] ?lhs : Symbol, [<Optional>] ?rhs : Symbol) =
        IdentityWithAttrLikeRhs(?lhs = lhs, ?rhs = rhs)

    /// <summary>Reshape some or all dimensions of `lhs` to have the same shape as some or all dimensions of `rhs`.
    /// 
    /// Returns a **view** of the `lhs` array with a new shape without altering any data.
    /// 
    /// Example::
    /// 
    ///   x = [1, 2, 3, 4, 5, 6]
    ///   y = [[0, -4], [3, 2], [2, 2]]
    ///   reshape_like(x, y) = [[1, 2], [3, 4], [5, 6]]
    /// 
    /// More precise control over how dimensions are inherited is achieved by specifying \
    /// slices over the `lhs` and `rhs` array dimensions. Only the sliced `lhs` dimensions \
    /// are reshaped to the `rhs` sliced dimensions, with the non-sliced `lhs` dimensions staying the same.
    /// 
    ///   Examples::
    /// 
    ///   - lhs shape = (30,7), rhs shape = (15,2,4), lhs_begin=0, lhs_end=1, rhs_begin=0, rhs_end=2, output shape = (15,2,7)
    ///   - lhs shape = (3, 5), rhs shape = (1,15,4), lhs_begin=0, lhs_end=2, rhs_begin=1, rhs_end=2, output shape = (15)
    /// 
    /// Negative indices are supported, and `None` can be used for either `lhs_end` or `rhs_end` to indicate the end of the range.
    /// 
    ///   Example::
    /// 
    ///   - lhs shape = (30, 12), rhs shape = (4, 2, 2, 3), lhs_begin=-1, lhs_end=None, rhs_begin=1, rhs_end=None, output shape = (30, 2, 2, 3)
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\elemwise_unary_op_basic.cc:L513</summary>
    /// <param name="lhs">First input.</param>
    /// <param name="rhs">Second input.</param>
    /// <param name="lhsBegin">Defaults to 0. The beginning index along which the lhs dimensions are to be reshaped. Supports negative indices.</param>
    /// <param name="lhsEnd">Defaults to None. The ending index along which the lhs dimensions are to be used for reshaping. Supports negative indices.</param>
    /// <param name="rhsBegin">Defaults to 0. The beginning index along which the rhs dimensions are to be used for reshaping. Supports negative indices.</param>
    /// <param name="rhsEnd">Defaults to None. The ending index along which the rhs dimensions are to be used for reshaping. Supports negative indices.</param>
    static member ReshapeLike(lhs : NDArray, 
                              rhs : NDArray, 
                              [<Optional>] ?lhsBegin : int, 
                              [<Optional>] ?lhsEnd : int, 
                              [<Optional>] ?rhsBegin : int, 
                              [<Optional>] ?rhsEnd : int) =
        let creator = AtomicSymbolCreator.FromName "reshape_like"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg lhs)) then lhs.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg rhs)) then rhs.UnsafeHandle|]
                                                 [|"lhs_begin"; "lhs_end"; "rhs_begin"; "rhs_end"|]
                                                 [|(match lhsBegin with None -> "None" | Some lhsBegin -> string lhsBegin); (match lhsEnd with None -> "None" | Some lhsEnd -> string lhsEnd); (match rhsBegin with None -> "None" | Some rhsBegin -> string rhsBegin); (match rhsEnd with None -> "None" | Some rhsEnd -> string rhsEnd)|]
        (new NDArray(outputs.[0]))
    /// <summary>Reshape some or all dimensions of `lhs` to have the same shape as some or all dimensions of `rhs`.
    /// 
    /// Returns a **view** of the `lhs` array with a new shape without altering any data.
    /// 
    /// Example::
    /// 
    ///   x = [1, 2, 3, 4, 5, 6]
    ///   y = [[0, -4], [3, 2], [2, 2]]
    ///   reshape_like(x, y) = [[1, 2], [3, 4], [5, 6]]
    /// 
    /// More precise control over how dimensions are inherited is achieved by specifying \
    /// slices over the `lhs` and `rhs` array dimensions. Only the sliced `lhs` dimensions \
    /// are reshaped to the `rhs` sliced dimensions, with the non-sliced `lhs` dimensions staying the same.
    /// 
    ///   Examples::
    /// 
    ///   - lhs shape = (30,7), rhs shape = (15,2,4), lhs_begin=0, lhs_end=1, rhs_begin=0, rhs_end=2, output shape = (15,2,7)
    ///   - lhs shape = (3, 5), rhs shape = (1,15,4), lhs_begin=0, lhs_end=2, rhs_begin=1, rhs_end=2, output shape = (15)
    /// 
    /// Negative indices are supported, and `None` can be used for either `lhs_end` or `rhs_end` to indicate the end of the range.
    /// 
    ///   Example::
    /// 
    ///   - lhs shape = (30, 12), rhs shape = (4, 2, 2, 3), lhs_begin=-1, lhs_end=None, rhs_begin=1, rhs_end=None, output shape = (30, 2, 2, 3)
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\elemwise_unary_op_basic.cc:L513</summary>
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="lhs">First input.</param>
    /// <param name="rhs">Second input.</param>
    /// <param name="lhsBegin">Defaults to 0. The beginning index along which the lhs dimensions are to be reshaped. Supports negative indices.</param>
    /// <param name="lhsEnd">Defaults to None. The ending index along which the lhs dimensions are to be used for reshaping. Supports negative indices.</param>
    /// <param name="rhsBegin">Defaults to 0. The beginning index along which the rhs dimensions are to be used for reshaping. Supports negative indices.</param>
    /// <param name="rhsEnd">Defaults to None. The ending index along which the rhs dimensions are to be used for reshaping. Supports negative indices.</param>
    static member ReshapeLike(outputArray : NDArray seq, 
                              lhs : NDArray, 
                              rhs : NDArray, 
                              [<Optional>] ?lhsBegin : int, 
                              [<Optional>] ?lhsEnd : int, 
                              [<Optional>] ?rhsBegin : int, 
                              [<Optional>] ?rhsEnd : int) =
        let creator = AtomicSymbolCreator.FromName "reshape_like"
        let names = [|"lhs_begin"; "lhs_end"; "rhs_begin"; "rhs_end"|]
        let vals = [|(match lhsBegin with None -> "None" | Some lhsBegin -> string lhsBegin); (match lhsEnd with None -> "None" | Some lhsEnd -> string lhsEnd); (match rhsBegin with None -> "None" | Some rhsBegin -> string rhsBegin); (match rhsEnd with None -> "None" | Some rhsEnd -> string rhsEnd)|]
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg lhs)) then lhs.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg rhs)) then rhs.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <summary>Reshape some or all dimensions of `lhs` to have the same shape as some or all dimensions of `rhs`.
    /// 
    /// Returns a **view** of the `lhs` array with a new shape without altering any data.
    /// 
    /// Example::
    /// 
    ///   x = [1, 2, 3, 4, 5, 6]
    ///   y = [[0, -4], [3, 2], [2, 2]]
    ///   reshape_like(x, y) = [[1, 2], [3, 4], [5, 6]]
    /// 
    /// More precise control over how dimensions are inherited is achieved by specifying \
    /// slices over the `lhs` and `rhs` array dimensions. Only the sliced `lhs` dimensions \
    /// are reshaped to the `rhs` sliced dimensions, with the non-sliced `lhs` dimensions staying the same.
    /// 
    ///   Examples::
    /// 
    ///   - lhs shape = (30,7), rhs shape = (15,2,4), lhs_begin=0, lhs_end=1, rhs_begin=0, rhs_end=2, output shape = (15,2,7)
    ///   - lhs shape = (3, 5), rhs shape = (1,15,4), lhs_begin=0, lhs_end=2, rhs_begin=1, rhs_end=2, output shape = (15)
    /// 
    /// Negative indices are supported, and `None` can be used for either `lhs_end` or `rhs_end` to indicate the end of the range.
    /// 
    ///   Example::
    /// 
    ///   - lhs shape = (30, 12), rhs shape = (4, 2, 2, 3), lhs_begin=-1, lhs_end=None, rhs_begin=1, rhs_end=None, output shape = (30, 2, 2, 3)
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\elemwise_unary_op_basic.cc:L513</summary>
    /// <param name="lhs">First input.</param>
    /// <param name="rhs">Second input.</param>
    /// <param name="lhsBegin">Defaults to 0. The beginning index along which the lhs dimensions are to be reshaped. Supports negative indices.</param>
    /// <param name="lhsEnd">Defaults to None. The ending index along which the lhs dimensions are to be used for reshaping. Supports negative indices.</param>
    /// <param name="rhsBegin">Defaults to 0. The beginning index along which the rhs dimensions are to be used for reshaping. Supports negative indices.</param>
    /// <param name="rhsEnd">Defaults to None. The ending index along which the rhs dimensions are to be used for reshaping. Supports negative indices.</param>
    static member ReshapeLike([<Optional>] ?lhs : Symbol, [<Optional>] ?rhs : Symbol, [<Optional>] ?lhsBegin : int, [<Optional>] ?lhsEnd : int, [<Optional>] ?rhsBegin : int, [<Optional>] ?rhsEnd : int) =
        ReshapeLike(?lhs = lhs, ?rhs = rhs, ?lhsBegin = lhsBegin, ?lhsEnd = lhsEnd, ?rhsBegin = rhsBegin, ?rhsEnd = rhsEnd)

    /// <summary>Returns a 1D int64 array containing the shape of data.
    /// 
    /// Example::
    /// 
    ///   shape_array([[1,2,3,4], [5,6,7,8]]) = [2,4]
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\elemwise_unary_op_basic.cc:L574</summary>
    /// <param name="data">Input Array.</param>
    static member ShapeArray(data : NDArray) =
        let creator = AtomicSymbolCreator.FromName "shape_array"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle|]
                                                 Array.empty
                                                 Array.empty
        (new NDArray(outputs.[0]))
    /// <summary>Returns a 1D int64 array containing the shape of data.
    /// 
    /// Example::
    /// 
    ///   shape_array([[1,2,3,4], [5,6,7,8]]) = [2,4]
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\elemwise_unary_op_basic.cc:L574</summary>
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="data">Input Array.</param>
    static member ShapeArray(outputArray : NDArray seq, data : NDArray) =
        let creator = AtomicSymbolCreator.FromName "shape_array"
        let names = Array.empty
        let vals = Array.empty
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <summary>Returns a 1D int64 array containing the shape of data.
    /// 
    /// Example::
    /// 
    ///   shape_array([[1,2,3,4], [5,6,7,8]]) = [2,4]
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\elemwise_unary_op_basic.cc:L574</summary>
    /// <param name="data">Input Array.</param>
    static member ShapeArray([<Optional>] ?data : Symbol) =
        ShapeArray(?data = data)

    /// <summary>Returns a 1D int64 array containing the size of data.
    /// 
    /// Example::
    /// 
    ///   size_array([[1,2,3,4], [5,6,7,8]]) = [8]
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\elemwise_unary_op_basic.cc:L625</summary>
    /// <param name="data">Input Array.</param>
    static member SizeArray(data : NDArray) =
        let creator = AtomicSymbolCreator.FromName "size_array"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle|]
                                                 Array.empty
                                                 Array.empty
        (new NDArray(outputs.[0]))
    /// <summary>Returns a 1D int64 array containing the size of data.
    /// 
    /// Example::
    /// 
    ///   size_array([[1,2,3,4], [5,6,7,8]]) = [8]
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\elemwise_unary_op_basic.cc:L625</summary>
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="data">Input Array.</param>
    static member SizeArray(outputArray : NDArray seq, data : NDArray) =
        let creator = AtomicSymbolCreator.FromName "size_array"
        let names = Array.empty
        let vals = Array.empty
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <summary>Returns a 1D int64 array containing the size of data.
    /// 
    /// Example::
    /// 
    ///   size_array([[1,2,3,4], [5,6,7,8]]) = [8]
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\elemwise_unary_op_basic.cc:L625</summary>
    /// <param name="data">Input Array.</param>
    static member SizeArray([<Optional>] ?data : Symbol) =
        SizeArray(?data = data)

    /// <summary>Casts all elements of the input to a new type.
    /// 
    /// .. note:: ``Cast`` is deprecated. Use ``cast`` instead.
    /// 
    /// Example::
    /// 
    ///    cast([0.9, 1.3], dtype=&#39;int32&#39;) = [0, 1]
    ///    cast([1e20, 11.1], dtype=&#39;float16&#39;) = [inf, 11.09375]
    ///    cast([300, 11.1, 10.9, -1, -3], dtype=&#39;uint8&#39;) = [44, 11, 10, 255, 253]
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\elemwise_unary_op_basic.cc:L665</summary>
    /// <param name="data">The input.</param>
    /// <param name="dtype">Output data type.</param>
    static member Cast(data : NDArray, dtype : DataType) =
        let creator = AtomicSymbolCreator.FromName "Cast"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle|]
                                                 [|"dtype"|]
                                                 [|string dtype|]
        (new NDArray(outputs.[0]))
    /// <summary>Casts all elements of the input to a new type.
    /// 
    /// .. note:: ``Cast`` is deprecated. Use ``cast`` instead.
    /// 
    /// Example::
    /// 
    ///    cast([0.9, 1.3], dtype=&#39;int32&#39;) = [0, 1]
    ///    cast([1e20, 11.1], dtype=&#39;float16&#39;) = [inf, 11.09375]
    ///    cast([300, 11.1, 10.9, -1, -3], dtype=&#39;uint8&#39;) = [44, 11, 10, 255, 253]
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\elemwise_unary_op_basic.cc:L665</summary>
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="data">The input.</param>
    /// <param name="dtype">Output data type.</param>
    static member Cast(outputArray : NDArray seq, data : NDArray, dtype : DataType) =
        let creator = AtomicSymbolCreator.FromName "Cast"
        let names = [|"dtype"|]
        let vals = [|string dtype|]
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <summary>Casts all elements of the input to a new type.
    /// 
    /// .. note:: ``Cast`` is deprecated. Use ``cast`` instead.
    /// 
    /// Example::
    /// 
    ///    cast([0.9, 1.3], dtype=&#39;int32&#39;) = [0, 1]
    ///    cast([1e20, 11.1], dtype=&#39;float16&#39;) = [inf, 11.09375]
    ///    cast([300, 11.1, 10.9, -1, -3], dtype=&#39;uint8&#39;) = [44, 11, 10, 255, 253]
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\elemwise_unary_op_basic.cc:L665</summary>
    /// <param name="data">The input.</param>
    /// <param name="dtype">Output data type.</param>
    static member Cast(data : Symbol, dtype : DataType) =
        Cast(data, dtype)
    /// <summary>Casts all elements of the input to a new type.
    /// 
    /// .. note:: ``Cast`` is deprecated. Use ``cast`` instead.
    /// 
    /// Example::
    /// 
    ///    cast([0.9, 1.3], dtype=&#39;int32&#39;) = [0, 1]
    ///    cast([1e20, 11.1], dtype=&#39;float16&#39;) = [inf, 11.09375]
    ///    cast([300, 11.1, 10.9, -1, -3], dtype=&#39;uint8&#39;) = [44, 11, 10, 255, 253]
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\elemwise_unary_op_basic.cc:L665</summary>
    /// <param name="dtype">Output data type.</param>
    /// <param name="data">The input.</param>
    static member Cast(dtype : DataType, [<Optional>] ?data : Symbol) =
        Cast(dtype, ?data = data)


    /// <summary>Numerical negative of the argument, element-wise.
    /// 
    /// The storage type of ``negative`` output depends upon the input storage type:
    /// 
    ///    - negative(default) = default
    ///    - negative(row_sparse) = row_sparse
    ///    - negative(csr) = csr
    /// 
    /// </summary>
    /// <param name="data">The input array.</param>
    static member Negative(data : NDArray) =
        let creator = AtomicSymbolCreator.FromName "negative"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle|]
                                                 Array.empty
                                                 Array.empty
        (new NDArray(outputs.[0]))
    /// <summary>Numerical negative of the argument, element-wise.
    /// 
    /// The storage type of ``negative`` output depends upon the input storage type:
    /// 
    ///    - negative(default) = default
    ///    - negative(row_sparse) = row_sparse
    ///    - negative(csr) = csr
    /// 
    /// </summary>
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="data">The input array.</param>
    static member Negative(outputArray : NDArray seq, data : NDArray) =
        let creator = AtomicSymbolCreator.FromName "negative"
        let names = Array.empty
        let vals = Array.empty
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <summary>Numerical negative of the argument, element-wise.
    /// 
    /// The storage type of ``negative`` output depends upon the input storage type:
    /// 
    ///    - negative(default) = default
    ///    - negative(row_sparse) = row_sparse
    ///    - negative(csr) = csr
    /// 
    /// </summary>
    /// <param name="data">The input array.</param>
    static member Negative([<Optional>] ?data : Symbol) =
        Negative(?data = data)

    /// <summary>Returns element-wise absolute value of the input.
    /// 
    /// Example::
    /// 
    ///    abs([-2, 0, 3]) = [2, 0, 3]
    /// 
    /// The storage type of ``abs`` output depends upon the input storage type:
    /// 
    ///    - abs(default) = default
    ///    - abs(row_sparse) = row_sparse
    ///    - abs(csr) = csr
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\elemwise_unary_op_basic.cc:L721</summary>
    /// <param name="data">The input array.</param>
    static member Abs(data : NDArray) =
        let creator = AtomicSymbolCreator.FromName "abs"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle|]
                                                 Array.empty
                                                 Array.empty
        (new NDArray(outputs.[0]))
    /// <summary>Returns element-wise absolute value of the input.
    /// 
    /// Example::
    /// 
    ///    abs([-2, 0, 3]) = [2, 0, 3]
    /// 
    /// The storage type of ``abs`` output depends upon the input storage type:
    /// 
    ///    - abs(default) = default
    ///    - abs(row_sparse) = row_sparse
    ///    - abs(csr) = csr
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\elemwise_unary_op_basic.cc:L721</summary>
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="data">The input array.</param>
    static member Abs(outputArray : NDArray seq, data : NDArray) =
        let creator = AtomicSymbolCreator.FromName "abs"
        let names = Array.empty
        let vals = Array.empty
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <summary>Returns element-wise absolute value of the input.
    /// 
    /// Example::
    /// 
    ///    abs([-2, 0, 3]) = [2, 0, 3]
    /// 
    /// The storage type of ``abs`` output depends upon the input storage type:
    /// 
    ///    - abs(default) = default
    ///    - abs(row_sparse) = row_sparse
    ///    - abs(csr) = csr
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\elemwise_unary_op_basic.cc:L721</summary>
    /// <param name="data">The input array.</param>
    static member Abs([<Optional>] ?data : Symbol) =
        Abs(?data = data)


    /// <summary>Returns element-wise sign of the input.
    /// 
    /// Example::
    /// 
    ///    sign([-2, 0, 3]) = [-1, 0, 1]
    /// 
    /// The storage type of ``sign`` output depends upon the input storage type:
    /// 
    ///    - sign(default) = default
    ///    - sign(row_sparse) = row_sparse
    ///    - sign(csr) = csr
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\elemwise_unary_op_basic.cc:L759</summary>
    /// <param name="data">The input array.</param>
    static member Sign(data : NDArray) =
        let creator = AtomicSymbolCreator.FromName "sign"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle|]
                                                 Array.empty
                                                 Array.empty
        (new NDArray(outputs.[0]))
    /// <summary>Returns element-wise sign of the input.
    /// 
    /// Example::
    /// 
    ///    sign([-2, 0, 3]) = [-1, 0, 1]
    /// 
    /// The storage type of ``sign`` output depends upon the input storage type:
    /// 
    ///    - sign(default) = default
    ///    - sign(row_sparse) = row_sparse
    ///    - sign(csr) = csr
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\elemwise_unary_op_basic.cc:L759</summary>
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="data">The input array.</param>
    static member Sign(outputArray : NDArray seq, data : NDArray) =
        let creator = AtomicSymbolCreator.FromName "sign"
        let names = Array.empty
        let vals = Array.empty
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <summary>Returns element-wise sign of the input.
    /// 
    /// Example::
    /// 
    ///    sign([-2, 0, 3]) = [-1, 0, 1]
    /// 
    /// The storage type of ``sign`` output depends upon the input storage type:
    /// 
    ///    - sign(default) = default
    ///    - sign(row_sparse) = row_sparse
    ///    - sign(csr) = csr
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\elemwise_unary_op_basic.cc:L759</summary>
    /// <param name="data">The input array.</param>
    static member Sign([<Optional>] ?data : Symbol) =
        Sign(?data = data)


    /// <summary>Returns element-wise rounded value to the nearest integer of the input.
    /// 
    /// Example::
    /// 
    ///    round([-1.5, 1.5, -1.9, 1.9, 2.1]) = [-2.,  2., -2.,  2.,  2.]
    /// 
    /// The storage type of ``round`` output depends upon the input storage type:
    /// 
    ///   - round(default) = default
    ///   - round(row_sparse) = row_sparse
    ///   - round(csr) = csr
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\elemwise_unary_op_basic.cc:L778</summary>
    /// <param name="data">The input array.</param>
    static member Round(data : NDArray) =
        let creator = AtomicSymbolCreator.FromName "round"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle|]
                                                 Array.empty
                                                 Array.empty
        (new NDArray(outputs.[0]))
    /// <summary>Returns element-wise rounded value to the nearest integer of the input.
    /// 
    /// Example::
    /// 
    ///    round([-1.5, 1.5, -1.9, 1.9, 2.1]) = [-2.,  2., -2.,  2.,  2.]
    /// 
    /// The storage type of ``round`` output depends upon the input storage type:
    /// 
    ///   - round(default) = default
    ///   - round(row_sparse) = row_sparse
    ///   - round(csr) = csr
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\elemwise_unary_op_basic.cc:L778</summary>
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="data">The input array.</param>
    static member Round(outputArray : NDArray seq, data : NDArray) =
        let creator = AtomicSymbolCreator.FromName "round"
        let names = Array.empty
        let vals = Array.empty
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <summary>Returns element-wise rounded value to the nearest integer of the input.
    /// 
    /// Example::
    /// 
    ///    round([-1.5, 1.5, -1.9, 1.9, 2.1]) = [-2.,  2., -2.,  2.,  2.]
    /// 
    /// The storage type of ``round`` output depends upon the input storage type:
    /// 
    ///   - round(default) = default
    ///   - round(row_sparse) = row_sparse
    ///   - round(csr) = csr
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\elemwise_unary_op_basic.cc:L778</summary>
    /// <param name="data">The input array.</param>
    static member Round([<Optional>] ?data : Symbol) =
        Round(?data = data)

    /// <summary>Returns element-wise rounded value to the nearest integer of the input.
    /// 
    /// .. note::
    ///    - For input ``n.5`` ``rint`` returns ``n`` while ``round`` returns ``n+1``.
    ///    - For input ``-n.5`` both ``rint`` and ``round`` returns ``-n-1``.
    /// 
    /// Example::
    /// 
    ///    rint([-1.5, 1.5, -1.9, 1.9, 2.1]) = [-2.,  1., -2.,  2.,  2.]
    /// 
    /// The storage type of ``rint`` output depends upon the input storage type:
    /// 
    ///    - rint(default) = default
    ///    - rint(row_sparse) = row_sparse
    ///    - rint(csr) = csr
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\elemwise_unary_op_basic.cc:L799</summary>
    /// <param name="data">The input array.</param>
    static member Rint(data : NDArray) =
        let creator = AtomicSymbolCreator.FromName "rint"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle|]
                                                 Array.empty
                                                 Array.empty
        (new NDArray(outputs.[0]))
    /// <summary>Returns element-wise rounded value to the nearest integer of the input.
    /// 
    /// .. note::
    ///    - For input ``n.5`` ``rint`` returns ``n`` while ``round`` returns ``n+1``.
    ///    - For input ``-n.5`` both ``rint`` and ``round`` returns ``-n-1``.
    /// 
    /// Example::
    /// 
    ///    rint([-1.5, 1.5, -1.9, 1.9, 2.1]) = [-2.,  1., -2.,  2.,  2.]
    /// 
    /// The storage type of ``rint`` output depends upon the input storage type:
    /// 
    ///    - rint(default) = default
    ///    - rint(row_sparse) = row_sparse
    ///    - rint(csr) = csr
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\elemwise_unary_op_basic.cc:L799</summary>
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="data">The input array.</param>
    static member Rint(outputArray : NDArray seq, data : NDArray) =
        let creator = AtomicSymbolCreator.FromName "rint"
        let names = Array.empty
        let vals = Array.empty
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <summary>Returns element-wise rounded value to the nearest integer of the input.
    /// 
    /// .. note::
    ///    - For input ``n.5`` ``rint`` returns ``n`` while ``round`` returns ``n+1``.
    ///    - For input ``-n.5`` both ``rint`` and ``round`` returns ``-n-1``.
    /// 
    /// Example::
    /// 
    ///    rint([-1.5, 1.5, -1.9, 1.9, 2.1]) = [-2.,  1., -2.,  2.,  2.]
    /// 
    /// The storage type of ``rint`` output depends upon the input storage type:
    /// 
    ///    - rint(default) = default
    ///    - rint(row_sparse) = row_sparse
    ///    - rint(csr) = csr
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\elemwise_unary_op_basic.cc:L799</summary>
    /// <param name="data">The input array.</param>
    static member Rint([<Optional>] ?data : Symbol) =
        Rint(?data = data)

    /// <summary>Returns element-wise ceiling of the input.
    /// 
    /// The ceil of the scalar x is the smallest integer i, such that i &gt;= x.
    /// 
    /// Example::
    /// 
    ///    ceil([-2.1, -1.9, 1.5, 1.9, 2.1]) = [-2., -1.,  2.,  2.,  3.]
    /// 
    /// The storage type of ``ceil`` output depends upon the input storage type:
    /// 
    ///    - ceil(default) = default
    ///    - ceil(row_sparse) = row_sparse
    ///    - ceil(csr) = csr
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\elemwise_unary_op_basic.cc:L818</summary>
    /// <param name="data">The input array.</param>
    static member Ceil(data : NDArray) =
        let creator = AtomicSymbolCreator.FromName "ceil"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle|]
                                                 Array.empty
                                                 Array.empty
        (new NDArray(outputs.[0]))
    /// <summary>Returns element-wise ceiling of the input.
    /// 
    /// The ceil of the scalar x is the smallest integer i, such that i &gt;= x.
    /// 
    /// Example::
    /// 
    ///    ceil([-2.1, -1.9, 1.5, 1.9, 2.1]) = [-2., -1.,  2.,  2.,  3.]
    /// 
    /// The storage type of ``ceil`` output depends upon the input storage type:
    /// 
    ///    - ceil(default) = default
    ///    - ceil(row_sparse) = row_sparse
    ///    - ceil(csr) = csr
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\elemwise_unary_op_basic.cc:L818</summary>
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="data">The input array.</param>
    static member Ceil(outputArray : NDArray seq, data : NDArray) =
        let creator = AtomicSymbolCreator.FromName "ceil"
        let names = Array.empty
        let vals = Array.empty
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <summary>Returns element-wise ceiling of the input.
    /// 
    /// The ceil of the scalar x is the smallest integer i, such that i &gt;= x.
    /// 
    /// Example::
    /// 
    ///    ceil([-2.1, -1.9, 1.5, 1.9, 2.1]) = [-2., -1.,  2.,  2.,  3.]
    /// 
    /// The storage type of ``ceil`` output depends upon the input storage type:
    /// 
    ///    - ceil(default) = default
    ///    - ceil(row_sparse) = row_sparse
    ///    - ceil(csr) = csr
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\elemwise_unary_op_basic.cc:L818</summary>
    /// <param name="data">The input array.</param>
    static member Ceil([<Optional>] ?data : Symbol) =
        Ceil(?data = data)

    /// <summary>Returns element-wise floor of the input.
    /// 
    /// The floor of the scalar x is the largest integer i, such that i &lt;= x.
    /// 
    /// Example::
    /// 
    ///    floor([-2.1, -1.9, 1.5, 1.9, 2.1]) = [-3., -2.,  1.,  1.,  2.]
    /// 
    /// The storage type of ``floor`` output depends upon the input storage type:
    /// 
    ///    - floor(default) = default
    ///    - floor(row_sparse) = row_sparse
    ///    - floor(csr) = csr
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\elemwise_unary_op_basic.cc:L837</summary>
    /// <param name="data">The input array.</param>
    static member Floor(data : NDArray) =
        let creator = AtomicSymbolCreator.FromName "floor"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle|]
                                                 Array.empty
                                                 Array.empty
        (new NDArray(outputs.[0]))
    /// <summary>Returns element-wise floor of the input.
    /// 
    /// The floor of the scalar x is the largest integer i, such that i &lt;= x.
    /// 
    /// Example::
    /// 
    ///    floor([-2.1, -1.9, 1.5, 1.9, 2.1]) = [-3., -2.,  1.,  1.,  2.]
    /// 
    /// The storage type of ``floor`` output depends upon the input storage type:
    /// 
    ///    - floor(default) = default
    ///    - floor(row_sparse) = row_sparse
    ///    - floor(csr) = csr
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\elemwise_unary_op_basic.cc:L837</summary>
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="data">The input array.</param>
    static member Floor(outputArray : NDArray seq, data : NDArray) =
        let creator = AtomicSymbolCreator.FromName "floor"
        let names = Array.empty
        let vals = Array.empty
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <summary>Returns element-wise floor of the input.
    /// 
    /// The floor of the scalar x is the largest integer i, such that i &lt;= x.
    /// 
    /// Example::
    /// 
    ///    floor([-2.1, -1.9, 1.5, 1.9, 2.1]) = [-3., -2.,  1.,  1.,  2.]
    /// 
    /// The storage type of ``floor`` output depends upon the input storage type:
    /// 
    ///    - floor(default) = default
    ///    - floor(row_sparse) = row_sparse
    ///    - floor(csr) = csr
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\elemwise_unary_op_basic.cc:L837</summary>
    /// <param name="data">The input array.</param>
    static member Floor([<Optional>] ?data : Symbol) =
        Floor(?data = data)

    /// <summary>Return the element-wise truncated value of the input.
    /// 
    /// The truncated value of the scalar x is the nearest integer i which is closer to
    /// zero than x is. In short, the fractional part of the signed number x is discarded.
    /// 
    /// Example::
    /// 
    ///    trunc([-2.1, -1.9, 1.5, 1.9, 2.1]) = [-2., -1.,  1.,  1.,  2.]
    /// 
    /// The storage type of ``trunc`` output depends upon the input storage type:
    /// 
    ///    - trunc(default) = default
    ///    - trunc(row_sparse) = row_sparse
    ///    - trunc(csr) = csr
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\elemwise_unary_op_basic.cc:L857</summary>
    /// <param name="data">The input array.</param>
    static member Trunc(data : NDArray) =
        let creator = AtomicSymbolCreator.FromName "trunc"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle|]
                                                 Array.empty
                                                 Array.empty
        (new NDArray(outputs.[0]))
    /// <summary>Return the element-wise truncated value of the input.
    /// 
    /// The truncated value of the scalar x is the nearest integer i which is closer to
    /// zero than x is. In short, the fractional part of the signed number x is discarded.
    /// 
    /// Example::
    /// 
    ///    trunc([-2.1, -1.9, 1.5, 1.9, 2.1]) = [-2., -1.,  1.,  1.,  2.]
    /// 
    /// The storage type of ``trunc`` output depends upon the input storage type:
    /// 
    ///    - trunc(default) = default
    ///    - trunc(row_sparse) = row_sparse
    ///    - trunc(csr) = csr
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\elemwise_unary_op_basic.cc:L857</summary>
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="data">The input array.</param>
    static member Trunc(outputArray : NDArray seq, data : NDArray) =
        let creator = AtomicSymbolCreator.FromName "trunc"
        let names = Array.empty
        let vals = Array.empty
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <summary>Return the element-wise truncated value of the input.
    /// 
    /// The truncated value of the scalar x is the nearest integer i which is closer to
    /// zero than x is. In short, the fractional part of the signed number x is discarded.
    /// 
    /// Example::
    /// 
    ///    trunc([-2.1, -1.9, 1.5, 1.9, 2.1]) = [-2., -1.,  1.,  1.,  2.]
    /// 
    /// The storage type of ``trunc`` output depends upon the input storage type:
    /// 
    ///    - trunc(default) = default
    ///    - trunc(row_sparse) = row_sparse
    ///    - trunc(csr) = csr
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\elemwise_unary_op_basic.cc:L857</summary>
    /// <param name="data">The input array.</param>
    static member Trunc([<Optional>] ?data : Symbol) =
        Trunc(?data = data)

    /// <summary>Returns element-wise rounded value to the nearest \
    /// integer towards zero of the input.
    /// 
    /// Example::
    /// 
    ///    fix([-2.1, -1.9, 1.9, 2.1]) = [-2., -1.,  1., 2.]
    /// 
    /// The storage type of ``fix`` output depends upon the input storage type:
    /// 
    ///    - fix(default) = default
    ///    - fix(row_sparse) = row_sparse
    ///    - fix(csr) = csr
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\elemwise_unary_op_basic.cc:L875</summary>
    /// <param name="data">The input array.</param>
    static member Fix(data : NDArray) =
        let creator = AtomicSymbolCreator.FromName "fix"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle|]
                                                 Array.empty
                                                 Array.empty
        (new NDArray(outputs.[0]))
    /// <summary>Returns element-wise rounded value to the nearest \
    /// integer towards zero of the input.
    /// 
    /// Example::
    /// 
    ///    fix([-2.1, -1.9, 1.9, 2.1]) = [-2., -1.,  1., 2.]
    /// 
    /// The storage type of ``fix`` output depends upon the input storage type:
    /// 
    ///    - fix(default) = default
    ///    - fix(row_sparse) = row_sparse
    ///    - fix(csr) = csr
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\elemwise_unary_op_basic.cc:L875</summary>
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="data">The input array.</param>
    static member Fix(outputArray : NDArray seq, data : NDArray) =
        let creator = AtomicSymbolCreator.FromName "fix"
        let names = Array.empty
        let vals = Array.empty
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <summary>Returns element-wise rounded value to the nearest \
    /// integer towards zero of the input.
    /// 
    /// Example::
    /// 
    ///    fix([-2.1, -1.9, 1.9, 2.1]) = [-2., -1.,  1., 2.]
    /// 
    /// The storage type of ``fix`` output depends upon the input storage type:
    /// 
    ///    - fix(default) = default
    ///    - fix(row_sparse) = row_sparse
    ///    - fix(csr) = csr
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\elemwise_unary_op_basic.cc:L875</summary>
    /// <param name="data">The input array.</param>
    static member Fix([<Optional>] ?data : Symbol) =
        Fix(?data = data)

    /// <summary>Returns element-wise gauss error function of the input.
    /// 
    /// Example::
    /// 
    ///    erf([0, -1., 10.]) = [0., -0.8427, 1.]
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\elemwise_unary_op_basic.cc:L887</summary>
    /// <param name="data">The input array.</param>
    static member Erf(data : NDArray) =
        let creator = AtomicSymbolCreator.FromName "erf"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle|]
                                                 Array.empty
                                                 Array.empty
        (new NDArray(outputs.[0]))
    /// <summary>Returns element-wise gauss error function of the input.
    /// 
    /// Example::
    /// 
    ///    erf([0, -1., 10.]) = [0., -0.8427, 1.]
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\elemwise_unary_op_basic.cc:L887</summary>
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="data">The input array.</param>
    static member Erf(outputArray : NDArray seq, data : NDArray) =
        let creator = AtomicSymbolCreator.FromName "erf"
        let names = Array.empty
        let vals = Array.empty
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <summary>Returns element-wise gauss error function of the input.
    /// 
    /// Example::
    /// 
    ///    erf([0, -1., 10.]) = [0., -0.8427, 1.]
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\elemwise_unary_op_basic.cc:L887</summary>
    /// <param name="data">The input array.</param>
    static member Erf([<Optional>] ?data : Symbol) =
        Erf(?data = data)


    /// <summary>Returns element-wise inverse gauss error function of the input.
    /// 
    /// Example::
    /// 
    ///    erfinv([0, 0.5., -1.]) = [0., 0.4769, -inf]
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\elemwise_unary_op_basic.cc:L909</summary>
    /// <param name="data">The input array.</param>
    static member Erfinv(data : NDArray) =
        let creator = AtomicSymbolCreator.FromName "erfinv"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle|]
                                                 Array.empty
                                                 Array.empty
        (new NDArray(outputs.[0]))
    /// <summary>Returns element-wise inverse gauss error function of the input.
    /// 
    /// Example::
    /// 
    ///    erfinv([0, 0.5., -1.]) = [0., 0.4769, -inf]
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\elemwise_unary_op_basic.cc:L909</summary>
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="data">The input array.</param>
    static member Erfinv(outputArray : NDArray seq, data : NDArray) =
        let creator = AtomicSymbolCreator.FromName "erfinv"
        let names = Array.empty
        let vals = Array.empty
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <summary>Returns element-wise inverse gauss error function of the input.
    /// 
    /// Example::
    /// 
    ///    erfinv([0, 0.5., -1.]) = [0., 0.4769, -inf]
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\elemwise_unary_op_basic.cc:L909</summary>
    /// <param name="data">The input array.</param>
    static member Erfinv([<Optional>] ?data : Symbol) =
        Erfinv(?data = data)


    /// <summary>Returns the gamma function (extension of the factorial function \
    /// to the reals), computed element-wise on the input array.
    /// 
    /// The storage type of ``gamma`` output is always dense
    /// 
    /// </summary>
    /// <param name="data">The input array.</param>
    static member Gamma(data : NDArray) =
        let creator = AtomicSymbolCreator.FromName "gamma"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle|]
                                                 Array.empty
                                                 Array.empty
        (new NDArray(outputs.[0]))
    /// <summary>Returns the gamma function (extension of the factorial function \
    /// to the reals), computed element-wise on the input array.
    /// 
    /// The storage type of ``gamma`` output is always dense
    /// 
    /// </summary>
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="data">The input array.</param>
    static member Gamma(outputArray : NDArray seq, data : NDArray) =
        let creator = AtomicSymbolCreator.FromName "gamma"
        let names = Array.empty
        let vals = Array.empty
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <summary>Returns the gamma function (extension of the factorial function \
    /// to the reals), computed element-wise on the input array.
    /// 
    /// The storage type of ``gamma`` output is always dense
    /// 
    /// </summary>
    /// <param name="data">The input array.</param>
    static member Gamma([<Optional>] ?data : Symbol) =
        Gamma(?data = data)


    /// <summary>Returns element-wise log of the absolute value of the gamma function \
    /// of the input.
    /// 
    /// The storage type of ``gammaln`` output is always dense
    /// 
    /// </summary>
    /// <param name="data">The input array.</param>
    static member Gammaln(data : NDArray) =
        let creator = AtomicSymbolCreator.FromName "gammaln"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle|]
                                                 Array.empty
                                                 Array.empty
        (new NDArray(outputs.[0]))
    /// <summary>Returns element-wise log of the absolute value of the gamma function \
    /// of the input.
    /// 
    /// The storage type of ``gammaln`` output is always dense
    /// 
    /// </summary>
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="data">The input array.</param>
    static member Gammaln(outputArray : NDArray seq, data : NDArray) =
        let creator = AtomicSymbolCreator.FromName "gammaln"
        let names = Array.empty
        let vals = Array.empty
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <summary>Returns element-wise log of the absolute value of the gamma function \
    /// of the input.
    /// 
    /// The storage type of ``gammaln`` output is always dense
    /// 
    /// </summary>
    /// <param name="data">The input array.</param>
    static member Gammaln([<Optional>] ?data : Symbol) =
        Gammaln(?data = data)


    /// <summary>Returns the result of logical NOT (!) function
    /// 
    /// Example:
    ///   logical_not([-2., 0., 1.]) = [0., 1., 0.]
    /// 
    /// </summary>
    /// <param name="data">The input array.</param>
    static member LogicalNot(data : NDArray) =
        let creator = AtomicSymbolCreator.FromName "logical_not"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle|]
                                                 Array.empty
                                                 Array.empty
        (new NDArray(outputs.[0]))
    /// <summary>Returns the result of logical NOT (!) function
    /// 
    /// Example:
    ///   logical_not([-2., 0., 1.]) = [0., 1., 0.]
    /// 
    /// </summary>
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="data">The input array.</param>
    static member LogicalNot(outputArray : NDArray seq, data : NDArray) =
        let creator = AtomicSymbolCreator.FromName "logical_not"
        let names = Array.empty
        let vals = Array.empty
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <summary>Returns the result of logical NOT (!) function
    /// 
    /// Example:
    ///   logical_not([-2., 0., 1.]) = [0., 1., 0.]
    /// 
    /// </summary>
    /// <param name="data">The input array.</param>
    static member LogicalNot([<Optional>] ?data : Symbol) =
        LogicalNot(?data = data)

    /// <summary>Returns element-wise exponential value of the input.
    /// 
    /// .. math::
    ///    exp(x) = e^x \approx 2.718^x
    /// 
    /// Example::
    /// 
    ///    exp([0, 1, 2]) = [1., 2.71828175, 7.38905621]
    /// 
    /// The storage type of ``exp`` output is always dense
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\elemwise_unary_op_logexp.cc:L64</summary>
    /// <param name="data">The input array.</param>
    static member Exp(data : NDArray) =
        let creator = AtomicSymbolCreator.FromName "exp"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle|]
                                                 Array.empty
                                                 Array.empty
        (new NDArray(outputs.[0]))
    /// <summary>Returns element-wise exponential value of the input.
    /// 
    /// .. math::
    ///    exp(x) = e^x \approx 2.718^x
    /// 
    /// Example::
    /// 
    ///    exp([0, 1, 2]) = [1., 2.71828175, 7.38905621]
    /// 
    /// The storage type of ``exp`` output is always dense
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\elemwise_unary_op_logexp.cc:L64</summary>
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="data">The input array.</param>
    static member Exp(outputArray : NDArray seq, data : NDArray) =
        let creator = AtomicSymbolCreator.FromName "exp"
        let names = Array.empty
        let vals = Array.empty
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <summary>Returns element-wise exponential value of the input.
    /// 
    /// .. math::
    ///    exp(x) = e^x \approx 2.718^x
    /// 
    /// Example::
    /// 
    ///    exp([0, 1, 2]) = [1., 2.71828175, 7.38905621]
    /// 
    /// The storage type of ``exp`` output is always dense
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\elemwise_unary_op_logexp.cc:L64</summary>
    /// <param name="data">The input array.</param>
    static member Exp([<Optional>] ?data : Symbol) =
        Exp(?data = data)

    /// <summary>Returns element-wise Natural logarithmic value of the input.
    /// 
    /// The natural logarithm is logarithm in base *e*, so that ``log(exp(x)) = x``
    /// 
    /// The storage type of ``log`` output is always dense
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\elemwise_unary_op_logexp.cc:L77</summary>
    /// <param name="data">The input array.</param>
    static member Log(data : NDArray) =
        let creator = AtomicSymbolCreator.FromName "log"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle|]
                                                 Array.empty
                                                 Array.empty
        (new NDArray(outputs.[0]))
    /// <summary>Returns element-wise Natural logarithmic value of the input.
    /// 
    /// The natural logarithm is logarithm in base *e*, so that ``log(exp(x)) = x``
    /// 
    /// The storage type of ``log`` output is always dense
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\elemwise_unary_op_logexp.cc:L77</summary>
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="data">The input array.</param>
    static member Log(outputArray : NDArray seq, data : NDArray) =
        let creator = AtomicSymbolCreator.FromName "log"
        let names = Array.empty
        let vals = Array.empty
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <summary>Returns element-wise Natural logarithmic value of the input.
    /// 
    /// The natural logarithm is logarithm in base *e*, so that ``log(exp(x)) = x``
    /// 
    /// The storage type of ``log`` output is always dense
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\elemwise_unary_op_logexp.cc:L77</summary>
    /// <param name="data">The input array.</param>
    static member Log([<Optional>] ?data : Symbol) =
        Log(?data = data)

    /// <summary>Returns element-wise Base-10 logarithmic value of the input.
    /// 
    /// ``10**log10(x) = x``
    /// 
    /// The storage type of ``log10`` output is always dense
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\elemwise_unary_op_logexp.cc:L94</summary>
    /// <param name="data">The input array.</param>
    static member Log10(data : NDArray) =
        let creator = AtomicSymbolCreator.FromName "log10"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle|]
                                                 Array.empty
                                                 Array.empty
        (new NDArray(outputs.[0]))
    /// <summary>Returns element-wise Base-10 logarithmic value of the input.
    /// 
    /// ``10**log10(x) = x``
    /// 
    /// The storage type of ``log10`` output is always dense
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\elemwise_unary_op_logexp.cc:L94</summary>
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="data">The input array.</param>
    static member Log10(outputArray : NDArray seq, data : NDArray) =
        let creator = AtomicSymbolCreator.FromName "log10"
        let names = Array.empty
        let vals = Array.empty
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <summary>Returns element-wise Base-10 logarithmic value of the input.
    /// 
    /// ``10**log10(x) = x``
    /// 
    /// The storage type of ``log10`` output is always dense
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\elemwise_unary_op_logexp.cc:L94</summary>
    /// <param name="data">The input array.</param>
    static member Log10([<Optional>] ?data : Symbol) =
        Log10(?data = data)

    /// <summary>Returns element-wise Base-2 logarithmic value of the input.
    /// 
    /// ``2**log2(x) = x``
    /// 
    /// The storage type of ``log2`` output is always dense
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\elemwise_unary_op_logexp.cc:L106</summary>
    /// <param name="data">The input array.</param>
    static member Log2(data : NDArray) =
        let creator = AtomicSymbolCreator.FromName "log2"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle|]
                                                 Array.empty
                                                 Array.empty
        (new NDArray(outputs.[0]))
    /// <summary>Returns element-wise Base-2 logarithmic value of the input.
    /// 
    /// ``2**log2(x) = x``
    /// 
    /// The storage type of ``log2`` output is always dense
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\elemwise_unary_op_logexp.cc:L106</summary>
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="data">The input array.</param>
    static member Log2(outputArray : NDArray seq, data : NDArray) =
        let creator = AtomicSymbolCreator.FromName "log2"
        let names = Array.empty
        let vals = Array.empty
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <summary>Returns element-wise Base-2 logarithmic value of the input.
    /// 
    /// ``2**log2(x) = x``
    /// 
    /// The storage type of ``log2`` output is always dense
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\elemwise_unary_op_logexp.cc:L106</summary>
    /// <param name="data">The input array.</param>
    static member Log2([<Optional>] ?data : Symbol) =
        Log2(?data = data)




    /// <summary>Returns element-wise ``log(1 + x)`` value of the input.
    /// 
    /// This function is more accurate than ``log(1 + x)``  for small ``x`` so that
    /// :math:`1+x\approx 1`
    /// 
    /// The storage type of ``log1p`` output depends upon the input storage type:
    /// 
    ///    - log1p(default) = default
    ///    - log1p(row_sparse) = row_sparse
    ///    - log1p(csr) = csr
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\elemwise_unary_op_logexp.cc:L199</summary>
    /// <param name="data">The input array.</param>
    static member Log1p(data : NDArray) =
        let creator = AtomicSymbolCreator.FromName "log1p"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle|]
                                                 Array.empty
                                                 Array.empty
        (new NDArray(outputs.[0]))
    /// <summary>Returns element-wise ``log(1 + x)`` value of the input.
    /// 
    /// This function is more accurate than ``log(1 + x)``  for small ``x`` so that
    /// :math:`1+x\approx 1`
    /// 
    /// The storage type of ``log1p`` output depends upon the input storage type:
    /// 
    ///    - log1p(default) = default
    ///    - log1p(row_sparse) = row_sparse
    ///    - log1p(csr) = csr
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\elemwise_unary_op_logexp.cc:L199</summary>
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="data">The input array.</param>
    static member Log1p(outputArray : NDArray seq, data : NDArray) =
        let creator = AtomicSymbolCreator.FromName "log1p"
        let names = Array.empty
        let vals = Array.empty
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <summary>Returns element-wise ``log(1 + x)`` value of the input.
    /// 
    /// This function is more accurate than ``log(1 + x)``  for small ``x`` so that
    /// :math:`1+x\approx 1`
    /// 
    /// The storage type of ``log1p`` output depends upon the input storage type:
    /// 
    ///    - log1p(default) = default
    ///    - log1p(row_sparse) = row_sparse
    ///    - log1p(csr) = csr
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\elemwise_unary_op_logexp.cc:L199</summary>
    /// <param name="data">The input array.</param>
    static member Log1p([<Optional>] ?data : Symbol) =
        Log1p(?data = data)


    /// <summary>Returns ``exp(x) - 1`` computed element-wise on the input.
    /// 
    /// This function provides greater precision than ``exp(x) - 1`` for small values of ``x``.
    /// 
    /// The storage type of ``expm1`` output depends upon the input storage type:
    /// 
    ///    - expm1(default) = default
    ///    - expm1(row_sparse) = row_sparse
    ///    - expm1(csr) = csr
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\elemwise_unary_op_logexp.cc:L217</summary>
    /// <param name="data">The input array.</param>
    static member Expm1(data : NDArray) =
        let creator = AtomicSymbolCreator.FromName "expm1"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle|]
                                                 Array.empty
                                                 Array.empty
        (new NDArray(outputs.[0]))
    /// <summary>Returns ``exp(x) - 1`` computed element-wise on the input.
    /// 
    /// This function provides greater precision than ``exp(x) - 1`` for small values of ``x``.
    /// 
    /// The storage type of ``expm1`` output depends upon the input storage type:
    /// 
    ///    - expm1(default) = default
    ///    - expm1(row_sparse) = row_sparse
    ///    - expm1(csr) = csr
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\elemwise_unary_op_logexp.cc:L217</summary>
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="data">The input array.</param>
    static member Expm1(outputArray : NDArray seq, data : NDArray) =
        let creator = AtomicSymbolCreator.FromName "expm1"
        let names = Array.empty
        let vals = Array.empty
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <summary>Returns ``exp(x) - 1`` computed element-wise on the input.
    /// 
    /// This function provides greater precision than ``exp(x) - 1`` for small values of ``x``.
    /// 
    /// The storage type of ``expm1`` output depends upon the input storage type:
    /// 
    ///    - expm1(default) = default
    ///    - expm1(row_sparse) = row_sparse
    ///    - expm1(csr) = csr
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\elemwise_unary_op_logexp.cc:L217</summary>
    /// <param name="data">The input array.</param>
    static member Expm1([<Optional>] ?data : Symbol) =
        Expm1(?data = data)


    /// <summary>Returns the reciprocal of the argument, element-wise.
    /// 
    /// Calculates 1/x.
    /// 
    /// Example::
    /// 
    ///     reciprocal([-2, 1, 3, 1.6, 0.2]) = [-0.5, 1.0, 0.33333334, 0.625, 5.0]
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\elemwise_unary_op_pow.cc:L42</summary>
    /// <param name="data">The input array.</param>
    static member Reciprocal(data : NDArray) =
        let creator = AtomicSymbolCreator.FromName "reciprocal"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle|]
                                                 Array.empty
                                                 Array.empty
        (new NDArray(outputs.[0]))
    /// <summary>Returns the reciprocal of the argument, element-wise.
    /// 
    /// Calculates 1/x.
    /// 
    /// Example::
    /// 
    ///     reciprocal([-2, 1, 3, 1.6, 0.2]) = [-0.5, 1.0, 0.33333334, 0.625, 5.0]
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\elemwise_unary_op_pow.cc:L42</summary>
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="data">The input array.</param>
    static member Reciprocal(outputArray : NDArray seq, data : NDArray) =
        let creator = AtomicSymbolCreator.FromName "reciprocal"
        let names = Array.empty
        let vals = Array.empty
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <summary>Returns the reciprocal of the argument, element-wise.
    /// 
    /// Calculates 1/x.
    /// 
    /// Example::
    /// 
    ///     reciprocal([-2, 1, 3, 1.6, 0.2]) = [-0.5, 1.0, 0.33333334, 0.625, 5.0]
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\elemwise_unary_op_pow.cc:L42</summary>
    /// <param name="data">The input array.</param>
    static member Reciprocal([<Optional>] ?data : Symbol) =
        Reciprocal(?data = data)


    /// <summary>Returns element-wise squared value of the input.
    /// 
    /// .. math::
    ///    square(x) = x^2
    /// 
    /// Example::
    /// 
    ///    square([2, 3, 4]) = [4, 9, 16]
    /// 
    /// The storage type of ``square`` output depends upon the input storage type:
    /// 
    ///    - square(default) = default
    ///    - square(row_sparse) = row_sparse
    ///    - square(csr) = csr
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\elemwise_unary_op_pow.cc:L118</summary>
    /// <param name="data">The input array.</param>
    static member Square(data : NDArray) =
        let creator = AtomicSymbolCreator.FromName "square"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle|]
                                                 Array.empty
                                                 Array.empty
        (new NDArray(outputs.[0]))
    /// <summary>Returns element-wise squared value of the input.
    /// 
    /// .. math::
    ///    square(x) = x^2
    /// 
    /// Example::
    /// 
    ///    square([2, 3, 4]) = [4, 9, 16]
    /// 
    /// The storage type of ``square`` output depends upon the input storage type:
    /// 
    ///    - square(default) = default
    ///    - square(row_sparse) = row_sparse
    ///    - square(csr) = csr
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\elemwise_unary_op_pow.cc:L118</summary>
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="data">The input array.</param>
    static member Square(outputArray : NDArray seq, data : NDArray) =
        let creator = AtomicSymbolCreator.FromName "square"
        let names = Array.empty
        let vals = Array.empty
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <summary>Returns element-wise squared value of the input.
    /// 
    /// .. math::
    ///    square(x) = x^2
    /// 
    /// Example::
    /// 
    ///    square([2, 3, 4]) = [4, 9, 16]
    /// 
    /// The storage type of ``square`` output depends upon the input storage type:
    /// 
    ///    - square(default) = default
    ///    - square(row_sparse) = row_sparse
    ///    - square(csr) = csr
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\elemwise_unary_op_pow.cc:L118</summary>
    /// <param name="data">The input array.</param>
    static member Square([<Optional>] ?data : Symbol) =
        Square(?data = data)


    /// <summary>Returns element-wise square-root value of the input.
    /// 
    /// .. math::
    ///    \textrm{sqrt}(x) = \sqrt{x}
    /// 
    /// Example::
    /// 
    ///    sqrt([4, 9, 16]) = [2, 3, 4]
    /// 
    /// The storage type of ``sqrt`` output depends upon the input storage type:
    /// 
    ///    - sqrt(default) = default
    ///    - sqrt(row_sparse) = row_sparse
    ///    - sqrt(csr) = csr
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\elemwise_unary_op_pow.cc:L142</summary>
    /// <param name="data">The input array.</param>
    static member Sqrt(data : NDArray) =
        let creator = AtomicSymbolCreator.FromName "sqrt"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle|]
                                                 Array.empty
                                                 Array.empty
        (new NDArray(outputs.[0]))
    /// <summary>Returns element-wise square-root value of the input.
    /// 
    /// .. math::
    ///    \textrm{sqrt}(x) = \sqrt{x}
    /// 
    /// Example::
    /// 
    ///    sqrt([4, 9, 16]) = [2, 3, 4]
    /// 
    /// The storage type of ``sqrt`` output depends upon the input storage type:
    /// 
    ///    - sqrt(default) = default
    ///    - sqrt(row_sparse) = row_sparse
    ///    - sqrt(csr) = csr
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\elemwise_unary_op_pow.cc:L142</summary>
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="data">The input array.</param>
    static member Sqrt(outputArray : NDArray seq, data : NDArray) =
        let creator = AtomicSymbolCreator.FromName "sqrt"
        let names = Array.empty
        let vals = Array.empty
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <summary>Returns element-wise square-root value of the input.
    /// 
    /// .. math::
    ///    \textrm{sqrt}(x) = \sqrt{x}
    /// 
    /// Example::
    /// 
    ///    sqrt([4, 9, 16]) = [2, 3, 4]
    /// 
    /// The storage type of ``sqrt`` output depends upon the input storage type:
    /// 
    ///    - sqrt(default) = default
    ///    - sqrt(row_sparse) = row_sparse
    ///    - sqrt(csr) = csr
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\elemwise_unary_op_pow.cc:L142</summary>
    /// <param name="data">The input array.</param>
    static member Sqrt([<Optional>] ?data : Symbol) =
        Sqrt(?data = data)


    /// <summary>Returns element-wise inverse square-root value of the input.
    /// 
    /// .. math::
    ///    rsqrt(x) = 1/\sqrt{x}
    /// 
    /// Example::
    /// 
    ///    rsqrt([4,9,16]) = [0.5, 0.33333334, 0.25]
    /// 
    /// The storage type of ``rsqrt`` output is always dense
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\elemwise_unary_op_pow.cc:L193</summary>
    /// <param name="data">The input array.</param>
    static member Rsqrt(data : NDArray) =
        let creator = AtomicSymbolCreator.FromName "rsqrt"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle|]
                                                 Array.empty
                                                 Array.empty
        (new NDArray(outputs.[0]))
    /// <summary>Returns element-wise inverse square-root value of the input.
    /// 
    /// .. math::
    ///    rsqrt(x) = 1/\sqrt{x}
    /// 
    /// Example::
    /// 
    ///    rsqrt([4,9,16]) = [0.5, 0.33333334, 0.25]
    /// 
    /// The storage type of ``rsqrt`` output is always dense
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\elemwise_unary_op_pow.cc:L193</summary>
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="data">The input array.</param>
    static member Rsqrt(outputArray : NDArray seq, data : NDArray) =
        let creator = AtomicSymbolCreator.FromName "rsqrt"
        let names = Array.empty
        let vals = Array.empty
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <summary>Returns element-wise inverse square-root value of the input.
    /// 
    /// .. math::
    ///    rsqrt(x) = 1/\sqrt{x}
    /// 
    /// Example::
    /// 
    ///    rsqrt([4,9,16]) = [0.5, 0.33333334, 0.25]
    /// 
    /// The storage type of ``rsqrt`` output is always dense
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\elemwise_unary_op_pow.cc:L193</summary>
    /// <param name="data">The input array.</param>
    static member Rsqrt([<Optional>] ?data : Symbol) =
        Rsqrt(?data = data)


    /// <summary>Returns element-wise cube-root value of the input.
    /// 
    /// .. math::
    ///    cbrt(x) = \sqrt[3]{x}
    /// 
    /// Example::
    /// 
    ///    cbrt([1, 8, -125]) = [1, 2, -5]
    /// 
    /// The storage type of ``cbrt`` output depends upon the input storage type:
    /// 
    ///    - cbrt(default) = default
    ///    - cbrt(row_sparse) = row_sparse
    ///    - cbrt(csr) = csr
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\elemwise_unary_op_pow.cc:L216</summary>
    /// <param name="data">The input array.</param>
    static member Cbrt(data : NDArray) =
        let creator = AtomicSymbolCreator.FromName "cbrt"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle|]
                                                 Array.empty
                                                 Array.empty
        (new NDArray(outputs.[0]))
    /// <summary>Returns element-wise cube-root value of the input.
    /// 
    /// .. math::
    ///    cbrt(x) = \sqrt[3]{x}
    /// 
    /// Example::
    /// 
    ///    cbrt([1, 8, -125]) = [1, 2, -5]
    /// 
    /// The storage type of ``cbrt`` output depends upon the input storage type:
    /// 
    ///    - cbrt(default) = default
    ///    - cbrt(row_sparse) = row_sparse
    ///    - cbrt(csr) = csr
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\elemwise_unary_op_pow.cc:L216</summary>
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="data">The input array.</param>
    static member Cbrt(outputArray : NDArray seq, data : NDArray) =
        let creator = AtomicSymbolCreator.FromName "cbrt"
        let names = Array.empty
        let vals = Array.empty
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <summary>Returns element-wise cube-root value of the input.
    /// 
    /// .. math::
    ///    cbrt(x) = \sqrt[3]{x}
    /// 
    /// Example::
    /// 
    ///    cbrt([1, 8, -125]) = [1, 2, -5]
    /// 
    /// The storage type of ``cbrt`` output depends upon the input storage type:
    /// 
    ///    - cbrt(default) = default
    ///    - cbrt(row_sparse) = row_sparse
    ///    - cbrt(csr) = csr
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\elemwise_unary_op_pow.cc:L216</summary>
    /// <param name="data">The input array.</param>
    static member Cbrt([<Optional>] ?data : Symbol) =
        Cbrt(?data = data)


    /// <summary>Returns element-wise inverse cube-root value of the input.
    /// 
    /// .. math::
    ///    rcbrt(x) = 1/\sqrt[3]{x}
    /// 
    /// Example::
    /// 
    ///    rcbrt([1,8,-125]) = [1.0, 0.5, -0.2]
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\elemwise_unary_op_pow.cc:L269</summary>
    /// <param name="data">The input array.</param>
    static member Rcbrt(data : NDArray) =
        let creator = AtomicSymbolCreator.FromName "rcbrt"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle|]
                                                 Array.empty
                                                 Array.empty
        (new NDArray(outputs.[0]))
    /// <summary>Returns element-wise inverse cube-root value of the input.
    /// 
    /// .. math::
    ///    rcbrt(x) = 1/\sqrt[3]{x}
    /// 
    /// Example::
    /// 
    ///    rcbrt([1,8,-125]) = [1.0, 0.5, -0.2]
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\elemwise_unary_op_pow.cc:L269</summary>
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="data">The input array.</param>
    static member Rcbrt(outputArray : NDArray seq, data : NDArray) =
        let creator = AtomicSymbolCreator.FromName "rcbrt"
        let names = Array.empty
        let vals = Array.empty
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <summary>Returns element-wise inverse cube-root value of the input.
    /// 
    /// .. math::
    ///    rcbrt(x) = 1/\sqrt[3]{x}
    /// 
    /// Example::
    /// 
    ///    rcbrt([1,8,-125]) = [1.0, 0.5, -0.2]
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\elemwise_unary_op_pow.cc:L269</summary>
    /// <param name="data">The input array.</param>
    static member Rcbrt([<Optional>] ?data : Symbol) =
        Rcbrt(?data = data)


    /// <summary>Computes the element-wise sine of the input array.
    /// 
    /// The input should be in radians (:math:`2\pi` rad equals 360 degrees).
    /// 
    /// .. math::
    ///    sin([0, \pi/4, \pi/2]) = [0, 0.707, 1]
    /// 
    /// The storage type of ``sin`` output depends upon the input storage type:
    /// 
    ///    - sin(default) = default
    ///    - sin(row_sparse) = row_sparse
    ///    - sin(csr) = csr
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\elemwise_unary_op_trig.cc:L47</summary>
    /// <param name="data">The input array.</param>
    static member Sin(data : NDArray) =
        let creator = AtomicSymbolCreator.FromName "sin"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle|]
                                                 Array.empty
                                                 Array.empty
        (new NDArray(outputs.[0]))
    /// <summary>Computes the element-wise sine of the input array.
    /// 
    /// The input should be in radians (:math:`2\pi` rad equals 360 degrees).
    /// 
    /// .. math::
    ///    sin([0, \pi/4, \pi/2]) = [0, 0.707, 1]
    /// 
    /// The storage type of ``sin`` output depends upon the input storage type:
    /// 
    ///    - sin(default) = default
    ///    - sin(row_sparse) = row_sparse
    ///    - sin(csr) = csr
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\elemwise_unary_op_trig.cc:L47</summary>
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="data">The input array.</param>
    static member Sin(outputArray : NDArray seq, data : NDArray) =
        let creator = AtomicSymbolCreator.FromName "sin"
        let names = Array.empty
        let vals = Array.empty
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <summary>Computes the element-wise sine of the input array.
    /// 
    /// The input should be in radians (:math:`2\pi` rad equals 360 degrees).
    /// 
    /// .. math::
    ///    sin([0, \pi/4, \pi/2]) = [0, 0.707, 1]
    /// 
    /// The storage type of ``sin`` output depends upon the input storage type:
    /// 
    ///    - sin(default) = default
    ///    - sin(row_sparse) = row_sparse
    ///    - sin(csr) = csr
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\elemwise_unary_op_trig.cc:L47</summary>
    /// <param name="data">The input array.</param>
    static member Sin([<Optional>] ?data : Symbol) =
        Sin(?data = data)


    /// <summary>Computes the element-wise cosine of the input array.
    /// 
    /// The input should be in radians (:math:`2\pi` rad equals 360 degrees).
    /// 
    /// .. math::
    ///    cos([0, \pi/4, \pi/2]) = [1, 0.707, 0]
    /// 
    /// The storage type of ``cos`` output is always dense
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\elemwise_unary_op_trig.cc:L90</summary>
    /// <param name="data">The input array.</param>
    static member Cos(data : NDArray) =
        let creator = AtomicSymbolCreator.FromName "cos"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle|]
                                                 Array.empty
                                                 Array.empty
        (new NDArray(outputs.[0]))
    /// <summary>Computes the element-wise cosine of the input array.
    /// 
    /// The input should be in radians (:math:`2\pi` rad equals 360 degrees).
    /// 
    /// .. math::
    ///    cos([0, \pi/4, \pi/2]) = [1, 0.707, 0]
    /// 
    /// The storage type of ``cos`` output is always dense
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\elemwise_unary_op_trig.cc:L90</summary>
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="data">The input array.</param>
    static member Cos(outputArray : NDArray seq, data : NDArray) =
        let creator = AtomicSymbolCreator.FromName "cos"
        let names = Array.empty
        let vals = Array.empty
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <summary>Computes the element-wise cosine of the input array.
    /// 
    /// The input should be in radians (:math:`2\pi` rad equals 360 degrees).
    /// 
    /// .. math::
    ///    cos([0, \pi/4, \pi/2]) = [1, 0.707, 0]
    /// 
    /// The storage type of ``cos`` output is always dense
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\elemwise_unary_op_trig.cc:L90</summary>
    /// <param name="data">The input array.</param>
    static member Cos([<Optional>] ?data : Symbol) =
        Cos(?data = data)


    /// <summary>Computes the element-wise tangent of the input array.
    /// 
    /// The input should be in radians (:math:`2\pi` rad equals 360 degrees).
    /// 
    /// .. math::
    ///    tan([0, \pi/4, \pi/2]) = [0, 1, -inf]
    /// 
    /// The storage type of ``tan`` output depends upon the input storage type:
    /// 
    ///    - tan(default) = default
    ///    - tan(row_sparse) = row_sparse
    ///    - tan(csr) = csr
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\elemwise_unary_op_trig.cc:L140</summary>
    /// <param name="data">The input array.</param>
    static member Tan(data : NDArray) =
        let creator = AtomicSymbolCreator.FromName "tan"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle|]
                                                 Array.empty
                                                 Array.empty
        (new NDArray(outputs.[0]))
    /// <summary>Computes the element-wise tangent of the input array.
    /// 
    /// The input should be in radians (:math:`2\pi` rad equals 360 degrees).
    /// 
    /// .. math::
    ///    tan([0, \pi/4, \pi/2]) = [0, 1, -inf]
    /// 
    /// The storage type of ``tan`` output depends upon the input storage type:
    /// 
    ///    - tan(default) = default
    ///    - tan(row_sparse) = row_sparse
    ///    - tan(csr) = csr
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\elemwise_unary_op_trig.cc:L140</summary>
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="data">The input array.</param>
    static member Tan(outputArray : NDArray seq, data : NDArray) =
        let creator = AtomicSymbolCreator.FromName "tan"
        let names = Array.empty
        let vals = Array.empty
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <summary>Computes the element-wise tangent of the input array.
    /// 
    /// The input should be in radians (:math:`2\pi` rad equals 360 degrees).
    /// 
    /// .. math::
    ///    tan([0, \pi/4, \pi/2]) = [0, 1, -inf]
    /// 
    /// The storage type of ``tan`` output depends upon the input storage type:
    /// 
    ///    - tan(default) = default
    ///    - tan(row_sparse) = row_sparse
    ///    - tan(csr) = csr
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\elemwise_unary_op_trig.cc:L140</summary>
    /// <param name="data">The input array.</param>
    static member Tan([<Optional>] ?data : Symbol) =
        Tan(?data = data)


    /// <summary>Returns element-wise inverse sine of the input array.
    /// 
    /// The input should be in the range `[-1, 1]`.
    /// The output is in the closed interval of [:math:`-\pi/2`, :math:`\pi/2`].
    /// 
    /// .. math::
    ///    arcsin([-1, -.707, 0, .707, 1]) = [-\pi/2, -\pi/4, 0, \pi/4, \pi/2]
    /// 
    /// The storage type of ``arcsin`` output depends upon the input storage type:
    /// 
    ///    - arcsin(default) = default
    ///    - arcsin(row_sparse) = row_sparse
    ///    - arcsin(csr) = csr
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\elemwise_unary_op_trig.cc:L187</summary>
    /// <param name="data">The input array.</param>
    static member Arcsin(data : NDArray) =
        let creator = AtomicSymbolCreator.FromName "arcsin"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle|]
                                                 Array.empty
                                                 Array.empty
        (new NDArray(outputs.[0]))
    /// <summary>Returns element-wise inverse sine of the input array.
    /// 
    /// The input should be in the range `[-1, 1]`.
    /// The output is in the closed interval of [:math:`-\pi/2`, :math:`\pi/2`].
    /// 
    /// .. math::
    ///    arcsin([-1, -.707, 0, .707, 1]) = [-\pi/2, -\pi/4, 0, \pi/4, \pi/2]
    /// 
    /// The storage type of ``arcsin`` output depends upon the input storage type:
    /// 
    ///    - arcsin(default) = default
    ///    - arcsin(row_sparse) = row_sparse
    ///    - arcsin(csr) = csr
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\elemwise_unary_op_trig.cc:L187</summary>
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="data">The input array.</param>
    static member Arcsin(outputArray : NDArray seq, data : NDArray) =
        let creator = AtomicSymbolCreator.FromName "arcsin"
        let names = Array.empty
        let vals = Array.empty
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <summary>Returns element-wise inverse sine of the input array.
    /// 
    /// The input should be in the range `[-1, 1]`.
    /// The output is in the closed interval of [:math:`-\pi/2`, :math:`\pi/2`].
    /// 
    /// .. math::
    ///    arcsin([-1, -.707, 0, .707, 1]) = [-\pi/2, -\pi/4, 0, \pi/4, \pi/2]
    /// 
    /// The storage type of ``arcsin`` output depends upon the input storage type:
    /// 
    ///    - arcsin(default) = default
    ///    - arcsin(row_sparse) = row_sparse
    ///    - arcsin(csr) = csr
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\elemwise_unary_op_trig.cc:L187</summary>
    /// <param name="data">The input array.</param>
    static member Arcsin([<Optional>] ?data : Symbol) =
        Arcsin(?data = data)


    /// <summary>Returns element-wise inverse cosine of the input array.
    /// 
    /// The input should be in range `[-1, 1]`.
    /// The output is in the closed interval :math:`[0, \pi]`
    /// 
    /// .. math::
    ///    arccos([-1, -.707, 0, .707, 1]) = [\pi, 3\pi/4, \pi/2, \pi/4, 0]
    /// 
    /// The storage type of ``arccos`` output is always dense
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\elemwise_unary_op_trig.cc:L206</summary>
    /// <param name="data">The input array.</param>
    static member Arccos(data : NDArray) =
        let creator = AtomicSymbolCreator.FromName "arccos"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle|]
                                                 Array.empty
                                                 Array.empty
        (new NDArray(outputs.[0]))
    /// <summary>Returns element-wise inverse cosine of the input array.
    /// 
    /// The input should be in range `[-1, 1]`.
    /// The output is in the closed interval :math:`[0, \pi]`
    /// 
    /// .. math::
    ///    arccos([-1, -.707, 0, .707, 1]) = [\pi, 3\pi/4, \pi/2, \pi/4, 0]
    /// 
    /// The storage type of ``arccos`` output is always dense
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\elemwise_unary_op_trig.cc:L206</summary>
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="data">The input array.</param>
    static member Arccos(outputArray : NDArray seq, data : NDArray) =
        let creator = AtomicSymbolCreator.FromName "arccos"
        let names = Array.empty
        let vals = Array.empty
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <summary>Returns element-wise inverse cosine of the input array.
    /// 
    /// The input should be in range `[-1, 1]`.
    /// The output is in the closed interval :math:`[0, \pi]`
    /// 
    /// .. math::
    ///    arccos([-1, -.707, 0, .707, 1]) = [\pi, 3\pi/4, \pi/2, \pi/4, 0]
    /// 
    /// The storage type of ``arccos`` output is always dense
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\elemwise_unary_op_trig.cc:L206</summary>
    /// <param name="data">The input array.</param>
    static member Arccos([<Optional>] ?data : Symbol) =
        Arccos(?data = data)


    /// <summary>Returns element-wise inverse tangent of the input array.
    /// 
    /// The output is in the closed interval :math:`[-\pi/2, \pi/2]`
    /// 
    /// .. math::
    ///    arctan([-1, 0, 1]) = [-\pi/4, 0, \pi/4]
    /// 
    /// The storage type of ``arctan`` output depends upon the input storage type:
    /// 
    ///    - arctan(default) = default
    ///    - arctan(row_sparse) = row_sparse
    ///    - arctan(csr) = csr
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\elemwise_unary_op_trig.cc:L227</summary>
    /// <param name="data">The input array.</param>
    static member Arctan(data : NDArray) =
        let creator = AtomicSymbolCreator.FromName "arctan"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle|]
                                                 Array.empty
                                                 Array.empty
        (new NDArray(outputs.[0]))
    /// <summary>Returns element-wise inverse tangent of the input array.
    /// 
    /// The output is in the closed interval :math:`[-\pi/2, \pi/2]`
    /// 
    /// .. math::
    ///    arctan([-1, 0, 1]) = [-\pi/4, 0, \pi/4]
    /// 
    /// The storage type of ``arctan`` output depends upon the input storage type:
    /// 
    ///    - arctan(default) = default
    ///    - arctan(row_sparse) = row_sparse
    ///    - arctan(csr) = csr
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\elemwise_unary_op_trig.cc:L227</summary>
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="data">The input array.</param>
    static member Arctan(outputArray : NDArray seq, data : NDArray) =
        let creator = AtomicSymbolCreator.FromName "arctan"
        let names = Array.empty
        let vals = Array.empty
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <summary>Returns element-wise inverse tangent of the input array.
    /// 
    /// The output is in the closed interval :math:`[-\pi/2, \pi/2]`
    /// 
    /// .. math::
    ///    arctan([-1, 0, 1]) = [-\pi/4, 0, \pi/4]
    /// 
    /// The storage type of ``arctan`` output depends upon the input storage type:
    /// 
    ///    - arctan(default) = default
    ///    - arctan(row_sparse) = row_sparse
    ///    - arctan(csr) = csr
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\elemwise_unary_op_trig.cc:L227</summary>
    /// <param name="data">The input array.</param>
    static member Arctan([<Optional>] ?data : Symbol) =
        Arctan(?data = data)


    /// <summary>Converts each element of the input array from radians to degrees.
    /// 
    /// .. math::
    ///    degrees([0, \pi/2, \pi, 3\pi/2, 2\pi]) = [0, 90, 180, 270, 360]
    /// 
    /// The storage type of ``degrees`` output depends upon the input storage type:
    /// 
    ///    - degrees(default) = default
    ///    - degrees(row_sparse) = row_sparse
    ///    - degrees(csr) = csr
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\elemwise_unary_op_trig.cc:L274</summary>
    /// <param name="data">The input array.</param>
    static member Degrees(data : NDArray) =
        let creator = AtomicSymbolCreator.FromName "degrees"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle|]
                                                 Array.empty
                                                 Array.empty
        (new NDArray(outputs.[0]))
    /// <summary>Converts each element of the input array from radians to degrees.
    /// 
    /// .. math::
    ///    degrees([0, \pi/2, \pi, 3\pi/2, 2\pi]) = [0, 90, 180, 270, 360]
    /// 
    /// The storage type of ``degrees`` output depends upon the input storage type:
    /// 
    ///    - degrees(default) = default
    ///    - degrees(row_sparse) = row_sparse
    ///    - degrees(csr) = csr
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\elemwise_unary_op_trig.cc:L274</summary>
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="data">The input array.</param>
    static member Degrees(outputArray : NDArray seq, data : NDArray) =
        let creator = AtomicSymbolCreator.FromName "degrees"
        let names = Array.empty
        let vals = Array.empty
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <summary>Converts each element of the input array from radians to degrees.
    /// 
    /// .. math::
    ///    degrees([0, \pi/2, \pi, 3\pi/2, 2\pi]) = [0, 90, 180, 270, 360]
    /// 
    /// The storage type of ``degrees`` output depends upon the input storage type:
    /// 
    ///    - degrees(default) = default
    ///    - degrees(row_sparse) = row_sparse
    ///    - degrees(csr) = csr
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\elemwise_unary_op_trig.cc:L274</summary>
    /// <param name="data">The input array.</param>
    static member Degrees([<Optional>] ?data : Symbol) =
        Degrees(?data = data)


    /// <summary>Converts each element of the input array from degrees to radians.
    /// 
    /// .. math::
    ///    radians([0, 90, 180, 270, 360]) = [0, \pi/2, \pi, 3\pi/2, 2\pi]
    /// 
    /// The storage type of ``radians`` output depends upon the input storage type:
    /// 
    ///    - radians(default) = default
    ///    - radians(row_sparse) = row_sparse
    ///    - radians(csr) = csr
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\elemwise_unary_op_trig.cc:L293</summary>
    /// <param name="data">The input array.</param>
    static member Radians(data : NDArray) =
        let creator = AtomicSymbolCreator.FromName "radians"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle|]
                                                 Array.empty
                                                 Array.empty
        (new NDArray(outputs.[0]))
    /// <summary>Converts each element of the input array from degrees to radians.
    /// 
    /// .. math::
    ///    radians([0, 90, 180, 270, 360]) = [0, \pi/2, \pi, 3\pi/2, 2\pi]
    /// 
    /// The storage type of ``radians`` output depends upon the input storage type:
    /// 
    ///    - radians(default) = default
    ///    - radians(row_sparse) = row_sparse
    ///    - radians(csr) = csr
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\elemwise_unary_op_trig.cc:L293</summary>
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="data">The input array.</param>
    static member Radians(outputArray : NDArray seq, data : NDArray) =
        let creator = AtomicSymbolCreator.FromName "radians"
        let names = Array.empty
        let vals = Array.empty
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <summary>Converts each element of the input array from degrees to radians.
    /// 
    /// .. math::
    ///    radians([0, 90, 180, 270, 360]) = [0, \pi/2, \pi, 3\pi/2, 2\pi]
    /// 
    /// The storage type of ``radians`` output depends upon the input storage type:
    /// 
    ///    - radians(default) = default
    ///    - radians(row_sparse) = row_sparse
    ///    - radians(csr) = csr
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\elemwise_unary_op_trig.cc:L293</summary>
    /// <param name="data">The input array.</param>
    static member Radians([<Optional>] ?data : Symbol) =
        Radians(?data = data)


    /// <summary>Returns the hyperbolic sine of the input array, computed element-wise.
    /// 
    /// .. math::
    ///    sinh(x) = 0.5\times(exp(x) - exp(-x))
    /// 
    /// The storage type of ``sinh`` output depends upon the input storage type:
    /// 
    ///    - sinh(default) = default
    ///    - sinh(row_sparse) = row_sparse
    ///    - sinh(csr) = csr
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\elemwise_unary_op_trig.cc:L313</summary>
    /// <param name="data">The input array.</param>
    static member Sinh(data : NDArray) =
        let creator = AtomicSymbolCreator.FromName "sinh"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle|]
                                                 Array.empty
                                                 Array.empty
        (new NDArray(outputs.[0]))
    /// <summary>Returns the hyperbolic sine of the input array, computed element-wise.
    /// 
    /// .. math::
    ///    sinh(x) = 0.5\times(exp(x) - exp(-x))
    /// 
    /// The storage type of ``sinh`` output depends upon the input storage type:
    /// 
    ///    - sinh(default) = default
    ///    - sinh(row_sparse) = row_sparse
    ///    - sinh(csr) = csr
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\elemwise_unary_op_trig.cc:L313</summary>
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="data">The input array.</param>
    static member Sinh(outputArray : NDArray seq, data : NDArray) =
        let creator = AtomicSymbolCreator.FromName "sinh"
        let names = Array.empty
        let vals = Array.empty
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <summary>Returns the hyperbolic sine of the input array, computed element-wise.
    /// 
    /// .. math::
    ///    sinh(x) = 0.5\times(exp(x) - exp(-x))
    /// 
    /// The storage type of ``sinh`` output depends upon the input storage type:
    /// 
    ///    - sinh(default) = default
    ///    - sinh(row_sparse) = row_sparse
    ///    - sinh(csr) = csr
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\elemwise_unary_op_trig.cc:L313</summary>
    /// <param name="data">The input array.</param>
    static member Sinh([<Optional>] ?data : Symbol) =
        Sinh(?data = data)


    /// <summary>Returns the hyperbolic cosine  of the input array, computed element-wise.
    /// 
    /// .. math::
    ///    cosh(x) = 0.5\times(exp(x) + exp(-x))
    /// 
    /// The storage type of ``cosh`` output is always dense
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\elemwise_unary_op_trig.cc:L351</summary>
    /// <param name="data">The input array.</param>
    static member Cosh(data : NDArray) =
        let creator = AtomicSymbolCreator.FromName "cosh"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle|]
                                                 Array.empty
                                                 Array.empty
        (new NDArray(outputs.[0]))
    /// <summary>Returns the hyperbolic cosine  of the input array, computed element-wise.
    /// 
    /// .. math::
    ///    cosh(x) = 0.5\times(exp(x) + exp(-x))
    /// 
    /// The storage type of ``cosh`` output is always dense
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\elemwise_unary_op_trig.cc:L351</summary>
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="data">The input array.</param>
    static member Cosh(outputArray : NDArray seq, data : NDArray) =
        let creator = AtomicSymbolCreator.FromName "cosh"
        let names = Array.empty
        let vals = Array.empty
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <summary>Returns the hyperbolic cosine  of the input array, computed element-wise.
    /// 
    /// .. math::
    ///    cosh(x) = 0.5\times(exp(x) + exp(-x))
    /// 
    /// The storage type of ``cosh`` output is always dense
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\elemwise_unary_op_trig.cc:L351</summary>
    /// <param name="data">The input array.</param>
    static member Cosh([<Optional>] ?data : Symbol) =
        Cosh(?data = data)


    /// <summary>Returns the hyperbolic tangent of the input array, computed element-wise.
    /// 
    /// .. math::
    ///    tanh(x) = sinh(x) / cosh(x)
    /// 
    /// The storage type of ``tanh`` output depends upon the input storage type:
    /// 
    ///    - tanh(default) = default
    ///    - tanh(row_sparse) = row_sparse
    ///    - tanh(csr) = csr
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\elemwise_unary_op_trig.cc:L393</summary>
    /// <param name="data">The input array.</param>
    static member Tanh(data : NDArray) =
        let creator = AtomicSymbolCreator.FromName "tanh"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle|]
                                                 Array.empty
                                                 Array.empty
        (new NDArray(outputs.[0]))
    /// <summary>Returns the hyperbolic tangent of the input array, computed element-wise.
    /// 
    /// .. math::
    ///    tanh(x) = sinh(x) / cosh(x)
    /// 
    /// The storage type of ``tanh`` output depends upon the input storage type:
    /// 
    ///    - tanh(default) = default
    ///    - tanh(row_sparse) = row_sparse
    ///    - tanh(csr) = csr
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\elemwise_unary_op_trig.cc:L393</summary>
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="data">The input array.</param>
    static member Tanh(outputArray : NDArray seq, data : NDArray) =
        let creator = AtomicSymbolCreator.FromName "tanh"
        let names = Array.empty
        let vals = Array.empty
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <summary>Returns the hyperbolic tangent of the input array, computed element-wise.
    /// 
    /// .. math::
    ///    tanh(x) = sinh(x) / cosh(x)
    /// 
    /// The storage type of ``tanh`` output depends upon the input storage type:
    /// 
    ///    - tanh(default) = default
    ///    - tanh(row_sparse) = row_sparse
    ///    - tanh(csr) = csr
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\elemwise_unary_op_trig.cc:L393</summary>
    /// <param name="data">The input array.</param>
    static member Tanh([<Optional>] ?data : Symbol) =
        Tanh(?data = data)


    /// <summary>Returns the element-wise inverse hyperbolic sine of the input array, \
    /// computed element-wise.
    /// 
    /// The storage type of ``arcsinh`` output depends upon the input storage type:
    /// 
    ///    - arcsinh(default) = default
    ///    - arcsinh(row_sparse) = row_sparse
    ///    - arcsinh(csr) = csr
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\elemwise_unary_op_trig.cc:L436</summary>
    /// <param name="data">The input array.</param>
    static member Arcsinh(data : NDArray) =
        let creator = AtomicSymbolCreator.FromName "arcsinh"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle|]
                                                 Array.empty
                                                 Array.empty
        (new NDArray(outputs.[0]))
    /// <summary>Returns the element-wise inverse hyperbolic sine of the input array, \
    /// computed element-wise.
    /// 
    /// The storage type of ``arcsinh`` output depends upon the input storage type:
    /// 
    ///    - arcsinh(default) = default
    ///    - arcsinh(row_sparse) = row_sparse
    ///    - arcsinh(csr) = csr
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\elemwise_unary_op_trig.cc:L436</summary>
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="data">The input array.</param>
    static member Arcsinh(outputArray : NDArray seq, data : NDArray) =
        let creator = AtomicSymbolCreator.FromName "arcsinh"
        let names = Array.empty
        let vals = Array.empty
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <summary>Returns the element-wise inverse hyperbolic sine of the input array, \
    /// computed element-wise.
    /// 
    /// The storage type of ``arcsinh`` output depends upon the input storage type:
    /// 
    ///    - arcsinh(default) = default
    ///    - arcsinh(row_sparse) = row_sparse
    ///    - arcsinh(csr) = csr
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\elemwise_unary_op_trig.cc:L436</summary>
    /// <param name="data">The input array.</param>
    static member Arcsinh([<Optional>] ?data : Symbol) =
        Arcsinh(?data = data)


    /// <summary>Returns the element-wise inverse hyperbolic cosine of the input array, \
    /// computed element-wise.
    /// 
    /// The storage type of ``arccosh`` output is always dense
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\elemwise_unary_op_trig.cc:L474</summary>
    /// <param name="data">The input array.</param>
    static member Arccosh(data : NDArray) =
        let creator = AtomicSymbolCreator.FromName "arccosh"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle|]
                                                 Array.empty
                                                 Array.empty
        (new NDArray(outputs.[0]))
    /// <summary>Returns the element-wise inverse hyperbolic cosine of the input array, \
    /// computed element-wise.
    /// 
    /// The storage type of ``arccosh`` output is always dense
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\elemwise_unary_op_trig.cc:L474</summary>
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="data">The input array.</param>
    static member Arccosh(outputArray : NDArray seq, data : NDArray) =
        let creator = AtomicSymbolCreator.FromName "arccosh"
        let names = Array.empty
        let vals = Array.empty
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <summary>Returns the element-wise inverse hyperbolic cosine of the input array, \
    /// computed element-wise.
    /// 
    /// The storage type of ``arccosh`` output is always dense
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\elemwise_unary_op_trig.cc:L474</summary>
    /// <param name="data">The input array.</param>
    static member Arccosh([<Optional>] ?data : Symbol) =
        Arccosh(?data = data)


    /// <summary>Returns the element-wise inverse hyperbolic tangent of the input array, \
    /// computed element-wise.
    /// 
    /// The storage type of ``arctanh`` output depends upon the input storage type:
    /// 
    ///    - arctanh(default) = default
    ///    - arctanh(row_sparse) = row_sparse
    ///    - arctanh(csr) = csr
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\elemwise_unary_op_trig.cc:L515</summary>
    /// <param name="data">The input array.</param>
    static member Arctanh(data : NDArray) =
        let creator = AtomicSymbolCreator.FromName "arctanh"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle|]
                                                 Array.empty
                                                 Array.empty
        (new NDArray(outputs.[0]))
    /// <summary>Returns the element-wise inverse hyperbolic tangent of the input array, \
    /// computed element-wise.
    /// 
    /// The storage type of ``arctanh`` output depends upon the input storage type:
    /// 
    ///    - arctanh(default) = default
    ///    - arctanh(row_sparse) = row_sparse
    ///    - arctanh(csr) = csr
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\elemwise_unary_op_trig.cc:L515</summary>
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="data">The input array.</param>
    static member Arctanh(outputArray : NDArray seq, data : NDArray) =
        let creator = AtomicSymbolCreator.FromName "arctanh"
        let names = Array.empty
        let vals = Array.empty
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <summary>Returns the element-wise inverse hyperbolic tangent of the input array, \
    /// computed element-wise.
    /// 
    /// The storage type of ``arctanh`` output depends upon the input storage type:
    /// 
    ///    - arctanh(default) = default
    ///    - arctanh(row_sparse) = row_sparse
    ///    - arctanh(csr) = csr
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\elemwise_unary_op_trig.cc:L515</summary>
    /// <param name="data">The input array.</param>
    static member Arctanh([<Optional>] ?data : Symbol) =
        Arctanh(?data = data)


    /// <summary>This operators implements the histogram function.
    /// 
    /// Example::
    ///   x = [[0, 1], [2, 2], [3, 4]]
    ///   histo, bin_edges = histogram(data=x, bin_bounds=[], bin_cnt=5, range=(0,5))
    ///   histo = [1, 1, 2, 1, 1]
    ///   bin_edges = [0., 1., 2., 3., 4.]
    ///   histo, bin_edges = histogram(data=x, bin_bounds=[0., 2.1, 3.])
    ///   histo = [4, 1]
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\histogram.cc:L137</summary>
    /// <param name="data">Input ndarray</param>
    /// <param name="bins">Input ndarray</param>
    /// <param name="binCnt">Number of bins for uniform case</param>
    /// <param name="range">The lower and upper range of the bins. if not provided, range is simply (a.min(), a.max()). values outside the range are ignored. the first element of the range must be less than or equal to the second. range affects the automatic bin computation as well. while bin width is computed to be optimal based on the actual data within range, the bin count will fill the entire range including portions containing no data.</param>
    static member Histogram(data : NDArray, bins : NDArray, [<Optional>] ?binCnt : int, [<Optional>] ?range : float seq) =
        let creator = AtomicSymbolCreator.FromName "_histogram"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg bins)) then bins.UnsafeHandle|]
                                                 [|"bin_cnt"; "range"|]
                                                 [|(match binCnt with None -> "None" | Some binCnt -> string binCnt); (match range with None -> "None" | Some range -> string range)|]
        (new NDArray(outputs.[0])), (new NDArray(outputs.[1]))
    /// <summary>This operators implements the histogram function.
    /// 
    /// Example::
    ///   x = [[0, 1], [2, 2], [3, 4]]
    ///   histo, bin_edges = histogram(data=x, bin_bounds=[], bin_cnt=5, range=(0,5))
    ///   histo = [1, 1, 2, 1, 1]
    ///   bin_edges = [0., 1., 2., 3., 4.]
    ///   histo, bin_edges = histogram(data=x, bin_bounds=[0., 2.1, 3.])
    ///   histo = [4, 1]
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\histogram.cc:L137</summary>
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="data">Input ndarray</param>
    /// <param name="bins">Input ndarray</param>
    /// <param name="binCnt">Number of bins for uniform case</param>
    /// <param name="range">The lower and upper range of the bins. if not provided, range is simply (a.min(), a.max()). values outside the range are ignored. the first element of the range must be less than or equal to the second. range affects the automatic bin computation as well. while bin width is computed to be optimal based on the actual data within range, the bin count will fill the entire range including portions containing no data.</param>
    static member Histogram(outputArray : NDArray seq, data : NDArray, bins : NDArray, [<Optional>] ?binCnt : int, [<Optional>] ?range : float seq) =
        let creator = AtomicSymbolCreator.FromName "_histogram"
        let names = [|"bin_cnt"; "range"|]
        let vals = [|(match binCnt with None -> "None" | Some binCnt -> string binCnt); (match range with None -> "None" | Some range -> string range)|]
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg bins)) then bins.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <summary>This operators implements the histogram function.
    /// 
    /// Example::
    ///   x = [[0, 1], [2, 2], [3, 4]]
    ///   histo, bin_edges = histogram(data=x, bin_bounds=[], bin_cnt=5, range=(0,5))
    ///   histo = [1, 1, 2, 1, 1]
    ///   bin_edges = [0., 1., 2., 3., 4.]
    ///   histo, bin_edges = histogram(data=x, bin_bounds=[0., 2.1, 3.])
    ///   histo = [4, 1]
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\histogram.cc:L137</summary>
    /// <param name="data">Input ndarray</param>
    /// <param name="bins">Input ndarray</param>
    /// <param name="binCnt">Number of bins for uniform case</param>
    /// <param name="range">The lower and upper range of the bins. if not provided, range is simply (a.min(), a.max()). values outside the range are ignored. the first element of the range must be less than or equal to the second. range affects the automatic bin computation as well. while bin width is computed to be optimal based on the actual data within range, the bin count will fill the entire range including portions containing no data.</param>
    static member Histogram([<Optional>] ?data : Symbol, [<Optional>] ?bins : Symbol, [<Optional>] ?binCnt : int, [<Optional>] ?range : float seq) =
        Histogram(?data = data, ?bins = bins, ?binCnt = binCnt, ?range = range)

    /// <summary>Maps integer indices to vector representations (embeddings).
    /// 
    /// This operator maps words to real-valued vectors in a high-dimensional space,
    /// called word embeddings. These embeddings can capture semantic and syntactic properties of the words.
    /// For example, it has been noted that in the learned embedding spaces, similar words tend
    /// to be close to each other and dissimilar words far apart.
    /// 
    /// For an input array of shape (d1, ..., dK),
    /// the shape of an output array is (d1, ..., dK, output_dim).
    /// All the input values should be integers in the range [0, input_dim).
    /// 
    /// If the input_dim is ip0 and output_dim is op0, then shape of the embedding weight matrix must be
    /// (ip0, op0).
    /// 
    /// When &quot;sparse_grad&quot; is False, if any index mentioned is too large, it is replaced by the index that
    /// addresses the last vector in an embedding matrix.
    /// When &quot;sparse_grad&quot; is True, an error will be raised if invalid indices are found.
    /// 
    /// Examples::
    /// 
    ///   input_dim = 4
    ///   output_dim = 5
    /// 
    ///   // Each row in weight matrix y represents a word. So, y = (w0,w1,w2,w3)
    ///   y = [[  0.,   1.,   2.,   3.,   4.],
    ///        [  5.,   6.,   7.,   8.,   9.],
    ///        [ 10.,  11.,  12.,  13.,  14.],
    ///        [ 15.,  16.,  17.,  18.,  19.]]
    /// 
    ///   // Input array x represents n-grams(2-gram). So, x = [(w1,w3), (w0,w2)]
    ///   x = [[ 1.,  3.],
    ///        [ 0.,  2.]]
    /// 
    ///   // Mapped input x to its vector representation y.
    ///   Embedding(x, y, 4, 5) = [[[  5.,   6.,   7.,   8.,   9.],
    ///                             [ 15.,  16.,  17.,  18.,  19.]],
    /// 
    ///                            [[  0.,   1.,   2.,   3.,   4.],
    ///                             [ 10.,  11.,  12.,  13.,  14.]]]
    /// 
    /// 
    /// The storage type of weight can be either row_sparse or default.
    /// 
    /// .. Note::
    /// 
    ///     If &quot;sparse_grad&quot; is set to True, the storage type of gradient w.r.t weights will be
    ///     &quot;row_sparse&quot;. Only a subset of optimizers support sparse gradients, including SGD, AdaGrad
    ///     and Adam. Note that by default lazy updates is turned on, which may perform differently
    ///     from standard updates. For more details, please check the Optimization API at:
    ///     https://mxnet.incubator.apache.org/api/python/optimization/optimization.html
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\indexing_op.cc:L539</summary>
    /// <param name="data">The input array to the embedding operator.</param>
    /// <param name="weight">The embedding weight matrix.</param>
    /// <param name="inputDim">Vocabulary size of the input indices.</param>
    /// <param name="outputDim">Dimension of the embedding vectors.</param>
    /// <param name="dtype">Data type of weight.</param>
    /// <param name="sparseGrad">Compute row sparse gradient in the backward calculation. If set to True, the grad&#39;s storage type is row_sparse.</param>
    static member Embedding(data : NDArray, 
                            weight : NDArray, 
                            inputDim : int, 
                            outputDim : int, 
                            [<Optional>] dtype : DataType, 
                            [<Optional; DefaultParameterValue(false)>] sparseGrad : bool) =
        let creator = AtomicSymbolCreator.FromName "Embedding"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg weight)) then weight.UnsafeHandle|]
                                                 [|"input_dim"; "output_dim"; "dtype"; "sparse_grad"|]
                                                 [|string inputDim; string outputDim; (if isNull (dtype :> obj) then "float32" else string dtype); string sparseGrad|]
        (new NDArray(outputs.[0]))
    /// <summary>Maps integer indices to vector representations (embeddings).
    /// 
    /// This operator maps words to real-valued vectors in a high-dimensional space,
    /// called word embeddings. These embeddings can capture semantic and syntactic properties of the words.
    /// For example, it has been noted that in the learned embedding spaces, similar words tend
    /// to be close to each other and dissimilar words far apart.
    /// 
    /// For an input array of shape (d1, ..., dK),
    /// the shape of an output array is (d1, ..., dK, output_dim).
    /// All the input values should be integers in the range [0, input_dim).
    /// 
    /// If the input_dim is ip0 and output_dim is op0, then shape of the embedding weight matrix must be
    /// (ip0, op0).
    /// 
    /// When &quot;sparse_grad&quot; is False, if any index mentioned is too large, it is replaced by the index that
    /// addresses the last vector in an embedding matrix.
    /// When &quot;sparse_grad&quot; is True, an error will be raised if invalid indices are found.
    /// 
    /// Examples::
    /// 
    ///   input_dim = 4
    ///   output_dim = 5
    /// 
    ///   // Each row in weight matrix y represents a word. So, y = (w0,w1,w2,w3)
    ///   y = [[  0.,   1.,   2.,   3.,   4.],
    ///        [  5.,   6.,   7.,   8.,   9.],
    ///        [ 10.,  11.,  12.,  13.,  14.],
    ///        [ 15.,  16.,  17.,  18.,  19.]]
    /// 
    ///   // Input array x represents n-grams(2-gram). So, x = [(w1,w3), (w0,w2)]
    ///   x = [[ 1.,  3.],
    ///        [ 0.,  2.]]
    /// 
    ///   // Mapped input x to its vector representation y.
    ///   Embedding(x, y, 4, 5) = [[[  5.,   6.,   7.,   8.,   9.],
    ///                             [ 15.,  16.,  17.,  18.,  19.]],
    /// 
    ///                            [[  0.,   1.,   2.,   3.,   4.],
    ///                             [ 10.,  11.,  12.,  13.,  14.]]]
    /// 
    /// 
    /// The storage type of weight can be either row_sparse or default.
    /// 
    /// .. Note::
    /// 
    ///     If &quot;sparse_grad&quot; is set to True, the storage type of gradient w.r.t weights will be
    ///     &quot;row_sparse&quot;. Only a subset of optimizers support sparse gradients, including SGD, AdaGrad
    ///     and Adam. Note that by default lazy updates is turned on, which may perform differently
    ///     from standard updates. For more details, please check the Optimization API at:
    ///     https://mxnet.incubator.apache.org/api/python/optimization/optimization.html
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\indexing_op.cc:L539</summary>
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="data">The input array to the embedding operator.</param>
    /// <param name="weight">The embedding weight matrix.</param>
    /// <param name="inputDim">Vocabulary size of the input indices.</param>
    /// <param name="outputDim">Dimension of the embedding vectors.</param>
    /// <param name="dtype">Data type of weight.</param>
    /// <param name="sparseGrad">Compute row sparse gradient in the backward calculation. If set to True, the grad&#39;s storage type is row_sparse.</param>
    static member Embedding(outputArray : NDArray seq, 
                            data : NDArray, 
                            weight : NDArray, 
                            inputDim : int, 
                            outputDim : int, 
                            [<Optional>] dtype : DataType, 
                            [<Optional; DefaultParameterValue(false)>] sparseGrad : bool) =
        let creator = AtomicSymbolCreator.FromName "Embedding"
        let names = [|"input_dim"; "output_dim"; "dtype"; "sparse_grad"|]
        let vals = [|string inputDim; string outputDim; (if isNull (dtype :> obj) then "float32" else string dtype); string sparseGrad|]
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg weight)) then weight.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <summary>Maps integer indices to vector representations (embeddings).
    /// 
    /// This operator maps words to real-valued vectors in a high-dimensional space,
    /// called word embeddings. These embeddings can capture semantic and syntactic properties of the words.
    /// For example, it has been noted that in the learned embedding spaces, similar words tend
    /// to be close to each other and dissimilar words far apart.
    /// 
    /// For an input array of shape (d1, ..., dK),
    /// the shape of an output array is (d1, ..., dK, output_dim).
    /// All the input values should be integers in the range [0, input_dim).
    /// 
    /// If the input_dim is ip0 and output_dim is op0, then shape of the embedding weight matrix must be
    /// (ip0, op0).
    /// 
    /// When &quot;sparse_grad&quot; is False, if any index mentioned is too large, it is replaced by the index that
    /// addresses the last vector in an embedding matrix.
    /// When &quot;sparse_grad&quot; is True, an error will be raised if invalid indices are found.
    /// 
    /// Examples::
    /// 
    ///   input_dim = 4
    ///   output_dim = 5
    /// 
    ///   // Each row in weight matrix y represents a word. So, y = (w0,w1,w2,w3)
    ///   y = [[  0.,   1.,   2.,   3.,   4.],
    ///        [  5.,   6.,   7.,   8.,   9.],
    ///        [ 10.,  11.,  12.,  13.,  14.],
    ///        [ 15.,  16.,  17.,  18.,  19.]]
    /// 
    ///   // Input array x represents n-grams(2-gram). So, x = [(w1,w3), (w0,w2)]
    ///   x = [[ 1.,  3.],
    ///        [ 0.,  2.]]
    /// 
    ///   // Mapped input x to its vector representation y.
    ///   Embedding(x, y, 4, 5) = [[[  5.,   6.,   7.,   8.,   9.],
    ///                             [ 15.,  16.,  17.,  18.,  19.]],
    /// 
    ///                            [[  0.,   1.,   2.,   3.,   4.],
    ///                             [ 10.,  11.,  12.,  13.,  14.]]]
    /// 
    /// 
    /// The storage type of weight can be either row_sparse or default.
    /// 
    /// .. Note::
    /// 
    ///     If &quot;sparse_grad&quot; is set to True, the storage type of gradient w.r.t weights will be
    ///     &quot;row_sparse&quot;. Only a subset of optimizers support sparse gradients, including SGD, AdaGrad
    ///     and Adam. Note that by default lazy updates is turned on, which may perform differently
    ///     from standard updates. For more details, please check the Optimization API at:
    ///     https://mxnet.incubator.apache.org/api/python/optimization/optimization.html
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\indexing_op.cc:L539</summary>
    /// <param name="data">The input array to the embedding operator.</param>
    /// <param name="weight">The embedding weight matrix.</param>
    /// <param name="inputDim">Vocabulary size of the input indices.</param>
    /// <param name="outputDim">Dimension of the embedding vectors.</param>
    /// <param name="dtype">Data type of weight.</param>
    /// <param name="sparseGrad">Compute row sparse gradient in the backward calculation. If set to True, the grad&#39;s storage type is row_sparse.</param>
    static member Embedding(data : Symbol, weight : Symbol, inputDim : int, outputDim : int, [<Optional>] ?dtype : DataType, [<Optional>] ?sparseGrad : bool) =
        Embedding(data, weight, inputDim, outputDim, ?dtype = dtype, ?sparseGrad = sparseGrad)
    /// <summary>Maps integer indices to vector representations (embeddings).
    /// 
    /// This operator maps words to real-valued vectors in a high-dimensional space,
    /// called word embeddings. These embeddings can capture semantic and syntactic properties of the words.
    /// For example, it has been noted that in the learned embedding spaces, similar words tend
    /// to be close to each other and dissimilar words far apart.
    /// 
    /// For an input array of shape (d1, ..., dK),
    /// the shape of an output array is (d1, ..., dK, output_dim).
    /// All the input values should be integers in the range [0, input_dim).
    /// 
    /// If the input_dim is ip0 and output_dim is op0, then shape of the embedding weight matrix must be
    /// (ip0, op0).
    /// 
    /// When &quot;sparse_grad&quot; is False, if any index mentioned is too large, it is replaced by the index that
    /// addresses the last vector in an embedding matrix.
    /// When &quot;sparse_grad&quot; is True, an error will be raised if invalid indices are found.
    /// 
    /// Examples::
    /// 
    ///   input_dim = 4
    ///   output_dim = 5
    /// 
    ///   // Each row in weight matrix y represents a word. So, y = (w0,w1,w2,w3)
    ///   y = [[  0.,   1.,   2.,   3.,   4.],
    ///        [  5.,   6.,   7.,   8.,   9.],
    ///        [ 10.,  11.,  12.,  13.,  14.],
    ///        [ 15.,  16.,  17.,  18.,  19.]]
    /// 
    ///   // Input array x represents n-grams(2-gram). So, x = [(w1,w3), (w0,w2)]
    ///   x = [[ 1.,  3.],
    ///        [ 0.,  2.]]
    /// 
    ///   // Mapped input x to its vector representation y.
    ///   Embedding(x, y, 4, 5) = [[[  5.,   6.,   7.,   8.,   9.],
    ///                             [ 15.,  16.,  17.,  18.,  19.]],
    /// 
    ///                            [[  0.,   1.,   2.,   3.,   4.],
    ///                             [ 10.,  11.,  12.,  13.,  14.]]]
    /// 
    /// 
    /// The storage type of weight can be either row_sparse or default.
    /// 
    /// .. Note::
    /// 
    ///     If &quot;sparse_grad&quot; is set to True, the storage type of gradient w.r.t weights will be
    ///     &quot;row_sparse&quot;. Only a subset of optimizers support sparse gradients, including SGD, AdaGrad
    ///     and Adam. Note that by default lazy updates is turned on, which may perform differently
    ///     from standard updates. For more details, please check the Optimization API at:
    ///     https://mxnet.incubator.apache.org/api/python/optimization/optimization.html
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\indexing_op.cc:L539</summary>
    /// <param name="inputDim">Vocabulary size of the input indices.</param>
    /// <param name="outputDim">Dimension of the embedding vectors.</param>
    /// <param name="data">The input array to the embedding operator.</param>
    /// <param name="weight">The embedding weight matrix.</param>
    /// <param name="dtype">Data type of weight.</param>
    /// <param name="sparseGrad">Compute row sparse gradient in the backward calculation. If set to True, the grad&#39;s storage type is row_sparse.</param>
    static member Embedding(inputDim : int, outputDim : int, [<Optional>] ?data : Symbol, [<Optional>] ?weight : Symbol, [<Optional>] ?dtype : DataType, [<Optional>] ?sparseGrad : bool) =
        Embedding(inputDim, outputDim, ?data = data, ?weight = weight, ?dtype = dtype, ?sparseGrad = sparseGrad)

    /// <summary>Maps integer indices to vector representations (embeddings).
    /// 
    /// note:: ``contrib.SparseEmbedding`` is deprecated, use ``Embedding`` instead.
    /// 
    /// This operator maps words to real-valued vectors in a high-dimensional space,
    /// called word embeddings. These embeddings can capture semantic and syntactic properties of the words.
    /// For example, it has been noted that in the learned embedding spaces, similar words tend
    /// to be close to each other and dissimilar words far apart.
    /// 
    /// For an input array of shape (d1, ..., dK),
    /// the shape of an output array is (d1, ..., dK, output_dim).
    /// All the input values should be integers in the range [0, input_dim).
    /// 
    /// If the input_dim is ip0 and output_dim is op0, then shape of the embedding weight matrix must be
    /// (ip0, op0).
    /// 
    /// The storage type of the gradient will be `row_sparse`.
    /// 
    /// .. Note::
    /// 
    ///     `SparseEmbedding` is designed for the use case where `input_dim` is very large (e.g. 100k).
    ///     The operator is available on both CPU and GPU.
    ///     When `deterministic` is set to `True`, the accumulation of gradients follows a
    ///     deterministic order if a feature appears multiple times in the input. However, the
    ///     accumulation is usually slower when the order is enforced on GPU.
    ///     When the operator is used on the GPU, the recommended value for `deterministic` is `True`.
    /// 
    /// Examples::
    /// 
    ///   input_dim = 4
    ///   output_dim = 5
    /// 
    ///   // Each row in weight matrix y represents a word. So, y = (w0,w1,w2,w3)
    ///   y = [[  0.,   1.,   2.,   3.,   4.],
    ///        [  5.,   6.,   7.,   8.,   9.],
    ///        [ 10.,  11.,  12.,  13.,  14.],
    ///        [ 15.,  16.,  17.,  18.,  19.]]
    /// 
    ///   // Input array x represents n-grams(2-gram). So, x = [(w1,w3), (w0,w2)]
    ///   x = [[ 1.,  3.],
    ///        [ 0.,  2.]]
    /// 
    ///   // Mapped input x to its vector representation y.
    ///   SparseEmbedding(x, y, 4, 5) = [[[  5.,   6.,   7.,   8.,   9.],
    ///                                  [ 15.,  16.,  17.,  18.,  19.]],
    /// 
    ///                                 [[  0.,   1.,   2.,   3.,   4.],
    ///                                  [ 10.,  11.,  12.,  13.,  14.]]]
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\indexing_op.cc:L616</summary>
    /// <param name="data">The input array to the embedding operator.</param>
    /// <param name="weight">The embedding weight matrix.</param>
    /// <param name="inputDim">Vocabulary size of the input indices.</param>
    /// <param name="outputDim">Dimension of the embedding vectors.</param>
    /// <param name="dtype">Data type of weight.</param>
    /// <param name="sparseGrad">Compute row sparse gradient in the backward calculation. If set to True, the grad&#39;s storage type is row_sparse.</param>
    static member ContribSparseEmbedding(data : NDArray, 
                                         weight : NDArray, 
                                         inputDim : int, 
                                         outputDim : int, 
                                         [<Optional>] dtype : DataType, 
                                         [<Optional; DefaultParameterValue(false)>] sparseGrad : bool) =
        let creator = AtomicSymbolCreator.FromName "_contrib_SparseEmbedding"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg weight)) then weight.UnsafeHandle|]
                                                 [|"input_dim"; "output_dim"; "dtype"; "sparse_grad"|]
                                                 [|string inputDim; string outputDim; (if isNull (dtype :> obj) then "float32" else string dtype); string sparseGrad|]
        (new NDArray(outputs.[0]))
    /// <summary>Maps integer indices to vector representations (embeddings).
    /// 
    /// note:: ``contrib.SparseEmbedding`` is deprecated, use ``Embedding`` instead.
    /// 
    /// This operator maps words to real-valued vectors in a high-dimensional space,
    /// called word embeddings. These embeddings can capture semantic and syntactic properties of the words.
    /// For example, it has been noted that in the learned embedding spaces, similar words tend
    /// to be close to each other and dissimilar words far apart.
    /// 
    /// For an input array of shape (d1, ..., dK),
    /// the shape of an output array is (d1, ..., dK, output_dim).
    /// All the input values should be integers in the range [0, input_dim).
    /// 
    /// If the input_dim is ip0 and output_dim is op0, then shape of the embedding weight matrix must be
    /// (ip0, op0).
    /// 
    /// The storage type of the gradient will be `row_sparse`.
    /// 
    /// .. Note::
    /// 
    ///     `SparseEmbedding` is designed for the use case where `input_dim` is very large (e.g. 100k).
    ///     The operator is available on both CPU and GPU.
    ///     When `deterministic` is set to `True`, the accumulation of gradients follows a
    ///     deterministic order if a feature appears multiple times in the input. However, the
    ///     accumulation is usually slower when the order is enforced on GPU.
    ///     When the operator is used on the GPU, the recommended value for `deterministic` is `True`.
    /// 
    /// Examples::
    /// 
    ///   input_dim = 4
    ///   output_dim = 5
    /// 
    ///   // Each row in weight matrix y represents a word. So, y = (w0,w1,w2,w3)
    ///   y = [[  0.,   1.,   2.,   3.,   4.],
    ///        [  5.,   6.,   7.,   8.,   9.],
    ///        [ 10.,  11.,  12.,  13.,  14.],
    ///        [ 15.,  16.,  17.,  18.,  19.]]
    /// 
    ///   // Input array x represents n-grams(2-gram). So, x = [(w1,w3), (w0,w2)]
    ///   x = [[ 1.,  3.],
    ///        [ 0.,  2.]]
    /// 
    ///   // Mapped input x to its vector representation y.
    ///   SparseEmbedding(x, y, 4, 5) = [[[  5.,   6.,   7.,   8.,   9.],
    ///                                  [ 15.,  16.,  17.,  18.,  19.]],
    /// 
    ///                                 [[  0.,   1.,   2.,   3.,   4.],
    ///                                  [ 10.,  11.,  12.,  13.,  14.]]]
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\indexing_op.cc:L616</summary>
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="data">The input array to the embedding operator.</param>
    /// <param name="weight">The embedding weight matrix.</param>
    /// <param name="inputDim">Vocabulary size of the input indices.</param>
    /// <param name="outputDim">Dimension of the embedding vectors.</param>
    /// <param name="dtype">Data type of weight.</param>
    /// <param name="sparseGrad">Compute row sparse gradient in the backward calculation. If set to True, the grad&#39;s storage type is row_sparse.</param>
    static member ContribSparseEmbedding(outputArray : NDArray seq, 
                                         data : NDArray, 
                                         weight : NDArray, 
                                         inputDim : int, 
                                         outputDim : int, 
                                         [<Optional>] dtype : DataType, 
                                         [<Optional; DefaultParameterValue(false)>] sparseGrad : bool) =
        let creator = AtomicSymbolCreator.FromName "_contrib_SparseEmbedding"
        let names = [|"input_dim"; "output_dim"; "dtype"; "sparse_grad"|]
        let vals = [|string inputDim; string outputDim; (if isNull (dtype :> obj) then "float32" else string dtype); string sparseGrad|]
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg weight)) then weight.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <summary>Maps integer indices to vector representations (embeddings).
    /// 
    /// note:: ``contrib.SparseEmbedding`` is deprecated, use ``Embedding`` instead.
    /// 
    /// This operator maps words to real-valued vectors in a high-dimensional space,
    /// called word embeddings. These embeddings can capture semantic and syntactic properties of the words.
    /// For example, it has been noted that in the learned embedding spaces, similar words tend
    /// to be close to each other and dissimilar words far apart.
    /// 
    /// For an input array of shape (d1, ..., dK),
    /// the shape of an output array is (d1, ..., dK, output_dim).
    /// All the input values should be integers in the range [0, input_dim).
    /// 
    /// If the input_dim is ip0 and output_dim is op0, then shape of the embedding weight matrix must be
    /// (ip0, op0).
    /// 
    /// The storage type of the gradient will be `row_sparse`.
    /// 
    /// .. Note::
    /// 
    ///     `SparseEmbedding` is designed for the use case where `input_dim` is very large (e.g. 100k).
    ///     The operator is available on both CPU and GPU.
    ///     When `deterministic` is set to `True`, the accumulation of gradients follows a
    ///     deterministic order if a feature appears multiple times in the input. However, the
    ///     accumulation is usually slower when the order is enforced on GPU.
    ///     When the operator is used on the GPU, the recommended value for `deterministic` is `True`.
    /// 
    /// Examples::
    /// 
    ///   input_dim = 4
    ///   output_dim = 5
    /// 
    ///   // Each row in weight matrix y represents a word. So, y = (w0,w1,w2,w3)
    ///   y = [[  0.,   1.,   2.,   3.,   4.],
    ///        [  5.,   6.,   7.,   8.,   9.],
    ///        [ 10.,  11.,  12.,  13.,  14.],
    ///        [ 15.,  16.,  17.,  18.,  19.]]
    /// 
    ///   // Input array x represents n-grams(2-gram). So, x = [(w1,w3), (w0,w2)]
    ///   x = [[ 1.,  3.],
    ///        [ 0.,  2.]]
    /// 
    ///   // Mapped input x to its vector representation y.
    ///   SparseEmbedding(x, y, 4, 5) = [[[  5.,   6.,   7.,   8.,   9.],
    ///                                  [ 15.,  16.,  17.,  18.,  19.]],
    /// 
    ///                                 [[  0.,   1.,   2.,   3.,   4.],
    ///                                  [ 10.,  11.,  12.,  13.,  14.]]]
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\indexing_op.cc:L616</summary>
    /// <param name="data">The input array to the embedding operator.</param>
    /// <param name="weight">The embedding weight matrix.</param>
    /// <param name="inputDim">Vocabulary size of the input indices.</param>
    /// <param name="outputDim">Dimension of the embedding vectors.</param>
    /// <param name="dtype">Data type of weight.</param>
    /// <param name="sparseGrad">Compute row sparse gradient in the backward calculation. If set to True, the grad&#39;s storage type is row_sparse.</param>
    static member ContribSparseEmbedding(data : Symbol, weight : Symbol, inputDim : int, outputDim : int, [<Optional>] ?dtype : DataType, [<Optional>] ?sparseGrad : bool) =
        ContribSparseEmbedding(data, weight, inputDim, outputDim, ?dtype = dtype, ?sparseGrad = sparseGrad)
    /// <summary>Maps integer indices to vector representations (embeddings).
    /// 
    /// note:: ``contrib.SparseEmbedding`` is deprecated, use ``Embedding`` instead.
    /// 
    /// This operator maps words to real-valued vectors in a high-dimensional space,
    /// called word embeddings. These embeddings can capture semantic and syntactic properties of the words.
    /// For example, it has been noted that in the learned embedding spaces, similar words tend
    /// to be close to each other and dissimilar words far apart.
    /// 
    /// For an input array of shape (d1, ..., dK),
    /// the shape of an output array is (d1, ..., dK, output_dim).
    /// All the input values should be integers in the range [0, input_dim).
    /// 
    /// If the input_dim is ip0 and output_dim is op0, then shape of the embedding weight matrix must be
    /// (ip0, op0).
    /// 
    /// The storage type of the gradient will be `row_sparse`.
    /// 
    /// .. Note::
    /// 
    ///     `SparseEmbedding` is designed for the use case where `input_dim` is very large (e.g. 100k).
    ///     The operator is available on both CPU and GPU.
    ///     When `deterministic` is set to `True`, the accumulation of gradients follows a
    ///     deterministic order if a feature appears multiple times in the input. However, the
    ///     accumulation is usually slower when the order is enforced on GPU.
    ///     When the operator is used on the GPU, the recommended value for `deterministic` is `True`.
    /// 
    /// Examples::
    /// 
    ///   input_dim = 4
    ///   output_dim = 5
    /// 
    ///   // Each row in weight matrix y represents a word. So, y = (w0,w1,w2,w3)
    ///   y = [[  0.,   1.,   2.,   3.,   4.],
    ///        [  5.,   6.,   7.,   8.,   9.],
    ///        [ 10.,  11.,  12.,  13.,  14.],
    ///        [ 15.,  16.,  17.,  18.,  19.]]
    /// 
    ///   // Input array x represents n-grams(2-gram). So, x = [(w1,w3), (w0,w2)]
    ///   x = [[ 1.,  3.],
    ///        [ 0.,  2.]]
    /// 
    ///   // Mapped input x to its vector representation y.
    ///   SparseEmbedding(x, y, 4, 5) = [[[  5.,   6.,   7.,   8.,   9.],
    ///                                  [ 15.,  16.,  17.,  18.,  19.]],
    /// 
    ///                                 [[  0.,   1.,   2.,   3.,   4.],
    ///                                  [ 10.,  11.,  12.,  13.,  14.]]]
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\indexing_op.cc:L616</summary>
    /// <param name="inputDim">Vocabulary size of the input indices.</param>
    /// <param name="outputDim">Dimension of the embedding vectors.</param>
    /// <param name="data">The input array to the embedding operator.</param>
    /// <param name="weight">The embedding weight matrix.</param>
    /// <param name="dtype">Data type of weight.</param>
    /// <param name="sparseGrad">Compute row sparse gradient in the backward calculation. If set to True, the grad&#39;s storage type is row_sparse.</param>
    static member ContribSparseEmbedding(inputDim : int, outputDim : int, [<Optional>] ?data : Symbol, [<Optional>] ?weight : Symbol, [<Optional>] ?dtype : DataType, [<Optional>] ?sparseGrad : bool) =
        ContribSparseEmbedding(inputDim, outputDim, ?data = data, ?weight = weight, ?dtype = dtype, ?sparseGrad = sparseGrad)



    /// <summary>Takes elements from an input array along the given axis.
    /// 
    /// This function slices the input array along a particular axis with the provided indices.
    /// 
    /// Given data tensor of rank r &gt;= 1, and indices tensor of rank q, gather entries of the axis
    /// dimension of data (by default outer-most one as axis=0) indexed by indices, and concatenates them
    /// in an output tensor of rank q + (r - 1).
    /// 
    /// Examples::
    /// 
    ///   x = [4.  5.  6.]
    /// 
    ///   // Trivial case, take the second element along the first axis.
    /// 
    ///   take(x, [1]) = [ 5. ]
    /// 
    ///   // The other trivial case, axis=-1, take the third element along the first axis
    /// 
    ///   take(x, [3], axis=-1, mode=&#39;clip&#39;) = [ 6. ]
    /// 
    ///   x = [[ 1.,  2.],
    ///        [ 3.,  4.],
    ///        [ 5.,  6.]]
    /// 
    ///   // In this case we will get rows 0 and 1, then 1 and 2. Along axis 0
    /// 
    ///   take(x, [[0,1],[1,2]]) = [[[ 1.,  2.],
    ///                              [ 3.,  4.]],
    /// 
    ///                             [[ 3.,  4.],
    ///                              [ 5.,  6.]]]
    /// 
    ///   // In this case we will get rows 0 and 1, then 1 and 2 (calculated by wrapping around).
    ///   // Along axis 1
    /// 
    ///   take(x, [[0, 3], [-1, -2]], axis=1, mode=&#39;wrap&#39;) = [[[ 1.  2.]
    ///                                                        [ 2.  1.]]
    /// 
    ///                                                       [[ 3.  4.]
    ///                                                        [ 4.  3.]]
    /// 
    ///                                                       [[ 5.  6.]
    ///                                                        [ 6.  5.]]]
    /// 
    /// The storage type of ``take`` output depends upon the input storage type:
    /// 
    ///    - take(default, default) = default
    ///    - take(csr, default, axis=0) = csr
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\indexing_op.cc:L718</summary>
    /// <param name="a">The input array.</param>
    /// <param name="indices">The indices of the values to be extracted.</param>
    /// <param name="axis">The axis of input array to be taken.For input tensor of rank r, it could be in the range of [-r, r-1]</param>
    /// <param name="mode">Specify how out-of-bound indices bahave. Default is &quot;clip&quot;. &quot;clip&quot; means clip to the range. So, if all indices mentioned are too large, they are replaced by the index that addresses the last element along an axis. &quot;wrap&quot; means to wrap around. &quot;raise&quot; means to raise an error when index out of range.</param>
    static member Take(a : NDArray, indices : NDArray, [<Optional; DefaultParameterValue(0)>] axis : int, [<Optional>] mode : TakeMode) =
        let creator = AtomicSymbolCreator.FromName "take"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg a)) then a.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg indices)) then indices.UnsafeHandle|]
                                                 [|"axis"; "mode"|]
                                                 [|string axis; (if isNull (mode :> obj) then "clip" else string mode)|]
        (new NDArray(outputs.[0]))
    /// <summary>Takes elements from an input array along the given axis.
    /// 
    /// This function slices the input array along a particular axis with the provided indices.
    /// 
    /// Given data tensor of rank r &gt;= 1, and indices tensor of rank q, gather entries of the axis
    /// dimension of data (by default outer-most one as axis=0) indexed by indices, and concatenates them
    /// in an output tensor of rank q + (r - 1).
    /// 
    /// Examples::
    /// 
    ///   x = [4.  5.  6.]
    /// 
    ///   // Trivial case, take the second element along the first axis.
    /// 
    ///   take(x, [1]) = [ 5. ]
    /// 
    ///   // The other trivial case, axis=-1, take the third element along the first axis
    /// 
    ///   take(x, [3], axis=-1, mode=&#39;clip&#39;) = [ 6. ]
    /// 
    ///   x = [[ 1.,  2.],
    ///        [ 3.,  4.],
    ///        [ 5.,  6.]]
    /// 
    ///   // In this case we will get rows 0 and 1, then 1 and 2. Along axis 0
    /// 
    ///   take(x, [[0,1],[1,2]]) = [[[ 1.,  2.],
    ///                              [ 3.,  4.]],
    /// 
    ///                             [[ 3.,  4.],
    ///                              [ 5.,  6.]]]
    /// 
    ///   // In this case we will get rows 0 and 1, then 1 and 2 (calculated by wrapping around).
    ///   // Along axis 1
    /// 
    ///   take(x, [[0, 3], [-1, -2]], axis=1, mode=&#39;wrap&#39;) = [[[ 1.  2.]
    ///                                                        [ 2.  1.]]
    /// 
    ///                                                       [[ 3.  4.]
    ///                                                        [ 4.  3.]]
    /// 
    ///                                                       [[ 5.  6.]
    ///                                                        [ 6.  5.]]]
    /// 
    /// The storage type of ``take`` output depends upon the input storage type:
    /// 
    ///    - take(default, default) = default
    ///    - take(csr, default, axis=0) = csr
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\indexing_op.cc:L718</summary>
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="a">The input array.</param>
    /// <param name="indices">The indices of the values to be extracted.</param>
    /// <param name="axis">The axis of input array to be taken.For input tensor of rank r, it could be in the range of [-r, r-1]</param>
    /// <param name="mode">Specify how out-of-bound indices bahave. Default is &quot;clip&quot;. &quot;clip&quot; means clip to the range. So, if all indices mentioned are too large, they are replaced by the index that addresses the last element along an axis. &quot;wrap&quot; means to wrap around. &quot;raise&quot; means to raise an error when index out of range.</param>
    static member Take(outputArray : NDArray seq, a : NDArray, indices : NDArray, [<Optional; DefaultParameterValue(0)>] axis : int, [<Optional>] mode : TakeMode) =
        let creator = AtomicSymbolCreator.FromName "take"
        let names = [|"axis"; "mode"|]
        let vals = [|string axis; (if isNull (mode :> obj) then "clip" else string mode)|]
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg a)) then a.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg indices)) then indices.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <summary>Takes elements from an input array along the given axis.
    /// 
    /// This function slices the input array along a particular axis with the provided indices.
    /// 
    /// Given data tensor of rank r &gt;= 1, and indices tensor of rank q, gather entries of the axis
    /// dimension of data (by default outer-most one as axis=0) indexed by indices, and concatenates them
    /// in an output tensor of rank q + (r - 1).
    /// 
    /// Examples::
    /// 
    ///   x = [4.  5.  6.]
    /// 
    ///   // Trivial case, take the second element along the first axis.
    /// 
    ///   take(x, [1]) = [ 5. ]
    /// 
    ///   // The other trivial case, axis=-1, take the third element along the first axis
    /// 
    ///   take(x, [3], axis=-1, mode=&#39;clip&#39;) = [ 6. ]
    /// 
    ///   x = [[ 1.,  2.],
    ///        [ 3.,  4.],
    ///        [ 5.,  6.]]
    /// 
    ///   // In this case we will get rows 0 and 1, then 1 and 2. Along axis 0
    /// 
    ///   take(x, [[0,1],[1,2]]) = [[[ 1.,  2.],
    ///                              [ 3.,  4.]],
    /// 
    ///                             [[ 3.,  4.],
    ///                              [ 5.,  6.]]]
    /// 
    ///   // In this case we will get rows 0 and 1, then 1 and 2 (calculated by wrapping around).
    ///   // Along axis 1
    /// 
    ///   take(x, [[0, 3], [-1, -2]], axis=1, mode=&#39;wrap&#39;) = [[[ 1.  2.]
    ///                                                        [ 2.  1.]]
    /// 
    ///                                                       [[ 3.  4.]
    ///                                                        [ 4.  3.]]
    /// 
    ///                                                       [[ 5.  6.]
    ///                                                        [ 6.  5.]]]
    /// 
    /// The storage type of ``take`` output depends upon the input storage type:
    /// 
    ///    - take(default, default) = default
    ///    - take(csr, default, axis=0) = csr
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\indexing_op.cc:L718</summary>
    /// <param name="a">The input array.</param>
    /// <param name="indices">The indices of the values to be extracted.</param>
    /// <param name="axis">The axis of input array to be taken.For input tensor of rank r, it could be in the range of [-r, r-1]</param>
    /// <param name="mode">Specify how out-of-bound indices bahave. Default is &quot;clip&quot;. &quot;clip&quot; means clip to the range. So, if all indices mentioned are too large, they are replaced by the index that addresses the last element along an axis. &quot;wrap&quot; means to wrap around. &quot;raise&quot; means to raise an error when index out of range.</param>
    static member Take([<Optional>] ?a : Symbol, [<Optional>] ?indices : Symbol, [<Optional>] ?axis : int, [<Optional>] ?mode : TakeMode) =
        Take(?a = a, ?indices = indices, ?axis = axis, ?mode = mode)


    /// <summary>Takes elements from a data batch.
    /// 
    /// .. note::
    ///   `batch_take` is deprecated. Use `pick` instead.
    /// 
    /// Given an input array of shape ``(d0, d1)`` and indices of shape ``(i0,)``, the result will be
    /// an output array of shape ``(i0,)`` with::
    /// 
    ///   output[i] = input[i, indices[i]]
    /// 
    /// Examples::
    /// 
    ///   x = [[ 1.,  2.],
    ///        [ 3.,  4.],
    ///        [ 5.,  6.]]
    /// 
    ///   // takes elements with specified indices
    ///   batch_take(x, [0,1,0]) = [ 1.  4.  5.]
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\indexing_op.cc:L777</summary>
    /// <param name="a">The input array</param>
    /// <param name="indices">The index array</param>
    static member BatchTake(a : NDArray, indices : NDArray) =
        let creator = AtomicSymbolCreator.FromName "batch_take"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg a)) then a.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg indices)) then indices.UnsafeHandle|]
                                                 Array.empty
                                                 Array.empty
        (new NDArray(outputs.[0]))
    /// <summary>Takes elements from a data batch.
    /// 
    /// .. note::
    ///   `batch_take` is deprecated. Use `pick` instead.
    /// 
    /// Given an input array of shape ``(d0, d1)`` and indices of shape ``(i0,)``, the result will be
    /// an output array of shape ``(i0,)`` with::
    /// 
    ///   output[i] = input[i, indices[i]]
    /// 
    /// Examples::
    /// 
    ///   x = [[ 1.,  2.],
    ///        [ 3.,  4.],
    ///        [ 5.,  6.]]
    /// 
    ///   // takes elements with specified indices
    ///   batch_take(x, [0,1,0]) = [ 1.  4.  5.]
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\indexing_op.cc:L777</summary>
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="a">The input array</param>
    /// <param name="indices">The index array</param>
    static member BatchTake(outputArray : NDArray seq, a : NDArray, indices : NDArray) =
        let creator = AtomicSymbolCreator.FromName "batch_take"
        let names = Array.empty
        let vals = Array.empty
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg a)) then a.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg indices)) then indices.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <summary>Takes elements from a data batch.
    /// 
    /// .. note::
    ///   `batch_take` is deprecated. Use `pick` instead.
    /// 
    /// Given an input array of shape ``(d0, d1)`` and indices of shape ``(i0,)``, the result will be
    /// an output array of shape ``(i0,)`` with::
    /// 
    ///   output[i] = input[i, indices[i]]
    /// 
    /// Examples::
    /// 
    ///   x = [[ 1.,  2.],
    ///        [ 3.,  4.],
    ///        [ 5.,  6.]]
    /// 
    ///   // takes elements with specified indices
    ///   batch_take(x, [0,1,0]) = [ 1.  4.  5.]
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\indexing_op.cc:L777</summary>
    /// <param name="a">The input array</param>
    /// <param name="indices">The index array</param>
    static member BatchTake([<Optional>] ?a : Symbol, [<Optional>] ?indices : Symbol) =
        BatchTake(?a = a, ?indices = indices)

    /// <summary>Returns a one-hot array.
    /// 
    /// The locations represented by `indices` take value `on_value`, while all
    /// other locations take value `off_value`.
    /// 
    /// `one_hot` operation with `indices` of shape ``(i0, i1)`` and `depth`  of ``d`` would result
    /// in an output array of shape ``(i0, i1, d)`` with::
    /// 
    ///   output[i,j,:] = off_value
    ///   output[i,j,indices[i,j]] = on_value
    /// 
    /// Examples::
    /// 
    ///   one_hot([1,0,2,0], 3) = [[ 0.  1.  0.]
    ///                            [ 1.  0.  0.]
    ///                            [ 0.  0.  1.]
    ///                            [ 1.  0.  0.]]
    /// 
    ///   one_hot([1,0,2,0], 3, on_value=8, off_value=1,
    ///           dtype=&#39;int32&#39;) = [[1 8 1]
    ///                             [8 1 1]
    ///                             [1 1 8]
    ///                             [8 1 1]]
    /// 
    ///   one_hot([[1,0],[1,0],[2,0]], 3) = [[[ 0.  1.  0.]
    ///                                       [ 1.  0.  0.]]
    /// 
    ///                                      [[ 0.  1.  0.]
    ///                                       [ 1.  0.  0.]]
    /// 
    ///                                      [[ 0.  0.  1.]
    ///                                       [ 1.  0.  0.]]]
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\indexing_op.cc:L824</summary>
    /// <param name="indices">array of locations where to set on_value</param>
    /// <param name="depth">Depth of the one hot dimension.</param>
    /// <param name="onValue">The value assigned to the locations represented by indices.</param>
    /// <param name="offValue">The value assigned to the locations not represented by indices.</param>
    /// <param name="dtype">DType of the output</param>
    static member OneHot(indices : NDArray, 
                         depth : int, 
                         [<Optional; DefaultParameterValue(1.0)>] onValue : double, 
                         [<Optional; DefaultParameterValue(0.0)>] offValue : double, 
                         [<Optional>] dtype : DataType) =
        let creator = AtomicSymbolCreator.FromName "one_hot"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg indices)) then indices.UnsafeHandle|]
                                                 [|"depth"; "on_value"; "off_value"; "dtype"|]
                                                 [|string depth; string onValue; string offValue; (if isNull (dtype :> obj) then "float32" else string dtype)|]
        (new NDArray(outputs.[0]))
    /// <summary>Returns a one-hot array.
    /// 
    /// The locations represented by `indices` take value `on_value`, while all
    /// other locations take value `off_value`.
    /// 
    /// `one_hot` operation with `indices` of shape ``(i0, i1)`` and `depth`  of ``d`` would result
    /// in an output array of shape ``(i0, i1, d)`` with::
    /// 
    ///   output[i,j,:] = off_value
    ///   output[i,j,indices[i,j]] = on_value
    /// 
    /// Examples::
    /// 
    ///   one_hot([1,0,2,0], 3) = [[ 0.  1.  0.]
    ///                            [ 1.  0.  0.]
    ///                            [ 0.  0.  1.]
    ///                            [ 1.  0.  0.]]
    /// 
    ///   one_hot([1,0,2,0], 3, on_value=8, off_value=1,
    ///           dtype=&#39;int32&#39;) = [[1 8 1]
    ///                             [8 1 1]
    ///                             [1 1 8]
    ///                             [8 1 1]]
    /// 
    ///   one_hot([[1,0],[1,0],[2,0]], 3) = [[[ 0.  1.  0.]
    ///                                       [ 1.  0.  0.]]
    /// 
    ///                                      [[ 0.  1.  0.]
    ///                                       [ 1.  0.  0.]]
    /// 
    ///                                      [[ 0.  0.  1.]
    ///                                       [ 1.  0.  0.]]]
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\indexing_op.cc:L824</summary>
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="indices">array of locations where to set on_value</param>
    /// <param name="depth">Depth of the one hot dimension.</param>
    /// <param name="onValue">The value assigned to the locations represented by indices.</param>
    /// <param name="offValue">The value assigned to the locations not represented by indices.</param>
    /// <param name="dtype">DType of the output</param>
    static member OneHot(outputArray : NDArray seq, 
                         indices : NDArray, 
                         depth : int, 
                         [<Optional; DefaultParameterValue(1.0)>] onValue : double, 
                         [<Optional; DefaultParameterValue(0.0)>] offValue : double, 
                         [<Optional>] dtype : DataType) =
        let creator = AtomicSymbolCreator.FromName "one_hot"
        let names = [|"depth"; "on_value"; "off_value"; "dtype"|]
        let vals = [|string depth; string onValue; string offValue; (if isNull (dtype :> obj) then "float32" else string dtype)|]
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg indices)) then indices.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <summary>Returns a one-hot array.
    /// 
    /// The locations represented by `indices` take value `on_value`, while all
    /// other locations take value `off_value`.
    /// 
    /// `one_hot` operation with `indices` of shape ``(i0, i1)`` and `depth`  of ``d`` would result
    /// in an output array of shape ``(i0, i1, d)`` with::
    /// 
    ///   output[i,j,:] = off_value
    ///   output[i,j,indices[i,j]] = on_value
    /// 
    /// Examples::
    /// 
    ///   one_hot([1,0,2,0], 3) = [[ 0.  1.  0.]
    ///                            [ 1.  0.  0.]
    ///                            [ 0.  0.  1.]
    ///                            [ 1.  0.  0.]]
    /// 
    ///   one_hot([1,0,2,0], 3, on_value=8, off_value=1,
    ///           dtype=&#39;int32&#39;) = [[1 8 1]
    ///                             [8 1 1]
    ///                             [1 1 8]
    ///                             [8 1 1]]
    /// 
    ///   one_hot([[1,0],[1,0],[2,0]], 3) = [[[ 0.  1.  0.]
    ///                                       [ 1.  0.  0.]]
    /// 
    ///                                      [[ 0.  1.  0.]
    ///                                       [ 1.  0.  0.]]
    /// 
    ///                                      [[ 0.  0.  1.]
    ///                                       [ 1.  0.  0.]]]
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\indexing_op.cc:L824</summary>
    /// <param name="indices">array of locations where to set on_value</param>
    /// <param name="depth">Depth of the one hot dimension.</param>
    /// <param name="onValue">The value assigned to the locations represented by indices.</param>
    /// <param name="offValue">The value assigned to the locations not represented by indices.</param>
    /// <param name="dtype">DType of the output</param>
    static member OneHot(indices : Symbol, depth : int, [<Optional>] ?onValue : double, [<Optional>] ?offValue : double, [<Optional>] ?dtype : DataType) =
        OneHot(indices, depth, ?onValue = onValue, ?offValue = offValue, ?dtype = dtype)
    /// <summary>Returns a one-hot array.
    /// 
    /// The locations represented by `indices` take value `on_value`, while all
    /// other locations take value `off_value`.
    /// 
    /// `one_hot` operation with `indices` of shape ``(i0, i1)`` and `depth`  of ``d`` would result
    /// in an output array of shape ``(i0, i1, d)`` with::
    /// 
    ///   output[i,j,:] = off_value
    ///   output[i,j,indices[i,j]] = on_value
    /// 
    /// Examples::
    /// 
    ///   one_hot([1,0,2,0], 3) = [[ 0.  1.  0.]
    ///                            [ 1.  0.  0.]
    ///                            [ 0.  0.  1.]
    ///                            [ 1.  0.  0.]]
    /// 
    ///   one_hot([1,0,2,0], 3, on_value=8, off_value=1,
    ///           dtype=&#39;int32&#39;) = [[1 8 1]
    ///                             [8 1 1]
    ///                             [1 1 8]
    ///                             [8 1 1]]
    /// 
    ///   one_hot([[1,0],[1,0],[2,0]], 3) = [[[ 0.  1.  0.]
    ///                                       [ 1.  0.  0.]]
    /// 
    ///                                      [[ 0.  1.  0.]
    ///                                       [ 1.  0.  0.]]
    /// 
    ///                                      [[ 0.  0.  1.]
    ///                                       [ 1.  0.  0.]]]
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\indexing_op.cc:L824</summary>
    /// <param name="depth">Depth of the one hot dimension.</param>
    /// <param name="indices">array of locations where to set on_value</param>
    /// <param name="onValue">The value assigned to the locations represented by indices.</param>
    /// <param name="offValue">The value assigned to the locations not represented by indices.</param>
    /// <param name="dtype">DType of the output</param>
    static member OneHot(depth : int, [<Optional>] ?indices : Symbol, [<Optional>] ?onValue : double, [<Optional>] ?offValue : double, [<Optional>] ?dtype : DataType) =
        OneHot(depth, ?indices = indices, ?onValue = onValue, ?offValue = offValue, ?dtype = dtype)

    /// <summary>Gather elements or slices from `data` and store to a tensor whose
    /// shape is defined by `indices`.
    /// 
    /// Given `data` with shape `(X_0, X_1, ..., X_{N-1})` and indices with shape
    /// `(M, Y_0, ..., Y_{K-1})`, the output will have shape `(Y_0, ..., Y_{K-1}, X_M, ..., X_{N-1})`,
    /// where `M &lt;= N`. If `M == N`, output shape will simply be `(Y_0, ..., Y_{K-1})`.
    /// 
    /// The elements in output is defined as follows::
    /// 
    ///   output[y_0, ..., y_{K-1}, x_M, ..., x_{N-1}] = data[indices[0, y_0, ..., y_{K-1}],
    ///                                                       ...,
    ///                                                       indices[M-1, y_0, ..., y_{K-1}],
    ///                                                       x_M, ..., x_{N-1}]
    /// 
    /// Examples::
    /// 
    ///   data = [[0, 1], [2, 3]]
    ///   indices = [[1, 1, 0], [0, 1, 0]]
    ///   gather_nd(data, indices) = [2, 3, 0]
    /// 
    ///   data = [[[1, 2], [3, 4]], [[5, 6], [7, 8]]]
    ///   indices = [[0, 1], [1, 0]]
    ///   gather_nd(data, indices) = [[3, 4], [5, 6]]
    /// 
    /// </summary>
    /// <param name="data">data</param>
    /// <param name="indices">indices</param>
    static member GatherNd(data : NDArray, indices : NDArray) =
        let creator = AtomicSymbolCreator.FromName "gather_nd"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg indices)) then indices.UnsafeHandle|]
                                                 Array.empty
                                                 Array.empty
        (new NDArray(outputs.[0]))
    /// <summary>Gather elements or slices from `data` and store to a tensor whose
    /// shape is defined by `indices`.
    /// 
    /// Given `data` with shape `(X_0, X_1, ..., X_{N-1})` and indices with shape
    /// `(M, Y_0, ..., Y_{K-1})`, the output will have shape `(Y_0, ..., Y_{K-1}, X_M, ..., X_{N-1})`,
    /// where `M &lt;= N`. If `M == N`, output shape will simply be `(Y_0, ..., Y_{K-1})`.
    /// 
    /// The elements in output is defined as follows::
    /// 
    ///   output[y_0, ..., y_{K-1}, x_M, ..., x_{N-1}] = data[indices[0, y_0, ..., y_{K-1}],
    ///                                                       ...,
    ///                                                       indices[M-1, y_0, ..., y_{K-1}],
    ///                                                       x_M, ..., x_{N-1}]
    /// 
    /// Examples::
    /// 
    ///   data = [[0, 1], [2, 3]]
    ///   indices = [[1, 1, 0], [0, 1, 0]]
    ///   gather_nd(data, indices) = [2, 3, 0]
    /// 
    ///   data = [[[1, 2], [3, 4]], [[5, 6], [7, 8]]]
    ///   indices = [[0, 1], [1, 0]]
    ///   gather_nd(data, indices) = [[3, 4], [5, 6]]
    /// 
    /// </summary>
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="data">data</param>
    /// <param name="indices">indices</param>
    static member GatherNd(outputArray : NDArray seq, data : NDArray, indices : NDArray) =
        let creator = AtomicSymbolCreator.FromName "gather_nd"
        let names = Array.empty
        let vals = Array.empty
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg indices)) then indices.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <summary>Gather elements or slices from `data` and store to a tensor whose
    /// shape is defined by `indices`.
    /// 
    /// Given `data` with shape `(X_0, X_1, ..., X_{N-1})` and indices with shape
    /// `(M, Y_0, ..., Y_{K-1})`, the output will have shape `(Y_0, ..., Y_{K-1}, X_M, ..., X_{N-1})`,
    /// where `M &lt;= N`. If `M == N`, output shape will simply be `(Y_0, ..., Y_{K-1})`.
    /// 
    /// The elements in output is defined as follows::
    /// 
    ///   output[y_0, ..., y_{K-1}, x_M, ..., x_{N-1}] = data[indices[0, y_0, ..., y_{K-1}],
    ///                                                       ...,
    ///                                                       indices[M-1, y_0, ..., y_{K-1}],
    ///                                                       x_M, ..., x_{N-1}]
    /// 
    /// Examples::
    /// 
    ///   data = [[0, 1], [2, 3]]
    ///   indices = [[1, 1, 0], [0, 1, 0]]
    ///   gather_nd(data, indices) = [2, 3, 0]
    /// 
    ///   data = [[[1, 2], [3, 4]], [[5, 6], [7, 8]]]
    ///   indices = [[0, 1], [1, 0]]
    ///   gather_nd(data, indices) = [[3, 4], [5, 6]]
    /// 
    /// </summary>
    /// <param name="data">data</param>
    /// <param name="indices">indices</param>
    static member GatherNd([<Optional>] ?data : Symbol, [<Optional>] ?indices : Symbol) =
        GatherNd(?data = data, ?indices = indices)

    /// <summary>Scatters data into a new tensor according to indices.
    /// 
    /// Given `data` with shape `(Y_0, ..., Y_{K-1}, X_M, ..., X_{N-1})` and indices with shape
    /// `(M, Y_0, ..., Y_{K-1})`, the output will have shape `(X_0, X_1, ..., X_{N-1})`,
    /// where `M &lt;= N`. If `M == N`, data shape should simply be `(Y_0, ..., Y_{K-1})`.
    /// 
    /// The elements in output is defined as follows::
    /// 
    ///   output[indices[0, y_0, ..., y_{K-1}],
    ///          ...,
    ///          indices[M-1, y_0, ..., y_{K-1}],
    ///          x_M, ..., x_{N-1}] = data[y_0, ..., y_{K-1}, x_M, ..., x_{N-1}]
    /// 
    /// all other entries in output are 0.
    /// 
    /// .. warning::
    /// 
    ///     If the indices have duplicates, the result will be non-deterministic and
    ///     the gradient of `scatter_nd` will not be correct!!
    /// 
    /// 
    /// Examples::
    /// 
    ///   data = [2, 3, 0]
    ///   indices = [[1, 1, 0], [0, 1, 0]]
    ///   shape = (2, 2)
    ///   scatter_nd(data, indices, shape) = [[0, 0], [2, 3]]
    /// 
    ///   data = [[[1, 2], [3, 4]], [[5, 6], [7, 8]]]
    ///   indices = [[0, 1], [1, 1]]
    ///   shape = (2, 2, 2, 2)
    ///   scatter_nd(data, indices, shape) = [[[[0, 0],
    ///                                         [0, 0]],
    /// 
    ///                                        [[1, 2],
    ///                                         [3, 4]]],
    /// 
    ///                                       [[[0, 0],
    ///                                         [0, 0]],
    /// 
    ///                                        [[5, 6],
    ///                                         [7, 8]]]]
    /// 
    /// </summary>
    /// <param name="data">data</param>
    /// <param name="indices">indices</param>
    /// <param name="shape">Shape of output.</param>
    static member ScatterNd(data : NDArray, indices : NDArray, shape : int seq) =
        let creator = AtomicSymbolCreator.FromName "scatter_nd"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg indices)) then indices.UnsafeHandle|]
                                                 [|"shape"|]
                                                 [|(shape |> Seq.map string |> String.concat ", " |> sprintf "[%s]")|]
        (new NDArray(outputs.[0]))
    /// <summary>Scatters data into a new tensor according to indices.
    /// 
    /// Given `data` with shape `(Y_0, ..., Y_{K-1}, X_M, ..., X_{N-1})` and indices with shape
    /// `(M, Y_0, ..., Y_{K-1})`, the output will have shape `(X_0, X_1, ..., X_{N-1})`,
    /// where `M &lt;= N`. If `M == N`, data shape should simply be `(Y_0, ..., Y_{K-1})`.
    /// 
    /// The elements in output is defined as follows::
    /// 
    ///   output[indices[0, y_0, ..., y_{K-1}],
    ///          ...,
    ///          indices[M-1, y_0, ..., y_{K-1}],
    ///          x_M, ..., x_{N-1}] = data[y_0, ..., y_{K-1}, x_M, ..., x_{N-1}]
    /// 
    /// all other entries in output are 0.
    /// 
    /// .. warning::
    /// 
    ///     If the indices have duplicates, the result will be non-deterministic and
    ///     the gradient of `scatter_nd` will not be correct!!
    /// 
    /// 
    /// Examples::
    /// 
    ///   data = [2, 3, 0]
    ///   indices = [[1, 1, 0], [0, 1, 0]]
    ///   shape = (2, 2)
    ///   scatter_nd(data, indices, shape) = [[0, 0], [2, 3]]
    /// 
    ///   data = [[[1, 2], [3, 4]], [[5, 6], [7, 8]]]
    ///   indices = [[0, 1], [1, 1]]
    ///   shape = (2, 2, 2, 2)
    ///   scatter_nd(data, indices, shape) = [[[[0, 0],
    ///                                         [0, 0]],
    /// 
    ///                                        [[1, 2],
    ///                                         [3, 4]]],
    /// 
    ///                                       [[[0, 0],
    ///                                         [0, 0]],
    /// 
    ///                                        [[5, 6],
    ///                                         [7, 8]]]]
    /// 
    /// </summary>
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="data">data</param>
    /// <param name="indices">indices</param>
    /// <param name="shape">Shape of output.</param>
    static member ScatterNd(outputArray : NDArray seq, data : NDArray, indices : NDArray, shape : int seq) =
        let creator = AtomicSymbolCreator.FromName "scatter_nd"
        let names = [|"shape"|]
        let vals = [|(shape |> Seq.map string |> String.concat ", " |> sprintf "[%s]")|]
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg indices)) then indices.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <summary>Scatters data into a new tensor according to indices.
    /// 
    /// Given `data` with shape `(Y_0, ..., Y_{K-1}, X_M, ..., X_{N-1})` and indices with shape
    /// `(M, Y_0, ..., Y_{K-1})`, the output will have shape `(X_0, X_1, ..., X_{N-1})`,
    /// where `M &lt;= N`. If `M == N`, data shape should simply be `(Y_0, ..., Y_{K-1})`.
    /// 
    /// The elements in output is defined as follows::
    /// 
    ///   output[indices[0, y_0, ..., y_{K-1}],
    ///          ...,
    ///          indices[M-1, y_0, ..., y_{K-1}],
    ///          x_M, ..., x_{N-1}] = data[y_0, ..., y_{K-1}, x_M, ..., x_{N-1}]
    /// 
    /// all other entries in output are 0.
    /// 
    /// .. warning::
    /// 
    ///     If the indices have duplicates, the result will be non-deterministic and
    ///     the gradient of `scatter_nd` will not be correct!!
    /// 
    /// 
    /// Examples::
    /// 
    ///   data = [2, 3, 0]
    ///   indices = [[1, 1, 0], [0, 1, 0]]
    ///   shape = (2, 2)
    ///   scatter_nd(data, indices, shape) = [[0, 0], [2, 3]]
    /// 
    ///   data = [[[1, 2], [3, 4]], [[5, 6], [7, 8]]]
    ///   indices = [[0, 1], [1, 1]]
    ///   shape = (2, 2, 2, 2)
    ///   scatter_nd(data, indices, shape) = [[[[0, 0],
    ///                                         [0, 0]],
    /// 
    ///                                        [[1, 2],
    ///                                         [3, 4]]],
    /// 
    ///                                       [[[0, 0],
    ///                                         [0, 0]],
    /// 
    ///                                        [[5, 6],
    ///                                         [7, 8]]]]
    /// 
    /// </summary>
    /// <param name="data">data</param>
    /// <param name="indices">indices</param>
    /// <param name="shape">Shape of output.</param>
    static member ScatterNd(data : Symbol, indices : Symbol, shape : int seq) =
        ScatterNd(data, indices, shape)
    /// <summary>Scatters data into a new tensor according to indices.
    /// 
    /// Given `data` with shape `(Y_0, ..., Y_{K-1}, X_M, ..., X_{N-1})` and indices with shape
    /// `(M, Y_0, ..., Y_{K-1})`, the output will have shape `(X_0, X_1, ..., X_{N-1})`,
    /// where `M &lt;= N`. If `M == N`, data shape should simply be `(Y_0, ..., Y_{K-1})`.
    /// 
    /// The elements in output is defined as follows::
    /// 
    ///   output[indices[0, y_0, ..., y_{K-1}],
    ///          ...,
    ///          indices[M-1, y_0, ..., y_{K-1}],
    ///          x_M, ..., x_{N-1}] = data[y_0, ..., y_{K-1}, x_M, ..., x_{N-1}]
    /// 
    /// all other entries in output are 0.
    /// 
    /// .. warning::
    /// 
    ///     If the indices have duplicates, the result will be non-deterministic and
    ///     the gradient of `scatter_nd` will not be correct!!
    /// 
    /// 
    /// Examples::
    /// 
    ///   data = [2, 3, 0]
    ///   indices = [[1, 1, 0], [0, 1, 0]]
    ///   shape = (2, 2)
    ///   scatter_nd(data, indices, shape) = [[0, 0], [2, 3]]
    /// 
    ///   data = [[[1, 2], [3, 4]], [[5, 6], [7, 8]]]
    ///   indices = [[0, 1], [1, 1]]
    ///   shape = (2, 2, 2, 2)
    ///   scatter_nd(data, indices, shape) = [[[[0, 0],
    ///                                         [0, 0]],
    /// 
    ///                                        [[1, 2],
    ///                                         [3, 4]]],
    /// 
    ///                                       [[[0, 0],
    ///                                         [0, 0]],
    /// 
    ///                                        [[5, 6],
    ///                                         [7, 8]]]]
    /// 
    /// </summary>
    /// <param name="shape">Shape of output.</param>
    /// <param name="data">data</param>
    /// <param name="indices">indices</param>
    static member ScatterNd(shape : int seq, [<Optional>] ?data : Symbol, [<Optional>] ?indices : Symbol) =
        ScatterNd(shape, ?data = data, ?indices = indices)


    /// <summary>This operator has the same functionality as scatter_nd
    /// except that it does not reset the elements not indexed by the input
    /// index `NDArray` in the input data `NDArray`. output should be explicitly
    /// given and be the same as lhs.
    /// 
    /// .. note:: This operator is for internal use only.
    /// 
    /// Examples::
    /// 
    ///   data = [2, 3, 0]
    ///   indices = [[1, 1, 0], [0, 1, 0]]
    ///   out = [[1, 1], [1, 1]]
    ///   _scatter_set_nd(lhs=out, rhs=data, indices=indices, out=out)
    ///   out = [[0, 1], [2, 3]]
    /// 
    /// </summary>
    /// <param name="lhs">source input</param>
    /// <param name="rhs">value to assign</param>
    /// <param name="indices">indices</param>
    /// <param name="shape">Shape of output.</param>
    static member ScatterSetNd(lhs : NDArray, rhs : NDArray, indices : NDArray, shape : int seq) =
        let creator = AtomicSymbolCreator.FromName "_scatter_set_nd"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg lhs)) then lhs.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg rhs)) then rhs.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg indices)) then indices.UnsafeHandle|]
                                                 [|"shape"|]
                                                 [|(shape |> Seq.map string |> String.concat ", " |> sprintf "[%s]")|]
        (new NDArray(outputs.[0]))
    /// <summary>This operator has the same functionality as scatter_nd
    /// except that it does not reset the elements not indexed by the input
    /// index `NDArray` in the input data `NDArray`. output should be explicitly
    /// given and be the same as lhs.
    /// 
    /// .. note:: This operator is for internal use only.
    /// 
    /// Examples::
    /// 
    ///   data = [2, 3, 0]
    ///   indices = [[1, 1, 0], [0, 1, 0]]
    ///   out = [[1, 1], [1, 1]]
    ///   _scatter_set_nd(lhs=out, rhs=data, indices=indices, out=out)
    ///   out = [[0, 1], [2, 3]]
    /// 
    /// </summary>
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="lhs">source input</param>
    /// <param name="rhs">value to assign</param>
    /// <param name="indices">indices</param>
    /// <param name="shape">Shape of output.</param>
    static member ScatterSetNd(outputArray : NDArray seq, lhs : NDArray, rhs : NDArray, indices : NDArray, shape : int seq) =
        let creator = AtomicSymbolCreator.FromName "_scatter_set_nd"
        let names = [|"shape"|]
        let vals = [|(shape |> Seq.map string |> String.concat ", " |> sprintf "[%s]")|]
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg lhs)) then lhs.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg rhs)) then rhs.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg indices)) then indices.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <summary>This operator has the same functionality as scatter_nd
    /// except that it does not reset the elements not indexed by the input
    /// index `NDArray` in the input data `NDArray`. output should be explicitly
    /// given and be the same as lhs.
    /// 
    /// .. note:: This operator is for internal use only.
    /// 
    /// Examples::
    /// 
    ///   data = [2, 3, 0]
    ///   indices = [[1, 1, 0], [0, 1, 0]]
    ///   out = [[1, 1], [1, 1]]
    ///   _scatter_set_nd(lhs=out, rhs=data, indices=indices, out=out)
    ///   out = [[0, 1], [2, 3]]
    /// 
    /// </summary>
    /// <param name="lhs">source input</param>
    /// <param name="rhs">value to assign</param>
    /// <param name="indices">indices</param>
    /// <param name="shape">Shape of output.</param>
    static member ScatterSetNd(lhs : Symbol, rhs : Symbol, indices : Symbol, shape : int seq) =
        ScatterSetNd(lhs, rhs, indices, shape)
    /// <summary>This operator has the same functionality as scatter_nd
    /// except that it does not reset the elements not indexed by the input
    /// index `NDArray` in the input data `NDArray`. output should be explicitly
    /// given and be the same as lhs.
    /// 
    /// .. note:: This operator is for internal use only.
    /// 
    /// Examples::
    /// 
    ///   data = [2, 3, 0]
    ///   indices = [[1, 1, 0], [0, 1, 0]]
    ///   out = [[1, 1], [1, 1]]
    ///   _scatter_set_nd(lhs=out, rhs=data, indices=indices, out=out)
    ///   out = [[0, 1], [2, 3]]
    /// 
    /// </summary>
    /// <param name="shape">Shape of output.</param>
    /// <param name="lhs">source input</param>
    /// <param name="rhs">value to assign</param>
    /// <param name="indices">indices</param>
    static member ScatterSetNd(shape : int seq, [<Optional>] ?lhs : Symbol, [<Optional>] ?rhs : Symbol, [<Optional>] ?indices : Symbol) =
        ScatterSetNd(shape, ?lhs = lhs, ?rhs = rhs, ?indices = indices)

    /// <summary>fill target with zeros without default dtype</summary>
    /// <param name="ctx">Context of output, in format [cpu|gpu|cpu_pinned](n).Only used for imperative calls.</param>
    /// <param name="shape">The shape of the output</param>
    /// <param name="dtype">Target data type.</param>
    static member ZerosWithoutDtypeNDArray(ctx : Context, [<Optional>] shape : int seq, [<Optional; DefaultParameterValue(-1)>] dtype : int) =
        let creator = AtomicSymbolCreator.FromName "_zeros_without_dtype"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 Array.empty
                                                 [|"ctx"; "shape"; "dtype"|]
                                                 [|string ctx; (if isNull (shape :> obj) then null else (shape |> Seq.map string |> String.concat ", " |> sprintf "[%s]")); string dtype|]
        (new NDArray(outputs.[0]))
    /// <summary>fill target with zeros without default dtype</summary>
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="ctx">Context of output, in format [cpu|gpu|cpu_pinned](n).Only used for imperative calls.</param>
    /// <param name="shape">The shape of the output</param>
    /// <param name="dtype">Target data type.</param>
    static member ZerosWithoutDtype(outputArray : NDArray seq, ctx : Context, [<Optional>] shape : int seq, [<Optional; DefaultParameterValue(-1)>] dtype : int) =
        let creator = AtomicSymbolCreator.FromName "_zeros_without_dtype"
        let names = [|"ctx"; "shape"; "dtype"|]
        let vals = [|string ctx; (if isNull (shape :> obj) then null else (shape |> Seq.map string |> String.concat ", " |> sprintf "[%s]")); string dtype|]
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     Array.empty
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <summary>fill target with zeros without default dtype</summary>
    /// <param name="shape">The shape of the output</param>
    /// <param name="dtype">Target data type.</param>
    static member ZerosWithoutDtype([<Optional>] ?shape : int seq, [<Optional>] ?dtype : int) =
        ZerosWithoutDtype(?shape = shape, ?dtype = dtype)

    /// <summary>fill target with zeros</summary>
    /// <param name="ctx">Context of output, in format [cpu|gpu|cpu_pinned](n).Only used for imperative calls.</param>
    /// <param name="shape">The shape of the output</param>
    /// <param name="dtype">Target data type.</param>
    static member ZerosNDArray(ctx : Context, [<Optional>] shape : int seq, [<Optional>] dtype : DataType) =
        let creator = AtomicSymbolCreator.FromName "_zeros"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 Array.empty
                                                 [|"ctx"; "shape"; "dtype"|]
                                                 [|string ctx; (if isNull (shape :> obj) then "[]" else (shape |> Seq.map string |> String.concat ", " |> sprintf "[%s]")); (if isNull (dtype :> obj) then "float32" else string dtype)|]
        (new NDArray(outputs.[0]))
    /// <summary>fill target with zeros</summary>
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="ctx">Context of output, in format [cpu|gpu|cpu_pinned](n).Only used for imperative calls.</param>
    /// <param name="shape">The shape of the output</param>
    /// <param name="dtype">Target data type.</param>
    static member Zeros(outputArray : NDArray seq, ctx : Context, [<Optional>] shape : int seq, [<Optional>] dtype : DataType) =
        let creator = AtomicSymbolCreator.FromName "_zeros"
        let names = [|"ctx"; "shape"; "dtype"|]
        let vals = [|string ctx; (if isNull (shape :> obj) then "[]" else (shape |> Seq.map string |> String.concat ", " |> sprintf "[%s]")); (if isNull (dtype :> obj) then "float32" else string dtype)|]
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     Array.empty
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <summary>fill target with zeros</summary>
    /// <param name="shape">The shape of the output</param>
    /// <param name="dtype">Target data type.</param>
    static member Zeros([<Optional>] ?shape : int seq, [<Optional>] ?dtype : DataType) =
        Zeros(?shape = shape, ?dtype = dtype)

    /// <summary>Return a 2-D array with ones on the diagonal and zeros elsewhere.</summary>
    /// <param name="N">Number of rows in the output.</param>
    /// <param name="ctx">Context of output, in format [cpu|gpu|cpu_pinned](n).Only used for imperative calls.</param>
    /// <param name="M">Number of columns in the output. If 0, defaults to N</param>
    /// <param name="k">Index of the diagonal. 0 (the default) refers to the main diagonal.A positive value refers to an upper diagonal.A negative value to a lower diagonal.</param>
    /// <param name="dtype">Target data type.</param>
    static member EyeNDArray(N : int64, 
                             ctx : Context, 
                             [<Optional; DefaultParameterValue(0L)>] M : int64, 
                             [<Optional; DefaultParameterValue(0L)>] k : int64, 
                             [<Optional>] dtype : DataType) =
        let creator = AtomicSymbolCreator.FromName "_eye"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 Array.empty
                                                 [|"N"; "ctx"; "M"; "k"; "dtype"|]
                                                 [|string N; string ctx; string M; string k; (if isNull (dtype :> obj) then "float32" else string dtype)|]
        (new NDArray(outputs.[0]))
    /// <summary>Return a 2-D array with ones on the diagonal and zeros elsewhere.</summary>
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="N">Number of rows in the output.</param>
    /// <param name="ctx">Context of output, in format [cpu|gpu|cpu_pinned](n).Only used for imperative calls.</param>
    /// <param name="M">Number of columns in the output. If 0, defaults to N</param>
    /// <param name="k">Index of the diagonal. 0 (the default) refers to the main diagonal.A positive value refers to an upper diagonal.A negative value to a lower diagonal.</param>
    /// <param name="dtype">Target data type.</param>
    static member Eye(outputArray : NDArray seq, 
                      N : int64, 
                      ctx : Context, 
                      [<Optional; DefaultParameterValue(0L)>] M : int64, 
                      [<Optional; DefaultParameterValue(0L)>] k : int64, 
                      [<Optional>] dtype : DataType) =
        let creator = AtomicSymbolCreator.FromName "_eye"
        let names = [|"N"; "ctx"; "M"; "k"; "dtype"|]
        let vals = [|string N; string ctx; string M; string k; (if isNull (dtype :> obj) then "float32" else string dtype)|]
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     Array.empty
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <summary>Return a 2-D array with ones on the diagonal and zeros elsewhere.</summary>
    /// <param name="N">Number of rows in the output.</param>
    /// <param name="M">Number of columns in the output. If 0, defaults to N</param>
    /// <param name="k">Index of the diagonal. 0 (the default) refers to the main diagonal.A positive value refers to an upper diagonal.A negative value to a lower diagonal.</param>
    /// <param name="dtype">Target data type.</param>
    static member Eye(N : int64, [<Optional>] ?M : int64, [<Optional>] ?k : int64, [<Optional>] ?dtype : DataType) =
        Eye(N, ?M = M, ?k = k, ?dtype = dtype)

    /// <summary>fill target with ones</summary>
    /// <param name="ctx">Context of output, in format [cpu|gpu|cpu_pinned](n).Only used for imperative calls.</param>
    /// <param name="shape">The shape of the output</param>
    /// <param name="dtype">Target data type.</param>
    static member OnesNDArray(ctx : Context, [<Optional>] shape : int seq, [<Optional>] dtype : DataType) =
        let creator = AtomicSymbolCreator.FromName "_ones"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 Array.empty
                                                 [|"ctx"; "shape"; "dtype"|]
                                                 [|string ctx; (if isNull (shape :> obj) then "[]" else (shape |> Seq.map string |> String.concat ", " |> sprintf "[%s]")); (if isNull (dtype :> obj) then "float32" else string dtype)|]
        (new NDArray(outputs.[0]))
    /// <summary>fill target with ones</summary>
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="ctx">Context of output, in format [cpu|gpu|cpu_pinned](n).Only used for imperative calls.</param>
    /// <param name="shape">The shape of the output</param>
    /// <param name="dtype">Target data type.</param>
    static member Ones(outputArray : NDArray seq, ctx : Context, [<Optional>] shape : int seq, [<Optional>] dtype : DataType) =
        let creator = AtomicSymbolCreator.FromName "_ones"
        let names = [|"ctx"; "shape"; "dtype"|]
        let vals = [|string ctx; (if isNull (shape :> obj) then "[]" else (shape |> Seq.map string |> String.concat ", " |> sprintf "[%s]")); (if isNull (dtype :> obj) then "float32" else string dtype)|]
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     Array.empty
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <summary>fill target with ones</summary>
    /// <param name="shape">The shape of the output</param>
    /// <param name="dtype">Target data type.</param>
    static member Ones([<Optional>] ?shape : int seq, [<Optional>] ?dtype : DataType) =
        Ones(?shape = shape, ?dtype = dtype)

    /// <summary>fill target with a scalar value</summary>
    /// <param name="ctx">Context of output, in format [cpu|gpu|cpu_pinned](n).Only used for imperative calls.</param>
    /// <param name="value">Value with which to fill newly created tensor</param>
    /// <param name="shape">The shape of the output</param>
    /// <param name="dtype">Target data type.</param>
    static member FullNDArray(ctx : Context, value : double, [<Optional>] shape : int seq, [<Optional>] dtype : DataType) =
        let creator = AtomicSymbolCreator.FromName "_full"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 Array.empty
                                                 [|"ctx"; "value"; "shape"; "dtype"|]
                                                 [|string ctx; string value; (if isNull (shape :> obj) then null else (shape |> Seq.map string |> String.concat ", " |> sprintf "[%s]")); (if isNull (dtype :> obj) then "float32" else string dtype)|]
        outputs |> Array.map (fun h -> new NDArray(h))
    /// <summary>fill target with a scalar value</summary>
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="ctx">Context of output, in format [cpu|gpu|cpu_pinned](n).Only used for imperative calls.</param>
    /// <param name="value">Value with which to fill newly created tensor</param>
    /// <param name="shape">The shape of the output</param>
    /// <param name="dtype">Target data type.</param>
    static member Full(outputArray : NDArray seq, ctx : Context, value : double, [<Optional>] shape : int seq, [<Optional>] dtype : DataType) =
        let creator = AtomicSymbolCreator.FromName "_full"
        let names = [|"ctx"; "value"; "shape"; "dtype"|]
        let vals = [|string ctx; string value; (if isNull (shape :> obj) then null else (shape |> Seq.map string |> String.concat ", " |> sprintf "[%s]")); (if isNull (dtype :> obj) then "float32" else string dtype)|]
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     Array.empty
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <summary>fill target with a scalar value</summary>
    /// <param name="value">Value with which to fill newly created tensor</param>
    /// <param name="shape">The shape of the output</param>
    /// <param name="dtype">Target data type.</param>
    static member Full(value : double, [<Optional>] ?shape : int seq, [<Optional>] ?dtype : DataType) =
        Full(value, ?shape = shape, ?dtype = dtype)

    /// <summary>Return evenly spaced values within a given interval. Similar to Numpy</summary>
    /// <param name="start">Start of interval. The interval includes this value. The default start value is 0.</param>
    /// <param name="ctx">Context of output, in format [cpu|gpu|cpu_pinned](n).Only used for imperative calls.</param>
    /// <param name="stop">End of interval. The interval does not include this value, except in some cases where step is not an integer and floating point round-off affects the length of out.</param>
    /// <param name="step">Spacing between values.</param>
    /// <param name="repeat">The repeating time of all elements. E.g repeat=3, the element a will be repeated three times --&gt; a, a, a.</param>
    /// <param name="inferRange">When set to True, infer the stop position from the start, step, repeat, and output tensor size.</param>
    /// <param name="dtype">Target data type.</param>
    static member ArangeNDArray(start : double, 
                                ctx : Context, 
                                [<Optional>] ?stop : float, 
                                [<Optional>] ?step : double, 
                                [<Optional>] ?repeat : int, 
                                [<Optional>] ?inferRange : bool, 
                                [<Optional>] ?dtype : DataType) =
        let creator = AtomicSymbolCreator.FromName "_arange"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 Array.empty
                                                 [|"start"; "ctx"; "stop"; "step"; "repeat"; "infer_range"; "dtype"|]
                                                 [|string start; string ctx; (match stop with None -> "None" | Some stop -> string stop); (match step with None -> "1.0" | Some step -> string step); (match repeat with None -> "1" | Some repeat -> string repeat); (match inferRange with None -> "false" | Some inferRange -> string inferRange); (match dtype with None -> "float32" | Some dtype -> string dtype)|]
        (new NDArray(outputs.[0]))
    /// <summary>Return evenly spaced values within a given interval. Similar to Numpy</summary>
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="start">Start of interval. The interval includes this value. The default start value is 0.</param>
    /// <param name="ctx">Context of output, in format [cpu|gpu|cpu_pinned](n).Only used for imperative calls.</param>
    /// <param name="stop">End of interval. The interval does not include this value, except in some cases where step is not an integer and floating point round-off affects the length of out.</param>
    /// <param name="step">Spacing between values.</param>
    /// <param name="repeat">The repeating time of all elements. E.g repeat=3, the element a will be repeated three times --&gt; a, a, a.</param>
    /// <param name="inferRange">When set to True, infer the stop position from the start, step, repeat, and output tensor size.</param>
    /// <param name="dtype">Target data type.</param>
    static member Arange(outputArray : NDArray seq, 
                         start : double, 
                         ctx : Context, 
                         [<Optional>] ?stop : float, 
                         [<Optional>] ?step : double, 
                         [<Optional>] ?repeat : int, 
                         [<Optional>] ?inferRange : bool, 
                         [<Optional>] ?dtype : DataType) =
        let creator = AtomicSymbolCreator.FromName "_arange"
        let names = [|"start"; "ctx"; "stop"; "step"; "repeat"; "infer_range"; "dtype"|]
        let vals = [|string start; string ctx; (match stop with None -> "None" | Some stop -> string stop); (match step with None -> "1.0" | Some step -> string step); (match repeat with None -> "1" | Some repeat -> string repeat); (match inferRange with None -> "false" | Some inferRange -> string inferRange); (match dtype with None -> "float32" | Some dtype -> string dtype)|]
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     Array.empty
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <summary>Return evenly spaced values within a given interval. Similar to Numpy</summary>
    /// <param name="start">Start of interval. The interval includes this value. The default start value is 0.</param>
    /// <param name="stop">End of interval. The interval does not include this value, except in some cases where step is not an integer and floating point round-off affects the length of out.</param>
    /// <param name="step">Spacing between values.</param>
    /// <param name="repeat">The repeating time of all elements. E.g repeat=3, the element a will be repeated three times --&gt; a, a, a.</param>
    /// <param name="inferRange">When set to True, infer the stop position from the start, step, repeat, and output tensor size.</param>
    /// <param name="dtype">Target data type.</param>
    static member Arange(start : double, [<Optional>] ?stop : float, [<Optional>] ?step : double, [<Optional>] ?repeat : int, [<Optional>] ?inferRange : bool, [<Optional>] ?dtype : DataType) =
        Arange(start, ?stop = stop, ?step = step, ?repeat = repeat, ?inferRange = inferRange, ?dtype = dtype)

    /// <summary>Return an array with evenly spaced values. If axis is not given, the output will 
    /// have the same shape as the input array. Otherwise, the output will be a 1-D array with size of 
    /// the specified axis in input shape.
    /// 
    /// Examples::
    /// 
    ///   x = [[0.14883883 0.7772398  0.94865847 0.7225052 ]
    ///        [0.23729339 0.6112595  0.66538996 0.5132841 ]
    ///        [0.30822644 0.9912457  0.15502319 0.7043658 ]]
    ///        &lt;NDArray 3x4 @cpu(0)&gt;
    /// 
    ///   out = mx.nd.contrib.arange_like(x, start=0)
    /// 
    ///     [[ 0.  1.  2.  3.]
    ///      [ 4.  5.  6.  7.]
    ///      [ 8.  9. 10. 11.]]
    ///      &lt;NDArray 3x4 @cpu(0)&gt;
    /// 
    ///   out = mx.nd.contrib.arange_like(x, start=0, axis=-1)
    /// 
    ///     [0. 1. 2. 3.]
    ///     &lt;NDArray 4 @cpu(0)&gt;
    /// </summary>
    /// <param name="data">The input</param>
    /// <param name="ctx">Context of output, in format [cpu|gpu|cpu_pinned](n).Only used for imperative calls.</param>
    /// <param name="start">Start of interval. The interval includes this value. The default start value is 0.</param>
    /// <param name="step">Spacing between values.</param>
    /// <param name="repeat">The repeating time of all elements. E.g repeat=3, the element a will be repeated three times --&gt; a, a, a.</param>
    /// <param name="axis">Arange elements according to the size of a certain axis of input array. The negative numbers are interpreted counting from the backward. If not provided, will arange elements according to the input shape.</param>
    static member ContribArangeLike(data : NDArray, 
                                    ctx : Context, 
                                    [<Optional>] ?start : double, 
                                    [<Optional>] ?step : double, 
                                    [<Optional>] ?repeat : int, 
                                    [<Optional>] ?axis : int) =
        let creator = AtomicSymbolCreator.FromName "_contrib_arange_like"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle|]
                                                 [|"ctx"; "start"; "step"; "repeat"; "axis"|]
                                                 [|string ctx; (match start with None -> "0.0" | Some start -> string start); (match step with None -> "1.0" | Some step -> string step); (match repeat with None -> "1" | Some repeat -> string repeat); (match axis with None -> "None" | Some axis -> string axis)|]
        (new NDArray(outputs.[0]))
    /// <summary>Return an array with evenly spaced values. If axis is not given, the output will 
    /// have the same shape as the input array. Otherwise, the output will be a 1-D array with size of 
    /// the specified axis in input shape.
    /// 
    /// Examples::
    /// 
    ///   x = [[0.14883883 0.7772398  0.94865847 0.7225052 ]
    ///        [0.23729339 0.6112595  0.66538996 0.5132841 ]
    ///        [0.30822644 0.9912457  0.15502319 0.7043658 ]]
    ///        &lt;NDArray 3x4 @cpu(0)&gt;
    /// 
    ///   out = mx.nd.contrib.arange_like(x, start=0)
    /// 
    ///     [[ 0.  1.  2.  3.]
    ///      [ 4.  5.  6.  7.]
    ///      [ 8.  9. 10. 11.]]
    ///      &lt;NDArray 3x4 @cpu(0)&gt;
    /// 
    ///   out = mx.nd.contrib.arange_like(x, start=0, axis=-1)
    /// 
    ///     [0. 1. 2. 3.]
    ///     &lt;NDArray 4 @cpu(0)&gt;
    /// </summary>
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="data">The input</param>
    /// <param name="ctx">Context of output, in format [cpu|gpu|cpu_pinned](n).Only used for imperative calls.</param>
    /// <param name="start">Start of interval. The interval includes this value. The default start value is 0.</param>
    /// <param name="step">Spacing between values.</param>
    /// <param name="repeat">The repeating time of all elements. E.g repeat=3, the element a will be repeated three times --&gt; a, a, a.</param>
    /// <param name="axis">Arange elements according to the size of a certain axis of input array. The negative numbers are interpreted counting from the backward. If not provided, will arange elements according to the input shape.</param>
    static member ContribArangeLike(outputArray : NDArray seq, 
                                    data : NDArray, 
                                    ctx : Context, 
                                    [<Optional>] ?start : double, 
                                    [<Optional>] ?step : double, 
                                    [<Optional>] ?repeat : int, 
                                    [<Optional>] ?axis : int) =
        let creator = AtomicSymbolCreator.FromName "_contrib_arange_like"
        let names = [|"ctx"; "start"; "step"; "repeat"; "axis"|]
        let vals = [|string ctx; (match start with None -> "0.0" | Some start -> string start); (match step with None -> "1.0" | Some step -> string step); (match repeat with None -> "1" | Some repeat -> string repeat); (match axis with None -> "None" | Some axis -> string axis)|]
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <summary>Return an array with evenly spaced values. If axis is not given, the output will 
    /// have the same shape as the input array. Otherwise, the output will be a 1-D array with size of 
    /// the specified axis in input shape.
    /// 
    /// Examples::
    /// 
    ///   x = [[0.14883883 0.7772398  0.94865847 0.7225052 ]
    ///        [0.23729339 0.6112595  0.66538996 0.5132841 ]
    ///        [0.30822644 0.9912457  0.15502319 0.7043658 ]]
    ///        &lt;NDArray 3x4 @cpu(0)&gt;
    /// 
    ///   out = mx.nd.contrib.arange_like(x, start=0)
    /// 
    ///     [[ 0.  1.  2.  3.]
    ///      [ 4.  5.  6.  7.]
    ///      [ 8.  9. 10. 11.]]
    ///      &lt;NDArray 3x4 @cpu(0)&gt;
    /// 
    ///   out = mx.nd.contrib.arange_like(x, start=0, axis=-1)
    /// 
    ///     [0. 1. 2. 3.]
    ///     &lt;NDArray 4 @cpu(0)&gt;
    /// </summary>
    /// <param name="data">The input</param>
    /// <param name="start">Start of interval. The interval includes this value. The default start value is 0.</param>
    /// <param name="step">Spacing between values.</param>
    /// <param name="repeat">The repeating time of all elements. E.g repeat=3, the element a will be repeated three times --&gt; a, a, a.</param>
    /// <param name="axis">Arange elements according to the size of a certain axis of input array. The negative numbers are interpreted counting from the backward. If not provided, will arange elements according to the input shape.</param>
    static member ContribArangeLike([<Optional>] ?data : Symbol, [<Optional>] ?start : double, [<Optional>] ?step : double, [<Optional>] ?repeat : int, [<Optional>] ?axis : int) =
        ContribArangeLike(?data = data, ?start = start, ?step = step, ?repeat = repeat, ?axis = axis)

    /// <summary>Return evenly spaced numbers over a specified interval. Similar to Numpy</summary>
    /// <param name="start">Start of interval. The interval includes this value. The default start value is 0.</param>
    /// <param name="ctx">Context of output, in format [cpu|gpu|cpu_pinned](n).Only used for imperative calls.</param>
    /// <param name="stop">End of interval. The interval does not include this value, except in some cases where step is not an integer and floating point round-off affects the length of out.</param>
    /// <param name="step">Spacing between values.</param>
    /// <param name="repeat">The repeating time of all elements. E.g repeat=3, the element a will be repeated three times --&gt; a, a, a.</param>
    /// <param name="inferRange">When set to True, infer the stop position from the start, step, repeat, and output tensor size.</param>
    /// <param name="dtype">Target data type.</param>
    static member LinspaceNDArray(start : double, 
                                  ctx : Context, 
                                  [<Optional>] ?stop : float, 
                                  [<Optional>] ?step : double, 
                                  [<Optional>] ?repeat : int, 
                                  [<Optional>] ?inferRange : bool, 
                                  [<Optional>] ?dtype : DataType) =
        let creator = AtomicSymbolCreator.FromName "_linspace"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 Array.empty
                                                 [|"start"; "ctx"; "stop"; "step"; "repeat"; "infer_range"; "dtype"|]
                                                 [|string start; string ctx; (match stop with None -> "None" | Some stop -> string stop); (match step with None -> "1.0" | Some step -> string step); (match repeat with None -> "1" | Some repeat -> string repeat); (match inferRange with None -> "false" | Some inferRange -> string inferRange); (match dtype with None -> "float32" | Some dtype -> string dtype)|]
        (new NDArray(outputs.[0]))
    /// <summary>Return evenly spaced numbers over a specified interval. Similar to Numpy</summary>
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="start">Start of interval. The interval includes this value. The default start value is 0.</param>
    /// <param name="ctx">Context of output, in format [cpu|gpu|cpu_pinned](n).Only used for imperative calls.</param>
    /// <param name="stop">End of interval. The interval does not include this value, except in some cases where step is not an integer and floating point round-off affects the length of out.</param>
    /// <param name="step">Spacing between values.</param>
    /// <param name="repeat">The repeating time of all elements. E.g repeat=3, the element a will be repeated three times --&gt; a, a, a.</param>
    /// <param name="inferRange">When set to True, infer the stop position from the start, step, repeat, and output tensor size.</param>
    /// <param name="dtype">Target data type.</param>
    static member Linspace(outputArray : NDArray seq, 
                           start : double, 
                           ctx : Context, 
                           [<Optional>] ?stop : float, 
                           [<Optional>] ?step : double, 
                           [<Optional>] ?repeat : int, 
                           [<Optional>] ?inferRange : bool, 
                           [<Optional>] ?dtype : DataType) =
        let creator = AtomicSymbolCreator.FromName "_linspace"
        let names = [|"start"; "ctx"; "stop"; "step"; "repeat"; "infer_range"; "dtype"|]
        let vals = [|string start; string ctx; (match stop with None -> "None" | Some stop -> string stop); (match step with None -> "1.0" | Some step -> string step); (match repeat with None -> "1" | Some repeat -> string repeat); (match inferRange with None -> "false" | Some inferRange -> string inferRange); (match dtype with None -> "float32" | Some dtype -> string dtype)|]
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     Array.empty
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <summary>Return evenly spaced numbers over a specified interval. Similar to Numpy</summary>
    /// <param name="start">Start of interval. The interval includes this value. The default start value is 0.</param>
    /// <param name="stop">End of interval. The interval does not include this value, except in some cases where step is not an integer and floating point round-off affects the length of out.</param>
    /// <param name="step">Spacing between values.</param>
    /// <param name="repeat">The repeating time of all elements. E.g repeat=3, the element a will be repeated three times --&gt; a, a, a.</param>
    /// <param name="inferRange">When set to True, infer the stop position from the start, step, repeat, and output tensor size.</param>
    /// <param name="dtype">Target data type.</param>
    static member Linspace(start : double, [<Optional>] ?stop : float, [<Optional>] ?step : double, [<Optional>] ?repeat : int, [<Optional>] ?inferRange : bool, [<Optional>] ?dtype : DataType) =
        Linspace(start, ?stop = stop, ?step = step, ?repeat = repeat, ?inferRange = inferRange, ?dtype = dtype)

    /// <summary>Return an array of zeros with the same shape, type and storage type
    /// as the input array.
    /// 
    /// The storage type of ``zeros_like`` output depends on the storage type of the input
    /// 
    /// - zeros_like(row_sparse) = row_sparse
    /// - zeros_like(csr) = csr
    /// - zeros_like(default) = default
    /// 
    /// Examples::
    /// 
    ///   x = [[ 1.,  1.,  1.],
    ///        [ 1.,  1.,  1.]]
    /// 
    ///   zeros_like(x) = [[ 0.,  0.,  0.],
    ///                    [ 0.,  0.,  0.]]
    /// 
    /// </summary>
    /// <param name="data">The input</param>
    static member ZerosLike(data : NDArray) =
        let creator = AtomicSymbolCreator.FromName "zeros_like"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle|]
                                                 Array.empty
                                                 Array.empty
        (new NDArray(outputs.[0]))
    /// <summary>Return an array of zeros with the same shape, type and storage type
    /// as the input array.
    /// 
    /// The storage type of ``zeros_like`` output depends on the storage type of the input
    /// 
    /// - zeros_like(row_sparse) = row_sparse
    /// - zeros_like(csr) = csr
    /// - zeros_like(default) = default
    /// 
    /// Examples::
    /// 
    ///   x = [[ 1.,  1.,  1.],
    ///        [ 1.,  1.,  1.]]
    /// 
    ///   zeros_like(x) = [[ 0.,  0.,  0.],
    ///                    [ 0.,  0.,  0.]]
    /// 
    /// </summary>
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="data">The input</param>
    static member ZerosLike(outputArray : NDArray seq, data : NDArray) =
        let creator = AtomicSymbolCreator.FromName "zeros_like"
        let names = Array.empty
        let vals = Array.empty
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <summary>Return an array of zeros with the same shape, type and storage type
    /// as the input array.
    /// 
    /// The storage type of ``zeros_like`` output depends on the storage type of the input
    /// 
    /// - zeros_like(row_sparse) = row_sparse
    /// - zeros_like(csr) = csr
    /// - zeros_like(default) = default
    /// 
    /// Examples::
    /// 
    ///   x = [[ 1.,  1.,  1.],
    ///        [ 1.,  1.,  1.]]
    /// 
    ///   zeros_like(x) = [[ 0.,  0.,  0.],
    ///                    [ 0.,  0.,  0.]]
    /// 
    /// </summary>
    /// <param name="data">The input</param>
    static member ZerosLike([<Optional>] ?data : Symbol) =
        ZerosLike(?data = data)

    /// <summary>Return an array of ones with the same shape and type
    /// as the input array.
    /// 
    /// Examples::
    /// 
    ///   x = [[ 0.,  0.,  0.],
    ///        [ 0.,  0.,  0.]]
    /// 
    ///   ones_like(x) = [[ 1.,  1.,  1.],
    ///                   [ 1.,  1.,  1.]]
    /// 
    /// </summary>
    /// <param name="data">The input</param>
    static member OnesLike(data : NDArray) =
        let creator = AtomicSymbolCreator.FromName "ones_like"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle|]
                                                 Array.empty
                                                 Array.empty
        (new NDArray(outputs.[0]))
    /// <summary>Return an array of ones with the same shape and type
    /// as the input array.
    /// 
    /// Examples::
    /// 
    ///   x = [[ 0.,  0.,  0.],
    ///        [ 0.,  0.,  0.]]
    /// 
    ///   ones_like(x) = [[ 1.,  1.,  1.],
    ///                   [ 1.,  1.,  1.]]
    /// 
    /// </summary>
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="data">The input</param>
    static member OnesLike(outputArray : NDArray seq, data : NDArray) =
        let creator = AtomicSymbolCreator.FromName "ones_like"
        let names = Array.empty
        let vals = Array.empty
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <summary>Return an array of ones with the same shape and type
    /// as the input array.
    /// 
    /// Examples::
    /// 
    ///   x = [[ 0.,  0.,  0.],
    ///        [ 0.,  0.,  0.]]
    /// 
    ///   ones_like(x) = [[ 1.,  1.,  1.],
    ///                   [ 1.,  1.,  1.]]
    /// 
    /// </summary>
    /// <param name="data">The input</param>
    static member OnesLike([<Optional>] ?data : Symbol) =
        OnesLike(?data = data)

    /// <summary>Performs general matrix multiplication and accumulation.
    /// Input are tensors *A*, *B*, *C*, each of dimension *n &gt;= 2* and having the same shape
    /// on the leading *n-2* dimensions.
    /// 
    /// If *n=2*, the BLAS3 function *gemm* is performed:
    /// 
    ///    *out* = *alpha* \* *op*\ (*A*) \* *op*\ (*B*) + *beta* \* *C*
    /// 
    /// Here, *alpha* and *beta* are scalar parameters, and *op()* is either the identity or
    /// matrix transposition (depending on *transpose_a*, *transpose_b*).
    /// 
    /// If *n&gt;2*, *gemm* is performed separately for a batch of matrices. The column indices of the matrices
    /// are given by the last dimensions of the tensors, the row indices by the axis specified with the *axis*
    /// parameter. By default, the trailing two dimensions will be used for matrix encoding.
    /// 
    /// For a non-default axis parameter, the operation performed is equivalent to a series of swapaxes/gemm/swapaxes
    /// calls. For example let *A*, *B*, *C* be 5 dimensional tensors. Then gemm(*A*, *B*, *C*, axis=1) is equivalent
    /// to the following without the overhead of the additional swapaxis operations::
    /// 
    ///     A1 = swapaxes(A, dim1=1, dim2=3)
    ///     B1 = swapaxes(B, dim1=1, dim2=3)
    ///     C = swapaxes(C, dim1=1, dim2=3)
    ///     C = gemm(A1, B1, C)
    ///     C = swapaxis(C, dim1=1, dim2=3)
    /// 
    /// When the input data is of type float32 and the environment variables MXNET_CUDA_ALLOW_TENSOR_CORE
    /// and MXNET_CUDA_TENSOR_OP_MATH_ALLOW_CONVERSION are set to 1, this operator will try to use
    /// pseudo-float16 precision (float32 math with float16 I/O) precision in order to use
    /// Tensor Cores on suitable NVIDIA GPUs. This can sometimes give significant speedups.
    /// 
    /// .. note:: The operator supports float32 and float64 data types only.
    /// 
    /// Examples::
    /// 
    ///    Single matrix multiply-add
    ///    A = [[1.0, 1.0], [1.0, 1.0]]
    ///    B = [[1.0, 1.0], [1.0, 1.0], [1.0, 1.0]]
    ///    C = [[1.0, 1.0, 1.0], [1.0, 1.0, 1.0]]
    ///    gemm(A, B, C, transpose_b=True, alpha=2.0, beta=10.0)
    ///            = [[14.0, 14.0, 14.0], [14.0, 14.0, 14.0]]
    /// 
    ///    Batch matrix multiply-add
    ///    A = [[[1.0, 1.0]], [[0.1, 0.1]]]
    ///    B = [[[1.0, 1.0]], [[0.1, 0.1]]]
    ///    C = [[[10.0]], [[0.01]]]
    ///    gemm(A, B, C, transpose_b=True, alpha=2.0 , beta=10.0)
    ///            = [[[104.0]], [[0.14]]]
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\la_op.cc:L89</summary>
    /// <param name="A">Tensor of input matrices</param>
    /// <param name="B">Tensor of input matrices</param>
    /// <param name="C">Tensor of input matrices</param>
    /// <param name="transposeA">Multiply with transposed of first input (A).</param>
    /// <param name="transposeB">Multiply with transposed of second input (B).</param>
    /// <param name="alpha">Scalar factor multiplied with A*B.</param>
    /// <param name="beta">Scalar factor multiplied with C.</param>
    /// <param name="axis">Axis corresponding to the matrix rows.</param>
    static member LinalgGemm(A : NDArray, 
                             B : NDArray, 
                             C : NDArray, 
                             [<Optional; DefaultParameterValue(false)>] transposeA : bool, 
                             [<Optional; DefaultParameterValue(false)>] transposeB : bool, 
                             [<Optional; DefaultParameterValue(1.0)>] alpha : double, 
                             [<Optional; DefaultParameterValue(1.0)>] beta : double, 
                             [<Optional; DefaultParameterValue(-2)>] axis : int) =
        let creator = AtomicSymbolCreator.FromName "_linalg_gemm"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg A)) then A.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg B)) then B.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg C)) then C.UnsafeHandle|]
                                                 [|"transpose_a"; "transpose_b"; "alpha"; "beta"; "axis"|]
                                                 [|string transposeA; string transposeB; string alpha; string beta; string axis|]
        (new NDArray(outputs.[0]))
    /// <summary>Performs general matrix multiplication and accumulation.
    /// Input are tensors *A*, *B*, *C*, each of dimension *n &gt;= 2* and having the same shape
    /// on the leading *n-2* dimensions.
    /// 
    /// If *n=2*, the BLAS3 function *gemm* is performed:
    /// 
    ///    *out* = *alpha* \* *op*\ (*A*) \* *op*\ (*B*) + *beta* \* *C*
    /// 
    /// Here, *alpha* and *beta* are scalar parameters, and *op()* is either the identity or
    /// matrix transposition (depending on *transpose_a*, *transpose_b*).
    /// 
    /// If *n&gt;2*, *gemm* is performed separately for a batch of matrices. The column indices of the matrices
    /// are given by the last dimensions of the tensors, the row indices by the axis specified with the *axis*
    /// parameter. By default, the trailing two dimensions will be used for matrix encoding.
    /// 
    /// For a non-default axis parameter, the operation performed is equivalent to a series of swapaxes/gemm/swapaxes
    /// calls. For example let *A*, *B*, *C* be 5 dimensional tensors. Then gemm(*A*, *B*, *C*, axis=1) is equivalent
    /// to the following without the overhead of the additional swapaxis operations::
    /// 
    ///     A1 = swapaxes(A, dim1=1, dim2=3)
    ///     B1 = swapaxes(B, dim1=1, dim2=3)
    ///     C = swapaxes(C, dim1=1, dim2=3)
    ///     C = gemm(A1, B1, C)
    ///     C = swapaxis(C, dim1=1, dim2=3)
    /// 
    /// When the input data is of type float32 and the environment variables MXNET_CUDA_ALLOW_TENSOR_CORE
    /// and MXNET_CUDA_TENSOR_OP_MATH_ALLOW_CONVERSION are set to 1, this operator will try to use
    /// pseudo-float16 precision (float32 math with float16 I/O) precision in order to use
    /// Tensor Cores on suitable NVIDIA GPUs. This can sometimes give significant speedups.
    /// 
    /// .. note:: The operator supports float32 and float64 data types only.
    /// 
    /// Examples::
    /// 
    ///    Single matrix multiply-add
    ///    A = [[1.0, 1.0], [1.0, 1.0]]
    ///    B = [[1.0, 1.0], [1.0, 1.0], [1.0, 1.0]]
    ///    C = [[1.0, 1.0, 1.0], [1.0, 1.0, 1.0]]
    ///    gemm(A, B, C, transpose_b=True, alpha=2.0, beta=10.0)
    ///            = [[14.0, 14.0, 14.0], [14.0, 14.0, 14.0]]
    /// 
    ///    Batch matrix multiply-add
    ///    A = [[[1.0, 1.0]], [[0.1, 0.1]]]
    ///    B = [[[1.0, 1.0]], [[0.1, 0.1]]]
    ///    C = [[[10.0]], [[0.01]]]
    ///    gemm(A, B, C, transpose_b=True, alpha=2.0 , beta=10.0)
    ///            = [[[104.0]], [[0.14]]]
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\la_op.cc:L89</summary>
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="A">Tensor of input matrices</param>
    /// <param name="B">Tensor of input matrices</param>
    /// <param name="C">Tensor of input matrices</param>
    /// <param name="transposeA">Multiply with transposed of first input (A).</param>
    /// <param name="transposeB">Multiply with transposed of second input (B).</param>
    /// <param name="alpha">Scalar factor multiplied with A*B.</param>
    /// <param name="beta">Scalar factor multiplied with C.</param>
    /// <param name="axis">Axis corresponding to the matrix rows.</param>
    static member LinalgGemm(outputArray : NDArray seq, 
                             A : NDArray, 
                             B : NDArray, 
                             C : NDArray, 
                             [<Optional; DefaultParameterValue(false)>] transposeA : bool, 
                             [<Optional; DefaultParameterValue(false)>] transposeB : bool, 
                             [<Optional; DefaultParameterValue(1.0)>] alpha : double, 
                             [<Optional; DefaultParameterValue(1.0)>] beta : double, 
                             [<Optional; DefaultParameterValue(-2)>] axis : int) =
        let creator = AtomicSymbolCreator.FromName "_linalg_gemm"
        let names = [|"transpose_a"; "transpose_b"; "alpha"; "beta"; "axis"|]
        let vals = [|string transposeA; string transposeB; string alpha; string beta; string axis|]
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg A)) then A.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg B)) then B.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg C)) then C.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <summary>Performs general matrix multiplication and accumulation.
    /// Input are tensors *A*, *B*, *C*, each of dimension *n &gt;= 2* and having the same shape
    /// on the leading *n-2* dimensions.
    /// 
    /// If *n=2*, the BLAS3 function *gemm* is performed:
    /// 
    ///    *out* = *alpha* \* *op*\ (*A*) \* *op*\ (*B*) + *beta* \* *C*
    /// 
    /// Here, *alpha* and *beta* are scalar parameters, and *op()* is either the identity or
    /// matrix transposition (depending on *transpose_a*, *transpose_b*).
    /// 
    /// If *n&gt;2*, *gemm* is performed separately for a batch of matrices. The column indices of the matrices
    /// are given by the last dimensions of the tensors, the row indices by the axis specified with the *axis*
    /// parameter. By default, the trailing two dimensions will be used for matrix encoding.
    /// 
    /// For a non-default axis parameter, the operation performed is equivalent to a series of swapaxes/gemm/swapaxes
    /// calls. For example let *A*, *B*, *C* be 5 dimensional tensors. Then gemm(*A*, *B*, *C*, axis=1) is equivalent
    /// to the following without the overhead of the additional swapaxis operations::
    /// 
    ///     A1 = swapaxes(A, dim1=1, dim2=3)
    ///     B1 = swapaxes(B, dim1=1, dim2=3)
    ///     C = swapaxes(C, dim1=1, dim2=3)
    ///     C = gemm(A1, B1, C)
    ///     C = swapaxis(C, dim1=1, dim2=3)
    /// 
    /// When the input data is of type float32 and the environment variables MXNET_CUDA_ALLOW_TENSOR_CORE
    /// and MXNET_CUDA_TENSOR_OP_MATH_ALLOW_CONVERSION are set to 1, this operator will try to use
    /// pseudo-float16 precision (float32 math with float16 I/O) precision in order to use
    /// Tensor Cores on suitable NVIDIA GPUs. This can sometimes give significant speedups.
    /// 
    /// .. note:: The operator supports float32 and float64 data types only.
    /// 
    /// Examples::
    /// 
    ///    Single matrix multiply-add
    ///    A = [[1.0, 1.0], [1.0, 1.0]]
    ///    B = [[1.0, 1.0], [1.0, 1.0], [1.0, 1.0]]
    ///    C = [[1.0, 1.0, 1.0], [1.0, 1.0, 1.0]]
    ///    gemm(A, B, C, transpose_b=True, alpha=2.0, beta=10.0)
    ///            = [[14.0, 14.0, 14.0], [14.0, 14.0, 14.0]]
    /// 
    ///    Batch matrix multiply-add
    ///    A = [[[1.0, 1.0]], [[0.1, 0.1]]]
    ///    B = [[[1.0, 1.0]], [[0.1, 0.1]]]
    ///    C = [[[10.0]], [[0.01]]]
    ///    gemm(A, B, C, transpose_b=True, alpha=2.0 , beta=10.0)
    ///            = [[[104.0]], [[0.14]]]
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\la_op.cc:L89</summary>
    /// <param name="A">Tensor of input matrices</param>
    /// <param name="B">Tensor of input matrices</param>
    /// <param name="C">Tensor of input matrices</param>
    /// <param name="transposeA">Multiply with transposed of first input (A).</param>
    /// <param name="transposeB">Multiply with transposed of second input (B).</param>
    /// <param name="alpha">Scalar factor multiplied with A*B.</param>
    /// <param name="beta">Scalar factor multiplied with C.</param>
    /// <param name="axis">Axis corresponding to the matrix rows.</param>
    static member LinalgGemm([<Optional>] ?A : Symbol, [<Optional>] ?B : Symbol, [<Optional>] ?C : Symbol, [<Optional>] ?transposeA : bool, [<Optional>] ?transposeB : bool, [<Optional>] ?alpha : double, [<Optional>] ?beta : double, [<Optional>] ?axis : int) =
        LinalgGemm(?A = A, ?B = B, ?C = C, ?transposeA = transposeA, ?transposeB = transposeB, ?alpha = alpha, ?beta = beta, ?axis = axis)


    /// <summary>Performs general matrix multiplication.
    /// Input are tensors *A*, *B*, each of dimension *n &gt;= 2* and having the same shape
    /// on the leading *n-2* dimensions.
    /// 
    /// If *n=2*, the BLAS3 function *gemm* is performed:
    /// 
    ///    *out* = *alpha* \* *op*\ (*A*) \* *op*\ (*B*)
    /// 
    /// Here *alpha* is a scalar parameter and *op()* is either the identity or the matrix
    /// transposition (depending on *transpose_a*, *transpose_b*).
    /// 
    /// If *n&gt;2*, *gemm* is performed separately for a batch of matrices. The column indices of the matrices
    /// are given by the last dimensions of the tensors, the row indices by the axis specified with the *axis*
    /// parameter. By default, the trailing two dimensions will be used for matrix encoding.
    /// 
    /// For a non-default axis parameter, the operation performed is equivalent to a series of swapaxes/gemm/swapaxes
    /// calls. For example let *A*, *B* be 5 dimensional tensors. Then gemm(*A*, *B*, axis=1) is equivalent to
    /// the following without the overhead of the additional swapaxis operations::
    /// 
    ///     A1 = swapaxes(A, dim1=1, dim2=3)
    ///     B1 = swapaxes(B, dim1=1, dim2=3)
    ///     C = gemm2(A1, B1)
    ///     C = swapaxis(C, dim1=1, dim2=3)
    /// 
    /// When the input data is of type float32 and the environment variables MXNET_CUDA_ALLOW_TENSOR_CORE
    /// and MXNET_CUDA_TENSOR_OP_MATH_ALLOW_CONVERSION are set to 1, this operator will try to use
    /// pseudo-float16 precision (float32 math with float16 I/O) precision in order to use
    /// Tensor Cores on suitable NVIDIA GPUs. This can sometimes give significant speedups.
    /// 
    /// .. note:: The operator supports float32 and float64 data types only.
    /// 
    /// Examples::
    /// 
    ///    Single matrix multiply
    ///    A = [[1.0, 1.0], [1.0, 1.0]]
    ///    B = [[1.0, 1.0], [1.0, 1.0], [1.0, 1.0]]
    ///    gemm2(A, B, transpose_b=True, alpha=2.0)
    ///             = [[4.0, 4.0, 4.0], [4.0, 4.0, 4.0]]
    /// 
    ///    Batch matrix multiply
    ///    A = [[[1.0, 1.0]], [[0.1, 0.1]]]
    ///    B = [[[1.0, 1.0]], [[0.1, 0.1]]]
    ///    gemm2(A, B, transpose_b=True, alpha=2.0)
    ///            = [[[4.0]], [[0.04 ]]]
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\la_op.cc:L163</summary>
    /// <param name="A">Tensor of input matrices</param>
    /// <param name="B">Tensor of input matrices</param>
    /// <param name="transposeA">Multiply with transposed of first input (A).</param>
    /// <param name="transposeB">Multiply with transposed of second input (B).</param>
    /// <param name="alpha">Scalar factor multiplied with A*B.</param>
    /// <param name="axis">Axis corresponding to the matrix row indices.</param>
    static member LinalgGemm2(A : NDArray, 
                              B : NDArray, 
                              [<Optional; DefaultParameterValue(false)>] transposeA : bool, 
                              [<Optional; DefaultParameterValue(false)>] transposeB : bool, 
                              [<Optional; DefaultParameterValue(1.0)>] alpha : double, 
                              [<Optional; DefaultParameterValue(-2)>] axis : int) =
        let creator = AtomicSymbolCreator.FromName "_linalg_gemm2"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg A)) then A.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg B)) then B.UnsafeHandle|]
                                                 [|"transpose_a"; "transpose_b"; "alpha"; "axis"|]
                                                 [|string transposeA; string transposeB; string alpha; string axis|]
        (new NDArray(outputs.[0]))
    /// <summary>Performs general matrix multiplication.
    /// Input are tensors *A*, *B*, each of dimension *n &gt;= 2* and having the same shape
    /// on the leading *n-2* dimensions.
    /// 
    /// If *n=2*, the BLAS3 function *gemm* is performed:
    /// 
    ///    *out* = *alpha* \* *op*\ (*A*) \* *op*\ (*B*)
    /// 
    /// Here *alpha* is a scalar parameter and *op()* is either the identity or the matrix
    /// transposition (depending on *transpose_a*, *transpose_b*).
    /// 
    /// If *n&gt;2*, *gemm* is performed separately for a batch of matrices. The column indices of the matrices
    /// are given by the last dimensions of the tensors, the row indices by the axis specified with the *axis*
    /// parameter. By default, the trailing two dimensions will be used for matrix encoding.
    /// 
    /// For a non-default axis parameter, the operation performed is equivalent to a series of swapaxes/gemm/swapaxes
    /// calls. For example let *A*, *B* be 5 dimensional tensors. Then gemm(*A*, *B*, axis=1) is equivalent to
    /// the following without the overhead of the additional swapaxis operations::
    /// 
    ///     A1 = swapaxes(A, dim1=1, dim2=3)
    ///     B1 = swapaxes(B, dim1=1, dim2=3)
    ///     C = gemm2(A1, B1)
    ///     C = swapaxis(C, dim1=1, dim2=3)
    /// 
    /// When the input data is of type float32 and the environment variables MXNET_CUDA_ALLOW_TENSOR_CORE
    /// and MXNET_CUDA_TENSOR_OP_MATH_ALLOW_CONVERSION are set to 1, this operator will try to use
    /// pseudo-float16 precision (float32 math with float16 I/O) precision in order to use
    /// Tensor Cores on suitable NVIDIA GPUs. This can sometimes give significant speedups.
    /// 
    /// .. note:: The operator supports float32 and float64 data types only.
    /// 
    /// Examples::
    /// 
    ///    Single matrix multiply
    ///    A = [[1.0, 1.0], [1.0, 1.0]]
    ///    B = [[1.0, 1.0], [1.0, 1.0], [1.0, 1.0]]
    ///    gemm2(A, B, transpose_b=True, alpha=2.0)
    ///             = [[4.0, 4.0, 4.0], [4.0, 4.0, 4.0]]
    /// 
    ///    Batch matrix multiply
    ///    A = [[[1.0, 1.0]], [[0.1, 0.1]]]
    ///    B = [[[1.0, 1.0]], [[0.1, 0.1]]]
    ///    gemm2(A, B, transpose_b=True, alpha=2.0)
    ///            = [[[4.0]], [[0.04 ]]]
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\la_op.cc:L163</summary>
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="A">Tensor of input matrices</param>
    /// <param name="B">Tensor of input matrices</param>
    /// <param name="transposeA">Multiply with transposed of first input (A).</param>
    /// <param name="transposeB">Multiply with transposed of second input (B).</param>
    /// <param name="alpha">Scalar factor multiplied with A*B.</param>
    /// <param name="axis">Axis corresponding to the matrix row indices.</param>
    static member LinalgGemm2(outputArray : NDArray seq, 
                              A : NDArray, 
                              B : NDArray, 
                              [<Optional; DefaultParameterValue(false)>] transposeA : bool, 
                              [<Optional; DefaultParameterValue(false)>] transposeB : bool, 
                              [<Optional; DefaultParameterValue(1.0)>] alpha : double, 
                              [<Optional; DefaultParameterValue(-2)>] axis : int) =
        let creator = AtomicSymbolCreator.FromName "_linalg_gemm2"
        let names = [|"transpose_a"; "transpose_b"; "alpha"; "axis"|]
        let vals = [|string transposeA; string transposeB; string alpha; string axis|]
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg A)) then A.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg B)) then B.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <summary>Performs general matrix multiplication.
    /// Input are tensors *A*, *B*, each of dimension *n &gt;= 2* and having the same shape
    /// on the leading *n-2* dimensions.
    /// 
    /// If *n=2*, the BLAS3 function *gemm* is performed:
    /// 
    ///    *out* = *alpha* \* *op*\ (*A*) \* *op*\ (*B*)
    /// 
    /// Here *alpha* is a scalar parameter and *op()* is either the identity or the matrix
    /// transposition (depending on *transpose_a*, *transpose_b*).
    /// 
    /// If *n&gt;2*, *gemm* is performed separately for a batch of matrices. The column indices of the matrices
    /// are given by the last dimensions of the tensors, the row indices by the axis specified with the *axis*
    /// parameter. By default, the trailing two dimensions will be used for matrix encoding.
    /// 
    /// For a non-default axis parameter, the operation performed is equivalent to a series of swapaxes/gemm/swapaxes
    /// calls. For example let *A*, *B* be 5 dimensional tensors. Then gemm(*A*, *B*, axis=1) is equivalent to
    /// the following without the overhead of the additional swapaxis operations::
    /// 
    ///     A1 = swapaxes(A, dim1=1, dim2=3)
    ///     B1 = swapaxes(B, dim1=1, dim2=3)
    ///     C = gemm2(A1, B1)
    ///     C = swapaxis(C, dim1=1, dim2=3)
    /// 
    /// When the input data is of type float32 and the environment variables MXNET_CUDA_ALLOW_TENSOR_CORE
    /// and MXNET_CUDA_TENSOR_OP_MATH_ALLOW_CONVERSION are set to 1, this operator will try to use
    /// pseudo-float16 precision (float32 math with float16 I/O) precision in order to use
    /// Tensor Cores on suitable NVIDIA GPUs. This can sometimes give significant speedups.
    /// 
    /// .. note:: The operator supports float32 and float64 data types only.
    /// 
    /// Examples::
    /// 
    ///    Single matrix multiply
    ///    A = [[1.0, 1.0], [1.0, 1.0]]
    ///    B = [[1.0, 1.0], [1.0, 1.0], [1.0, 1.0]]
    ///    gemm2(A, B, transpose_b=True, alpha=2.0)
    ///             = [[4.0, 4.0, 4.0], [4.0, 4.0, 4.0]]
    /// 
    ///    Batch matrix multiply
    ///    A = [[[1.0, 1.0]], [[0.1, 0.1]]]
    ///    B = [[[1.0, 1.0]], [[0.1, 0.1]]]
    ///    gemm2(A, B, transpose_b=True, alpha=2.0)
    ///            = [[[4.0]], [[0.04 ]]]
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\la_op.cc:L163</summary>
    /// <param name="A">Tensor of input matrices</param>
    /// <param name="B">Tensor of input matrices</param>
    /// <param name="transposeA">Multiply with transposed of first input (A).</param>
    /// <param name="transposeB">Multiply with transposed of second input (B).</param>
    /// <param name="alpha">Scalar factor multiplied with A*B.</param>
    /// <param name="axis">Axis corresponding to the matrix row indices.</param>
    static member LinalgGemm2([<Optional>] ?A : Symbol, [<Optional>] ?B : Symbol, [<Optional>] ?transposeA : bool, [<Optional>] ?transposeB : bool, [<Optional>] ?alpha : double, [<Optional>] ?axis : int) =
        LinalgGemm2(?A = A, ?B = B, ?transposeA = transposeA, ?transposeB = transposeB, ?alpha = alpha, ?axis = axis)


    /// <summary>Performs Cholesky factorization of a symmetric positive-definite matrix.
    /// Input is a tensor *A* of dimension *n &gt;= 2*.
    /// 
    /// If *n=2*, the Cholesky factor *B* of the symmetric, positive definite matrix *A* is
    /// computed. *B* is triangular (entries of upper or lower triangle are all zero), has
    /// positive diagonal entries, and:
    /// 
    ///   *A* = *B* \* *B*\ :sup:`T`  if *lower* = *true*
    ///   *A* = *B*\ :sup:`T` \* *B*  if *lower* = *false*
    /// 
    /// If *n&gt;2*, *potrf* is performed separately on the trailing two dimensions for all inputs
    /// (batch mode).
    /// 
    /// .. note:: The operator supports float32 and float64 data types only.
    /// 
    /// Examples::
    /// 
    ///    Single matrix factorization
    ///    A = [[4.0, 1.0], [1.0, 4.25]]
    ///    potrf(A) = [[2.0, 0], [0.5, 2.0]]
    /// 
    ///    Batch matrix factorization
    ///    A = [[[4.0, 1.0], [1.0, 4.25]], [[16.0, 4.0], [4.0, 17.0]]]
    ///    potrf(A) = [[[2.0, 0], [0.5, 2.0]], [[4.0, 0], [1.0, 4.0]]]
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\la_op.cc:L214</summary>
    /// <param name="A">Tensor of input matrices to be decomposed</param>
    static member LinalgPotrf(A : NDArray) =
        let creator = AtomicSymbolCreator.FromName "_linalg_potrf"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg A)) then A.UnsafeHandle|]
                                                 Array.empty
                                                 Array.empty
        (new NDArray(outputs.[0]))
    /// <summary>Performs Cholesky factorization of a symmetric positive-definite matrix.
    /// Input is a tensor *A* of dimension *n &gt;= 2*.
    /// 
    /// If *n=2*, the Cholesky factor *B* of the symmetric, positive definite matrix *A* is
    /// computed. *B* is triangular (entries of upper or lower triangle are all zero), has
    /// positive diagonal entries, and:
    /// 
    ///   *A* = *B* \* *B*\ :sup:`T`  if *lower* = *true*
    ///   *A* = *B*\ :sup:`T` \* *B*  if *lower* = *false*
    /// 
    /// If *n&gt;2*, *potrf* is performed separately on the trailing two dimensions for all inputs
    /// (batch mode).
    /// 
    /// .. note:: The operator supports float32 and float64 data types only.
    /// 
    /// Examples::
    /// 
    ///    Single matrix factorization
    ///    A = [[4.0, 1.0], [1.0, 4.25]]
    ///    potrf(A) = [[2.0, 0], [0.5, 2.0]]
    /// 
    ///    Batch matrix factorization
    ///    A = [[[4.0, 1.0], [1.0, 4.25]], [[16.0, 4.0], [4.0, 17.0]]]
    ///    potrf(A) = [[[2.0, 0], [0.5, 2.0]], [[4.0, 0], [1.0, 4.0]]]
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\la_op.cc:L214</summary>
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="A">Tensor of input matrices to be decomposed</param>
    static member LinalgPotrf(outputArray : NDArray seq, A : NDArray) =
        let creator = AtomicSymbolCreator.FromName "_linalg_potrf"
        let names = Array.empty
        let vals = Array.empty
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg A)) then A.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <summary>Performs Cholesky factorization of a symmetric positive-definite matrix.
    /// Input is a tensor *A* of dimension *n &gt;= 2*.
    /// 
    /// If *n=2*, the Cholesky factor *B* of the symmetric, positive definite matrix *A* is
    /// computed. *B* is triangular (entries of upper or lower triangle are all zero), has
    /// positive diagonal entries, and:
    /// 
    ///   *A* = *B* \* *B*\ :sup:`T`  if *lower* = *true*
    ///   *A* = *B*\ :sup:`T` \* *B*  if *lower* = *false*
    /// 
    /// If *n&gt;2*, *potrf* is performed separately on the trailing two dimensions for all inputs
    /// (batch mode).
    /// 
    /// .. note:: The operator supports float32 and float64 data types only.
    /// 
    /// Examples::
    /// 
    ///    Single matrix factorization
    ///    A = [[4.0, 1.0], [1.0, 4.25]]
    ///    potrf(A) = [[2.0, 0], [0.5, 2.0]]
    /// 
    ///    Batch matrix factorization
    ///    A = [[[4.0, 1.0], [1.0, 4.25]], [[16.0, 4.0], [4.0, 17.0]]]
    ///    potrf(A) = [[[2.0, 0], [0.5, 2.0]], [[4.0, 0], [1.0, 4.0]]]
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\la_op.cc:L214</summary>
    /// <param name="A">Tensor of input matrices to be decomposed</param>
    static member LinalgPotrf([<Optional>] ?A : Symbol) =
        LinalgPotrf(?A = A)


    /// <summary>Performs matrix inversion from a Cholesky factorization.
    /// Input is a tensor *A* of dimension *n &gt;= 2*.
    /// 
    /// If *n=2*, *A* is a triangular matrix (entries of upper or lower triangle are all zero)
    /// with positive diagonal. We compute:
    /// 
    ///   *out* = *A*\ :sup:`-T` \* *A*\ :sup:`-1` if *lower* = *true*
    ///   *out* = *A*\ :sup:`-1` \* *A*\ :sup:`-T` if *lower* = *false*
    /// 
    /// In other words, if *A* is the Cholesky factor of a symmetric positive definite matrix
    /// *B* (obtained by *potrf*), then
    /// 
    ///   *out* = *B*\ :sup:`-1`
    /// 
    /// If *n&gt;2*, *potri* is performed separately on the trailing two dimensions for all inputs
    /// (batch mode).
    /// 
    /// .. note:: The operator supports float32 and float64 data types only.
    /// 
    /// .. note:: Use this operator only if you are certain you need the inverse of *B*, and
    ///           cannot use the Cholesky factor *A* (*potrf*), together with backsubstitution
    ///           (*trsm*). The latter is numerically much safer, and also cheaper.
    /// 
    /// Examples::
    /// 
    ///    Single matrix inverse
    ///    A = [[2.0, 0], [0.5, 2.0]]
    ///    potri(A) = [[0.26563, -0.0625], [-0.0625, 0.25]]
    /// 
    ///    Batch matrix inverse
    ///    A = [[[2.0, 0], [0.5, 2.0]], [[4.0, 0], [1.0, 4.0]]]
    ///    potri(A) = [[[0.26563, -0.0625], [-0.0625, 0.25]],
    ///                [[0.06641, -0.01562], [-0.01562, 0,0625]]]
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\la_op.cc:L275</summary>
    /// <param name="A">Tensor of lower triangular matrices</param>
    static member LinalgPotri(A : NDArray) =
        let creator = AtomicSymbolCreator.FromName "_linalg_potri"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg A)) then A.UnsafeHandle|]
                                                 Array.empty
                                                 Array.empty
        (new NDArray(outputs.[0]))
    /// <summary>Performs matrix inversion from a Cholesky factorization.
    /// Input is a tensor *A* of dimension *n &gt;= 2*.
    /// 
    /// If *n=2*, *A* is a triangular matrix (entries of upper or lower triangle are all zero)
    /// with positive diagonal. We compute:
    /// 
    ///   *out* = *A*\ :sup:`-T` \* *A*\ :sup:`-1` if *lower* = *true*
    ///   *out* = *A*\ :sup:`-1` \* *A*\ :sup:`-T` if *lower* = *false*
    /// 
    /// In other words, if *A* is the Cholesky factor of a symmetric positive definite matrix
    /// *B* (obtained by *potrf*), then
    /// 
    ///   *out* = *B*\ :sup:`-1`
    /// 
    /// If *n&gt;2*, *potri* is performed separately on the trailing two dimensions for all inputs
    /// (batch mode).
    /// 
    /// .. note:: The operator supports float32 and float64 data types only.
    /// 
    /// .. note:: Use this operator only if you are certain you need the inverse of *B*, and
    ///           cannot use the Cholesky factor *A* (*potrf*), together with backsubstitution
    ///           (*trsm*). The latter is numerically much safer, and also cheaper.
    /// 
    /// Examples::
    /// 
    ///    Single matrix inverse
    ///    A = [[2.0, 0], [0.5, 2.0]]
    ///    potri(A) = [[0.26563, -0.0625], [-0.0625, 0.25]]
    /// 
    ///    Batch matrix inverse
    ///    A = [[[2.0, 0], [0.5, 2.0]], [[4.0, 0], [1.0, 4.0]]]
    ///    potri(A) = [[[0.26563, -0.0625], [-0.0625, 0.25]],
    ///                [[0.06641, -0.01562], [-0.01562, 0,0625]]]
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\la_op.cc:L275</summary>
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="A">Tensor of lower triangular matrices</param>
    static member LinalgPotri(outputArray : NDArray seq, A : NDArray) =
        let creator = AtomicSymbolCreator.FromName "_linalg_potri"
        let names = Array.empty
        let vals = Array.empty
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg A)) then A.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <summary>Performs matrix inversion from a Cholesky factorization.
    /// Input is a tensor *A* of dimension *n &gt;= 2*.
    /// 
    /// If *n=2*, *A* is a triangular matrix (entries of upper or lower triangle are all zero)
    /// with positive diagonal. We compute:
    /// 
    ///   *out* = *A*\ :sup:`-T` \* *A*\ :sup:`-1` if *lower* = *true*
    ///   *out* = *A*\ :sup:`-1` \* *A*\ :sup:`-T` if *lower* = *false*
    /// 
    /// In other words, if *A* is the Cholesky factor of a symmetric positive definite matrix
    /// *B* (obtained by *potrf*), then
    /// 
    ///   *out* = *B*\ :sup:`-1`
    /// 
    /// If *n&gt;2*, *potri* is performed separately on the trailing two dimensions for all inputs
    /// (batch mode).
    /// 
    /// .. note:: The operator supports float32 and float64 data types only.
    /// 
    /// .. note:: Use this operator only if you are certain you need the inverse of *B*, and
    ///           cannot use the Cholesky factor *A* (*potrf*), together with backsubstitution
    ///           (*trsm*). The latter is numerically much safer, and also cheaper.
    /// 
    /// Examples::
    /// 
    ///    Single matrix inverse
    ///    A = [[2.0, 0], [0.5, 2.0]]
    ///    potri(A) = [[0.26563, -0.0625], [-0.0625, 0.25]]
    /// 
    ///    Batch matrix inverse
    ///    A = [[[2.0, 0], [0.5, 2.0]], [[4.0, 0], [1.0, 4.0]]]
    ///    potri(A) = [[[0.26563, -0.0625], [-0.0625, 0.25]],
    ///                [[0.06641, -0.01562], [-0.01562, 0,0625]]]
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\la_op.cc:L275</summary>
    /// <param name="A">Tensor of lower triangular matrices</param>
    static member LinalgPotri([<Optional>] ?A : Symbol) =
        LinalgPotri(?A = A)


    /// <summary>Performs multiplication with a lower triangular matrix.
    /// Input are tensors *A*, *B*, each of dimension *n &gt;= 2* and having the same shape
    /// on the leading *n-2* dimensions.
    /// 
    /// If *n=2*, *A* must be triangular. The operator performs the BLAS3 function
    /// *trmm*:
    /// 
    ///    *out* = *alpha* \* *op*\ (*A*) \* *B*
    /// 
    /// if *rightside=False*, or
    /// 
    ///    *out* = *alpha* \* *B* \* *op*\ (*A*)
    /// 
    /// if *rightside=True*. Here, *alpha* is a scalar parameter, and *op()* is either the
    /// identity or the matrix transposition (depending on *transpose*).
    /// 
    /// If *n&gt;2*, *trmm* is performed separately on the trailing two dimensions for all inputs
    /// (batch mode).
    /// 
    /// .. note:: The operator supports float32 and float64 data types only.
    /// 
    /// Examples::
    /// 
    ///    Single triangular matrix multiply
    ///    A = [[1.0, 0], [1.0, 1.0]]
    ///    B = [[1.0, 1.0, 1.0], [1.0, 1.0, 1.0]]
    ///    trmm(A, B, alpha=2.0) = [[2.0, 2.0, 2.0], [4.0, 4.0, 4.0]]
    /// 
    ///    Batch triangular matrix multiply
    ///    A = [[[1.0, 0], [1.0, 1.0]], [[1.0, 0], [1.0, 1.0]]]
    ///    B = [[[1.0, 1.0, 1.0], [1.0, 1.0, 1.0]], [[0.5, 0.5, 0.5], [0.5, 0.5, 0.5]]]
    ///    trmm(A, B, alpha=2.0) = [[[2.0, 2.0, 2.0], [4.0, 4.0, 4.0]],
    ///                             [[1.0, 1.0, 1.0], [2.0, 2.0, 2.0]]]
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\la_op.cc:L333</summary>
    /// <param name="A">Tensor of lower triangular matrices</param>
    /// <param name="B">Tensor of matrices</param>
    /// <param name="transpose">Use transposed of the triangular matrix</param>
    /// <param name="rightside">Multiply triangular matrix from the right to non-triangular one.</param>
    /// <param name="lower">True if the triangular matrix is lower triangular, false if it is upper triangular.</param>
    /// <param name="alpha">Scalar factor to be applied to the result.</param>
    static member LinalgTrmm(A : NDArray, 
                             B : NDArray, 
                             [<Optional; DefaultParameterValue(false)>] transpose : bool, 
                             [<Optional; DefaultParameterValue(false)>] rightside : bool, 
                             [<Optional; DefaultParameterValue(true)>] lower : bool, 
                             [<Optional; DefaultParameterValue(1.0)>] alpha : double) =
        let creator = AtomicSymbolCreator.FromName "_linalg_trmm"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg A)) then A.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg B)) then B.UnsafeHandle|]
                                                 [|"transpose"; "rightside"; "lower"; "alpha"|]
                                                 [|string transpose; string rightside; string lower; string alpha|]
        (new NDArray(outputs.[0]))
    /// <summary>Performs multiplication with a lower triangular matrix.
    /// Input are tensors *A*, *B*, each of dimension *n &gt;= 2* and having the same shape
    /// on the leading *n-2* dimensions.
    /// 
    /// If *n=2*, *A* must be triangular. The operator performs the BLAS3 function
    /// *trmm*:
    /// 
    ///    *out* = *alpha* \* *op*\ (*A*) \* *B*
    /// 
    /// if *rightside=False*, or
    /// 
    ///    *out* = *alpha* \* *B* \* *op*\ (*A*)
    /// 
    /// if *rightside=True*. Here, *alpha* is a scalar parameter, and *op()* is either the
    /// identity or the matrix transposition (depending on *transpose*).
    /// 
    /// If *n&gt;2*, *trmm* is performed separately on the trailing two dimensions for all inputs
    /// (batch mode).
    /// 
    /// .. note:: The operator supports float32 and float64 data types only.
    /// 
    /// Examples::
    /// 
    ///    Single triangular matrix multiply
    ///    A = [[1.0, 0], [1.0, 1.0]]
    ///    B = [[1.0, 1.0, 1.0], [1.0, 1.0, 1.0]]
    ///    trmm(A, B, alpha=2.0) = [[2.0, 2.0, 2.0], [4.0, 4.0, 4.0]]
    /// 
    ///    Batch triangular matrix multiply
    ///    A = [[[1.0, 0], [1.0, 1.0]], [[1.0, 0], [1.0, 1.0]]]
    ///    B = [[[1.0, 1.0, 1.0], [1.0, 1.0, 1.0]], [[0.5, 0.5, 0.5], [0.5, 0.5, 0.5]]]
    ///    trmm(A, B, alpha=2.0) = [[[2.0, 2.0, 2.0], [4.0, 4.0, 4.0]],
    ///                             [[1.0, 1.0, 1.0], [2.0, 2.0, 2.0]]]
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\la_op.cc:L333</summary>
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="A">Tensor of lower triangular matrices</param>
    /// <param name="B">Tensor of matrices</param>
    /// <param name="transpose">Use transposed of the triangular matrix</param>
    /// <param name="rightside">Multiply triangular matrix from the right to non-triangular one.</param>
    /// <param name="lower">True if the triangular matrix is lower triangular, false if it is upper triangular.</param>
    /// <param name="alpha">Scalar factor to be applied to the result.</param>
    static member LinalgTrmm(outputArray : NDArray seq, 
                             A : NDArray, 
                             B : NDArray, 
                             [<Optional; DefaultParameterValue(false)>] transpose : bool, 
                             [<Optional; DefaultParameterValue(false)>] rightside : bool, 
                             [<Optional; DefaultParameterValue(true)>] lower : bool, 
                             [<Optional; DefaultParameterValue(1.0)>] alpha : double) =
        let creator = AtomicSymbolCreator.FromName "_linalg_trmm"
        let names = [|"transpose"; "rightside"; "lower"; "alpha"|]
        let vals = [|string transpose; string rightside; string lower; string alpha|]
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg A)) then A.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg B)) then B.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <summary>Performs multiplication with a lower triangular matrix.
    /// Input are tensors *A*, *B*, each of dimension *n &gt;= 2* and having the same shape
    /// on the leading *n-2* dimensions.
    /// 
    /// If *n=2*, *A* must be triangular. The operator performs the BLAS3 function
    /// *trmm*:
    /// 
    ///    *out* = *alpha* \* *op*\ (*A*) \* *B*
    /// 
    /// if *rightside=False*, or
    /// 
    ///    *out* = *alpha* \* *B* \* *op*\ (*A*)
    /// 
    /// if *rightside=True*. Here, *alpha* is a scalar parameter, and *op()* is either the
    /// identity or the matrix transposition (depending on *transpose*).
    /// 
    /// If *n&gt;2*, *trmm* is performed separately on the trailing two dimensions for all inputs
    /// (batch mode).
    /// 
    /// .. note:: The operator supports float32 and float64 data types only.
    /// 
    /// Examples::
    /// 
    ///    Single triangular matrix multiply
    ///    A = [[1.0, 0], [1.0, 1.0]]
    ///    B = [[1.0, 1.0, 1.0], [1.0, 1.0, 1.0]]
    ///    trmm(A, B, alpha=2.0) = [[2.0, 2.0, 2.0], [4.0, 4.0, 4.0]]
    /// 
    ///    Batch triangular matrix multiply
    ///    A = [[[1.0, 0], [1.0, 1.0]], [[1.0, 0], [1.0, 1.0]]]
    ///    B = [[[1.0, 1.0, 1.0], [1.0, 1.0, 1.0]], [[0.5, 0.5, 0.5], [0.5, 0.5, 0.5]]]
    ///    trmm(A, B, alpha=2.0) = [[[2.0, 2.0, 2.0], [4.0, 4.0, 4.0]],
    ///                             [[1.0, 1.0, 1.0], [2.0, 2.0, 2.0]]]
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\la_op.cc:L333</summary>
    /// <param name="A">Tensor of lower triangular matrices</param>
    /// <param name="B">Tensor of matrices</param>
    /// <param name="transpose">Use transposed of the triangular matrix</param>
    /// <param name="rightside">Multiply triangular matrix from the right to non-triangular one.</param>
    /// <param name="lower">True if the triangular matrix is lower triangular, false if it is upper triangular.</param>
    /// <param name="alpha">Scalar factor to be applied to the result.</param>
    static member LinalgTrmm([<Optional>] ?A : Symbol, [<Optional>] ?B : Symbol, [<Optional>] ?transpose : bool, [<Optional>] ?rightside : bool, [<Optional>] ?lower : bool, [<Optional>] ?alpha : double) =
        LinalgTrmm(?A = A, ?B = B, ?transpose = transpose, ?rightside = rightside, ?lower = lower, ?alpha = alpha)


    /// <summary>Solves matrix equation involving a lower triangular matrix.
    /// Input are tensors *A*, *B*, each of dimension *n &gt;= 2* and having the same shape
    /// on the leading *n-2* dimensions.
    /// 
    /// If *n=2*, *A* must be triangular. The operator performs the BLAS3 function
    /// *trsm*, solving for *out* in:
    /// 
    ///    *op*\ (*A*) \* *out* = *alpha* \* *B*
    /// 
    /// if *rightside=False*, or
    /// 
    ///    *out* \* *op*\ (*A*) = *alpha* \* *B*
    /// 
    /// if *rightside=True*. Here, *alpha* is a scalar parameter, and *op()* is either the
    /// identity or the matrix transposition (depending on *transpose*).
    /// 
    /// If *n&gt;2*, *trsm* is performed separately on the trailing two dimensions for all inputs
    /// (batch mode).
    /// 
    /// .. note:: The operator supports float32 and float64 data types only.
    /// 
    /// Examples::
    /// 
    ///    Single matrix solve
    ///    A = [[1.0, 0], [1.0, 1.0]]
    ///    B = [[2.0, 2.0, 2.0], [4.0, 4.0, 4.0]]
    ///    trsm(A, B, alpha=0.5) = [[1.0, 1.0, 1.0], [1.0, 1.0, 1.0]]
    /// 
    ///    Batch matrix solve
    ///    A = [[[1.0, 0], [1.0, 1.0]], [[1.0, 0], [1.0, 1.0]]]
    ///    B = [[[2.0, 2.0, 2.0], [4.0, 4.0, 4.0]],
    ///         [[4.0, 4.0, 4.0], [8.0, 8.0, 8.0]]]
    ///    trsm(A, B, alpha=0.5) = [[[1.0, 1.0, 1.0], [1.0, 1.0, 1.0]],
    ///                             [[2.0, 2.0, 2.0], [2.0, 2.0, 2.0]]]
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\la_op.cc:L396</summary>
    /// <param name="A">Tensor of lower triangular matrices</param>
    /// <param name="B">Tensor of matrices</param>
    /// <param name="transpose">Use transposed of the triangular matrix</param>
    /// <param name="rightside">Multiply triangular matrix from the right to non-triangular one.</param>
    /// <param name="lower">True if the triangular matrix is lower triangular, false if it is upper triangular.</param>
    /// <param name="alpha">Scalar factor to be applied to the result.</param>
    static member LinalgTrsm(A : NDArray, 
                             B : NDArray, 
                             [<Optional; DefaultParameterValue(false)>] transpose : bool, 
                             [<Optional; DefaultParameterValue(false)>] rightside : bool, 
                             [<Optional; DefaultParameterValue(true)>] lower : bool, 
                             [<Optional; DefaultParameterValue(1.0)>] alpha : double) =
        let creator = AtomicSymbolCreator.FromName "_linalg_trsm"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg A)) then A.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg B)) then B.UnsafeHandle|]
                                                 [|"transpose"; "rightside"; "lower"; "alpha"|]
                                                 [|string transpose; string rightside; string lower; string alpha|]
        (new NDArray(outputs.[0]))
    /// <summary>Solves matrix equation involving a lower triangular matrix.
    /// Input are tensors *A*, *B*, each of dimension *n &gt;= 2* and having the same shape
    /// on the leading *n-2* dimensions.
    /// 
    /// If *n=2*, *A* must be triangular. The operator performs the BLAS3 function
    /// *trsm*, solving for *out* in:
    /// 
    ///    *op*\ (*A*) \* *out* = *alpha* \* *B*
    /// 
    /// if *rightside=False*, or
    /// 
    ///    *out* \* *op*\ (*A*) = *alpha* \* *B*
    /// 
    /// if *rightside=True*. Here, *alpha* is a scalar parameter, and *op()* is either the
    /// identity or the matrix transposition (depending on *transpose*).
    /// 
    /// If *n&gt;2*, *trsm* is performed separately on the trailing two dimensions for all inputs
    /// (batch mode).
    /// 
    /// .. note:: The operator supports float32 and float64 data types only.
    /// 
    /// Examples::
    /// 
    ///    Single matrix solve
    ///    A = [[1.0, 0], [1.0, 1.0]]
    ///    B = [[2.0, 2.0, 2.0], [4.0, 4.0, 4.0]]
    ///    trsm(A, B, alpha=0.5) = [[1.0, 1.0, 1.0], [1.0, 1.0, 1.0]]
    /// 
    ///    Batch matrix solve
    ///    A = [[[1.0, 0], [1.0, 1.0]], [[1.0, 0], [1.0, 1.0]]]
    ///    B = [[[2.0, 2.0, 2.0], [4.0, 4.0, 4.0]],
    ///         [[4.0, 4.0, 4.0], [8.0, 8.0, 8.0]]]
    ///    trsm(A, B, alpha=0.5) = [[[1.0, 1.0, 1.0], [1.0, 1.0, 1.0]],
    ///                             [[2.0, 2.0, 2.0], [2.0, 2.0, 2.0]]]
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\la_op.cc:L396</summary>
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="A">Tensor of lower triangular matrices</param>
    /// <param name="B">Tensor of matrices</param>
    /// <param name="transpose">Use transposed of the triangular matrix</param>
    /// <param name="rightside">Multiply triangular matrix from the right to non-triangular one.</param>
    /// <param name="lower">True if the triangular matrix is lower triangular, false if it is upper triangular.</param>
    /// <param name="alpha">Scalar factor to be applied to the result.</param>
    static member LinalgTrsm(outputArray : NDArray seq, 
                             A : NDArray, 
                             B : NDArray, 
                             [<Optional; DefaultParameterValue(false)>] transpose : bool, 
                             [<Optional; DefaultParameterValue(false)>] rightside : bool, 
                             [<Optional; DefaultParameterValue(true)>] lower : bool, 
                             [<Optional; DefaultParameterValue(1.0)>] alpha : double) =
        let creator = AtomicSymbolCreator.FromName "_linalg_trsm"
        let names = [|"transpose"; "rightside"; "lower"; "alpha"|]
        let vals = [|string transpose; string rightside; string lower; string alpha|]
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg A)) then A.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg B)) then B.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <summary>Solves matrix equation involving a lower triangular matrix.
    /// Input are tensors *A*, *B*, each of dimension *n &gt;= 2* and having the same shape
    /// on the leading *n-2* dimensions.
    /// 
    /// If *n=2*, *A* must be triangular. The operator performs the BLAS3 function
    /// *trsm*, solving for *out* in:
    /// 
    ///    *op*\ (*A*) \* *out* = *alpha* \* *B*
    /// 
    /// if *rightside=False*, or
    /// 
    ///    *out* \* *op*\ (*A*) = *alpha* \* *B*
    /// 
    /// if *rightside=True*. Here, *alpha* is a scalar parameter, and *op()* is either the
    /// identity or the matrix transposition (depending on *transpose*).
    /// 
    /// If *n&gt;2*, *trsm* is performed separately on the trailing two dimensions for all inputs
    /// (batch mode).
    /// 
    /// .. note:: The operator supports float32 and float64 data types only.
    /// 
    /// Examples::
    /// 
    ///    Single matrix solve
    ///    A = [[1.0, 0], [1.0, 1.0]]
    ///    B = [[2.0, 2.0, 2.0], [4.0, 4.0, 4.0]]
    ///    trsm(A, B, alpha=0.5) = [[1.0, 1.0, 1.0], [1.0, 1.0, 1.0]]
    /// 
    ///    Batch matrix solve
    ///    A = [[[1.0, 0], [1.0, 1.0]], [[1.0, 0], [1.0, 1.0]]]
    ///    B = [[[2.0, 2.0, 2.0], [4.0, 4.0, 4.0]],
    ///         [[4.0, 4.0, 4.0], [8.0, 8.0, 8.0]]]
    ///    trsm(A, B, alpha=0.5) = [[[1.0, 1.0, 1.0], [1.0, 1.0, 1.0]],
    ///                             [[2.0, 2.0, 2.0], [2.0, 2.0, 2.0]]]
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\la_op.cc:L396</summary>
    /// <param name="A">Tensor of lower triangular matrices</param>
    /// <param name="B">Tensor of matrices</param>
    /// <param name="transpose">Use transposed of the triangular matrix</param>
    /// <param name="rightside">Multiply triangular matrix from the right to non-triangular one.</param>
    /// <param name="lower">True if the triangular matrix is lower triangular, false if it is upper triangular.</param>
    /// <param name="alpha">Scalar factor to be applied to the result.</param>
    static member LinalgTrsm([<Optional>] ?A : Symbol, [<Optional>] ?B : Symbol, [<Optional>] ?transpose : bool, [<Optional>] ?rightside : bool, [<Optional>] ?lower : bool, [<Optional>] ?alpha : double) =
        LinalgTrsm(?A = A, ?B = B, ?transpose = transpose, ?rightside = rightside, ?lower = lower, ?alpha = alpha)


    /// <summary>Computes the sum of the logarithms of the diagonal elements of a square matrix.
    /// Input is a tensor *A* of dimension *n &gt;= 2*.
    /// 
    /// If *n=2*, *A* must be square with positive diagonal entries. We sum the natural
    /// logarithms of the diagonal elements, the result has shape (1,).
    /// 
    /// If *n&gt;2*, *sumlogdiag* is performed separately on the trailing two dimensions for all
    /// inputs (batch mode).
    /// 
    /// .. note:: The operator supports float32 and float64 data types only.
    /// 
    /// Examples::
    /// 
    ///    Single matrix reduction
    ///    A = [[1.0, 1.0], [1.0, 7.0]]
    ///    sumlogdiag(A) = [1.9459]
    /// 
    ///    Batch matrix reduction
    ///    A = [[[1.0, 1.0], [1.0, 7.0]], [[3.0, 0], [0, 17.0]]]
    ///    sumlogdiag(A) = [1.9459, 3.9318]
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\la_op.cc:L445</summary>
    /// <param name="A">Tensor of square matrices</param>
    static member LinalgSumlogdiag(A : NDArray) =
        let creator = AtomicSymbolCreator.FromName "_linalg_sumlogdiag"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg A)) then A.UnsafeHandle|]
                                                 Array.empty
                                                 Array.empty
        (new NDArray(outputs.[0]))
    /// <summary>Computes the sum of the logarithms of the diagonal elements of a square matrix.
    /// Input is a tensor *A* of dimension *n &gt;= 2*.
    /// 
    /// If *n=2*, *A* must be square with positive diagonal entries. We sum the natural
    /// logarithms of the diagonal elements, the result has shape (1,).
    /// 
    /// If *n&gt;2*, *sumlogdiag* is performed separately on the trailing two dimensions for all
    /// inputs (batch mode).
    /// 
    /// .. note:: The operator supports float32 and float64 data types only.
    /// 
    /// Examples::
    /// 
    ///    Single matrix reduction
    ///    A = [[1.0, 1.0], [1.0, 7.0]]
    ///    sumlogdiag(A) = [1.9459]
    /// 
    ///    Batch matrix reduction
    ///    A = [[[1.0, 1.0], [1.0, 7.0]], [[3.0, 0], [0, 17.0]]]
    ///    sumlogdiag(A) = [1.9459, 3.9318]
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\la_op.cc:L445</summary>
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="A">Tensor of square matrices</param>
    static member LinalgSumlogdiag(outputArray : NDArray seq, A : NDArray) =
        let creator = AtomicSymbolCreator.FromName "_linalg_sumlogdiag"
        let names = Array.empty
        let vals = Array.empty
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg A)) then A.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <summary>Computes the sum of the logarithms of the diagonal elements of a square matrix.
    /// Input is a tensor *A* of dimension *n &gt;= 2*.
    /// 
    /// If *n=2*, *A* must be square with positive diagonal entries. We sum the natural
    /// logarithms of the diagonal elements, the result has shape (1,).
    /// 
    /// If *n&gt;2*, *sumlogdiag* is performed separately on the trailing two dimensions for all
    /// inputs (batch mode).
    /// 
    /// .. note:: The operator supports float32 and float64 data types only.
    /// 
    /// Examples::
    /// 
    ///    Single matrix reduction
    ///    A = [[1.0, 1.0], [1.0, 7.0]]
    ///    sumlogdiag(A) = [1.9459]
    /// 
    ///    Batch matrix reduction
    ///    A = [[[1.0, 1.0], [1.0, 7.0]], [[3.0, 0], [0, 17.0]]]
    ///    sumlogdiag(A) = [1.9459, 3.9318]
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\la_op.cc:L445</summary>
    /// <param name="A">Tensor of square matrices</param>
    static member LinalgSumlogdiag([<Optional>] ?A : Symbol) =
        LinalgSumlogdiag(?A = A)


    /// <summary>Extracts the diagonal entries of a square matrix.
    /// Input is a tensor *A* of dimension *n &gt;= 2*.
    /// 
    /// If *n=2*, then *A* represents a single square matrix which diagonal elements get extracted as a 1-dimensional tensor.
    /// 
    /// If *n&gt;2*, then *A* represents a batch of square matrices on the trailing two dimensions. The extracted diagonals are returned as an *n-1*-dimensional tensor.
    /// 
    /// .. note:: The operator supports float32 and float64 data types only.
    /// 
    /// Examples::
    /// 
    ///     Single matrix diagonal extraction
    ///     A = [[1.0, 2.0],
    ///          [3.0, 4.0]]
    /// 
    ///     extractdiag(A) = [1.0, 4.0]
    /// 
    ///     extractdiag(A, 1) = [2.0]
    /// 
    ///     Batch matrix diagonal extraction
    ///     A = [[[1.0, 2.0],
    ///           [3.0, 4.0]],
    ///          [[5.0, 6.0],
    ///           [7.0, 8.0]]]
    /// 
    ///     extractdiag(A) = [[1.0, 4.0],
    ///                       [5.0, 8.0]]
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\la_op.cc:L495</summary>
    /// <param name="A">Tensor of square matrices</param>
    /// <param name="offset">Offset of the diagonal versus the main diagonal. 0 corresponds to the main diagonal, a negative/positive value to diagonals below/above the main diagonal.</param>
    static member LinalgExtractdiag(A : NDArray, [<Optional; DefaultParameterValue(0)>] offset : int) =
        let creator = AtomicSymbolCreator.FromName "_linalg_extractdiag"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg A)) then A.UnsafeHandle|]
                                                 [|"offset"|]
                                                 [|string offset|]
        (new NDArray(outputs.[0]))
    /// <summary>Extracts the diagonal entries of a square matrix.
    /// Input is a tensor *A* of dimension *n &gt;= 2*.
    /// 
    /// If *n=2*, then *A* represents a single square matrix which diagonal elements get extracted as a 1-dimensional tensor.
    /// 
    /// If *n&gt;2*, then *A* represents a batch of square matrices on the trailing two dimensions. The extracted diagonals are returned as an *n-1*-dimensional tensor.
    /// 
    /// .. note:: The operator supports float32 and float64 data types only.
    /// 
    /// Examples::
    /// 
    ///     Single matrix diagonal extraction
    ///     A = [[1.0, 2.0],
    ///          [3.0, 4.0]]
    /// 
    ///     extractdiag(A) = [1.0, 4.0]
    /// 
    ///     extractdiag(A, 1) = [2.0]
    /// 
    ///     Batch matrix diagonal extraction
    ///     A = [[[1.0, 2.0],
    ///           [3.0, 4.0]],
    ///          [[5.0, 6.0],
    ///           [7.0, 8.0]]]
    /// 
    ///     extractdiag(A) = [[1.0, 4.0],
    ///                       [5.0, 8.0]]
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\la_op.cc:L495</summary>
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="A">Tensor of square matrices</param>
    /// <param name="offset">Offset of the diagonal versus the main diagonal. 0 corresponds to the main diagonal, a negative/positive value to diagonals below/above the main diagonal.</param>
    static member LinalgExtractdiag(outputArray : NDArray seq, A : NDArray, [<Optional; DefaultParameterValue(0)>] offset : int) =
        let creator = AtomicSymbolCreator.FromName "_linalg_extractdiag"
        let names = [|"offset"|]
        let vals = [|string offset|]
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg A)) then A.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <summary>Extracts the diagonal entries of a square matrix.
    /// Input is a tensor *A* of dimension *n &gt;= 2*.
    /// 
    /// If *n=2*, then *A* represents a single square matrix which diagonal elements get extracted as a 1-dimensional tensor.
    /// 
    /// If *n&gt;2*, then *A* represents a batch of square matrices on the trailing two dimensions. The extracted diagonals are returned as an *n-1*-dimensional tensor.
    /// 
    /// .. note:: The operator supports float32 and float64 data types only.
    /// 
    /// Examples::
    /// 
    ///     Single matrix diagonal extraction
    ///     A = [[1.0, 2.0],
    ///          [3.0, 4.0]]
    /// 
    ///     extractdiag(A) = [1.0, 4.0]
    /// 
    ///     extractdiag(A, 1) = [2.0]
    /// 
    ///     Batch matrix diagonal extraction
    ///     A = [[[1.0, 2.0],
    ///           [3.0, 4.0]],
    ///          [[5.0, 6.0],
    ///           [7.0, 8.0]]]
    /// 
    ///     extractdiag(A) = [[1.0, 4.0],
    ///                       [5.0, 8.0]]
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\la_op.cc:L495</summary>
    /// <param name="A">Tensor of square matrices</param>
    /// <param name="offset">Offset of the diagonal versus the main diagonal. 0 corresponds to the main diagonal, a negative/positive value to diagonals below/above the main diagonal.</param>
    static member LinalgExtractdiag([<Optional>] ?A : Symbol, [<Optional>] ?offset : int) =
        LinalgExtractdiag(?A = A, ?offset = offset)


    /// <summary>Constructs a square matrix with the input as diagonal.
    /// Input is a tensor *A* of dimension *n &gt;= 1*.
    /// 
    /// If *n=1*, then *A* represents the diagonal entries of a single square matrix. This matrix will be returned as a 2-dimensional tensor.
    /// If *n&gt;1*, then *A* represents a batch of diagonals of square matrices. The batch of diagonal matrices will be returned as an *n+1*-dimensional tensor.
    /// 
    /// .. note:: The operator supports float32 and float64 data types only.
    /// 
    /// Examples::
    /// 
    ///     Single diagonal matrix construction
    ///     A = [1.0, 2.0]
    /// 
    ///     makediag(A)    = [[1.0, 0.0],
    ///                       [0.0, 2.0]]
    /// 
    ///     makediag(A, 1) = [[0.0, 1.0, 0.0],
    ///                       [0.0, 0.0, 2.0],
    ///                       [0.0, 0.0, 0.0]]
    /// 
    ///     Batch diagonal matrix construction
    ///     A = [[1.0, 2.0],
    ///          [3.0, 4.0]]
    /// 
    ///     makediag(A) = [[[1.0, 0.0],
    ///                     [0.0, 2.0]],
    ///                    [[3.0, 0.0],
    ///                     [0.0, 4.0]]]
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\la_op.cc:L547</summary>
    /// <param name="A">Tensor of diagonal entries</param>
    /// <param name="offset">Offset of the diagonal versus the main diagonal. 0 corresponds to the main diagonal, a negative/positive value to diagonals below/above the main diagonal.</param>
    static member LinalgMakediag(A : NDArray, [<Optional; DefaultParameterValue(0)>] offset : int) =
        let creator = AtomicSymbolCreator.FromName "_linalg_makediag"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg A)) then A.UnsafeHandle|]
                                                 [|"offset"|]
                                                 [|string offset|]
        (new NDArray(outputs.[0]))
    /// <summary>Constructs a square matrix with the input as diagonal.
    /// Input is a tensor *A* of dimension *n &gt;= 1*.
    /// 
    /// If *n=1*, then *A* represents the diagonal entries of a single square matrix. This matrix will be returned as a 2-dimensional tensor.
    /// If *n&gt;1*, then *A* represents a batch of diagonals of square matrices. The batch of diagonal matrices will be returned as an *n+1*-dimensional tensor.
    /// 
    /// .. note:: The operator supports float32 and float64 data types only.
    /// 
    /// Examples::
    /// 
    ///     Single diagonal matrix construction
    ///     A = [1.0, 2.0]
    /// 
    ///     makediag(A)    = [[1.0, 0.0],
    ///                       [0.0, 2.0]]
    /// 
    ///     makediag(A, 1) = [[0.0, 1.0, 0.0],
    ///                       [0.0, 0.0, 2.0],
    ///                       [0.0, 0.0, 0.0]]
    /// 
    ///     Batch diagonal matrix construction
    ///     A = [[1.0, 2.0],
    ///          [3.0, 4.0]]
    /// 
    ///     makediag(A) = [[[1.0, 0.0],
    ///                     [0.0, 2.0]],
    ///                    [[3.0, 0.0],
    ///                     [0.0, 4.0]]]
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\la_op.cc:L547</summary>
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="A">Tensor of diagonal entries</param>
    /// <param name="offset">Offset of the diagonal versus the main diagonal. 0 corresponds to the main diagonal, a negative/positive value to diagonals below/above the main diagonal.</param>
    static member LinalgMakediag(outputArray : NDArray seq, A : NDArray, [<Optional; DefaultParameterValue(0)>] offset : int) =
        let creator = AtomicSymbolCreator.FromName "_linalg_makediag"
        let names = [|"offset"|]
        let vals = [|string offset|]
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg A)) then A.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <summary>Constructs a square matrix with the input as diagonal.
    /// Input is a tensor *A* of dimension *n &gt;= 1*.
    /// 
    /// If *n=1*, then *A* represents the diagonal entries of a single square matrix. This matrix will be returned as a 2-dimensional tensor.
    /// If *n&gt;1*, then *A* represents a batch of diagonals of square matrices. The batch of diagonal matrices will be returned as an *n+1*-dimensional tensor.
    /// 
    /// .. note:: The operator supports float32 and float64 data types only.
    /// 
    /// Examples::
    /// 
    ///     Single diagonal matrix construction
    ///     A = [1.0, 2.0]
    /// 
    ///     makediag(A)    = [[1.0, 0.0],
    ///                       [0.0, 2.0]]
    /// 
    ///     makediag(A, 1) = [[0.0, 1.0, 0.0],
    ///                       [0.0, 0.0, 2.0],
    ///                       [0.0, 0.0, 0.0]]
    /// 
    ///     Batch diagonal matrix construction
    ///     A = [[1.0, 2.0],
    ///          [3.0, 4.0]]
    /// 
    ///     makediag(A) = [[[1.0, 0.0],
    ///                     [0.0, 2.0]],
    ///                    [[3.0, 0.0],
    ///                     [0.0, 4.0]]]
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\la_op.cc:L547</summary>
    /// <param name="A">Tensor of diagonal entries</param>
    /// <param name="offset">Offset of the diagonal versus the main diagonal. 0 corresponds to the main diagonal, a negative/positive value to diagonals below/above the main diagonal.</param>
    static member LinalgMakediag([<Optional>] ?A : Symbol, [<Optional>] ?offset : int) =
        LinalgMakediag(?A = A, ?offset = offset)


    /// <summary>Extracts a triangular sub-matrix from a square matrix.
    /// Input is a tensor *A* of dimension *n &gt;= 2*.
    /// 
    /// If *n=2*, then *A* represents a single square matrix from which a triangular sub-matrix is extracted as a 1-dimensional tensor.
    /// 
    /// If *n&gt;2*, then *A* represents a batch of square matrices on the trailing two dimensions. The extracted triangular sub-matrices are returned as an *n-1*-dimensional tensor.
    /// 
    /// The *offset* and *lower* parameters determine the triangle to be extracted:
    /// 
    /// - When *offset = 0* either the lower or upper triangle with respect to the main diagonal is extracted depending on the value of parameter *lower*.
    /// - When *offset = k &gt; 0* the upper triangle with respect to the k-th diagonal above the main diagonal is extracted. 
    /// - When *offset = k &lt; 0* the lower triangle with respect to the k-th diagonal below the main diagonal is extracted. 
    /// 
    /// .. note:: The operator supports float32 and float64 data types only.
    /// 
    /// Examples::
    /// 
    ///     Single triagonal extraction
    ///     A = [[1.0, 2.0],
    ///          [3.0, 4.0]]
    /// 
    ///     extracttrian(A) = [1.0, 3.0, 4.0]
    ///     extracttrian(A, lower=False) = [1.0, 2.0, 4.0]
    ///     extracttrian(A, 1) = [2.0]
    ///     extracttrian(A, -1) = [3.0]
    /// 
    ///     Batch triagonal extraction
    ///     A = [[[1.0, 2.0],
    ///           [3.0, 4.0]],
    ///          [[5.0, 6.0],
    ///           [7.0, 8.0]]]
    /// 
    ///     extracttrian(A) = [[1.0, 3.0, 4.0],
    ///                        [5.0, 7.0, 8.0]]
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\la_op.cc:L605</summary>
    /// <param name="A">Tensor of square matrices</param>
    /// <param name="offset">Offset of the diagonal versus the main diagonal. 0 corresponds to the main diagonal, a negative/positive value to diagonals below/above the main diagonal.</param>
    /// <param name="lower">Refer to the lower triangular matrix if lower=true, refer to the upper otherwise. Only relevant when offset=0</param>
    static member LinalgExtracttrian(A : NDArray, [<Optional; DefaultParameterValue(0)>] offset : int, [<Optional; DefaultParameterValue(true)>] lower : bool) =
        let creator = AtomicSymbolCreator.FromName "_linalg_extracttrian"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg A)) then A.UnsafeHandle|]
                                                 [|"offset"; "lower"|]
                                                 [|string offset; string lower|]
        (new NDArray(outputs.[0]))
    /// <summary>Extracts a triangular sub-matrix from a square matrix.
    /// Input is a tensor *A* of dimension *n &gt;= 2*.
    /// 
    /// If *n=2*, then *A* represents a single square matrix from which a triangular sub-matrix is extracted as a 1-dimensional tensor.
    /// 
    /// If *n&gt;2*, then *A* represents a batch of square matrices on the trailing two dimensions. The extracted triangular sub-matrices are returned as an *n-1*-dimensional tensor.
    /// 
    /// The *offset* and *lower* parameters determine the triangle to be extracted:
    /// 
    /// - When *offset = 0* either the lower or upper triangle with respect to the main diagonal is extracted depending on the value of parameter *lower*.
    /// - When *offset = k &gt; 0* the upper triangle with respect to the k-th diagonal above the main diagonal is extracted. 
    /// - When *offset = k &lt; 0* the lower triangle with respect to the k-th diagonal below the main diagonal is extracted. 
    /// 
    /// .. note:: The operator supports float32 and float64 data types only.
    /// 
    /// Examples::
    /// 
    ///     Single triagonal extraction
    ///     A = [[1.0, 2.0],
    ///          [3.0, 4.0]]
    /// 
    ///     extracttrian(A) = [1.0, 3.0, 4.0]
    ///     extracttrian(A, lower=False) = [1.0, 2.0, 4.0]
    ///     extracttrian(A, 1) = [2.0]
    ///     extracttrian(A, -1) = [3.0]
    /// 
    ///     Batch triagonal extraction
    ///     A = [[[1.0, 2.0],
    ///           [3.0, 4.0]],
    ///          [[5.0, 6.0],
    ///           [7.0, 8.0]]]
    /// 
    ///     extracttrian(A) = [[1.0, 3.0, 4.0],
    ///                        [5.0, 7.0, 8.0]]
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\la_op.cc:L605</summary>
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="A">Tensor of square matrices</param>
    /// <param name="offset">Offset of the diagonal versus the main diagonal. 0 corresponds to the main diagonal, a negative/positive value to diagonals below/above the main diagonal.</param>
    /// <param name="lower">Refer to the lower triangular matrix if lower=true, refer to the upper otherwise. Only relevant when offset=0</param>
    static member LinalgExtracttrian(outputArray : NDArray seq, A : NDArray, [<Optional; DefaultParameterValue(0)>] offset : int, [<Optional; DefaultParameterValue(true)>] lower : bool) =
        let creator = AtomicSymbolCreator.FromName "_linalg_extracttrian"
        let names = [|"offset"; "lower"|]
        let vals = [|string offset; string lower|]
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg A)) then A.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <summary>Extracts a triangular sub-matrix from a square matrix.
    /// Input is a tensor *A* of dimension *n &gt;= 2*.
    /// 
    /// If *n=2*, then *A* represents a single square matrix from which a triangular sub-matrix is extracted as a 1-dimensional tensor.
    /// 
    /// If *n&gt;2*, then *A* represents a batch of square matrices on the trailing two dimensions. The extracted triangular sub-matrices are returned as an *n-1*-dimensional tensor.
    /// 
    /// The *offset* and *lower* parameters determine the triangle to be extracted:
    /// 
    /// - When *offset = 0* either the lower or upper triangle with respect to the main diagonal is extracted depending on the value of parameter *lower*.
    /// - When *offset = k &gt; 0* the upper triangle with respect to the k-th diagonal above the main diagonal is extracted. 
    /// - When *offset = k &lt; 0* the lower triangle with respect to the k-th diagonal below the main diagonal is extracted. 
    /// 
    /// .. note:: The operator supports float32 and float64 data types only.
    /// 
    /// Examples::
    /// 
    ///     Single triagonal extraction
    ///     A = [[1.0, 2.0],
    ///          [3.0, 4.0]]
    /// 
    ///     extracttrian(A) = [1.0, 3.0, 4.0]
    ///     extracttrian(A, lower=False) = [1.0, 2.0, 4.0]
    ///     extracttrian(A, 1) = [2.0]
    ///     extracttrian(A, -1) = [3.0]
    /// 
    ///     Batch triagonal extraction
    ///     A = [[[1.0, 2.0],
    ///           [3.0, 4.0]],
    ///          [[5.0, 6.0],
    ///           [7.0, 8.0]]]
    /// 
    ///     extracttrian(A) = [[1.0, 3.0, 4.0],
    ///                        [5.0, 7.0, 8.0]]
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\la_op.cc:L605</summary>
    /// <param name="A">Tensor of square matrices</param>
    /// <param name="offset">Offset of the diagonal versus the main diagonal. 0 corresponds to the main diagonal, a negative/positive value to diagonals below/above the main diagonal.</param>
    /// <param name="lower">Refer to the lower triangular matrix if lower=true, refer to the upper otherwise. Only relevant when offset=0</param>
    static member LinalgExtracttrian([<Optional>] ?A : Symbol, [<Optional>] ?offset : int, [<Optional>] ?lower : bool) =
        LinalgExtracttrian(?A = A, ?offset = offset, ?lower = lower)


    /// <summary>Constructs a square matrix with the input representing a specific triangular sub-matrix.
    /// This is basically the inverse of *linalg.extracttrian*. Input is a tensor *A* of dimension *n &gt;= 1*.
    /// 
    /// If *n=1*, then *A* represents the entries of a triangular matrix which is lower triangular if *offset&lt;0* or *offset=0*, *lower=true*. The resulting matrix is derived by first constructing the square
    /// matrix with the entries outside the triangle set to zero and then adding *offset*-times an additional 
    /// diagonal with zero entries to the square matrix. 
    /// 
    /// If *n&gt;1*, then *A* represents a batch of triangular sub-matrices. The batch of corresponding square matrices is returned as an *n+1*-dimensional tensor.
    /// 
    /// .. note:: The operator supports float32 and float64 data types only.
    /// 
    /// Examples::
    /// 
    ///     Single  matrix construction
    ///     A = [1.0, 2.0, 3.0]
    /// 
    ///     maketrian(A)              = [[1.0, 0.0],
    ///                                  [2.0, 3.0]]
    /// 
    ///     maketrian(A, lower=false) = [[1.0, 2.0],
    ///                                  [0.0, 3.0]]
    /// 
    ///     maketrian(A, offset=1)    = [[0.0, 1.0, 2.0],
    ///                                  [0.0, 0.0, 3.0],
    ///                                  [0.0, 0.0, 0.0]]
    ///     maketrian(A, offset=-1)   = [[0.0, 0.0, 0.0],
    ///                                  [1.0, 0.0, 0.0],
    ///                                  [2.0, 3.0, 0.0]]
    /// 
    ///     Batch matrix construction
    ///     A = [[1.0, 2.0, 3.0],
    ///          [4.0, 5.0, 6.0]]
    /// 
    ///     maketrian(A)           = [[[1.0, 0.0],
    ///                                [2.0, 3.0]],
    ///                               [[4.0, 0.0],
    ///                                [5.0, 6.0]]]
    /// 
    ///     maketrian(A, offset=1) = [[[0.0, 1.0, 2.0],
    ///                                [0.0, 0.0, 3.0],
    ///                                [0.0, 0.0, 0.0]],
    ///                               [[0.0, 4.0, 5.0],
    ///                                [0.0, 0.0, 6.0],
    ///                                [0.0, 0.0, 0.0]]]
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\la_op.cc:L673</summary>
    /// <param name="A">Tensor of triangular matrices stored as vectors</param>
    /// <param name="offset">Offset of the diagonal versus the main diagonal. 0 corresponds to the main diagonal, a negative/positive value to diagonals below/above the main diagonal.</param>
    /// <param name="lower">Refer to the lower triangular matrix if lower=true, refer to the upper otherwise. Only relevant when offset=0</param>
    static member LinalgMaketrian(A : NDArray, [<Optional; DefaultParameterValue(0)>] offset : int, [<Optional; DefaultParameterValue(true)>] lower : bool) =
        let creator = AtomicSymbolCreator.FromName "_linalg_maketrian"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg A)) then A.UnsafeHandle|]
                                                 [|"offset"; "lower"|]
                                                 [|string offset; string lower|]
        (new NDArray(outputs.[0]))
    /// <summary>Constructs a square matrix with the input representing a specific triangular sub-matrix.
    /// This is basically the inverse of *linalg.extracttrian*. Input is a tensor *A* of dimension *n &gt;= 1*.
    /// 
    /// If *n=1*, then *A* represents the entries of a triangular matrix which is lower triangular if *offset&lt;0* or *offset=0*, *lower=true*. The resulting matrix is derived by first constructing the square
    /// matrix with the entries outside the triangle set to zero and then adding *offset*-times an additional 
    /// diagonal with zero entries to the square matrix. 
    /// 
    /// If *n&gt;1*, then *A* represents a batch of triangular sub-matrices. The batch of corresponding square matrices is returned as an *n+1*-dimensional tensor.
    /// 
    /// .. note:: The operator supports float32 and float64 data types only.
    /// 
    /// Examples::
    /// 
    ///     Single  matrix construction
    ///     A = [1.0, 2.0, 3.0]
    /// 
    ///     maketrian(A)              = [[1.0, 0.0],
    ///                                  [2.0, 3.0]]
    /// 
    ///     maketrian(A, lower=false) = [[1.0, 2.0],
    ///                                  [0.0, 3.0]]
    /// 
    ///     maketrian(A, offset=1)    = [[0.0, 1.0, 2.0],
    ///                                  [0.0, 0.0, 3.0],
    ///                                  [0.0, 0.0, 0.0]]
    ///     maketrian(A, offset=-1)   = [[0.0, 0.0, 0.0],
    ///                                  [1.0, 0.0, 0.0],
    ///                                  [2.0, 3.0, 0.0]]
    /// 
    ///     Batch matrix construction
    ///     A = [[1.0, 2.0, 3.0],
    ///          [4.0, 5.0, 6.0]]
    /// 
    ///     maketrian(A)           = [[[1.0, 0.0],
    ///                                [2.0, 3.0]],
    ///                               [[4.0, 0.0],
    ///                                [5.0, 6.0]]]
    /// 
    ///     maketrian(A, offset=1) = [[[0.0, 1.0, 2.0],
    ///                                [0.0, 0.0, 3.0],
    ///                                [0.0, 0.0, 0.0]],
    ///                               [[0.0, 4.0, 5.0],
    ///                                [0.0, 0.0, 6.0],
    ///                                [0.0, 0.0, 0.0]]]
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\la_op.cc:L673</summary>
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="A">Tensor of triangular matrices stored as vectors</param>
    /// <param name="offset">Offset of the diagonal versus the main diagonal. 0 corresponds to the main diagonal, a negative/positive value to diagonals below/above the main diagonal.</param>
    /// <param name="lower">Refer to the lower triangular matrix if lower=true, refer to the upper otherwise. Only relevant when offset=0</param>
    static member LinalgMaketrian(outputArray : NDArray seq, A : NDArray, [<Optional; DefaultParameterValue(0)>] offset : int, [<Optional; DefaultParameterValue(true)>] lower : bool) =
        let creator = AtomicSymbolCreator.FromName "_linalg_maketrian"
        let names = [|"offset"; "lower"|]
        let vals = [|string offset; string lower|]
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg A)) then A.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <summary>Constructs a square matrix with the input representing a specific triangular sub-matrix.
    /// This is basically the inverse of *linalg.extracttrian*. Input is a tensor *A* of dimension *n &gt;= 1*.
    /// 
    /// If *n=1*, then *A* represents the entries of a triangular matrix which is lower triangular if *offset&lt;0* or *offset=0*, *lower=true*. The resulting matrix is derived by first constructing the square
    /// matrix with the entries outside the triangle set to zero and then adding *offset*-times an additional 
    /// diagonal with zero entries to the square matrix. 
    /// 
    /// If *n&gt;1*, then *A* represents a batch of triangular sub-matrices. The batch of corresponding square matrices is returned as an *n+1*-dimensional tensor.
    /// 
    /// .. note:: The operator supports float32 and float64 data types only.
    /// 
    /// Examples::
    /// 
    ///     Single  matrix construction
    ///     A = [1.0, 2.0, 3.0]
    /// 
    ///     maketrian(A)              = [[1.0, 0.0],
    ///                                  [2.0, 3.0]]
    /// 
    ///     maketrian(A, lower=false) = [[1.0, 2.0],
    ///                                  [0.0, 3.0]]
    /// 
    ///     maketrian(A, offset=1)    = [[0.0, 1.0, 2.0],
    ///                                  [0.0, 0.0, 3.0],
    ///                                  [0.0, 0.0, 0.0]]
    ///     maketrian(A, offset=-1)   = [[0.0, 0.0, 0.0],
    ///                                  [1.0, 0.0, 0.0],
    ///                                  [2.0, 3.0, 0.0]]
    /// 
    ///     Batch matrix construction
    ///     A = [[1.0, 2.0, 3.0],
    ///          [4.0, 5.0, 6.0]]
    /// 
    ///     maketrian(A)           = [[[1.0, 0.0],
    ///                                [2.0, 3.0]],
    ///                               [[4.0, 0.0],
    ///                                [5.0, 6.0]]]
    /// 
    ///     maketrian(A, offset=1) = [[[0.0, 1.0, 2.0],
    ///                                [0.0, 0.0, 3.0],
    ///                                [0.0, 0.0, 0.0]],
    ///                               [[0.0, 4.0, 5.0],
    ///                                [0.0, 0.0, 6.0],
    ///                                [0.0, 0.0, 0.0]]]
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\la_op.cc:L673</summary>
    /// <param name="A">Tensor of triangular matrices stored as vectors</param>
    /// <param name="offset">Offset of the diagonal versus the main diagonal. 0 corresponds to the main diagonal, a negative/positive value to diagonals below/above the main diagonal.</param>
    /// <param name="lower">Refer to the lower triangular matrix if lower=true, refer to the upper otherwise. Only relevant when offset=0</param>
    static member LinalgMaketrian([<Optional>] ?A : Symbol, [<Optional>] ?offset : int, [<Optional>] ?lower : bool) =
        LinalgMaketrian(?A = A, ?offset = offset, ?lower = lower)


    /// <summary>Multiplication of matrix with its transpose.
    /// Input is a tensor *A* of dimension *n &gt;= 2*.
    /// 
    /// If *n=2*, the operator performs the BLAS3 function *syrk*:
    /// 
    ///   *out* = *alpha* \* *A* \* *A*\ :sup:`T`
    /// 
    /// if *transpose=False*, or
    /// 
    ///   *out* = *alpha* \* *A*\ :sup:`T` \ \* *A*
    /// 
    /// if *transpose=True*.
    /// 
    /// If *n&gt;2*, *syrk* is performed separately on the trailing two dimensions for all
    /// inputs (batch mode).
    /// 
    /// .. note:: The operator supports float32 and float64 data types only.
    /// 
    /// Examples::
    /// 
    ///    Single matrix multiply
    ///    A = [[1., 2., 3.], [4., 5., 6.]]
    ///    syrk(A, alpha=1., transpose=False)
    ///             = [[14., 32.],
    ///                [32., 77.]]
    ///    syrk(A, alpha=1., transpose=True)
    ///             = [[17., 22., 27.],
    ///                [22., 29., 36.],
    ///                [27., 36., 45.]]
    /// 
    ///    Batch matrix multiply
    ///    A = [[[1., 1.]], [[0.1, 0.1]]]
    ///    syrk(A, alpha=2., transpose=False) = [[[4.]], [[0.04]]]
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\la_op.cc:L730</summary>
    /// <param name="A">Tensor of input matrices</param>
    /// <param name="transpose">Use transpose of input matrix.</param>
    /// <param name="alpha">Scalar factor to be applied to the result.</param>
    static member LinalgSyrk(A : NDArray, [<Optional; DefaultParameterValue(false)>] transpose : bool, [<Optional; DefaultParameterValue(1.0)>] alpha : double) =
        let creator = AtomicSymbolCreator.FromName "_linalg_syrk"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg A)) then A.UnsafeHandle|]
                                                 [|"transpose"; "alpha"|]
                                                 [|string transpose; string alpha|]
        (new NDArray(outputs.[0]))
    /// <summary>Multiplication of matrix with its transpose.
    /// Input is a tensor *A* of dimension *n &gt;= 2*.
    /// 
    /// If *n=2*, the operator performs the BLAS3 function *syrk*:
    /// 
    ///   *out* = *alpha* \* *A* \* *A*\ :sup:`T`
    /// 
    /// if *transpose=False*, or
    /// 
    ///   *out* = *alpha* \* *A*\ :sup:`T` \ \* *A*
    /// 
    /// if *transpose=True*.
    /// 
    /// If *n&gt;2*, *syrk* is performed separately on the trailing two dimensions for all
    /// inputs (batch mode).
    /// 
    /// .. note:: The operator supports float32 and float64 data types only.
    /// 
    /// Examples::
    /// 
    ///    Single matrix multiply
    ///    A = [[1., 2., 3.], [4., 5., 6.]]
    ///    syrk(A, alpha=1., transpose=False)
    ///             = [[14., 32.],
    ///                [32., 77.]]
    ///    syrk(A, alpha=1., transpose=True)
    ///             = [[17., 22., 27.],
    ///                [22., 29., 36.],
    ///                [27., 36., 45.]]
    /// 
    ///    Batch matrix multiply
    ///    A = [[[1., 1.]], [[0.1, 0.1]]]
    ///    syrk(A, alpha=2., transpose=False) = [[[4.]], [[0.04]]]
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\la_op.cc:L730</summary>
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="A">Tensor of input matrices</param>
    /// <param name="transpose">Use transpose of input matrix.</param>
    /// <param name="alpha">Scalar factor to be applied to the result.</param>
    static member LinalgSyrk(outputArray : NDArray seq, A : NDArray, [<Optional; DefaultParameterValue(false)>] transpose : bool, [<Optional; DefaultParameterValue(1.0)>] alpha : double) =
        let creator = AtomicSymbolCreator.FromName "_linalg_syrk"
        let names = [|"transpose"; "alpha"|]
        let vals = [|string transpose; string alpha|]
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg A)) then A.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <summary>Multiplication of matrix with its transpose.
    /// Input is a tensor *A* of dimension *n &gt;= 2*.
    /// 
    /// If *n=2*, the operator performs the BLAS3 function *syrk*:
    /// 
    ///   *out* = *alpha* \* *A* \* *A*\ :sup:`T`
    /// 
    /// if *transpose=False*, or
    /// 
    ///   *out* = *alpha* \* *A*\ :sup:`T` \ \* *A*
    /// 
    /// if *transpose=True*.
    /// 
    /// If *n&gt;2*, *syrk* is performed separately on the trailing two dimensions for all
    /// inputs (batch mode).
    /// 
    /// .. note:: The operator supports float32 and float64 data types only.
    /// 
    /// Examples::
    /// 
    ///    Single matrix multiply
    ///    A = [[1., 2., 3.], [4., 5., 6.]]
    ///    syrk(A, alpha=1., transpose=False)
    ///             = [[14., 32.],
    ///                [32., 77.]]
    ///    syrk(A, alpha=1., transpose=True)
    ///             = [[17., 22., 27.],
    ///                [22., 29., 36.],
    ///                [27., 36., 45.]]
    /// 
    ///    Batch matrix multiply
    ///    A = [[[1., 1.]], [[0.1, 0.1]]]
    ///    syrk(A, alpha=2., transpose=False) = [[[4.]], [[0.04]]]
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\la_op.cc:L730</summary>
    /// <param name="A">Tensor of input matrices</param>
    /// <param name="transpose">Use transpose of input matrix.</param>
    /// <param name="alpha">Scalar factor to be applied to the result.</param>
    static member LinalgSyrk([<Optional>] ?A : Symbol, [<Optional>] ?transpose : bool, [<Optional>] ?alpha : double) =
        LinalgSyrk(?A = A, ?transpose = transpose, ?alpha = alpha)


    /// <summary>LQ factorization for general matrix.
    /// Input is a tensor *A* of dimension *n &gt;= 2*.
    /// 
    /// If *n=2*, we compute the LQ factorization (LAPACK *gelqf*, followed by *orglq*). *A*
    /// must have shape *(x, y)* with *x &lt;= y*, and must have full rank *=x*. The LQ
    /// factorization consists of *L* with shape *(x, x)* and *Q* with shape *(x, y)*, so
    /// that:
    /// 
    ///    *A* = *L* \* *Q*
    /// 
    /// Here, *L* is lower triangular (upper triangle equal to zero) with nonzero diagonal,
    /// and *Q* is row-orthonormal, meaning that
    /// 
    ///    *Q* \* *Q*\ :sup:`T`
    /// 
    /// is equal to the identity matrix of shape *(x, x)*.
    /// 
    /// If *n&gt;2*, *gelqf* is performed separately on the trailing two dimensions for all
    /// inputs (batch mode).
    /// 
    /// .. note:: The operator supports float32 and float64 data types only.
    /// 
    /// Examples::
    /// 
    ///    Single LQ factorization
    ///    A = [[1., 2., 3.], [4., 5., 6.]]
    ///    Q, L = gelqf(A)
    ///    Q = [[-0.26726124, -0.53452248, -0.80178373],
    ///         [0.87287156, 0.21821789, -0.43643578]]
    ///    L = [[-3.74165739, 0.],
    ///         [-8.55235974, 1.96396101]]
    /// 
    ///    Batch LQ factorization
    ///    A = [[[1., 2., 3.], [4., 5., 6.]],
    ///         [[7., 8., 9.], [10., 11., 12.]]]
    ///    Q, L = gelqf(A)
    ///    Q = [[[-0.26726124, -0.53452248, -0.80178373],
    ///          [0.87287156, 0.21821789, -0.43643578]],
    ///         [[-0.50257071, -0.57436653, -0.64616234],
    ///          [0.7620735, 0.05862104, -0.64483142]]]
    ///    L = [[[-3.74165739, 0.],
    ///          [-8.55235974, 1.96396101]],
    ///         [[-13.92838828, 0.],
    ///          [-19.09768702, 0.52758934]]]
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\la_op.cc:L798</summary>
    /// <param name="A">Tensor of input matrices to be factorized</param>
    static member LinalgGelqf(A : NDArray) =
        let creator = AtomicSymbolCreator.FromName "_linalg_gelqf"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg A)) then A.UnsafeHandle|]
                                                 Array.empty
                                                 Array.empty
        (new NDArray(outputs.[0])), (new NDArray(outputs.[1]))
    /// <summary>LQ factorization for general matrix.
    /// Input is a tensor *A* of dimension *n &gt;= 2*.
    /// 
    /// If *n=2*, we compute the LQ factorization (LAPACK *gelqf*, followed by *orglq*). *A*
    /// must have shape *(x, y)* with *x &lt;= y*, and must have full rank *=x*. The LQ
    /// factorization consists of *L* with shape *(x, x)* and *Q* with shape *(x, y)*, so
    /// that:
    /// 
    ///    *A* = *L* \* *Q*
    /// 
    /// Here, *L* is lower triangular (upper triangle equal to zero) with nonzero diagonal,
    /// and *Q* is row-orthonormal, meaning that
    /// 
    ///    *Q* \* *Q*\ :sup:`T`
    /// 
    /// is equal to the identity matrix of shape *(x, x)*.
    /// 
    /// If *n&gt;2*, *gelqf* is performed separately on the trailing two dimensions for all
    /// inputs (batch mode).
    /// 
    /// .. note:: The operator supports float32 and float64 data types only.
    /// 
    /// Examples::
    /// 
    ///    Single LQ factorization
    ///    A = [[1., 2., 3.], [4., 5., 6.]]
    ///    Q, L = gelqf(A)
    ///    Q = [[-0.26726124, -0.53452248, -0.80178373],
    ///         [0.87287156, 0.21821789, -0.43643578]]
    ///    L = [[-3.74165739, 0.],
    ///         [-8.55235974, 1.96396101]]
    /// 
    ///    Batch LQ factorization
    ///    A = [[[1., 2., 3.], [4., 5., 6.]],
    ///         [[7., 8., 9.], [10., 11., 12.]]]
    ///    Q, L = gelqf(A)
    ///    Q = [[[-0.26726124, -0.53452248, -0.80178373],
    ///          [0.87287156, 0.21821789, -0.43643578]],
    ///         [[-0.50257071, -0.57436653, -0.64616234],
    ///          [0.7620735, 0.05862104, -0.64483142]]]
    ///    L = [[[-3.74165739, 0.],
    ///          [-8.55235974, 1.96396101]],
    ///         [[-13.92838828, 0.],
    ///          [-19.09768702, 0.52758934]]]
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\la_op.cc:L798</summary>
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="A">Tensor of input matrices to be factorized</param>
    static member LinalgGelqf(outputArray : NDArray seq, A : NDArray) =
        let creator = AtomicSymbolCreator.FromName "_linalg_gelqf"
        let names = Array.empty
        let vals = Array.empty
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg A)) then A.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <summary>LQ factorization for general matrix.
    /// Input is a tensor *A* of dimension *n &gt;= 2*.
    /// 
    /// If *n=2*, we compute the LQ factorization (LAPACK *gelqf*, followed by *orglq*). *A*
    /// must have shape *(x, y)* with *x &lt;= y*, and must have full rank *=x*. The LQ
    /// factorization consists of *L* with shape *(x, x)* and *Q* with shape *(x, y)*, so
    /// that:
    /// 
    ///    *A* = *L* \* *Q*
    /// 
    /// Here, *L* is lower triangular (upper triangle equal to zero) with nonzero diagonal,
    /// and *Q* is row-orthonormal, meaning that
    /// 
    ///    *Q* \* *Q*\ :sup:`T`
    /// 
    /// is equal to the identity matrix of shape *(x, x)*.
    /// 
    /// If *n&gt;2*, *gelqf* is performed separately on the trailing two dimensions for all
    /// inputs (batch mode).
    /// 
    /// .. note:: The operator supports float32 and float64 data types only.
    /// 
    /// Examples::
    /// 
    ///    Single LQ factorization
    ///    A = [[1., 2., 3.], [4., 5., 6.]]
    ///    Q, L = gelqf(A)
    ///    Q = [[-0.26726124, -0.53452248, -0.80178373],
    ///         [0.87287156, 0.21821789, -0.43643578]]
    ///    L = [[-3.74165739, 0.],
    ///         [-8.55235974, 1.96396101]]
    /// 
    ///    Batch LQ factorization
    ///    A = [[[1., 2., 3.], [4., 5., 6.]],
    ///         [[7., 8., 9.], [10., 11., 12.]]]
    ///    Q, L = gelqf(A)
    ///    Q = [[[-0.26726124, -0.53452248, -0.80178373],
    ///          [0.87287156, 0.21821789, -0.43643578]],
    ///         [[-0.50257071, -0.57436653, -0.64616234],
    ///          [0.7620735, 0.05862104, -0.64483142]]]
    ///    L = [[[-3.74165739, 0.],
    ///          [-8.55235974, 1.96396101]],
    ///         [[-13.92838828, 0.],
    ///          [-19.09768702, 0.52758934]]]
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\la_op.cc:L798</summary>
    /// <param name="A">Tensor of input matrices to be factorized</param>
    static member LinalgGelqf([<Optional>] ?A : Symbol) =
        LinalgGelqf(?A = A)


    /// <summary>Eigendecomposition for symmetric matrix.
    /// Input is a tensor *A* of dimension *n &gt;= 2*.
    /// 
    /// If *n=2*, *A* must be symmetric, of shape *(x, x)*. We compute the eigendecomposition,
    /// resulting in the orthonormal matrix *U* of eigenvectors, shape *(x, x)*, and the
    /// vector *L* of eigenvalues, shape *(x,)*, so that:
    /// 
    ///    *U* \* *A* = *diag(L)* \* *U*
    /// 
    /// Here:
    /// 
    ///    *U* \* *U*\ :sup:`T` = *U*\ :sup:`T` \* *U* = *I*
    /// 
    /// where *I* is the identity matrix. Also, *L(0) &lt;= L(1) &lt;= L(2) &lt;= ...* (ascending order).
    /// 
    /// If *n&gt;2*, *syevd* is performed separately on the trailing two dimensions of *A* (batch
    /// mode). In this case, *U* has *n* dimensions like *A*, and *L* has *n-1* dimensions.
    /// 
    /// .. note:: The operator supports float32 and float64 data types only.
    /// 
    /// .. note:: Derivatives for this operator are defined only if *A* is such that all its
    ///           eigenvalues are distinct, and the eigengaps are not too small. If you need
    ///           gradients, do not apply this operator to matrices with multiple eigenvalues.
    /// 
    /// Examples::
    /// 
    ///    Single symmetric eigendecomposition
    ///    A = [[1., 2.], [2., 4.]]
    ///    U, L = syevd(A)
    ///    U = [[0.89442719, -0.4472136],
    ///         [0.4472136, 0.89442719]]
    ///    L = [0., 5.]
    /// 
    ///    Batch symmetric eigendecomposition
    ///    A = [[[1., 2.], [2., 4.]],
    ///         [[1., 2.], [2., 5.]]]
    ///    U, L = syevd(A)
    ///    U = [[[0.89442719, -0.4472136],
    ///          [0.4472136, 0.89442719]],
    ///         [[0.92387953, -0.38268343],
    ///          [0.38268343, 0.92387953]]]
    ///    L = [[0., 5.],
    ///         [0.17157288, 5.82842712]]
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\la_op.cc:L868</summary>
    /// <param name="A">Tensor of input matrices to be factorized</param>
    static member LinalgSyevd(A : NDArray) =
        let creator = AtomicSymbolCreator.FromName "_linalg_syevd"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg A)) then A.UnsafeHandle|]
                                                 Array.empty
                                                 Array.empty
        (new NDArray(outputs.[0])), (new NDArray(outputs.[1]))
    /// <summary>Eigendecomposition for symmetric matrix.
    /// Input is a tensor *A* of dimension *n &gt;= 2*.
    /// 
    /// If *n=2*, *A* must be symmetric, of shape *(x, x)*. We compute the eigendecomposition,
    /// resulting in the orthonormal matrix *U* of eigenvectors, shape *(x, x)*, and the
    /// vector *L* of eigenvalues, shape *(x,)*, so that:
    /// 
    ///    *U* \* *A* = *diag(L)* \* *U*
    /// 
    /// Here:
    /// 
    ///    *U* \* *U*\ :sup:`T` = *U*\ :sup:`T` \* *U* = *I*
    /// 
    /// where *I* is the identity matrix. Also, *L(0) &lt;= L(1) &lt;= L(2) &lt;= ...* (ascending order).
    /// 
    /// If *n&gt;2*, *syevd* is performed separately on the trailing two dimensions of *A* (batch
    /// mode). In this case, *U* has *n* dimensions like *A*, and *L* has *n-1* dimensions.
    /// 
    /// .. note:: The operator supports float32 and float64 data types only.
    /// 
    /// .. note:: Derivatives for this operator are defined only if *A* is such that all its
    ///           eigenvalues are distinct, and the eigengaps are not too small. If you need
    ///           gradients, do not apply this operator to matrices with multiple eigenvalues.
    /// 
    /// Examples::
    /// 
    ///    Single symmetric eigendecomposition
    ///    A = [[1., 2.], [2., 4.]]
    ///    U, L = syevd(A)
    ///    U = [[0.89442719, -0.4472136],
    ///         [0.4472136, 0.89442719]]
    ///    L = [0., 5.]
    /// 
    ///    Batch symmetric eigendecomposition
    ///    A = [[[1., 2.], [2., 4.]],
    ///         [[1., 2.], [2., 5.]]]
    ///    U, L = syevd(A)
    ///    U = [[[0.89442719, -0.4472136],
    ///          [0.4472136, 0.89442719]],
    ///         [[0.92387953, -0.38268343],
    ///          [0.38268343, 0.92387953]]]
    ///    L = [[0., 5.],
    ///         [0.17157288, 5.82842712]]
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\la_op.cc:L868</summary>
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="A">Tensor of input matrices to be factorized</param>
    static member LinalgSyevd(outputArray : NDArray seq, A : NDArray) =
        let creator = AtomicSymbolCreator.FromName "_linalg_syevd"
        let names = Array.empty
        let vals = Array.empty
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg A)) then A.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <summary>Eigendecomposition for symmetric matrix.
    /// Input is a tensor *A* of dimension *n &gt;= 2*.
    /// 
    /// If *n=2*, *A* must be symmetric, of shape *(x, x)*. We compute the eigendecomposition,
    /// resulting in the orthonormal matrix *U* of eigenvectors, shape *(x, x)*, and the
    /// vector *L* of eigenvalues, shape *(x,)*, so that:
    /// 
    ///    *U* \* *A* = *diag(L)* \* *U*
    /// 
    /// Here:
    /// 
    ///    *U* \* *U*\ :sup:`T` = *U*\ :sup:`T` \* *U* = *I*
    /// 
    /// where *I* is the identity matrix. Also, *L(0) &lt;= L(1) &lt;= L(2) &lt;= ...* (ascending order).
    /// 
    /// If *n&gt;2*, *syevd* is performed separately on the trailing two dimensions of *A* (batch
    /// mode). In this case, *U* has *n* dimensions like *A*, and *L* has *n-1* dimensions.
    /// 
    /// .. note:: The operator supports float32 and float64 data types only.
    /// 
    /// .. note:: Derivatives for this operator are defined only if *A* is such that all its
    ///           eigenvalues are distinct, and the eigengaps are not too small. If you need
    ///           gradients, do not apply this operator to matrices with multiple eigenvalues.
    /// 
    /// Examples::
    /// 
    ///    Single symmetric eigendecomposition
    ///    A = [[1., 2.], [2., 4.]]
    ///    U, L = syevd(A)
    ///    U = [[0.89442719, -0.4472136],
    ///         [0.4472136, 0.89442719]]
    ///    L = [0., 5.]
    /// 
    ///    Batch symmetric eigendecomposition
    ///    A = [[[1., 2.], [2., 4.]],
    ///         [[1., 2.], [2., 5.]]]
    ///    U, L = syevd(A)
    ///    U = [[[0.89442719, -0.4472136],
    ///          [0.4472136, 0.89442719]],
    ///         [[0.92387953, -0.38268343],
    ///          [0.38268343, 0.92387953]]]
    ///    L = [[0., 5.],
    ///         [0.17157288, 5.82842712]]
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\la_op.cc:L868</summary>
    /// <param name="A">Tensor of input matrices to be factorized</param>
    static member LinalgSyevd([<Optional>] ?A : Symbol) =
        LinalgSyevd(?A = A)


    /// <summary>Compute the inverse of a matrix.
    /// Input is a tensor *A* of dimension *n &gt;= 2*.
    /// 
    /// If *n=2*, *A* is a square matrix. We compute:
    /// 
    ///   *out* = *A*\ :sup:`-1`
    /// 
    /// If *n&gt;2*, *inverse* is performed separately on the trailing two dimensions
    /// for all inputs (batch mode).
    /// 
    /// .. note:: The operator supports float32 and float64 data types only.
    /// 
    /// Examples::
    /// 
    ///    Single matrix inverse
    ///    A = [[1., 4.], [2., 3.]]
    ///    inverse(A) = [[-0.6, 0.8], [0.4, -0.2]]
    /// 
    ///    Batch matrix inverse
    ///    A = [[[1., 4.], [2., 3.]],
    ///         [[1., 3.], [2., 4.]]]
    ///    inverse(A) = [[[-0.6, 0.8], [0.4, -0.2]],
    ///                  [[-2., 1.5], [1., -0.5]]]
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\la_op.cc:L920</summary>
    /// <param name="A">Tensor of square matrix</param>
    static member LinalgInverse(A : NDArray) =
        let creator = AtomicSymbolCreator.FromName "_linalg_inverse"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg A)) then A.UnsafeHandle|]
                                                 Array.empty
                                                 Array.empty
        (new NDArray(outputs.[0]))
    /// <summary>Compute the inverse of a matrix.
    /// Input is a tensor *A* of dimension *n &gt;= 2*.
    /// 
    /// If *n=2*, *A* is a square matrix. We compute:
    /// 
    ///   *out* = *A*\ :sup:`-1`
    /// 
    /// If *n&gt;2*, *inverse* is performed separately on the trailing two dimensions
    /// for all inputs (batch mode).
    /// 
    /// .. note:: The operator supports float32 and float64 data types only.
    /// 
    /// Examples::
    /// 
    ///    Single matrix inverse
    ///    A = [[1., 4.], [2., 3.]]
    ///    inverse(A) = [[-0.6, 0.8], [0.4, -0.2]]
    /// 
    ///    Batch matrix inverse
    ///    A = [[[1., 4.], [2., 3.]],
    ///         [[1., 3.], [2., 4.]]]
    ///    inverse(A) = [[[-0.6, 0.8], [0.4, -0.2]],
    ///                  [[-2., 1.5], [1., -0.5]]]
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\la_op.cc:L920</summary>
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="A">Tensor of square matrix</param>
    static member LinalgInverse(outputArray : NDArray seq, A : NDArray) =
        let creator = AtomicSymbolCreator.FromName "_linalg_inverse"
        let names = Array.empty
        let vals = Array.empty
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg A)) then A.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <summary>Compute the inverse of a matrix.
    /// Input is a tensor *A* of dimension *n &gt;= 2*.
    /// 
    /// If *n=2*, *A* is a square matrix. We compute:
    /// 
    ///   *out* = *A*\ :sup:`-1`
    /// 
    /// If *n&gt;2*, *inverse* is performed separately on the trailing two dimensions
    /// for all inputs (batch mode).
    /// 
    /// .. note:: The operator supports float32 and float64 data types only.
    /// 
    /// Examples::
    /// 
    ///    Single matrix inverse
    ///    A = [[1., 4.], [2., 3.]]
    ///    inverse(A) = [[-0.6, 0.8], [0.4, -0.2]]
    /// 
    ///    Batch matrix inverse
    ///    A = [[[1., 4.], [2., 3.]],
    ///         [[1., 3.], [2., 4.]]]
    ///    inverse(A) = [[[-0.6, 0.8], [0.4, -0.2]],
    ///                  [[-2., 1.5], [1., -0.5]]]
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\la_op.cc:L920</summary>
    /// <param name="A">Tensor of square matrix</param>
    static member LinalgInverse([<Optional>] ?A : Symbol) =
        LinalgInverse(?A = A)


    /// <summary>Compute the determinant of a matrix.
    /// Input is a tensor *A* of dimension *n &gt;= 2*.
    /// 
    /// If *n=2*, *A* is a square matrix. We compute:
    /// 
    ///   *out* = *det(A)*
    /// 
    /// If *n&gt;2*, *det* is performed separately on the trailing two dimensions
    /// for all inputs (batch mode).
    /// 
    /// .. note:: The operator supports float32 and float64 data types only.
    /// .. note:: There is no gradient backwarded when A is non-invertible (which is
    ///           equivalent to det(A) = 0) because zero is rarely hit upon in float
    ///           point computation and the Jacobi&#39;s formula on determinant gradient
    ///           is not computationally efficient when A is non-invertible.
    /// 
    /// Examples::
    /// 
    ///    Single matrix determinant
    ///    A = [[1., 4.], [2., 3.]]
    ///    det(A) = [-5.]
    /// 
    ///    Batch matrix determinant
    ///    A = [[[1., 4.], [2., 3.]],
    ///         [[2., 3.], [1., 4.]]]
    ///    det(A) = [-5., 5.]
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\la_op.cc:L974</summary>
    /// <param name="A">Tensor of square matrix</param>
    static member LinalgDet(A : NDArray) =
        let creator = AtomicSymbolCreator.FromName "_linalg_det"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg A)) then A.UnsafeHandle|]
                                                 Array.empty
                                                 Array.empty
        (new NDArray(outputs.[0]))
    /// <summary>Compute the determinant of a matrix.
    /// Input is a tensor *A* of dimension *n &gt;= 2*.
    /// 
    /// If *n=2*, *A* is a square matrix. We compute:
    /// 
    ///   *out* = *det(A)*
    /// 
    /// If *n&gt;2*, *det* is performed separately on the trailing two dimensions
    /// for all inputs (batch mode).
    /// 
    /// .. note:: The operator supports float32 and float64 data types only.
    /// .. note:: There is no gradient backwarded when A is non-invertible (which is
    ///           equivalent to det(A) = 0) because zero is rarely hit upon in float
    ///           point computation and the Jacobi&#39;s formula on determinant gradient
    ///           is not computationally efficient when A is non-invertible.
    /// 
    /// Examples::
    /// 
    ///    Single matrix determinant
    ///    A = [[1., 4.], [2., 3.]]
    ///    det(A) = [-5.]
    /// 
    ///    Batch matrix determinant
    ///    A = [[[1., 4.], [2., 3.]],
    ///         [[2., 3.], [1., 4.]]]
    ///    det(A) = [-5., 5.]
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\la_op.cc:L974</summary>
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="A">Tensor of square matrix</param>
    static member LinalgDet(outputArray : NDArray seq, A : NDArray) =
        let creator = AtomicSymbolCreator.FromName "_linalg_det"
        let names = Array.empty
        let vals = Array.empty
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg A)) then A.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <summary>Compute the determinant of a matrix.
    /// Input is a tensor *A* of dimension *n &gt;= 2*.
    /// 
    /// If *n=2*, *A* is a square matrix. We compute:
    /// 
    ///   *out* = *det(A)*
    /// 
    /// If *n&gt;2*, *det* is performed separately on the trailing two dimensions
    /// for all inputs (batch mode).
    /// 
    /// .. note:: The operator supports float32 and float64 data types only.
    /// .. note:: There is no gradient backwarded when A is non-invertible (which is
    ///           equivalent to det(A) = 0) because zero is rarely hit upon in float
    ///           point computation and the Jacobi&#39;s formula on determinant gradient
    ///           is not computationally efficient when A is non-invertible.
    /// 
    /// Examples::
    /// 
    ///    Single matrix determinant
    ///    A = [[1., 4.], [2., 3.]]
    ///    det(A) = [-5.]
    /// 
    ///    Batch matrix determinant
    ///    A = [[[1., 4.], [2., 3.]],
    ///         [[2., 3.], [1., 4.]]]
    ///    det(A) = [-5., 5.]
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\la_op.cc:L974</summary>
    /// <param name="A">Tensor of square matrix</param>
    static member LinalgDet([<Optional>] ?A : Symbol) =
        LinalgDet(?A = A)


    /// <summary>Compute the sign and log of the determinant of a matrix.
    /// Input is a tensor *A* of dimension *n &gt;= 2*.
    /// 
    /// If *n=2*, *A* is a square matrix. We compute:
    /// 
    ///   *sign* = *sign(det(A))*
    ///   *logabsdet* = *log(abs(det(A)))*
    /// 
    /// If *n&gt;2*, *slogdet* is performed separately on the trailing two dimensions
    /// for all inputs (batch mode).
    /// 
    /// .. note:: The operator supports float32 and float64 data types only.
    /// .. note:: The gradient is not properly defined on sign, so the gradient of
    ///           it is not backwarded.
    /// .. note:: No gradient is backwarded when A is non-invertible. Please see
    ///           the docs of operator det for detail.
    /// 
    /// Examples::
    /// 
    ///    Single matrix signed log determinant
    ///    A = [[2., 3.], [1., 4.]]
    ///    sign, logabsdet = slogdet(A)
    ///    sign = [1.]
    ///    logabsdet = [1.609438]
    /// 
    ///    Batch matrix signed log determinant
    ///    A = [[[2., 3.], [1., 4.]],
    ///         [[1., 2.], [2., 4.]],
    ///         [[1., 2.], [4., 3.]]]
    ///    sign, logabsdet = slogdet(A)
    ///    sign = [1., 0., -1.]
    ///    logabsdet = [1.609438, -inf, 1.609438]
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\la_op.cc:L1032</summary>
    /// <param name="A">Tensor of square matrix</param>
    static member LinalgSlogdet(A : NDArray) =
        let creator = AtomicSymbolCreator.FromName "_linalg_slogdet"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg A)) then A.UnsafeHandle|]
                                                 Array.empty
                                                 Array.empty
        (new NDArray(outputs.[0])), (new NDArray(outputs.[1]))
    /// <summary>Compute the sign and log of the determinant of a matrix.
    /// Input is a tensor *A* of dimension *n &gt;= 2*.
    /// 
    /// If *n=2*, *A* is a square matrix. We compute:
    /// 
    ///   *sign* = *sign(det(A))*
    ///   *logabsdet* = *log(abs(det(A)))*
    /// 
    /// If *n&gt;2*, *slogdet* is performed separately on the trailing two dimensions
    /// for all inputs (batch mode).
    /// 
    /// .. note:: The operator supports float32 and float64 data types only.
    /// .. note:: The gradient is not properly defined on sign, so the gradient of
    ///           it is not backwarded.
    /// .. note:: No gradient is backwarded when A is non-invertible. Please see
    ///           the docs of operator det for detail.
    /// 
    /// Examples::
    /// 
    ///    Single matrix signed log determinant
    ///    A = [[2., 3.], [1., 4.]]
    ///    sign, logabsdet = slogdet(A)
    ///    sign = [1.]
    ///    logabsdet = [1.609438]
    /// 
    ///    Batch matrix signed log determinant
    ///    A = [[[2., 3.], [1., 4.]],
    ///         [[1., 2.], [2., 4.]],
    ///         [[1., 2.], [4., 3.]]]
    ///    sign, logabsdet = slogdet(A)
    ///    sign = [1., 0., -1.]
    ///    logabsdet = [1.609438, -inf, 1.609438]
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\la_op.cc:L1032</summary>
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="A">Tensor of square matrix</param>
    static member LinalgSlogdet(outputArray : NDArray seq, A : NDArray) =
        let creator = AtomicSymbolCreator.FromName "_linalg_slogdet"
        let names = Array.empty
        let vals = Array.empty
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg A)) then A.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <summary>Compute the sign and log of the determinant of a matrix.
    /// Input is a tensor *A* of dimension *n &gt;= 2*.
    /// 
    /// If *n=2*, *A* is a square matrix. We compute:
    /// 
    ///   *sign* = *sign(det(A))*
    ///   *logabsdet* = *log(abs(det(A)))*
    /// 
    /// If *n&gt;2*, *slogdet* is performed separately on the trailing two dimensions
    /// for all inputs (batch mode).
    /// 
    /// .. note:: The operator supports float32 and float64 data types only.
    /// .. note:: The gradient is not properly defined on sign, so the gradient of
    ///           it is not backwarded.
    /// .. note:: No gradient is backwarded when A is non-invertible. Please see
    ///           the docs of operator det for detail.
    /// 
    /// Examples::
    /// 
    ///    Single matrix signed log determinant
    ///    A = [[2., 3.], [1., 4.]]
    ///    sign, logabsdet = slogdet(A)
    ///    sign = [1.]
    ///    logabsdet = [1.609438]
    /// 
    ///    Batch matrix signed log determinant
    ///    A = [[[2., 3.], [1., 4.]],
    ///         [[1., 2.], [2., 4.]],
    ///         [[1., 2.], [4., 3.]]]
    ///    sign, logabsdet = slogdet(A)
    ///    sign = [1., 0., -1.]
    ///    logabsdet = [1.609438, -inf, 1.609438]
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\la_op.cc:L1032</summary>
    /// <param name="A">Tensor of square matrix</param>
    static member LinalgSlogdet([<Optional>] ?A : Symbol) =
        LinalgSlogdet(?A = A)


    /// <summary>Reshapes the input array.
    /// .. note:: ``Reshape`` is deprecated, use ``reshape``
    /// Given an array and a shape, this function returns a copy of the array in the new shape.
    /// The shape is a tuple of integers such as (2,3,4). The size of the new shape should be same as the size of the input array.
    /// Example::
    ///   reshape([1,2,3,4], shape=(2,2)) = [[1,2], [3,4]]
    /// Some dimensions of the shape can take special values from the set {0, -1, -2, -3, -4}. The significance of each is explained below:
    /// - ``0``  copy this dimension from the input to the output shape.
    ///   Example::
    ///   - input shape = (2,3,4), shape = (4,0,2), output shape = (4,3,2)
    ///   - input shape = (2,3,4), shape = (2,0,0), output shape = (2,3,4)
    /// - ``-1`` infers the dimension of the output shape by using the remainder of the input dimensions
    ///   keeping the size of the new array same as that of the input array.
    ///   At most one dimension of shape can be -1.
    ///   Example::
    ///   - input shape = (2,3,4), shape = (6,1,-1), output shape = (6,1,4)
    ///   - input shape = (2,3,4), shape = (3,-1,8), output shape = (3,1,8)
    ///   - input shape = (2,3,4), shape=(-1,), output shape = (24,)
    /// - ``-2`` copy all/remainder of the input dimensions to the output shape.
    ///   Example::
    ///   - input shape = (2,3,4), shape = (-2,), output shape = (2,3,4)
    ///   - input shape = (2,3,4), shape = (2,-2), output shape = (2,3,4)
    ///   - input shape = (2,3,4), shape = (-2,1,1), output shape = (2,3,4,1,1)
    /// - ``-3`` use the product of two consecutive dimensions of the input shape as the output dimension.
    ///   Example::
    ///   - input shape = (2,3,4), shape = (-3,4), output shape = (6,4)
    ///   - input shape = (2,3,4,5), shape = (-3,-3), output shape = (6,20)
    ///   - input shape = (2,3,4), shape = (0,-3), output shape = (2,12)
    ///   - input shape = (2,3,4), shape = (-3,-2), output shape = (6,4)
    /// - ``-4`` split one dimension of the input into two dimensions passed subsequent to -4 in shape (can contain -1).
    ///   Example::
    ///   - input shape = (2,3,4), shape = (-4,1,2,-2), output shape =(1,2,3,4)
    ///   - input shape = (2,3,4), shape = (2,-4,-1,3,-2), output shape = (2,1,3,4)
    /// If the argument `reverse` is set to 1, then the special values are inferred from right to left.
    ///   Example::
    ///   - without reverse=1, for input shape = (10,5,4), shape = (-1,0), output shape would be (40,5)
    ///   - with reverse=1, output shape will be (50,4).
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\matrix_op.cc:L175</summary>
    /// <param name="data">Input data to reshape.</param>
    /// <param name="shape">The target shape</param>
    /// <param name="reverse">If true then the special values are inferred from right to left</param>
    /// <param name="targetShape">(Deprecated! Use ``shape`` instead.) Target new shape. One and only one dim can be 0, in which case it will be inferred from the rest of dims</param>
    /// <param name="keepHighest">(Deprecated! Use ``shape`` instead.) Whether keep the highest dim unchanged.If set to true, then the first dim in target_shape is ignored,and always fixed as input</param>
    static member Reshape(data : NDArray, 
                          [<Optional>] shape : int seq, 
                          [<Optional; DefaultParameterValue(false)>] reverse : bool, 
                          [<Optional>] targetShape : int seq, 
                          [<Optional; DefaultParameterValue(false)>] keepHighest : bool) =
        let creator = AtomicSymbolCreator.FromName "Reshape"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle|]
                                                 [|"shape"; "reverse"; "target_shape"; "keep_highest"|]
                                                 [|(if isNull (shape :> obj) then "[]" else (shape |> Seq.map string |> String.concat ", " |> sprintf "[%s]")); string reverse; (if isNull (targetShape :> obj) then "[]" else (targetShape |> Seq.map string |> String.concat ", " |> sprintf "[%s]")); string keepHighest|]
        (new NDArray(outputs.[0]))
    /// <summary>Reshapes the input array.
    /// .. note:: ``Reshape`` is deprecated, use ``reshape``
    /// Given an array and a shape, this function returns a copy of the array in the new shape.
    /// The shape is a tuple of integers such as (2,3,4). The size of the new shape should be same as the size of the input array.
    /// Example::
    ///   reshape([1,2,3,4], shape=(2,2)) = [[1,2], [3,4]]
    /// Some dimensions of the shape can take special values from the set {0, -1, -2, -3, -4}. The significance of each is explained below:
    /// - ``0``  copy this dimension from the input to the output shape.
    ///   Example::
    ///   - input shape = (2,3,4), shape = (4,0,2), output shape = (4,3,2)
    ///   - input shape = (2,3,4), shape = (2,0,0), output shape = (2,3,4)
    /// - ``-1`` infers the dimension of the output shape by using the remainder of the input dimensions
    ///   keeping the size of the new array same as that of the input array.
    ///   At most one dimension of shape can be -1.
    ///   Example::
    ///   - input shape = (2,3,4), shape = (6,1,-1), output shape = (6,1,4)
    ///   - input shape = (2,3,4), shape = (3,-1,8), output shape = (3,1,8)
    ///   - input shape = (2,3,4), shape=(-1,), output shape = (24,)
    /// - ``-2`` copy all/remainder of the input dimensions to the output shape.
    ///   Example::
    ///   - input shape = (2,3,4), shape = (-2,), output shape = (2,3,4)
    ///   - input shape = (2,3,4), shape = (2,-2), output shape = (2,3,4)
    ///   - input shape = (2,3,4), shape = (-2,1,1), output shape = (2,3,4,1,1)
    /// - ``-3`` use the product of two consecutive dimensions of the input shape as the output dimension.
    ///   Example::
    ///   - input shape = (2,3,4), shape = (-3,4), output shape = (6,4)
    ///   - input shape = (2,3,4,5), shape = (-3,-3), output shape = (6,20)
    ///   - input shape = (2,3,4), shape = (0,-3), output shape = (2,12)
    ///   - input shape = (2,3,4), shape = (-3,-2), output shape = (6,4)
    /// - ``-4`` split one dimension of the input into two dimensions passed subsequent to -4 in shape (can contain -1).
    ///   Example::
    ///   - input shape = (2,3,4), shape = (-4,1,2,-2), output shape =(1,2,3,4)
    ///   - input shape = (2,3,4), shape = (2,-4,-1,3,-2), output shape = (2,1,3,4)
    /// If the argument `reverse` is set to 1, then the special values are inferred from right to left.
    ///   Example::
    ///   - without reverse=1, for input shape = (10,5,4), shape = (-1,0), output shape would be (40,5)
    ///   - with reverse=1, output shape will be (50,4).
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\matrix_op.cc:L175</summary>
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="data">Input data to reshape.</param>
    /// <param name="shape">The target shape</param>
    /// <param name="reverse">If true then the special values are inferred from right to left</param>
    /// <param name="targetShape">(Deprecated! Use ``shape`` instead.) Target new shape. One and only one dim can be 0, in which case it will be inferred from the rest of dims</param>
    /// <param name="keepHighest">(Deprecated! Use ``shape`` instead.) Whether keep the highest dim unchanged.If set to true, then the first dim in target_shape is ignored,and always fixed as input</param>
    static member Reshape(outputArray : NDArray seq, 
                          data : NDArray, 
                          [<Optional>] shape : int seq, 
                          [<Optional; DefaultParameterValue(false)>] reverse : bool, 
                          [<Optional>] targetShape : int seq, 
                          [<Optional; DefaultParameterValue(false)>] keepHighest : bool) =
        let creator = AtomicSymbolCreator.FromName "Reshape"
        let names = [|"shape"; "reverse"; "target_shape"; "keep_highest"|]
        let vals = [|(if isNull (shape :> obj) then "[]" else (shape |> Seq.map string |> String.concat ", " |> sprintf "[%s]")); string reverse; (if isNull (targetShape :> obj) then "[]" else (targetShape |> Seq.map string |> String.concat ", " |> sprintf "[%s]")); string keepHighest|]
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <summary>Reshapes the input array.
    /// .. note:: ``Reshape`` is deprecated, use ``reshape``
    /// Given an array and a shape, this function returns a copy of the array in the new shape.
    /// The shape is a tuple of integers such as (2,3,4). The size of the new shape should be same as the size of the input array.
    /// Example::
    ///   reshape([1,2,3,4], shape=(2,2)) = [[1,2], [3,4]]
    /// Some dimensions of the shape can take special values from the set {0, -1, -2, -3, -4}. The significance of each is explained below:
    /// - ``0``  copy this dimension from the input to the output shape.
    ///   Example::
    ///   - input shape = (2,3,4), shape = (4,0,2), output shape = (4,3,2)
    ///   - input shape = (2,3,4), shape = (2,0,0), output shape = (2,3,4)
    /// - ``-1`` infers the dimension of the output shape by using the remainder of the input dimensions
    ///   keeping the size of the new array same as that of the input array.
    ///   At most one dimension of shape can be -1.
    ///   Example::
    ///   - input shape = (2,3,4), shape = (6,1,-1), output shape = (6,1,4)
    ///   - input shape = (2,3,4), shape = (3,-1,8), output shape = (3,1,8)
    ///   - input shape = (2,3,4), shape=(-1,), output shape = (24,)
    /// - ``-2`` copy all/remainder of the input dimensions to the output shape.
    ///   Example::
    ///   - input shape = (2,3,4), shape = (-2,), output shape = (2,3,4)
    ///   - input shape = (2,3,4), shape = (2,-2), output shape = (2,3,4)
    ///   - input shape = (2,3,4), shape = (-2,1,1), output shape = (2,3,4,1,1)
    /// - ``-3`` use the product of two consecutive dimensions of the input shape as the output dimension.
    ///   Example::
    ///   - input shape = (2,3,4), shape = (-3,4), output shape = (6,4)
    ///   - input shape = (2,3,4,5), shape = (-3,-3), output shape = (6,20)
    ///   - input shape = (2,3,4), shape = (0,-3), output shape = (2,12)
    ///   - input shape = (2,3,4), shape = (-3,-2), output shape = (6,4)
    /// - ``-4`` split one dimension of the input into two dimensions passed subsequent to -4 in shape (can contain -1).
    ///   Example::
    ///   - input shape = (2,3,4), shape = (-4,1,2,-2), output shape =(1,2,3,4)
    ///   - input shape = (2,3,4), shape = (2,-4,-1,3,-2), output shape = (2,1,3,4)
    /// If the argument `reverse` is set to 1, then the special values are inferred from right to left.
    ///   Example::
    ///   - without reverse=1, for input shape = (10,5,4), shape = (-1,0), output shape would be (40,5)
    ///   - with reverse=1, output shape will be (50,4).
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\matrix_op.cc:L175</summary>
    /// <param name="data">Input data to reshape.</param>
    /// <param name="shape">The target shape</param>
    /// <param name="reverse">If true then the special values are inferred from right to left</param>
    /// <param name="targetShape">(Deprecated! Use ``shape`` instead.) Target new shape. One and only one dim can be 0, in which case it will be inferred from the rest of dims</param>
    /// <param name="keepHighest">(Deprecated! Use ``shape`` instead.) Whether keep the highest dim unchanged.If set to true, then the first dim in target_shape is ignored,and always fixed as input</param>
    static member Reshape([<Optional>] ?data : Symbol, [<Optional>] ?shape : int seq, [<Optional>] ?reverse : bool, [<Optional>] ?targetShape : int seq, [<Optional>] ?keepHighest : bool) =
        Reshape(?data = data, ?shape = shape, ?reverse = reverse, ?targetShape = targetShape, ?keepHighest = keepHighest)

    /// <summary>Permutes the dimensions of an array.
    /// Examples::
    ///   x = [[ 1, 2],
    ///        [ 3, 4]]
    ///   transpose(x) = [[ 1.,  3.],
    ///                   [ 2.,  4.]]
    ///   x = [[[ 1.,  2.],
    ///         [ 3.,  4.]],
    ///        [[ 5.,  6.],
    ///         [ 7.,  8.]]]
    ///   transpose(x) = [[[ 1.,  5.],
    ///                    [ 3.,  7.]],
    ///                   [[ 2.,  6.],
    ///                    [ 4.,  8.]]]
    ///   transpose(x, axes=(1,0,2)) = [[[ 1.,  2.],
    ///                                  [ 5.,  6.]],
    ///                                 [[ 3.,  4.],
    ///                                  [ 7.,  8.]]]
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\matrix_op.cc:L327</summary>
    /// <param name="data">Source input</param>
    /// <param name="axes">Target axis order. By default the axes will be inverted.</param>
    static member Transpose(data : NDArray, [<Optional>] axes : int seq) =
        let creator = AtomicSymbolCreator.FromName "transpose"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle|]
                                                 [|"axes"|]
                                                 [|(if isNull (axes :> obj) then "[]" else (axes |> Seq.map string |> String.concat ", " |> sprintf "[%s]"))|]
        (new NDArray(outputs.[0]))
    /// <summary>Permutes the dimensions of an array.
    /// Examples::
    ///   x = [[ 1, 2],
    ///        [ 3, 4]]
    ///   transpose(x) = [[ 1.,  3.],
    ///                   [ 2.,  4.]]
    ///   x = [[[ 1.,  2.],
    ///         [ 3.,  4.]],
    ///        [[ 5.,  6.],
    ///         [ 7.,  8.]]]
    ///   transpose(x) = [[[ 1.,  5.],
    ///                    [ 3.,  7.]],
    ///                   [[ 2.,  6.],
    ///                    [ 4.,  8.]]]
    ///   transpose(x, axes=(1,0,2)) = [[[ 1.,  2.],
    ///                                  [ 5.,  6.]],
    ///                                 [[ 3.,  4.],
    ///                                  [ 7.,  8.]]]
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\matrix_op.cc:L327</summary>
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="data">Source input</param>
    /// <param name="axes">Target axis order. By default the axes will be inverted.</param>
    static member Transpose(outputArray : NDArray seq, data : NDArray, [<Optional>] axes : int seq) =
        let creator = AtomicSymbolCreator.FromName "transpose"
        let names = [|"axes"|]
        let vals = [|(if isNull (axes :> obj) then "[]" else (axes |> Seq.map string |> String.concat ", " |> sprintf "[%s]"))|]
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <summary>Permutes the dimensions of an array.
    /// Examples::
    ///   x = [[ 1, 2],
    ///        [ 3, 4]]
    ///   transpose(x) = [[ 1.,  3.],
    ///                   [ 2.,  4.]]
    ///   x = [[[ 1.,  2.],
    ///         [ 3.,  4.]],
    ///        [[ 5.,  6.],
    ///         [ 7.,  8.]]]
    ///   transpose(x) = [[[ 1.,  5.],
    ///                    [ 3.,  7.]],
    ///                   [[ 2.,  6.],
    ///                    [ 4.,  8.]]]
    ///   transpose(x, axes=(1,0,2)) = [[[ 1.,  2.],
    ///                                  [ 5.,  6.]],
    ///                                 [[ 3.,  4.],
    ///                                  [ 7.,  8.]]]
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\matrix_op.cc:L327</summary>
    /// <param name="data">Source input</param>
    /// <param name="axes">Target axis order. By default the axes will be inverted.</param>
    static member Transpose([<Optional>] ?data : Symbol, [<Optional>] ?axes : int seq) =
        Transpose(?data = data, ?axes = axes)

    /// <summary>Inserts a new axis of size 1 into the array shape
    /// For example, given ``x`` with shape ``(2,3,4)``, then ``expand_dims(x, axis=1)``
    /// will return a new array with shape ``(2,1,3,4)``.
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\matrix_op.cc:L394</summary>
    /// <param name="data">Source input</param>
    /// <param name="axis">Position where new axis is to be inserted. Suppose that the input `NDArray`&#39;s dimension is `ndim`, the range of the inserted axis is `[-ndim, ndim]`</param>
    static member ExpandDims(data : NDArray, axis : int) =
        let creator = AtomicSymbolCreator.FromName "expand_dims"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle|]
                                                 [|"axis"|]
                                                 [|string axis|]
        (new NDArray(outputs.[0]))
    /// <summary>Inserts a new axis of size 1 into the array shape
    /// For example, given ``x`` with shape ``(2,3,4)``, then ``expand_dims(x, axis=1)``
    /// will return a new array with shape ``(2,1,3,4)``.
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\matrix_op.cc:L394</summary>
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="data">Source input</param>
    /// <param name="axis">Position where new axis is to be inserted. Suppose that the input `NDArray`&#39;s dimension is `ndim`, the range of the inserted axis is `[-ndim, ndim]`</param>
    static member ExpandDims(outputArray : NDArray seq, data : NDArray, axis : int) =
        let creator = AtomicSymbolCreator.FromName "expand_dims"
        let names = [|"axis"|]
        let vals = [|string axis|]
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <summary>Inserts a new axis of size 1 into the array shape
    /// For example, given ``x`` with shape ``(2,3,4)``, then ``expand_dims(x, axis=1)``
    /// will return a new array with shape ``(2,1,3,4)``.
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\matrix_op.cc:L394</summary>
    /// <param name="data">Source input</param>
    /// <param name="axis">Position where new axis is to be inserted. Suppose that the input `NDArray`&#39;s dimension is `ndim`, the range of the inserted axis is `[-ndim, ndim]`</param>
    static member ExpandDims(data : Symbol, axis : int) =
        ExpandDims(data, axis)
    /// <summary>Inserts a new axis of size 1 into the array shape
    /// For example, given ``x`` with shape ``(2,3,4)``, then ``expand_dims(x, axis=1)``
    /// will return a new array with shape ``(2,1,3,4)``.
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\matrix_op.cc:L394</summary>
    /// <param name="axis">Position where new axis is to be inserted. Suppose that the input `NDArray`&#39;s dimension is `ndim`, the range of the inserted axis is `[-ndim, ndim]`</param>
    /// <param name="data">Source input</param>
    static member ExpandDims(axis : int, [<Optional>] ?data : Symbol) =
        ExpandDims(axis, ?data = data)

    /// <summary>Slices a region of the array.
    /// .. note:: ``crop`` is deprecated. Use ``slice`` instead.
    /// This function returns a sliced array between the indices given
    /// by `begin` and `end` with the corresponding `step`.
    /// For an input array of ``shape=(d_0, d_1, ..., d_n-1)``,
    /// slice operation with ``begin=(b_0, b_1...b_m-1)``,
    /// ``end=(e_0, e_1, ..., e_m-1)``, and ``step=(s_0, s_1, ..., s_m-1)``,
    /// where m &lt;= n, results in an array with the shape
    /// ``(|e_0-b_0|/|s_0|, ..., |e_m-1-b_m-1|/|s_m-1|, d_m, ..., d_n-1)``.
    /// The resulting array&#39;s *k*-th dimension contains elements
    /// from the *k*-th dimension of the input array starting
    /// from index ``b_k`` (inclusive) with step ``s_k``
    /// until reaching ``e_k`` (exclusive).
    /// If the *k*-th elements are `None` in the sequence of `begin`, `end`,
    /// and `step`, the following rule will be used to set default values.
    /// If `s_k` is `None`, set `s_k=1`. If `s_k &gt; 0`, set `b_k=0`, `e_k=d_k`;
    /// else, set `b_k=d_k-1`, `e_k=-1`.
    /// The storage type of ``slice`` output depends on storage types of inputs
    /// - slice(csr) = csr
    /// - otherwise, ``slice`` generates output with default storage
    /// .. note:: When input data storage type is csr, it only supports
    ///    step=(), or step=(None,), or step=(1,) to generate a csr output.
    ///    For other step parameter values, it falls back to slicing
    ///    a dense tensor.
    /// Example::
    ///   x = [[  1.,   2.,   3.,   4.],
    ///        [  5.,   6.,   7.,   8.],
    ///        [  9.,  10.,  11.,  12.]]
    ///   slice(x, begin=(0,1), end=(2,4)) = [[ 2.,  3.,  4.],
    ///                                      [ 6.,  7.,  8.]]
    ///   slice(x, begin=(None, 0), end=(None, 3), step=(-1, 2)) = [[9., 11.],
    ///                                                             [5.,  7.],
    ///                                                             [1.,  3.]]
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\matrix_op.cc:L481</summary>
    /// <param name="data">Source input</param>
    /// <param name="sliceBegin">starting indices for the slice operation, supports negative indices.</param>
    /// <param name="sliceEnd">ending indices for the slice operation, supports negative indices.</param>
    /// <param name="step">step for the slice operation, supports negative values.</param>
    static member Slice(data : NDArray, sliceBegin : int option seq, sliceEnd : int option seq, [<Optional>] step : int option seq) =
        let creator = AtomicSymbolCreator.FromName "slice"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle|]
                                                 [|"begin"; "end"; "step"|]
                                                 [|string sliceBegin; string sliceEnd; (if isNull (step :> obj) then "[]" else string step)|]
        outputs |> Array.map (fun h -> new NDArray(h))
    /// <summary>Slices a region of the array.
    /// .. note:: ``crop`` is deprecated. Use ``slice`` instead.
    /// This function returns a sliced array between the indices given
    /// by `begin` and `end` with the corresponding `step`.
    /// For an input array of ``shape=(d_0, d_1, ..., d_n-1)``,
    /// slice operation with ``begin=(b_0, b_1...b_m-1)``,
    /// ``end=(e_0, e_1, ..., e_m-1)``, and ``step=(s_0, s_1, ..., s_m-1)``,
    /// where m &lt;= n, results in an array with the shape
    /// ``(|e_0-b_0|/|s_0|, ..., |e_m-1-b_m-1|/|s_m-1|, d_m, ..., d_n-1)``.
    /// The resulting array&#39;s *k*-th dimension contains elements
    /// from the *k*-th dimension of the input array starting
    /// from index ``b_k`` (inclusive) with step ``s_k``
    /// until reaching ``e_k`` (exclusive).
    /// If the *k*-th elements are `None` in the sequence of `begin`, `end`,
    /// and `step`, the following rule will be used to set default values.
    /// If `s_k` is `None`, set `s_k=1`. If `s_k &gt; 0`, set `b_k=0`, `e_k=d_k`;
    /// else, set `b_k=d_k-1`, `e_k=-1`.
    /// The storage type of ``slice`` output depends on storage types of inputs
    /// - slice(csr) = csr
    /// - otherwise, ``slice`` generates output with default storage
    /// .. note:: When input data storage type is csr, it only supports
    ///    step=(), or step=(None,), or step=(1,) to generate a csr output.
    ///    For other step parameter values, it falls back to slicing
    ///    a dense tensor.
    /// Example::
    ///   x = [[  1.,   2.,   3.,   4.],
    ///        [  5.,   6.,   7.,   8.],
    ///        [  9.,  10.,  11.,  12.]]
    ///   slice(x, begin=(0,1), end=(2,4)) = [[ 2.,  3.,  4.],
    ///                                      [ 6.,  7.,  8.]]
    ///   slice(x, begin=(None, 0), end=(None, 3), step=(-1, 2)) = [[9., 11.],
    ///                                                             [5.,  7.],
    ///                                                             [1.,  3.]]
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\matrix_op.cc:L481</summary>
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="data">Source input</param>
    /// <param name="sliceBegin">starting indices for the slice operation, supports negative indices.</param>
    /// <param name="sliceEnd">ending indices for the slice operation, supports negative indices.</param>
    /// <param name="step">step for the slice operation, supports negative values.</param>
    static member Slice(outputArray : NDArray seq, data : NDArray, sliceBegin : int option seq, sliceEnd : int option seq, [<Optional>] step : int option seq) =
        let creator = AtomicSymbolCreator.FromName "slice"
        let names = [|"begin"; "end"; "step"|]
        let vals = [|string sliceBegin; string sliceEnd; (if isNull (step :> obj) then "[]" else string step)|]
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <summary>Slices a region of the array.
    /// .. note:: ``crop`` is deprecated. Use ``slice`` instead.
    /// This function returns a sliced array between the indices given
    /// by `begin` and `end` with the corresponding `step`.
    /// For an input array of ``shape=(d_0, d_1, ..., d_n-1)``,
    /// slice operation with ``begin=(b_0, b_1...b_m-1)``,
    /// ``end=(e_0, e_1, ..., e_m-1)``, and ``step=(s_0, s_1, ..., s_m-1)``,
    /// where m &lt;= n, results in an array with the shape
    /// ``(|e_0-b_0|/|s_0|, ..., |e_m-1-b_m-1|/|s_m-1|, d_m, ..., d_n-1)``.
    /// The resulting array&#39;s *k*-th dimension contains elements
    /// from the *k*-th dimension of the input array starting
    /// from index ``b_k`` (inclusive) with step ``s_k``
    /// until reaching ``e_k`` (exclusive).
    /// If the *k*-th elements are `None` in the sequence of `begin`, `end`,
    /// and `step`, the following rule will be used to set default values.
    /// If `s_k` is `None`, set `s_k=1`. If `s_k &gt; 0`, set `b_k=0`, `e_k=d_k`;
    /// else, set `b_k=d_k-1`, `e_k=-1`.
    /// The storage type of ``slice`` output depends on storage types of inputs
    /// - slice(csr) = csr
    /// - otherwise, ``slice`` generates output with default storage
    /// .. note:: When input data storage type is csr, it only supports
    ///    step=(), or step=(None,), or step=(1,) to generate a csr output.
    ///    For other step parameter values, it falls back to slicing
    ///    a dense tensor.
    /// Example::
    ///   x = [[  1.,   2.,   3.,   4.],
    ///        [  5.,   6.,   7.,   8.],
    ///        [  9.,  10.,  11.,  12.]]
    ///   slice(x, begin=(0,1), end=(2,4)) = [[ 2.,  3.,  4.],
    ///                                      [ 6.,  7.,  8.]]
    ///   slice(x, begin=(None, 0), end=(None, 3), step=(-1, 2)) = [[9., 11.],
    ///                                                             [5.,  7.],
    ///                                                             [1.,  3.]]
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\matrix_op.cc:L481</summary>
    /// <param name="data">Source input</param>
    /// <param name="sliceBegin">starting indices for the slice operation, supports negative indices.</param>
    /// <param name="sliceEnd">ending indices for the slice operation, supports negative indices.</param>
    /// <param name="step">step for the slice operation, supports negative values.</param>
    static member Slice(data : Symbol, sliceBegin : int option seq, sliceEnd : int option seq, [<Optional>] ?step : int option seq) =
        Slice(data, sliceBegin, sliceEnd, ?step = step)
    /// <summary>Slices a region of the array.
    /// .. note:: ``crop`` is deprecated. Use ``slice`` instead.
    /// This function returns a sliced array between the indices given
    /// by `begin` and `end` with the corresponding `step`.
    /// For an input array of ``shape=(d_0, d_1, ..., d_n-1)``,
    /// slice operation with ``begin=(b_0, b_1...b_m-1)``,
    /// ``end=(e_0, e_1, ..., e_m-1)``, and ``step=(s_0, s_1, ..., s_m-1)``,
    /// where m &lt;= n, results in an array with the shape
    /// ``(|e_0-b_0|/|s_0|, ..., |e_m-1-b_m-1|/|s_m-1|, d_m, ..., d_n-1)``.
    /// The resulting array&#39;s *k*-th dimension contains elements
    /// from the *k*-th dimension of the input array starting
    /// from index ``b_k`` (inclusive) with step ``s_k``
    /// until reaching ``e_k`` (exclusive).
    /// If the *k*-th elements are `None` in the sequence of `begin`, `end`,
    /// and `step`, the following rule will be used to set default values.
    /// If `s_k` is `None`, set `s_k=1`. If `s_k &gt; 0`, set `b_k=0`, `e_k=d_k`;
    /// else, set `b_k=d_k-1`, `e_k=-1`.
    /// The storage type of ``slice`` output depends on storage types of inputs
    /// - slice(csr) = csr
    /// - otherwise, ``slice`` generates output with default storage
    /// .. note:: When input data storage type is csr, it only supports
    ///    step=(), or step=(None,), or step=(1,) to generate a csr output.
    ///    For other step parameter values, it falls back to slicing
    ///    a dense tensor.
    /// Example::
    ///   x = [[  1.,   2.,   3.,   4.],
    ///        [  5.,   6.,   7.,   8.],
    ///        [  9.,  10.,  11.,  12.]]
    ///   slice(x, begin=(0,1), end=(2,4)) = [[ 2.,  3.,  4.],
    ///                                      [ 6.,  7.,  8.]]
    ///   slice(x, begin=(None, 0), end=(None, 3), step=(-1, 2)) = [[9., 11.],
    ///                                                             [5.,  7.],
    ///                                                             [1.,  3.]]
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\matrix_op.cc:L481</summary>
    /// <param name="sliceBegin">starting indices for the slice operation, supports negative indices.</param>
    /// <param name="sliceEnd">ending indices for the slice operation, supports negative indices.</param>
    /// <param name="data">Source input</param>
    /// <param name="step">step for the slice operation, supports negative values.</param>
    static member Slice(sliceBegin : int option seq, sliceEnd : int option seq, [<Optional>] ?data : Symbol, [<Optional>] ?step : int option seq) =
        Slice(sliceBegin, sliceEnd, ?data = data, ?step = step)


    /// <summary>Assign the rhs to a cropped subset of lhs.
    /// 
    /// Requirements
    /// ------------
    /// - output should be explicitly given and be the same as lhs.
    /// - lhs and rhs are of the same data type, and on the same device.
    /// 
    /// 
    /// From:C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\matrix_op.cc:514</summary>
    /// <param name="lhs">Source input</param>
    /// <param name="rhs">value to assign</param>
    /// <param name="sliceBegin">starting indices for the slice operation, supports negative indices.</param>
    /// <param name="sliceEnd">ending indices for the slice operation, supports negative indices.</param>
    /// <param name="step">step for the slice operation, supports negative values.</param>
    static member SliceAssign(lhs : NDArray, 
                              rhs : NDArray, 
                              sliceBegin : int option seq, 
                              sliceEnd : int option seq, 
                              [<Optional>] step : int option seq) =
        let creator = AtomicSymbolCreator.FromName "_slice_assign"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg lhs)) then lhs.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg rhs)) then rhs.UnsafeHandle|]
                                                 [|"begin"; "end"; "step"|]
                                                 [|string sliceBegin; string sliceEnd; (if isNull (step :> obj) then "[]" else string step)|]
        (new NDArray(outputs.[0]))
    /// <summary>Assign the rhs to a cropped subset of lhs.
    /// 
    /// Requirements
    /// ------------
    /// - output should be explicitly given and be the same as lhs.
    /// - lhs and rhs are of the same data type, and on the same device.
    /// 
    /// 
    /// From:C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\matrix_op.cc:514</summary>
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="lhs">Source input</param>
    /// <param name="rhs">value to assign</param>
    /// <param name="sliceBegin">starting indices for the slice operation, supports negative indices.</param>
    /// <param name="sliceEnd">ending indices for the slice operation, supports negative indices.</param>
    /// <param name="step">step for the slice operation, supports negative values.</param>
    static member SliceAssign(outputArray : NDArray seq, 
                              lhs : NDArray, 
                              rhs : NDArray, 
                              sliceBegin : int option seq, 
                              sliceEnd : int option seq, 
                              [<Optional>] step : int option seq) =
        let creator = AtomicSymbolCreator.FromName "_slice_assign"
        let names = [|"begin"; "end"; "step"|]
        let vals = [|string sliceBegin; string sliceEnd; (if isNull (step :> obj) then "[]" else string step)|]
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg lhs)) then lhs.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg rhs)) then rhs.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <summary>Assign the rhs to a cropped subset of lhs.
    /// 
    /// Requirements
    /// ------------
    /// - output should be explicitly given and be the same as lhs.
    /// - lhs and rhs are of the same data type, and on the same device.
    /// 
    /// 
    /// From:C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\matrix_op.cc:514</summary>
    /// <param name="lhs">Source input</param>
    /// <param name="rhs">value to assign</param>
    /// <param name="sliceBegin">starting indices for the slice operation, supports negative indices.</param>
    /// <param name="sliceEnd">ending indices for the slice operation, supports negative indices.</param>
    /// <param name="step">step for the slice operation, supports negative values.</param>
    static member SliceAssign(lhs : Symbol, rhs : Symbol, sliceBegin : int option seq, sliceEnd : int option seq, [<Optional>] ?step : int option seq) =
        SliceAssign(lhs, rhs, sliceBegin, sliceEnd, ?step = step)
    /// <summary>Assign the rhs to a cropped subset of lhs.
    /// 
    /// Requirements
    /// ------------
    /// - output should be explicitly given and be the same as lhs.
    /// - lhs and rhs are of the same data type, and on the same device.
    /// 
    /// 
    /// From:C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\matrix_op.cc:514</summary>
    /// <param name="sliceBegin">starting indices for the slice operation, supports negative indices.</param>
    /// <param name="sliceEnd">ending indices for the slice operation, supports negative indices.</param>
    /// <param name="lhs">Source input</param>
    /// <param name="rhs">value to assign</param>
    /// <param name="step">step for the slice operation, supports negative values.</param>
    static member SliceAssign(sliceBegin : int option seq, sliceEnd : int option seq, [<Optional>] ?lhs : Symbol, [<Optional>] ?rhs : Symbol, [<Optional>] ?step : int option seq) =
        SliceAssign(sliceBegin, sliceEnd, ?lhs = lhs, ?rhs = rhs, ?step = step)

    /// <summary>(Assign the scalar to a cropped subset of the input.
    /// 
    /// Requirements
    /// ------------
    /// - output should be explicitly given and be the same as input
    /// )
    /// 
    /// From:C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\matrix_op.cc:540</summary>
    /// <param name="data">Source input</param>
    /// <param name="sliceBegin">starting indices for the slice operation, supports negative indices.</param>
    /// <param name="sliceEnd">ending indices for the slice operation, supports negative indices.</param>
    /// <param name="scalar">The scalar value for assignment.</param>
    /// <param name="step">step for the slice operation, supports negative values.</param>
    static member SliceAssignScalar(data : NDArray, 
                                    sliceBegin : int option seq, 
                                    sliceEnd : int option seq, 
                                    [<Optional; DefaultParameterValue(0.0)>] scalar : double, 
                                    [<Optional>] step : int option seq) =
        let creator = AtomicSymbolCreator.FromName "_slice_assign_scalar"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle|]
                                                 [|"begin"; "end"; "scalar"; "step"|]
                                                 [|string sliceBegin; string sliceEnd; string scalar; (if isNull (step :> obj) then "[]" else string step)|]
        (new NDArray(outputs.[0]))
    /// <summary>(Assign the scalar to a cropped subset of the input.
    /// 
    /// Requirements
    /// ------------
    /// - output should be explicitly given and be the same as input
    /// )
    /// 
    /// From:C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\matrix_op.cc:540</summary>
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="data">Source input</param>
    /// <param name="sliceBegin">starting indices for the slice operation, supports negative indices.</param>
    /// <param name="sliceEnd">ending indices for the slice operation, supports negative indices.</param>
    /// <param name="scalar">The scalar value for assignment.</param>
    /// <param name="step">step for the slice operation, supports negative values.</param>
    static member SliceAssignScalar(outputArray : NDArray seq, 
                                    data : NDArray, 
                                    sliceBegin : int option seq, 
                                    sliceEnd : int option seq, 
                                    [<Optional; DefaultParameterValue(0.0)>] scalar : double, 
                                    [<Optional>] step : int option seq) =
        let creator = AtomicSymbolCreator.FromName "_slice_assign_scalar"
        let names = [|"begin"; "end"; "scalar"; "step"|]
        let vals = [|string sliceBegin; string sliceEnd; string scalar; (if isNull (step :> obj) then "[]" else string step)|]
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <summary>(Assign the scalar to a cropped subset of the input.
    /// 
    /// Requirements
    /// ------------
    /// - output should be explicitly given and be the same as input
    /// )
    /// 
    /// From:C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\matrix_op.cc:540</summary>
    /// <param name="data">Source input</param>
    /// <param name="sliceBegin">starting indices for the slice operation, supports negative indices.</param>
    /// <param name="sliceEnd">ending indices for the slice operation, supports negative indices.</param>
    /// <param name="scalar">The scalar value for assignment.</param>
    /// <param name="step">step for the slice operation, supports negative values.</param>
    static member SliceAssignScalar(data : Symbol, sliceBegin : int option seq, sliceEnd : int option seq, [<Optional>] ?scalar : double, [<Optional>] ?step : int option seq) =
        SliceAssignScalar(data, sliceBegin, sliceEnd, ?scalar = scalar, ?step = step)
    /// <summary>(Assign the scalar to a cropped subset of the input.
    /// 
    /// Requirements
    /// ------------
    /// - output should be explicitly given and be the same as input
    /// )
    /// 
    /// From:C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\matrix_op.cc:540</summary>
    /// <param name="sliceBegin">starting indices for the slice operation, supports negative indices.</param>
    /// <param name="sliceEnd">ending indices for the slice operation, supports negative indices.</param>
    /// <param name="data">Source input</param>
    /// <param name="scalar">The scalar value for assignment.</param>
    /// <param name="step">step for the slice operation, supports negative values.</param>
    static member SliceAssignScalar(sliceBegin : int option seq, sliceEnd : int option seq, [<Optional>] ?data : Symbol, [<Optional>] ?scalar : double, [<Optional>] ?step : int option seq) =
        SliceAssignScalar(sliceBegin, sliceEnd, ?data = data, ?scalar = scalar, ?step = step)

    /// <summary>Slices along a given axis.
    /// Returns an array slice along a given `axis` starting from the `begin` index
    /// to the `end` index.
    /// Examples::
    ///   x = [[  1.,   2.,   3.,   4.],
    ///        [  5.,   6.,   7.,   8.],
    ///        [  9.,  10.,  11.,  12.]]
    ///   slice_axis(x, axis=0, begin=1, end=3) = [[  5.,   6.,   7.,   8.],
    ///                                            [  9.,  10.,  11.,  12.]]
    ///   slice_axis(x, axis=1, begin=0, end=2) = [[  1.,   2.],
    ///                                            [  5.,   6.],
    ///                                            [  9.,  10.]]
    ///   slice_axis(x, axis=1, begin=-3, end=-1) = [[  2.,   3.],
    ///                                              [  6.,   7.],
    ///                                              [ 10.,  11.]]
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\matrix_op.cc:L570</summary>
    /// <param name="data">Source input</param>
    /// <param name="axis">Axis along which to be sliced, supports negative indexes.</param>
    /// <param name="sliceBegin">The beginning index along the axis to be sliced,  supports negative indexes.</param>
    /// <param name="sliceEnd">The ending index along the axis to be sliced,  supports negative indexes.</param>
    static member SliceAxis(data : NDArray, axis : int, sliceBegin : int, [<Optional>] ?sliceEnd : int) =
        let creator = AtomicSymbolCreator.FromName "slice_axis"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle|]
                                                 [|"axis"; "begin"; "end"|]
                                                 [|string axis; string sliceBegin; (match sliceEnd with None -> "None" | Some sliceEnd -> string sliceEnd)|]
        (new NDArray(outputs.[0]))
    /// <summary>Slices along a given axis.
    /// Returns an array slice along a given `axis` starting from the `begin` index
    /// to the `end` index.
    /// Examples::
    ///   x = [[  1.,   2.,   3.,   4.],
    ///        [  5.,   6.,   7.,   8.],
    ///        [  9.,  10.,  11.,  12.]]
    ///   slice_axis(x, axis=0, begin=1, end=3) = [[  5.,   6.,   7.,   8.],
    ///                                            [  9.,  10.,  11.,  12.]]
    ///   slice_axis(x, axis=1, begin=0, end=2) = [[  1.,   2.],
    ///                                            [  5.,   6.],
    ///                                            [  9.,  10.]]
    ///   slice_axis(x, axis=1, begin=-3, end=-1) = [[  2.,   3.],
    ///                                              [  6.,   7.],
    ///                                              [ 10.,  11.]]
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\matrix_op.cc:L570</summary>
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="data">Source input</param>
    /// <param name="axis">Axis along which to be sliced, supports negative indexes.</param>
    /// <param name="sliceBegin">The beginning index along the axis to be sliced,  supports negative indexes.</param>
    /// <param name="sliceEnd">The ending index along the axis to be sliced,  supports negative indexes.</param>
    static member SliceAxis(outputArray : NDArray seq, data : NDArray, axis : int, sliceBegin : int, [<Optional>] ?sliceEnd : int) =
        let creator = AtomicSymbolCreator.FromName "slice_axis"
        let names = [|"axis"; "begin"; "end"|]
        let vals = [|string axis; string sliceBegin; (match sliceEnd with None -> "None" | Some sliceEnd -> string sliceEnd)|]
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <summary>Slices along a given axis.
    /// Returns an array slice along a given `axis` starting from the `begin` index
    /// to the `end` index.
    /// Examples::
    ///   x = [[  1.,   2.,   3.,   4.],
    ///        [  5.,   6.,   7.,   8.],
    ///        [  9.,  10.,  11.,  12.]]
    ///   slice_axis(x, axis=0, begin=1, end=3) = [[  5.,   6.,   7.,   8.],
    ///                                            [  9.,  10.,  11.,  12.]]
    ///   slice_axis(x, axis=1, begin=0, end=2) = [[  1.,   2.],
    ///                                            [  5.,   6.],
    ///                                            [  9.,  10.]]
    ///   slice_axis(x, axis=1, begin=-3, end=-1) = [[  2.,   3.],
    ///                                              [  6.,   7.],
    ///                                              [ 10.,  11.]]
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\matrix_op.cc:L570</summary>
    /// <param name="data">Source input</param>
    /// <param name="axis">Axis along which to be sliced, supports negative indexes.</param>
    /// <param name="sliceBegin">The beginning index along the axis to be sliced,  supports negative indexes.</param>
    /// <param name="sliceEnd">The ending index along the axis to be sliced,  supports negative indexes.</param>
    static member SliceAxis(data : Symbol, axis : int, sliceBegin : int, [<Optional>] ?sliceEnd : int) =
        SliceAxis(data, axis, sliceBegin, ?sliceEnd = sliceEnd)
    /// <summary>Slices along a given axis.
    /// Returns an array slice along a given `axis` starting from the `begin` index
    /// to the `end` index.
    /// Examples::
    ///   x = [[  1.,   2.,   3.,   4.],
    ///        [  5.,   6.,   7.,   8.],
    ///        [  9.,  10.,  11.,  12.]]
    ///   slice_axis(x, axis=0, begin=1, end=3) = [[  5.,   6.,   7.,   8.],
    ///                                            [  9.,  10.,  11.,  12.]]
    ///   slice_axis(x, axis=1, begin=0, end=2) = [[  1.,   2.],
    ///                                            [  5.,   6.],
    ///                                            [  9.,  10.]]
    ///   slice_axis(x, axis=1, begin=-3, end=-1) = [[  2.,   3.],
    ///                                              [  6.,   7.],
    ///                                              [ 10.,  11.]]
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\matrix_op.cc:L570</summary>
    /// <param name="axis">Axis along which to be sliced, supports negative indexes.</param>
    /// <param name="sliceBegin">The beginning index along the axis to be sliced,  supports negative indexes.</param>
    /// <param name="data">Source input</param>
    /// <param name="sliceEnd">The ending index along the axis to be sliced,  supports negative indexes.</param>
    static member SliceAxis(axis : int, sliceBegin : int, [<Optional>] ?data : Symbol, [<Optional>] ?sliceEnd : int) =
        SliceAxis(axis, sliceBegin, ?data = data, ?sliceEnd = sliceEnd)


    /// <summary>Slices a region of the array like the shape of another array.
    /// This function is similar to ``slice``, however, the `begin` are always `0`s
    /// and `end` of specific axes are inferred from the second input `shape_like`.
    /// Given the second `shape_like` input of ``shape=(d_0, d_1, ..., d_n-1)``,
    /// a ``slice_like`` operator with default empty `axes`, it performs the
    /// following operation:
    /// `` out = slice(input, begin=(0, 0, ..., 0), end=(d_0, d_1, ..., d_n-1))``.
    /// When `axes` is not empty, it is used to speficy which axes are being sliced.
    /// Given a 4-d input data, ``slice_like`` operator with ``axes=(0, 2, -1)``
    /// will perform the following operation:
    /// `` out = slice(input, begin=(0, 0, 0, 0), end=(d_0, None, d_2, d_3))``.
    /// Note that it is allowed to have first and second input with different dimensions,
    /// however, you have to make sure the `axes` are specified and not exceeding the
    /// dimension limits.
    /// For example, given `input_1` with ``shape=(2,3,4,5)`` and `input_2` with
    /// ``shape=(1,2,3)``, it is not allowed to use:
    /// `` out = slice_like(a, b)`` because ndim of `input_1` is 4, and ndim of `input_2`
    /// is 3.
    /// The following is allowed in this situation:
    /// `` out = slice_like(a, b, axes=(0, 2))``
    /// Example::
    ///   x = [[  1.,   2.,   3.,   4.],
    ///        [  5.,   6.,   7.,   8.],
    ///        [  9.,  10.,  11.,  12.]]
    ///   y = [[  0.,   0.,   0.],
    ///        [  0.,   0.,   0.]]
    ///   slice_like(x, y) = [[ 1.,  2.,  3.]
    ///                       [ 5.,  6.,  7.]]
    ///   slice_like(x, y, axes=(0, 1)) = [[ 1.,  2.,  3.]
    ///                                    [ 5.,  6.,  7.]]
    ///   slice_like(x, y, axes=(0)) = [[ 1.,  2.,  3.,  4.]
    ///                                 [ 5.,  6.,  7.,  8.]]
    ///   slice_like(x, y, axes=(-1)) = [[  1.,   2.,   3.]
    ///                                  [  5.,   6.,   7.]
    ///                                  [  9.,  10.,  11.]]
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\matrix_op.cc:L624</summary>
    /// <param name="data">Source input</param>
    /// <param name="shapeLike">Shape like input</param>
    /// <param name="axes">List of axes on which input data will be sliced according to the corresponding size of the second input. By default will slice on all axes. Negative axes are supported.</param>
    static member SliceLike(data : NDArray, shapeLike : NDArray, [<Optional>] axes : int seq) =
        let creator = AtomicSymbolCreator.FromName "slice_like"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg shapeLike)) then shapeLike.UnsafeHandle|]
                                                 [|"axes"|]
                                                 [|(if isNull (axes :> obj) then "[]" else (axes |> Seq.map string |> String.concat ", " |> sprintf "[%s]"))|]
        (new NDArray(outputs.[0]))
    /// <summary>Slices a region of the array like the shape of another array.
    /// This function is similar to ``slice``, however, the `begin` are always `0`s
    /// and `end` of specific axes are inferred from the second input `shape_like`.
    /// Given the second `shape_like` input of ``shape=(d_0, d_1, ..., d_n-1)``,
    /// a ``slice_like`` operator with default empty `axes`, it performs the
    /// following operation:
    /// `` out = slice(input, begin=(0, 0, ..., 0), end=(d_0, d_1, ..., d_n-1))``.
    /// When `axes` is not empty, it is used to speficy which axes are being sliced.
    /// Given a 4-d input data, ``slice_like`` operator with ``axes=(0, 2, -1)``
    /// will perform the following operation:
    /// `` out = slice(input, begin=(0, 0, 0, 0), end=(d_0, None, d_2, d_3))``.
    /// Note that it is allowed to have first and second input with different dimensions,
    /// however, you have to make sure the `axes` are specified and not exceeding the
    /// dimension limits.
    /// For example, given `input_1` with ``shape=(2,3,4,5)`` and `input_2` with
    /// ``shape=(1,2,3)``, it is not allowed to use:
    /// `` out = slice_like(a, b)`` because ndim of `input_1` is 4, and ndim of `input_2`
    /// is 3.
    /// The following is allowed in this situation:
    /// `` out = slice_like(a, b, axes=(0, 2))``
    /// Example::
    ///   x = [[  1.,   2.,   3.,   4.],
    ///        [  5.,   6.,   7.,   8.],
    ///        [  9.,  10.,  11.,  12.]]
    ///   y = [[  0.,   0.,   0.],
    ///        [  0.,   0.,   0.]]
    ///   slice_like(x, y) = [[ 1.,  2.,  3.]
    ///                       [ 5.,  6.,  7.]]
    ///   slice_like(x, y, axes=(0, 1)) = [[ 1.,  2.,  3.]
    ///                                    [ 5.,  6.,  7.]]
    ///   slice_like(x, y, axes=(0)) = [[ 1.,  2.,  3.,  4.]
    ///                                 [ 5.,  6.,  7.,  8.]]
    ///   slice_like(x, y, axes=(-1)) = [[  1.,   2.,   3.]
    ///                                  [  5.,   6.,   7.]
    ///                                  [  9.,  10.,  11.]]
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\matrix_op.cc:L624</summary>
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="data">Source input</param>
    /// <param name="shapeLike">Shape like input</param>
    /// <param name="axes">List of axes on which input data will be sliced according to the corresponding size of the second input. By default will slice on all axes. Negative axes are supported.</param>
    static member SliceLike(outputArray : NDArray seq, data : NDArray, shapeLike : NDArray, [<Optional>] axes : int seq) =
        let creator = AtomicSymbolCreator.FromName "slice_like"
        let names = [|"axes"|]
        let vals = [|(if isNull (axes :> obj) then "[]" else (axes |> Seq.map string |> String.concat ", " |> sprintf "[%s]"))|]
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg shapeLike)) then shapeLike.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <summary>Slices a region of the array like the shape of another array.
    /// This function is similar to ``slice``, however, the `begin` are always `0`s
    /// and `end` of specific axes are inferred from the second input `shape_like`.
    /// Given the second `shape_like` input of ``shape=(d_0, d_1, ..., d_n-1)``,
    /// a ``slice_like`` operator with default empty `axes`, it performs the
    /// following operation:
    /// `` out = slice(input, begin=(0, 0, ..., 0), end=(d_0, d_1, ..., d_n-1))``.
    /// When `axes` is not empty, it is used to speficy which axes are being sliced.
    /// Given a 4-d input data, ``slice_like`` operator with ``axes=(0, 2, -1)``
    /// will perform the following operation:
    /// `` out = slice(input, begin=(0, 0, 0, 0), end=(d_0, None, d_2, d_3))``.
    /// Note that it is allowed to have first and second input with different dimensions,
    /// however, you have to make sure the `axes` are specified and not exceeding the
    /// dimension limits.
    /// For example, given `input_1` with ``shape=(2,3,4,5)`` and `input_2` with
    /// ``shape=(1,2,3)``, it is not allowed to use:
    /// `` out = slice_like(a, b)`` because ndim of `input_1` is 4, and ndim of `input_2`
    /// is 3.
    /// The following is allowed in this situation:
    /// `` out = slice_like(a, b, axes=(0, 2))``
    /// Example::
    ///   x = [[  1.,   2.,   3.,   4.],
    ///        [  5.,   6.,   7.,   8.],
    ///        [  9.,  10.,  11.,  12.]]
    ///   y = [[  0.,   0.,   0.],
    ///        [  0.,   0.,   0.]]
    ///   slice_like(x, y) = [[ 1.,  2.,  3.]
    ///                       [ 5.,  6.,  7.]]
    ///   slice_like(x, y, axes=(0, 1)) = [[ 1.,  2.,  3.]
    ///                                    [ 5.,  6.,  7.]]
    ///   slice_like(x, y, axes=(0)) = [[ 1.,  2.,  3.,  4.]
    ///                                 [ 5.,  6.,  7.,  8.]]
    ///   slice_like(x, y, axes=(-1)) = [[  1.,   2.,   3.]
    ///                                  [  5.,   6.,   7.]
    ///                                  [  9.,  10.,  11.]]
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\matrix_op.cc:L624</summary>
    /// <param name="data">Source input</param>
    /// <param name="shapeLike">Shape like input</param>
    /// <param name="axes">List of axes on which input data will be sliced according to the corresponding size of the second input. By default will slice on all axes. Negative axes are supported.</param>
    static member SliceLike([<Optional>] ?data : Symbol, [<Optional>] ?shapeLike : Symbol, [<Optional>] ?axes : int seq) =
        SliceLike(?data = data, ?shapeLike = shapeLike, ?axes = axes)


    /// <summary>Clips (limits) the values in an array.
    /// Given an interval, values outside the interval are clipped to the interval edges.
    /// Clipping ``x`` between `a_min` and `a_max` would be::
    /// .. math::
    ///    clip(x, a_min, a_max) = \max(\min(x, a_max), a_min))
    /// Example::
    ///     x = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
    ///     clip(x,1,8) = [ 1.,  1.,  2.,  3.,  4.,  5.,  6.,  7.,  8.,  8.]
    /// The storage type of ``clip`` output depends on storage types of inputs and the a_min, a_max \
    /// parameter values:
    ///    - clip(default) = default
    ///    - clip(row_sparse, a_min &lt;= 0, a_max &gt;= 0) = row_sparse
    ///    - clip(csr, a_min &lt;= 0, a_max &gt;= 0) = csr
    ///    - clip(row_sparse, a_min &lt; 0, a_max &lt; 0) = default
    ///    - clip(row_sparse, a_min &gt; 0, a_max &gt; 0) = default
    ///    - clip(csr, a_min &lt; 0, a_max &lt; 0) = csr
    ///    - clip(csr, a_min &gt; 0, a_max &gt; 0) = csr
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\matrix_op.cc:L676</summary>
    /// <param name="data">Input array.</param>
    /// <param name="aMin">Minimum value</param>
    /// <param name="aMax">Maximum value</param>
    static member Clip(data : NDArray, aMin : float, aMax : float) =
        let creator = AtomicSymbolCreator.FromName "clip"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle|]
                                                 [|"a_min"; "a_max"|]
                                                 [|string aMin; string aMax|]
        (new NDArray(outputs.[0]))
    /// <summary>Clips (limits) the values in an array.
    /// Given an interval, values outside the interval are clipped to the interval edges.
    /// Clipping ``x`` between `a_min` and `a_max` would be::
    /// .. math::
    ///    clip(x, a_min, a_max) = \max(\min(x, a_max), a_min))
    /// Example::
    ///     x = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
    ///     clip(x,1,8) = [ 1.,  1.,  2.,  3.,  4.,  5.,  6.,  7.,  8.,  8.]
    /// The storage type of ``clip`` output depends on storage types of inputs and the a_min, a_max \
    /// parameter values:
    ///    - clip(default) = default
    ///    - clip(row_sparse, a_min &lt;= 0, a_max &gt;= 0) = row_sparse
    ///    - clip(csr, a_min &lt;= 0, a_max &gt;= 0) = csr
    ///    - clip(row_sparse, a_min &lt; 0, a_max &lt; 0) = default
    ///    - clip(row_sparse, a_min &gt; 0, a_max &gt; 0) = default
    ///    - clip(csr, a_min &lt; 0, a_max &lt; 0) = csr
    ///    - clip(csr, a_min &gt; 0, a_max &gt; 0) = csr
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\matrix_op.cc:L676</summary>
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="data">Input array.</param>
    /// <param name="aMin">Minimum value</param>
    /// <param name="aMax">Maximum value</param>
    static member Clip(outputArray : NDArray seq, data : NDArray, aMin : float, aMax : float) =
        let creator = AtomicSymbolCreator.FromName "clip"
        let names = [|"a_min"; "a_max"|]
        let vals = [|string aMin; string aMax|]
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <summary>Clips (limits) the values in an array.
    /// Given an interval, values outside the interval are clipped to the interval edges.
    /// Clipping ``x`` between `a_min` and `a_max` would be::
    /// .. math::
    ///    clip(x, a_min, a_max) = \max(\min(x, a_max), a_min))
    /// Example::
    ///     x = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
    ///     clip(x,1,8) = [ 1.,  1.,  2.,  3.,  4.,  5.,  6.,  7.,  8.,  8.]
    /// The storage type of ``clip`` output depends on storage types of inputs and the a_min, a_max \
    /// parameter values:
    ///    - clip(default) = default
    ///    - clip(row_sparse, a_min &lt;= 0, a_max &gt;= 0) = row_sparse
    ///    - clip(csr, a_min &lt;= 0, a_max &gt;= 0) = csr
    ///    - clip(row_sparse, a_min &lt; 0, a_max &lt; 0) = default
    ///    - clip(row_sparse, a_min &gt; 0, a_max &gt; 0) = default
    ///    - clip(csr, a_min &lt; 0, a_max &lt; 0) = csr
    ///    - clip(csr, a_min &gt; 0, a_max &gt; 0) = csr
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\matrix_op.cc:L676</summary>
    /// <param name="data">Input array.</param>
    /// <param name="aMin">Minimum value</param>
    /// <param name="aMax">Maximum value</param>
    static member Clip(data : Symbol, aMin : float, aMax : float) =
        Clip(data, aMin, aMax)
    /// <summary>Clips (limits) the values in an array.
    /// Given an interval, values outside the interval are clipped to the interval edges.
    /// Clipping ``x`` between `a_min` and `a_max` would be::
    /// .. math::
    ///    clip(x, a_min, a_max) = \max(\min(x, a_max), a_min))
    /// Example::
    ///     x = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
    ///     clip(x,1,8) = [ 1.,  1.,  2.,  3.,  4.,  5.,  6.,  7.,  8.,  8.]
    /// The storage type of ``clip`` output depends on storage types of inputs and the a_min, a_max \
    /// parameter values:
    ///    - clip(default) = default
    ///    - clip(row_sparse, a_min &lt;= 0, a_max &gt;= 0) = row_sparse
    ///    - clip(csr, a_min &lt;= 0, a_max &gt;= 0) = csr
    ///    - clip(row_sparse, a_min &lt; 0, a_max &lt; 0) = default
    ///    - clip(row_sparse, a_min &gt; 0, a_max &gt; 0) = default
    ///    - clip(csr, a_min &lt; 0, a_max &lt; 0) = csr
    ///    - clip(csr, a_min &gt; 0, a_max &gt; 0) = csr
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\matrix_op.cc:L676</summary>
    /// <param name="aMin">Minimum value</param>
    /// <param name="aMax">Maximum value</param>
    /// <param name="data">Input array.</param>
    static member Clip(aMin : float, aMax : float, [<Optional>] ?data : Symbol) =
        Clip(aMin, aMax, ?data = data)


    /// <summary>Repeats elements of an array.
    /// By default, ``repeat`` flattens the input array into 1-D and then repeats the
    /// elements::
    ///   x = [[ 1, 2],
    ///        [ 3, 4]]
    ///   repeat(x, repeats=2) = [ 1.,  1.,  2.,  2.,  3.,  3.,  4.,  4.]
    /// The parameter ``axis`` specifies the axis along which to perform repeat::
    ///   repeat(x, repeats=2, axis=1) = [[ 1.,  1.,  2.,  2.],
    ///                                   [ 3.,  3.,  4.,  4.]]
    ///   repeat(x, repeats=2, axis=0) = [[ 1.,  2.],
    ///                                   [ 1.,  2.],
    ///                                   [ 3.,  4.],
    ///                                   [ 3.,  4.]]
    ///   repeat(x, repeats=2, axis=-1) = [[ 1.,  1.,  2.,  2.],
    ///                                    [ 3.,  3.,  4.,  4.]]
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\matrix_op.cc:L743</summary>
    /// <param name="data">Input data array</param>
    /// <param name="repeats">The number of repetitions for each element.</param>
    /// <param name="axis">The axis along which to repeat values. The negative numbers are interpreted counting from the backward. By default, use the flattened input array, and return a flat output array.</param>
    static member Repeat(data : NDArray, repeats : int, [<Optional>] ?axis : int) =
        let creator = AtomicSymbolCreator.FromName "repeat"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle|]
                                                 [|"repeats"; "axis"|]
                                                 [|string repeats; (match axis with None -> "None" | Some axis -> string axis)|]
        (new NDArray(outputs.[0]))
    /// <summary>Repeats elements of an array.
    /// By default, ``repeat`` flattens the input array into 1-D and then repeats the
    /// elements::
    ///   x = [[ 1, 2],
    ///        [ 3, 4]]
    ///   repeat(x, repeats=2) = [ 1.,  1.,  2.,  2.,  3.,  3.,  4.,  4.]
    /// The parameter ``axis`` specifies the axis along which to perform repeat::
    ///   repeat(x, repeats=2, axis=1) = [[ 1.,  1.,  2.,  2.],
    ///                                   [ 3.,  3.,  4.,  4.]]
    ///   repeat(x, repeats=2, axis=0) = [[ 1.,  2.],
    ///                                   [ 1.,  2.],
    ///                                   [ 3.,  4.],
    ///                                   [ 3.,  4.]]
    ///   repeat(x, repeats=2, axis=-1) = [[ 1.,  1.,  2.,  2.],
    ///                                    [ 3.,  3.,  4.,  4.]]
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\matrix_op.cc:L743</summary>
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="data">Input data array</param>
    /// <param name="repeats">The number of repetitions for each element.</param>
    /// <param name="axis">The axis along which to repeat values. The negative numbers are interpreted counting from the backward. By default, use the flattened input array, and return a flat output array.</param>
    static member Repeat(outputArray : NDArray seq, data : NDArray, repeats : int, [<Optional>] ?axis : int) =
        let creator = AtomicSymbolCreator.FromName "repeat"
        let names = [|"repeats"; "axis"|]
        let vals = [|string repeats; (match axis with None -> "None" | Some axis -> string axis)|]
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <summary>Repeats elements of an array.
    /// By default, ``repeat`` flattens the input array into 1-D and then repeats the
    /// elements::
    ///   x = [[ 1, 2],
    ///        [ 3, 4]]
    ///   repeat(x, repeats=2) = [ 1.,  1.,  2.,  2.,  3.,  3.,  4.,  4.]
    /// The parameter ``axis`` specifies the axis along which to perform repeat::
    ///   repeat(x, repeats=2, axis=1) = [[ 1.,  1.,  2.,  2.],
    ///                                   [ 3.,  3.,  4.,  4.]]
    ///   repeat(x, repeats=2, axis=0) = [[ 1.,  2.],
    ///                                   [ 1.,  2.],
    ///                                   [ 3.,  4.],
    ///                                   [ 3.,  4.]]
    ///   repeat(x, repeats=2, axis=-1) = [[ 1.,  1.,  2.,  2.],
    ///                                    [ 3.,  3.,  4.,  4.]]
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\matrix_op.cc:L743</summary>
    /// <param name="data">Input data array</param>
    /// <param name="repeats">The number of repetitions for each element.</param>
    /// <param name="axis">The axis along which to repeat values. The negative numbers are interpreted counting from the backward. By default, use the flattened input array, and return a flat output array.</param>
    static member Repeat(data : Symbol, repeats : int, [<Optional>] ?axis : int) =
        Repeat(data, repeats, ?axis = axis)
    /// <summary>Repeats elements of an array.
    /// By default, ``repeat`` flattens the input array into 1-D and then repeats the
    /// elements::
    ///   x = [[ 1, 2],
    ///        [ 3, 4]]
    ///   repeat(x, repeats=2) = [ 1.,  1.,  2.,  2.,  3.,  3.,  4.,  4.]
    /// The parameter ``axis`` specifies the axis along which to perform repeat::
    ///   repeat(x, repeats=2, axis=1) = [[ 1.,  1.,  2.,  2.],
    ///                                   [ 3.,  3.,  4.,  4.]]
    ///   repeat(x, repeats=2, axis=0) = [[ 1.,  2.],
    ///                                   [ 1.,  2.],
    ///                                   [ 3.,  4.],
    ///                                   [ 3.,  4.]]
    ///   repeat(x, repeats=2, axis=-1) = [[ 1.,  1.,  2.,  2.],
    ///                                    [ 3.,  3.,  4.,  4.]]
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\matrix_op.cc:L743</summary>
    /// <param name="repeats">The number of repetitions for each element.</param>
    /// <param name="data">Input data array</param>
    /// <param name="axis">The axis along which to repeat values. The negative numbers are interpreted counting from the backward. By default, use the flattened input array, and return a flat output array.</param>
    static member Repeat(repeats : int, [<Optional>] ?data : Symbol, [<Optional>] ?axis : int) =
        Repeat(repeats, ?data = data, ?axis = axis)


    /// <summary>Repeats the whole array multiple times.
    /// If ``reps`` has length *d*, and input array has dimension of *n*. There are
    /// three cases:
    /// - **n=d**. Repeat *i*-th dimension of the input by ``reps[i]`` times::
    ///     x = [[1, 2],
    ///          [3, 4]]
    ///     tile(x, reps=(2,3)) = [[ 1.,  2.,  1.,  2.,  1.,  2.],
    ///                            [ 3.,  4.,  3.,  4.,  3.,  4.],
    ///                            [ 1.,  2.,  1.,  2.,  1.,  2.],
    ///                            [ 3.,  4.,  3.,  4.,  3.,  4.]]
    /// - **n&gt;d**. ``reps`` is promoted to length *n* by pre-pending 1&#39;s to it. Thus for
    ///   an input shape ``(2,3)``, ``repos=(2,)`` is treated as ``(1,2)``::
    ///     tile(x, reps=(2,)) = [[ 1.,  2.,  1.,  2.],
    ///                           [ 3.,  4.,  3.,  4.]]
    /// - **n&lt;d**. The input is promoted to be d-dimensional by prepending new axes. So a
    ///   shape ``(2,2)`` array is promoted to ``(1,2,2)`` for 3-D replication::
    ///     tile(x, reps=(2,2,3)) = [[[ 1.,  2.,  1.,  2.,  1.,  2.],
    ///                               [ 3.,  4.,  3.,  4.,  3.,  4.],
    ///                               [ 1.,  2.,  1.,  2.,  1.,  2.],
    ///                               [ 3.,  4.,  3.,  4.,  3.,  4.]],
    ///                              [[ 1.,  2.,  1.,  2.,  1.,  2.],
    ///                               [ 3.,  4.,  3.,  4.,  3.,  4.],
    ///                               [ 1.,  2.,  1.,  2.,  1.,  2.],
    ///                               [ 3.,  4.,  3.,  4.,  3.,  4.]]]
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\matrix_op.cc:L795</summary>
    /// <param name="data">Input data array</param>
    /// <param name="reps">The number of times for repeating the tensor a. Each dim size of reps must be a positive integer. If reps has length d, the result will have dimension of max(d, a.ndim); If a.ndim &lt; d, a is promoted to be d-dimensional by prepending new axes. If a.ndim &gt; d, reps is promoted to a.ndim by pre-pending 1&#39;s to it.</param>
    static member Tile(data : NDArray, reps : int seq) =
        let creator = AtomicSymbolCreator.FromName "tile"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle|]
                                                 [|"reps"|]
                                                 [|(reps |> Seq.map string |> String.concat ", " |> sprintf "[%s]")|]
        (new NDArray(outputs.[0]))
    /// <summary>Repeats the whole array multiple times.
    /// If ``reps`` has length *d*, and input array has dimension of *n*. There are
    /// three cases:
    /// - **n=d**. Repeat *i*-th dimension of the input by ``reps[i]`` times::
    ///     x = [[1, 2],
    ///          [3, 4]]
    ///     tile(x, reps=(2,3)) = [[ 1.,  2.,  1.,  2.,  1.,  2.],
    ///                            [ 3.,  4.,  3.,  4.,  3.,  4.],
    ///                            [ 1.,  2.,  1.,  2.,  1.,  2.],
    ///                            [ 3.,  4.,  3.,  4.,  3.,  4.]]
    /// - **n&gt;d**. ``reps`` is promoted to length *n* by pre-pending 1&#39;s to it. Thus for
    ///   an input shape ``(2,3)``, ``repos=(2,)`` is treated as ``(1,2)``::
    ///     tile(x, reps=(2,)) = [[ 1.,  2.,  1.,  2.],
    ///                           [ 3.,  4.,  3.,  4.]]
    /// - **n&lt;d**. The input is promoted to be d-dimensional by prepending new axes. So a
    ///   shape ``(2,2)`` array is promoted to ``(1,2,2)`` for 3-D replication::
    ///     tile(x, reps=(2,2,3)) = [[[ 1.,  2.,  1.,  2.,  1.,  2.],
    ///                               [ 3.,  4.,  3.,  4.,  3.,  4.],
    ///                               [ 1.,  2.,  1.,  2.,  1.,  2.],
    ///                               [ 3.,  4.,  3.,  4.,  3.,  4.]],
    ///                              [[ 1.,  2.,  1.,  2.,  1.,  2.],
    ///                               [ 3.,  4.,  3.,  4.,  3.,  4.],
    ///                               [ 1.,  2.,  1.,  2.,  1.,  2.],
    ///                               [ 3.,  4.,  3.,  4.,  3.,  4.]]]
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\matrix_op.cc:L795</summary>
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="data">Input data array</param>
    /// <param name="reps">The number of times for repeating the tensor a. Each dim size of reps must be a positive integer. If reps has length d, the result will have dimension of max(d, a.ndim); If a.ndim &lt; d, a is promoted to be d-dimensional by prepending new axes. If a.ndim &gt; d, reps is promoted to a.ndim by pre-pending 1&#39;s to it.</param>
    static member Tile(outputArray : NDArray seq, data : NDArray, reps : int seq) =
        let creator = AtomicSymbolCreator.FromName "tile"
        let names = [|"reps"|]
        let vals = [|(reps |> Seq.map string |> String.concat ", " |> sprintf "[%s]")|]
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <summary>Repeats the whole array multiple times.
    /// If ``reps`` has length *d*, and input array has dimension of *n*. There are
    /// three cases:
    /// - **n=d**. Repeat *i*-th dimension of the input by ``reps[i]`` times::
    ///     x = [[1, 2],
    ///          [3, 4]]
    ///     tile(x, reps=(2,3)) = [[ 1.,  2.,  1.,  2.,  1.,  2.],
    ///                            [ 3.,  4.,  3.,  4.,  3.,  4.],
    ///                            [ 1.,  2.,  1.,  2.,  1.,  2.],
    ///                            [ 3.,  4.,  3.,  4.,  3.,  4.]]
    /// - **n&gt;d**. ``reps`` is promoted to length *n* by pre-pending 1&#39;s to it. Thus for
    ///   an input shape ``(2,3)``, ``repos=(2,)`` is treated as ``(1,2)``::
    ///     tile(x, reps=(2,)) = [[ 1.,  2.,  1.,  2.],
    ///                           [ 3.,  4.,  3.,  4.]]
    /// - **n&lt;d**. The input is promoted to be d-dimensional by prepending new axes. So a
    ///   shape ``(2,2)`` array is promoted to ``(1,2,2)`` for 3-D replication::
    ///     tile(x, reps=(2,2,3)) = [[[ 1.,  2.,  1.,  2.,  1.,  2.],
    ///                               [ 3.,  4.,  3.,  4.,  3.,  4.],
    ///                               [ 1.,  2.,  1.,  2.,  1.,  2.],
    ///                               [ 3.,  4.,  3.,  4.,  3.,  4.]],
    ///                              [[ 1.,  2.,  1.,  2.,  1.,  2.],
    ///                               [ 3.,  4.,  3.,  4.,  3.,  4.],
    ///                               [ 1.,  2.,  1.,  2.,  1.,  2.],
    ///                               [ 3.,  4.,  3.,  4.,  3.,  4.]]]
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\matrix_op.cc:L795</summary>
    /// <param name="data">Input data array</param>
    /// <param name="reps">The number of times for repeating the tensor a. Each dim size of reps must be a positive integer. If reps has length d, the result will have dimension of max(d, a.ndim); If a.ndim &lt; d, a is promoted to be d-dimensional by prepending new axes. If a.ndim &gt; d, reps is promoted to a.ndim by pre-pending 1&#39;s to it.</param>
    static member Tile(data : Symbol, reps : int seq) =
        Tile(data, reps)
    /// <summary>Repeats the whole array multiple times.
    /// If ``reps`` has length *d*, and input array has dimension of *n*. There are
    /// three cases:
    /// - **n=d**. Repeat *i*-th dimension of the input by ``reps[i]`` times::
    ///     x = [[1, 2],
    ///          [3, 4]]
    ///     tile(x, reps=(2,3)) = [[ 1.,  2.,  1.,  2.,  1.,  2.],
    ///                            [ 3.,  4.,  3.,  4.,  3.,  4.],
    ///                            [ 1.,  2.,  1.,  2.,  1.,  2.],
    ///                            [ 3.,  4.,  3.,  4.,  3.,  4.]]
    /// - **n&gt;d**. ``reps`` is promoted to length *n* by pre-pending 1&#39;s to it. Thus for
    ///   an input shape ``(2,3)``, ``repos=(2,)`` is treated as ``(1,2)``::
    ///     tile(x, reps=(2,)) = [[ 1.,  2.,  1.,  2.],
    ///                           [ 3.,  4.,  3.,  4.]]
    /// - **n&lt;d**. The input is promoted to be d-dimensional by prepending new axes. So a
    ///   shape ``(2,2)`` array is promoted to ``(1,2,2)`` for 3-D replication::
    ///     tile(x, reps=(2,2,3)) = [[[ 1.,  2.,  1.,  2.,  1.,  2.],
    ///                               [ 3.,  4.,  3.,  4.,  3.,  4.],
    ///                               [ 1.,  2.,  1.,  2.,  1.,  2.],
    ///                               [ 3.,  4.,  3.,  4.,  3.,  4.]],
    ///                              [[ 1.,  2.,  1.,  2.,  1.,  2.],
    ///                               [ 3.,  4.,  3.,  4.,  3.,  4.],
    ///                               [ 1.,  2.,  1.,  2.,  1.,  2.],
    ///                               [ 3.,  4.,  3.,  4.,  3.,  4.]]]
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\matrix_op.cc:L795</summary>
    /// <param name="reps">The number of times for repeating the tensor a. Each dim size of reps must be a positive integer. If reps has length d, the result will have dimension of max(d, a.ndim); If a.ndim &lt; d, a is promoted to be d-dimensional by prepending new axes. If a.ndim &gt; d, reps is promoted to a.ndim by pre-pending 1&#39;s to it.</param>
    /// <param name="data">Input data array</param>
    static member Tile(reps : int seq, [<Optional>] ?data : Symbol) =
        Tile(reps, ?data = data)


    /// <summary>Reverses the order of elements along given axis while preserving array shape.
    /// Note: reverse and flip are equivalent. We use reverse in the following examples.
    /// Examples::
    ///   x = [[ 0.,  1.,  2.,  3.,  4.],
    ///        [ 5.,  6.,  7.,  8.,  9.]]
    ///   reverse(x, axis=0) = [[ 5.,  6.,  7.,  8.,  9.],
    ///                         [ 0.,  1.,  2.,  3.,  4.]]
    ///   reverse(x, axis=1) = [[ 4.,  3.,  2.,  1.,  0.],
    ///                         [ 9.,  8.,  7.,  6.,  5.]]
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\matrix_op.cc:L831</summary>
    /// <param name="data">Input data array</param>
    /// <param name="axis">The axis which to reverse elements.</param>
    static member Reverse(data : NDArray, axis : int seq) =
        let creator = AtomicSymbolCreator.FromName "reverse"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle|]
                                                 [|"axis"|]
                                                 [|(axis |> Seq.map string |> String.concat ", " |> sprintf "[%s]")|]
        (new NDArray(outputs.[0]))
    /// <summary>Reverses the order of elements along given axis while preserving array shape.
    /// Note: reverse and flip are equivalent. We use reverse in the following examples.
    /// Examples::
    ///   x = [[ 0.,  1.,  2.,  3.,  4.],
    ///        [ 5.,  6.,  7.,  8.,  9.]]
    ///   reverse(x, axis=0) = [[ 5.,  6.,  7.,  8.,  9.],
    ///                         [ 0.,  1.,  2.,  3.,  4.]]
    ///   reverse(x, axis=1) = [[ 4.,  3.,  2.,  1.,  0.],
    ///                         [ 9.,  8.,  7.,  6.,  5.]]
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\matrix_op.cc:L831</summary>
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="data">Input data array</param>
    /// <param name="axis">The axis which to reverse elements.</param>
    static member Reverse(outputArray : NDArray seq, data : NDArray, axis : int seq) =
        let creator = AtomicSymbolCreator.FromName "reverse"
        let names = [|"axis"|]
        let vals = [|(axis |> Seq.map string |> String.concat ", " |> sprintf "[%s]")|]
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <summary>Reverses the order of elements along given axis while preserving array shape.
    /// Note: reverse and flip are equivalent. We use reverse in the following examples.
    /// Examples::
    ///   x = [[ 0.,  1.,  2.,  3.,  4.],
    ///        [ 5.,  6.,  7.,  8.,  9.]]
    ///   reverse(x, axis=0) = [[ 5.,  6.,  7.,  8.,  9.],
    ///                         [ 0.,  1.,  2.,  3.,  4.]]
    ///   reverse(x, axis=1) = [[ 4.,  3.,  2.,  1.,  0.],
    ///                         [ 9.,  8.,  7.,  6.,  5.]]
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\matrix_op.cc:L831</summary>
    /// <param name="data">Input data array</param>
    /// <param name="axis">The axis which to reverse elements.</param>
    static member Reverse(data : Symbol, axis : int seq) =
        Reverse(data, axis)
    /// <summary>Reverses the order of elements along given axis while preserving array shape.
    /// Note: reverse and flip are equivalent. We use reverse in the following examples.
    /// Examples::
    ///   x = [[ 0.,  1.,  2.,  3.,  4.],
    ///        [ 5.,  6.,  7.,  8.,  9.]]
    ///   reverse(x, axis=0) = [[ 5.,  6.,  7.,  8.,  9.],
    ///                         [ 0.,  1.,  2.,  3.,  4.]]
    ///   reverse(x, axis=1) = [[ 4.,  3.,  2.,  1.,  0.],
    ///                         [ 9.,  8.,  7.,  6.,  5.]]
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\matrix_op.cc:L831</summary>
    /// <param name="axis">The axis which to reverse elements.</param>
    /// <param name="data">Input data array</param>
    static member Reverse(axis : int seq, [<Optional>] ?data : Symbol) =
        Reverse(axis, ?data = data)


    /// <summary>Join a sequence of arrays along a new axis.
    /// The axis parameter specifies the index of the new axis in the dimensions of the
    /// result. For example, if axis=0 it will be the first dimension and if axis=-1 it
    /// will be the last dimension.
    /// Examples::
    ///   x = [1, 2]
    ///   y = [3, 4]
    ///   stack(x, y) = [[1, 2],
    ///                  [3, 4]]
    ///   stack(x, y, axis=1) = [[1, 3],
    ///                          [2, 4]]
    /// </summary>
    /// <param name="data">List of arrays to stack</param>
    /// <param name="numArgs">Number of inputs to be stacked.</param>
    /// <param name="axis">The axis in the result array along which the input arrays are stacked.</param>
    static member Stack([<ParamArray>] data : NDArray[], [<Optional; DefaultParameterValue(0)>] axis : int) =
        let creator = AtomicSymbolCreator.FromName "stack"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 (data |> Array.map (fun x -> x.UnsafeHandle))
                                                 [|"num_args"; "axis"|]
                                                 [|string data.Length; string axis|]
        (new NDArray(outputs.[0]))
    /// <summary>Join a sequence of arrays along a new axis.
    /// The axis parameter specifies the index of the new axis in the dimensions of the
    /// result. For example, if axis=0 it will be the first dimension and if axis=-1 it
    /// will be the last dimension.
    /// Examples::
    ///   x = [1, 2]
    ///   y = [3, 4]
    ///   stack(x, y) = [[1, 2],
    ///                  [3, 4]]
    ///   stack(x, y, axis=1) = [[1, 3],
    ///                          [2, 4]]
    /// </summary>
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="data">List of arrays to stack</param>
    /// <param name="numArgs">Number of inputs to be stacked.</param>
    /// <param name="axis">The axis in the result array along which the input arrays are stacked.</param>
    static member Stack(outputArray : NDArray seq, [<ParamArray>] data : NDArray[], [<Optional; DefaultParameterValue(0)>] axis : int) =
        let creator = AtomicSymbolCreator.FromName "stack"
        let names = [|"num_args"; "axis"|]
        let vals = [|string data.Length; string axis|]
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     (data |> Array.map (fun x -> x.UnsafeHandle))
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <summary>Join a sequence of arrays along a new axis.
    /// The axis parameter specifies the index of the new axis in the dimensions of the
    /// result. For example, if axis=0 it will be the first dimension and if axis=-1 it
    /// will be the last dimension.
    /// Examples::
    ///   x = [1, 2]
    ///   y = [3, 4]
    ///   stack(x, y) = [[1, 2],
    ///                  [3, 4]]
    ///   stack(x, y, axis=1) = [[1, 3],
    ///                          [2, 4]]
    /// </summary>
    /// <param name="data">List of arrays to stack</param>
    /// <param name="axis">The axis in the result array along which the input arrays are stacked.</param>
    static member Stack([<Optional>] ?data : Symbol seq, [<Optional>] ?axis : int) =
        Stack(?data = data, ?axis = axis)


    /// <summary>Remove single-dimensional entries from the shape of an array.
    /// Same behavior of defining the output tensor shape as numpy.squeeze for the most of cases.
    /// See the following note for exception.
    /// Examples::
    ///   data = [[[0], [1], [2]]]
    ///   squeeze(data) = [0, 1, 2]
    ///   squeeze(data, axis=0) = [[0], [1], [2]]
    ///   squeeze(data, axis=2) = [[0, 1, 2]]
    ///   squeeze(data, axis=(0, 2)) = [0, 1, 2]
    /// .. Note::
    ///   The output of this operator will keep at least one dimension not removed. For example,
    ///   squeeze([[[4]]]) = [4], while in numpy.squeeze, the output will become a scalar.
    /// </summary>
    /// <param name="data">data to squeeze</param>
    /// <param name="axis">Selects a subset of the single-dimensional entries in the shape. If an axis is selected with shape entry greater than one, an error is raised.</param>
    static member Squeeze(data : NDArray, [<Optional>] ?axis : int seq) =
        let creator = AtomicSymbolCreator.FromName "squeeze"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle|]
                                                 [|"axis"|]
                                                 [|(match axis with None -> "None" | Some axis -> (axis |> Seq.map string |> String.concat ", " |> sprintf "[%s]"))|]
        (new NDArray(outputs.[0]))
    /// <summary>Remove single-dimensional entries from the shape of an array.
    /// Same behavior of defining the output tensor shape as numpy.squeeze for the most of cases.
    /// See the following note for exception.
    /// Examples::
    ///   data = [[[0], [1], [2]]]
    ///   squeeze(data) = [0, 1, 2]
    ///   squeeze(data, axis=0) = [[0], [1], [2]]
    ///   squeeze(data, axis=2) = [[0, 1, 2]]
    ///   squeeze(data, axis=(0, 2)) = [0, 1, 2]
    /// .. Note::
    ///   The output of this operator will keep at least one dimension not removed. For example,
    ///   squeeze([[[4]]]) = [4], while in numpy.squeeze, the output will become a scalar.
    /// </summary>
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="data">data to squeeze</param>
    /// <param name="axis">Selects a subset of the single-dimensional entries in the shape. If an axis is selected with shape entry greater than one, an error is raised.</param>
    static member Squeeze(outputArray : NDArray seq, data : NDArray, [<Optional>] ?axis : int seq) =
        let creator = AtomicSymbolCreator.FromName "squeeze"
        let names = [|"axis"|]
        let vals = [|(match axis with None -> "None" | Some axis -> (axis |> Seq.map string |> String.concat ", " |> sprintf "[%s]"))|]
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <summary>Remove single-dimensional entries from the shape of an array.
    /// Same behavior of defining the output tensor shape as numpy.squeeze for the most of cases.
    /// See the following note for exception.
    /// Examples::
    ///   data = [[[0], [1], [2]]]
    ///   squeeze(data) = [0, 1, 2]
    ///   squeeze(data, axis=0) = [[0], [1], [2]]
    ///   squeeze(data, axis=2) = [[0, 1, 2]]
    ///   squeeze(data, axis=(0, 2)) = [0, 1, 2]
    /// .. Note::
    ///   The output of this operator will keep at least one dimension not removed. For example,
    ///   squeeze([[[4]]]) = [4], while in numpy.squeeze, the output will become a scalar.
    /// </summary>
    /// <param name="data">data to squeeze</param>
    /// <param name="axis">Selects a subset of the single-dimensional entries in the shape. If an axis is selected with shape entry greater than one, an error is raised.</param>
    static member Squeeze([<Optional>] ?data : Symbol, [<Optional>] ?axis : int seq) =
        Squeeze(?data = data, ?axis = axis)


    /// <summary>Rearranges(permutes) data from depth into blocks of spatial data.
    /// Similar to ONNX DepthToSpace operator:
    /// https://github.com/onnx/onnx/blob/master/docs/Operators.md#DepthToSpace.
    /// The output is a new tensor where the values from depth dimension are moved in spatial blocks
    /// to height and width dimension. The reverse of this operation is ``space_to_depth``.
    /// .. math::
    ///     \begin{gather*}
    ///     x \prime = reshape(x, [N, block\_size, block\_size, C / (block\_size ^ 2), H * block\_size, W * block\_size]) \\
    ///     x \prime \prime = transpose(x \prime, [0, 3, 4, 1, 5, 2]) \\
    ///     y = reshape(x \prime \prime, [N, C / (block\_size ^ 2), H * block\_size, W * block\_size])
    ///     \end{gather*}
    /// where :math:`x` is an input tensor with default layout as :math:`[N, C, H, W]`: [batch, channels, height, width]
    /// and :math:`y` is the output tensor of layout :math:`[N, C / (block\_size ^ 2), H * block\_size, W * block\_size]`
    /// Example::
    ///   x = [[[[0, 1, 2],
    ///          [3, 4, 5]],
    ///         [[6, 7, 8],
    ///          [9, 10, 11]],
    ///         [[12, 13, 14],
    ///          [15, 16, 17]],
    ///         [[18, 19, 20],
    ///          [21, 22, 23]]]]
    ///   depth_to_space(x, 2) = [[[[0, 6, 1, 7, 2, 8],
    ///                             [12, 18, 13, 19, 14, 20],
    ///                             [3, 9, 4, 10, 5, 11],
    ///                             [15, 21, 16, 22, 17, 23]]]]
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\matrix_op.cc:L971</summary>
    /// <param name="data">Input ndarray</param>
    /// <param name="blockSize">Blocks of [block_size. block_size] are moved</param>
    static member DepthToSpace(data : NDArray, blockSize : int) =
        let creator = AtomicSymbolCreator.FromName "depth_to_space"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle|]
                                                 [|"block_size"|]
                                                 [|string blockSize|]
        (new NDArray(outputs.[0]))
    /// <summary>Rearranges(permutes) data from depth into blocks of spatial data.
    /// Similar to ONNX DepthToSpace operator:
    /// https://github.com/onnx/onnx/blob/master/docs/Operators.md#DepthToSpace.
    /// The output is a new tensor where the values from depth dimension are moved in spatial blocks
    /// to height and width dimension. The reverse of this operation is ``space_to_depth``.
    /// .. math::
    ///     \begin{gather*}
    ///     x \prime = reshape(x, [N, block\_size, block\_size, C / (block\_size ^ 2), H * block\_size, W * block\_size]) \\
    ///     x \prime \prime = transpose(x \prime, [0, 3, 4, 1, 5, 2]) \\
    ///     y = reshape(x \prime \prime, [N, C / (block\_size ^ 2), H * block\_size, W * block\_size])
    ///     \end{gather*}
    /// where :math:`x` is an input tensor with default layout as :math:`[N, C, H, W]`: [batch, channels, height, width]
    /// and :math:`y` is the output tensor of layout :math:`[N, C / (block\_size ^ 2), H * block\_size, W * block\_size]`
    /// Example::
    ///   x = [[[[0, 1, 2],
    ///          [3, 4, 5]],
    ///         [[6, 7, 8],
    ///          [9, 10, 11]],
    ///         [[12, 13, 14],
    ///          [15, 16, 17]],
    ///         [[18, 19, 20],
    ///          [21, 22, 23]]]]
    ///   depth_to_space(x, 2) = [[[[0, 6, 1, 7, 2, 8],
    ///                             [12, 18, 13, 19, 14, 20],
    ///                             [3, 9, 4, 10, 5, 11],
    ///                             [15, 21, 16, 22, 17, 23]]]]
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\matrix_op.cc:L971</summary>
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="data">Input ndarray</param>
    /// <param name="blockSize">Blocks of [block_size. block_size] are moved</param>
    static member DepthToSpace(outputArray : NDArray seq, data : NDArray, blockSize : int) =
        let creator = AtomicSymbolCreator.FromName "depth_to_space"
        let names = [|"block_size"|]
        let vals = [|string blockSize|]
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <summary>Rearranges(permutes) data from depth into blocks of spatial data.
    /// Similar to ONNX DepthToSpace operator:
    /// https://github.com/onnx/onnx/blob/master/docs/Operators.md#DepthToSpace.
    /// The output is a new tensor where the values from depth dimension are moved in spatial blocks
    /// to height and width dimension. The reverse of this operation is ``space_to_depth``.
    /// .. math::
    ///     \begin{gather*}
    ///     x \prime = reshape(x, [N, block\_size, block\_size, C / (block\_size ^ 2), H * block\_size, W * block\_size]) \\
    ///     x \prime \prime = transpose(x \prime, [0, 3, 4, 1, 5, 2]) \\
    ///     y = reshape(x \prime \prime, [N, C / (block\_size ^ 2), H * block\_size, W * block\_size])
    ///     \end{gather*}
    /// where :math:`x` is an input tensor with default layout as :math:`[N, C, H, W]`: [batch, channels, height, width]
    /// and :math:`y` is the output tensor of layout :math:`[N, C / (block\_size ^ 2), H * block\_size, W * block\_size]`
    /// Example::
    ///   x = [[[[0, 1, 2],
    ///          [3, 4, 5]],
    ///         [[6, 7, 8],
    ///          [9, 10, 11]],
    ///         [[12, 13, 14],
    ///          [15, 16, 17]],
    ///         [[18, 19, 20],
    ///          [21, 22, 23]]]]
    ///   depth_to_space(x, 2) = [[[[0, 6, 1, 7, 2, 8],
    ///                             [12, 18, 13, 19, 14, 20],
    ///                             [3, 9, 4, 10, 5, 11],
    ///                             [15, 21, 16, 22, 17, 23]]]]
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\matrix_op.cc:L971</summary>
    /// <param name="data">Input ndarray</param>
    /// <param name="blockSize">Blocks of [block_size. block_size] are moved</param>
    static member DepthToSpace(data : Symbol, blockSize : int) =
        DepthToSpace(data, blockSize)
    /// <summary>Rearranges(permutes) data from depth into blocks of spatial data.
    /// Similar to ONNX DepthToSpace operator:
    /// https://github.com/onnx/onnx/blob/master/docs/Operators.md#DepthToSpace.
    /// The output is a new tensor where the values from depth dimension are moved in spatial blocks
    /// to height and width dimension. The reverse of this operation is ``space_to_depth``.
    /// .. math::
    ///     \begin{gather*}
    ///     x \prime = reshape(x, [N, block\_size, block\_size, C / (block\_size ^ 2), H * block\_size, W * block\_size]) \\
    ///     x \prime \prime = transpose(x \prime, [0, 3, 4, 1, 5, 2]) \\
    ///     y = reshape(x \prime \prime, [N, C / (block\_size ^ 2), H * block\_size, W * block\_size])
    ///     \end{gather*}
    /// where :math:`x` is an input tensor with default layout as :math:`[N, C, H, W]`: [batch, channels, height, width]
    /// and :math:`y` is the output tensor of layout :math:`[N, C / (block\_size ^ 2), H * block\_size, W * block\_size]`
    /// Example::
    ///   x = [[[[0, 1, 2],
    ///          [3, 4, 5]],
    ///         [[6, 7, 8],
    ///          [9, 10, 11]],
    ///         [[12, 13, 14],
    ///          [15, 16, 17]],
    ///         [[18, 19, 20],
    ///          [21, 22, 23]]]]
    ///   depth_to_space(x, 2) = [[[[0, 6, 1, 7, 2, 8],
    ///                             [12, 18, 13, 19, 14, 20],
    ///                             [3, 9, 4, 10, 5, 11],
    ///                             [15, 21, 16, 22, 17, 23]]]]
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\matrix_op.cc:L971</summary>
    /// <param name="blockSize">Blocks of [block_size. block_size] are moved</param>
    /// <param name="data">Input ndarray</param>
    static member DepthToSpace(blockSize : int, [<Optional>] ?data : Symbol) =
        DepthToSpace(blockSize, ?data = data)

    /// <summary>Rearranges(permutes) blocks of spatial data into depth.
    /// Similar to ONNX SpaceToDepth operator:
    /// https://github.com/onnx/onnx/blob/master/docs/Operators.md#SpaceToDepth
    /// The output is a new tensor where the values from height and width dimension are
    /// moved to the depth dimension. The reverse of this operation is ``depth_to_space``.
    /// .. math::
    ///     \begin{gather*}
    ///     x \prime = reshape(x, [N, C, H / block\_size, block\_size, W / block\_size, block\_size]) \\
    ///     x \prime \prime = transpose(x \prime, [0, 3, 5, 1, 2, 4]) \\
    ///     y = reshape(x \prime \prime, [N, C * (block\_size ^ 2), H / block\_size, W / block\_size])
    ///     \end{gather*}
    /// where :math:`x` is an input tensor with default layout as :math:`[N, C, H, W]`: [batch, channels, height, width]
    /// and :math:`y` is the output tensor of layout :math:`[N, C * (block\_size ^ 2), H / block\_size, W / block\_size]`
    /// Example::
    ///   x = [[[[0, 6, 1, 7, 2, 8],
    ///          [12, 18, 13, 19, 14, 20],
    ///          [3, 9, 4, 10, 5, 11],
    ///          [15, 21, 16, 22, 17, 23]]]]
    ///   space_to_depth(x, 2) = [[[[0, 1, 2],
    ///                             [3, 4, 5]],
    ///                            [[6, 7, 8],
    ///                             [9, 10, 11]],
    ///                            [[12, 13, 14],
    ///                             [15, 16, 17]],
    ///                            [[18, 19, 20],
    ///                             [21, 22, 23]]]]
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\matrix_op.cc:L1018</summary>
    /// <param name="data">Input ndarray</param>
    /// <param name="blockSize">Blocks of [block_size. block_size] are moved</param>
    static member SpaceToDepth(data : NDArray, blockSize : int) =
        let creator = AtomicSymbolCreator.FromName "space_to_depth"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle|]
                                                 [|"block_size"|]
                                                 [|string blockSize|]
        (new NDArray(outputs.[0]))
    /// <summary>Rearranges(permutes) blocks of spatial data into depth.
    /// Similar to ONNX SpaceToDepth operator:
    /// https://github.com/onnx/onnx/blob/master/docs/Operators.md#SpaceToDepth
    /// The output is a new tensor where the values from height and width dimension are
    /// moved to the depth dimension. The reverse of this operation is ``depth_to_space``.
    /// .. math::
    ///     \begin{gather*}
    ///     x \prime = reshape(x, [N, C, H / block\_size, block\_size, W / block\_size, block\_size]) \\
    ///     x \prime \prime = transpose(x \prime, [0, 3, 5, 1, 2, 4]) \\
    ///     y = reshape(x \prime \prime, [N, C * (block\_size ^ 2), H / block\_size, W / block\_size])
    ///     \end{gather*}
    /// where :math:`x` is an input tensor with default layout as :math:`[N, C, H, W]`: [batch, channels, height, width]
    /// and :math:`y` is the output tensor of layout :math:`[N, C * (block\_size ^ 2), H / block\_size, W / block\_size]`
    /// Example::
    ///   x = [[[[0, 6, 1, 7, 2, 8],
    ///          [12, 18, 13, 19, 14, 20],
    ///          [3, 9, 4, 10, 5, 11],
    ///          [15, 21, 16, 22, 17, 23]]]]
    ///   space_to_depth(x, 2) = [[[[0, 1, 2],
    ///                             [3, 4, 5]],
    ///                            [[6, 7, 8],
    ///                             [9, 10, 11]],
    ///                            [[12, 13, 14],
    ///                             [15, 16, 17]],
    ///                            [[18, 19, 20],
    ///                             [21, 22, 23]]]]
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\matrix_op.cc:L1018</summary>
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="data">Input ndarray</param>
    /// <param name="blockSize">Blocks of [block_size. block_size] are moved</param>
    static member SpaceToDepth(outputArray : NDArray seq, data : NDArray, blockSize : int) =
        let creator = AtomicSymbolCreator.FromName "space_to_depth"
        let names = [|"block_size"|]
        let vals = [|string blockSize|]
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <summary>Rearranges(permutes) blocks of spatial data into depth.
    /// Similar to ONNX SpaceToDepth operator:
    /// https://github.com/onnx/onnx/blob/master/docs/Operators.md#SpaceToDepth
    /// The output is a new tensor where the values from height and width dimension are
    /// moved to the depth dimension. The reverse of this operation is ``depth_to_space``.
    /// .. math::
    ///     \begin{gather*}
    ///     x \prime = reshape(x, [N, C, H / block\_size, block\_size, W / block\_size, block\_size]) \\
    ///     x \prime \prime = transpose(x \prime, [0, 3, 5, 1, 2, 4]) \\
    ///     y = reshape(x \prime \prime, [N, C * (block\_size ^ 2), H / block\_size, W / block\_size])
    ///     \end{gather*}
    /// where :math:`x` is an input tensor with default layout as :math:`[N, C, H, W]`: [batch, channels, height, width]
    /// and :math:`y` is the output tensor of layout :math:`[N, C * (block\_size ^ 2), H / block\_size, W / block\_size]`
    /// Example::
    ///   x = [[[[0, 6, 1, 7, 2, 8],
    ///          [12, 18, 13, 19, 14, 20],
    ///          [3, 9, 4, 10, 5, 11],
    ///          [15, 21, 16, 22, 17, 23]]]]
    ///   space_to_depth(x, 2) = [[[[0, 1, 2],
    ///                             [3, 4, 5]],
    ///                            [[6, 7, 8],
    ///                             [9, 10, 11]],
    ///                            [[12, 13, 14],
    ///                             [15, 16, 17]],
    ///                            [[18, 19, 20],
    ///                             [21, 22, 23]]]]
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\matrix_op.cc:L1018</summary>
    /// <param name="data">Input ndarray</param>
    /// <param name="blockSize">Blocks of [block_size. block_size] are moved</param>
    static member SpaceToDepth(data : Symbol, blockSize : int) =
        SpaceToDepth(data, blockSize)
    /// <summary>Rearranges(permutes) blocks of spatial data into depth.
    /// Similar to ONNX SpaceToDepth operator:
    /// https://github.com/onnx/onnx/blob/master/docs/Operators.md#SpaceToDepth
    /// The output is a new tensor where the values from height and width dimension are
    /// moved to the depth dimension. The reverse of this operation is ``depth_to_space``.
    /// .. math::
    ///     \begin{gather*}
    ///     x \prime = reshape(x, [N, C, H / block\_size, block\_size, W / block\_size, block\_size]) \\
    ///     x \prime \prime = transpose(x \prime, [0, 3, 5, 1, 2, 4]) \\
    ///     y = reshape(x \prime \prime, [N, C * (block\_size ^ 2), H / block\_size, W / block\_size])
    ///     \end{gather*}
    /// where :math:`x` is an input tensor with default layout as :math:`[N, C, H, W]`: [batch, channels, height, width]
    /// and :math:`y` is the output tensor of layout :math:`[N, C * (block\_size ^ 2), H / block\_size, W / block\_size]`
    /// Example::
    ///   x = [[[[0, 6, 1, 7, 2, 8],
    ///          [12, 18, 13, 19, 14, 20],
    ///          [3, 9, 4, 10, 5, 11],
    ///          [15, 21, 16, 22, 17, 23]]]]
    ///   space_to_depth(x, 2) = [[[[0, 1, 2],
    ///                             [3, 4, 5]],
    ///                            [[6, 7, 8],
    ///                             [9, 10, 11]],
    ///                            [[12, 13, 14],
    ///                             [15, 16, 17]],
    ///                            [[18, 19, 20],
    ///                             [21, 22, 23]]]]
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\matrix_op.cc:L1018</summary>
    /// <param name="blockSize">Blocks of [block_size. block_size] are moved</param>
    /// <param name="data">Input ndarray</param>
    static member SpaceToDepth(blockSize : int, [<Optional>] ?data : Symbol) =
        SpaceToDepth(blockSize, ?data = data)

    /// <summary>Splits an array along a particular axis into multiple sub-arrays.
    /// Example::
    ///    x  = [[[ 1.]
    ///           [ 2.]]
    ///          [[ 3.]
    ///           [ 4.]]
    ///          [[ 5.]
    ///           [ 6.]]]
    ///    x.shape = (3, 2, 1)
    ///    y = split_v2(x, axis=1, indices_or_sections=2) // a list of 2 arrays with shape (3, 1, 1)
    ///    y = [[[ 1.]]
    ///         [[ 3.]]
    ///         [[ 5.]]]
    ///        [[[ 2.]]
    ///         [[ 4.]]
    ///         [[ 6.]]]
    ///    y[0].shape = (3, 1, 1)
    ///    z = split_v2(x, axis=0, indices_or_sections=3) // a list of 3 arrays with shape (1, 2, 1)
    ///    z = [[[ 1.]
    ///          [ 2.]]]
    ///        [[[ 3.]
    ///          [ 4.]]]
    ///        [[[ 5.]
    ///          [ 6.]]]
    ///    z[0].shape = (1, 2, 1)
    ///    w = split_v2(x, axis=0, indices_or_sections=(1,)) // a list of 2 arrays with shape [(1, 2, 1), (2, 2, 1)]
    ///    w = [[[ 1.]
    ///          [ 2.]]]
    ///        [[[3.]
    ///          [4.]]
    ///         [[5.]
    ///          [6.]]]
    ///   w[0].shape = (1, 2, 1)
    ///   w[1].shape = (2, 2, 1)
    /// `squeeze_axis=True` removes the axis with length 1 from the shapes of the output arrays.
    /// **Note** that setting `squeeze_axis` to ``1`` removes axis with length 1 only
    /// along the `axis` which it is split.
    /// Also `squeeze_axis` can be set to true only if ``input.shape[axis] == indices_or_sections``.
    /// Example::
    ///    z = split_v2(x, axis=0, indices_or_sections=3, squeeze_axis=1) // a list of 3 arrays with shape (2, 1)
    ///    z = [[ 1.]
    ///         [ 2.]]
    ///        [[ 3.]
    ///         [ 4.]]
    ///        [[ 5.]
    ///         [ 6.]]
    ///    z[0].shape = (2, 1)
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\matrix_op.cc:L1087</summary>
    /// <param name="data">The input</param>
    /// <param name="indices">Indices of splits. The elements should denote the boundaries of at which split is performed along the `axis`.</param>
    /// <param name="axis">Axis along which to split.</param>
    /// <param name="squeezeAxis">If true, Removes the axis with length 1 from the shapes of the output arrays. **Note** that setting `squeeze_axis` to ``true`` removes axis with length 1 only along the `axis` which it is split. Also `squeeze_axis` can be set to ``true`` only if ``input.shape[axis] == num_outputs``.</param>
    /// <param name="sections">Number of sections if equally splitted. Default to 0 which means split by indices.</param>
    static member SplitV2(data : NDArray, 
                          indices : int seq, 
                          [<Optional; DefaultParameterValue(1)>] axis : int, 
                          [<Optional; DefaultParameterValue(false)>] squeezeAxis : bool, 
                          [<Optional; DefaultParameterValue(0)>] sections : int) =
        let creator = AtomicSymbolCreator.FromName "_split_v2"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle|]
                                                 [|"indices"; "axis"; "squeeze_axis"; "sections"|]
                                                 [|(indices |> Seq.map string |> String.concat ", " |> sprintf "[%s]"); string axis; string squeezeAxis; string sections|]
        outputs |> Array.map (fun h -> new NDArray(h))
    /// <summary>Splits an array along a particular axis into multiple sub-arrays.
    /// Example::
    ///    x  = [[[ 1.]
    ///           [ 2.]]
    ///          [[ 3.]
    ///           [ 4.]]
    ///          [[ 5.]
    ///           [ 6.]]]
    ///    x.shape = (3, 2, 1)
    ///    y = split_v2(x, axis=1, indices_or_sections=2) // a list of 2 arrays with shape (3, 1, 1)
    ///    y = [[[ 1.]]
    ///         [[ 3.]]
    ///         [[ 5.]]]
    ///        [[[ 2.]]
    ///         [[ 4.]]
    ///         [[ 6.]]]
    ///    y[0].shape = (3, 1, 1)
    ///    z = split_v2(x, axis=0, indices_or_sections=3) // a list of 3 arrays with shape (1, 2, 1)
    ///    z = [[[ 1.]
    ///          [ 2.]]]
    ///        [[[ 3.]
    ///          [ 4.]]]
    ///        [[[ 5.]
    ///          [ 6.]]]
    ///    z[0].shape = (1, 2, 1)
    ///    w = split_v2(x, axis=0, indices_or_sections=(1,)) // a list of 2 arrays with shape [(1, 2, 1), (2, 2, 1)]
    ///    w = [[[ 1.]
    ///          [ 2.]]]
    ///        [[[3.]
    ///          [4.]]
    ///         [[5.]
    ///          [6.]]]
    ///   w[0].shape = (1, 2, 1)
    ///   w[1].shape = (2, 2, 1)
    /// `squeeze_axis=True` removes the axis with length 1 from the shapes of the output arrays.
    /// **Note** that setting `squeeze_axis` to ``1`` removes axis with length 1 only
    /// along the `axis` which it is split.
    /// Also `squeeze_axis` can be set to true only if ``input.shape[axis] == indices_or_sections``.
    /// Example::
    ///    z = split_v2(x, axis=0, indices_or_sections=3, squeeze_axis=1) // a list of 3 arrays with shape (2, 1)
    ///    z = [[ 1.]
    ///         [ 2.]]
    ///        [[ 3.]
    ///         [ 4.]]
    ///        [[ 5.]
    ///         [ 6.]]
    ///    z[0].shape = (2, 1)
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\matrix_op.cc:L1087</summary>
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="data">The input</param>
    /// <param name="indices">Indices of splits. The elements should denote the boundaries of at which split is performed along the `axis`.</param>
    /// <param name="axis">Axis along which to split.</param>
    /// <param name="squeezeAxis">If true, Removes the axis with length 1 from the shapes of the output arrays. **Note** that setting `squeeze_axis` to ``true`` removes axis with length 1 only along the `axis` which it is split. Also `squeeze_axis` can be set to ``true`` only if ``input.shape[axis] == num_outputs``.</param>
    /// <param name="sections">Number of sections if equally splitted. Default to 0 which means split by indices.</param>
    static member SplitV2(outputArray : NDArray seq, 
                          data : NDArray, 
                          indices : int seq, 
                          [<Optional; DefaultParameterValue(1)>] axis : int, 
                          [<Optional; DefaultParameterValue(false)>] squeezeAxis : bool, 
                          [<Optional; DefaultParameterValue(0)>] sections : int) =
        let creator = AtomicSymbolCreator.FromName "_split_v2"
        let names = [|"indices"; "axis"; "squeeze_axis"; "sections"|]
        let vals = [|(indices |> Seq.map string |> String.concat ", " |> sprintf "[%s]"); string axis; string squeezeAxis; string sections|]
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <summary>Splits an array along a particular axis into multiple sub-arrays.
    /// Example::
    ///    x  = [[[ 1.]
    ///           [ 2.]]
    ///          [[ 3.]
    ///           [ 4.]]
    ///          [[ 5.]
    ///           [ 6.]]]
    ///    x.shape = (3, 2, 1)
    ///    y = split_v2(x, axis=1, indices_or_sections=2) // a list of 2 arrays with shape (3, 1, 1)
    ///    y = [[[ 1.]]
    ///         [[ 3.]]
    ///         [[ 5.]]]
    ///        [[[ 2.]]
    ///         [[ 4.]]
    ///         [[ 6.]]]
    ///    y[0].shape = (3, 1, 1)
    ///    z = split_v2(x, axis=0, indices_or_sections=3) // a list of 3 arrays with shape (1, 2, 1)
    ///    z = [[[ 1.]
    ///          [ 2.]]]
    ///        [[[ 3.]
    ///          [ 4.]]]
    ///        [[[ 5.]
    ///          [ 6.]]]
    ///    z[0].shape = (1, 2, 1)
    ///    w = split_v2(x, axis=0, indices_or_sections=(1,)) // a list of 2 arrays with shape [(1, 2, 1), (2, 2, 1)]
    ///    w = [[[ 1.]
    ///          [ 2.]]]
    ///        [[[3.]
    ///          [4.]]
    ///         [[5.]
    ///          [6.]]]
    ///   w[0].shape = (1, 2, 1)
    ///   w[1].shape = (2, 2, 1)
    /// `squeeze_axis=True` removes the axis with length 1 from the shapes of the output arrays.
    /// **Note** that setting `squeeze_axis` to ``1`` removes axis with length 1 only
    /// along the `axis` which it is split.
    /// Also `squeeze_axis` can be set to true only if ``input.shape[axis] == indices_or_sections``.
    /// Example::
    ///    z = split_v2(x, axis=0, indices_or_sections=3, squeeze_axis=1) // a list of 3 arrays with shape (2, 1)
    ///    z = [[ 1.]
    ///         [ 2.]]
    ///        [[ 3.]
    ///         [ 4.]]
    ///        [[ 5.]
    ///         [ 6.]]
    ///    z[0].shape = (2, 1)
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\matrix_op.cc:L1087</summary>
    /// <param name="data">The input</param>
    /// <param name="indices">Indices of splits. The elements should denote the boundaries of at which split is performed along the `axis`.</param>
    /// <param name="axis">Axis along which to split.</param>
    /// <param name="squeezeAxis">If true, Removes the axis with length 1 from the shapes of the output arrays. **Note** that setting `squeeze_axis` to ``true`` removes axis with length 1 only along the `axis` which it is split. Also `squeeze_axis` can be set to ``true`` only if ``input.shape[axis] == num_outputs``.</param>
    /// <param name="sections">Number of sections if equally splitted. Default to 0 which means split by indices.</param>
    static member SplitV2(data : Symbol, indices : int seq, [<Optional>] ?axis : int, [<Optional>] ?squeezeAxis : bool, [<Optional>] ?sections : int) =
        SplitV2(data, indices, ?axis = axis, ?squeezeAxis = squeezeAxis, ?sections = sections)
    /// <summary>Splits an array along a particular axis into multiple sub-arrays.
    /// Example::
    ///    x  = [[[ 1.]
    ///           [ 2.]]
    ///          [[ 3.]
    ///           [ 4.]]
    ///          [[ 5.]
    ///           [ 6.]]]
    ///    x.shape = (3, 2, 1)
    ///    y = split_v2(x, axis=1, indices_or_sections=2) // a list of 2 arrays with shape (3, 1, 1)
    ///    y = [[[ 1.]]
    ///         [[ 3.]]
    ///         [[ 5.]]]
    ///        [[[ 2.]]
    ///         [[ 4.]]
    ///         [[ 6.]]]
    ///    y[0].shape = (3, 1, 1)
    ///    z = split_v2(x, axis=0, indices_or_sections=3) // a list of 3 arrays with shape (1, 2, 1)
    ///    z = [[[ 1.]
    ///          [ 2.]]]
    ///        [[[ 3.]
    ///          [ 4.]]]
    ///        [[[ 5.]
    ///          [ 6.]]]
    ///    z[0].shape = (1, 2, 1)
    ///    w = split_v2(x, axis=0, indices_or_sections=(1,)) // a list of 2 arrays with shape [(1, 2, 1), (2, 2, 1)]
    ///    w = [[[ 1.]
    ///          [ 2.]]]
    ///        [[[3.]
    ///          [4.]]
    ///         [[5.]
    ///          [6.]]]
    ///   w[0].shape = (1, 2, 1)
    ///   w[1].shape = (2, 2, 1)
    /// `squeeze_axis=True` removes the axis with length 1 from the shapes of the output arrays.
    /// **Note** that setting `squeeze_axis` to ``1`` removes axis with length 1 only
    /// along the `axis` which it is split.
    /// Also `squeeze_axis` can be set to true only if ``input.shape[axis] == indices_or_sections``.
    /// Example::
    ///    z = split_v2(x, axis=0, indices_or_sections=3, squeeze_axis=1) // a list of 3 arrays with shape (2, 1)
    ///    z = [[ 1.]
    ///         [ 2.]]
    ///        [[ 3.]
    ///         [ 4.]]
    ///        [[ 5.]
    ///         [ 6.]]
    ///    z[0].shape = (2, 1)
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\matrix_op.cc:L1087</summary>
    /// <param name="indices">Indices of splits. The elements should denote the boundaries of at which split is performed along the `axis`.</param>
    /// <param name="data">The input</param>
    /// <param name="axis">Axis along which to split.</param>
    /// <param name="squeezeAxis">If true, Removes the axis with length 1 from the shapes of the output arrays. **Note** that setting `squeeze_axis` to ``true`` removes axis with length 1 only along the `axis` which it is split. Also `squeeze_axis` can be set to ``true`` only if ``input.shape[axis] == num_outputs``.</param>
    /// <param name="sections">Number of sections if equally splitted. Default to 0 which means split by indices.</param>
    static member SplitV2(indices : int seq, [<Optional>] ?data : Symbol, [<Optional>] ?axis : int, [<Optional>] ?squeezeAxis : bool, [<Optional>] ?sections : int) =
        SplitV2(indices, ?data = data, ?axis = axis, ?squeezeAxis = squeezeAxis, ?sections = sections)

    static member SplitV2BackwardNDArray() =
        let creator = AtomicSymbolCreator.FromName "_split_v2_backward"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 Array.empty
                                                 Array.empty
                                                 Array.empty
        (new NDArray(outputs.[0]))
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    static member SplitV2Backward(outputArray : NDArray seq) =
        let creator = AtomicSymbolCreator.FromName "_split_v2_backward"
        let names = Array.empty
        let vals = Array.empty
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     Array.empty
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    static member SplitV2Backward() =
        SplitV2Backward()

    /// <summary>Returns the indices of the top *k* elements in an input array along the given
    ///  axis (by default).
    ///  If ret_type is set to &#39;value&#39; returns the value of top *k* elements (instead of indices).
    ///  In case of ret_type = &#39;both&#39;, both value and index would be returned.
    ///  The returned elements will be sorted.
    /// 
    /// Examples::
    /// 
    ///   x = [[ 0.3,  0.2,  0.4],
    ///        [ 0.1,  0.3,  0.2]]
    /// 
    ///   // returns an index of the largest element on last axis
    ///   topk(x) = [[ 2.],
    ///              [ 1.]]
    /// 
    ///   // returns the value of top-2 largest elements on last axis
    ///   topk(x, ret_typ=&#39;value&#39;, k=2) = [[ 0.4,  0.3],
    ///                                    [ 0.3,  0.2]]
    /// 
    ///   // returns the value of top-2 smallest elements on last axis
    ///   topk(x, ret_typ=&#39;value&#39;, k=2, is_ascend=1) = [[ 0.2 ,  0.3],
    ///                                                [ 0.1 ,  0.2]]
    /// 
    ///   // returns the value of top-2 largest elements on axis 0
    ///   topk(x, axis=0, ret_typ=&#39;value&#39;, k=2) = [[ 0.3,  0.3,  0.4],
    ///                                            [ 0.1,  0.2,  0.2]]
    /// 
    ///   // flattens and then returns list of both values and indices
    ///   topk(x, ret_typ=&#39;both&#39;, k=2) = [[[ 0.4,  0.3], [ 0.3,  0.2]] ,  [[ 2.,  0.], [ 1.,  2.]]]
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\ordering_op.cc:L68</summary>
    /// <param name="data">The input array</param>
    /// <param name="axis">Axis along which to choose the top k indices. If not given, the flattened array is used. Default is -1.</param>
    /// <param name="k">Number of top elements to select, should be always smaller than or equal to the element number in the given axis. A global sort is performed if set k &lt; 1.</param>
    /// <param name="retTyp">The return type.
    ///  &quot;value&quot; means to return the top k values, &quot;indices&quot; means to return the indices of the top k values, &quot;mask&quot; means to return a mask array containing 0 and 1. 1 means the top k values. &quot;both&quot; means to return a list of both values and indices of top k elements.</param>
    /// <param name="isAscend">Whether to choose k largest or k smallest elements. Top K largest elements will be chosen if set to false.</param>
    /// <param name="dtype">DType of the output indices when ret_typ is &quot;indices&quot; or &quot;both&quot;. An error will be raised if the selected data type cannot precisely represent the indices.</param>
    static member Topk(data : NDArray, 
                       [<Optional>] ?axis : int, 
                       [<Optional>] ?k : int, 
                       [<Optional>] ?retTyp : RetTyp, 
                       [<Optional>] ?isAscend : bool, 
                       [<Optional>] ?dtype : DataType) =
        let creator = AtomicSymbolCreator.FromName "topk"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle|]
                                                 [|"axis"; "k"; "ret_typ"; "is_ascend"; "dtype"|]
                                                 [|(match axis with None -> "None" | Some axis -> string axis); (match k with None -> "1" | Some k -> string k); (match retTyp with None -> "indices" | Some retTyp -> string retTyp); (match isAscend with None -> "false" | Some isAscend -> string isAscend); (match dtype with None -> "float32" | Some dtype -> string dtype)|]
        outputs |> Array.map (fun h -> new NDArray(h))
    /// <summary>Returns the indices of the top *k* elements in an input array along the given
    ///  axis (by default).
    ///  If ret_type is set to &#39;value&#39; returns the value of top *k* elements (instead of indices).
    ///  In case of ret_type = &#39;both&#39;, both value and index would be returned.
    ///  The returned elements will be sorted.
    /// 
    /// Examples::
    /// 
    ///   x = [[ 0.3,  0.2,  0.4],
    ///        [ 0.1,  0.3,  0.2]]
    /// 
    ///   // returns an index of the largest element on last axis
    ///   topk(x) = [[ 2.],
    ///              [ 1.]]
    /// 
    ///   // returns the value of top-2 largest elements on last axis
    ///   topk(x, ret_typ=&#39;value&#39;, k=2) = [[ 0.4,  0.3],
    ///                                    [ 0.3,  0.2]]
    /// 
    ///   // returns the value of top-2 smallest elements on last axis
    ///   topk(x, ret_typ=&#39;value&#39;, k=2, is_ascend=1) = [[ 0.2 ,  0.3],
    ///                                                [ 0.1 ,  0.2]]
    /// 
    ///   // returns the value of top-2 largest elements on axis 0
    ///   topk(x, axis=0, ret_typ=&#39;value&#39;, k=2) = [[ 0.3,  0.3,  0.4],
    ///                                            [ 0.1,  0.2,  0.2]]
    /// 
    ///   // flattens and then returns list of both values and indices
    ///   topk(x, ret_typ=&#39;both&#39;, k=2) = [[[ 0.4,  0.3], [ 0.3,  0.2]] ,  [[ 2.,  0.], [ 1.,  2.]]]
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\ordering_op.cc:L68</summary>
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="data">The input array</param>
    /// <param name="axis">Axis along which to choose the top k indices. If not given, the flattened array is used. Default is -1.</param>
    /// <param name="k">Number of top elements to select, should be always smaller than or equal to the element number in the given axis. A global sort is performed if set k &lt; 1.</param>
    /// <param name="retTyp">The return type.
    ///  &quot;value&quot; means to return the top k values, &quot;indices&quot; means to return the indices of the top k values, &quot;mask&quot; means to return a mask array containing 0 and 1. 1 means the top k values. &quot;both&quot; means to return a list of both values and indices of top k elements.</param>
    /// <param name="isAscend">Whether to choose k largest or k smallest elements. Top K largest elements will be chosen if set to false.</param>
    /// <param name="dtype">DType of the output indices when ret_typ is &quot;indices&quot; or &quot;both&quot;. An error will be raised if the selected data type cannot precisely represent the indices.</param>
    static member Topk(outputArray : NDArray seq, 
                       data : NDArray, 
                       [<Optional>] ?axis : int, 
                       [<Optional>] ?k : int, 
                       [<Optional>] ?retTyp : RetTyp, 
                       [<Optional>] ?isAscend : bool, 
                       [<Optional>] ?dtype : DataType) =
        let creator = AtomicSymbolCreator.FromName "topk"
        let names = [|"axis"; "k"; "ret_typ"; "is_ascend"; "dtype"|]
        let vals = [|(match axis with None -> "None" | Some axis -> string axis); (match k with None -> "1" | Some k -> string k); (match retTyp with None -> "indices" | Some retTyp -> string retTyp); (match isAscend with None -> "false" | Some isAscend -> string isAscend); (match dtype with None -> "float32" | Some dtype -> string dtype)|]
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <summary>Returns the indices of the top *k* elements in an input array along the given
    ///  axis (by default).
    ///  If ret_type is set to &#39;value&#39; returns the value of top *k* elements (instead of indices).
    ///  In case of ret_type = &#39;both&#39;, both value and index would be returned.
    ///  The returned elements will be sorted.
    /// 
    /// Examples::
    /// 
    ///   x = [[ 0.3,  0.2,  0.4],
    ///        [ 0.1,  0.3,  0.2]]
    /// 
    ///   // returns an index of the largest element on last axis
    ///   topk(x) = [[ 2.],
    ///              [ 1.]]
    /// 
    ///   // returns the value of top-2 largest elements on last axis
    ///   topk(x, ret_typ=&#39;value&#39;, k=2) = [[ 0.4,  0.3],
    ///                                    [ 0.3,  0.2]]
    /// 
    ///   // returns the value of top-2 smallest elements on last axis
    ///   topk(x, ret_typ=&#39;value&#39;, k=2, is_ascend=1) = [[ 0.2 ,  0.3],
    ///                                                [ 0.1 ,  0.2]]
    /// 
    ///   // returns the value of top-2 largest elements on axis 0
    ///   topk(x, axis=0, ret_typ=&#39;value&#39;, k=2) = [[ 0.3,  0.3,  0.4],
    ///                                            [ 0.1,  0.2,  0.2]]
    /// 
    ///   // flattens and then returns list of both values and indices
    ///   topk(x, ret_typ=&#39;both&#39;, k=2) = [[[ 0.4,  0.3], [ 0.3,  0.2]] ,  [[ 2.,  0.], [ 1.,  2.]]]
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\ordering_op.cc:L68</summary>
    /// <param name="data">The input array</param>
    /// <param name="axis">Axis along which to choose the top k indices. If not given, the flattened array is used. Default is -1.</param>
    /// <param name="k">Number of top elements to select, should be always smaller than or equal to the element number in the given axis. A global sort is performed if set k &lt; 1.</param>
    /// <param name="retTyp">The return type.
    ///  &quot;value&quot; means to return the top k values, &quot;indices&quot; means to return the indices of the top k values, &quot;mask&quot; means to return a mask array containing 0 and 1. 1 means the top k values. &quot;both&quot; means to return a list of both values and indices of top k elements.</param>
    /// <param name="isAscend">Whether to choose k largest or k smallest elements. Top K largest elements will be chosen if set to false.</param>
    /// <param name="dtype">DType of the output indices when ret_typ is &quot;indices&quot; or &quot;both&quot;. An error will be raised if the selected data type cannot precisely represent the indices.</param>
    static member Topk([<Optional>] ?data : Symbol, [<Optional>] ?axis : int, [<Optional>] ?k : int, [<Optional>] ?retTyp : RetTyp, [<Optional>] ?isAscend : bool, [<Optional>] ?dtype : DataType) =
        Topk(?data = data, ?axis = axis, ?k = k, ?retTyp = retTyp, ?isAscend = isAscend, ?dtype = dtype)


    /// <summary>Returns a sorted copy of an input array along the given axis.
    /// 
    /// Examples::
    /// 
    ///   x = [[ 1, 4],
    ///        [ 3, 1]]
    /// 
    ///   // sorts along the last axis
    ///   sort(x) = [[ 1.,  4.],
    ///              [ 1.,  3.]]
    /// 
    ///   // flattens and then sorts
    ///   sort(x, axis=None) = [ 1.,  1.,  3.,  4.]
    /// 
    ///   // sorts along the first axis
    ///   sort(x, axis=0) = [[ 1.,  1.],
    ///                      [ 3.,  4.]]
    /// 
    ///   // in a descend order
    ///   sort(x, is_ascend=0) = [[ 4.,  1.],
    ///                           [ 3.,  1.]]
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\ordering_op.cc:L132</summary>
    /// <param name="data">The input array</param>
    /// <param name="axis">Axis along which to choose sort the input tensor. If not given, the flattened array is used. Default is -1.</param>
    /// <param name="isAscend">Whether to sort in ascending or descending order.</param>
    static member Sort(data : NDArray, [<Optional>] ?axis : int, [<Optional>] ?isAscend : bool) =
        let creator = AtomicSymbolCreator.FromName "sort"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle|]
                                                 [|"axis"; "is_ascend"|]
                                                 [|(match axis with None -> "None" | Some axis -> string axis); (match isAscend with None -> "true" | Some isAscend -> string isAscend)|]
        (new NDArray(outputs.[0]))
    /// <summary>Returns a sorted copy of an input array along the given axis.
    /// 
    /// Examples::
    /// 
    ///   x = [[ 1, 4],
    ///        [ 3, 1]]
    /// 
    ///   // sorts along the last axis
    ///   sort(x) = [[ 1.,  4.],
    ///              [ 1.,  3.]]
    /// 
    ///   // flattens and then sorts
    ///   sort(x, axis=None) = [ 1.,  1.,  3.,  4.]
    /// 
    ///   // sorts along the first axis
    ///   sort(x, axis=0) = [[ 1.,  1.],
    ///                      [ 3.,  4.]]
    /// 
    ///   // in a descend order
    ///   sort(x, is_ascend=0) = [[ 4.,  1.],
    ///                           [ 3.,  1.]]
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\ordering_op.cc:L132</summary>
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="data">The input array</param>
    /// <param name="axis">Axis along which to choose sort the input tensor. If not given, the flattened array is used. Default is -1.</param>
    /// <param name="isAscend">Whether to sort in ascending or descending order.</param>
    static member Sort(outputArray : NDArray seq, data : NDArray, [<Optional>] ?axis : int, [<Optional>] ?isAscend : bool) =
        let creator = AtomicSymbolCreator.FromName "sort"
        let names = [|"axis"; "is_ascend"|]
        let vals = [|(match axis with None -> "None" | Some axis -> string axis); (match isAscend with None -> "true" | Some isAscend -> string isAscend)|]
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <summary>Returns a sorted copy of an input array along the given axis.
    /// 
    /// Examples::
    /// 
    ///   x = [[ 1, 4],
    ///        [ 3, 1]]
    /// 
    ///   // sorts along the last axis
    ///   sort(x) = [[ 1.,  4.],
    ///              [ 1.,  3.]]
    /// 
    ///   // flattens and then sorts
    ///   sort(x, axis=None) = [ 1.,  1.,  3.,  4.]
    /// 
    ///   // sorts along the first axis
    ///   sort(x, axis=0) = [[ 1.,  1.],
    ///                      [ 3.,  4.]]
    /// 
    ///   // in a descend order
    ///   sort(x, is_ascend=0) = [[ 4.,  1.],
    ///                           [ 3.,  1.]]
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\ordering_op.cc:L132</summary>
    /// <param name="data">The input array</param>
    /// <param name="axis">Axis along which to choose sort the input tensor. If not given, the flattened array is used. Default is -1.</param>
    /// <param name="isAscend">Whether to sort in ascending or descending order.</param>
    static member Sort([<Optional>] ?data : Symbol, [<Optional>] ?axis : int, [<Optional>] ?isAscend : bool) =
        Sort(?data = data, ?axis = axis, ?isAscend = isAscend)

    /// <summary>Returns the indices that would sort an input array along the given axis.
    /// 
    /// This function performs sorting along the given axis and returns an array of indices having same shape
    /// as an input array that index data in sorted order.
    /// 
    /// Examples::
    /// 
    ///   x = [[ 0.3,  0.2,  0.4],
    ///        [ 0.1,  0.3,  0.2]]
    /// 
    ///   // sort along axis -1
    ///   argsort(x) = [[ 1.,  0.,  2.],
    ///                 [ 0.,  2.,  1.]]
    /// 
    ///   // sort along axis 0
    ///   argsort(x, axis=0) = [[ 1.,  0.,  1.]
    ///                         [ 0.,  1.,  0.]]
    /// 
    ///   // flatten and then sort
    ///   argsort(x, axis=None) = [ 3.,  1.,  5.,  0.,  4.,  2.]
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\ordering_op.cc:L183</summary>
    /// <param name="data">The input array</param>
    /// <param name="axis">Axis along which to sort the input tensor. If not given, the flattened array is used. Default is -1.</param>
    /// <param name="isAscend">Whether to sort in ascending or descending order.</param>
    /// <param name="dtype">DType of the output indices. It is only valid when ret_typ is &quot;indices&quot; or &quot;both&quot;. An error will be raised if the selected data type cannot precisely represent the indices.</param>
    static member Argsort(data : NDArray, [<Optional>] ?axis : int, [<Optional>] ?isAscend : bool, [<Optional>] ?dtype : DataType) =
        let creator = AtomicSymbolCreator.FromName "argsort"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle|]
                                                 [|"axis"; "is_ascend"; "dtype"|]
                                                 [|(match axis with None -> "None" | Some axis -> string axis); (match isAscend with None -> "true" | Some isAscend -> string isAscend); (match dtype with None -> "float32" | Some dtype -> string dtype)|]
        (new NDArray(outputs.[0]))
    /// <summary>Returns the indices that would sort an input array along the given axis.
    /// 
    /// This function performs sorting along the given axis and returns an array of indices having same shape
    /// as an input array that index data in sorted order.
    /// 
    /// Examples::
    /// 
    ///   x = [[ 0.3,  0.2,  0.4],
    ///        [ 0.1,  0.3,  0.2]]
    /// 
    ///   // sort along axis -1
    ///   argsort(x) = [[ 1.,  0.,  2.],
    ///                 [ 0.,  2.,  1.]]
    /// 
    ///   // sort along axis 0
    ///   argsort(x, axis=0) = [[ 1.,  0.,  1.]
    ///                         [ 0.,  1.,  0.]]
    /// 
    ///   // flatten and then sort
    ///   argsort(x, axis=None) = [ 3.,  1.,  5.,  0.,  4.,  2.]
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\ordering_op.cc:L183</summary>
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="data">The input array</param>
    /// <param name="axis">Axis along which to sort the input tensor. If not given, the flattened array is used. Default is -1.</param>
    /// <param name="isAscend">Whether to sort in ascending or descending order.</param>
    /// <param name="dtype">DType of the output indices. It is only valid when ret_typ is &quot;indices&quot; or &quot;both&quot;. An error will be raised if the selected data type cannot precisely represent the indices.</param>
    static member Argsort(outputArray : NDArray seq, data : NDArray, [<Optional>] ?axis : int, [<Optional>] ?isAscend : bool, [<Optional>] ?dtype : DataType) =
        let creator = AtomicSymbolCreator.FromName "argsort"
        let names = [|"axis"; "is_ascend"; "dtype"|]
        let vals = [|(match axis with None -> "None" | Some axis -> string axis); (match isAscend with None -> "true" | Some isAscend -> string isAscend); (match dtype with None -> "float32" | Some dtype -> string dtype)|]
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <summary>Returns the indices that would sort an input array along the given axis.
    /// 
    /// This function performs sorting along the given axis and returns an array of indices having same shape
    /// as an input array that index data in sorted order.
    /// 
    /// Examples::
    /// 
    ///   x = [[ 0.3,  0.2,  0.4],
    ///        [ 0.1,  0.3,  0.2]]
    /// 
    ///   // sort along axis -1
    ///   argsort(x) = [[ 1.,  0.,  2.],
    ///                 [ 0.,  2.,  1.]]
    /// 
    ///   // sort along axis 0
    ///   argsort(x, axis=0) = [[ 1.,  0.,  1.]
    ///                         [ 0.,  1.,  0.]]
    /// 
    ///   // flatten and then sort
    ///   argsort(x, axis=None) = [ 3.,  1.,  5.,  0.,  4.,  2.]
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\ordering_op.cc:L183</summary>
    /// <param name="data">The input array</param>
    /// <param name="axis">Axis along which to sort the input tensor. If not given, the flattened array is used. Default is -1.</param>
    /// <param name="isAscend">Whether to sort in ascending or descending order.</param>
    /// <param name="dtype">DType of the output indices. It is only valid when ret_typ is &quot;indices&quot; or &quot;both&quot;. An error will be raised if the selected data type cannot precisely represent the indices.</param>
    static member Argsort([<Optional>] ?data : Symbol, [<Optional>] ?axis : int, [<Optional>] ?isAscend : bool, [<Optional>] ?dtype : DataType) =
        Argsort(?data = data, ?axis = axis, ?isAscend = isAscend, ?dtype = dtype)

    /// <summary>Converts a batch of index arrays into an array of flat indices. The operator follows numpy conventions so a single multi index is given by a column of the input matrix. The leading dimension may be left unspecified by using -1 as placeholder.  
    /// 
    /// Examples::
    ///    
    ///    A = [[3,6,6],[4,5,1]]
    ///    ravel(A, shape=(7,6)) = [22,41,37]
    ///    ravel(A, shape=(-1,6)) = [22,41,37]
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\ravel.cc:L42</summary>
    /// <param name="data">Batch of multi-indices</param>
    /// <param name="shape">Shape of the array into which the multi-indices apply.</param>
    static member RavelMultiIndex(data : NDArray, [<Optional>] shape : int seq) =
        let creator = AtomicSymbolCreator.FromName "_ravel_multi_index"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle|]
                                                 [|"shape"|]
                                                 [|(if isNull (shape :> obj) then null else (shape |> Seq.map string |> String.concat ", " |> sprintf "[%s]"))|]
        (new NDArray(outputs.[0]))
    /// <summary>Converts a batch of index arrays into an array of flat indices. The operator follows numpy conventions so a single multi index is given by a column of the input matrix. The leading dimension may be left unspecified by using -1 as placeholder.  
    /// 
    /// Examples::
    ///    
    ///    A = [[3,6,6],[4,5,1]]
    ///    ravel(A, shape=(7,6)) = [22,41,37]
    ///    ravel(A, shape=(-1,6)) = [22,41,37]
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\ravel.cc:L42</summary>
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="data">Batch of multi-indices</param>
    /// <param name="shape">Shape of the array into which the multi-indices apply.</param>
    static member RavelMultiIndex(outputArray : NDArray seq, data : NDArray, [<Optional>] shape : int seq) =
        let creator = AtomicSymbolCreator.FromName "_ravel_multi_index"
        let names = [|"shape"|]
        let vals = [|(if isNull (shape :> obj) then null else (shape |> Seq.map string |> String.concat ", " |> sprintf "[%s]"))|]
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <summary>Converts a batch of index arrays into an array of flat indices. The operator follows numpy conventions so a single multi index is given by a column of the input matrix. The leading dimension may be left unspecified by using -1 as placeholder.  
    /// 
    /// Examples::
    ///    
    ///    A = [[3,6,6],[4,5,1]]
    ///    ravel(A, shape=(7,6)) = [22,41,37]
    ///    ravel(A, shape=(-1,6)) = [22,41,37]
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\ravel.cc:L42</summary>
    /// <param name="data">Batch of multi-indices</param>
    /// <param name="shape">Shape of the array into which the multi-indices apply.</param>
    static member RavelMultiIndex([<Optional>] ?data : Symbol, [<Optional>] ?shape : int seq) =
        RavelMultiIndex(?data = data, ?shape = shape)

    /// <summary>Converts an array of flat indices into a batch of index arrays. The operator follows numpy conventions so a single multi index is given by a column of the output matrix. The leading dimension may be left unspecified by using -1 as placeholder.  
    /// 
    /// Examples::
    /// 
    ///    A = [22,41,37]
    ///    unravel(A, shape=(7,6)) = [[3,6,6],[4,5,1]]
    ///    unravel(A, shape=(-1,6)) = [[3,6,6],[4,5,1]]
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\ravel.cc:L68</summary>
    /// <param name="data">Array of flat indices</param>
    /// <param name="shape">Shape of the array into which the multi-indices apply.</param>
    static member UnravelIndex(data : NDArray, [<Optional>] shape : int seq) =
        let creator = AtomicSymbolCreator.FromName "_unravel_index"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle|]
                                                 [|"shape"|]
                                                 [|(if isNull (shape :> obj) then null else (shape |> Seq.map string |> String.concat ", " |> sprintf "[%s]"))|]
        (new NDArray(outputs.[0]))
    /// <summary>Converts an array of flat indices into a batch of index arrays. The operator follows numpy conventions so a single multi index is given by a column of the output matrix. The leading dimension may be left unspecified by using -1 as placeholder.  
    /// 
    /// Examples::
    /// 
    ///    A = [22,41,37]
    ///    unravel(A, shape=(7,6)) = [[3,6,6],[4,5,1]]
    ///    unravel(A, shape=(-1,6)) = [[3,6,6],[4,5,1]]
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\ravel.cc:L68</summary>
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="data">Array of flat indices</param>
    /// <param name="shape">Shape of the array into which the multi-indices apply.</param>
    static member UnravelIndex(outputArray : NDArray seq, data : NDArray, [<Optional>] shape : int seq) =
        let creator = AtomicSymbolCreator.FromName "_unravel_index"
        let names = [|"shape"|]
        let vals = [|(if isNull (shape :> obj) then null else (shape |> Seq.map string |> String.concat ", " |> sprintf "[%s]"))|]
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <summary>Converts an array of flat indices into a batch of index arrays. The operator follows numpy conventions so a single multi index is given by a column of the output matrix. The leading dimension may be left unspecified by using -1 as placeholder.  
    /// 
    /// Examples::
    /// 
    ///    A = [22,41,37]
    ///    unravel(A, shape=(7,6)) = [[3,6,6],[4,5,1]]
    ///    unravel(A, shape=(-1,6)) = [[3,6,6],[4,5,1]]
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\ravel.cc:L68</summary>
    /// <param name="data">Array of flat indices</param>
    /// <param name="shape">Shape of the array into which the multi-indices apply.</param>
    static member UnravelIndex([<Optional>] ?data : Symbol, [<Optional>] ?shape : int seq) =
        UnravelIndex(?data = data, ?shape = shape)

    /// <summary>Pick rows specified by user input index array from a row sparse matrix
    /// and save them in the output sparse matrix.
    /// 
    /// Example::
    /// 
    ///   data = [[1, 2], [3, 4], [5, 6]]
    ///   indices = [0, 1, 3]
    ///   shape = (4, 2)
    ///   rsp_in = row_sparse_array(data, indices)
    ///   to_retain = [0, 3]
    ///   rsp_out = retain(rsp_in, to_retain)
    ///   rsp_out.data = [[1, 2], [5, 6]]
    ///   rsp_out.indices = [0, 3]
    /// 
    /// The storage type of ``retain`` output depends on storage types of inputs
    /// 
    /// - retain(row_sparse, default) = row_sparse
    /// - otherwise, ``retain`` is not supported
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\sparse_retain.cc:L53</summary>
    /// <param name="data">The input array for sparse_retain operator.</param>
    /// <param name="indices">The index array of rows ids that will be retained.</param>
    static member SparseRetain(data : NDArray, indices : NDArray) =
        let creator = AtomicSymbolCreator.FromName "_sparse_retain"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg indices)) then indices.UnsafeHandle|]
                                                 Array.empty
                                                 Array.empty
        (new NDArray(outputs.[0]))
    /// <summary>Pick rows specified by user input index array from a row sparse matrix
    /// and save them in the output sparse matrix.
    /// 
    /// Example::
    /// 
    ///   data = [[1, 2], [3, 4], [5, 6]]
    ///   indices = [0, 1, 3]
    ///   shape = (4, 2)
    ///   rsp_in = row_sparse_array(data, indices)
    ///   to_retain = [0, 3]
    ///   rsp_out = retain(rsp_in, to_retain)
    ///   rsp_out.data = [[1, 2], [5, 6]]
    ///   rsp_out.indices = [0, 3]
    /// 
    /// The storage type of ``retain`` output depends on storage types of inputs
    /// 
    /// - retain(row_sparse, default) = row_sparse
    /// - otherwise, ``retain`` is not supported
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\sparse_retain.cc:L53</summary>
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="data">The input array for sparse_retain operator.</param>
    /// <param name="indices">The index array of rows ids that will be retained.</param>
    static member SparseRetain(outputArray : NDArray seq, data : NDArray, indices : NDArray) =
        let creator = AtomicSymbolCreator.FromName "_sparse_retain"
        let names = Array.empty
        let vals = Array.empty
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg indices)) then indices.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <summary>Pick rows specified by user input index array from a row sparse matrix
    /// and save them in the output sparse matrix.
    /// 
    /// Example::
    /// 
    ///   data = [[1, 2], [3, 4], [5, 6]]
    ///   indices = [0, 1, 3]
    ///   shape = (4, 2)
    ///   rsp_in = row_sparse_array(data, indices)
    ///   to_retain = [0, 3]
    ///   rsp_out = retain(rsp_in, to_retain)
    ///   rsp_out.data = [[1, 2], [5, 6]]
    ///   rsp_out.indices = [0, 3]
    /// 
    /// The storage type of ``retain`` output depends on storage types of inputs
    /// 
    /// - retain(row_sparse, default) = row_sparse
    /// - otherwise, ``retain`` is not supported
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\sparse_retain.cc:L53</summary>
    /// <param name="data">The input array for sparse_retain operator.</param>
    /// <param name="indices">The index array of rows ids that will be retained.</param>
    static member SparseRetain([<Optional>] ?data : Symbol, [<Optional>] ?indices : Symbol) =
        SparseRetain(?data = data, ?indices = indices)


    /// <summary>Computes the square sum of array elements over a given axis
    /// for row-sparse matrix. This is a temporary solution for fusing ops square and
    /// sum together for row-sparse matrix to save memory for storing gradients.
    /// It will become deprecated once the functionality of fusing operators is finished
    /// in the future.
    /// 
    /// Example::
    /// 
    ///   dns = mx.nd.array([[0, 0], [1, 2], [0, 0], [3, 4], [0, 0]])
    ///   rsp = dns.tostype(&#39;row_sparse&#39;)
    ///   sum = mx.nd._internal._square_sum(rsp, axis=1)
    ///   sum = [0, 5, 0, 25, 0]
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\square_sum.cc:L63</summary>
    /// <param name="data">The input</param>
    /// <param name="axis">The axis or axes along which to perform the reduction.
    /// 
    ///       The default, `axis=()`, will compute over all elements into a
    ///       scalar array with shape `(1,)`.
    /// 
    ///       If `axis` is int, a reduction is performed on a particular axis.
    /// 
    ///       If `axis` is a tuple of ints, a reduction is performed on all the axes
    ///       specified in the tuple.
    /// 
    ///       If `exclude` is true, reduction will be performed on the axes that are
    ///       NOT in axis instead.
    /// 
    ///       Negative values means indexing from right to left.</param>
    /// <param name="keepdims">If this is set to `True`, the reduced axes are left in the result as dimension with size one.</param>
    /// <param name="exclude">Whether to perform reduction on axis that are NOT in axis instead.</param>
    static member SquareSum(data : NDArray, [<Optional>] ?axis : int seq, [<Optional>] ?keepdims : bool, [<Optional>] ?exclude : bool) =
        let creator = AtomicSymbolCreator.FromName "_square_sum"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle|]
                                                 [|"axis"; "keepdims"; "exclude"|]
                                                 [|(match axis with None -> "None" | Some axis -> (axis |> Seq.map string |> String.concat ", " |> sprintf "[%s]")); (match keepdims with None -> "false" | Some keepdims -> string keepdims); (match exclude with None -> "false" | Some exclude -> string exclude)|]
        (new NDArray(outputs.[0]))
    /// <summary>Computes the square sum of array elements over a given axis
    /// for row-sparse matrix. This is a temporary solution for fusing ops square and
    /// sum together for row-sparse matrix to save memory for storing gradients.
    /// It will become deprecated once the functionality of fusing operators is finished
    /// in the future.
    /// 
    /// Example::
    /// 
    ///   dns = mx.nd.array([[0, 0], [1, 2], [0, 0], [3, 4], [0, 0]])
    ///   rsp = dns.tostype(&#39;row_sparse&#39;)
    ///   sum = mx.nd._internal._square_sum(rsp, axis=1)
    ///   sum = [0, 5, 0, 25, 0]
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\square_sum.cc:L63</summary>
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="data">The input</param>
    /// <param name="axis">The axis or axes along which to perform the reduction.
    /// 
    ///       The default, `axis=()`, will compute over all elements into a
    ///       scalar array with shape `(1,)`.
    /// 
    ///       If `axis` is int, a reduction is performed on a particular axis.
    /// 
    ///       If `axis` is a tuple of ints, a reduction is performed on all the axes
    ///       specified in the tuple.
    /// 
    ///       If `exclude` is true, reduction will be performed on the axes that are
    ///       NOT in axis instead.
    /// 
    ///       Negative values means indexing from right to left.</param>
    /// <param name="keepdims">If this is set to `True`, the reduced axes are left in the result as dimension with size one.</param>
    /// <param name="exclude">Whether to perform reduction on axis that are NOT in axis instead.</param>
    static member SquareSum(outputArray : NDArray seq, data : NDArray, [<Optional>] ?axis : int seq, [<Optional>] ?keepdims : bool, [<Optional>] ?exclude : bool) =
        let creator = AtomicSymbolCreator.FromName "_square_sum"
        let names = [|"axis"; "keepdims"; "exclude"|]
        let vals = [|(match axis with None -> "None" | Some axis -> (axis |> Seq.map string |> String.concat ", " |> sprintf "[%s]")); (match keepdims with None -> "false" | Some keepdims -> string keepdims); (match exclude with None -> "false" | Some exclude -> string exclude)|]
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <summary>Computes the square sum of array elements over a given axis
    /// for row-sparse matrix. This is a temporary solution for fusing ops square and
    /// sum together for row-sparse matrix to save memory for storing gradients.
    /// It will become deprecated once the functionality of fusing operators is finished
    /// in the future.
    /// 
    /// Example::
    /// 
    ///   dns = mx.nd.array([[0, 0], [1, 2], [0, 0], [3, 4], [0, 0]])
    ///   rsp = dns.tostype(&#39;row_sparse&#39;)
    ///   sum = mx.nd._internal._square_sum(rsp, axis=1)
    ///   sum = [0, 5, 0, 25, 0]
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\tensor\square_sum.cc:L63</summary>
    /// <param name="data">The input</param>
    /// <param name="axis">The axis or axes along which to perform the reduction.
    /// 
    ///       The default, `axis=()`, will compute over all elements into a
    ///       scalar array with shape `(1,)`.
    /// 
    ///       If `axis` is int, a reduction is performed on a particular axis.
    /// 
    ///       If `axis` is a tuple of ints, a reduction is performed on all the axes
    ///       specified in the tuple.
    /// 
    ///       If `exclude` is true, reduction will be performed on the axes that are
    ///       NOT in axis instead.
    /// 
    ///       Negative values means indexing from right to left.</param>
    /// <param name="keepdims">If this is set to `True`, the reduced axes are left in the result as dimension with size one.</param>
    /// <param name="exclude">Whether to perform reduction on axis that are NOT in axis instead.</param>
    static member SquareSum([<Optional>] ?data : Symbol, [<Optional>] ?axis : int seq, [<Optional>] ?keepdims : bool, [<Optional>] ?exclude : bool) =
        SquareSum(?data = data, ?axis = axis, ?keepdims = keepdims, ?exclude = exclude)


    /// <summary>Generate mask targets for Mask-RCNN.</summary>
    /// <param name="rois">Bounding box coordinates, a 3D array</param>
    /// <param name="gtMasks">Input masks of full image size, a 4D array</param>
    /// <param name="matches">Index to a gt_mask, a 2D array</param>
    /// <param name="clsTargets">Value [0, num_class), excluding background class, a 2D array</param>
    /// <param name="numRois">Number of sampled RoIs.</param>
    /// <param name="numClasses">Number of classes.</param>
    /// <param name="maskSize">Size of the pooled masks height and width: (h, w).</param>
    /// <param name="sampleRatio">Sampling ratio of ROI align. Set to -1 to use adaptative size.</param>
    static member ContribMrcnnMaskTarget(rois : NDArray, 
                                         gtMasks : NDArray, 
                                         matches : NDArray, 
                                         clsTargets : NDArray, 
                                         numRois : int, 
                                         numClasses : int, 
                                         maskSize : int seq, 
                                         [<Optional; DefaultParameterValue(2)>] sampleRatio : int) =
        let creator = AtomicSymbolCreator.FromName "_contrib_mrcnn_mask_target"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg rois)) then rois.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg gtMasks)) then gtMasks.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg matches)) then matches.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg clsTargets)) then clsTargets.UnsafeHandle|]
                                                 [|"num_rois"; "num_classes"; "mask_size"; "sample_ratio"|]
                                                 [|string numRois; string numClasses; (maskSize |> Seq.map string |> String.concat ", " |> sprintf "[%s]"); string sampleRatio|]
        outputs |> Array.map (fun h -> new NDArray(h))
    /// <summary>Generate mask targets for Mask-RCNN.</summary>
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="rois">Bounding box coordinates, a 3D array</param>
    /// <param name="gtMasks">Input masks of full image size, a 4D array</param>
    /// <param name="matches">Index to a gt_mask, a 2D array</param>
    /// <param name="clsTargets">Value [0, num_class), excluding background class, a 2D array</param>
    /// <param name="numRois">Number of sampled RoIs.</param>
    /// <param name="numClasses">Number of classes.</param>
    /// <param name="maskSize">Size of the pooled masks height and width: (h, w).</param>
    /// <param name="sampleRatio">Sampling ratio of ROI align. Set to -1 to use adaptative size.</param>
    static member ContribMrcnnMaskTarget(outputArray : NDArray seq, 
                                         rois : NDArray, 
                                         gtMasks : NDArray, 
                                         matches : NDArray, 
                                         clsTargets : NDArray, 
                                         numRois : int, 
                                         numClasses : int, 
                                         maskSize : int seq, 
                                         [<Optional; DefaultParameterValue(2)>] sampleRatio : int) =
        let creator = AtomicSymbolCreator.FromName "_contrib_mrcnn_mask_target"
        let names = [|"num_rois"; "num_classes"; "mask_size"; "sample_ratio"|]
        let vals = [|string numRois; string numClasses; (maskSize |> Seq.map string |> String.concat ", " |> sprintf "[%s]"); string sampleRatio|]
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg rois)) then rois.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg gtMasks)) then gtMasks.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg matches)) then matches.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg clsTargets)) then clsTargets.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <summary>Generate mask targets for Mask-RCNN.</summary>
    /// <param name="rois">Bounding box coordinates, a 3D array</param>
    /// <param name="gtMasks">Input masks of full image size, a 4D array</param>
    /// <param name="matches">Index to a gt_mask, a 2D array</param>
    /// <param name="clsTargets">Value [0, num_class), excluding background class, a 2D array</param>
    /// <param name="numRois">Number of sampled RoIs.</param>
    /// <param name="numClasses">Number of classes.</param>
    /// <param name="maskSize">Size of the pooled masks height and width: (h, w).</param>
    /// <param name="sampleRatio">Sampling ratio of ROI align. Set to -1 to use adaptative size.</param>
    static member ContribMrcnnMaskTarget(rois : Symbol, gtMasks : Symbol, matches : Symbol, clsTargets : Symbol, numRois : int, numClasses : int, maskSize : int seq, [<Optional>] ?sampleRatio : int) =
        ContribMrcnnMaskTarget(rois, gtMasks, matches, clsTargets, numRois, numClasses, maskSize, ?sampleRatio = sampleRatio)
    /// <summary>Generate mask targets for Mask-RCNN.</summary>
    /// <param name="numRois">Number of sampled RoIs.</param>
    /// <param name="numClasses">Number of classes.</param>
    /// <param name="maskSize">Size of the pooled masks height and width: (h, w).</param>
    /// <param name="rois">Bounding box coordinates, a 3D array</param>
    /// <param name="gtMasks">Input masks of full image size, a 4D array</param>
    /// <param name="matches">Index to a gt_mask, a 2D array</param>
    /// <param name="clsTargets">Value [0, num_class), excluding background class, a 2D array</param>
    /// <param name="sampleRatio">Sampling ratio of ROI align. Set to -1 to use adaptative size.</param>
    static member ContribMrcnnMaskTarget(numRois : int, numClasses : int, maskSize : int seq, [<Optional>] ?rois : Symbol, [<Optional>] ?gtMasks : Symbol, [<Optional>] ?matches : Symbol, [<Optional>] ?clsTargets : Symbol, [<Optional>] ?sampleRatio : int) =
        ContribMrcnnMaskTarget(numRois, numClasses, maskSize, ?rois = rois, ?gtMasks = gtMasks, ?matches = matches, ?clsTargets = clsTargets, ?sampleRatio = sampleRatio)


    /// <summary>Applies bilinear sampling to input feature map.
    /// 
    /// Bilinear Sampling is the key of  [NIPS2015] \&quot;Spatial Transformer Networks\&quot;. The usage of the operator is very similar to remap function in OpenCV,
    /// except that the operator has the backward pass.
    /// 
    /// Given :math:`data` and :math:`grid`, then the output is computed by
    /// 
    /// .. math::
    ///   x_{src} = grid[batch, 0, y_{dst}, x_{dst}] \\
    ///   y_{src} = grid[batch, 1, y_{dst}, x_{dst}] \\
    ///   output[batch, channel, y_{dst}, x_{dst}] = G(data[batch, channel, y_{src}, x_{src})
    /// 
    /// :math:`x_{dst}`, :math:`y_{dst}` enumerate all spatial locations in :math:`output`, and :math:`G()` denotes the bilinear interpolation kernel.
    /// The out-boundary points will be padded with zeros.The shape of the output will be (data.shape[0], data.shape[1], grid.shape[2], grid.shape[3]).
    /// 
    /// The operator assumes that :math:`data` has &#39;NCHW&#39; layout and :math:`grid` has been normalized to [-1, 1].
    /// 
    /// BilinearSampler often cooperates with GridGenerator which generates sampling grids for BilinearSampler.
    /// GridGenerator supports two kinds of transformation: ``affine`` and ``warp``.
    /// If users want to design a CustomOp to manipulate :math:`grid`, please firstly refer to the code of GridGenerator.
    /// 
    /// Example 1::
    /// 
    ///   ## Zoom out data two times
    ///   data = array([[[[1, 4, 3, 6],
    ///                   [1, 8, 8, 9],
    ///                   [0, 4, 1, 5],
    ///                   [1, 0, 1, 3]]]])
    /// 
    ///   affine_matrix = array([[2, 0, 0],
    ///                          [0, 2, 0]])
    /// 
    ///   affine_matrix = reshape(affine_matrix, shape=(1, 6))
    /// 
    ///   grid = GridGenerator(data=affine_matrix, transform_type=&#39;affine&#39;, target_shape=(4, 4))
    /// 
    ///   out = BilinearSampler(data, grid)
    /// 
    ///   out
    ///   [[[[ 0,   0,     0,   0],
    ///      [ 0,   3.5,   6.5, 0],
    ///      [ 0,   1.25,  2.5, 0],
    ///      [ 0,   0,     0,   0]]]
    /// 
    /// 
    /// Example 2::
    /// 
    ///   ## shift data horizontally by -1 pixel
    /// 
    ///   data = array([[[[1, 4, 3, 6],
    ///                   [1, 8, 8, 9],
    ///                   [0, 4, 1, 5],
    ///                   [1, 0, 1, 3]]]])
    /// 
    ///   warp_maxtrix = array([[[[1, 1, 1, 1],
    ///                           [1, 1, 1, 1],
    ///                           [1, 1, 1, 1],
    ///                           [1, 1, 1, 1]],
    ///                          [[0, 0, 0, 0],
    ///                           [0, 0, 0, 0],
    ///                           [0, 0, 0, 0],
    ///                           [0, 0, 0, 0]]]])
    /// 
    ///   grid = GridGenerator(data=warp_matrix, transform_type=&#39;warp&#39;)
    ///   out = BilinearSampler(data, grid)
    /// 
    ///   out
    ///   [[[[ 4,  3,  6,  0],
    ///      [ 8,  8,  9,  0],
    ///      [ 4,  1,  5,  0],
    ///      [ 0,  1,  3,  0]]]
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\bilinear_sampler.cc:L256</summary>
    /// <param name="data">Input data to the BilinearsamplerOp.</param>
    /// <param name="grid">Input grid to the BilinearsamplerOp.grid has two channels: x_src, y_src</param>
    /// <param name="cudnnOff">whether to turn cudnn off</param>
    static member BilinearSampler(data : NDArray, grid : NDArray, [<Optional>] ?cudnnOff : bool) =
        let creator = AtomicSymbolCreator.FromName "BilinearSampler"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg grid)) then grid.UnsafeHandle|]
                                                 [|"cudnn_off"|]
                                                 [|(match cudnnOff with None -> "None" | Some cudnnOff -> string cudnnOff)|]
        outputs |> Array.map (fun h -> new NDArray(h))
    /// <summary>Applies bilinear sampling to input feature map.
    /// 
    /// Bilinear Sampling is the key of  [NIPS2015] \&quot;Spatial Transformer Networks\&quot;. The usage of the operator is very similar to remap function in OpenCV,
    /// except that the operator has the backward pass.
    /// 
    /// Given :math:`data` and :math:`grid`, then the output is computed by
    /// 
    /// .. math::
    ///   x_{src} = grid[batch, 0, y_{dst}, x_{dst}] \\
    ///   y_{src} = grid[batch, 1, y_{dst}, x_{dst}] \\
    ///   output[batch, channel, y_{dst}, x_{dst}] = G(data[batch, channel, y_{src}, x_{src})
    /// 
    /// :math:`x_{dst}`, :math:`y_{dst}` enumerate all spatial locations in :math:`output`, and :math:`G()` denotes the bilinear interpolation kernel.
    /// The out-boundary points will be padded with zeros.The shape of the output will be (data.shape[0], data.shape[1], grid.shape[2], grid.shape[3]).
    /// 
    /// The operator assumes that :math:`data` has &#39;NCHW&#39; layout and :math:`grid` has been normalized to [-1, 1].
    /// 
    /// BilinearSampler often cooperates with GridGenerator which generates sampling grids for BilinearSampler.
    /// GridGenerator supports two kinds of transformation: ``affine`` and ``warp``.
    /// If users want to design a CustomOp to manipulate :math:`grid`, please firstly refer to the code of GridGenerator.
    /// 
    /// Example 1::
    /// 
    ///   ## Zoom out data two times
    ///   data = array([[[[1, 4, 3, 6],
    ///                   [1, 8, 8, 9],
    ///                   [0, 4, 1, 5],
    ///                   [1, 0, 1, 3]]]])
    /// 
    ///   affine_matrix = array([[2, 0, 0],
    ///                          [0, 2, 0]])
    /// 
    ///   affine_matrix = reshape(affine_matrix, shape=(1, 6))
    /// 
    ///   grid = GridGenerator(data=affine_matrix, transform_type=&#39;affine&#39;, target_shape=(4, 4))
    /// 
    ///   out = BilinearSampler(data, grid)
    /// 
    ///   out
    ///   [[[[ 0,   0,     0,   0],
    ///      [ 0,   3.5,   6.5, 0],
    ///      [ 0,   1.25,  2.5, 0],
    ///      [ 0,   0,     0,   0]]]
    /// 
    /// 
    /// Example 2::
    /// 
    ///   ## shift data horizontally by -1 pixel
    /// 
    ///   data = array([[[[1, 4, 3, 6],
    ///                   [1, 8, 8, 9],
    ///                   [0, 4, 1, 5],
    ///                   [1, 0, 1, 3]]]])
    /// 
    ///   warp_maxtrix = array([[[[1, 1, 1, 1],
    ///                           [1, 1, 1, 1],
    ///                           [1, 1, 1, 1],
    ///                           [1, 1, 1, 1]],
    ///                          [[0, 0, 0, 0],
    ///                           [0, 0, 0, 0],
    ///                           [0, 0, 0, 0],
    ///                           [0, 0, 0, 0]]]])
    /// 
    ///   grid = GridGenerator(data=warp_matrix, transform_type=&#39;warp&#39;)
    ///   out = BilinearSampler(data, grid)
    /// 
    ///   out
    ///   [[[[ 4,  3,  6,  0],
    ///      [ 8,  8,  9,  0],
    ///      [ 4,  1,  5,  0],
    ///      [ 0,  1,  3,  0]]]
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\bilinear_sampler.cc:L256</summary>
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="data">Input data to the BilinearsamplerOp.</param>
    /// <param name="grid">Input grid to the BilinearsamplerOp.grid has two channels: x_src, y_src</param>
    /// <param name="cudnnOff">whether to turn cudnn off</param>
    static member BilinearSampler(outputArray : NDArray seq, data : NDArray, grid : NDArray, [<Optional>] ?cudnnOff : bool) =
        let creator = AtomicSymbolCreator.FromName "BilinearSampler"
        let names = [|"cudnn_off"|]
        let vals = [|(match cudnnOff with None -> "None" | Some cudnnOff -> string cudnnOff)|]
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg grid)) then grid.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <summary>Applies bilinear sampling to input feature map.
    /// 
    /// Bilinear Sampling is the key of  [NIPS2015] \&quot;Spatial Transformer Networks\&quot;. The usage of the operator is very similar to remap function in OpenCV,
    /// except that the operator has the backward pass.
    /// 
    /// Given :math:`data` and :math:`grid`, then the output is computed by
    /// 
    /// .. math::
    ///   x_{src} = grid[batch, 0, y_{dst}, x_{dst}] \\
    ///   y_{src} = grid[batch, 1, y_{dst}, x_{dst}] \\
    ///   output[batch, channel, y_{dst}, x_{dst}] = G(data[batch, channel, y_{src}, x_{src})
    /// 
    /// :math:`x_{dst}`, :math:`y_{dst}` enumerate all spatial locations in :math:`output`, and :math:`G()` denotes the bilinear interpolation kernel.
    /// The out-boundary points will be padded with zeros.The shape of the output will be (data.shape[0], data.shape[1], grid.shape[2], grid.shape[3]).
    /// 
    /// The operator assumes that :math:`data` has &#39;NCHW&#39; layout and :math:`grid` has been normalized to [-1, 1].
    /// 
    /// BilinearSampler often cooperates with GridGenerator which generates sampling grids for BilinearSampler.
    /// GridGenerator supports two kinds of transformation: ``affine`` and ``warp``.
    /// If users want to design a CustomOp to manipulate :math:`grid`, please firstly refer to the code of GridGenerator.
    /// 
    /// Example 1::
    /// 
    ///   ## Zoom out data two times
    ///   data = array([[[[1, 4, 3, 6],
    ///                   [1, 8, 8, 9],
    ///                   [0, 4, 1, 5],
    ///                   [1, 0, 1, 3]]]])
    /// 
    ///   affine_matrix = array([[2, 0, 0],
    ///                          [0, 2, 0]])
    /// 
    ///   affine_matrix = reshape(affine_matrix, shape=(1, 6))
    /// 
    ///   grid = GridGenerator(data=affine_matrix, transform_type=&#39;affine&#39;, target_shape=(4, 4))
    /// 
    ///   out = BilinearSampler(data, grid)
    /// 
    ///   out
    ///   [[[[ 0,   0,     0,   0],
    ///      [ 0,   3.5,   6.5, 0],
    ///      [ 0,   1.25,  2.5, 0],
    ///      [ 0,   0,     0,   0]]]
    /// 
    /// 
    /// Example 2::
    /// 
    ///   ## shift data horizontally by -1 pixel
    /// 
    ///   data = array([[[[1, 4, 3, 6],
    ///                   [1, 8, 8, 9],
    ///                   [0, 4, 1, 5],
    ///                   [1, 0, 1, 3]]]])
    /// 
    ///   warp_maxtrix = array([[[[1, 1, 1, 1],
    ///                           [1, 1, 1, 1],
    ///                           [1, 1, 1, 1],
    ///                           [1, 1, 1, 1]],
    ///                          [[0, 0, 0, 0],
    ///                           [0, 0, 0, 0],
    ///                           [0, 0, 0, 0],
    ///                           [0, 0, 0, 0]]]])
    /// 
    ///   grid = GridGenerator(data=warp_matrix, transform_type=&#39;warp&#39;)
    ///   out = BilinearSampler(data, grid)
    /// 
    ///   out
    ///   [[[[ 4,  3,  6,  0],
    ///      [ 8,  8,  9,  0],
    ///      [ 4,  1,  5,  0],
    ///      [ 0,  1,  3,  0]]]
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\bilinear_sampler.cc:L256</summary>
    /// <param name="data">Input data to the BilinearsamplerOp.</param>
    /// <param name="grid">Input grid to the BilinearsamplerOp.grid has two channels: x_src, y_src</param>
    /// <param name="cudnnOff">whether to turn cudnn off</param>
    static member BilinearSampler([<Optional>] ?data : Symbol, [<Optional>] ?grid : Symbol, [<Optional>] ?cudnnOff : bool) =
        BilinearSampler(?data = data, ?grid = grid, ?cudnnOff = cudnnOff)


    /// <summary>Apply CountSketch to input: map a d-dimension data to k-dimension data&quot;
    /// 
    /// .. note:: `count_sketch` is only available on GPU.
    /// 
    /// Assume input data has shape (N, d), sign hash table s has shape (N, d),
    /// index hash table h has shape (N, d) and mapping dimension out_dim = k,
    /// each element in s is either +1 or -1, each element in h is random integer from 0 to k-1.
    /// Then the operator computs:
    /// 
    /// .. math::
    ///    out[h[i]] += data[i] * s[i]
    /// 
    /// Example::
    /// 
    ///    out_dim = 5
    ///    x = [[1.2, 2.5, 3.4],[3.2, 5.7, 6.6]]
    ///    h = [[0, 3, 4]]
    ///    s = [[1, -1, 1]]
    ///    mx.contrib.ndarray.count_sketch(data=x, h=h, s=s, out_dim = 5) = [[1.2, 0, 0, -2.5, 3.4],
    ///                                                                      [3.2, 0, 0, -5.7, 6.6]]
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\contrib\count_sketch.cc:L67</summary>
    /// <param name="data">Input data to the CountSketchOp.</param>
    /// <param name="h">The index vector</param>
    /// <param name="s">The sign vector</param>
    /// <param name="outDim">The output dimension.</param>
    /// <param name="processingBatchSize">How many sketch vectors to process at one time.</param>
    static member ContribCountSketch(data : NDArray, 
                                     h : NDArray, 
                                     s : NDArray, 
                                     outDim : int, 
                                     [<Optional; DefaultParameterValue(32)>] processingBatchSize : int) =
        let creator = AtomicSymbolCreator.FromName "_contrib_count_sketch"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg h)) then h.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg s)) then s.UnsafeHandle|]
                                                 [|"out_dim"; "processing_batch_size"|]
                                                 [|string outDim; string processingBatchSize|]
        outputs |> Array.map (fun h -> new NDArray(h))
    /// <summary>Apply CountSketch to input: map a d-dimension data to k-dimension data&quot;
    /// 
    /// .. note:: `count_sketch` is only available on GPU.
    /// 
    /// Assume input data has shape (N, d), sign hash table s has shape (N, d),
    /// index hash table h has shape (N, d) and mapping dimension out_dim = k,
    /// each element in s is either +1 or -1, each element in h is random integer from 0 to k-1.
    /// Then the operator computs:
    /// 
    /// .. math::
    ///    out[h[i]] += data[i] * s[i]
    /// 
    /// Example::
    /// 
    ///    out_dim = 5
    ///    x = [[1.2, 2.5, 3.4],[3.2, 5.7, 6.6]]
    ///    h = [[0, 3, 4]]
    ///    s = [[1, -1, 1]]
    ///    mx.contrib.ndarray.count_sketch(data=x, h=h, s=s, out_dim = 5) = [[1.2, 0, 0, -2.5, 3.4],
    ///                                                                      [3.2, 0, 0, -5.7, 6.6]]
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\contrib\count_sketch.cc:L67</summary>
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="data">Input data to the CountSketchOp.</param>
    /// <param name="h">The index vector</param>
    /// <param name="s">The sign vector</param>
    /// <param name="outDim">The output dimension.</param>
    /// <param name="processingBatchSize">How many sketch vectors to process at one time.</param>
    static member ContribCountSketch(outputArray : NDArray seq, 
                                     data : NDArray, 
                                     h : NDArray, 
                                     s : NDArray, 
                                     outDim : int, 
                                     [<Optional; DefaultParameterValue(32)>] processingBatchSize : int) =
        let creator = AtomicSymbolCreator.FromName "_contrib_count_sketch"
        let names = [|"out_dim"; "processing_batch_size"|]
        let vals = [|string outDim; string processingBatchSize|]
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg h)) then h.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg s)) then s.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <summary>Apply CountSketch to input: map a d-dimension data to k-dimension data&quot;
    /// 
    /// .. note:: `count_sketch` is only available on GPU.
    /// 
    /// Assume input data has shape (N, d), sign hash table s has shape (N, d),
    /// index hash table h has shape (N, d) and mapping dimension out_dim = k,
    /// each element in s is either +1 or -1, each element in h is random integer from 0 to k-1.
    /// Then the operator computs:
    /// 
    /// .. math::
    ///    out[h[i]] += data[i] * s[i]
    /// 
    /// Example::
    /// 
    ///    out_dim = 5
    ///    x = [[1.2, 2.5, 3.4],[3.2, 5.7, 6.6]]
    ///    h = [[0, 3, 4]]
    ///    s = [[1, -1, 1]]
    ///    mx.contrib.ndarray.count_sketch(data=x, h=h, s=s, out_dim = 5) = [[1.2, 0, 0, -2.5, 3.4],
    ///                                                                      [3.2, 0, 0, -5.7, 6.6]]
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\contrib\count_sketch.cc:L67</summary>
    /// <param name="data">Input data to the CountSketchOp.</param>
    /// <param name="h">The index vector</param>
    /// <param name="s">The sign vector</param>
    /// <param name="outDim">The output dimension.</param>
    /// <param name="processingBatchSize">How many sketch vectors to process at one time.</param>
    static member ContribCountSketch(data : Symbol, h : Symbol, s : Symbol, outDim : int, [<Optional>] ?processingBatchSize : int) =
        ContribCountSketch(data, h, s, outDim, ?processingBatchSize = processingBatchSize)
    /// <summary>Apply CountSketch to input: map a d-dimension data to k-dimension data&quot;
    /// 
    /// .. note:: `count_sketch` is only available on GPU.
    /// 
    /// Assume input data has shape (N, d), sign hash table s has shape (N, d),
    /// index hash table h has shape (N, d) and mapping dimension out_dim = k,
    /// each element in s is either +1 or -1, each element in h is random integer from 0 to k-1.
    /// Then the operator computs:
    /// 
    /// .. math::
    ///    out[h[i]] += data[i] * s[i]
    /// 
    /// Example::
    /// 
    ///    out_dim = 5
    ///    x = [[1.2, 2.5, 3.4],[3.2, 5.7, 6.6]]
    ///    h = [[0, 3, 4]]
    ///    s = [[1, -1, 1]]
    ///    mx.contrib.ndarray.count_sketch(data=x, h=h, s=s, out_dim = 5) = [[1.2, 0, 0, -2.5, 3.4],
    ///                                                                      [3.2, 0, 0, -5.7, 6.6]]
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\contrib\count_sketch.cc:L67</summary>
    /// <param name="outDim">The output dimension.</param>
    /// <param name="data">Input data to the CountSketchOp.</param>
    /// <param name="h">The index vector</param>
    /// <param name="s">The sign vector</param>
    /// <param name="processingBatchSize">How many sketch vectors to process at one time.</param>
    static member ContribCountSketch(outDim : int, [<Optional>] ?data : Symbol, [<Optional>] ?h : Symbol, [<Optional>] ?s : Symbol, [<Optional>] ?processingBatchSize : int) =
        ContribCountSketch(outDim, ?data = data, ?h = h, ?s = s, ?processingBatchSize = processingBatchSize)


    /// <summary>Compute 2-D deformable convolution on 4-D input.
    /// 
    /// The deformable convolution operation is described in https://arxiv.org/abs/1703.06211
    /// 
    /// For 2-D deformable convolution, the shapes are
    /// 
    /// - **data**: *(batch_size, channel, height, width)*
    /// - **offset**: *(batch_size, num_deformable_group * kernel[0] * kernel[1] * 2, height, width)*
    /// - **weight**: *(num_filter, channel, kernel[0], kernel[1])*
    /// - **bias**: *(num_filter,)*
    /// - **out**: *(batch_size, num_filter, out_height, out_width)*.
    /// 
    /// Define::
    /// 
    ///   f(x,k,p,s,d) = floor((x+2*p-d*(k-1)-1)/s)+1
    /// 
    /// then we have::
    /// 
    ///   out_height=f(height, kernel[0], pad[0], stride[0], dilate[0])
    ///   out_width=f(width, kernel[1], pad[1], stride[1], dilate[1])
    /// 
    /// If ``no_bias`` is set to be true, then the ``bias`` term is ignored.
    /// 
    /// The default data ``layout`` is *NCHW*, namely *(batch_size, channle, height,
    /// width)*.
    /// 
    /// If ``num_group`` is larger than 1, denoted by *g*, then split the input ``data``
    /// evenly into *g* parts along the channel axis, and also evenly split ``weight``
    /// along the first dimension. Next compute the convolution on the *i*-th part of
    /// the data with the *i*-th weight part. The output is obtained by concating all
    /// the *g* results.
    /// 
    /// If ``num_deformable_group`` is larger than 1, denoted by *dg*, then split the
    /// input ``offset`` evenly into *dg* parts along the channel axis, and also evenly
    /// split ``data`` into *dg* parts along the channel axis. Next compute the
    /// deformable convolution, apply the *i*-th part of the offset on the *i*-th part
    /// of the data.
    /// 
    /// 
    /// Both ``weight`` and ``bias`` are learnable parameters.
    /// 
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\contrib\deformable_convolution.cc:L100</summary>
    /// <param name="data">Input data to the DeformableConvolutionOp.</param>
    /// <param name="offset">Input offset to the DeformableConvolutionOp.</param>
    /// <param name="weight">Weight matrix.</param>
    /// <param name="bias">Bias parameter.</param>
    /// <param name="kernel">Convolution kernel size: (h, w) or (d, h, w)</param>
    /// <param name="numFilter">Convolution filter(channel) number</param>
    /// <param name="stride">Convolution stride: (h, w) or (d, h, w). Defaults to 1 for each dimension.</param>
    /// <param name="dilate">Convolution dilate: (h, w) or (d, h, w). Defaults to 1 for each dimension.</param>
    /// <param name="pad">Zero pad for convolution: (h, w) or (d, h, w). Defaults to no padding.</param>
    /// <param name="numGroup">Number of group partitions.</param>
    /// <param name="numDeformableGroup">Number of deformable group partitions.</param>
    /// <param name="workspace">Maximum temperal workspace allowed for convolution (MB).</param>
    /// <param name="noBias">Whether to disable bias parameter.</param>
    /// <param name="layout">Set layout for input, output and weight. Empty for
    ///     default layout: NCW for 1d, NCHW for 2d and NCDHW for 3d.</param>
    static member ContribDeformableConvolution(data : NDArray, 
                                               offset : NDArray, 
                                               weight : NDArray, 
                                               bias : NDArray, 
                                               kernel : int seq, 
                                               numFilter : int, 
                                               [<Optional>] stride : int seq, 
                                               [<Optional>] dilate : int seq, 
                                               [<Optional>] pad : int seq, 
                                               [<Optional; DefaultParameterValue(1)>] numGroup : int, 
                                               [<Optional; DefaultParameterValue(1)>] numDeformableGroup : int, 
                                               [<Optional; DefaultParameterValue(1024L)>] workspace : int64, 
                                               [<Optional; DefaultParameterValue(false)>] noBias : bool, 
                                               [<Optional>] layout : ContribDeformableConvolutionLayout) =
        let creator = AtomicSymbolCreator.FromName "_contrib_DeformableConvolution"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg offset)) then offset.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg weight)) then weight.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg bias)) then bias.UnsafeHandle|]
                                                 [|"kernel"; "num_filter"; "stride"; "dilate"; "pad"; "num_group"; "num_deformable_group"; "workspace"; "no_bias"; "layout"|]
                                                 [|(kernel |> Seq.map string |> String.concat ", " |> sprintf "[%s]"); string numFilter; (if isNull (stride :> obj) then "[]" else (stride |> Seq.map string |> String.concat ", " |> sprintf "[%s]")); (if isNull (dilate :> obj) then "[]" else (dilate |> Seq.map string |> String.concat ", " |> sprintf "[%s]")); (if isNull (pad :> obj) then "[]" else (pad |> Seq.map string |> String.concat ", " |> sprintf "[%s]")); string numGroup; string numDeformableGroup; string workspace; string noBias; (if isNull (layout :> obj) then "None" else string layout)|]
        outputs |> Array.map (fun h -> new NDArray(h))
    /// <summary>Compute 2-D deformable convolution on 4-D input.
    /// 
    /// The deformable convolution operation is described in https://arxiv.org/abs/1703.06211
    /// 
    /// For 2-D deformable convolution, the shapes are
    /// 
    /// - **data**: *(batch_size, channel, height, width)*
    /// - **offset**: *(batch_size, num_deformable_group * kernel[0] * kernel[1] * 2, height, width)*
    /// - **weight**: *(num_filter, channel, kernel[0], kernel[1])*
    /// - **bias**: *(num_filter,)*
    /// - **out**: *(batch_size, num_filter, out_height, out_width)*.
    /// 
    /// Define::
    /// 
    ///   f(x,k,p,s,d) = floor((x+2*p-d*(k-1)-1)/s)+1
    /// 
    /// then we have::
    /// 
    ///   out_height=f(height, kernel[0], pad[0], stride[0], dilate[0])
    ///   out_width=f(width, kernel[1], pad[1], stride[1], dilate[1])
    /// 
    /// If ``no_bias`` is set to be true, then the ``bias`` term is ignored.
    /// 
    /// The default data ``layout`` is *NCHW*, namely *(batch_size, channle, height,
    /// width)*.
    /// 
    /// If ``num_group`` is larger than 1, denoted by *g*, then split the input ``data``
    /// evenly into *g* parts along the channel axis, and also evenly split ``weight``
    /// along the first dimension. Next compute the convolution on the *i*-th part of
    /// the data with the *i*-th weight part. The output is obtained by concating all
    /// the *g* results.
    /// 
    /// If ``num_deformable_group`` is larger than 1, denoted by *dg*, then split the
    /// input ``offset`` evenly into *dg* parts along the channel axis, and also evenly
    /// split ``data`` into *dg* parts along the channel axis. Next compute the
    /// deformable convolution, apply the *i*-th part of the offset on the *i*-th part
    /// of the data.
    /// 
    /// 
    /// Both ``weight`` and ``bias`` are learnable parameters.
    /// 
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\contrib\deformable_convolution.cc:L100</summary>
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="data">Input data to the DeformableConvolutionOp.</param>
    /// <param name="offset">Input offset to the DeformableConvolutionOp.</param>
    /// <param name="weight">Weight matrix.</param>
    /// <param name="bias">Bias parameter.</param>
    /// <param name="kernel">Convolution kernel size: (h, w) or (d, h, w)</param>
    /// <param name="numFilter">Convolution filter(channel) number</param>
    /// <param name="stride">Convolution stride: (h, w) or (d, h, w). Defaults to 1 for each dimension.</param>
    /// <param name="dilate">Convolution dilate: (h, w) or (d, h, w). Defaults to 1 for each dimension.</param>
    /// <param name="pad">Zero pad for convolution: (h, w) or (d, h, w). Defaults to no padding.</param>
    /// <param name="numGroup">Number of group partitions.</param>
    /// <param name="numDeformableGroup">Number of deformable group partitions.</param>
    /// <param name="workspace">Maximum temperal workspace allowed for convolution (MB).</param>
    /// <param name="noBias">Whether to disable bias parameter.</param>
    /// <param name="layout">Set layout for input, output and weight. Empty for
    ///     default layout: NCW for 1d, NCHW for 2d and NCDHW for 3d.</param>
    static member ContribDeformableConvolution(outputArray : NDArray seq, 
                                               data : NDArray, 
                                               offset : NDArray, 
                                               weight : NDArray, 
                                               bias : NDArray, 
                                               kernel : int seq, 
                                               numFilter : int, 
                                               [<Optional>] stride : int seq, 
                                               [<Optional>] dilate : int seq, 
                                               [<Optional>] pad : int seq, 
                                               [<Optional; DefaultParameterValue(1)>] numGroup : int, 
                                               [<Optional; DefaultParameterValue(1)>] numDeformableGroup : int, 
                                               [<Optional; DefaultParameterValue(1024L)>] workspace : int64, 
                                               [<Optional; DefaultParameterValue(false)>] noBias : bool, 
                                               [<Optional>] layout : ContribDeformableConvolutionLayout) =
        let creator = AtomicSymbolCreator.FromName "_contrib_DeformableConvolution"
        let names = [|"kernel"; "num_filter"; "stride"; "dilate"; "pad"; "num_group"; "num_deformable_group"; "workspace"; "no_bias"; "layout"|]
        let vals = [|(kernel |> Seq.map string |> String.concat ", " |> sprintf "[%s]"); string numFilter; (if isNull (stride :> obj) then "[]" else (stride |> Seq.map string |> String.concat ", " |> sprintf "[%s]")); (if isNull (dilate :> obj) then "[]" else (dilate |> Seq.map string |> String.concat ", " |> sprintf "[%s]")); (if isNull (pad :> obj) then "[]" else (pad |> Seq.map string |> String.concat ", " |> sprintf "[%s]")); string numGroup; string numDeformableGroup; string workspace; string noBias; (if isNull (layout :> obj) then "None" else string layout)|]
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg offset)) then offset.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg weight)) then weight.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg bias)) then bias.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <summary>Compute 2-D deformable convolution on 4-D input.
    /// 
    /// The deformable convolution operation is described in https://arxiv.org/abs/1703.06211
    /// 
    /// For 2-D deformable convolution, the shapes are
    /// 
    /// - **data**: *(batch_size, channel, height, width)*
    /// - **offset**: *(batch_size, num_deformable_group * kernel[0] * kernel[1] * 2, height, width)*
    /// - **weight**: *(num_filter, channel, kernel[0], kernel[1])*
    /// - **bias**: *(num_filter,)*
    /// - **out**: *(batch_size, num_filter, out_height, out_width)*.
    /// 
    /// Define::
    /// 
    ///   f(x,k,p,s,d) = floor((x+2*p-d*(k-1)-1)/s)+1
    /// 
    /// then we have::
    /// 
    ///   out_height=f(height, kernel[0], pad[0], stride[0], dilate[0])
    ///   out_width=f(width, kernel[1], pad[1], stride[1], dilate[1])
    /// 
    /// If ``no_bias`` is set to be true, then the ``bias`` term is ignored.
    /// 
    /// The default data ``layout`` is *NCHW*, namely *(batch_size, channle, height,
    /// width)*.
    /// 
    /// If ``num_group`` is larger than 1, denoted by *g*, then split the input ``data``
    /// evenly into *g* parts along the channel axis, and also evenly split ``weight``
    /// along the first dimension. Next compute the convolution on the *i*-th part of
    /// the data with the *i*-th weight part. The output is obtained by concating all
    /// the *g* results.
    /// 
    /// If ``num_deformable_group`` is larger than 1, denoted by *dg*, then split the
    /// input ``offset`` evenly into *dg* parts along the channel axis, and also evenly
    /// split ``data`` into *dg* parts along the channel axis. Next compute the
    /// deformable convolution, apply the *i*-th part of the offset on the *i*-th part
    /// of the data.
    /// 
    /// 
    /// Both ``weight`` and ``bias`` are learnable parameters.
    /// 
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\contrib\deformable_convolution.cc:L100</summary>
    /// <param name="data">Input data to the DeformableConvolutionOp.</param>
    /// <param name="offset">Input offset to the DeformableConvolutionOp.</param>
    /// <param name="weight">Weight matrix.</param>
    /// <param name="bias">Bias parameter.</param>
    /// <param name="kernel">Convolution kernel size: (h, w) or (d, h, w)</param>
    /// <param name="numFilter">Convolution filter(channel) number</param>
    /// <param name="stride">Convolution stride: (h, w) or (d, h, w). Defaults to 1 for each dimension.</param>
    /// <param name="dilate">Convolution dilate: (h, w) or (d, h, w). Defaults to 1 for each dimension.</param>
    /// <param name="pad">Zero pad for convolution: (h, w) or (d, h, w). Defaults to no padding.</param>
    /// <param name="numGroup">Number of group partitions.</param>
    /// <param name="numDeformableGroup">Number of deformable group partitions.</param>
    /// <param name="workspace">Maximum temperal workspace allowed for convolution (MB).</param>
    /// <param name="noBias">Whether to disable bias parameter.</param>
    /// <param name="layout">Set layout for input, output and weight. Empty for
    ///     default layout: NCW for 1d, NCHW for 2d and NCDHW for 3d.</param>
    static member ContribDeformableConvolution(data : Symbol, offset : Symbol, weight : Symbol, bias : Symbol, kernel : int seq, numFilter : int, [<Optional>] ?stride : int seq, [<Optional>] ?dilate : int seq, [<Optional>] ?pad : int seq, [<Optional>] ?numGroup : int, [<Optional>] ?numDeformableGroup : int, [<Optional>] ?workspace : int64, [<Optional>] ?noBias : bool, [<Optional>] ?layout : ContribDeformableConvolutionLayout) =
        ContribDeformableConvolution(data, offset, weight, bias, kernel, numFilter, ?stride = stride, ?dilate = dilate, ?pad = pad, ?numGroup = numGroup, ?numDeformableGroup = numDeformableGroup, ?workspace = workspace, ?noBias = noBias, ?layout = layout)
    /// <summary>Compute 2-D deformable convolution on 4-D input.
    /// 
    /// The deformable convolution operation is described in https://arxiv.org/abs/1703.06211
    /// 
    /// For 2-D deformable convolution, the shapes are
    /// 
    /// - **data**: *(batch_size, channel, height, width)*
    /// - **offset**: *(batch_size, num_deformable_group * kernel[0] * kernel[1] * 2, height, width)*
    /// - **weight**: *(num_filter, channel, kernel[0], kernel[1])*
    /// - **bias**: *(num_filter,)*
    /// - **out**: *(batch_size, num_filter, out_height, out_width)*.
    /// 
    /// Define::
    /// 
    ///   f(x,k,p,s,d) = floor((x+2*p-d*(k-1)-1)/s)+1
    /// 
    /// then we have::
    /// 
    ///   out_height=f(height, kernel[0], pad[0], stride[0], dilate[0])
    ///   out_width=f(width, kernel[1], pad[1], stride[1], dilate[1])
    /// 
    /// If ``no_bias`` is set to be true, then the ``bias`` term is ignored.
    /// 
    /// The default data ``layout`` is *NCHW*, namely *(batch_size, channle, height,
    /// width)*.
    /// 
    /// If ``num_group`` is larger than 1, denoted by *g*, then split the input ``data``
    /// evenly into *g* parts along the channel axis, and also evenly split ``weight``
    /// along the first dimension. Next compute the convolution on the *i*-th part of
    /// the data with the *i*-th weight part. The output is obtained by concating all
    /// the *g* results.
    /// 
    /// If ``num_deformable_group`` is larger than 1, denoted by *dg*, then split the
    /// input ``offset`` evenly into *dg* parts along the channel axis, and also evenly
    /// split ``data`` into *dg* parts along the channel axis. Next compute the
    /// deformable convolution, apply the *i*-th part of the offset on the *i*-th part
    /// of the data.
    /// 
    /// 
    /// Both ``weight`` and ``bias`` are learnable parameters.
    /// 
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\contrib\deformable_convolution.cc:L100</summary>
    /// <param name="kernel">Convolution kernel size: (h, w) or (d, h, w)</param>
    /// <param name="numFilter">Convolution filter(channel) number</param>
    /// <param name="data">Input data to the DeformableConvolutionOp.</param>
    /// <param name="offset">Input offset to the DeformableConvolutionOp.</param>
    /// <param name="weight">Weight matrix.</param>
    /// <param name="bias">Bias parameter.</param>
    /// <param name="stride">Convolution stride: (h, w) or (d, h, w). Defaults to 1 for each dimension.</param>
    /// <param name="dilate">Convolution dilate: (h, w) or (d, h, w). Defaults to 1 for each dimension.</param>
    /// <param name="pad">Zero pad for convolution: (h, w) or (d, h, w). Defaults to no padding.</param>
    /// <param name="numGroup">Number of group partitions.</param>
    /// <param name="numDeformableGroup">Number of deformable group partitions.</param>
    /// <param name="workspace">Maximum temperal workspace allowed for convolution (MB).</param>
    /// <param name="noBias">Whether to disable bias parameter.</param>
    /// <param name="layout">Set layout for input, output and weight. Empty for
    ///     default layout: NCW for 1d, NCHW for 2d and NCDHW for 3d.</param>
    static member ContribDeformableConvolution(kernel : int seq, numFilter : int, [<Optional>] ?data : Symbol, [<Optional>] ?offset : Symbol, [<Optional>] ?weight : Symbol, [<Optional>] ?bias : Symbol, [<Optional>] ?stride : int seq, [<Optional>] ?dilate : int seq, [<Optional>] ?pad : int seq, [<Optional>] ?numGroup : int, [<Optional>] ?numDeformableGroup : int, [<Optional>] ?workspace : int64, [<Optional>] ?noBias : bool, [<Optional>] ?layout : ContribDeformableConvolutionLayout) =
        ContribDeformableConvolution(kernel, numFilter, ?data = data, ?offset = offset, ?weight = weight, ?bias = bias, ?stride = stride, ?dilate = dilate, ?pad = pad, ?numGroup = numGroup, ?numDeformableGroup = numDeformableGroup, ?workspace = workspace, ?noBias = noBias, ?layout = layout)


    /// <summary>Performs deformable position-sensitive region-of-interest pooling on inputs.
    /// The DeformablePSROIPooling operation is described in https://arxiv.org/abs/1703.06211 .batch_size will change to the number of region bounding boxes after DeformablePSROIPooling</summary>
    /// <param name="data">Input data to the pooling operator, a 4D Feature maps</param>
    /// <param name="rois">Bounding box coordinates, a 2D array of [[batch_index, x1, y1, x2, y2]]. (x1, y1) and (x2, y2) are top left and down right corners of designated region of interest. batch_index indicates the index of corresponding image in the input data</param>
    /// <param name="trans">transition parameter</param>
    /// <param name="spatialScale">Ratio of input feature map height (or w) to raw image height (or w). Equals the reciprocal of total stride in convolutional layers</param>
    /// <param name="outputDim">fix output dim</param>
    /// <param name="groupSize">fix group size</param>
    /// <param name="pooledSize">fix pooled size</param>
    /// <param name="partSize">fix part size</param>
    /// <param name="samplePerPart">fix samples per part</param>
    /// <param name="transStd">fix transition std</param>
    /// <param name="noTrans">Whether to disable trans parameter.</param>
    static member ContribDeformablePSROIPooling(data : Symbol, rois : Symbol, trans : Symbol, spatialScale : float, outputDim : int, groupSize : int, pooledSize : int, [<Optional>] ?partSize : int, [<Optional>] ?samplePerPart : int, [<Optional>] ?transStd : float, [<Optional>] ?noTrans : bool) =
        ContribDeformablePSROIPooling(data, rois, trans, spatialScale, outputDim, groupSize, pooledSize, ?partSize = partSize, ?samplePerPart = samplePerPart, ?transStd = transStd, ?noTrans = noTrans)
    /// <summary>Performs deformable position-sensitive region-of-interest pooling on inputs.
    /// The DeformablePSROIPooling operation is described in https://arxiv.org/abs/1703.06211 .batch_size will change to the number of region bounding boxes after DeformablePSROIPooling</summary>
    /// <param name="spatialScale">Ratio of input feature map height (or w) to raw image height (or w). Equals the reciprocal of total stride in convolutional layers</param>
    /// <param name="outputDim">fix output dim</param>
    /// <param name="groupSize">fix group size</param>
    /// <param name="pooledSize">fix pooled size</param>
    /// <param name="data">Input data to the pooling operator, a 4D Feature maps</param>
    /// <param name="rois">Bounding box coordinates, a 2D array of [[batch_index, x1, y1, x2, y2]]. (x1, y1) and (x2, y2) are top left and down right corners of designated region of interest. batch_index indicates the index of corresponding image in the input data</param>
    /// <param name="trans">transition parameter</param>
    /// <param name="partSize">fix part size</param>
    /// <param name="samplePerPart">fix samples per part</param>
    /// <param name="transStd">fix transition std</param>
    /// <param name="noTrans">Whether to disable trans parameter.</param>
    static member ContribDeformablePSROIPooling(spatialScale : float, outputDim : int, groupSize : int, pooledSize : int, [<Optional>] ?data : Symbol, [<Optional>] ?rois : Symbol, [<Optional>] ?trans : Symbol, [<Optional>] ?partSize : int, [<Optional>] ?samplePerPart : int, [<Optional>] ?transStd : float, [<Optional>] ?noTrans : bool) =
        ContribDeformablePSROIPooling(spatialScale, outputDim, groupSize, pooledSize, ?data = data, ?rois = rois, ?trans = trans, ?partSize = partSize, ?samplePerPart = samplePerPart, ?transStd = transStd, ?noTrans = noTrans)


    /// <summary>Apply 1D FFT to input&quot;
    /// 
    /// .. note:: `fft` is only available on GPU.
    /// 
    /// Currently accept 2 input data shapes: (N, d) or (N1, N2, N3, d), data can only be real numbers.
    /// The output data has shape: (N, 2*d) or (N1, N2, N3, 2*d). The format is: [real0, imag0, real1, imag1, ...].
    /// 
    /// Example::
    /// 
    ///    data = np.random.normal(0,1,(3,4))
    ///    out = mx.contrib.ndarray.fft(data = mx.nd.array(data,ctx = mx.gpu(0)))
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\contrib\fft.cc:L56</summary>
    /// <param name="data">Input data to the FFTOp.</param>
    /// <param name="computeSize">Maximum size of sub-batch to be forwarded at one time</param>
    static member ContribFft(data : NDArray, [<Optional; DefaultParameterValue(128)>] computeSize : int) =
        let creator = AtomicSymbolCreator.FromName "_contrib_fft"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle|]
                                                 [|"compute_size"|]
                                                 [|string computeSize|]
        outputs |> Array.map (fun h -> new NDArray(h))
    /// <summary>Apply 1D FFT to input&quot;
    /// 
    /// .. note:: `fft` is only available on GPU.
    /// 
    /// Currently accept 2 input data shapes: (N, d) or (N1, N2, N3, d), data can only be real numbers.
    /// The output data has shape: (N, 2*d) or (N1, N2, N3, 2*d). The format is: [real0, imag0, real1, imag1, ...].
    /// 
    /// Example::
    /// 
    ///    data = np.random.normal(0,1,(3,4))
    ///    out = mx.contrib.ndarray.fft(data = mx.nd.array(data,ctx = mx.gpu(0)))
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\contrib\fft.cc:L56</summary>
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="data">Input data to the FFTOp.</param>
    /// <param name="computeSize">Maximum size of sub-batch to be forwarded at one time</param>
    static member ContribFft(outputArray : NDArray seq, data : NDArray, [<Optional; DefaultParameterValue(128)>] computeSize : int) =
        let creator = AtomicSymbolCreator.FromName "_contrib_fft"
        let names = [|"compute_size"|]
        let vals = [|string computeSize|]
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <summary>Apply 1D FFT to input&quot;
    /// 
    /// .. note:: `fft` is only available on GPU.
    /// 
    /// Currently accept 2 input data shapes: (N, d) or (N1, N2, N3, d), data can only be real numbers.
    /// The output data has shape: (N, 2*d) or (N1, N2, N3, 2*d). The format is: [real0, imag0, real1, imag1, ...].
    /// 
    /// Example::
    /// 
    ///    data = np.random.normal(0,1,(3,4))
    ///    out = mx.contrib.ndarray.fft(data = mx.nd.array(data,ctx = mx.gpu(0)))
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\contrib\fft.cc:L56</summary>
    /// <param name="data">Input data to the FFTOp.</param>
    /// <param name="computeSize">Maximum size of sub-batch to be forwarded at one time</param>
    static member ContribFft([<Optional>] ?data : Symbol, [<Optional>] ?computeSize : int) =
        ContribFft(?data = data, ?computeSize = computeSize)


    /// <summary>Apply 1D ifft to input&quot;
    /// 
    /// .. note:: `ifft` is only available on GPU.
    /// 
    /// Currently accept 2 input data shapes: (N, d) or (N1, N2, N3, d). Data is in format: [real0, imag0, real1, imag1, ...].
    /// Last dimension must be an even number.
    /// The output data has shape: (N, d/2) or (N1, N2, N3, d/2). It is only the real part of the result.
    /// 
    /// Example::
    /// 
    ///    data = np.random.normal(0,1,(3,4))
    ///    out = mx.contrib.ndarray.ifft(data = mx.nd.array(data,ctx = mx.gpu(0)))
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\contrib\ifft.cc:L58</summary>
    /// <param name="data">Input data to the IFFTOp.</param>
    /// <param name="computeSize">Maximum size of sub-batch to be forwarded at one time</param>
    static member ContribIfft(data : NDArray, [<Optional; DefaultParameterValue(128)>] computeSize : int) =
        let creator = AtomicSymbolCreator.FromName "_contrib_ifft"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle|]
                                                 [|"compute_size"|]
                                                 [|string computeSize|]
        outputs |> Array.map (fun h -> new NDArray(h))
    /// <summary>Apply 1D ifft to input&quot;
    /// 
    /// .. note:: `ifft` is only available on GPU.
    /// 
    /// Currently accept 2 input data shapes: (N, d) or (N1, N2, N3, d). Data is in format: [real0, imag0, real1, imag1, ...].
    /// Last dimension must be an even number.
    /// The output data has shape: (N, d/2) or (N1, N2, N3, d/2). It is only the real part of the result.
    /// 
    /// Example::
    /// 
    ///    data = np.random.normal(0,1,(3,4))
    ///    out = mx.contrib.ndarray.ifft(data = mx.nd.array(data,ctx = mx.gpu(0)))
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\contrib\ifft.cc:L58</summary>
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="data">Input data to the IFFTOp.</param>
    /// <param name="computeSize">Maximum size of sub-batch to be forwarded at one time</param>
    static member ContribIfft(outputArray : NDArray seq, data : NDArray, [<Optional; DefaultParameterValue(128)>] computeSize : int) =
        let creator = AtomicSymbolCreator.FromName "_contrib_ifft"
        let names = [|"compute_size"|]
        let vals = [|string computeSize|]
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <summary>Apply 1D ifft to input&quot;
    /// 
    /// .. note:: `ifft` is only available on GPU.
    /// 
    /// Currently accept 2 input data shapes: (N, d) or (N1, N2, N3, d). Data is in format: [real0, imag0, real1, imag1, ...].
    /// Last dimension must be an even number.
    /// The output data has shape: (N, d/2) or (N1, N2, N3, d/2). It is only the real part of the result.
    /// 
    /// Example::
    /// 
    ///    data = np.random.normal(0,1,(3,4))
    ///    out = mx.contrib.ndarray.ifft(data = mx.nd.array(data,ctx = mx.gpu(0)))
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\contrib\ifft.cc:L58</summary>
    /// <param name="data">Input data to the IFFTOp.</param>
    /// <param name="computeSize">Maximum size of sub-batch to be forwarded at one time</param>
    static member ContribIfft([<Optional>] ?data : Symbol, [<Optional>] ?computeSize : int) =
        ContribIfft(?data = data, ?computeSize = computeSize)


    /// <summary>Compute 2-D modulated deformable convolution on 4-D input.
    /// 
    /// The modulated deformable convolution operation is described in https://arxiv.org/abs/1811.11168
    /// 
    /// For 2-D modulated deformable convolution, the shapes are
    /// 
    /// - **data**: *(batch_size, channel, height, width)*
    /// - **offset**: *(batch_size, num_deformable_group * kernel[0] * kernel[1] * 2, height, width)*
    /// - **mask**: *(batch_size, num_deformable_group * kernel[0] * kernel[1], height, width)*
    /// - **weight**: *(num_filter, channel, kernel[0], kernel[1])*
    /// - **bias**: *(num_filter,)*
    /// - **out**: *(batch_size, num_filter, out_height, out_width)*.
    /// 
    /// Define::
    /// 
    ///   f(x,k,p,s,d) = floor((x+2*p-d*(k-1)-1)/s)+1
    /// 
    /// then we have::
    /// 
    ///   out_height=f(height, kernel[0], pad[0], stride[0], dilate[0])
    ///   out_width=f(width, kernel[1], pad[1], stride[1], dilate[1])
    /// 
    /// If ``no_bias`` is set to be true, then the ``bias`` term is ignored.
    /// 
    /// The default data ``layout`` is *NCHW*, namely *(batch_size, channle, height,
    /// width)*.
    /// 
    /// If ``num_group`` is larger than 1, denoted by *g*, then split the input ``data``
    /// evenly into *g* parts along the channel axis, and also evenly split ``weight``
    /// along the first dimension. Next compute the convolution on the *i*-th part of
    /// the data with the *i*-th weight part. The output is obtained by concating all
    /// the *g* results.
    /// 
    /// If ``num_deformable_group`` is larger than 1, denoted by *dg*, then split the
    /// input ``offset`` evenly into *dg* parts along the channel axis, and also evenly
    /// split ``out`` evenly into *dg* parts along the channel axis. Next compute the
    /// deformable convolution, apply the *i*-th part of the offset part on the *i*-th
    /// out.
    /// 
    /// 
    /// Both ``weight`` and ``bias`` are learnable parameters.
    /// 
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\contrib\modulated_deformable_convolution.cc:L102</summary>
    /// <param name="data">Input data to the ModulatedDeformableConvolutionOp.</param>
    /// <param name="offset">Input offset to ModulatedDeformableConvolutionOp.</param>
    /// <param name="mask">Input mask to the ModulatedDeformableConvolutionOp.</param>
    /// <param name="weight">Weight matrix.</param>
    /// <param name="bias">Bias parameter.</param>
    /// <param name="kernel">Convolution kernel size: (h, w) or (d, h, w)</param>
    /// <param name="numFilter">Convolution filter(channel) number</param>
    /// <param name="stride">Convolution stride: (h, w) or (d, h, w). Defaults to 1 for each dimension.</param>
    /// <param name="dilate">Convolution dilate: (h, w) or (d, h, w). Defaults to 1 for each dimension.</param>
    /// <param name="pad">Zero pad for convolution: (h, w) or (d, h, w). Defaults to no padding.</param>
    /// <param name="numGroup">Number of group partitions.</param>
    /// <param name="numDeformableGroup">Number of deformable group partitions.</param>
    /// <param name="workspace">Maximum temperal workspace allowed for convolution (MB).</param>
    /// <param name="noBias">Whether to disable bias parameter.</param>
    /// <param name="im2colStep">Maximum number of images per im2col computation; The total batch size should be divisable by this value or smaller than this value; if you face out of memory problem, you can try to use a smaller value here.</param>
    /// <param name="layout">Set layout for input, output and weight. Empty for
    ///     default layout: NCW for 1d, NCHW for 2d and NCDHW for 3d.</param>
    static member ContribModulatedDeformableConvolution(data : NDArray, 
                                                        offset : NDArray, 
                                                        mask : NDArray, 
                                                        weight : NDArray, 
                                                        bias : NDArray, 
                                                        kernel : int seq, 
                                                        numFilter : int, 
                                                        [<Optional>] stride : int seq, 
                                                        [<Optional>] dilate : int seq, 
                                                        [<Optional>] pad : int seq, 
                                                        [<Optional; DefaultParameterValue(1)>] numGroup : int, 
                                                        [<Optional; DefaultParameterValue(1)>] numDeformableGroup : int, 
                                                        [<Optional; DefaultParameterValue(1024L)>] workspace : int64, 
                                                        [<Optional; DefaultParameterValue(false)>] noBias : bool, 
                                                        [<Optional; DefaultParameterValue(64)>] im2colStep : int, 
                                                        [<Optional>] layout : ContribModulatedDeformableConvolutionLayout) =
        let creator = AtomicSymbolCreator.FromName "_contrib_ModulatedDeformableConvolution"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg offset)) then offset.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg mask)) then mask.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg weight)) then weight.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg bias)) then bias.UnsafeHandle|]
                                                 [|"kernel"; "num_filter"; "stride"; "dilate"; "pad"; "num_group"; "num_deformable_group"; "workspace"; "no_bias"; "im2col_step"; "layout"|]
                                                 [|(kernel |> Seq.map string |> String.concat ", " |> sprintf "[%s]"); string numFilter; (if isNull (stride :> obj) then "[]" else (stride |> Seq.map string |> String.concat ", " |> sprintf "[%s]")); (if isNull (dilate :> obj) then "[]" else (dilate |> Seq.map string |> String.concat ", " |> sprintf "[%s]")); (if isNull (pad :> obj) then "[]" else (pad |> Seq.map string |> String.concat ", " |> sprintf "[%s]")); string numGroup; string numDeformableGroup; string workspace; string noBias; string im2colStep; (if isNull (layout :> obj) then "None" else string layout)|]
        outputs |> Array.map (fun h -> new NDArray(h))
    /// <summary>Compute 2-D modulated deformable convolution on 4-D input.
    /// 
    /// The modulated deformable convolution operation is described in https://arxiv.org/abs/1811.11168
    /// 
    /// For 2-D modulated deformable convolution, the shapes are
    /// 
    /// - **data**: *(batch_size, channel, height, width)*
    /// - **offset**: *(batch_size, num_deformable_group * kernel[0] * kernel[1] * 2, height, width)*
    /// - **mask**: *(batch_size, num_deformable_group * kernel[0] * kernel[1], height, width)*
    /// - **weight**: *(num_filter, channel, kernel[0], kernel[1])*
    /// - **bias**: *(num_filter,)*
    /// - **out**: *(batch_size, num_filter, out_height, out_width)*.
    /// 
    /// Define::
    /// 
    ///   f(x,k,p,s,d) = floor((x+2*p-d*(k-1)-1)/s)+1
    /// 
    /// then we have::
    /// 
    ///   out_height=f(height, kernel[0], pad[0], stride[0], dilate[0])
    ///   out_width=f(width, kernel[1], pad[1], stride[1], dilate[1])
    /// 
    /// If ``no_bias`` is set to be true, then the ``bias`` term is ignored.
    /// 
    /// The default data ``layout`` is *NCHW*, namely *(batch_size, channle, height,
    /// width)*.
    /// 
    /// If ``num_group`` is larger than 1, denoted by *g*, then split the input ``data``
    /// evenly into *g* parts along the channel axis, and also evenly split ``weight``
    /// along the first dimension. Next compute the convolution on the *i*-th part of
    /// the data with the *i*-th weight part. The output is obtained by concating all
    /// the *g* results.
    /// 
    /// If ``num_deformable_group`` is larger than 1, denoted by *dg*, then split the
    /// input ``offset`` evenly into *dg* parts along the channel axis, and also evenly
    /// split ``out`` evenly into *dg* parts along the channel axis. Next compute the
    /// deformable convolution, apply the *i*-th part of the offset part on the *i*-th
    /// out.
    /// 
    /// 
    /// Both ``weight`` and ``bias`` are learnable parameters.
    /// 
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\contrib\modulated_deformable_convolution.cc:L102</summary>
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="data">Input data to the ModulatedDeformableConvolutionOp.</param>
    /// <param name="offset">Input offset to ModulatedDeformableConvolutionOp.</param>
    /// <param name="mask">Input mask to the ModulatedDeformableConvolutionOp.</param>
    /// <param name="weight">Weight matrix.</param>
    /// <param name="bias">Bias parameter.</param>
    /// <param name="kernel">Convolution kernel size: (h, w) or (d, h, w)</param>
    /// <param name="numFilter">Convolution filter(channel) number</param>
    /// <param name="stride">Convolution stride: (h, w) or (d, h, w). Defaults to 1 for each dimension.</param>
    /// <param name="dilate">Convolution dilate: (h, w) or (d, h, w). Defaults to 1 for each dimension.</param>
    /// <param name="pad">Zero pad for convolution: (h, w) or (d, h, w). Defaults to no padding.</param>
    /// <param name="numGroup">Number of group partitions.</param>
    /// <param name="numDeformableGroup">Number of deformable group partitions.</param>
    /// <param name="workspace">Maximum temperal workspace allowed for convolution (MB).</param>
    /// <param name="noBias">Whether to disable bias parameter.</param>
    /// <param name="im2colStep">Maximum number of images per im2col computation; The total batch size should be divisable by this value or smaller than this value; if you face out of memory problem, you can try to use a smaller value here.</param>
    /// <param name="layout">Set layout for input, output and weight. Empty for
    ///     default layout: NCW for 1d, NCHW for 2d and NCDHW for 3d.</param>
    static member ContribModulatedDeformableConvolution(outputArray : NDArray seq, 
                                                        data : NDArray, 
                                                        offset : NDArray, 
                                                        mask : NDArray, 
                                                        weight : NDArray, 
                                                        bias : NDArray, 
                                                        kernel : int seq, 
                                                        numFilter : int, 
                                                        [<Optional>] stride : int seq, 
                                                        [<Optional>] dilate : int seq, 
                                                        [<Optional>] pad : int seq, 
                                                        [<Optional; DefaultParameterValue(1)>] numGroup : int, 
                                                        [<Optional; DefaultParameterValue(1)>] numDeformableGroup : int, 
                                                        [<Optional; DefaultParameterValue(1024L)>] workspace : int64, 
                                                        [<Optional; DefaultParameterValue(false)>] noBias : bool, 
                                                        [<Optional; DefaultParameterValue(64)>] im2colStep : int, 
                                                        [<Optional>] layout : ContribModulatedDeformableConvolutionLayout) =
        let creator = AtomicSymbolCreator.FromName "_contrib_ModulatedDeformableConvolution"
        let names = [|"kernel"; "num_filter"; "stride"; "dilate"; "pad"; "num_group"; "num_deformable_group"; "workspace"; "no_bias"; "im2col_step"; "layout"|]
        let vals = [|(kernel |> Seq.map string |> String.concat ", " |> sprintf "[%s]"); string numFilter; (if isNull (stride :> obj) then "[]" else (stride |> Seq.map string |> String.concat ", " |> sprintf "[%s]")); (if isNull (dilate :> obj) then "[]" else (dilate |> Seq.map string |> String.concat ", " |> sprintf "[%s]")); (if isNull (pad :> obj) then "[]" else (pad |> Seq.map string |> String.concat ", " |> sprintf "[%s]")); string numGroup; string numDeformableGroup; string workspace; string noBias; string im2colStep; (if isNull (layout :> obj) then "None" else string layout)|]
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg offset)) then offset.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg mask)) then mask.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg weight)) then weight.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg bias)) then bias.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <summary>Compute 2-D modulated deformable convolution on 4-D input.
    /// 
    /// The modulated deformable convolution operation is described in https://arxiv.org/abs/1811.11168
    /// 
    /// For 2-D modulated deformable convolution, the shapes are
    /// 
    /// - **data**: *(batch_size, channel, height, width)*
    /// - **offset**: *(batch_size, num_deformable_group * kernel[0] * kernel[1] * 2, height, width)*
    /// - **mask**: *(batch_size, num_deformable_group * kernel[0] * kernel[1], height, width)*
    /// - **weight**: *(num_filter, channel, kernel[0], kernel[1])*
    /// - **bias**: *(num_filter,)*
    /// - **out**: *(batch_size, num_filter, out_height, out_width)*.
    /// 
    /// Define::
    /// 
    ///   f(x,k,p,s,d) = floor((x+2*p-d*(k-1)-1)/s)+1
    /// 
    /// then we have::
    /// 
    ///   out_height=f(height, kernel[0], pad[0], stride[0], dilate[0])
    ///   out_width=f(width, kernel[1], pad[1], stride[1], dilate[1])
    /// 
    /// If ``no_bias`` is set to be true, then the ``bias`` term is ignored.
    /// 
    /// The default data ``layout`` is *NCHW*, namely *(batch_size, channle, height,
    /// width)*.
    /// 
    /// If ``num_group`` is larger than 1, denoted by *g*, then split the input ``data``
    /// evenly into *g* parts along the channel axis, and also evenly split ``weight``
    /// along the first dimension. Next compute the convolution on the *i*-th part of
    /// the data with the *i*-th weight part. The output is obtained by concating all
    /// the *g* results.
    /// 
    /// If ``num_deformable_group`` is larger than 1, denoted by *dg*, then split the
    /// input ``offset`` evenly into *dg* parts along the channel axis, and also evenly
    /// split ``out`` evenly into *dg* parts along the channel axis. Next compute the
    /// deformable convolution, apply the *i*-th part of the offset part on the *i*-th
    /// out.
    /// 
    /// 
    /// Both ``weight`` and ``bias`` are learnable parameters.
    /// 
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\contrib\modulated_deformable_convolution.cc:L102</summary>
    /// <param name="data">Input data to the ModulatedDeformableConvolutionOp.</param>
    /// <param name="offset">Input offset to ModulatedDeformableConvolutionOp.</param>
    /// <param name="mask">Input mask to the ModulatedDeformableConvolutionOp.</param>
    /// <param name="weight">Weight matrix.</param>
    /// <param name="bias">Bias parameter.</param>
    /// <param name="kernel">Convolution kernel size: (h, w) or (d, h, w)</param>
    /// <param name="numFilter">Convolution filter(channel) number</param>
    /// <param name="stride">Convolution stride: (h, w) or (d, h, w). Defaults to 1 for each dimension.</param>
    /// <param name="dilate">Convolution dilate: (h, w) or (d, h, w). Defaults to 1 for each dimension.</param>
    /// <param name="pad">Zero pad for convolution: (h, w) or (d, h, w). Defaults to no padding.</param>
    /// <param name="numGroup">Number of group partitions.</param>
    /// <param name="numDeformableGroup">Number of deformable group partitions.</param>
    /// <param name="workspace">Maximum temperal workspace allowed for convolution (MB).</param>
    /// <param name="noBias">Whether to disable bias parameter.</param>
    /// <param name="im2colStep">Maximum number of images per im2col computation; The total batch size should be divisable by this value or smaller than this value; if you face out of memory problem, you can try to use a smaller value here.</param>
    /// <param name="layout">Set layout for input, output and weight. Empty for
    ///     default layout: NCW for 1d, NCHW for 2d and NCDHW for 3d.</param>
    static member ContribModulatedDeformableConvolution(data : Symbol, offset : Symbol, mask : Symbol, weight : Symbol, bias : Symbol, kernel : int seq, numFilter : int, [<Optional>] ?stride : int seq, [<Optional>] ?dilate : int seq, [<Optional>] ?pad : int seq, [<Optional>] ?numGroup : int, [<Optional>] ?numDeformableGroup : int, [<Optional>] ?workspace : int64, [<Optional>] ?noBias : bool, [<Optional>] ?im2colStep : int, [<Optional>] ?layout : ContribModulatedDeformableConvolutionLayout) =
        ContribModulatedDeformableConvolution(data, offset, mask, weight, bias, kernel, numFilter, ?stride = stride, ?dilate = dilate, ?pad = pad, ?numGroup = numGroup, ?numDeformableGroup = numDeformableGroup, ?workspace = workspace, ?noBias = noBias, ?im2colStep = im2colStep, ?layout = layout)
    /// <summary>Compute 2-D modulated deformable convolution on 4-D input.
    /// 
    /// The modulated deformable convolution operation is described in https://arxiv.org/abs/1811.11168
    /// 
    /// For 2-D modulated deformable convolution, the shapes are
    /// 
    /// - **data**: *(batch_size, channel, height, width)*
    /// - **offset**: *(batch_size, num_deformable_group * kernel[0] * kernel[1] * 2, height, width)*
    /// - **mask**: *(batch_size, num_deformable_group * kernel[0] * kernel[1], height, width)*
    /// - **weight**: *(num_filter, channel, kernel[0], kernel[1])*
    /// - **bias**: *(num_filter,)*
    /// - **out**: *(batch_size, num_filter, out_height, out_width)*.
    /// 
    /// Define::
    /// 
    ///   f(x,k,p,s,d) = floor((x+2*p-d*(k-1)-1)/s)+1
    /// 
    /// then we have::
    /// 
    ///   out_height=f(height, kernel[0], pad[0], stride[0], dilate[0])
    ///   out_width=f(width, kernel[1], pad[1], stride[1], dilate[1])
    /// 
    /// If ``no_bias`` is set to be true, then the ``bias`` term is ignored.
    /// 
    /// The default data ``layout`` is *NCHW*, namely *(batch_size, channle, height,
    /// width)*.
    /// 
    /// If ``num_group`` is larger than 1, denoted by *g*, then split the input ``data``
    /// evenly into *g* parts along the channel axis, and also evenly split ``weight``
    /// along the first dimension. Next compute the convolution on the *i*-th part of
    /// the data with the *i*-th weight part. The output is obtained by concating all
    /// the *g* results.
    /// 
    /// If ``num_deformable_group`` is larger than 1, denoted by *dg*, then split the
    /// input ``offset`` evenly into *dg* parts along the channel axis, and also evenly
    /// split ``out`` evenly into *dg* parts along the channel axis. Next compute the
    /// deformable convolution, apply the *i*-th part of the offset part on the *i*-th
    /// out.
    /// 
    /// 
    /// Both ``weight`` and ``bias`` are learnable parameters.
    /// 
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\contrib\modulated_deformable_convolution.cc:L102</summary>
    /// <param name="kernel">Convolution kernel size: (h, w) or (d, h, w)</param>
    /// <param name="numFilter">Convolution filter(channel) number</param>
    /// <param name="data">Input data to the ModulatedDeformableConvolutionOp.</param>
    /// <param name="offset">Input offset to ModulatedDeformableConvolutionOp.</param>
    /// <param name="mask">Input mask to the ModulatedDeformableConvolutionOp.</param>
    /// <param name="weight">Weight matrix.</param>
    /// <param name="bias">Bias parameter.</param>
    /// <param name="stride">Convolution stride: (h, w) or (d, h, w). Defaults to 1 for each dimension.</param>
    /// <param name="dilate">Convolution dilate: (h, w) or (d, h, w). Defaults to 1 for each dimension.</param>
    /// <param name="pad">Zero pad for convolution: (h, w) or (d, h, w). Defaults to no padding.</param>
    /// <param name="numGroup">Number of group partitions.</param>
    /// <param name="numDeformableGroup">Number of deformable group partitions.</param>
    /// <param name="workspace">Maximum temperal workspace allowed for convolution (MB).</param>
    /// <param name="noBias">Whether to disable bias parameter.</param>
    /// <param name="im2colStep">Maximum number of images per im2col computation; The total batch size should be divisable by this value or smaller than this value; if you face out of memory problem, you can try to use a smaller value here.</param>
    /// <param name="layout">Set layout for input, output and weight. Empty for
    ///     default layout: NCW for 1d, NCHW for 2d and NCDHW for 3d.</param>
    static member ContribModulatedDeformableConvolution(kernel : int seq, numFilter : int, [<Optional>] ?data : Symbol, [<Optional>] ?offset : Symbol, [<Optional>] ?mask : Symbol, [<Optional>] ?weight : Symbol, [<Optional>] ?bias : Symbol, [<Optional>] ?stride : int seq, [<Optional>] ?dilate : int seq, [<Optional>] ?pad : int seq, [<Optional>] ?numGroup : int, [<Optional>] ?numDeformableGroup : int, [<Optional>] ?workspace : int64, [<Optional>] ?noBias : bool, [<Optional>] ?im2colStep : int, [<Optional>] ?layout : ContribModulatedDeformableConvolutionLayout) =
        ContribModulatedDeformableConvolution(kernel, numFilter, ?data = data, ?offset = offset, ?mask = mask, ?weight = weight, ?bias = bias, ?stride = stride, ?dilate = dilate, ?pad = pad, ?numGroup = numGroup, ?numDeformableGroup = numDeformableGroup, ?workspace = workspace, ?noBias = noBias, ?im2colStep = im2colStep, ?layout = layout)


    /// <summary>Generate region proposals via RPN</summary>
    /// <param name="clsProb">Score of how likely proposal is object.</param>
    /// <param name="bboxPred">BBox Predicted deltas from anchors for proposals</param>
    /// <param name="imInfo">Image size and scale.</param>
    /// <param name="rpnPreNmsTopN">Number of top scoring boxes to keep before applying NMS to RPN proposals</param>
    /// <param name="rpnPostNmsTopN">Number of top scoring boxes to keep after applying NMS to RPN proposals</param>
    /// <param name="threshold">NMS value, below which to suppress.</param>
    /// <param name="rpnMinSize">Minimum height or width in proposal</param>
    /// <param name="scales">Used to generate anchor windows by enumerating scales</param>
    /// <param name="ratios">Used to generate anchor windows by enumerating ratios</param>
    /// <param name="featureStride">The size of the receptive field each unit in the convolution layer of the rpn,for example the product of all stride&#39;s prior to this layer.</param>
    /// <param name="outputScore">Add score to outputs</param>
    /// <param name="iouLoss">Usage of IoU Loss</param>
    static member ContribMultiProposal(clsProb : NDArray, 
                                       bboxPred : NDArray, 
                                       imInfo : NDArray, 
                                       [<Optional; DefaultParameterValue(6000)>] rpnPreNmsTopN : int, 
                                       [<Optional; DefaultParameterValue(300)>] rpnPostNmsTopN : int, 
                                       [<Optional; DefaultParameterValue(0.699999988)>] threshold : float, 
                                       [<Optional; DefaultParameterValue(16)>] rpnMinSize : int, 
                                       [<Optional>] scales : double seq, 
                                       [<Optional>] ratios : double seq, 
                                       [<Optional; DefaultParameterValue(16)>] featureStride : int, 
                                       [<Optional; DefaultParameterValue(false)>] outputScore : bool, 
                                       [<Optional; DefaultParameterValue(false)>] iouLoss : bool) =
        let creator = AtomicSymbolCreator.FromName "_contrib_MultiProposal"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg clsProb)) then clsProb.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg bboxPred)) then bboxPred.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg imInfo)) then imInfo.UnsafeHandle|]
                                                 [|"rpn_pre_nms_top_n"; "rpn_post_nms_top_n"; "threshold"; "rpn_min_size"; "scales"; "ratios"; "feature_stride"; "output_score"; "iou_loss"|]
                                                 [|string rpnPreNmsTopN; string rpnPostNmsTopN; string threshold; string rpnMinSize; (if isNull (scales :> obj) then "[4,8,16,32]" else string scales); (if isNull (ratios :> obj) then "[0.5,1,2]" else string ratios); string featureStride; string outputScore; string iouLoss|]
        outputs |> Array.map (fun h -> new NDArray(h))
    /// <summary>Generate region proposals via RPN</summary>
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="clsProb">Score of how likely proposal is object.</param>
    /// <param name="bboxPred">BBox Predicted deltas from anchors for proposals</param>
    /// <param name="imInfo">Image size and scale.</param>
    /// <param name="rpnPreNmsTopN">Number of top scoring boxes to keep before applying NMS to RPN proposals</param>
    /// <param name="rpnPostNmsTopN">Number of top scoring boxes to keep after applying NMS to RPN proposals</param>
    /// <param name="threshold">NMS value, below which to suppress.</param>
    /// <param name="rpnMinSize">Minimum height or width in proposal</param>
    /// <param name="scales">Used to generate anchor windows by enumerating scales</param>
    /// <param name="ratios">Used to generate anchor windows by enumerating ratios</param>
    /// <param name="featureStride">The size of the receptive field each unit in the convolution layer of the rpn,for example the product of all stride&#39;s prior to this layer.</param>
    /// <param name="outputScore">Add score to outputs</param>
    /// <param name="iouLoss">Usage of IoU Loss</param>
    static member ContribMultiProposal(outputArray : NDArray seq, 
                                       clsProb : NDArray, 
                                       bboxPred : NDArray, 
                                       imInfo : NDArray, 
                                       [<Optional; DefaultParameterValue(6000)>] rpnPreNmsTopN : int, 
                                       [<Optional; DefaultParameterValue(300)>] rpnPostNmsTopN : int, 
                                       [<Optional; DefaultParameterValue(0.699999988)>] threshold : float, 
                                       [<Optional; DefaultParameterValue(16)>] rpnMinSize : int, 
                                       [<Optional>] scales : double seq, 
                                       [<Optional>] ratios : double seq, 
                                       [<Optional; DefaultParameterValue(16)>] featureStride : int, 
                                       [<Optional; DefaultParameterValue(false)>] outputScore : bool, 
                                       [<Optional; DefaultParameterValue(false)>] iouLoss : bool) =
        let creator = AtomicSymbolCreator.FromName "_contrib_MultiProposal"
        let names = [|"rpn_pre_nms_top_n"; "rpn_post_nms_top_n"; "threshold"; "rpn_min_size"; "scales"; "ratios"; "feature_stride"; "output_score"; "iou_loss"|]
        let vals = [|string rpnPreNmsTopN; string rpnPostNmsTopN; string threshold; string rpnMinSize; (if isNull (scales :> obj) then "[4,8,16,32]" else string scales); (if isNull (ratios :> obj) then "[0.5,1,2]" else string ratios); string featureStride; string outputScore; string iouLoss|]
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg clsProb)) then clsProb.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg bboxPred)) then bboxPred.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg imInfo)) then imInfo.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <summary>Generate region proposals via RPN</summary>
    /// <param name="clsProb">Score of how likely proposal is object.</param>
    /// <param name="bboxPred">BBox Predicted deltas from anchors for proposals</param>
    /// <param name="imInfo">Image size and scale.</param>
    /// <param name="rpnPreNmsTopN">Number of top scoring boxes to keep before applying NMS to RPN proposals</param>
    /// <param name="rpnPostNmsTopN">Number of top scoring boxes to keep after applying NMS to RPN proposals</param>
    /// <param name="threshold">NMS value, below which to suppress.</param>
    /// <param name="rpnMinSize">Minimum height or width in proposal</param>
    /// <param name="scales">Used to generate anchor windows by enumerating scales</param>
    /// <param name="ratios">Used to generate anchor windows by enumerating ratios</param>
    /// <param name="featureStride">The size of the receptive field each unit in the convolution layer of the rpn,for example the product of all stride&#39;s prior to this layer.</param>
    /// <param name="outputScore">Add score to outputs</param>
    /// <param name="iouLoss">Usage of IoU Loss</param>
    static member ContribMultiProposal([<Optional>] ?clsProb : Symbol, [<Optional>] ?bboxPred : Symbol, [<Optional>] ?imInfo : Symbol, [<Optional>] ?rpnPreNmsTopN : int, [<Optional>] ?rpnPostNmsTopN : int, [<Optional>] ?threshold : float, [<Optional>] ?rpnMinSize : int, [<Optional>] ?scales : double seq, [<Optional>] ?ratios : double seq, [<Optional>] ?featureStride : int, [<Optional>] ?outputScore : bool, [<Optional>] ?iouLoss : bool) =
        ContribMultiProposal(?clsProb = clsProb, ?bboxPred = bboxPred, ?imInfo = imInfo, ?rpnPreNmsTopN = rpnPreNmsTopN, ?rpnPostNmsTopN = rpnPostNmsTopN, ?threshold = threshold, ?rpnMinSize = rpnMinSize, ?scales = scales, ?ratios = ratios, ?featureStride = featureStride, ?outputScore = outputScore, ?iouLoss = iouLoss)





    /// <summary>Generate region proposals via RPN</summary>
    /// <param name="clsProb">Score of how likely proposal is object.</param>
    /// <param name="bboxPred">BBox Predicted deltas from anchors for proposals</param>
    /// <param name="imInfo">Image size and scale.</param>
    /// <param name="rpnPreNmsTopN">Number of top scoring boxes to keep before applying NMS to RPN proposals</param>
    /// <param name="rpnPostNmsTopN">Number of top scoring boxes to keep after applying NMS to RPN proposals</param>
    /// <param name="threshold">NMS value, below which to suppress.</param>
    /// <param name="rpnMinSize">Minimum height or width in proposal</param>
    /// <param name="scales">Used to generate anchor windows by enumerating scales</param>
    /// <param name="ratios">Used to generate anchor windows by enumerating ratios</param>
    /// <param name="featureStride">The size of the receptive field each unit in the convolution layer of the rpn,for example the product of all stride&#39;s prior to this layer.</param>
    /// <param name="outputScore">Add score to outputs</param>
    /// <param name="iouLoss">Usage of IoU Loss</param>
    static member ContribProposal(clsProb : NDArray, 
                                  bboxPred : NDArray, 
                                  imInfo : NDArray, 
                                  [<Optional; DefaultParameterValue(6000)>] rpnPreNmsTopN : int, 
                                  [<Optional; DefaultParameterValue(300)>] rpnPostNmsTopN : int, 
                                  [<Optional; DefaultParameterValue(0.699999988)>] threshold : float, 
                                  [<Optional; DefaultParameterValue(16)>] rpnMinSize : int, 
                                  [<Optional>] scales : double seq, 
                                  [<Optional>] ratios : double seq, 
                                  [<Optional; DefaultParameterValue(16)>] featureStride : int, 
                                  [<Optional; DefaultParameterValue(false)>] outputScore : bool, 
                                  [<Optional; DefaultParameterValue(false)>] iouLoss : bool) =
        let creator = AtomicSymbolCreator.FromName "_contrib_Proposal"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg clsProb)) then clsProb.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg bboxPred)) then bboxPred.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg imInfo)) then imInfo.UnsafeHandle|]
                                                 [|"rpn_pre_nms_top_n"; "rpn_post_nms_top_n"; "threshold"; "rpn_min_size"; "scales"; "ratios"; "feature_stride"; "output_score"; "iou_loss"|]
                                                 [|string rpnPreNmsTopN; string rpnPostNmsTopN; string threshold; string rpnMinSize; (if isNull (scales :> obj) then "[4,8,16,32]" else string scales); (if isNull (ratios :> obj) then "[0.5,1,2]" else string ratios); string featureStride; string outputScore; string iouLoss|]
        outputs |> Array.map (fun h -> new NDArray(h))
    /// <summary>Generate region proposals via RPN</summary>
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="clsProb">Score of how likely proposal is object.</param>
    /// <param name="bboxPred">BBox Predicted deltas from anchors for proposals</param>
    /// <param name="imInfo">Image size and scale.</param>
    /// <param name="rpnPreNmsTopN">Number of top scoring boxes to keep before applying NMS to RPN proposals</param>
    /// <param name="rpnPostNmsTopN">Number of top scoring boxes to keep after applying NMS to RPN proposals</param>
    /// <param name="threshold">NMS value, below which to suppress.</param>
    /// <param name="rpnMinSize">Minimum height or width in proposal</param>
    /// <param name="scales">Used to generate anchor windows by enumerating scales</param>
    /// <param name="ratios">Used to generate anchor windows by enumerating ratios</param>
    /// <param name="featureStride">The size of the receptive field each unit in the convolution layer of the rpn,for example the product of all stride&#39;s prior to this layer.</param>
    /// <param name="outputScore">Add score to outputs</param>
    /// <param name="iouLoss">Usage of IoU Loss</param>
    static member ContribProposal(outputArray : NDArray seq, 
                                  clsProb : NDArray, 
                                  bboxPred : NDArray, 
                                  imInfo : NDArray, 
                                  [<Optional; DefaultParameterValue(6000)>] rpnPreNmsTopN : int, 
                                  [<Optional; DefaultParameterValue(300)>] rpnPostNmsTopN : int, 
                                  [<Optional; DefaultParameterValue(0.699999988)>] threshold : float, 
                                  [<Optional; DefaultParameterValue(16)>] rpnMinSize : int, 
                                  [<Optional>] scales : double seq, 
                                  [<Optional>] ratios : double seq, 
                                  [<Optional; DefaultParameterValue(16)>] featureStride : int, 
                                  [<Optional; DefaultParameterValue(false)>] outputScore : bool, 
                                  [<Optional; DefaultParameterValue(false)>] iouLoss : bool) =
        let creator = AtomicSymbolCreator.FromName "_contrib_Proposal"
        let names = [|"rpn_pre_nms_top_n"; "rpn_post_nms_top_n"; "threshold"; "rpn_min_size"; "scales"; "ratios"; "feature_stride"; "output_score"; "iou_loss"|]
        let vals = [|string rpnPreNmsTopN; string rpnPostNmsTopN; string threshold; string rpnMinSize; (if isNull (scales :> obj) then "[4,8,16,32]" else string scales); (if isNull (ratios :> obj) then "[0.5,1,2]" else string ratios); string featureStride; string outputScore; string iouLoss|]
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg clsProb)) then clsProb.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg bboxPred)) then bboxPred.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg imInfo)) then imInfo.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <summary>Generate region proposals via RPN</summary>
    /// <param name="clsProb">Score of how likely proposal is object.</param>
    /// <param name="bboxPred">BBox Predicted deltas from anchors for proposals</param>
    /// <param name="imInfo">Image size and scale.</param>
    /// <param name="rpnPreNmsTopN">Number of top scoring boxes to keep before applying NMS to RPN proposals</param>
    /// <param name="rpnPostNmsTopN">Number of top scoring boxes to keep after applying NMS to RPN proposals</param>
    /// <param name="threshold">NMS value, below which to suppress.</param>
    /// <param name="rpnMinSize">Minimum height or width in proposal</param>
    /// <param name="scales">Used to generate anchor windows by enumerating scales</param>
    /// <param name="ratios">Used to generate anchor windows by enumerating ratios</param>
    /// <param name="featureStride">The size of the receptive field each unit in the convolution layer of the rpn,for example the product of all stride&#39;s prior to this layer.</param>
    /// <param name="outputScore">Add score to outputs</param>
    /// <param name="iouLoss">Usage of IoU Loss</param>
    static member ContribProposal([<Optional>] ?clsProb : Symbol, [<Optional>] ?bboxPred : Symbol, [<Optional>] ?imInfo : Symbol, [<Optional>] ?rpnPreNmsTopN : int, [<Optional>] ?rpnPostNmsTopN : int, [<Optional>] ?threshold : float, [<Optional>] ?rpnMinSize : int, [<Optional>] ?scales : double seq, [<Optional>] ?ratios : double seq, [<Optional>] ?featureStride : int, [<Optional>] ?outputScore : bool, [<Optional>] ?iouLoss : bool) =
        ContribProposal(?clsProb = clsProb, ?bboxPred = bboxPred, ?imInfo = imInfo, ?rpnPreNmsTopN = rpnPreNmsTopN, ?rpnPostNmsTopN = rpnPostNmsTopN, ?threshold = threshold, ?rpnMinSize = rpnMinSize, ?scales = scales, ?ratios = ratios, ?featureStride = featureStride, ?outputScore = outputScore, ?iouLoss = iouLoss)


    /// <summary>Performs region-of-interest pooling on inputs. Resize bounding box coordinates by spatial_scale and crop input feature maps accordingly. The cropped feature maps are pooled by max pooling to a fixed size output indicated by pooled_size. batch_size will change to the number of region bounding boxes after PSROIPooling</summary>
    /// <param name="data">Input data to the pooling operator, a 4D Feature maps</param>
    /// <param name="rois">Bounding box coordinates, a 2D array of [[batch_index, x1, y1, x2, y2]]. (x1, y1) and (x2, y2) are top left and down right corners of designated region of interest. batch_index indicates the index of corresponding image in the input data</param>
    /// <param name="spatialScale">Ratio of input feature map height (or w) to raw image height (or w). Equals the reciprocal of total stride in convolutional layers</param>
    /// <param name="outputDim">fix output dim</param>
    /// <param name="pooledSize">fix pooled size</param>
    /// <param name="groupSize">fix group size</param>
    static member ContribPSROIPooling(data : Symbol, rois : Symbol, spatialScale : float, outputDim : int, pooledSize : int, [<Optional>] ?groupSize : int) =
        ContribPSROIPooling(data, rois, spatialScale, outputDim, pooledSize, ?groupSize = groupSize)
    /// <summary>Performs region-of-interest pooling on inputs. Resize bounding box coordinates by spatial_scale and crop input feature maps accordingly. The cropped feature maps are pooled by max pooling to a fixed size output indicated by pooled_size. batch_size will change to the number of region bounding boxes after PSROIPooling</summary>
    /// <param name="spatialScale">Ratio of input feature map height (or w) to raw image height (or w). Equals the reciprocal of total stride in convolutional layers</param>
    /// <param name="outputDim">fix output dim</param>
    /// <param name="pooledSize">fix pooled size</param>
    /// <param name="data">Input data to the pooling operator, a 4D Feature maps</param>
    /// <param name="rois">Bounding box coordinates, a 2D array of [[batch_index, x1, y1, x2, y2]]. (x1, y1) and (x2, y2) are top left and down right corners of designated region of interest. batch_index indicates the index of corresponding image in the input data</param>
    /// <param name="groupSize">fix group size</param>
    static member ContribPSROIPooling(spatialScale : float, outputDim : int, pooledSize : int, [<Optional>] ?data : Symbol, [<Optional>] ?rois : Symbol, [<Optional>] ?groupSize : int) =
        ContribPSROIPooling(spatialScale, outputDim, pooledSize, ?data = data, ?rois = rois, ?groupSize = groupSize)



    /// <summary>This operator is DEPRECATED. Apply convolution to input then add a bias.</summary>
    /// <param name="data">Input data to the ConvolutionV1Op.</param>
    /// <param name="weight">Weight matrix.</param>
    /// <param name="bias">Bias parameter.</param>
    /// <param name="kernel">convolution kernel size: (h, w) or (d, h, w)</param>
    /// <param name="numFilter">convolution filter(channel) number</param>
    /// <param name="stride">convolution stride: (h, w) or (d, h, w)</param>
    /// <param name="dilate">convolution dilate: (h, w) or (d, h, w)</param>
    /// <param name="pad">pad for convolution: (h, w) or (d, h, w)</param>
    /// <param name="numGroup">Number of group partitions. Equivalent to slicing input into num_group
    ///     partitions, apply convolution on each, then concatenate the results</param>
    /// <param name="workspace">Maximum temporary workspace allowed for convolution (MB).This parameter determines the effective batch size of the convolution kernel, which may be smaller than the given batch size. Also, the workspace will be automatically enlarged to make sure that we can run the kernel with batch_size=1</param>
    /// <param name="noBias">Whether to disable bias parameter.</param>
    /// <param name="cudnnTune">Whether to pick convolution algo by running performance test.
    ///     Leads to higher startup time but may give faster speed. Options are:
    ///     &#39;off&#39;: no tuning
    ///     &#39;limited_workspace&#39;: run test and pick the fastest algorithm that doesn&#39;t exceed workspace limit.
    ///     &#39;fastest&#39;: pick the fastest algorithm and ignore workspace limit.
    ///     If set to None (default), behavior is determined by environment
    ///     variable MXNET_CUDNN_AUTOTUNE_DEFAULT: 0 for off,
    ///     1 for limited workspace (default), 2 for fastest.</param>
    /// <param name="cudnnOff">Turn off cudnn for this layer.</param>
    /// <param name="layout">Set layout for input, output and weight. Empty for
    ///     default layout: NCHW for 2d and NCDHW for 3d.</param>
    static member ConvolutionV1(data : NDArray, 
                                weight : NDArray, 
                                bias : NDArray, 
                                kernel : int seq, 
                                numFilter : int, 
                                [<Optional>] stride : int seq, 
                                [<Optional>] dilate : int seq, 
                                [<Optional>] pad : int seq, 
                                [<Optional; DefaultParameterValue(1)>] numGroup : int, 
                                [<Optional; DefaultParameterValue(1024L)>] workspace : int64, 
                                [<Optional; DefaultParameterValue(false)>] noBias : bool, 
                                [<Optional>] cudnnTune : CudnnTune, 
                                [<Optional; DefaultParameterValue(false)>] cudnnOff : bool, 
                                [<Optional>] layout : ConvolutionV1Layout) =
        let creator = AtomicSymbolCreator.FromName "Convolution_v1"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg weight)) then weight.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg bias)) then bias.UnsafeHandle|]
                                                 [|"kernel"; "num_filter"; "stride"; "dilate"; "pad"; "num_group"; "workspace"; "no_bias"; "cudnn_tune"; "cudnn_off"; "layout"|]
                                                 [|(kernel |> Seq.map string |> String.concat ", " |> sprintf "[%s]"); string numFilter; (if isNull (stride :> obj) then "[]" else (stride |> Seq.map string |> String.concat ", " |> sprintf "[%s]")); (if isNull (dilate :> obj) then "[]" else (dilate |> Seq.map string |> String.concat ", " |> sprintf "[%s]")); (if isNull (pad :> obj) then "[]" else (pad |> Seq.map string |> String.concat ", " |> sprintf "[%s]")); string numGroup; string workspace; string noBias; (if isNull (cudnnTune :> obj) then "None" else string cudnnTune); string cudnnOff; (if isNull (layout :> obj) then "None" else string layout)|]
        (new NDArray(outputs.[0]))
    /// <summary>This operator is DEPRECATED. Apply convolution to input then add a bias.</summary>
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="data">Input data to the ConvolutionV1Op.</param>
    /// <param name="weight">Weight matrix.</param>
    /// <param name="bias">Bias parameter.</param>
    /// <param name="kernel">convolution kernel size: (h, w) or (d, h, w)</param>
    /// <param name="numFilter">convolution filter(channel) number</param>
    /// <param name="stride">convolution stride: (h, w) or (d, h, w)</param>
    /// <param name="dilate">convolution dilate: (h, w) or (d, h, w)</param>
    /// <param name="pad">pad for convolution: (h, w) or (d, h, w)</param>
    /// <param name="numGroup">Number of group partitions. Equivalent to slicing input into num_group
    ///     partitions, apply convolution on each, then concatenate the results</param>
    /// <param name="workspace">Maximum temporary workspace allowed for convolution (MB).This parameter determines the effective batch size of the convolution kernel, which may be smaller than the given batch size. Also, the workspace will be automatically enlarged to make sure that we can run the kernel with batch_size=1</param>
    /// <param name="noBias">Whether to disable bias parameter.</param>
    /// <param name="cudnnTune">Whether to pick convolution algo by running performance test.
    ///     Leads to higher startup time but may give faster speed. Options are:
    ///     &#39;off&#39;: no tuning
    ///     &#39;limited_workspace&#39;: run test and pick the fastest algorithm that doesn&#39;t exceed workspace limit.
    ///     &#39;fastest&#39;: pick the fastest algorithm and ignore workspace limit.
    ///     If set to None (default), behavior is determined by environment
    ///     variable MXNET_CUDNN_AUTOTUNE_DEFAULT: 0 for off,
    ///     1 for limited workspace (default), 2 for fastest.</param>
    /// <param name="cudnnOff">Turn off cudnn for this layer.</param>
    /// <param name="layout">Set layout for input, output and weight. Empty for
    ///     default layout: NCHW for 2d and NCDHW for 3d.</param>
    static member ConvolutionV1(outputArray : NDArray seq, 
                                data : NDArray, 
                                weight : NDArray, 
                                bias : NDArray, 
                                kernel : int seq, 
                                numFilter : int, 
                                [<Optional>] stride : int seq, 
                                [<Optional>] dilate : int seq, 
                                [<Optional>] pad : int seq, 
                                [<Optional; DefaultParameterValue(1)>] numGroup : int, 
                                [<Optional; DefaultParameterValue(1024L)>] workspace : int64, 
                                [<Optional; DefaultParameterValue(false)>] noBias : bool, 
                                [<Optional>] cudnnTune : CudnnTune, 
                                [<Optional; DefaultParameterValue(false)>] cudnnOff : bool, 
                                [<Optional>] layout : ConvolutionV1Layout) =
        let creator = AtomicSymbolCreator.FromName "Convolution_v1"
        let names = [|"kernel"; "num_filter"; "stride"; "dilate"; "pad"; "num_group"; "workspace"; "no_bias"; "cudnn_tune"; "cudnn_off"; "layout"|]
        let vals = [|(kernel |> Seq.map string |> String.concat ", " |> sprintf "[%s]"); string numFilter; (if isNull (stride :> obj) then "[]" else (stride |> Seq.map string |> String.concat ", " |> sprintf "[%s]")); (if isNull (dilate :> obj) then "[]" else (dilate |> Seq.map string |> String.concat ", " |> sprintf "[%s]")); (if isNull (pad :> obj) then "[]" else (pad |> Seq.map string |> String.concat ", " |> sprintf "[%s]")); string numGroup; string workspace; string noBias; (if isNull (cudnnTune :> obj) then "None" else string cudnnTune); string cudnnOff; (if isNull (layout :> obj) then "None" else string layout)|]
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg weight)) then weight.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg bias)) then bias.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <summary>This operator is DEPRECATED. Apply convolution to input then add a bias.</summary>
    /// <param name="data">Input data to the ConvolutionV1Op.</param>
    /// <param name="weight">Weight matrix.</param>
    /// <param name="bias">Bias parameter.</param>
    /// <param name="kernel">convolution kernel size: (h, w) or (d, h, w)</param>
    /// <param name="numFilter">convolution filter(channel) number</param>
    /// <param name="stride">convolution stride: (h, w) or (d, h, w)</param>
    /// <param name="dilate">convolution dilate: (h, w) or (d, h, w)</param>
    /// <param name="pad">pad for convolution: (h, w) or (d, h, w)</param>
    /// <param name="numGroup">Number of group partitions. Equivalent to slicing input into num_group
    ///     partitions, apply convolution on each, then concatenate the results</param>
    /// <param name="workspace">Maximum temporary workspace allowed for convolution (MB).This parameter determines the effective batch size of the convolution kernel, which may be smaller than the given batch size. Also, the workspace will be automatically enlarged to make sure that we can run the kernel with batch_size=1</param>
    /// <param name="noBias">Whether to disable bias parameter.</param>
    /// <param name="cudnnTune">Whether to pick convolution algo by running performance test.
    ///     Leads to higher startup time but may give faster speed. Options are:
    ///     &#39;off&#39;: no tuning
    ///     &#39;limited_workspace&#39;: run test and pick the fastest algorithm that doesn&#39;t exceed workspace limit.
    ///     &#39;fastest&#39;: pick the fastest algorithm and ignore workspace limit.
    ///     If set to None (default), behavior is determined by environment
    ///     variable MXNET_CUDNN_AUTOTUNE_DEFAULT: 0 for off,
    ///     1 for limited workspace (default), 2 for fastest.</param>
    /// <param name="cudnnOff">Turn off cudnn for this layer.</param>
    /// <param name="layout">Set layout for input, output and weight. Empty for
    ///     default layout: NCHW for 2d and NCDHW for 3d.</param>
    static member ConvolutionV1(data : Symbol, weight : Symbol, bias : Symbol, kernel : int seq, numFilter : int, [<Optional>] ?stride : int seq, [<Optional>] ?dilate : int seq, [<Optional>] ?pad : int seq, [<Optional>] ?numGroup : int, [<Optional>] ?workspace : int64, [<Optional>] ?noBias : bool, [<Optional>] ?cudnnTune : CudnnTune, [<Optional>] ?cudnnOff : bool, [<Optional>] ?layout : ConvolutionV1Layout) =
        ConvolutionV1(data, weight, bias, kernel, numFilter, ?stride = stride, ?dilate = dilate, ?pad = pad, ?numGroup = numGroup, ?workspace = workspace, ?noBias = noBias, ?cudnnTune = cudnnTune, ?cudnnOff = cudnnOff, ?layout = layout)
    /// <summary>This operator is DEPRECATED. Apply convolution to input then add a bias.</summary>
    /// <param name="kernel">convolution kernel size: (h, w) or (d, h, w)</param>
    /// <param name="numFilter">convolution filter(channel) number</param>
    /// <param name="data">Input data to the ConvolutionV1Op.</param>
    /// <param name="weight">Weight matrix.</param>
    /// <param name="bias">Bias parameter.</param>
    /// <param name="stride">convolution stride: (h, w) or (d, h, w)</param>
    /// <param name="dilate">convolution dilate: (h, w) or (d, h, w)</param>
    /// <param name="pad">pad for convolution: (h, w) or (d, h, w)</param>
    /// <param name="numGroup">Number of group partitions. Equivalent to slicing input into num_group
    ///     partitions, apply convolution on each, then concatenate the results</param>
    /// <param name="workspace">Maximum temporary workspace allowed for convolution (MB).This parameter determines the effective batch size of the convolution kernel, which may be smaller than the given batch size. Also, the workspace will be automatically enlarged to make sure that we can run the kernel with batch_size=1</param>
    /// <param name="noBias">Whether to disable bias parameter.</param>
    /// <param name="cudnnTune">Whether to pick convolution algo by running performance test.
    ///     Leads to higher startup time but may give faster speed. Options are:
    ///     &#39;off&#39;: no tuning
    ///     &#39;limited_workspace&#39;: run test and pick the fastest algorithm that doesn&#39;t exceed workspace limit.
    ///     &#39;fastest&#39;: pick the fastest algorithm and ignore workspace limit.
    ///     If set to None (default), behavior is determined by environment
    ///     variable MXNET_CUDNN_AUTOTUNE_DEFAULT: 0 for off,
    ///     1 for limited workspace (default), 2 for fastest.</param>
    /// <param name="cudnnOff">Turn off cudnn for this layer.</param>
    /// <param name="layout">Set layout for input, output and weight. Empty for
    ///     default layout: NCHW for 2d and NCDHW for 3d.</param>
    static member ConvolutionV1(kernel : int seq, numFilter : int, [<Optional>] ?data : Symbol, [<Optional>] ?weight : Symbol, [<Optional>] ?bias : Symbol, [<Optional>] ?stride : int seq, [<Optional>] ?dilate : int seq, [<Optional>] ?pad : int seq, [<Optional>] ?numGroup : int, [<Optional>] ?workspace : int64, [<Optional>] ?noBias : bool, [<Optional>] ?cudnnTune : CudnnTune, [<Optional>] ?cudnnOff : bool, [<Optional>] ?layout : ConvolutionV1Layout) =
        ConvolutionV1(kernel, numFilter, ?data = data, ?weight = weight, ?bias = bias, ?stride = stride, ?dilate = dilate, ?pad = pad, ?numGroup = numGroup, ?workspace = workspace, ?noBias = noBias, ?cudnnTune = cudnnTune, ?cudnnOff = cudnnOff, ?layout = layout)


    /// <summary>Applies correlation to inputs.
    /// 
    /// The correlation layer performs multiplicative patch comparisons between two feature maps.
    /// 
    /// Given two multi-channel feature maps :math:`f_{1}, f_{2}`, with :math:`w`, :math:`h`, and :math:`c` being their width, height, and number of channels,
    /// the correlation layer lets the network compare each patch from :math:`f_{1}` with each patch from :math:`f_{2}`.
    /// 
    /// For now we consider only a single comparison of two patches. The &#39;correlation&#39; of two patches centered at :math:`x_{1}` in the first map and
    /// :math:`x_{2}` in the second map is then defined as:
    /// 
    /// .. math::
    /// 
    ///    c(x_{1}, x_{2}) = \sum_{o \in [-k,k] \times [-k,k]} &lt;f_{1}(x_{1} + o), f_{2}(x_{2} + o)&gt;
    /// 
    /// for a square patch of size :math:`K:=2k+1`.
    /// 
    /// Note that the equation above is identical to one step of a convolution in neural networks, but instead of convolving data with a filter, it convolves data with other
    /// data. For this reason, it has no training weights.
    /// 
    /// Computing :math:`c(x_{1}, x_{2})` involves :math:`c * K^{2}` multiplications. Comparing all patch combinations involves :math:`w^{2}*h^{2}` such computations.
    /// 
    /// Given a maximum displacement :math:`d`, for each location :math:`x_{1}` it computes correlations :math:`c(x_{1}, x_{2})` only in a neighborhood of size :math:`D:=2d+1`,
    /// by limiting the range of :math:`x_{2}`. We use strides :math:`s_{1}, s_{2}`, to quantize :math:`x_{1}` globally and to quantize :math:`x_{2}` within the neighborhood
    /// centered around :math:`x_{1}`.
    /// 
    /// The final output is defined by the following expression:
    /// 
    /// .. math::
    ///   out[n, q, i, j] = c(x_{i, j}, x_{q})
    /// 
    /// where :math:`i` and :math:`j` enumerate spatial locations in :math:`f_{1}`, and :math:`q` denotes the :math:`q^{th}` neighborhood of :math:`x_{i,j}`.
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\correlation.cc:L198</summary>
    /// <param name="data1">Input data1 to the correlation.</param>
    /// <param name="data2">Input data2 to the correlation.</param>
    /// <param name="kernelSize">kernel size for Correlation must be an odd number</param>
    /// <param name="maxDisplacement">Max displacement of Correlation </param>
    /// <param name="stride1">stride1 quantize data1 globally</param>
    /// <param name="stride2">stride2 quantize data2 within the neighborhood centered around data1</param>
    /// <param name="padSize">pad for Correlation</param>
    /// <param name="isMultiply">operation type is either multiplication or subduction</param>
    static member Correlation(data1 : NDArray, 
                              data2 : NDArray, 
                              [<Optional; DefaultParameterValue(1)>] kernelSize : int, 
                              [<Optional; DefaultParameterValue(1)>] maxDisplacement : int, 
                              [<Optional; DefaultParameterValue(1)>] stride1 : int, 
                              [<Optional; DefaultParameterValue(1)>] stride2 : int, 
                              [<Optional; DefaultParameterValue(0)>] padSize : int, 
                              [<Optional; DefaultParameterValue(true)>] isMultiply : bool) =
        let creator = AtomicSymbolCreator.FromName "Correlation"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data1)) then data1.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data2)) then data2.UnsafeHandle|]
                                                 [|"kernel_size"; "max_displacement"; "stride1"; "stride2"; "pad_size"; "is_multiply"|]
                                                 [|string kernelSize; string maxDisplacement; string stride1; string stride2; string padSize; string isMultiply|]
        outputs |> Array.map (fun h -> new NDArray(h))
    /// <summary>Applies correlation to inputs.
    /// 
    /// The correlation layer performs multiplicative patch comparisons between two feature maps.
    /// 
    /// Given two multi-channel feature maps :math:`f_{1}, f_{2}`, with :math:`w`, :math:`h`, and :math:`c` being their width, height, and number of channels,
    /// the correlation layer lets the network compare each patch from :math:`f_{1}` with each patch from :math:`f_{2}`.
    /// 
    /// For now we consider only a single comparison of two patches. The &#39;correlation&#39; of two patches centered at :math:`x_{1}` in the first map and
    /// :math:`x_{2}` in the second map is then defined as:
    /// 
    /// .. math::
    /// 
    ///    c(x_{1}, x_{2}) = \sum_{o \in [-k,k] \times [-k,k]} &lt;f_{1}(x_{1} + o), f_{2}(x_{2} + o)&gt;
    /// 
    /// for a square patch of size :math:`K:=2k+1`.
    /// 
    /// Note that the equation above is identical to one step of a convolution in neural networks, but instead of convolving data with a filter, it convolves data with other
    /// data. For this reason, it has no training weights.
    /// 
    /// Computing :math:`c(x_{1}, x_{2})` involves :math:`c * K^{2}` multiplications. Comparing all patch combinations involves :math:`w^{2}*h^{2}` such computations.
    /// 
    /// Given a maximum displacement :math:`d`, for each location :math:`x_{1}` it computes correlations :math:`c(x_{1}, x_{2})` only in a neighborhood of size :math:`D:=2d+1`,
    /// by limiting the range of :math:`x_{2}`. We use strides :math:`s_{1}, s_{2}`, to quantize :math:`x_{1}` globally and to quantize :math:`x_{2}` within the neighborhood
    /// centered around :math:`x_{1}`.
    /// 
    /// The final output is defined by the following expression:
    /// 
    /// .. math::
    ///   out[n, q, i, j] = c(x_{i, j}, x_{q})
    /// 
    /// where :math:`i` and :math:`j` enumerate spatial locations in :math:`f_{1}`, and :math:`q` denotes the :math:`q^{th}` neighborhood of :math:`x_{i,j}`.
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\correlation.cc:L198</summary>
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="data1">Input data1 to the correlation.</param>
    /// <param name="data2">Input data2 to the correlation.</param>
    /// <param name="kernelSize">kernel size for Correlation must be an odd number</param>
    /// <param name="maxDisplacement">Max displacement of Correlation </param>
    /// <param name="stride1">stride1 quantize data1 globally</param>
    /// <param name="stride2">stride2 quantize data2 within the neighborhood centered around data1</param>
    /// <param name="padSize">pad for Correlation</param>
    /// <param name="isMultiply">operation type is either multiplication or subduction</param>
    static member Correlation(outputArray : NDArray seq, 
                              data1 : NDArray, 
                              data2 : NDArray, 
                              [<Optional; DefaultParameterValue(1)>] kernelSize : int, 
                              [<Optional; DefaultParameterValue(1)>] maxDisplacement : int, 
                              [<Optional; DefaultParameterValue(1)>] stride1 : int, 
                              [<Optional; DefaultParameterValue(1)>] stride2 : int, 
                              [<Optional; DefaultParameterValue(0)>] padSize : int, 
                              [<Optional; DefaultParameterValue(true)>] isMultiply : bool) =
        let creator = AtomicSymbolCreator.FromName "Correlation"
        let names = [|"kernel_size"; "max_displacement"; "stride1"; "stride2"; "pad_size"; "is_multiply"|]
        let vals = [|string kernelSize; string maxDisplacement; string stride1; string stride2; string padSize; string isMultiply|]
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data1)) then data1.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data2)) then data2.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <summary>Applies correlation to inputs.
    /// 
    /// The correlation layer performs multiplicative patch comparisons between two feature maps.
    /// 
    /// Given two multi-channel feature maps :math:`f_{1}, f_{2}`, with :math:`w`, :math:`h`, and :math:`c` being their width, height, and number of channels,
    /// the correlation layer lets the network compare each patch from :math:`f_{1}` with each patch from :math:`f_{2}`.
    /// 
    /// For now we consider only a single comparison of two patches. The &#39;correlation&#39; of two patches centered at :math:`x_{1}` in the first map and
    /// :math:`x_{2}` in the second map is then defined as:
    /// 
    /// .. math::
    /// 
    ///    c(x_{1}, x_{2}) = \sum_{o \in [-k,k] \times [-k,k]} &lt;f_{1}(x_{1} + o), f_{2}(x_{2} + o)&gt;
    /// 
    /// for a square patch of size :math:`K:=2k+1`.
    /// 
    /// Note that the equation above is identical to one step of a convolution in neural networks, but instead of convolving data with a filter, it convolves data with other
    /// data. For this reason, it has no training weights.
    /// 
    /// Computing :math:`c(x_{1}, x_{2})` involves :math:`c * K^{2}` multiplications. Comparing all patch combinations involves :math:`w^{2}*h^{2}` such computations.
    /// 
    /// Given a maximum displacement :math:`d`, for each location :math:`x_{1}` it computes correlations :math:`c(x_{1}, x_{2})` only in a neighborhood of size :math:`D:=2d+1`,
    /// by limiting the range of :math:`x_{2}`. We use strides :math:`s_{1}, s_{2}`, to quantize :math:`x_{1}` globally and to quantize :math:`x_{2}` within the neighborhood
    /// centered around :math:`x_{1}`.
    /// 
    /// The final output is defined by the following expression:
    /// 
    /// .. math::
    ///   out[n, q, i, j] = c(x_{i, j}, x_{q})
    /// 
    /// where :math:`i` and :math:`j` enumerate spatial locations in :math:`f_{1}`, and :math:`q` denotes the :math:`q^{th}` neighborhood of :math:`x_{i,j}`.
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\correlation.cc:L198</summary>
    /// <param name="data1">Input data1 to the correlation.</param>
    /// <param name="data2">Input data2 to the correlation.</param>
    /// <param name="kernelSize">kernel size for Correlation must be an odd number</param>
    /// <param name="maxDisplacement">Max displacement of Correlation </param>
    /// <param name="stride1">stride1 quantize data1 globally</param>
    /// <param name="stride2">stride2 quantize data2 within the neighborhood centered around data1</param>
    /// <param name="padSize">pad for Correlation</param>
    /// <param name="isMultiply">operation type is either multiplication or subduction</param>
    static member Correlation([<Optional>] ?data1 : Symbol, [<Optional>] ?data2 : Symbol, [<Optional>] ?kernelSize : int, [<Optional>] ?maxDisplacement : int, [<Optional>] ?stride1 : int, [<Optional>] ?stride2 : int, [<Optional>] ?padSize : int, [<Optional>] ?isMultiply : bool) =
        Correlation(?data1 = data1, ?data2 = data2, ?kernelSize = kernelSize, ?maxDisplacement = maxDisplacement, ?stride1 = stride1, ?stride2 = stride2, ?padSize = padSize, ?isMultiply = isMultiply)



    /// <summary>Special op to copy data cross device</summary>
    static member CrossDeviceCopyNDArray() =
        let creator = AtomicSymbolCreator.FromName "_CrossDeviceCopy"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 Array.empty
                                                 Array.empty
                                                 Array.empty
        outputs |> Array.map (fun h -> new NDArray(h))
    /// <summary>Special op to copy data cross device</summary>
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    static member CrossDeviceCopy(outputArray : NDArray seq) =
        let creator = AtomicSymbolCreator.FromName "_CrossDeviceCopy"
        let names = Array.empty
        let vals = Array.empty
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     Array.empty
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <summary>Special op to copy data cross device</summary>
    static member CrossDeviceCopy() =
        CrossDeviceCopy()




    /// <summary>Generates 2D sampling grid for bilinear sampling.</summary>
    /// <param name="data">Input data to the function.</param>
    /// <param name="transformType">The type of transformation. For `affine`, input data should be an affine matrix of size (batch, 6). For `warp`, input data should be an optical flow of size (batch, 2, h, w).</param>
    /// <param name="targetShape">Specifies the output shape (H, W). This is required if transformation type is `affine`. If transformation type is `warp`, this parameter is ignored.</param>
    static member GridGenerator(data : NDArray, transformType : GridGeneratorTransformType, [<Optional>] targetShape : int seq) =
        let creator = AtomicSymbolCreator.FromName "GridGenerator"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle|]
                                                 [|"transform_type"; "target_shape"|]
                                                 [|string transformType; (if isNull (targetShape :> obj) then "[0,0]" else (targetShape |> Seq.map string |> String.concat ", " |> sprintf "[%s]"))|]
        outputs |> Array.map (fun h -> new NDArray(h))
    /// <summary>Generates 2D sampling grid for bilinear sampling.</summary>
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="data">Input data to the function.</param>
    /// <param name="transformType">The type of transformation. For `affine`, input data should be an affine matrix of size (batch, 6). For `warp`, input data should be an optical flow of size (batch, 2, h, w).</param>
    /// <param name="targetShape">Specifies the output shape (H, W). This is required if transformation type is `affine`. If transformation type is `warp`, this parameter is ignored.</param>
    static member GridGenerator(outputArray : NDArray seq, data : NDArray, transformType : GridGeneratorTransformType, [<Optional>] targetShape : int seq) =
        let creator = AtomicSymbolCreator.FromName "GridGenerator"
        let names = [|"transform_type"; "target_shape"|]
        let vals = [|string transformType; (if isNull (targetShape :> obj) then "[0,0]" else (targetShape |> Seq.map string |> String.concat ", " |> sprintf "[%s]"))|]
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <summary>Generates 2D sampling grid for bilinear sampling.</summary>
    /// <param name="data">Input data to the function.</param>
    /// <param name="transformType">The type of transformation. For `affine`, input data should be an affine matrix of size (batch, 6). For `warp`, input data should be an optical flow of size (batch, 2, h, w).</param>
    /// <param name="targetShape">Specifies the output shape (H, W). This is required if transformation type is `affine`. If transformation type is `warp`, this parameter is ignored.</param>
    static member GridGenerator(data : Symbol, transformType : GridGeneratorTransformType, [<Optional>] ?targetShape : int seq) =
        GridGenerator(data, transformType, ?targetShape = targetShape)
    /// <summary>Generates 2D sampling grid for bilinear sampling.</summary>
    /// <param name="transformType">The type of transformation. For `affine`, input data should be an affine matrix of size (batch, 6). For `warp`, input data should be an optical flow of size (batch, 2, h, w).</param>
    /// <param name="data">Input data to the function.</param>
    /// <param name="targetShape">Specifies the output shape (H, W). This is required if transformation type is `affine`. If transformation type is `warp`, this parameter is ignored.</param>
    static member GridGenerator(transformType : GridGeneratorTransformType, [<Optional>] ?data : Symbol, [<Optional>] ?targetShape : int seq) =
        GridGenerator(transformType, ?data = data, ?targetShape = targetShape)



    /// <summary>Applies instance normalization to the n-dimensional input array.
    /// 
    /// This operator takes an n-dimensional input array where (n&gt;2) and normalizes
    /// the input using the following formula:
    /// 
    /// .. math::
    /// 
    ///   out = \frac{x - mean[data]}{ \sqrt{Var[data]} + \epsilon} * gamma + beta
    /// 
    /// This layer is similar to batch normalization layer (`BatchNorm`)
    /// with two differences: first, the normalization is
    /// carried out per example (instance), not over a batch. Second, the
    /// same normalization is applied both at test and train time. This
    /// operation is also known as `contrast normalization`.
    /// 
    /// If the input data is of shape [batch, channel, spacial_dim1, spacial_dim2, ...],
    /// `gamma` and `beta` parameters must be vectors of shape [channel].
    /// 
    /// This implementation is based on this paper [1]_
    /// 
    /// .. [1] Instance Normalization: The Missing Ingredient for Fast Stylization,
    ///    D. Ulyanov, A. Vedaldi, V. Lempitsky, 2016 (arXiv:1607.08022v2).
    /// 
    /// Examples::
    /// 
    ///   // Input of shape (2,1,2)
    ///   x = [[[ 1.1,  2.2]],
    ///        [[ 3.3,  4.4]]]
    /// 
    ///   // gamma parameter of length 1
    ///   gamma = [1.5]
    /// 
    ///   // beta parameter of length 1
    ///   beta = [0.5]
    /// 
    ///   // Instance normalization is calculated with the above formula
    ///   InstanceNorm(x,gamma,beta) = [[[-0.997527  ,  1.99752665]],
    ///                                 [[-0.99752653,  1.99752724]]]
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\instance_norm.cc:L95</summary>
    /// <param name="data">An n-dimensional input array (n &gt; 2) of the form [batch, channel, spatial_dim1, spatial_dim2, ...].</param>
    /// <param name="gamma">A vector of length &#39;channel&#39;, which multiplies the normalized input.</param>
    /// <param name="beta">A vector of length &#39;channel&#39;, which is added to the product of the normalized input and the weight.</param>
    /// <param name="eps">An `epsilon` parameter to prevent division by 0.</param>
    static member InstanceNorm(data : NDArray, gamma : NDArray, beta : NDArray, [<Optional; DefaultParameterValue(0.00100000005)>] eps : float) =
        let creator = AtomicSymbolCreator.FromName "InstanceNorm"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg gamma)) then gamma.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg beta)) then beta.UnsafeHandle|]
                                                 [|"eps"|]
                                                 [|string eps|]
        (new NDArray(outputs.[0]))
    /// <summary>Applies instance normalization to the n-dimensional input array.
    /// 
    /// This operator takes an n-dimensional input array where (n&gt;2) and normalizes
    /// the input using the following formula:
    /// 
    /// .. math::
    /// 
    ///   out = \frac{x - mean[data]}{ \sqrt{Var[data]} + \epsilon} * gamma + beta
    /// 
    /// This layer is similar to batch normalization layer (`BatchNorm`)
    /// with two differences: first, the normalization is
    /// carried out per example (instance), not over a batch. Second, the
    /// same normalization is applied both at test and train time. This
    /// operation is also known as `contrast normalization`.
    /// 
    /// If the input data is of shape [batch, channel, spacial_dim1, spacial_dim2, ...],
    /// `gamma` and `beta` parameters must be vectors of shape [channel].
    /// 
    /// This implementation is based on this paper [1]_
    /// 
    /// .. [1] Instance Normalization: The Missing Ingredient for Fast Stylization,
    ///    D. Ulyanov, A. Vedaldi, V. Lempitsky, 2016 (arXiv:1607.08022v2).
    /// 
    /// Examples::
    /// 
    ///   // Input of shape (2,1,2)
    ///   x = [[[ 1.1,  2.2]],
    ///        [[ 3.3,  4.4]]]
    /// 
    ///   // gamma parameter of length 1
    ///   gamma = [1.5]
    /// 
    ///   // beta parameter of length 1
    ///   beta = [0.5]
    /// 
    ///   // Instance normalization is calculated with the above formula
    ///   InstanceNorm(x,gamma,beta) = [[[-0.997527  ,  1.99752665]],
    ///                                 [[-0.99752653,  1.99752724]]]
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\instance_norm.cc:L95</summary>
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="data">An n-dimensional input array (n &gt; 2) of the form [batch, channel, spatial_dim1, spatial_dim2, ...].</param>
    /// <param name="gamma">A vector of length &#39;channel&#39;, which multiplies the normalized input.</param>
    /// <param name="beta">A vector of length &#39;channel&#39;, which is added to the product of the normalized input and the weight.</param>
    /// <param name="eps">An `epsilon` parameter to prevent division by 0.</param>
    static member InstanceNorm(outputArray : NDArray seq, data : NDArray, gamma : NDArray, beta : NDArray, [<Optional; DefaultParameterValue(0.00100000005)>] eps : float) =
        let creator = AtomicSymbolCreator.FromName "InstanceNorm"
        let names = [|"eps"|]
        let vals = [|string eps|]
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg gamma)) then gamma.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg beta)) then beta.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <summary>Applies instance normalization to the n-dimensional input array.
    /// 
    /// This operator takes an n-dimensional input array where (n&gt;2) and normalizes
    /// the input using the following formula:
    /// 
    /// .. math::
    /// 
    ///   out = \frac{x - mean[data]}{ \sqrt{Var[data]} + \epsilon} * gamma + beta
    /// 
    /// This layer is similar to batch normalization layer (`BatchNorm`)
    /// with two differences: first, the normalization is
    /// carried out per example (instance), not over a batch. Second, the
    /// same normalization is applied both at test and train time. This
    /// operation is also known as `contrast normalization`.
    /// 
    /// If the input data is of shape [batch, channel, spacial_dim1, spacial_dim2, ...],
    /// `gamma` and `beta` parameters must be vectors of shape [channel].
    /// 
    /// This implementation is based on this paper [1]_
    /// 
    /// .. [1] Instance Normalization: The Missing Ingredient for Fast Stylization,
    ///    D. Ulyanov, A. Vedaldi, V. Lempitsky, 2016 (arXiv:1607.08022v2).
    /// 
    /// Examples::
    /// 
    ///   // Input of shape (2,1,2)
    ///   x = [[[ 1.1,  2.2]],
    ///        [[ 3.3,  4.4]]]
    /// 
    ///   // gamma parameter of length 1
    ///   gamma = [1.5]
    /// 
    ///   // beta parameter of length 1
    ///   beta = [0.5]
    /// 
    ///   // Instance normalization is calculated with the above formula
    ///   InstanceNorm(x,gamma,beta) = [[[-0.997527  ,  1.99752665]],
    ///                                 [[-0.99752653,  1.99752724]]]
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\instance_norm.cc:L95</summary>
    /// <param name="data">An n-dimensional input array (n &gt; 2) of the form [batch, channel, spatial_dim1, spatial_dim2, ...].</param>
    /// <param name="gamma">A vector of length &#39;channel&#39;, which multiplies the normalized input.</param>
    /// <param name="beta">A vector of length &#39;channel&#39;, which is added to the product of the normalized input and the weight.</param>
    /// <param name="eps">An `epsilon` parameter to prevent division by 0.</param>
    static member InstanceNorm([<Optional>] ?data : Symbol, [<Optional>] ?gamma : Symbol, [<Optional>] ?beta : Symbol, [<Optional>] ?eps : float) =
        InstanceNorm(?data = data, ?gamma = gamma, ?beta = beta, ?eps = eps)


    /// <summary>Normalize the input array using the L2 norm.
    /// 
    /// For 1-D NDArray, it computes::
    /// 
    ///   out = data / sqrt(sum(data ** 2) + eps)
    /// 
    /// For N-D NDArray, if the input array has shape (N, N, ..., N),
    /// 
    /// with ``mode`` = ``instance``, it normalizes each instance in the multidimensional
    /// array by its L2 norm.::
    /// 
    ///   for i in 0...N
    ///     out[i,:,:,...,:] = data[i,:,:,...,:] / sqrt(sum(data[i,:,:,...,:] ** 2) + eps)
    /// 
    /// with ``mode`` = ``channel``, it normalizes each channel in the array by its L2 norm.::
    /// 
    ///   for i in 0...N
    ///     out[:,i,:,...,:] = data[:,i,:,...,:] / sqrt(sum(data[:,i,:,...,:] ** 2) + eps)
    /// 
    /// with ``mode`` = ``spatial``, it normalizes the cross channel norm for each position
    /// in the array by its L2 norm.::
    /// 
    ///   for dim in 2...N
    ///     for i in 0...N
    ///       out[.....,i,...] = take(out, indices=i, axis=dim) / sqrt(sum(take(out, indices=i, axis=dim) ** 2) + eps)
    ///           -dim-
    /// 
    /// Example::
    /// 
    ///   x = [[[1,2],
    ///         [3,4]],
    ///        [[2,2],
    ///         [5,6]]]
    /// 
    ///   L2Normalization(x, mode=&#39;instance&#39;)
    ///   =[[[ 0.18257418  0.36514837]
    ///      [ 0.54772252  0.73029673]]
    ///     [[ 0.24077171  0.24077171]
    ///      [ 0.60192931  0.72231513]]]
    /// 
    ///   L2Normalization(x, mode=&#39;channel&#39;)
    ///   =[[[ 0.31622776  0.44721359]
    ///      [ 0.94868326  0.89442718]]
    ///     [[ 0.37139067  0.31622776]
    ///      [ 0.92847669  0.94868326]]]
    /// 
    ///   L2Normalization(x, mode=&#39;spatial&#39;)
    ///   =[[[ 0.44721359  0.89442718]
    ///      [ 0.60000002  0.80000001]]
    ///     [[ 0.70710677  0.70710677]
    ///      [ 0.6401844   0.76822126]]]
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\l2_normalization.cc:L196</summary>
    /// <param name="data">Input array to normalize.</param>
    /// <param name="eps">A small constant for numerical stability.</param>
    /// <param name="mode">Specify the dimension along which to compute L2 norm.</param>
    static member L2Normalization(data : NDArray, [<Optional; DefaultParameterValue(1.00000001E-10)>] eps : float, [<Optional>] mode : L2NormalizationMode) =
        let creator = AtomicSymbolCreator.FromName "L2Normalization"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle|]
                                                 [|"eps"; "mode"|]
                                                 [|string eps; (if isNull (mode :> obj) then "instance" else string mode)|]
        (new NDArray(outputs.[0]))
    /// <summary>Normalize the input array using the L2 norm.
    /// 
    /// For 1-D NDArray, it computes::
    /// 
    ///   out = data / sqrt(sum(data ** 2) + eps)
    /// 
    /// For N-D NDArray, if the input array has shape (N, N, ..., N),
    /// 
    /// with ``mode`` = ``instance``, it normalizes each instance in the multidimensional
    /// array by its L2 norm.::
    /// 
    ///   for i in 0...N
    ///     out[i,:,:,...,:] = data[i,:,:,...,:] / sqrt(sum(data[i,:,:,...,:] ** 2) + eps)
    /// 
    /// with ``mode`` = ``channel``, it normalizes each channel in the array by its L2 norm.::
    /// 
    ///   for i in 0...N
    ///     out[:,i,:,...,:] = data[:,i,:,...,:] / sqrt(sum(data[:,i,:,...,:] ** 2) + eps)
    /// 
    /// with ``mode`` = ``spatial``, it normalizes the cross channel norm for each position
    /// in the array by its L2 norm.::
    /// 
    ///   for dim in 2...N
    ///     for i in 0...N
    ///       out[.....,i,...] = take(out, indices=i, axis=dim) / sqrt(sum(take(out, indices=i, axis=dim) ** 2) + eps)
    ///           -dim-
    /// 
    /// Example::
    /// 
    ///   x = [[[1,2],
    ///         [3,4]],
    ///        [[2,2],
    ///         [5,6]]]
    /// 
    ///   L2Normalization(x, mode=&#39;instance&#39;)
    ///   =[[[ 0.18257418  0.36514837]
    ///      [ 0.54772252  0.73029673]]
    ///     [[ 0.24077171  0.24077171]
    ///      [ 0.60192931  0.72231513]]]
    /// 
    ///   L2Normalization(x, mode=&#39;channel&#39;)
    ///   =[[[ 0.31622776  0.44721359]
    ///      [ 0.94868326  0.89442718]]
    ///     [[ 0.37139067  0.31622776]
    ///      [ 0.92847669  0.94868326]]]
    /// 
    ///   L2Normalization(x, mode=&#39;spatial&#39;)
    ///   =[[[ 0.44721359  0.89442718]
    ///      [ 0.60000002  0.80000001]]
    ///     [[ 0.70710677  0.70710677]
    ///      [ 0.6401844   0.76822126]]]
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\l2_normalization.cc:L196</summary>
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="data">Input array to normalize.</param>
    /// <param name="eps">A small constant for numerical stability.</param>
    /// <param name="mode">Specify the dimension along which to compute L2 norm.</param>
    static member L2Normalization(outputArray : NDArray seq, data : NDArray, [<Optional; DefaultParameterValue(1.00000001E-10)>] eps : float, [<Optional>] mode : L2NormalizationMode) =
        let creator = AtomicSymbolCreator.FromName "L2Normalization"
        let names = [|"eps"; "mode"|]
        let vals = [|string eps; (if isNull (mode :> obj) then "instance" else string mode)|]
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <summary>Normalize the input array using the L2 norm.
    /// 
    /// For 1-D NDArray, it computes::
    /// 
    ///   out = data / sqrt(sum(data ** 2) + eps)
    /// 
    /// For N-D NDArray, if the input array has shape (N, N, ..., N),
    /// 
    /// with ``mode`` = ``instance``, it normalizes each instance in the multidimensional
    /// array by its L2 norm.::
    /// 
    ///   for i in 0...N
    ///     out[i,:,:,...,:] = data[i,:,:,...,:] / sqrt(sum(data[i,:,:,...,:] ** 2) + eps)
    /// 
    /// with ``mode`` = ``channel``, it normalizes each channel in the array by its L2 norm.::
    /// 
    ///   for i in 0...N
    ///     out[:,i,:,...,:] = data[:,i,:,...,:] / sqrt(sum(data[:,i,:,...,:] ** 2) + eps)
    /// 
    /// with ``mode`` = ``spatial``, it normalizes the cross channel norm for each position
    /// in the array by its L2 norm.::
    /// 
    ///   for dim in 2...N
    ///     for i in 0...N
    ///       out[.....,i,...] = take(out, indices=i, axis=dim) / sqrt(sum(take(out, indices=i, axis=dim) ** 2) + eps)
    ///           -dim-
    /// 
    /// Example::
    /// 
    ///   x = [[[1,2],
    ///         [3,4]],
    ///        [[2,2],
    ///         [5,6]]]
    /// 
    ///   L2Normalization(x, mode=&#39;instance&#39;)
    ///   =[[[ 0.18257418  0.36514837]
    ///      [ 0.54772252  0.73029673]]
    ///     [[ 0.24077171  0.24077171]
    ///      [ 0.60192931  0.72231513]]]
    /// 
    ///   L2Normalization(x, mode=&#39;channel&#39;)
    ///   =[[[ 0.31622776  0.44721359]
    ///      [ 0.94868326  0.89442718]]
    ///     [[ 0.37139067  0.31622776]
    ///      [ 0.92847669  0.94868326]]]
    /// 
    ///   L2Normalization(x, mode=&#39;spatial&#39;)
    ///   =[[[ 0.44721359  0.89442718]
    ///      [ 0.60000002  0.80000001]]
    ///     [[ 0.70710677  0.70710677]
    ///      [ 0.6401844   0.76822126]]]
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\l2_normalization.cc:L196</summary>
    /// <param name="data">Input array to normalize.</param>
    /// <param name="eps">A small constant for numerical stability.</param>
    /// <param name="mode">Specify the dimension along which to compute L2 norm.</param>
    static member L2Normalization([<Optional>] ?data : Symbol, [<Optional>] ?eps : float, [<Optional>] ?mode : L2NormalizationMode) =
        L2Normalization(?data = data, ?eps = eps, ?mode = mode)


    /// <summary>Make your own loss function in network construction.
    /// 
    /// This operator accepts a customized loss function symbol as a terminal loss and
    /// the symbol should be an operator with no backward dependency.
    /// The output of this function is the gradient of loss with respect to the input data.
    /// 
    /// For example, if you are a making a cross entropy loss function. Assume ``out`` is the
    /// predicted output and ``label`` is the true label, then the cross entropy can be defined as::
    /// 
    ///   cross_entropy = label * log(out) + (1 - label) * log(1 - out)
    ///   loss = MakeLoss(cross_entropy)
    /// 
    /// We will need to use ``MakeLoss`` when we are creating our own loss function or we want to
    /// combine multiple loss functions. Also we may want to stop some variables&#39; gradients
    /// from backpropagation. See more detail in ``BlockGrad`` or ``stop_gradient``.
    /// 
    /// In addition, we can give a scale to the loss by setting ``grad_scale``,
    /// so that the gradient of the loss will be rescaled in the backpropagation.
    /// 
    /// .. note:: This operator should be used as a Symbol instead of NDArray.
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\make_loss.cc:L71</summary>
    /// <param name="data">Input array.</param>
    /// <param name="gradScale">Gradient scale as a supplement to unary and binary operators</param>
    /// <param name="validThresh">clip each element in the array to 0 when it is less than ``valid_thresh``. This is used when ``normalization`` is set to ``&#39;valid&#39;``.</param>
    /// <param name="normalization">If this is set to null, the output gradient will not be normalized. If this is set to batch, the output gradient will be divided by the batch size. If this is set to valid, the output gradient will be divided by the number of valid input elements.</param>
    static member MakeLoss(data : NDArray, [<Optional; DefaultParameterValue(1.0)>] gradScale : float, [<Optional; DefaultParameterValue(0.0)>] validThresh : float, [<Optional>] normalization : Normalization) =
        let creator = AtomicSymbolCreator.FromName "MakeLoss"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle|]
                                                 [|"grad_scale"; "valid_thresh"; "normalization"|]
                                                 [|string gradScale; string validThresh; (if isNull (normalization :> obj) then "null" else string normalization)|]
        (new NDArray(outputs.[0]))
    /// <summary>Make your own loss function in network construction.
    /// 
    /// This operator accepts a customized loss function symbol as a terminal loss and
    /// the symbol should be an operator with no backward dependency.
    /// The output of this function is the gradient of loss with respect to the input data.
    /// 
    /// For example, if you are a making a cross entropy loss function. Assume ``out`` is the
    /// predicted output and ``label`` is the true label, then the cross entropy can be defined as::
    /// 
    ///   cross_entropy = label * log(out) + (1 - label) * log(1 - out)
    ///   loss = MakeLoss(cross_entropy)
    /// 
    /// We will need to use ``MakeLoss`` when we are creating our own loss function or we want to
    /// combine multiple loss functions. Also we may want to stop some variables&#39; gradients
    /// from backpropagation. See more detail in ``BlockGrad`` or ``stop_gradient``.
    /// 
    /// In addition, we can give a scale to the loss by setting ``grad_scale``,
    /// so that the gradient of the loss will be rescaled in the backpropagation.
    /// 
    /// .. note:: This operator should be used as a Symbol instead of NDArray.
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\make_loss.cc:L71</summary>
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="data">Input array.</param>
    /// <param name="gradScale">Gradient scale as a supplement to unary and binary operators</param>
    /// <param name="validThresh">clip each element in the array to 0 when it is less than ``valid_thresh``. This is used when ``normalization`` is set to ``&#39;valid&#39;``.</param>
    /// <param name="normalization">If this is set to null, the output gradient will not be normalized. If this is set to batch, the output gradient will be divided by the batch size. If this is set to valid, the output gradient will be divided by the number of valid input elements.</param>
    static member MakeLoss(outputArray : NDArray seq, data : NDArray, [<Optional; DefaultParameterValue(1.0)>] gradScale : float, [<Optional; DefaultParameterValue(0.0)>] validThresh : float, [<Optional>] normalization : Normalization) =
        let creator = AtomicSymbolCreator.FromName "MakeLoss"
        let names = [|"grad_scale"; "valid_thresh"; "normalization"|]
        let vals = [|string gradScale; string validThresh; (if isNull (normalization :> obj) then "null" else string normalization)|]
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <summary>Make your own loss function in network construction.
    /// 
    /// This operator accepts a customized loss function symbol as a terminal loss and
    /// the symbol should be an operator with no backward dependency.
    /// The output of this function is the gradient of loss with respect to the input data.
    /// 
    /// For example, if you are a making a cross entropy loss function. Assume ``out`` is the
    /// predicted output and ``label`` is the true label, then the cross entropy can be defined as::
    /// 
    ///   cross_entropy = label * log(out) + (1 - label) * log(1 - out)
    ///   loss = MakeLoss(cross_entropy)
    /// 
    /// We will need to use ``MakeLoss`` when we are creating our own loss function or we want to
    /// combine multiple loss functions. Also we may want to stop some variables&#39; gradients
    /// from backpropagation. See more detail in ``BlockGrad`` or ``stop_gradient``.
    /// 
    /// In addition, we can give a scale to the loss by setting ``grad_scale``,
    /// so that the gradient of the loss will be rescaled in the backpropagation.
    /// 
    /// .. note:: This operator should be used as a Symbol instead of NDArray.
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\make_loss.cc:L71</summary>
    /// <param name="data">Input array.</param>
    /// <param name="gradScale">Gradient scale as a supplement to unary and binary operators</param>
    /// <param name="validThresh">clip each element in the array to 0 when it is less than ``valid_thresh``. This is used when ``normalization`` is set to ``&#39;valid&#39;``.</param>
    /// <param name="normalization">If this is set to null, the output gradient will not be normalized. If this is set to batch, the output gradient will be divided by the batch size. If this is set to valid, the output gradient will be divided by the number of valid input elements.</param>
    static member MakeLoss([<Optional>] ?data : Symbol, [<Optional>] ?gradScale : float, [<Optional>] ?validThresh : float, [<Optional>] ?normalization : Normalization) =
        MakeLoss(?data = data, ?gradScale = gradScale, ?validThresh = validThresh, ?normalization = normalization)





    /// <summary>Takes the last element of a sequence.
    /// 
    /// This function takes an n-dimensional input array of the form
    /// [max_sequence_length, batch_size, other_feature_dims] and returns a (n-1)-dimensional array
    /// of the form [batch_size, other_feature_dims].
    /// 
    /// Parameter `sequence_length` is used to handle variable-length sequences. `sequence_length` should be
    /// an input array of positive ints of dimension [batch_size]. To use this parameter,
    /// set `use_sequence_length` to `True`, otherwise each example in the batch is assumed
    /// to have the max sequence length.
    /// 
    /// .. note:: Alternatively, you can also use `take` operator.
    /// 
    /// Example::
    /// 
    ///    x = [[[  1.,   2.,   3.],
    ///          [  4.,   5.,   6.],
    ///          [  7.,   8.,   9.]],
    /// 
    ///         [[ 10.,   11.,   12.],
    ///          [ 13.,   14.,   15.],
    ///          [ 16.,   17.,   18.]],
    /// 
    ///         [[  19.,   20.,   21.],
    ///          [  22.,   23.,   24.],
    ///          [  25.,   26.,   27.]]]
    /// 
    ///    // returns last sequence when sequence_length parameter is not used
    ///    SequenceLast(x) = [[  19.,   20.,   21.],
    ///                       [  22.,   23.,   24.],
    ///                       [  25.,   26.,   27.]]
    /// 
    ///    // sequence_length is used
    ///    SequenceLast(x, sequence_length=[1,1,1], use_sequence_length=True) =
    ///             [[  1.,   2.,   3.],
    ///              [  4.,   5.,   6.],
    ///              [  7.,   8.,   9.]]
    /// 
    ///    // sequence_length is used
    ///    SequenceLast(x, sequence_length=[1,2,3], use_sequence_length=True) =
    ///             [[  1.,    2.,   3.],
    ///              [  13.,  14.,  15.],
    ///              [  25.,  26.,  27.]]
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\sequence_last.cc:L106</summary>
    /// <param name="data">n-dimensional input array of the form [max_sequence_length, batch_size, other_feature_dims] where n&gt;2</param>
    /// <param name="sequenceLength">vector of sequence lengths of the form [batch_size]</param>
    /// <param name="useSequenceLength">If set to true, this layer takes in an extra input parameter `sequence_length` to specify variable length sequence</param>
    /// <param name="axis">The sequence axis. Only values of 0 and 1 are currently supported.</param>
    static member SequenceLast(data : NDArray, sequenceLength : NDArray, [<Optional; DefaultParameterValue(false)>] useSequenceLength : bool, [<Optional; DefaultParameterValue(0)>] axis : int) =
        let creator = AtomicSymbolCreator.FromName "SequenceLast"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg sequenceLength)) then sequenceLength.UnsafeHandle|]
                                                 [|"use_sequence_length"; "axis"|]
                                                 [|string useSequenceLength; string axis|]
        (new NDArray(outputs.[0]))
    /// <summary>Takes the last element of a sequence.
    /// 
    /// This function takes an n-dimensional input array of the form
    /// [max_sequence_length, batch_size, other_feature_dims] and returns a (n-1)-dimensional array
    /// of the form [batch_size, other_feature_dims].
    /// 
    /// Parameter `sequence_length` is used to handle variable-length sequences. `sequence_length` should be
    /// an input array of positive ints of dimension [batch_size]. To use this parameter,
    /// set `use_sequence_length` to `True`, otherwise each example in the batch is assumed
    /// to have the max sequence length.
    /// 
    /// .. note:: Alternatively, you can also use `take` operator.
    /// 
    /// Example::
    /// 
    ///    x = [[[  1.,   2.,   3.],
    ///          [  4.,   5.,   6.],
    ///          [  7.,   8.,   9.]],
    /// 
    ///         [[ 10.,   11.,   12.],
    ///          [ 13.,   14.,   15.],
    ///          [ 16.,   17.,   18.]],
    /// 
    ///         [[  19.,   20.,   21.],
    ///          [  22.,   23.,   24.],
    ///          [  25.,   26.,   27.]]]
    /// 
    ///    // returns last sequence when sequence_length parameter is not used
    ///    SequenceLast(x) = [[  19.,   20.,   21.],
    ///                       [  22.,   23.,   24.],
    ///                       [  25.,   26.,   27.]]
    /// 
    ///    // sequence_length is used
    ///    SequenceLast(x, sequence_length=[1,1,1], use_sequence_length=True) =
    ///             [[  1.,   2.,   3.],
    ///              [  4.,   5.,   6.],
    ///              [  7.,   8.,   9.]]
    /// 
    ///    // sequence_length is used
    ///    SequenceLast(x, sequence_length=[1,2,3], use_sequence_length=True) =
    ///             [[  1.,    2.,   3.],
    ///              [  13.,  14.,  15.],
    ///              [  25.,  26.,  27.]]
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\sequence_last.cc:L106</summary>
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="data">n-dimensional input array of the form [max_sequence_length, batch_size, other_feature_dims] where n&gt;2</param>
    /// <param name="sequenceLength">vector of sequence lengths of the form [batch_size]</param>
    /// <param name="useSequenceLength">If set to true, this layer takes in an extra input parameter `sequence_length` to specify variable length sequence</param>
    /// <param name="axis">The sequence axis. Only values of 0 and 1 are currently supported.</param>
    static member SequenceLast(outputArray : NDArray seq, data : NDArray, sequenceLength : NDArray, [<Optional; DefaultParameterValue(false)>] useSequenceLength : bool, [<Optional; DefaultParameterValue(0)>] axis : int) =
        let creator = AtomicSymbolCreator.FromName "SequenceLast"
        let names = [|"use_sequence_length"; "axis"|]
        let vals = [|string useSequenceLength; string axis|]
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg sequenceLength)) then sequenceLength.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <summary>Takes the last element of a sequence.
    /// 
    /// This function takes an n-dimensional input array of the form
    /// [max_sequence_length, batch_size, other_feature_dims] and returns a (n-1)-dimensional array
    /// of the form [batch_size, other_feature_dims].
    /// 
    /// Parameter `sequence_length` is used to handle variable-length sequences. `sequence_length` should be
    /// an input array of positive ints of dimension [batch_size]. To use this parameter,
    /// set `use_sequence_length` to `True`, otherwise each example in the batch is assumed
    /// to have the max sequence length.
    /// 
    /// .. note:: Alternatively, you can also use `take` operator.
    /// 
    /// Example::
    /// 
    ///    x = [[[  1.,   2.,   3.],
    ///          [  4.,   5.,   6.],
    ///          [  7.,   8.,   9.]],
    /// 
    ///         [[ 10.,   11.,   12.],
    ///          [ 13.,   14.,   15.],
    ///          [ 16.,   17.,   18.]],
    /// 
    ///         [[  19.,   20.,   21.],
    ///          [  22.,   23.,   24.],
    ///          [  25.,   26.,   27.]]]
    /// 
    ///    // returns last sequence when sequence_length parameter is not used
    ///    SequenceLast(x) = [[  19.,   20.,   21.],
    ///                       [  22.,   23.,   24.],
    ///                       [  25.,   26.,   27.]]
    /// 
    ///    // sequence_length is used
    ///    SequenceLast(x, sequence_length=[1,1,1], use_sequence_length=True) =
    ///             [[  1.,   2.,   3.],
    ///              [  4.,   5.,   6.],
    ///              [  7.,   8.,   9.]]
    /// 
    ///    // sequence_length is used
    ///    SequenceLast(x, sequence_length=[1,2,3], use_sequence_length=True) =
    ///             [[  1.,    2.,   3.],
    ///              [  13.,  14.,  15.],
    ///              [  25.,  26.,  27.]]
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\sequence_last.cc:L106</summary>
    /// <param name="data">n-dimensional input array of the form [max_sequence_length, batch_size, other_feature_dims] where n&gt;2</param>
    /// <param name="sequenceLength">vector of sequence lengths of the form [batch_size]</param>
    /// <param name="useSequenceLength">If set to true, this layer takes in an extra input parameter `sequence_length` to specify variable length sequence</param>
    /// <param name="axis">The sequence axis. Only values of 0 and 1 are currently supported.</param>
    static member SequenceLast([<Optional>] ?data : Symbol, [<Optional>] ?sequenceLength : Symbol, [<Optional>] ?useSequenceLength : bool, [<Optional>] ?axis : int) =
        SequenceLast(?data = data, ?sequenceLength = sequenceLength, ?useSequenceLength = useSequenceLength, ?axis = axis)



    /// <summary>Reverses the elements of each sequence.
    /// 
    /// This function takes an n-dimensional input array of the form [max_sequence_length, batch_size, other_feature_dims]
    /// and returns an array of the same shape.
    /// 
    /// Parameter `sequence_length` is used to handle variable-length sequences.
    /// `sequence_length` should be an input array of positive ints of dimension [batch_size].
    /// To use this parameter, set `use_sequence_length` to `True`,
    /// otherwise each example in the batch is assumed to have the max sequence length.
    /// 
    /// Example::
    /// 
    ///    x = [[[  1.,   2.,   3.],
    ///          [  4.,   5.,   6.]],
    /// 
    ///         [[  7.,   8.,   9.],
    ///          [ 10.,  11.,  12.]],
    /// 
    ///         [[ 13.,  14.,   15.],
    ///          [ 16.,  17.,   18.]]]
    /// 
    ///    // Batch 1
    ///    B1 = [[  1.,   2.,   3.],
    ///          [  7.,   8.,   9.],
    ///          [ 13.,  14.,  15.]]
    /// 
    ///    // Batch 2
    ///    B2 = [[  4.,   5.,   6.],
    ///          [ 10.,  11.,  12.],
    ///          [ 16.,  17.,  18.]]
    /// 
    ///    // returns reverse sequence when sequence_length parameter is not used
    ///    SequenceReverse(x) = [[[ 13.,  14.,   15.],
    ///                           [ 16.,  17.,   18.]],
    /// 
    ///                          [[  7.,   8.,   9.],
    ///                           [ 10.,  11.,  12.]],
    /// 
    ///                          [[  1.,   2.,   3.],
    ///                           [  4.,   5.,   6.]]]
    /// 
    ///    // sequence_length [2,2] means 2 rows of
    ///    // both batch B1 and B2 will be reversed.
    ///    SequenceReverse(x, sequence_length=[2,2], use_sequence_length=True) =
    ///                      [[[  7.,   8.,   9.],
    ///                        [ 10.,  11.,  12.]],
    /// 
    ///                       [[  1.,   2.,   3.],
    ///                        [  4.,   5.,   6.]],
    /// 
    ///                       [[ 13.,  14.,   15.],
    ///                        [ 16.,  17.,   18.]]]
    /// 
    ///    // sequence_length [2,3] means 2 of batch B2 and 3 of batch B3
    ///    // will be reversed.
    ///    SequenceReverse(x, sequence_length=[2,3], use_sequence_length=True) =
    ///                     [[[  7.,   8.,   9.],
    ///                       [ 16.,  17.,  18.]],
    /// 
    ///                      [[  1.,   2.,   3.],
    ///                       [ 10.,  11.,  12.]],
    /// 
    ///                      [[ 13.,  14,   15.],
    ///                       [  4.,   5.,   6.]]]
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\sequence_reverse.cc:L122</summary>
    /// <param name="data">n-dimensional input array of the form [max_sequence_length, batch_size, other dims] where n&gt;2 </param>
    /// <param name="sequenceLength">vector of sequence lengths of the form [batch_size]</param>
    /// <param name="useSequenceLength">If set to true, this layer takes in an extra input parameter `sequence_length` to specify variable length sequence</param>
    /// <param name="axis">The sequence axis. Only 0 is currently supported.</param>
    static member SequenceReverse(data : NDArray, sequenceLength : NDArray, [<Optional; DefaultParameterValue(false)>] useSequenceLength : bool, [<Optional; DefaultParameterValue(0)>] axis : int) =
        let creator = AtomicSymbolCreator.FromName "SequenceReverse"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg sequenceLength)) then sequenceLength.UnsafeHandle|]
                                                 [|"use_sequence_length"; "axis"|]
                                                 [|string useSequenceLength; string axis|]
        (new NDArray(outputs.[0]))
    /// <summary>Reverses the elements of each sequence.
    /// 
    /// This function takes an n-dimensional input array of the form [max_sequence_length, batch_size, other_feature_dims]
    /// and returns an array of the same shape.
    /// 
    /// Parameter `sequence_length` is used to handle variable-length sequences.
    /// `sequence_length` should be an input array of positive ints of dimension [batch_size].
    /// To use this parameter, set `use_sequence_length` to `True`,
    /// otherwise each example in the batch is assumed to have the max sequence length.
    /// 
    /// Example::
    /// 
    ///    x = [[[  1.,   2.,   3.],
    ///          [  4.,   5.,   6.]],
    /// 
    ///         [[  7.,   8.,   9.],
    ///          [ 10.,  11.,  12.]],
    /// 
    ///         [[ 13.,  14.,   15.],
    ///          [ 16.,  17.,   18.]]]
    /// 
    ///    // Batch 1
    ///    B1 = [[  1.,   2.,   3.],
    ///          [  7.,   8.,   9.],
    ///          [ 13.,  14.,  15.]]
    /// 
    ///    // Batch 2
    ///    B2 = [[  4.,   5.,   6.],
    ///          [ 10.,  11.,  12.],
    ///          [ 16.,  17.,  18.]]
    /// 
    ///    // returns reverse sequence when sequence_length parameter is not used
    ///    SequenceReverse(x) = [[[ 13.,  14.,   15.],
    ///                           [ 16.,  17.,   18.]],
    /// 
    ///                          [[  7.,   8.,   9.],
    ///                           [ 10.,  11.,  12.]],
    /// 
    ///                          [[  1.,   2.,   3.],
    ///                           [  4.,   5.,   6.]]]
    /// 
    ///    // sequence_length [2,2] means 2 rows of
    ///    // both batch B1 and B2 will be reversed.
    ///    SequenceReverse(x, sequence_length=[2,2], use_sequence_length=True) =
    ///                      [[[  7.,   8.,   9.],
    ///                        [ 10.,  11.,  12.]],
    /// 
    ///                       [[  1.,   2.,   3.],
    ///                        [  4.,   5.,   6.]],
    /// 
    ///                       [[ 13.,  14.,   15.],
    ///                        [ 16.,  17.,   18.]]]
    /// 
    ///    // sequence_length [2,3] means 2 of batch B2 and 3 of batch B3
    ///    // will be reversed.
    ///    SequenceReverse(x, sequence_length=[2,3], use_sequence_length=True) =
    ///                     [[[  7.,   8.,   9.],
    ///                       [ 16.,  17.,  18.]],
    /// 
    ///                      [[  1.,   2.,   3.],
    ///                       [ 10.,  11.,  12.]],
    /// 
    ///                      [[ 13.,  14,   15.],
    ///                       [  4.,   5.,   6.]]]
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\sequence_reverse.cc:L122</summary>
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="data">n-dimensional input array of the form [max_sequence_length, batch_size, other dims] where n&gt;2 </param>
    /// <param name="sequenceLength">vector of sequence lengths of the form [batch_size]</param>
    /// <param name="useSequenceLength">If set to true, this layer takes in an extra input parameter `sequence_length` to specify variable length sequence</param>
    /// <param name="axis">The sequence axis. Only 0 is currently supported.</param>
    static member SequenceReverse(outputArray : NDArray seq, data : NDArray, sequenceLength : NDArray, [<Optional; DefaultParameterValue(false)>] useSequenceLength : bool, [<Optional; DefaultParameterValue(0)>] axis : int) =
        let creator = AtomicSymbolCreator.FromName "SequenceReverse"
        let names = [|"use_sequence_length"; "axis"|]
        let vals = [|string useSequenceLength; string axis|]
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg sequenceLength)) then sequenceLength.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <summary>Reverses the elements of each sequence.
    /// 
    /// This function takes an n-dimensional input array of the form [max_sequence_length, batch_size, other_feature_dims]
    /// and returns an array of the same shape.
    /// 
    /// Parameter `sequence_length` is used to handle variable-length sequences.
    /// `sequence_length` should be an input array of positive ints of dimension [batch_size].
    /// To use this parameter, set `use_sequence_length` to `True`,
    /// otherwise each example in the batch is assumed to have the max sequence length.
    /// 
    /// Example::
    /// 
    ///    x = [[[  1.,   2.,   3.],
    ///          [  4.,   5.,   6.]],
    /// 
    ///         [[  7.,   8.,   9.],
    ///          [ 10.,  11.,  12.]],
    /// 
    ///         [[ 13.,  14.,   15.],
    ///          [ 16.,  17.,   18.]]]
    /// 
    ///    // Batch 1
    ///    B1 = [[  1.,   2.,   3.],
    ///          [  7.,   8.,   9.],
    ///          [ 13.,  14.,  15.]]
    /// 
    ///    // Batch 2
    ///    B2 = [[  4.,   5.,   6.],
    ///          [ 10.,  11.,  12.],
    ///          [ 16.,  17.,  18.]]
    /// 
    ///    // returns reverse sequence when sequence_length parameter is not used
    ///    SequenceReverse(x) = [[[ 13.,  14.,   15.],
    ///                           [ 16.,  17.,   18.]],
    /// 
    ///                          [[  7.,   8.,   9.],
    ///                           [ 10.,  11.,  12.]],
    /// 
    ///                          [[  1.,   2.,   3.],
    ///                           [  4.,   5.,   6.]]]
    /// 
    ///    // sequence_length [2,2] means 2 rows of
    ///    // both batch B1 and B2 will be reversed.
    ///    SequenceReverse(x, sequence_length=[2,2], use_sequence_length=True) =
    ///                      [[[  7.,   8.,   9.],
    ///                        [ 10.,  11.,  12.]],
    /// 
    ///                       [[  1.,   2.,   3.],
    ///                        [  4.,   5.,   6.]],
    /// 
    ///                       [[ 13.,  14.,   15.],
    ///                        [ 16.,  17.,   18.]]]
    /// 
    ///    // sequence_length [2,3] means 2 of batch B2 and 3 of batch B3
    ///    // will be reversed.
    ///    SequenceReverse(x, sequence_length=[2,3], use_sequence_length=True) =
    ///                     [[[  7.,   8.,   9.],
    ///                       [ 16.,  17.,  18.]],
    /// 
    ///                      [[  1.,   2.,   3.],
    ///                       [ 10.,  11.,  12.]],
    /// 
    ///                      [[ 13.,  14,   15.],
    ///                       [  4.,   5.,   6.]]]
    /// 
    /// 
    /// 
    /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\sequence_reverse.cc:L122</summary>
    /// <param name="data">n-dimensional input array of the form [max_sequence_length, batch_size, other dims] where n&gt;2 </param>
    /// <param name="sequenceLength">vector of sequence lengths of the form [batch_size]</param>
    /// <param name="useSequenceLength">If set to true, this layer takes in an extra input parameter `sequence_length` to specify variable length sequence</param>
    /// <param name="axis">The sequence axis. Only 0 is currently supported.</param>
    static member SequenceReverse([<Optional>] ?data : Symbol, [<Optional>] ?sequenceLength : Symbol, [<Optional>] ?useSequenceLength : bool, [<Optional>] ?axis : int) =
        SequenceReverse(?data = data, ?sequenceLength = sequenceLength, ?useSequenceLength = useSequenceLength, ?axis = axis)



    /// <summary>Applies a spatial transformer to input feature map.</summary>
    /// <param name="data">Input data to the SpatialTransformerOp.</param>
    /// <param name="loc">localisation net, the output dim should be 6 when transform_type is affine. You shold initialize the weight and bias with identity tranform.</param>
    /// <param name="transformType">transformation type</param>
    /// <param name="samplerType">sampling type</param>
    /// <param name="targetShape">output shape(h, w) of spatial transformer: (y, x)</param>
    /// <param name="cudnnOff">whether to turn cudnn off</param>
    static member SpatialTransformer(data : NDArray, loc : NDArray, [<Optional>] ?targetShape : int seq, [<Optional>] ?cudnnOff : bool) =
        let creator = AtomicSymbolCreator.FromName "SpatialTransformer"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg loc)) then loc.UnsafeHandle|]
                                                 [|"transform_type"; "sampler_type"; "target_shape"; "cudnn_off"|]
                                                 [|"affine"; "bilinear"; (match targetShape with None -> "[0,0]" | Some targetShape -> (targetShape |> Seq.map string |> String.concat ", " |> sprintf "[%s]")); (match cudnnOff with None -> "None" | Some cudnnOff -> string cudnnOff)|]
        outputs |> Array.map (fun h -> new NDArray(h))
    /// <summary>Applies a spatial transformer to input feature map.</summary>
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="data">Input data to the SpatialTransformerOp.</param>
    /// <param name="loc">localisation net, the output dim should be 6 when transform_type is affine. You shold initialize the weight and bias with identity tranform.</param>
    /// <param name="transformType">transformation type</param>
    /// <param name="samplerType">sampling type</param>
    /// <param name="targetShape">output shape(h, w) of spatial transformer: (y, x)</param>
    /// <param name="cudnnOff">whether to turn cudnn off</param>
    static member SpatialTransformer(outputArray : NDArray seq, data : NDArray, loc : NDArray, [<Optional>] ?targetShape : int seq, [<Optional>] ?cudnnOff : bool) =
        let creator = AtomicSymbolCreator.FromName "SpatialTransformer"
        let names = [|"transform_type"; "sampler_type"; "target_shape"; "cudnn_off"|]
        let vals = [|"affine"; "bilinear"; (match targetShape with None -> "[0,0]" | Some targetShape -> (targetShape |> Seq.map string |> String.concat ", " |> sprintf "[%s]")); (match cudnnOff with None -> "None" | Some cudnnOff -> string cudnnOff)|]
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg loc)) then loc.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <summary>Applies a spatial transformer to input feature map.</summary>
    /// <param name="data">Input data to the SpatialTransformerOp.</param>
    /// <param name="loc">localisation net, the output dim should be 6 when transform_type is affine. You shold initialize the weight and bias with identity tranform.</param>
    /// <param name="transformType">transformation type</param>
    /// <param name="samplerType">sampling type</param>
    /// <param name="targetShape">output shape(h, w) of spatial transformer: (y, x)</param>
    /// <param name="cudnnOff">whether to turn cudnn off</param>
    static member SpatialTransformer(data : Symbol, loc : Symbol, transformType : SpatialTransformerTransformType, samplerType : SamplerType, [<Optional>] ?targetShape : int seq, [<Optional>] ?cudnnOff : bool) =
        SpatialTransformer(data, loc, transformType, samplerType, ?targetShape = targetShape, ?cudnnOff = cudnnOff)
    /// <summary>Applies a spatial transformer to input feature map.</summary>
    /// <param name="transformType">transformation type</param>
    /// <param name="samplerType">sampling type</param>
    /// <param name="data">Input data to the SpatialTransformerOp.</param>
    /// <param name="loc">localisation net, the output dim should be 6 when transform_type is affine. You shold initialize the weight and bias with identity tranform.</param>
    /// <param name="targetShape">output shape(h, w) of spatial transformer: (y, x)</param>
    /// <param name="cudnnOff">whether to turn cudnn off</param>
    static member SpatialTransformer(transformType : SpatialTransformerTransformType, samplerType : SamplerType, [<Optional>] ?data : Symbol, [<Optional>] ?loc : Symbol, [<Optional>] ?targetShape : int seq, [<Optional>] ?cudnnOff : bool) =
        SpatialTransformer(transformType, samplerType, ?data = data, ?loc = loc, ?targetShape = targetShape, ?cudnnOff = cudnnOff)


    /// <summary>Computes support vector machine based transformation of the input.
    /// 
    /// This tutorial demonstrates using SVM as output layer for classification instead of softmax:
    /// https://github.com/dmlc/mxnet/tree/master/example/svm_mnist.
    /// 
    /// </summary>
    /// <param name="data">Input data for SVM transformation.</param>
    /// <param name="label">Class label for the input data.</param>
    /// <param name="margin">The loss function penalizes outputs that lie outside this margin. Default margin is 1.</param>
    /// <param name="regularizationCoefficient">Regularization parameter for the SVM. This balances the tradeoff between coefficient size and error.</param>
    /// <param name="useLinear">Whether to use L1-SVM objective. L2-SVM objective is used by default.</param>
    static member SVMOutput(data : NDArray, 
                            label : NDArray, 
                            [<Optional; DefaultParameterValue(1.0)>] margin : float, 
                            [<Optional; DefaultParameterValue(1.0)>] regularizationCoefficient : float, 
                            [<Optional; DefaultParameterValue(false)>] useLinear : bool) =
        let creator = AtomicSymbolCreator.FromName "SVMOutput"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg label)) then label.UnsafeHandle|]
                                                 [|"margin"; "regularization_coefficient"; "use_linear"|]
                                                 [|string margin; string regularizationCoefficient; string useLinear|]
        (new NDArray(outputs.[0]))
    /// <summary>Computes support vector machine based transformation of the input.
    /// 
    /// This tutorial demonstrates using SVM as output layer for classification instead of softmax:
    /// https://github.com/dmlc/mxnet/tree/master/example/svm_mnist.
    /// 
    /// </summary>
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="data">Input data for SVM transformation.</param>
    /// <param name="label">Class label for the input data.</param>
    /// <param name="margin">The loss function penalizes outputs that lie outside this margin. Default margin is 1.</param>
    /// <param name="regularizationCoefficient">Regularization parameter for the SVM. This balances the tradeoff between coefficient size and error.</param>
    /// <param name="useLinear">Whether to use L1-SVM objective. L2-SVM objective is used by default.</param>
    static member SVMOutput(outputArray : NDArray seq, 
                            data : NDArray, 
                            label : NDArray, 
                            [<Optional; DefaultParameterValue(1.0)>] margin : float, 
                            [<Optional; DefaultParameterValue(1.0)>] regularizationCoefficient : float, 
                            [<Optional; DefaultParameterValue(false)>] useLinear : bool) =
        let creator = AtomicSymbolCreator.FromName "SVMOutput"
        let names = [|"margin"; "regularization_coefficient"; "use_linear"|]
        let vals = [|string margin; string regularizationCoefficient; string useLinear|]
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg label)) then label.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <summary>Computes support vector machine based transformation of the input.
    /// 
    /// This tutorial demonstrates using SVM as output layer for classification instead of softmax:
    /// https://github.com/dmlc/mxnet/tree/master/example/svm_mnist.
    /// 
    /// </summary>
    /// <param name="data">Input data for SVM transformation.</param>
    /// <param name="label">Class label for the input data.</param>
    /// <param name="margin">The loss function penalizes outputs that lie outside this margin. Default margin is 1.</param>
    /// <param name="regularizationCoefficient">Regularization parameter for the SVM. This balances the tradeoff between coefficient size and error.</param>
    /// <param name="useLinear">Whether to use L1-SVM objective. L2-SVM objective is used by default.</param>
    static member SVMOutput([<Optional>] ?data : Symbol, [<Optional>] ?label : Symbol, [<Optional>] ?margin : float, [<Optional>] ?regularizationCoefficient : float, [<Optional>] ?useLinear : bool) =
        SVMOutput(?data = data, ?label = label, ?margin = margin, ?regularizationCoefficient = regularizationCoefficient, ?useLinear = useLinear)



    /// <param name="src">Source input to the function.</param>
    static member SetValueNDArray(src : double) =
        let creator = AtomicSymbolCreator.FromName "_set_value"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 Array.empty
                                                 [|"src"|]
                                                 [|string src|]
        outputs |> Array.map (fun h -> new NDArray(h))
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="src">Source input to the function.</param>
    static member SetValue(outputArray : NDArray seq, src : double) =
        let creator = AtomicSymbolCreator.FromName "_set_value"
        let names = [|"src"|]
        let vals = [|string src|]
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     Array.empty
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <param name="src">Source input to the function.</param>
    static member SetValue(src : double) =
        SetValue(src)

    /// <param name="lhs">Left operand to the function.</param>
    /// <param name="rhs">Right operand to the function.</param>
    static member OnehotEncode(lhs : NDArray, rhs : NDArray) =
        let creator = AtomicSymbolCreator.FromName "_onehot_encode"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg lhs)) then lhs.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg rhs)) then rhs.UnsafeHandle|]
                                                 Array.empty
                                                 Array.empty
        outputs |> Array.map (fun h -> new NDArray(h))
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="lhs">Left operand to the function.</param>
    /// <param name="rhs">Right operand to the function.</param>
    static member OnehotEncode(outputArray : NDArray seq, lhs : NDArray, rhs : NDArray) =
        let creator = AtomicSymbolCreator.FromName "_onehot_encode"
        let names = Array.empty
        let vals = Array.empty
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg lhs)) then lhs.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg rhs)) then rhs.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()

    /// <summary>Fill one element of each line(row for python, column for R/Julia) in lhs according to index indicated by rhs and values indicated by mhs. This function assume rhs uses 0-based index.</summary>
    /// <param name="lhs">Left operand to the function.</param>
    /// <param name="mhs">Middle operand to the function.</param>
    /// <param name="rhs">Right operand to the function.</param>
    static member FillElement0index(lhs : NDArray, mhs : NDArray, rhs : NDArray) =
        let creator = AtomicSymbolCreator.FromName "fill_element_0index"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg lhs)) then lhs.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg mhs)) then mhs.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg rhs)) then rhs.UnsafeHandle|]
                                                 Array.empty
                                                 Array.empty
        outputs |> Array.map (fun h -> new NDArray(h))
    /// <summary>Fill one element of each line(row for python, column for R/Julia) in lhs according to index indicated by rhs and values indicated by mhs. This function assume rhs uses 0-based index.</summary>
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="lhs">Left operand to the function.</param>
    /// <param name="mhs">Middle operand to the function.</param>
    /// <param name="rhs">Right operand to the function.</param>
    static member FillElement0index(outputArray : NDArray seq, lhs : NDArray, mhs : NDArray, rhs : NDArray) =
        let creator = AtomicSymbolCreator.FromName "fill_element_0index"
        let names = Array.empty
        let vals = Array.empty
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg lhs)) then lhs.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg mhs)) then mhs.UnsafeHandle; if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg rhs)) then rhs.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()

    /// <summary>Decode an image, clip to (x0, y0, x1, y1), subtract mean, and write to buffer</summary>
    /// <param name="mean">image mean</param>
    /// <param name="index">buffer position for output</param>
    /// <param name="x0">x0</param>
    /// <param name="y0">y0</param>
    /// <param name="x1">x1</param>
    /// <param name="y1">y1</param>
    /// <param name="c">channel</param>
    /// <param name="size">length of str_img</param>
    static member Imdecode(mean : NDArray, 
                           index : int, 
                           x0 : int, 
                           y0 : int, 
                           x1 : int, 
                           y1 : int, 
                           c : int, 
                           size : int) =
        let creator = AtomicSymbolCreator.FromName "_imdecode"
        let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
                                                 [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg mean)) then mean.UnsafeHandle|]
                                                 [|"index"; "x0"; "y0"; "x1"; "y1"; "c"; "size"|]
                                                 [|string index; string x0; string y0; string x1; string y1; string c; string size|]
        outputs |> Array.map (fun h -> new NDArray(h))
    /// <summary>Decode an image, clip to (x0, y0, x1, y1), subtract mean, and write to buffer</summary>
    /// <param name = "outputArray">Array of NDArray for outputs</param>
    /// <param name="mean">image mean</param>
    /// <param name="index">buffer position for output</param>
    /// <param name="x0">x0</param>
    /// <param name="y0">y0</param>
    /// <param name="x1">x1</param>
    /// <param name="y1">y1</param>
    /// <param name="c">channel</param>
    /// <param name="size">length of str_img</param>
    static member Imdecode(outputArray : NDArray seq, 
                           mean : NDArray, 
                           index : int, 
                           x0 : int, 
                           y0 : int, 
                           x1 : int, 
                           y1 : int, 
                           c : int, 
                           size : int) =
        let creator = AtomicSymbolCreator.FromName "_imdecode"
        let names = [|"index"; "x0"; "y0"; "x1"; "y1"; "c"; "size"|]
        let vals = [|string index; string x0; string y0; string x1; string y1; string c; string size|]
        let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
        let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
                                                     [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg mean)) then mean.UnsafeHandle|]
                                                     (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
                                                     names
                                                     vals
        ()
    /// <summary>Decode an image, clip to (x0, y0, x1, y1), subtract mean, and write to buffer</summary>
    /// <param name="mean">image mean</param>
    /// <param name="index">buffer position for output</param>
    /// <param name="x0">x0</param>
    /// <param name="y0">y0</param>
    /// <param name="x1">x1</param>
    /// <param name="y1">y1</param>
    /// <param name="c">channel</param>
    /// <param name="size">length of str_img</param>
    static member Imdecode(mean : Symbol, index : int, x0 : int, y0 : int, x1 : int, y1 : int, c : int, size : int) =
        Imdecode(mean, index, x0, y0, x1, y1, c, size)
    /// <summary>Decode an image, clip to (x0, y0, x1, y1), subtract mean, and write to buffer</summary>
    /// <param name="index">buffer position for output</param>
    /// <param name="x0">x0</param>
    /// <param name="y0">y0</param>
    /// <param name="x1">x1</param>
    /// <param name="y1">y1</param>
    /// <param name="c">channel</param>
    /// <param name="size">length of str_img</param>
    /// <param name="mean">image mean</param>
    static member Imdecode(index : int, x0 : int, y0 : int, x1 : int, y1 : int, c : int, size : int, [<Optional>] ?mean : Symbol) =
        Imdecode(index, x0, y0, x1, y1, c, size, ?mean = mean)
//     /// <summary>
//     /// 
//     /// .. note:: `Crop` is deprecated. Use `slice` instead.
//     /// 
//     /// Crop the 2nd and 3rd dim of input data, with the corresponding size of h_w or
//     /// with width and height of the second input symbol, i.e., with one input, we need h_w to
//     /// specify the crop height and width, otherwise the second input symbol&#39;s size will be used
//     /// 
//     /// 
//     /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\crop.cc:L50</summary>
//     /// <param name="data">Tensor or List of Tensors, the second input will be used as crop_like shape reference</param>
//     /// <param name="numArgs">Number of inputs for crop, if equals one, then we will use the h_wfor crop height and width, else if equals two, then we will use the heightand width of the second input symbol, we name crop_like here</param>
//     /// <param name="offset">crop offset coordinate: (y, x)</param>
//     /// <param name="hW">crop height and width: (h, w)</param>
//     /// <param name="centerCrop">If set to true, then it will use be the center_crop,or it will crop using the shape of crop_like</param>
//     static member CropNDArray(data : Symbol or Symbol[], [<Optional>] offset : int seq, [<Optional>] hW : int seq, [<Optional; DefaultParameterValue(false)>] centerCrop : bool) =
//         let creator = AtomicSymbolCreator.FromName "Crop"
//         let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
//                                                  Array.empty
//                                                  [|"data"; "num_args"; "offset"; "h_w"; "center_crop"|]
//                                                  [|string data; numArgs (*TODO: this should be the length of the vararg*); (if isNull (offset :> obj) then "[0,0]" else (offset |> Seq.map string |> String.concat ", " |> sprintf "[%s]")); (if isNull (hW :> obj) then "[0,0]" else (hW |> Seq.map string |> String.concat ", " |> sprintf "[%s]")); string centerCrop|]
//         outputs |> Array.map (fun h -> new NDArray(h))
//     /// <summary>
//     /// 
//     /// .. note:: `Crop` is deprecated. Use `slice` instead.
//     /// 
//     /// Crop the 2nd and 3rd dim of input data, with the corresponding size of h_w or
//     /// with width and height of the second input symbol, i.e., with one input, we need h_w to
//     /// specify the crop height and width, otherwise the second input symbol&#39;s size will be used
//     /// 
//     /// 
//     /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\crop.cc:L50</summary>
//     /// <param name = "outputArray">Array of NDArray for outputs</param>
//     /// <param name="data">Tensor or List of Tensors, the second input will be used as crop_like shape reference</param>
//     /// <param name="numArgs">Number of inputs for crop, if equals one, then we will use the h_wfor crop height and width, else if equals two, then we will use the heightand width of the second input symbol, we name crop_like here</param>
//     /// <param name="offset">crop offset coordinate: (y, x)</param>
//     /// <param name="hW">crop height and width: (h, w)</param>
//     /// <param name="centerCrop">If set to true, then it will use be the center_crop,or it will crop using the shape of crop_like</param>
//     static member Crop(outputArray : NDArray seq, data : Symbol or Symbol[], [<Optional>] offset : int seq, [<Optional>] hW : int seq, [<Optional; DefaultParameterValue(false)>] centerCrop : bool) =
//         let creator = AtomicSymbolCreator.FromName "Crop"
//         let names = [|"data"; "num_args"; "offset"; "h_w"; "center_crop"|]
//         let vals = [|string data; numArgs (*TODO: this should be the length of the vararg*); (if isNull (offset :> obj) then "[0,0]" else (offset |> Seq.map string |> String.concat ", " |> sprintf "[%s]")); (if isNull (hW :> obj) then "[0,0]" else (hW |> Seq.map string |> String.concat ", " |> sprintf "[%s]")); string centerCrop|]
//         let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
//         let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
//                                                      Array.empty
//                                                      (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
//                                                      names
//                                                      vals
//         ()
//     /// <summary>
//     /// 
//     /// .. note:: `Crop` is deprecated. Use `slice` instead.
//     /// 
//     /// Crop the 2nd and 3rd dim of input data, with the corresponding size of h_w or
//     /// with width and height of the second input symbol, i.e., with one input, we need h_w to
//     /// specify the crop height and width, otherwise the second input symbol&#39;s size will be used
//     /// 
//     /// 
//     /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\crop.cc:L50</summary>
//     /// <param name="data">Tensor or List of Tensors, the second input will be used as crop_like shape reference</param>
//     /// <param name="offset">crop offset coordinate: (y, x)</param>
//     /// <param name="hW">crop height and width: (h, w)</param>
//     /// <param name="centerCrop">If set to true, then it will use be the center_crop,or it will crop using the shape of crop_like</param>
//     static member Crop(data : Symbol or Symbol[], [<Optional>] ?offset : int seq, [<Optional>] ?hW : int seq, [<Optional>] ?centerCrop : bool) =
//         Crop(data, ?offset = offset, ?hW = hW, ?centerCrop = centerCrop)

//     /// <summary>Stub for implementing an operator implemented in native frontend language.</summary>
//     /// <param name="data">Input data for the custom operator.</param>
//     /// <param name="info"></param>
//     /// <param name="needTopGrad">Whether this layer needs out grad for backward. Should be false for loss layers.</param>
//     static member Native([<ParamArray>] data : NDArray[], info : ptr, [<Optional; DefaultParameterValue(true)>] needTopGrad : bool) =
//         let creator = AtomicSymbolCreator.FromName "_Native"
//         let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
//                                                  (data |> Array.map (fun x -> x.UnsafeHandle))
//                                                  [|"info"; "need_top_grad"|]
//                                                  [|string info; string needTopGrad|]
//         outputs |> Array.map (fun h -> new NDArray(h))
//     /// <summary>Stub for implementing an operator implemented in native frontend language.</summary>
//     /// <param name = "outputArray">Array of NDArray for outputs</param>
//     /// <param name="data">Input data for the custom operator.</param>
//     /// <param name="info"></param>
//     /// <param name="needTopGrad">Whether this layer needs out grad for backward. Should be false for loss layers.</param>
//     static member Native(outputArray : NDArray seq, [<ParamArray>] data : NDArray[], info : ptr, [<Optional; DefaultParameterValue(true)>] needTopGrad : bool) =
//         let creator = AtomicSymbolCreator.FromName "_Native"
//         let names = [|"info"; "need_top_grad"|]
//         let vals = [|string info; string needTopGrad|]
//         let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
//         let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
//                                                      (data |> Array.map (fun x -> x.UnsafeHandle))
//                                                      (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
//                                                      names
//                                                      vals
//         ()
//     /// <summary>Stub for implementing an operator implemented in native frontend language.</summary>
//     /// <param name="data">Input data for the custom operator.</param>
//     /// <param name="info"></param>
//     /// <param name="needTopGrad">Whether this layer needs out grad for backward. Should be false for loss layers.</param>
//     static member Native(data : Symbol seq, info : ptr, [<Optional>] ?needTopGrad : bool) =
//         Native(data, info, ?needTopGrad = needTopGrad)
//     /// <summary>Stub for implementing an operator implemented in native frontend language.</summary>
//     /// <param name="info"></param>
//     /// <param name="data">Input data for the custom operator.</param>
//     /// <param name="needTopGrad">Whether this layer needs out grad for backward. Should be false for loss layers.</param>
//     static member Native(info : ptr, [<Optional>] ?data : Symbol seq, [<Optional>] ?needTopGrad : bool) =
//         Native(info, ?data = data, ?needTopGrad = needTopGrad)

//     /// <summary>Stub for implementing an operator implemented in native frontend language with ndarray.</summary>
//     /// <param name="data">Input data for the custom operator.</param>
//     /// <param name="info"></param>
//     static member NDArray([<ParamArray>] data : NDArray[], info : ptr) =
//         let creator = AtomicSymbolCreator.FromName "_NDArray"
//         let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
//                                                  (data |> Array.map (fun x -> x.UnsafeHandle))
//                                                  [|"info"|]
//                                                  [|string info|]
//         outputs |> Array.map (fun h -> new NDArray(h))
//     /// <summary>Stub for implementing an operator implemented in native frontend language with ndarray.</summary>
//     /// <param name = "outputArray">Array of NDArray for outputs</param>
//     /// <param name="data">Input data for the custom operator.</param>
//     /// <param name="info"></param>
//     static member NDArray(outputArray : NDArray seq, [<ParamArray>] data : NDArray[], info : ptr) =
//         let creator = AtomicSymbolCreator.FromName "_NDArray"
//         let names = [|"info"|]
//         let vals = [|string info|]
//         let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
//         let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
//                                                      (data |> Array.map (fun x -> x.UnsafeHandle))
//                                                      (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
//                                                      names
//                                                      vals
//         ()
//     /// <summary>Stub for implementing an operator implemented in native frontend language with ndarray.</summary>
//     /// <param name="data">Input data for the custom operator.</param>
//     /// <param name="info"></param>
//     static member NDArray(data : Symbol seq, info : ptr) =
//         NDArray(data, info)
//     /// <summary>Stub for implementing an operator implemented in native frontend language with ndarray.</summary>
//     /// <param name="info"></param>
//     /// <param name="data">Input data for the custom operator.</param>
//     static member NDArray(info : ptr, [<Optional>] ?data : Symbol seq) =
//         NDArray(info, ?data = data)
//     /// <summary>Stub for implementing an operator implemented in native frontend language with ndarray.</summary>
//     /// <param name="info"></param>
//     /// <param name="data">Input data for the custom operator.</param>
//     static member NDArray(info : ptr, [<ParamArray>] data : Symbol[]) =
//         NDArray(info, data)

// type PoolType = 
//     | Avg
//     | Max
//     | Sum
//     override x.ToString() =
//         match x with
//             | Avg -> "avg"
//             | Max -> "max"
//             | Sum -> "sum"

// type PoolingConvention = 
//     | Full
//     | Valid
//     override x.ToString() =
//         match x with
//             | Full -> "full"
//             | Valid -> "valid"

//     /// <summary>This operator is DEPRECATED.
//     /// Perform pooling on the input.
//     /// 
//     /// The shapes for 2-D pooling is
//     /// 
//     /// - **data**: *(batch_size, channel, height, width)*
//     /// - **out**: *(batch_size, num_filter, out_height, out_width)*, with::
//     /// 
//     ///     out_height = f(height, kernel[0], pad[0], stride[0])
//     ///     out_width = f(width, kernel[1], pad[1], stride[1])
//     /// 
//     /// The definition of *f* depends on ``pooling_convention``, which has two options:
//     /// 
//     /// - **valid** (default)::
//     /// 
//     ///     f(x, k, p, s) = floor((x+2*p-k)/s)+1
//     /// 
//     /// - **full**, which is compatible with Caffe::
//     /// 
//     ///     f(x, k, p, s) = ceil((x+2*p-k)/s)+1
//     /// 
//     /// But ``global_pool`` is set to be true, then do a global pooling, namely reset
//     /// ``kernel=(height, width)``.
//     /// 
//     /// Three pooling options are supported by ``pool_type``:
//     /// 
//     /// - **avg**: average pooling
//     /// - **max**: max pooling
//     /// - **sum**: sum pooling
//     /// 
//     /// 1-D pooling is special case of 2-D pooling with *weight=1* and
//     /// *kernel[1]=1*.
//     /// 
//     /// For 3-D pooling, an additional *depth* dimension is added before
//     /// *height*. Namely the input data will have shape *(batch_size, channel, depth,
//     /// height, width)*.
//     /// 
//     /// 
//     /// 
//     /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\pooling_v1.cc:L104</summary>
//     /// <param name="data">Input data to the pooling operator.</param>
//     /// <param name="kernel">pooling kernel size: (y, x) or (d, y, x)</param>
//     /// <param name="poolType">Pooling type to be applied.</param>
//     /// <param name="globalPool">Ignore kernel size, do global pooling based on current input feature map. </param>
//     /// <param name="poolingConvention">Pooling convention to be applied.</param>
//     /// <param name="stride">stride: for pooling (y, x) or (d, y, x)</param>
//     /// <param name="pad">pad for pooling: (y, x) or (d, y, x)</param>
//     static member PoolingV1(data : NDArray, 
//                             [<Optional>] kernel : int seq, 
//                             [<Optional>] poolType : PoolType, 
//                             [<Optional; DefaultParameterValue(false)>] globalPool : bool, 
//                             [<Optional>] poolingConvention : PoolingConvention, 
//                             [<Optional>] stride : int seq, 
//                             [<Optional>] pad : int seq) =
//         let creator = AtomicSymbolCreator.FromName "Pooling_v1"
//         let outputs = MXNDArray.imperativeInvoke creator.AtomicSymbolCreatorHandle
//                                                  [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle|]
//                                                  [|"kernel"; "pool_type"; "global_pool"; "pooling_convention"; "stride"; "pad"|]
//                                                  [|(if isNull (kernel :> obj) then "[]" else (kernel |> Seq.map string |> String.concat ", " |> sprintf "[%s]")); (if isNull (poolType :> obj) then "max" else string poolType); string globalPool; (if isNull (poolingConvention :> obj) then "valid" else string poolingConvention); (if isNull (stride :> obj) then "[]" else (stride |> Seq.map string |> String.concat ", " |> sprintf "[%s]")); (if isNull (pad :> obj) then "[]" else (pad |> Seq.map string |> String.concat ", " |> sprintf "[%s]"))|]
//         (new NDArray(outputs.[0]))
//     /// <summary>This operator is DEPRECATED.
//     /// Perform pooling on the input.
//     /// 
//     /// The shapes for 2-D pooling is
//     /// 
//     /// - **data**: *(batch_size, channel, height, width)*
//     /// - **out**: *(batch_size, num_filter, out_height, out_width)*, with::
//     /// 
//     ///     out_height = f(height, kernel[0], pad[0], stride[0])
//     ///     out_width = f(width, kernel[1], pad[1], stride[1])
//     /// 
//     /// The definition of *f* depends on ``pooling_convention``, which has two options:
//     /// 
//     /// - **valid** (default)::
//     /// 
//     ///     f(x, k, p, s) = floor((x+2*p-k)/s)+1
//     /// 
//     /// - **full**, which is compatible with Caffe::
//     /// 
//     ///     f(x, k, p, s) = ceil((x+2*p-k)/s)+1
//     /// 
//     /// But ``global_pool`` is set to be true, then do a global pooling, namely reset
//     /// ``kernel=(height, width)``.
//     /// 
//     /// Three pooling options are supported by ``pool_type``:
//     /// 
//     /// - **avg**: average pooling
//     /// - **max**: max pooling
//     /// - **sum**: sum pooling
//     /// 
//     /// 1-D pooling is special case of 2-D pooling with *weight=1* and
//     /// *kernel[1]=1*.
//     /// 
//     /// For 3-D pooling, an additional *depth* dimension is added before
//     /// *height*. Namely the input data will have shape *(batch_size, channel, depth,
//     /// height, width)*.
//     /// 
//     /// 
//     /// 
//     /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\pooling_v1.cc:L104</summary>
//     /// <param name = "outputArray">Array of NDArray for outputs</param>
//     /// <param name="data">Input data to the pooling operator.</param>
//     /// <param name="kernel">pooling kernel size: (y, x) or (d, y, x)</param>
//     /// <param name="poolType">Pooling type to be applied.</param>
//     /// <param name="globalPool">Ignore kernel size, do global pooling based on current input feature map. </param>
//     /// <param name="poolingConvention">Pooling convention to be applied.</param>
//     /// <param name="stride">stride: for pooling (y, x) or (d, y, x)</param>
//     /// <param name="pad">pad for pooling: (y, x) or (d, y, x)</param>
//     static member PoolingV1(outputArray : NDArray seq, 
//                             data : NDArray, 
//                             [<Optional>] kernel : int seq, 
//                             [<Optional>] poolType : PoolType, 
//                             [<Optional; DefaultParameterValue(false)>] globalPool : bool, 
//                             [<Optional>] poolingConvention : PoolingConvention, 
//                             [<Optional>] stride : int seq, 
//                             [<Optional>] pad : int seq) =
//         let creator = AtomicSymbolCreator.FromName "Pooling_v1"
//         let names = [|"kernel"; "pool_type"; "global_pool"; "pooling_convention"; "stride"; "pad"|]
//         let vals = [|(if isNull (kernel :> obj) then "[]" else (kernel |> Seq.map string |> String.concat ", " |> sprintf "[%s]")); (if isNull (poolType :> obj) then "max" else string poolType); string globalPool; (if isNull (poolingConvention :> obj) then "valid" else string poolingConvention); (if isNull (stride :> obj) then "[]" else (stride |> Seq.map string |> String.concat ", " |> sprintf "[%s]")); (if isNull (pad :> obj) then "[]" else (pad |> Seq.map string |> String.concat ", " |> sprintf "[%s]"))|]
//         let names,vals = (names, vals) ||> Array.zip |> Array.choose (fun (n,v) -> if isNull v then None else Some(n,v)) |> Array.unzip
//         let outputs = MXNDArray.imperativeInvokeInto creator.AtomicSymbolCreatorHandle
//                                                      [|if (not(LanguagePrimitives.PhysicalEquality NDArray.NoArg data)) then data.UnsafeHandle|]
//                                                      (outputArray |> Seq.map (fun x -> x.UnsafeHandle) |> Seq.toArray)
//                                                      names
//                                                      vals
//         ()
//     /// <summary>This operator is DEPRECATED.
//     /// Perform pooling on the input.
//     /// 
//     /// The shapes for 2-D pooling is
//     /// 
//     /// - **data**: *(batch_size, channel, height, width)*
//     /// - **out**: *(batch_size, num_filter, out_height, out_width)*, with::
//     /// 
//     ///     out_height = f(height, kernel[0], pad[0], stride[0])
//     ///     out_width = f(width, kernel[1], pad[1], stride[1])
//     /// 
//     /// The definition of *f* depends on ``pooling_convention``, which has two options:
//     /// 
//     /// - **valid** (default)::
//     /// 
//     ///     f(x, k, p, s) = floor((x+2*p-k)/s)+1
//     /// 
//     /// - **full**, which is compatible with Caffe::
//     /// 
//     ///     f(x, k, p, s) = ceil((x+2*p-k)/s)+1
//     /// 
//     /// But ``global_pool`` is set to be true, then do a global pooling, namely reset
//     /// ``kernel=(height, width)``.
//     /// 
//     /// Three pooling options are supported by ``pool_type``:
//     /// 
//     /// - **avg**: average pooling
//     /// - **max**: max pooling
//     /// - **sum**: sum pooling
//     /// 
//     /// 1-D pooling is special case of 2-D pooling with *weight=1* and
//     /// *kernel[1]=1*.
//     /// 
//     /// For 3-D pooling, an additional *depth* dimension is added before
//     /// *height*. Namely the input data will have shape *(batch_size, channel, depth,
//     /// height, width)*.
//     /// 
//     /// 
//     /// 
//     /// Defined in C:\Jenkins\workspace\mxnet\mxnet\src\operator\pooling_v1.cc:L104</summary>
//     /// <param name="data">Input data to the pooling operator.</param>
//     /// <param name="kernel">pooling kernel size: (y, x) or (d, y, x)</param>
//     /// <param name="poolType">Pooling type to be applied.</param>
//     /// <param name="globalPool">Ignore kernel size, do global pooling based on current input feature map. </param>
//     /// <param name="poolingConvention">Pooling convention to be applied.</param>
//     /// <param name="stride">stride: for pooling (y, x) or (d, y, x)</param>
//     /// <param name="pad">pad for pooling: (y, x) or (d, y, x)</param>
//     static member PoolingV1([<Optional>] ?data : Symbol, [<Optional>] ?kernel : int seq, [<Optional>] ?poolType : PoolType, [<Optional>] ?globalPool : bool, [<Optional>] ?poolingConvention : PoolingConvention, [<Optional>] ?stride : int seq, [<Optional>] ?pad : int seq) =
//         PoolingV1(?data = data, ?kernel = kernel, ?poolType = poolType, ?globalPool = globalPool, ?poolingConvention = poolingConvention, ?stride = stride, ?pad = pad)
